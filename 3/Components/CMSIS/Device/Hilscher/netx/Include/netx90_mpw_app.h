/*
 * Copyright (c) 2009-2018 ARM Limited. All rights reserved.
 * 
 * SPDX-License-Identifier: Apache-2.0
 * 
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @file     netx90_mpw_app.h
 * @brief    CMSIS HeaderFile
 * @version  1.1
 * @date     08. October 2018
 * @note     Generated by SVDConv V3.3.18 on Monday, 08.10.2018 16:21:39
 *           from File 'netx90_mpw_app.svd',
 *           last modified on Monday, 08.10.2018 14:18:28
 */



/** @addtogroup netX_header netX Header
  * @{
  */


/** @addtogroup netx90_mpw_app netX90 engineering sample
 *  @brief Header file derived from netx90_mpw_app.svd
  * @{
  */


#ifndef NETX90_MPW_APP_H
#define NETX90_MPW_APP_H

#ifdef __cplusplus
extern "C" {
#endif


/*lint -save -e18 */

/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M4 Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* =======================================  netx90_mpw_app Specific Interrupt Numbers  ======================================= */
  timer_app0_IRQn           =   1,              /*!< 1  timer_app0                                                             */
  timer_app1_IRQn           =   2,              /*!< 2  timer_app1                                                             */
  timer_app2_IRQn           =   3,              /*!< 3  timer_app2                                                             */
  timer_app_systime_s_IRQn  =   4,              /*!< 4  timer_app_systime_s                                                    */
  wdg_app_IRQn              =   5,              /*!< 5  wdg_app                                                                */
  dmac_app_reg_IRQn         =   6,              /*!< 6  dmac_app_reg                                                           */
  mcp_app_IRQn              =   7,              /*!< 7  mcp_app                                                                */
  uart_app_IRQn             =   8,              /*!< 8  uart_app                                                               */
  i2c_app_IRQn              =   9,              /*!< 9  i2c_app                                                                */
  i2c_xpic_app_IRQn         =  10,              /*!< 10 i2c_xpic_app                                                           */
  ecc_app_1bit_error_IRQn   =  11,              /*!< 11 ecc_app_1bit_error                                                     */
  ecc_app_2bit_error_IRQn   =  12,              /*!< 12 ecc_app_2bit_error                                                     */
  xpic_debug_app_IRQn       =  13,              /*!< 13 xpic_debug_app                                                         */
  wdg_xpic_app_arm_IRQn     =  14,              /*!< 14 wdg_xpic_app_arm                                                       */
  nfifo_arm_app_IRQn        =  15,              /*!< 15 nfifo_arm_app                                                          */
  io_link_irq_xpic_app_IRQn =  16,              /*!< 16 io_link_irq_xpic_app                                                   */
  spi0_app_IRQn             =  17,              /*!< 17 spi0_app                                                               */
  spi1_app_IRQn             =  18,              /*!< 18 spi1_app                                                               */
  spi2_app_IRQn             =  19,              /*!< 19 spi2_app                                                               */
  spi_xpic_app_IRQn         =  20,              /*!< 20 spi_xpic_app                                                           */
  uart_xpic_app_IRQn        =  21,              /*!< 21 uart_xpic_app                                                          */
  bod_IRQn                  =  22,              /*!< 22 bod                                                                    */
  sqi_IRQn                  =  23,              /*!< 23 sqi                                                                    */
  hif_pio_arm_IRQn          =  24,              /*!< 24 hif_pio_arm                                                            */
  eth_IRQn                  =  25,              /*!< 25 eth                                                                    */
  adc0_IRQn                 =  26,              /*!< 26 adc0                                                                   */
  adc1_IRQn                 =  27,              /*!< 27 adc1                                                                   */
  hash_IRQn                 =  28,              /*!< 28 hash                                                                   */
  aes_IRQn                  =  29,              /*!< 29 aes                                                                    */
  mtgy_IRQn                 =  30,              /*!< 30 mtgy                                                                   */
  hif_rdy_to_IRQn           =  31,              /*!< 31 hif_rdy_to                                                             */
  gpio_app0_IRQn            =  32,              /*!< 32 gpio_app0                                                              */
  gpio_app1_IRQn            =  33,              /*!< 33 gpio_app1                                                              */
  gpio_app2_IRQn            =  34,              /*!< 34 gpio_app2                                                              */
  gpio_app3_IRQn            =  35,              /*!< 35 gpio_app3                                                              */
  gpio_app4_IRQn            =  36,              /*!< 36 gpio_app4                                                              */
  gpio_app5_IRQn            =  37,              /*!< 37 gpio_app5                                                              */
  gpio_app6_IRQn            =  38,              /*!< 38 gpio_app6                                                              */
  gpio_app7_IRQn            =  39,              /*!< 39 gpio_app7                                                              */
  gpio_app_timer0_IRQn      =  40,              /*!< 40 gpio_app_timer0                                                        */
  gpio_app_timer1_IRQn      =  41,              /*!< 41 gpio_app_timer1                                                        */
  gpio_app_timer2_IRQn      =  42,              /*!< 42 gpio_app_timer2                                                        */
  trigger_out_edge0_IRQn    =  43,              /*!< 43 trigger_out_edge0                                                      */
  trigger_out_edge1_IRQn    =  44,              /*!< 44 trigger_out_edge1                                                      */
  fpu_arm_app_IRQn          =  47,              /*!< 47 fpu_arm_app                                                            */
  hs_com_host_hsc0_IRQn     =  48,              /*!< 48 hs_com_host_hsc0                                                       */
  hs_com_host_hsc1_IRQn     =  49,              /*!< 49 hs_com_host_hsc1                                                       */
  hs_com_host_hsc2_IRQn     =  50,              /*!< 50 hs_com_host_hsc2                                                       */
  hs_com_host_hsc3_IRQn     =  51,              /*!< 51 hs_com_host_hsc3                                                       */
  hs_com_host_hsc4_IRQn     =  52,              /*!< 52 hs_com_host_hsc4                                                       */
  hs_com_host_hsc5_IRQn     =  53,              /*!< 53 hs_com_host_hsc5                                                       */
  hs_com_host_hsc6_IRQn     =  54,              /*!< 54 hs_com_host_hsc6                                                       */
  hs_com_host_hsc7_IRQn     =  55,              /*!< 55 hs_com_host_hsc7                                                       */
  hs_com_host_hsc8to15_IRQn =  56,              /*!< 56 hs_com_host_hsc8to15                                                   */
  idpm_com_host_IRQn        =  57,              /*!< 57 idpm_com_host                                                          */
  endat_app0_IRQn           =  58,              /*!< 58 endat_app0                                                             */
  endat_app1_IRQn           =  59,              /*!< 59 endat_app1                                                             */
  biss_app0_IRQn            =  60,              /*!< 60 biss_app0                                                              */
  biss_app1_IRQn            =  61,              /*!< 61 biss_app1                                                              */
  can_ctrl0_app_IRQn        =  62,              /*!< 62 can_ctrl0_app                                                          */
  can_ctrl1_app_IRQn        =  63,              /*!< 63 can_ctrl1_app                                                          */
  firewall_IRQn             =  64               /*!< 64 firewall                                                               */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M4 Processor and Core Peripherals  =========================== */
#define __CM4_REV                 0x0001U       /*!< CM4 Core Revision                                                         */
#define __NVIC_PRIO_BITS               4        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __MPU_PRESENT                  1        /*!< MPU present or not                                                        */
#define __FPU_PRESENT                  1        /*!< FPU present or not                                                        */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm4.h"                           /*!< ARM Cortex-M4 processor and core peripherals                              */
#include "system_netx.h"                        /*!< netx90_mpw_app System                                                     */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                          cm4_scs                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief cm4_scs (cm4_scs)
  */

typedef struct {                                /*!< (@ 0xE000E000) cm4_scs Structure                                          */
  __IM  uint32_t  RESERVED[2];
  __IOM uint32_t  cm4_scs_actlr;                /*!< (@ 0x00000008) Auxiliary control register                                 */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  cm4_scs_stcsr;                /*!< (@ 0x00000010) SysTick control and status register                        */
  __IOM uint32_t  cm4_scs_strvr;                /*!< (@ 0x00000014) SysTick Reload Value register                              */
  __IOM uint32_t  cm4_scs_stcvr;                /*!< (@ 0x00000018) SysTick current value register                             */
  __IM  uint32_t  cm4_scs_stcr;                 /*!< (@ 0x0000001C) SysTick calibration value register                         */
  __IM  uint32_t  RESERVED2[56];
  
  union {
    __IOM uint32_t cm4_scs_nvic_iser0;          /*!< (@ 0x00000100) Interrupt set-enable register 0 Enables, or reads
                                                                    the enable state of a group of interrupts.                 */
    
    struct {
      __IOM uint32_t setena     : 32;           /*!< [31..0] For register cm4_scs_nvic_iser[n], enables or shows
                                                     the current enabled state of interrupt (m+(32*n)): 0: On
                                                     reads, interrupt disabled. On writes, no effect. 1: On
                                                     reads, interrupt enabled. On writes, enable interrupt.
                                                     Software can enable multiple interrupts in a single write
                                                     to cm4_scs_nvic_iser[n].                                                  */
    } cm4_scs_nvic_iser0_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_iser1;          /*!< (@ 0x00000104) Interrupt set-enable register 1 Enables, or reads
                                                                    the enable state of a group of interrupts.                 */
    
    struct {
      __IOM uint32_t setena     : 32;           /*!< [31..0] For register cm4_scs_nvic_iser[n], enables or shows
                                                     the current enabled state of interrupt (m+(32*n)): 0: On
                                                     reads, interrupt disabled. On writes, no effect. 1: On
                                                     reads, interrupt enabled. On writes, enable interrupt.
                                                     Software can enable multiple interrupts in a single write
                                                     to cm4_scs_nvic_iser[n].                                                  */
    } cm4_scs_nvic_iser1_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_iser2;          /*!< (@ 0x00000108) Interrupt set-enable register 2 Enables, or reads
                                                                    the enable state of a group of interrupts.                 */
    
    struct {
      __IOM uint32_t setena     : 32;           /*!< [31..0] For register cm4_scs_nvic_iser[n], enables or shows
                                                     the current enabled state of interrupt (m+(32*n)): 0: On
                                                     reads, interrupt disabled. On writes, no effect. 1: On
                                                     reads, interrupt enabled. On writes, enable interrupt.
                                                     Software can enable multiple interrupts in a single write
                                                     to cm4_scs_nvic_iser[n].                                                  */
    } cm4_scs_nvic_iser2_b;
  } ;
  __IM  uint32_t  RESERVED3[29];
  
  union {
    __IOM uint32_t cm4_scs_nvic_icer0;          /*!< (@ 0x00000180) Interrupt clear-enable register 0 Disables, or
                                                                    reads the enable state of a group of interrupts.           */
    
    struct {
      __IOM uint32_t clrena     : 32;           /*!< [31..0] For register cm4_scs_nvic_icer[n], disables or shows
                                                     the current enabled state of interrupt (m+(32*n)): 0: On
                                                     reads, interrupt disabled. On writes, no effect. 1: On
                                                     reads, interrupt enabled. On writes, disable interrupt.
                                                     Software can disable multiple interrupts in a single write
                                                     to cm4_scs_nvic_icer[n].                                                  */
    } cm4_scs_nvic_icer0_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_icer1;          /*!< (@ 0x00000184) Interrupt clear-enable register 1 Disables, or
                                                                    reads the enable state of a group of interrupts.           */
    
    struct {
      __IOM uint32_t clrena     : 32;           /*!< [31..0] For register cm4_scs_nvic_icer[n], disables or shows
                                                     the current enabled state of interrupt (m+(32*n)): 0: On
                                                     reads, interrupt disabled. On writes, no effect. 1: On
                                                     reads, interrupt enabled. On writes, disable interrupt.
                                                     Software can disable multiple interrupts in a single write
                                                     to cm4_scs_nvic_icer[n].                                                  */
    } cm4_scs_nvic_icer1_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_icer2;          /*!< (@ 0x00000188) Interrupt clear-enable register 2 Disables, or
                                                                    reads the enable state of a group of interrupts.           */
    
    struct {
      __IOM uint32_t clrena     : 32;           /*!< [31..0] For register cm4_scs_nvic_icer[n], disables or shows
                                                     the current enabled state of interrupt (m+(32*n)): 0: On
                                                     reads, interrupt disabled. On writes, no effect. 1: On
                                                     reads, interrupt enabled. On writes, disable interrupt.
                                                     Software can disable multiple interrupts in a single write
                                                     to cm4_scs_nvic_icer[n].                                                  */
    } cm4_scs_nvic_icer2_b;
  } ;
  __IM  uint32_t  RESERVED4[29];
  
  union {
    __IOM uint32_t cm4_scs_nvic_ispr0;          /*!< (@ 0x00000200) Interrupt set-pending register 0 For a group
                                                                    of interrupts, changes interrupt status
                                                                    to pending, or shows the current pending
                                                                    status.                                                    */
    
    struct {
      __IOM uint32_t setpend    : 32;           /*!< [31..0] For register cm4_scs_nvic_ispr[n], changes the state
                                                     of interrupt (m+(32*n)) to pending, or shows whether the
                                                     state of the interrupt is pending: 0: On reads, interrupt
                                                     is not pending. On writes, no effect. 1: On reads, interrupt
                                                     is pending. On writes, change state of interrupt to pending.
                                                     Software can set multiple interrupts to pending state in
                                                     a single write to cm4_scs_nvic_ispr[n].                                   */
    } cm4_scs_nvic_ispr0_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ispr1;          /*!< (@ 0x00000204) Interrupt set-pending register 1 For a group
                                                                    of interrupts, changes interrupt status
                                                                    to pending, or shows the current pending
                                                                    status.                                                    */
    
    struct {
      __IOM uint32_t setpend    : 32;           /*!< [31..0] For register cm4_scs_nvic_ispr[n], changes the state
                                                     of interrupt (m+(32*n)) to pending, or shows whether the
                                                     state of the interrupt is pending: 0: On reads, interrupt
                                                     is not pending. On writes, no effect. 1: On reads, interrupt
                                                     is pending. On writes, change state of interrupt to pending.
                                                     Software can set multiple interrupts to pending state in
                                                     a single write to cm4_scs_nvic_ispr[n].                                   */
    } cm4_scs_nvic_ispr1_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ispr2;          /*!< (@ 0x00000208) Interrupt set-pending register 2 For a group
                                                                    of interrupts, changes interrupt status
                                                                    to pending, or shows the current pending
                                                                    status.                                                    */
    
    struct {
      __IOM uint32_t setpend    : 32;           /*!< [31..0] For register cm4_scs_nvic_ispr[n], changes the state
                                                     of interrupt (m+(32*n)) to pending, or shows whether the
                                                     state of the interrupt is pending: 0: On reads, interrupt
                                                     is not pending. On writes, no effect. 1: On reads, interrupt
                                                     is pending. On writes, change state of interrupt to pending.
                                                     Software can set multiple interrupts to pending state in
                                                     a single write to cm4_scs_nvic_ispr[n].                                   */
    } cm4_scs_nvic_ispr2_b;
  } ;
  __IM  uint32_t  RESERVED5[29];
  
  union {
    __IOM uint32_t cm4_scs_nvic_icpr0;          /*!< (@ 0x00000280) Interrupt clear-pending register 0 For a group
                                                                    of interrupts, clears the interrupt pending
                                                                    status, or shows the current pending status.               */
    
    struct {
      __IOM uint32_t clrpend    : 32;           /*!< [31..0] For register cm4_scs_nvic_ispr[n], clears the pending
                                                     state of interrupt (m+(32*n)), or shows whether the state
                                                     of the interrupt is pending: 0: On reads, interrupt is
                                                     not pending. On writes, no effect. 1: On reads, interrupt
                                                     is pending. On writes, clears the pending state of interrupt.
                                                     Software can clear the pending state of multiple interrupts
                                                     in a single write to cm4_scs_nvic_icpr[n].                                */
    } cm4_scs_nvic_icpr0_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_icpr1;          /*!< (@ 0x00000284) Interrupt clear-pending register 1 For a group
                                                                    of interrupts, clears the interrupt pending
                                                                    status, or shows the current pending status.               */
    
    struct {
      __IOM uint32_t clrpend    : 32;           /*!< [31..0] For register cm4_scs_nvic_ispr[n], clears the pending
                                                     state of interrupt (m+(32*n)), or shows whether the state
                                                     of the interrupt is pending: 0: On reads, interrupt is
                                                     not pending. On writes, no effect. 1: On reads, interrupt
                                                     is pending. On writes, clears the pending state of interrupt.
                                                     Software can clear the pending state of multiple interrupts
                                                     in a single write to cm4_scs_nvic_icpr[n].                                */
    } cm4_scs_nvic_icpr1_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_icpr2;          /*!< (@ 0x00000288) Interrupt clear-pending register 2 For a group
                                                                    of interrupts, clears the interrupt pending
                                                                    status, or shows the current pending status.               */
    
    struct {
      __IOM uint32_t clrpend    : 32;           /*!< [31..0] For register cm4_scs_nvic_ispr[n], clears the pending
                                                     state of interrupt (m+(32*n)), or shows whether the state
                                                     of the interrupt is pending: 0: On reads, interrupt is
                                                     not pending. On writes, no effect. 1: On reads, interrupt
                                                     is pending. On writes, clears the pending state of interrupt.
                                                     Software can clear the pending state of multiple interrupts
                                                     in a single write to cm4_scs_nvic_icpr[n].                                */
    } cm4_scs_nvic_icpr2_b;
  } ;
  __IM  uint32_t  RESERVED6[29];
  
  union {
    __IM  uint32_t cm4_scs_nvic_iabr0;          /*!< (@ 0x00000300) Interrupt active bit register 0 For a group of
                                                                    32 interrupts, shows whether each interrupt
                                                                    is active.                                                 */
    
    struct {
      __IM  uint32_t active     : 32;           /*!< [31..0] For register cm4_scs_nvic_iabr[n], shows whether interrupt
                                                     (m+(32*n)) is active.                                                     */
    } cm4_scs_nvic_iabr0_b;
  } ;
  
  union {
    __IM  uint32_t cm4_scs_nvic_iabr1;          /*!< (@ 0x00000304) Interrupt active bit register 1 For a group of
                                                                    32 interrupts, shows whether each interrupt
                                                                    is active.                                                 */
    
    struct {
      __IM  uint32_t active     : 32;           /*!< [31..0] For register cm4_scs_nvic_iabr[n], shows whether interrupt
                                                     (m+(32*n)) is active.                                                     */
    } cm4_scs_nvic_iabr1_b;
  } ;
  
  union {
    __IM  uint32_t cm4_scs_nvic_iabr2;          /*!< (@ 0x00000308) Interrupt active bit register 2 For a group of
                                                                    32 interrupts, shows whether each interrupt
                                                                    is active.                                                 */
    
    struct {
      __IM  uint32_t active     : 32;           /*!< [31..0] For register cm4_scs_nvic_iabr[n], shows whether interrupt
                                                     (m+(32*n)) is active.                                                     */
    } cm4_scs_nvic_iabr2_b;
  } ;
  __IM  uint32_t  RESERVED7[61];
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr0;           /*!< (@ 0x00000400) Interrupt priority register 0 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr0_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr1;           /*!< (@ 0x00000404) Interrupt priority register 1 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr1_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr2;           /*!< (@ 0x00000408) Interrupt priority register 2 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr2_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr3;           /*!< (@ 0x0000040C) Interrupt priority register 3 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr3_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr4;           /*!< (@ 0x00000410) Interrupt priority register 4 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr4_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr5;           /*!< (@ 0x00000414) Interrupt priority register 5 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr5_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr6;           /*!< (@ 0x00000418) Interrupt priority register 6 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr6_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr7;           /*!< (@ 0x0000041C) Interrupt priority register 7 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr7_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr8;           /*!< (@ 0x00000420) Interrupt priority register 8 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr8_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr9;           /*!< (@ 0x00000424) Interrupt priority register 9 Sets or reads interrupt
                                                                    priorities.                                                */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr9_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr10;          /*!< (@ 0x00000428) Interrupt priority register 10 Sets or reads
                                                                    interrupt priorities.                                      */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr10_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr11;          /*!< (@ 0x0000042C) Interrupt priority register 11 Sets or reads
                                                                    interrupt priorities.                                      */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr11_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr12;          /*!< (@ 0x00000430) Interrupt priority register 12 Sets or reads
                                                                    interrupt priorities.                                      */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr12_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr13;          /*!< (@ 0x00000434) Interrupt priority register 13 Sets or reads
                                                                    interrupt priorities.                                      */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr13_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr14;          /*!< (@ 0x00000438) Interrupt priority register 14 Sets or reads
                                                                    interrupt priorities.                                      */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr14_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr15;          /*!< (@ 0x0000043C) Interrupt priority register 15 Sets or reads
                                                                    interrupt priorities.                                      */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr15_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_nvic_ipr16;          /*!< (@ 0x00000440) Interrupt priority register 16 Sets or reads
                                                                    interrupt priorities.                                      */
    
    struct {
      __IOM uint32_t pri_n0     : 8;            /*!< [7..0] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n.                                                                */
      __IOM uint32_t pri_n1     : 8;            /*!< [15..8] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+1.                                                              */
      __IOM uint32_t pri_n2     : 8;            /*!< [23..16] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+2.                                                              */
      __IOM uint32_t pri_n3     : 8;            /*!< [31..24] For register cm4_scs_nvic_ipr[n], priority of interrupt
                                                     number 4n+3.                                                              */
    } cm4_scs_nvic_ipr16_b;
  } ;
  __IM  uint32_t  RESERVED8[559];
  __IM  uint32_t  cm4_scs_cpuid;                /*!< (@ 0x00000D00) CPUID base register                                        */
  __IOM uint32_t  cm4_scs_icsr;                 /*!< (@ 0x00000D04) Interrupt control and state register                       */
  
  union {
    __IOM uint32_t cm4_scs_vtor;                /*!< (@ 0x00000D08) Vector table offset register Holds the vector
                                                                    table address.                                             */
    
    struct {
      __IOM uint32_t reserved0  : 7;            /*!< [6..0] reserved                                                           */
      __IOM uint32_t tbloff     : 25;           /*!< [31..7] Bits[31:7] of the vector table address.                           */
    } cm4_scs_vtor_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_aircr;               /*!< (@ 0x00000D0C) Application interrupt and reset control reister
                                                                    Sets or returns interrupt control data.                    */
    
    struct {
      __IOM uint32_t vectreset  : 1;            /*!< [0..0] Writing 1 to this bit causes a local system reset. This
                                                     bit self-clears. The effect of writing a 1 to this bit
                                                     if the processor is not halted in Debug state is UNPREDICTABLE.
                                                     When the processor is halted in Debug state, if a write
                                                     to the register writes a 1 to both VECTRESET and SYSRESETREQ,
                                                     the behavior is UNPREDICTABLE. This bit is write only.
                                                     Note: The netx90 doesn't support a local system reset.
                                                     Writing 1 results in UNPREDICTABLE behaviour of the whole
                                                     system! Use sysresetreq instead!                                          */
      __IOM uint32_t vectclractive : 1;         /*!< [1..1] Writing 1 to this bit clears all active state information
                                                     for fixed and configurable exceptions. This includes clearing
                                                     the IPSR to zero. The effect of writing a 1 to this bit
                                                     if the processor is not halted in Debug state is UNPREDICTABLE.
                                                     This bit is write only.                                                   */
      __IOM uint32_t sysresetreq : 1;           /*!< [2..2] System Reset Request. Writing 1 to this bit asserts a
                                                     signal to the external system to request a Local reset.
                                                     A Local or Power-on reset clears this bit to 0.                           */
      __IOM uint32_t reserved0  : 5;            /*!< [7..3] reserved                                                           */
      __IOM uint32_t prigroup   : 3;            /*!< [10..8] Priority grouping, indicates the binary point position.           */
      __IOM uint32_t reserved1  : 4;            /*!< [14..11] reserved                                                         */
      __IOM uint32_t endianness : 1;            /*!< [15..15] Indicates the memory system endianness: 0 - Little
                                                     endian, 1 - Big endian. This bit is static or configured
                                                     by a hardware input on reset. This bit is read only.                      */
      __IOM uint32_t vectkey    : 16;           /*!< [31..16] Vector Key. Register writes must write 0x05FA to this
                                                     field, otherwise the write is ignored. On reads, returns
                                                     0xFA05.                                                                   */
    } cm4_scs_aircr_b;
  } ;
  __IOM uint32_t  cm4_scs_scr;                  /*!< (@ 0x00000D10) System control Register                                    */
  __IOM uint32_t  cm4_scs_ccr;                  /*!< (@ 0x00000D14) Configuration and control Register                         */
  __IOM uint32_t  cm4_scs_shpr1;                /*!< (@ 0x00000D18) System Handler Priority Register 1                         */
  __IOM uint32_t  cm4_scs_shpr2;                /*!< (@ 0x00000D1C) System Handler Priority Register 2                         */
  __IOM uint32_t  cm4_scs_shpr3;                /*!< (@ 0x00000D20) System Handler Priority Register 3                         */
  __IOM uint32_t  cm4_scs_shcsr;                /*!< (@ 0x00000D24) System Handler Control and State Register                  */
  
  union {
    __IOM uint32_t cm4_scs_cfsr;                /*!< (@ 0x00000D28) Configurable Fault Status Register Contains the
                                                                    three Configurable Fault Status Registers.                 */
    
    struct {
      __IOM uint32_t mmfsr_iaccviol : 1;        /*!< [0..0] MPU or Execute Never (XN) default memory map access violation
                                                     on an instruction fetch has occurred. The fault is signalled
                                                     only if the instruction is issued.                                        */
      __IOM uint32_t mmfsr_daccviol : 1;        /*!< [1..1] Data access violation. The MMFAR shows the data address
                                                     that the load or store tried to access.                                   */
      __IOM uint32_t reserved0  : 1;            /*!< [2..2] reserved                                                           */
      __IOM uint32_t mmfsr_munstkerr : 1;       /*!< [3..3] A derived MemManage fault occurred on exception return.            */
      __IOM uint32_t mmfsr_mstkerr : 1;         /*!< [4..4] A derived MemManage fault occurred on exception entry.             */
      __IOM uint32_t mmfsr_lsperr : 1;          /*!< [5..5] A MemManage fault occurred during FP lazy state preservation.      */
      __IOM uint32_t reserved1  : 1;            /*!< [6..6] reserved                                                           */
      __IOM uint32_t mmfsr_mmarvalid : 1;       /*!< [7..7] MMFAR has valid contents.                                          */
      __IOM uint32_t bfsr_ibuserr : 1;          /*!< [8..8] A bus fault on an instruction prefetch has occurred.
                                                     The fault is signaled only if the instruction is issued.                  */
      __IOM uint32_t bfsr_preciserr : 1;        /*!< [9..9] A precise data access error has occurred, and the processor
                                                     has written the faulting address to the BFAR.                             */
      __IOM uint32_t bfsr_impreciserr : 1;      /*!< [10..10] Imprecise data access error has occurred.                        */
      __IOM uint32_t bfsr_unstkerr : 1;         /*!< [11..11] A derived bus fault has occurred on exception return.            */
      __IOM uint32_t bfsr_stkerr : 1;           /*!< [12..12] A derived bus fault has occurred on exception entry.             */
      __IOM uint32_t bfsr_lsperr : 1;           /*!< [13..13] A bus fault occurred during FP lazy state preservation.          */
      __IOM uint32_t reserved2  : 1;            /*!< [14..14] reserved                                                         */
      __IOM uint32_t bfsr_bfarvalid : 1;        /*!< [15..15] BFAR has valid contents.                                         */
      __IOM uint32_t ufsr_undefinstr : 1;       /*!< [16..16] The processor has attempted to execute an undefined
                                                     instruction. This might be an undefined instruction associated
                                                     with an enabled coprocessor.                                              */
      __IOM uint32_t ufsr_invstate : 1;         /*!< [17..17] Instruction executed with invalid EPSR.T or EPSR.IT
                                                     field.                                                                    */
      __IOM uint32_t ufsr_invpc : 1;            /*!< [18..18] An integrity check error has occurred on EXC_RETURN.             */
      __IOM uint32_t ufsr_nocp  : 1;            /*!< [19..19] A coprocessor access error has occurred. This shows
                                                     that the coprocessor is disabled or not present.                          */
      __IOM uint32_t reserved3  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t ufsr_unaligned : 1;        /*!< [24..24] Unaligned access error has occurred. Multi-word accesses
                                                     always fault if not word aligned. Software can configure
                                                     unaligned word and halfword accesses to fault, by enabling
                                                     UNALIGN_TRP in the CCR.                                                   */
      __IOM uint32_t ufsr_divbyzero : 1;        /*!< [25..25] Divide by zero error has occurred.                               */
      __IOM uint32_t reserved4  : 6;            /*!< [31..26] reserved                                                         */
    } cm4_scs_cfsr_b;
  } ;
  __IOM uint32_t  cm4_scs_hfsr;                 /*!< (@ 0x00000D2C) HardFault Status Register                                  */
  
  union {
    __IOM uint32_t cm4_scs_dfsr;                /*!< (@ 0x00000D30) Debug fault status Register Shows which debug
                                                                    event occurred. Note: Writing 1 to a register
                                                                    bit clears the bit to 0.                                   */
    
    struct {
      __IOM uint32_t halted     : 1;            /*!< [0..0] Indicates a debug event generated by either: - A C_HALT
                                                     or C_STEP request, triggered by a write to the DHCSR. -
                                                     A step request triggered by setting DEMCR.MON_STEP to 1.                  */
      __IOM uint32_t bkpt       : 1;            /*!< [1..1] Indicates a debug event generated by BKPT instruction
                                                     execution or a breakpoint match in FPB.                                   */
      __IOM uint32_t dwttrap    : 1;            /*!< [2..2] Indicates a debug event generated by the DWT.                      */
      __IOM uint32_t vcatch     : 1;            /*!< [3..3] Indicates triggering of a Vector catch.                            */
      __IOM uint32_t external   : 1;            /*!< [4..4] Indicates a debug event generated because of the assertion
                                                     of an external debug request.                                             */
    } cm4_scs_dfsr_b;
  } ;
  __IOM uint32_t  cm4_scs_mmfar;                /*!< (@ 0x00000D34) MemManage Faul Address Register                            */
  __IOM uint32_t  cm4_scs_bfar;                 /*!< (@ 0x00000D38) BusFault Address Register                                  */
  __IOM uint32_t  cm4_scs_afsr;                 /*!< (@ 0x00000D3C) Auxiliary Fault Status Register                            */
  __IM  uint32_t  RESERVED9[18];
  __IOM uint32_t  cm4_scs_cpacr;                /*!< (@ 0x00000D88) Coprocessor Access Control Register                        */
  __IM  uint32_t  RESERVED10[25];
  
  union {
    __IOM uint32_t cm4_scs_dhcsr;               /*!< (@ 0x00000DF0) Debug halting control and status register Controls
                                                                    halting debug. Note: On writes bits 31-16
                                                                    (dbgkey) must be set to 0xA05F.                            */
    
    struct {
      __IOM uint32_t c_debugen  : 1;            /*!< [0..0] Halting debug enable bit. If a debugger writes to DHCSR
                                                     to change the value of this bit from 0 to 1, it must also
                                                     write 0 to the C_MASKINTS bit, otherwise behavior is UNPREDICTABLE.
                                                     This bit can only be written by the DAP, it ignores writes
                                                     from software.                                                            */
      __IOM uint32_t c_halt     : 1;            /*!< [1..1] Processor halt bit. The effects of writes to this bit
                                                     are: - 0: Causes the processor to leave Debug state, if
                                                     in Debug state. - 1: Halt the processor. This bit is UNKNOWN
                                                     after a Power-on reset, and is 0 after a Local reset.                     */
      __IOM uint32_t c_step     : 1;            /*!< [2..2] Processor step bit. The effects of writes to this bit
                                                     are: - 0: No effect. - 1: Single step enabled. This bit
                                                     is UNKNOWN after a Power-on reset.                                        */
      __IOM uint32_t c_maskints : 1;            /*!< [3..3] When debug is enabled, the debugger can write to this
                                                     bit to mask PendSV, SysTick and external configurable interrupts:
                                                     - 0: Do not mask. - 1: Mask PendSV, SysTick and external
                                                     configurable interrupts. The effect of any attempt to change
                                                     the value of this bit is UNPREDICTABLE unless both: - Before
                                                     the write to DHCSR, the value of the C_HALT bit is 1. -
                                                     The write to the DHCSR that changes the C_MASKINTS bit
                                                     also writes 1 to the C_HALT bit. This means that a single
                                                     write to DHCSR cannot set the C_HALT to 0                                 */
      __IOM uint32_t reserved0  : 1;            /*!< [4..4] reserved                                                           */
      __IOM uint32_t c_snapstall : 1;           /*!< [5..5] Allow imprecise entry to Debug state. The actions on
                                                     writing to this bit are: - 0: No action. - 1: Allow imprecise
                                                     entry to Debug state, for example by forcing any stalled
                                                     load or store instruction to complete. Setting this bit
                                                     to 1 allows a debugger to request imprecise entry to Debug
                                                     state. The effect of setting this bit to 1 is UNPREDICTABLE
                                                     unless the DHCSR write also sets C_DEBUGEN and C_HALT to
                                                     1. This means that if the processor is not already in Debug
                                                     stateit enters Debug state when the stalled                               */
      __IOM uint32_t reserved1  : 10;           /*!< [15..6] reserved                                                          */
      __IOM uint32_t s_regrdy   : 1;            /*!< [16..16] A handshake flag for transfers through the DCRDR: -
                                                     Writing to DCRSR clears the bit to 0. - Completion of the
                                                     DCRDR transfer then sets the bit to 1. For more information
                                                     about DCRDR transfers see Debug Core Register Data Register,
                                                     DCRDR. This bit is valid only when the processor is in
                                                     Debug state, otherwise the bit is UNKNOWN. This bit is
                                                     read-only.                                                                */
      __IOM uint32_t s_halt     : 1;            /*!< [17..17] Indicates whether the processor is in Debug state.
                                                     This bit is read-only.                                                    */
      __IOM uint32_t s_sleep    : 1;            /*!< [18..18] Indicates whether the processor is sleeping. The debugger
                                                     must set the C_HALT bit to 1 to gain control, or wait for
                                                     an interrupt or other wakeup event to wakeup the system.
                                                     This bit is read-only.                                                    */
      __IOM uint32_t s_lockup   : 1;            /*!< [19..19] Indicates whether the processor is locked up because
                                                     of an unrecoverable exception. This bit can only be read
                                                     as 1 by a remote debugger, using the DAP. The value of
                                                     1 indicates that the processor is running but locked up.
                                                     The bit clears to 0 when the processor enters Debug state.
                                                     This bit is read-only.                                                    */
      __IOM uint32_t reserved2  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t s_retire_st : 1;           /*!< [24..24] Set to 1 every time the processor retires one or more
                                                     instructions. This is a sticky bit, that clears to 0 on
                                                     a read of DHCSR. The architecture does not define precisely
                                                     when this bit is set to 1. It requires only that this happen
                                                     periodically in Non-debug state to indicate that software
                                                     execution is progressing. This bit is UNKNOWN after a Power-on
                                                     or Local reset, but then is set to 1 as soon as the processor
                                                     executes and retires an instruction. This bit is read-only.               */
      __IOM uint32_t s_reset_st : 1;            /*!< [25..25] Indicates whether the processor has been reset since
                                                     the last read of DHCSR. This is a sticky bit, that clears
                                                     to 0 on a read of DHCSR. This bit is read-only.                           */
      __IOM uint32_t reserved3  : 6;            /*!< [31..26] reserved                                                         */
    } cm4_scs_dhcsr_b;
  } ;
  
  union {
    __OM  uint32_t cm4_scs_dcrsr;               /*!< (@ 0x00000DF4) Debug core register selector register With the
                                                                    DCRDR, the DCRSR provides debug access to
                                                                    the ARM core registers, special-purpose
                                                                    registers, and Floating-point extension
                                                                    registers. A write to DCRSR specifies the
                                                                    register to transfer, whether the transfer
                                                                    is a read or a write, and starts the transfer.             */
    
    struct {
      __OM  uint32_t regsel     : 7;            /*!< [6..0] Specifies the ARM core register, special-purpose register,
                                                     or Floating-point extension register, to transfer: { |
                                                     0 - 12 ARM core registers R0-R12. 13 The current SP. See
                                                     also values 17 (MSP) and 18 (PSP). 14 LR. 15 DebugReturnAddress.
                                                     16 xPSR. 17 Main stack pointer, MSP. 18 Process stack pointer,
                                                     PSP. 20 Bits[31:24]: CONTROL, Bits[23:16]: FAULTMASK, Bits[15:8]:
                                                     BASEPRI, Bits[7:0]: PRIMASK. In each field, the valid bits
                                                     are packed with leading zeros. For example, FAULTMAS                      */
      __OM  uint32_t reserved0  : 9;            /*!< [15..7] reserved                                                          */
      __OM  uint32_t regwnr     : 1;            /*!< [16..16] Specifies the access type for the transfer: 0 : Read.
                                                     1 : Write.                                                                */
      __OM  uint32_t reserved1  : 15;           /*!< [31..17] reserved                                                         */
    } cm4_scs_dcrsr_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_dcrdr;               /*!< (@ 0x00000DF8) Debug core register data register With the DCRSR,
                                                                    the DCRDR provides debug access to the ARM
                                                                    core registers, special-purpose registers,
                                                                    and Floating-point extension registers.
                                                                    The DCRDR is the data register for these
                                                                    accesses. Used on its own, the DCRDR provides
                                                                    a message passing resource between an external
                                                                    debugger and a debug agent running on the
                                                                    processor. Note: The architecture does not
                                                                    define any handshaking mechanism for this
                                                                    use of DCRDR.                                              */
    
    struct {
      __IOM uint32_t dbgtmp     : 32;           /*!< [31..0] Data temporary cache, for reading and writing the ARM
                                                     core registers, special-purpose registers, and Floating-point
                                                     extension registers.                                                      */
    } cm4_scs_dcrdr_b;
  } ;
  
  union {
    __IOM uint32_t cm4_scs_demcr;               /*!< (@ 0x00000DFC) Debug exception and monitor control register
                                                                    Manages vector catch behavior and DebugMonitor
                                                                    handling when debugging.                                   */
    
    struct {
      __IOM uint32_t vc_corereset : 1;          /*!< [0..0] Enable Reset Vector Catch. This causes a Local reset
                                                     to halt a running system. If DHCSR.C_DEBUGEN is set to
                                                     0, the processor ignores the value of this bit.                           */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t vc_mmerr   : 1;            /*!< [4..4] Enable halting debug trap on a MemManage exception. If
                                                     DHCSR.C_DEBUGEN is set to 0, the processor ignores the
                                                     value of this bit.                                                        */
      __IOM uint32_t vc_nocperr : 1;            /*!< [5..5] Enable halting debug trap on a UsageFault caused by an
                                                     access to a Coprocessor. If DHCSR.C_DEBUGEN is set to 0,
                                                     the processor ignores the value of this bit.                              */
      __IOM uint32_t vc_chkerr  : 1;            /*!< [6..6] Enable halting debug trap on a UsageFault exception caused
                                                     by a checking error, for example an alignment check error.
                                                     If DHCSR.C_DEBUGEN is set to 0, the processor ignores the
                                                     value of this bit.                                                        */
      __IOM uint32_t vc_staterr : 1;            /*!< [7..7] Enable halting debug trap on a UsageFault exception caused
                                                     by a state information error, for example an Undefined
                                                     Instruction exception. If DHCSR.C_DEBUGEN is set to 0,
                                                     the processor ignores the value of this bit.                              */
      __IOM uint32_t vc_buserr  : 1;            /*!< [8..8] Enable halting debug trap on a BusFault exception. If
                                                     DHCSR.C_DEBUGEN is set to 0, the processor ignores the
                                                     value of this bit.                                                        */
      __IOM uint32_t vc_interr  : 1;            /*!< [9..9] Enable halting debug trap on a fault occurring during
                                                     exception entry or exception return. If DHCSR.C_DEBUGEN
                                                     is set to 0, the processor ignores the value of this bit.                 */
      __IOM uint32_t vc_harderr : 1;            /*!< [10..10] Enable halting debug trap on a HardFault exception.
                                                     If DHCSR.C_DEBUGEN is set to 0, the processor ignores the
                                                     value of this bit.                                                        */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t mon_en     : 1;            /*!< [16..16] Enable the DebugMonitor exception. If DHCSR.C_DEBUGEN
                                                     is set to 1, the processor ignores the value of this bit.                 */
      __IOM uint32_t mon_pend   : 1;            /*!< [17..17] Sets or clears the pending state of the DebugMonitor
                                                     exception: - 0: Clear the status of the DebugMonitor exception
                                                     to not pending. - 1: Set the status of the DebugMonitor
                                                     exception to pending. When the DebugMonitor exception is
                                                     pending it becomes active subject to the exception priority
                                                     rules. A debugger can use this bit to wakeup the monitor
                                                     using the DAP. The effect of setting this bit to 1 is not
                                                     affected by the value of the MON_EN bit. A debugger can
                                                     set MON_PEND to 1, and force the processor to tak                         */
      __IOM uint32_t mon_step   : 1;            /*!< [18..18] When MON_EN is set to 0, this feature is disabled and
                                                     the processor ignores MON_STEP. When MON_EN is set to 1,
                                                     the meaning of MON_STEP is: - 0: Do not step the processor.
                                                     - 1: Step the processor. Setting this bit to 1 makes the
                                                     step request pending. The effect of changing this bit at
                                                     an execution priority that is lower than the priority of
                                                     the DebugMonitor exception is UNPREDICTABLE.                              */
      __IOM uint32_t mon_req    : 1;            /*!< [19..19] DebugMonitor semaphore bit. The processor does not
                                                     use this bit. The monitor software defines the meaning
                                                     and use of this bit.                                                      */
      __IOM uint32_t reserved2  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t trcena     : 1;            /*!< [24..24] Global enable for all DWT and ITM features: - 0: DWT
                                                     and ITM units disabled. - 1: DWT and ITM units enabled.
                                                     If the DWT and ITM units are not implemented, this bit
                                                     is UNK/SBZP. When TRCENA is set to 0: - DWT registers return
                                                     UNKNOWN values on reads. Whether the processor ignores
                                                     writes to the DWT unit is IMPLEMENTATION DEFINED. - ITM
                                                     registers return UNKNOWN values on reads. Whether the processor
                                                     ignores writes to the ITM unit is IMPLEMENTATION DEFINED.
                                                     Setting this bit to 0 might not stop all events. To                       */
      __IOM uint32_t reserved3  : 7;            /*!< [31..25] reserved                                                         */
    } cm4_scs_demcr_b;
  } ;
  __IM  uint32_t  RESERVED11[116];
  __IM  uint32_t  cm4_scs_pidr4;                /*!< (@ 0x00000FD0) Peripheral ID Register 4                                   */
  __IM  uint32_t  RESERVED12[3];
  __IM  uint32_t  cm4_scs_pidr0;                /*!< (@ 0x00000FE0) Peripheral ID Register 0                                   */
  __IM  uint32_t  cm4_scs_pidr1;                /*!< (@ 0x00000FE4) Peripheral ID Register 1                                   */
  __IM  uint32_t  cm4_scs_pidr2;                /*!< (@ 0x00000FE8) Peripheral ID Register 2                                   */
  __IM  uint32_t  cm4_scs_pidr3;                /*!< (@ 0x00000FEC) Peripheral ID Register 3                                   */
  
  union {
    __IM  uint32_t cm4_scs_cidr0;               /*!< (@ 0x00000FF0) Component ID Register 0                                    */
    
    struct {
      __IM  uint32_t prmbl_0    : 8;            /*!< [7..0] Preamble byte 0.                                                   */
    } cm4_scs_cidr0_b;
  } ;
  
  union {
    __IM  uint32_t cm4_scs_cidr1;               /*!< (@ 0x00000FF4) Component ID Register 1                                    */
    
    struct {
      __IM  uint32_t prmbl_1    : 4;            /*!< [3..0] Preamble bits[11:8].                                               */
      __IM  uint32_t cclass     : 4;            /*!< [7..4] Component class.                                                   */
    } cm4_scs_cidr1_b;
  } ;
  
  union {
    __IM  uint32_t cm4_scs_cidr2;               /*!< (@ 0x00000FF8) Component ID Register 2                                    */
    
    struct {
      __IM  uint32_t prmbl_2    : 8;            /*!< [7..0] Preamble byte 2.                                                   */
    } cm4_scs_cidr2_b;
  } ;
  
  union {
    __IM  uint32_t cm4_scs_cidr3;               /*!< (@ 0x00000FFC) Component ID Register 3                                    */
    
    struct {
      __IM  uint32_t prmbl_3    : 8;            /*!< [7..0] Preamble byte 3.                                                   */
    } cm4_scs_cidr3_b;
  } ;
} cm4_scs_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                       cm4_misc_ctrl                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief cm4_misc_ctrl (cm4_misc_ctrl)
  */

typedef struct {                                /*!< (@ 0xE0043000) cm4_misc_ctrl Structure                                    */
  
  union {
    __IM  uint32_t cm4_misc_ctrl_cpu_info;      /*!< (@ 0x00000000) CPU information register Provides a processor
                                                                    identification mechanism to distinguish
                                                                    between Com ARM and App ARM.                               */
    
    struct {
      __IM  uint32_t id         : 1;            /*!< [0..0] CPU identification 0: Com ARM 1: App ARM                           */
      __IM  uint32_t fpu        : 1;            /*!< [1..1] CPU has FPU If '0' all cm4_misc_ctrl_fpu_* registers
                                                     have no effect and are read as zero.                                      */
    } cm4_misc_ctrl_cpu_info_b;
  } ;
  
  union {
    __IOM uint32_t cm4_misc_ctrl_fpu_irq_raw;   /*!< (@ 0x00000004) FPU raw IRQ Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit. Note: Before clearing an IRQ in this
                                                                    register, the corresponding exception status
                                                                    must be cleared within the FPU. Otherwise
                                                                    the IRQ will be re-asserted immediately.                   */
    
    struct {
      __IOM uint32_t ixc        : 1;            /*!< [0..0] Inexact (IEEE 754-2008 defined exception).                         */
      __IOM uint32_t ufc        : 1;            /*!< [1..1] Underflow (IEEE 754-2008 defined exception).                       */
      __IOM uint32_t ofc        : 1;            /*!< [2..2] Overflow (IEEE 754-2008 defined exception).                        */
      __IOM uint32_t dzc        : 1;            /*!< [3..3] Division by zero (IEEE 754-2008 defined exception).                */
      __IOM uint32_t ioc        : 1;            /*!< [4..4] Invalid operation (IEEE 754-2008 defined exception).               */
      __IOM uint32_t idc        : 1;            /*!< [5..5] Input denormal (ARM-specific exception).                           */
    } cm4_misc_ctrl_fpu_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t cm4_misc_ctrl_fpu_irq_masked;/*!< (@ 0x00000008) FPU masked IRQ Shows status of masked IRQs.                */
    
    struct {
      __IM  uint32_t ixc        : 1;            /*!< [0..0] Inexact (IEEE 754-2008 defined exception).                         */
      __IM  uint32_t ufc        : 1;            /*!< [1..1] Underflow (IEEE 754-2008 defined exception).                       */
      __IM  uint32_t ofc        : 1;            /*!< [2..2] Overflow (IEEE 754-2008 defined exception).                        */
      __IM  uint32_t dzc        : 1;            /*!< [3..3] Division by zero (IEEE 754-2008 defined exception).                */
      __IM  uint32_t ioc        : 1;            /*!< [4..4] Invalid operation (IEEE 754-2008 defined exception).               */
      __IM  uint32_t idc        : 1;            /*!< [5..5] Input denormal (ARM-specific exception).                           */
    } cm4_misc_ctrl_fpu_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t cm4_misc_ctrl_fpu_irq_msk_set;/*!< (@ 0x0000000C) FPU IRQ mask set The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to cm4_misc_ctrl_fpu_irq_r       */
    
    struct {
      __IOM uint32_t ixc        : 1;            /*!< [0..0] Inexact (IEEE 754-2008 defined exception).                         */
      __IOM uint32_t ufc        : 1;            /*!< [1..1] Underflow (IEEE 754-2008 defined exception).                       */
      __IOM uint32_t ofc        : 1;            /*!< [2..2] Overflow (IEEE 754-2008 defined exception).                        */
      __IOM uint32_t dzc        : 1;            /*!< [3..3] Division by zero (IEEE 754-2008 defined exception).                */
      __IOM uint32_t ioc        : 1;            /*!< [4..4] Invalid operation (IEEE 754-2008 defined exception).               */
      __IOM uint32_t idc        : 1;            /*!< [5..5] Input denormal (ARM-specific exception).                           */
    } cm4_misc_ctrl_fpu_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t cm4_misc_ctrl_fpu_irq_msk_reset;/*!< (@ 0x00000010) FPU IRQ mask reset This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t ixc        : 1;            /*!< [0..0] Inexact (IEEE 754-2008 defined exception).                         */
      __IOM uint32_t ufc        : 1;            /*!< [1..1] Underflow (IEEE 754-2008 defined exception).                       */
      __IOM uint32_t ofc        : 1;            /*!< [2..2] Overflow (IEEE 754-2008 defined exception).                        */
      __IOM uint32_t dzc        : 1;            /*!< [3..3] Division by zero (IEEE 754-2008 defined exception).                */
      __IOM uint32_t ioc        : 1;            /*!< [4..4] Invalid operation (IEEE 754-2008 defined exception).               */
      __IOM uint32_t idc        : 1;            /*!< [5..5] Input denormal (ARM-specific exception).                           */
    } cm4_misc_ctrl_fpu_irq_msk_reset_b;
  } ;
} cm4_misc_ctrl_Type;                           /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                         idpm_com                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief idpm_com (idpm_com)
  */

typedef struct {                                /*!< (@ 0xFF001B00) idpm_com Structure                                         */
  
  union {
    __IOM uint32_t idpm_cfg0x0;                 /*!< (@ 0x00000000) DPM IO Control Register 0. This register is accessible
                                                                    in any DPM-mode (8, 16, 32 bit, SRAM, Intel,
                                                                    Motorola, little endian, big endian) by
                                                                    access to DPM address 0. Basic DPM settings
                                                                    are configurable here to make higher addresses
                                                                    accessible. To avoid instable system configurations,
                                                                    global changes of important configuration
                                                                    registers must be confirmed (re)writing
                                                                    'mode' bit field of this register. View
                                                                    'mode' description for details.                            */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] Global IDPM enable bit. The IDPM module must be enabled
                                                     by the INTLOGIC area before the host area (i.e. DPM mirrors
                                                     of INTRAMHS) can be used. While disabled all host access
                                                     (access to DPM mirrors of INTRAMHS) will be ignored. Read
                                                     will return 0x0bad0bad.                                                   */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t endian     : 2;            /*!< [5..4] Endianess of 32 bit (DWord) address alignment (B0: least
                                                     significant byte, B3: most significant byte): { | | | |
                                                     | coding Address A+3 A+2 A+1 A+0 00 little endian B3 B2
                                                     B1 B0 01 16 bit big endian B2 B3 B0 B1 10 32 bit big endian
                                                     B0 B1 B2 B3 11 reserved } Little endian is used netX inside.
                                                     If big endian host device is used, set to this 01                         */
      __IOM uint32_t reserved1  : 26;           /*!< [31..6] reserved                                                          */
    } idpm_cfg0x0_b;
  } ;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t idpm_addr_cfg;               /*!< (@ 0x00000010) DPM External Address Configuration Register.               */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t cfg_win_addr_cfg : 2;      /*!< [5..4] Location of the DPM Configuration Window (Window 0).
                                                     Supported settings are: 00: Low Configuration Window: The
                                                     Configuration Window is located in the first 256 bytes
                                                     of external DPM address range (0x0 to 0xff). It is located
                                                     before the first enabled Data Window (1 to 4). 01: High
                                                     Configuration Window: The Configuration Window is located
                                                     in the last 256 bytes of external DPM address range. Example:
                                                     'addr_range' is 8kB: Configuration Window is located in
                                                     0x1F00..0x1FFF. 10: reserved. 11: Configuration Window                    */
      __IOM uint32_t reserved1  : 26;           /*!< [31..6] reserved                                                          */
    } idpm_addr_cfg_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IM  uint32_t idpm_status;                 /*!< (@ 0x0000001C) DPM Status Register.                                       */
    
    struct {
      __IM  uint32_t unlocked   : 1;            /*!< [0..0] DPM is locked during netX power up and boot phase. DPM
                                                     access to other addresses than DPM configuration window
                                                     0 cannot be done before this bit is set to 1. Write access
                                                     to data windows (netX AHB area) will be ignored and read
                                                     access will deliver invalid data while locked. Poll for
                                                     1 after power-up or reset.                                                */
    } idpm_status_b;
  } ;
  __IM  uint32_t  RESERVED2[6];
  
  union {
    __IOM uint32_t idpm_tunnel_cfg;             /*!< (@ 0x00000038) Register description is too long, please enter
                                                                    short descripton                                           */
    
    struct {
      __IOM uint32_t wp_data    : 1;            /*!< [0..0] Access Tunnel function is write-protected for data access
                                                     (DWords 0 to 14 (15 for 'tunnel_all') of DATunnel). 0:
                                                     Write access is forwarded through the tunnel. 1: Write
                                                     access to DWords 0 to 14 (15 for 'tunnel_all') of DATunnel
                                                     will be ignored. Data write protection for host is enabled
                                                     by default and can be disabled by clearing this bit.                      */
      __IOM uint32_t wp_itbaddr : 1;            /*!< [1..1] ITBAddr is write-protected from host. 0: The ITBAddr
                                                     is mirrored to offset 0x3C of the tunnel and can also be
                                                     programmed there. 1: ITBAddr (Internal netX 32 bit Tunnel
                                                     Target Base Address) is read-only for tunnel offset 0x3C.
                                                     It can only be changed via configuration window 0 idpm_itbaddr
                                                     address or the INTLOGIC IDPM area.                                        */
      __IOM uint32_t enable     : 1;            /*!< [2..2] Enable/disable Access Tunnel function.                             */
      __IOM uint32_t tunnel_all : 1;            /*!< [3..3] Enable/disable the ITBAddr configuration register at
                                                     tunnel offset 0x3C. 0: Only 15 DWords are tunneled to the
                                                     internal tunnel target. The idpm_itbaddr is available at
                                                     offset 0x3C. One DWord of the tunnel target area is hidden
                                                     by idpm_itbaddr. 1: All 16 DWords are tunneled to the internal
                                                     tunnel target. The idpm_itbaddr is not available at offset
                                                     0x3C. All 64 tunnel target bytes can be reached (no hidden
                                                     register). Note: Target mapping (base and map) will not
                                                     be affected by this bit. Using a 'map' value no                           */
      __IOM uint32_t reserved0  : 2;            /*!< [5..4] reserved                                                           */
      __IOM uint32_t base       : 9;            /*!< [14..6] DPM Access Tunnel (DATunnel) Base Address divided by
                                                     64 on external visible address space. Note: Default setting
                                                     for tunnel base is starting on external address 0x100.                    */
      __IOM uint32_t reserved1  : 16;           /*!< [30..15] reserved                                                         */
      __IOM uint32_t wp_cfg_win : 1;            /*!< [31..31] Write-protect tunnel configuration inside the configuration
                                                     window 0. 0: The two tunnel configuration registers ('idpm_tunnel_cfg'
                                                     and 'idpm_itbaddr') can be programmed via configuration
                                                     window 0 and the INTLOGIC_SYS-IDPM address area. 1: The
                                                     tunnel configuration registers ('idpm_tunnel_cfg' and 'idpm_itbaddr')
                                                     cannot be programmed by the host via configuration window
                                                     0 (they are read-only for the host there). They can only
                                                     be programmed via the INTLOGIC_SYS-IDPM address area. Note:
                                                     Set this bit to protect                                                   */
    } idpm_tunnel_cfg_b;
  } ;
  
  union {
    __IOM uint32_t idpm_itbaddr;                /*!< (@ 0x0000003C) DPM Access Tunnel (DATunnel) netX Internal Target
                                                                    Base Address (ITBAddr) Configuration Register.
                                                                    For DPM Access Tunnel (DATunnel) function
                                                                    view description of dpm_tunnel_cfg register.
                                                                    This register contains ITBAddr value that
                                                                    can also be changed by host on last offset
                                                                    0x3c (last DWord) of external DATunnel area
                                                                    (defined by bit field 'base' in 'dpm_tunnel_cfg'
                                                                    register). However this register can also
                                                                    be write-protected from host if bit 'wp_itbaddr'
                                                                    in 'dpm_tunnel_cfg' register is set. Write
                                                                                                                               */
    
    struct {
      __IOM uint32_t wp_data_ro : 1;            /*!< [0..0] Access Tunnel function is write-protected from data access
                                                     (DWords 0 to 14 of DATunnel). This is a read-only bit here.
                                                     Its setting can be changed in 'dpm_tunnel_cfg' register.
                                                     View description of dpm_tunnel_cfg register.                              */
      __IOM uint32_t wp_itbaddr_ro : 1;         /*!< [1..1] ITBAddr is write-protected from host. This is a read-only
                                                     bit here. Its setting can be changed in 'dpm_tunnel_cfg'
                                                     register. View description of dpm_tunnel_cfg register.                    */
      __IOM uint32_t map        : 4;            /*!< [5..2] Mapping part of ITBAddr. View description of dpm_tunnel_cfg
                                                     register.                                                                 */
      __IOM uint32_t base       : 26;           /*!< [31..6] Internal netX Tunnel Target Base Address (ITBAddr) divided
                                                     by 64. View description of dpm_tunnel_cfg register.                       */
    } idpm_itbaddr_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win1_end;               /*!< (@ 0x00000040) DPM Window 1 End Address Configuration Register.
                                                                    Smallest DPM window configuration unit is
                                                                    128 bytes (i.e. lowest 7 bits of address
                                                                    configuration are always 0). At address
                                                                    0x0 DPM configuration window is mapped after
                                                                    reset (length: 256 bytes, containing all
                                                                    DPM addresses defined here). Each window
                                                                    starts at window end address of the preceding
                                                                    window. Hence external window 1 start address
                                                                    is 0x100, window 2 starts at value programmed
                                                                    in this register and so on. Note: This register
                                                                    can be wri                                                 */
    
    struct {
      __IOM uint32_t reserved0  : 7;            /*!< [6..0] reserved                                                           */
      __IOM uint32_t win_end    : 9;            /*!< [15..7] Window 1 End Address divided by 128. Last external address
                                                     is win_end*128-1. Setting win_end to 0 will disable this
                                                     window.                                                                   */
      __IOM uint32_t reserved1  : 16;           /*!< [31..16] reserved                                                         */
    } idpm_win1_end_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win1_map;               /*!< (@ 0x00000044) DPM Window 1 Address Map Configuration Register.
                                                                    Smallest DPM window configuration unit is
                                                                    128 bytes (i.e. lowest 7 bits of address
                                                                    configuration are always 0). For further
                                                                    information view description of 'dpm_win1_end'
                                                                    register.                                                  */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t win_map_alt : 2;           /*!< [3..2] Window 1 Alternative Address Mapping Configuration. Alternative
                                                     Address Mapping can be generated by Triple Buffer Managers
                                                     inside HANDSHAKE_CTRL unit. Coding: 00 : Alternative Address
                                                     Mapping disabled. 01 : Alternative Address Mapping enabled:
                                                     Use Triple Buffer Manager 0 from HANDSHAKE_CTRL unit. 10
                                                     : Alternative Address Mapping enabled: Use Triple Buffer
                                                     Manager 1 from HANDSHAKE_CTRL unit. 11 : reserved If Alternative
                                                     Address Mapping is enabled, mapping value is taken according
                                                     to buffer status of related                                               */
      __IOM uint32_t reserved1  : 1;            /*!< [4..4] reserved                                                           */
      __IOM uint32_t wp_cfg_win : 1;            /*!< [5..5] Write-protect window configuration inside the configuration
                                                     window 0. 0: All 8 window configuration registers ('dpm_winX_and'
                                                     and 'dpm_winX_map') can be programmed via configuration
                                                     window 0 and the INTLOGIC-DPM address area. 1: All 8 window
                                                     configuration registers ('dpm_winX_and' and 'dpm_winX_map')
                                                     cannot be programmed by the host via configuration window
                                                     0 (they are read-only for the host there). They can only
                                                     be programmed via the INTLOGIC-DPM address area. Note:
                                                     Set this bit to protect the NETX from r                                   */
      __IOM uint32_t reserved2  : 1;            /*!< [6..6] reserved                                                           */
      __IOM uint32_t win_map    : 8;            /*!< [14..7] Window 1 Address Mapping. Internal access address HADDR
                                                     to netX logic is combined by DPM interface by: HADDR[31:16]:
                                                     unchanged, as it comes form accessing master HADDR[15:0]:
                                                     mapped DPM address. This part of address is defined by
                                                     programmed win_map value for each window. The value to
                                                     be programmed is address bits 15 to 0 of netX internal
                                                     window start address minus start address of the external
                                                     window (i.e. end address of preceding window) . Example:
                                                     Window n starts at 0x400 of external DPM address range
                                                     (                                                                         */
      __IOM uint32_t reserved3  : 17;           /*!< [31..15] reserved                                                         */
    } idpm_win1_map_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win2_end;               /*!< (@ 0x00000048) DPM Window 2 End Address Configuration Register.
                                                                    For detailed information refer to 'idpm_win1_end'
                                                                    register description. Note: This register
                                                                    can be write-protected by the 'wp_cfg_win'-bit
                                                                    of the 'idpm_win1_map' register.                           */
    
    struct {
      __IOM uint32_t reserved0  : 7;            /*!< [6..0] reserved                                                           */
      __IOM uint32_t win_end    : 9;            /*!< [15..7] Window 2 End Address divided by 128. Last external address
                                                     is win_end*128-1.                                                         */
      __IOM uint32_t reserved1  : 16;           /*!< [31..16] reserved                                                         */
    } idpm_win2_end_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win2_map;               /*!< (@ 0x0000004C) DPM Window 2 Address Map Configuration Register.
                                                                    For detailed information refer to 'dpm_win1_map'
                                                                    register description. Note: This register
                                                                    can be write-protected by the 'wp_cfg_win'-bit
                                                                    of the 'idpm_win1_map' register.                           */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t win_map_alt : 2;           /*!< [3..2] Window Alternative Address Mapping Configuration.                  */
      __IOM uint32_t reserved1  : 3;            /*!< [6..4] reserved                                                           */
      __IOM uint32_t win_map    : 8;            /*!< [14..7] Window address mapping.                                           */
      __IOM uint32_t reserved2  : 17;           /*!< [31..15] reserved                                                         */
    } idpm_win2_map_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win3_end;               /*!< (@ 0x00000050) DPM Window 3 End Address Configuration Register.
                                                                    For detailed information refer to 'idpm_win1_end'
                                                                    register description. Note: This register
                                                                    can be write-protected by the 'wp_cfg_win'-bit
                                                                    of the 'idpm_win1_map' register.                           */
    
    struct {
      __IOM uint32_t reserved0  : 7;            /*!< [6..0] reserved                                                           */
      __IOM uint32_t win_end    : 9;            /*!< [15..7] Window 3 End Address divided by 128. Last external address
                                                     is win_end*128-1.                                                         */
      __IOM uint32_t reserved1  : 16;           /*!< [31..16] reserved                                                         */
    } idpm_win3_end_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win3_map;               /*!< (@ 0x00000054) DPM Window 3 Address Map Configuration Register.
                                                                    For detailed information refer to 'dpm_win1_map'
                                                                    register description. Note: This register
                                                                    can be write-protected by the 'wp_cfg_win'-bit
                                                                    of the 'idpm_win1_map' register.                           */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t win_map_alt : 2;           /*!< [3..2] Window Alternative Address Mapping Configuration.                  */
      __IOM uint32_t reserved1  : 3;            /*!< [6..4] reserved                                                           */
      __IOM uint32_t win_map    : 8;            /*!< [14..7] Window map address.                                               */
      __IOM uint32_t reserved2  : 17;           /*!< [31..15] reserved                                                         */
    } idpm_win3_map_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win4_end;               /*!< (@ 0x00000058) DPM Window 4 End Address Configuration Register.
                                                                    For detailed information refer to 'idpm_win1_end'
                                                                    register description. Note: This register
                                                                    can be write-protected by the 'wp_cfg_win'-bit
                                                                    of the 'idpm_win1_map' register.                           */
    
    struct {
      __IOM uint32_t reserved0  : 7;            /*!< [6..0] reserved                                                           */
      __IOM uint32_t win_end    : 9;            /*!< [15..7] Window 4 End Address divided by 128. Last external address
                                                     is win_end*128-1.                                                         */
      __IOM uint32_t reserved1  : 16;           /*!< [31..16] reserved                                                         */
    } idpm_win4_end_b;
  } ;
  
  union {
    __IOM uint32_t idpm_win4_map;               /*!< (@ 0x0000005C) DPM Window 4 Address Map Configuration Register.
                                                                    For detailed information refer to 'dpm_win1_map'
                                                                    register description. Note: This register
                                                                    can be write-protected by the 'wp_cfg_win'-bit
                                                                    of the 'idpm_win1_map' register.                           */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t win_map_alt : 2;           /*!< [3..2] Window Alternative Address Mapping Configuration.                  */
      __IOM uint32_t reserved1  : 3;            /*!< [6..4] reserved                                                           */
      __IOM uint32_t win_map    : 8;            /*!< [14..7] Window map address.                                               */
      __IOM uint32_t reserved2  : 17;           /*!< [31..15] reserved                                                         */
    } idpm_win4_map_b;
  } ;
  __IM  uint32_t  RESERVED3[8];
  
  union {
    __IM  uint32_t idpm_irq_raw;                /*!< (@ 0x00000080) DPM Raw (before masking) IRQ Status Register.
                                                                    If a bit is set, the related interrupt is
                                                                    asserted. Interrupts must be reset in interrupt
                                                                    generating module. Interrupts cannot be
                                                                    cleared here. Important: There are two completely
                                                                    independent sets of IRQ registers: IRQ register-set
                                                                    1: 'dpm_irq_raw' (and related registers
                                                                    e.g. 'dpm_irq_irq_*' registers). IRQ register-set
                                                                    2: 'dpm_firmware_irq_* registers' (netx50
                                                                    compatible register set: DPM_HOST_INT_EN0,2
                                                                    DPM_HOST_INT_STA0,2). Programming (maskin                  */
    
    struct {
      __IM  uint32_t dpm_sw     : 1;            /*!< [0..0] raw software IRQ for IRQ targets interrupt                         */
      __IM  uint32_t reserved0  : 1;            /*!< [1..1] reserved                                                           */
      __IM  uint32_t firmware   : 1;            /*!< [2..2] raw combined handshake-cell and SYS_STA firmware interrupt         */
      __IM  uint32_t reserved1  : 29;           /*!< [31..3] reserved                                                          */
    } idpm_irq_raw_b;
  } ;
  
  union {
    __IOM uint32_t idpm_irq_host_mask_set;      /*!< (@ 0x00000084) DPM Interrupt Mask Register for IDPM host interrupt.
                                                                    Write access with '1' sets related interrupt
                                                                    mask bits (enables interrupt request for
                                                                    corresponding interrupt source). Write access
                                                                    with '0' does not influence related interrupt
                                                                    mask bit. Read access shows actual interrupt
                                                                    mask. If a mask bit is set, the related
                                                                    interrupt will activate the IRQ for IDPM
                                                                    host interrupt. Interrupts must be reset
                                                                    in interrupt generating module. Interrupts
                                                                    cannot be cleared here. To release IRQ for
                                                                    IDPM host in                                               */
    
    struct {
      __IOM uint32_t dpm_sw     : 1;            /*!< [0..0] set software IRQ for IRQ targets interrupt mask for IDPM
                                                     host interrupt                                                            */
      __IOM uint32_t reserved0  : 1;            /*!< [1..1] reserved                                                           */
      __IOM uint32_t firmware   : 1;            /*!< [2..2] set combined handshake-cell and SYS_STA firmware interrupt
                                                     mask for IDPM host interrupt                                              */
      __IOM uint32_t reserved1  : 29;           /*!< [31..3] reserved                                                          */
    } idpm_irq_host_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t idpm_irq_host_mask_reset;    /*!< (@ 0x00000088) DPM Interrupt Mask Reset Register for IDPM host
                                                                    interrupt. Write access with '1' resets
                                                                    related interrupt mask bits (disables interrupt
                                                                    request for corresponding interrupt source).
                                                                    Write access with '0' does not influence
                                                                    related interrupt mask bit. Read access
                                                                    shows actual interrupt mask. If a mask bit
                                                                    is set, the related interrupt will activate
                                                                    the IRQ for IDPM host interrupt. Interrupts
                                                                    must be reset in interrupt generating module.
                                                                    Interrupts cannot be cleared here. To release
                                                                    IRQ for IDP                                                */
    
    struct {
      __IOM uint32_t dpm_sw     : 1;            /*!< [0..0] reset software IRQ for IRQ targets interrupt mask for
                                                     IDPM host interrupt                                                       */
      __IOM uint32_t reserved0  : 1;            /*!< [1..1] reserved                                                           */
      __IOM uint32_t firmware   : 1;            /*!< [2..2] reset combined handshake-cell and SYS_STA firmware interrupt
                                                     mask for IDPM host interrupt                                              */
      __IOM uint32_t reserved1  : 29;           /*!< [31..3] reserved                                                          */
    } idpm_irq_host_mask_reset_b;
  } ;
  
  union {
    __IM  uint32_t idpm_irq_host_masked;        /*!< (@ 0x0000008C) DPM Masked Interrupt Status Register for IDPM
                                                                    host interrupt. A bit is set, when the related
                                                                    mask bit is set in 'dpm_irq_host_mask'-register
                                                                    and the related interrupt is asserted. IRQ
                                                                    for IDPM host interrupt is asserted if at
                                                                    least one bit is set here. Interrupts must
                                                                    be reset in interrupt generating module.
                                                                    Interrupts cannot be cleared here. To release
                                                                    IRQ for IDPM host interrupt without clearing
                                                                    interrupt in module, reset related mask
                                                                    bit to 0. Note: For further information
                                                                    view descripti                                             */
    
    struct {
      __IM  uint32_t dpm_sw     : 1;            /*!< [0..0] masked software IRQ for IRQ targets interrupt state for
                                                     IDPM host interrupt                                                       */
      __IM  uint32_t reserved0  : 1;            /*!< [1..1] reserved                                                           */
      __IM  uint32_t firmware   : 1;            /*!< [2..2] masked combined handshake-cell and SYS_STA firmware interrupt
                                                     state for IDPM host interrupt                                             */
      __IM  uint32_t reserved1  : 29;           /*!< [31..3] reserved                                                          */
    } idpm_irq_host_masked_b;
  } ;
  __IM  uint32_t  RESERVED4[12];
  
  union {
    __IOM uint32_t idpm_sw_irq;                 /*!< (@ 0x000000C0) DPM Register for Software Interrupt Generation
                                                                    to Host and netX Interrupt Targets. Host
                                                                    and netX masters can generate an interrupt
                                                                    to netX interrupt targets (e.g. ARM-VIC)
                                                                    by this register. To propagate interrupt
                                                                    states from this register to the interrupt
                                                                    target the 'idpm_sw' IRQ must be enabled
                                                                    inside the appropriate interrupt controller
                                                                    (e.g. the ARM-VIC). Note: There is a set
                                                                    and a reset bit for the sw-IRQ to avoid
                                                                    read-modify-write sequences. When both (set
                                                                    and reset) bits are set at th                              */
    
    struct {
      __IOM uint32_t set_host   : 1;            /*!< [0..0] Set 'dpm_sw' IRQ for host (current 'dpm_sw' status for
                                                     host when read)                                                           */
      __IOM uint32_t reserved0  : 7;            /*!< [7..1] reserved                                                           */
      __IOM uint32_t reset_host : 1;            /*!< [8..8] Reset 'dpm_sw' IRQ for host (always 0 when read)                   */
      __IOM uint32_t reserved1  : 23;           /*!< [31..9] reserved                                                          */
    } idpm_sw_irq_b;
  } ;
  __IM  uint32_t  RESERVED5[5];
  
  union {
    __IOM uint32_t idpm_sys_sta;                /*!< (@ 0x000000D8) DPM System Status Information Register. This
                                                                    register can be used for firmware status
                                                                    information. Note: This register is NOT
                                                                    fully compatible to netx50 DPM_HOST_SYS_STAT
                                                                    register: Only the HOST_STATE-bits of DPM0
                                                                    can be read from the 'netx_status'-register
                                                                    inside ASIC_CTRL address area. The HOST_STATE-bits
                                                                    of DPM1 and IDPM can not be read from the
                                                                    'netx_status'-register inside ASIC_CTRL
                                                                    address area.                                              */
    
    struct {
      __IOM uint32_t RDY_ro     : 1;            /*!< [0..0] Output state of netX RDY LED IO. Note: This bit field
                                                     can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL
                                                     address area.                                                             */
      __IOM uint32_t RUN_ro     : 1;            /*!< [1..1] Output state of netX RUN LED IO. Note: This bit field
                                                     can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL
                                                     address area.                                                             */
      __IOM uint32_t NETX_STATE_ro : 2;         /*!< [3..2] Bit field for Hilscher firmware compatibility. Note:
                                                     This bit field can be changed by 'netx_status'-register
                                                     inside ASIC_CTRL address area.                                            */
      __IOM uint32_t HOST_STATE : 4;            /*!< [7..4] Bit field for Hilscher firmware. Note: This bit field
                                                     can NOT be read from 'netx_status'-register inside ASIC_CTRL
                                                     address area.                                                             */
      __IOM uint32_t NETX_STA_CODE_ro : 8;      /*!< [15..8] Bit field for Hilscher firmware compatibility (read
                                                     only). Note: This bit field can be changed by 'netx_status'-register
                                                     inside ASIC_CTRL address area.                                            */
    } idpm_sys_sta_b;
  } ;
  
  union {
    __IOM uint32_t idpm_reset_request;          /*!< (@ 0x000000DC) DPM Reset Request Register. Note: This register
                                                                    is compatible to netx50 DPM_HOST_RESET_REQ
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t reset_key  : 8;            /*!< [7..0] Reset key sequence register. A netx hardware reset is
                                                     generated if the following sequence is written to this
                                                     register: 1st access: write 0x00 2nd access: write 0x01
                                                     3rd access: write 0x03 4th access: write 0x07 5th access:
                                                     write 0x0f 6th access: write 0x1f 7th access: write 0x3f
                                                     8th access: write 0x7f To issue a reset the sequence must
                                                     not be interrupted by a write access to another register
                                                     of this DPM module register area. Writing 0x00 will always
                                                     restart the sequence. Reading thi                                         */
    } idpm_reset_request_b;
  } ;
  
  union {
    __IOM uint32_t idpm_firmware_irq_raw;       /*!< (@ 0x000000E0) 1st netx50 compatible DPM Interrupt Status Register
                                                                    (related to 'dpm_firmware_irq_mask'-register).
                                                                    Writing a '1' to an IRQ flag will clear
                                                                    the Interrupt. This is always done even
                                                                    if related bit inside 'dpm_firmware_irq_mask'-register
                                                                    is not set (this is compatible to netx50).
                                                                    Important: There are two completely independent
                                                                    sets of IRQ registers: IRQ register-set
                                                                    1: 'dpm_irq_raw' (and related registers
                                                                    e.g. 'dpm_irq_irq_*' registers). IRQ register-set
                                                                    2: 'dpm_firmware_irq_* registers' (netx5                   */
    
    struct {
      __IOM uint32_t HS_EVENT0  : 1;            /*!< [0..0] Handshake Event 0 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT1  : 1;            /*!< [1..1] Handshake Event 1 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT2  : 1;            /*!< [2..2] Handshake Event 2 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT3  : 1;            /*!< [3..3] Handshake Event 3 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT4  : 1;            /*!< [4..4] Handshake Event 4 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT5  : 1;            /*!< [5..5] Handshake Event 5 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT6  : 1;            /*!< [6..6] Handshake Event 6 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT7  : 1;            /*!< [7..7] Handshake Event 7 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT8  : 1;            /*!< [8..8] Handshake Event 8 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT9  : 1;            /*!< [9..9] Handshake Event 9 IRQ status flag.                                 */
      __IOM uint32_t HS_EVENT10 : 1;            /*!< [10..10] Handshake Event 10 IRQ status flag.                              */
      __IOM uint32_t HS_EVENT11 : 1;            /*!< [11..11] Handshake Event 11 IRQ status flag.                              */
      __IOM uint32_t HS_EVENT12 : 1;            /*!< [12..12] Handshake Event 12 IRQ status flag.                              */
      __IOM uint32_t HS_EVENT13 : 1;            /*!< [13..13] Handshake Event 13 IRQ status flag.                              */
      __IOM uint32_t HS_EVENT14 : 1;            /*!< [14..14] Handshake Event 14 IRQ status flag.                              */
      __IOM uint32_t HS_EVENT15 : 1;            /*!< [15..15] Handshake Event 15 IRQ status flag.                              */
      __IOM uint32_t IRQ_VECTOR : 8;            /*!< [23..16] Interrupt Vector according to status flags generated
                                                     by enabled IRQ sources. { | Code IRQ status 0x00 No IRQ.
                                                     ---- ------- 0x10 Handshake Cell 0 IRQ. 0x11 Handshake
                                                     Cell 1 IRQ. 0x12 Handshake Cell 2 IRQ. 0x13 Handshake Cell
                                                     3 IRQ. 0x14 Handshake Cell 4 IRQ. 0x15 Handshake Cell 5
                                                     IRQ. 0x16 Handshake Cell 6 IRQ. 0x17 Handshake Cell 7 IRQ.
                                                     0x18 Handshake Cell 8 IRQ. 0x19 Handshake Cell 9 IRQ. 0x1a
                                                     Handshake Cell 10 IRQ. 0x1b Handshake Cell 11 IRQ. 0x1c
                                                     Handshake Cell 12 IRQ                                                     */
      __IOM uint32_t reserved0  : 1;            /*!< [24..24] reserved                                                         */
      __IOM uint32_t res_TMR_ro : 1;            /*!< [25..25] reserved for Timer IRQ flag (not available in this
                                                     netX version).                                                            */
      __IOM uint32_t SYS_STA    : 1;            /*!< [26..26] System Status Change IRQ flag.                                   */
      __IOM uint32_t reserved1  : 1;            /*!< [27..27] reserved                                                         */
      __IOM uint32_t res_RDY_TIMEOUT_ro : 1;    /*!< [28..28] reserved, DPM_RDY timeout error does not exist for
                                                     IDPM.                                                                     */
      __IOM uint32_t res_WDG_NETX_ro : 1;       /*!< [29..29] reserved for netX supervision Watchdog Timeout IRQ
                                                     flag (not available in this netX version).                                */
      __IOM uint32_t res_MEM_LCK_ro : 1;        /*!< [30..30] reserved for Memory Lock IRQ flag (not available in
                                                     this netX version).                                                       */
      __IOM uint32_t INT_REQ    : 1;            /*!< [31..31] Interrupt Request for IRQs handled in this register.
                                                     0: No Interrupts to host requested by IRQ sources handled
                                                     in this register. 1: IRQ sources handled in this register
                                                     request a host IRQ. Note: This bit is masked by INT_EN-bit
                                                     in dpm_firmware_irq_mask register. For propagation of INT_REQ
                                                     to host, ARM or xPIC, INT_EN-bit must be set and firmware
                                                     IRQ must be activated in related dpm_irq_* register.                      */
    } idpm_firmware_irq_raw_b;
  } ;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t idpm_firmware_irq_mask;      /*!< (@ 0x000000F0) DPM Handshake Interrupt Enable Register. Only
                                                                    netx50 compatible 'dpm_firmware_irq' registers
                                                                    are related to settings of this register.
                                                                    Note: This register is compatible to netx50
                                                                    DPM_HOST_INT_EN0 register, however some
                                                                    unused IRQs have been removed. Note: HS_EVENT-bits
                                                                    are not read-only. This is netX50 compliant.
                                                                    Recent netX50 Documentation marks HS_EVENT-bits
                                                                    as read-only. This is an dokumentation error.
                                                                    For netX50 compatibility, these bits can
                                                                    also be controlled from netX-side in HANDSHA               */
    
    struct {
      __IOM uint32_t HS_EVENT0  : 1;            /*!< [0..0] Handshake Event 0 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT1  : 1;            /*!< [1..1] Handshake Event 1 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT2  : 1;            /*!< [2..2] Handshake Event 2 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT3  : 1;            /*!< [3..3] Handshake Event 3 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT4  : 1;            /*!< [4..4] Handshake Event 4 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT5  : 1;            /*!< [5..5] Handshake Event 5 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT6  : 1;            /*!< [6..6] Handshake Event 6 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT7  : 1;            /*!< [7..7] Handshake Event 7 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT8  : 1;            /*!< [8..8] Handshake Event 8 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT9  : 1;            /*!< [9..9] Handshake Event 9 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT10 : 1;            /*!< [10..10] Handshake Event 10 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT11 : 1;            /*!< [11..11] Handshake Event 11 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT12 : 1;            /*!< [12..12] Handshake Event 12 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT13 : 1;            /*!< [13..13] Handshake Event 13 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT14 : 1;            /*!< [14..14] Handshake Event 14 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t HS_EVENT15 : 1;            /*!< [15..15] Handshake Event 15 IRQ Enable (also netX-controllable
                                                     by HANDSHAKE_CTRL, netX50 comp.).                                         */
      __IOM uint32_t reserved0  : 9;            /*!< [24..16] reserved                                                         */
      __IOM uint32_t res_TMR_ro : 1;            /*!< [25..25] reserved for Timer IRQ (not available in this netX
                                                     version).                                                                 */
      __IOM uint32_t SYS_STA    : 1;            /*!< [26..26] System Status Change IRQ Enable.                                 */
      __IOM uint32_t reserved1  : 1;            /*!< [27..27] reserved                                                         */
      __IOM uint32_t res_RDY_TIMEOUT_ro : 1;    /*!< [28..28] reserved, DPM_RDY timeout error does not exist for
                                                     IDPM.                                                                     */
      __IOM uint32_t res_WDG_NETX_ro : 1;       /*!< [29..29] reserved for netX supervision Watchdog Timeout IRQ
                                                     (not available in this netX version).                                     */
      __IOM uint32_t res_MEM_LCK_ro : 1;        /*!< [30..30] reserved for Memory Lock IRQ (not available in this
                                                     netX version).                                                            */
      __IOM uint32_t INT_EN     : 1;            /*!< [31..31] Interrupt Enable for IRQs handled in this register.
                                                     Only if this bit is set, global firmware IRQ will be asserted
                                                     to host CPU, ARM or xPIC by dpm_irq_* registers. 0: No
                                                     Interrupts to host, ARM or xPIC are generated by IRQ sources
                                                     handled in this register. 1: Enabled IRQ sources handled
                                                     in this register generate a host, ARM or xPIC IRQ if asserted.
                                                     Note: Enable bits for single IRQ events are not affected
                                                     if this bit is set or reset.                                              */
    } idpm_firmware_irq_mask_b;
  } ;
  __IM  uint32_t  RESERVED7[2];
  
  union {
    __IM  uint32_t idpm_netx_version;           /*!< (@ 0x000000FC) DPM netX Version Register. This register is mirrored
                                                                    form asic_ctrl register area and can be
                                                                    set during netX booting phase by netX firmware.
                                                                    This register is not valid if unlocked bit
                                                                    is not set in dpm_status register. Together
                                                                    with dpm_netx_version register, full 32
                                                                    bit version can be read by any host device,
                                                                    even if DPM interface is not initialized
                                                                    yet. Bytes byte0 and byte2 can be always
                                                                    read here even if DPM is uninitialized (8
                                                                    bit default from dpm_cfg0x0 after power
                                                                    on) and host device                                        */
    
    struct {
      __IM  uint32_t netx_version : 32;         /*!< [31..0] netX version from version register.                               */
    } idpm_netx_version_b;
  } ;
} idpm_com_Type;                                /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           hash                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief hash (hash)
  */

typedef struct {                                /*!< (@ 0xFF080000) hash Structure                                             */
  
  union {
    __OM  uint32_t hash_din;                    /*!< (@ 0x00000000) Hash FIFO input: Unlike all other registers,
                                                                    this address can be written with DWord(32
                                                                    Bit), Word(16 Bit) or Byte acccss. The FIFO
                                                                    controller will automatically collect data
                                                                    and start HASH-calculation, if enough data
                                                                    (complete DWords) are collected.                           */
    
    struct {
      __OM  uint32_t val        : 32;           /*!< [31..0] data bits                                                         */
    } hash_din_b;
  } ;
  
  union {
    __IOM uint32_t hash_cfg;                    /*!< (@ 0x00000004) Hash config register:                                      */
    
    struct {
      __IOM uint32_t mode       : 3;            /*!< [2..0] Hash core mode 100: MD5 011: SHA2-512 010: SHA2-384 001:
                                                     SHA2-256 000: SHA1-160 Note: When changing the mode, a
                                                     reset must be performed to correctly initialize the SHA/MD5
                                                     core. This can be done by setting the 'reset' bit together
                                                     with the new mode or in a second access after setting the
                                                     mode.                                                                     */
      __IOM uint32_t reset      : 1;            /*!< [3..3] Reset of SHA engine: After writing '1', this bit will
                                                     automatically be reset. 1: reset internal registers, use
                                                     this to start calculation of new hash 0: start calculation
                                                     as soon as enough data in FIFO buffer                                     */
      __IOM uint32_t dma_en     : 1;            /*!< [4..4] Enable DMAC control signals                                        */
      __IOM uint32_t dma_burst_only : 1;        /*!< [5..5] Generate DMAC burst signal only. When set to '1' the
                                                     DMAC logic will only generate burst requests to the DMAC.
                                                     This is to overcome limitations of the current DMA controller
                                                     implementation that only accepts burst requests for DMAC
                                                     controlled memory to peripheral transfers.                                */
    } hash_cfg_b;
  } ;
  
  union {
    __IM  uint32_t hash_stat;                   /*!< (@ 0x00000008) Hash status register:                                      */
    
    struct {
      __IM  uint32_t fifo_fill  : 9;            /*!< [8..0] Fill level of FIFO in bytes (0..256)                               */
    } hash_stat_b;
  } ;
  
  union {
    __IM  uint32_t hash_debug_info;             /*!< (@ 0x0000000C) Hash info register:                                        */
    
    struct {
      __IM  uint32_t sha_round  : 7;            /*!< [6..0] 7bit current state counter of the SHA core.                        */
    } hash_debug_info_b;
  } ;
  
  union {
    __IOM uint32_t hash_irq_raw;                /*!< (@ 0x00000010) Hash raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit.                                                       */
    
    struct {
      __IOM uint32_t hash_ready : 1;            /*!< [0..0] Hash core has finished calculation and hash value inside
                                                     the registers crypt_hash[15:0] is valid. Note: This interrupt
                                                     will be asserted when the hash FIFO is empty and the calculation
                                                     of the last block from the FIFO has finished. The interrupt
                                                     will be re-asserted after clearing as long as no new data
                                                     has been fed into the FIFO or a software reset has been
                                                     performed (hash_cfg-reset=1). Note: This interrupt could
                                                     have got asserted in situations where the FIFO runs empty,
                                                     the hash core finished the operati                                        */
      __IOM uint32_t fifo_underrun : 1;         /*!< [1..1] input buffer was underrun, set hash_cfg-reset=1 to reset
                                                     this bit. Note: underrun is only a theoretical FIFO status,
                                                     because the hardware logic of the hash core won't fetch
                                                     data from the FIFO when it's empty.                                       */
      __IOM uint32_t fifo_overflow : 1;         /*!< [2..2] input buffer was overflown, set hash_cfg-reset=1 to reset
                                                     this bit.                                                                 */
    } hash_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t hash_irq_masked;             /*!< (@ 0x00000014) Hash masked IRQ: Shows status of masked IRQs.              */
    
    struct {
      __IM  uint32_t hash_ready : 1;            /*!< [0..0] Hash core has finished calculation and hash value inside
                                                     the registers crypt_hash[15:0] is valid                                   */
      __IM  uint32_t fifo_underrun : 1;         /*!< [1..1] input buffer was underrun, set hash_cfg-reset=1 to reset
                                                     this bit                                                                  */
      __IM  uint32_t fifo_overflow : 1;         /*!< [2..2] input buffer was overflown, set hash_cfg-reset=1 to reset
                                                     this bit                                                                  */
    } hash_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t hash_irq_msk_set;            /*!< (@ 0x00000018) Hash IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to crypt_hash_irq_raw.           */
    
    struct {
      __IOM uint32_t hash_ready : 1;            /*!< [0..0] Hash core has finished calculation and hash value inside
                                                     the registers crypt_hash[15:0] is valid                                   */
      __IOM uint32_t fifo_underrun : 1;         /*!< [1..1] input buffer was underrun, set hash_cfg-reset=1 to reset
                                                     this bit                                                                  */
      __IOM uint32_t fifo_overflow : 1;         /*!< [2..2] input buffer was overflown, set hash_cfg-reset=1 to reset
                                                     this bit                                                                  */
    } hash_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t hash_irq_msk_reset;          /*!< (@ 0x0000001C) Hash IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t hash_ready : 1;            /*!< [0..0] Hash core has finished calculation and hash value inside
                                                     the registers crypt_hash[15:0] is valid                                   */
      __IOM uint32_t fifo_underrun : 1;         /*!< [1..1] input buffer was underrun, set hash_cfg-reset=1 to reset
                                                     this bit                                                                  */
      __IOM uint32_t fifo_overflow : 1;         /*!< [2..2] input buffer was overflown, set hash_cfg-reset=1 to reset
                                                     this bit                                                                  */
    } hash_irq_msk_reset_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout0;                  /*!< (@ 0x00000020) Hash value0 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } hash_dout0_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout1;                  /*!< (@ 0x00000024) Hash value1 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } hash_dout1_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout2;                  /*!< (@ 0x00000028) Hash value2 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } hash_dout2_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout3;                  /*!< (@ 0x0000002C) Hash value3 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } hash_dout3_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout4;                  /*!< (@ 0x00000030) Hash value4 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } hash_dout4_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout5;                  /*!< (@ 0x00000034) Hash value5 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } hash_dout5_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout6;                  /*!< (@ 0x00000038) Hash value6 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } hash_dout6_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout7;                  /*!< (@ 0x0000003C) Hash value7 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } hash_dout7_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout8;                  /*!< (@ 0x00000040) Hash value8 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } hash_dout8_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout9;                  /*!< (@ 0x00000044) Hash value9 register                                       */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } hash_dout9_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout10;                 /*!< (@ 0x00000048) Hash value10 register                                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } hash_dout10_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout11;                 /*!< (@ 0x0000004C) Hash value11 register                                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } hash_dout11_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout12;                 /*!< (@ 0x00000050) Hash value12 register                                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } hash_dout12_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout13;                 /*!< (@ 0x00000054) Hash value13 register                                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } hash_dout13_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout14;                 /*!< (@ 0x00000058) Hash value14 register                                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } hash_dout14_b;
  } ;
  
  union {
    __IM  uint32_t hash_dout15;                 /*!< (@ 0x0000005C) Hash value15 register                                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } hash_dout15_b;
  } ;
} hash_Type;                                    /*!< Size = 96 (0x60)                                                          */



/* =========================================================================================================================== */
/* ================                                            aes                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief aes (aes)
  */

typedef struct {                                /*!< (@ 0xFF080080) aes Structure                                              */
  
  union {
    __IOM uint32_t aes_cfg;                     /*!< (@ 0x00000000) AES config register                                        */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] Enables the AES core operation.                                    */
      __IOM uint32_t mode       : 1;            /*!< [1..1] AES core operation mode 0: Encrypt 1: Decrypt                      */
      __IOM uint32_t key_len    : 2;            /*!< [3..2] AES key length 0: 128 bit 1: 192 bit 2: 256 bit 3: reserved        */
      __IOM uint32_t key_exp_start : 1;         /*!< [4..4] Start AES key expansion After writing '1', this bit will
                                                     automatically be reset. Data input can be started when
                                                     key expansion is ready (see crypt_aes_stat bit 'key_exp_ready').          */
      __IOM uint32_t in_fifo_wm : 6;            /*!< [10..5] Input FIFO watermark level (0..63) used for in_fifo_wm
                                                     interrupt                                                                 */
      __IOM uint32_t out_fifo_wm : 6;           /*!< [16..11] Output FIFO watermark level (0..63) used for out_fifo_wm
                                                     interrupt                                                                 */
      __IOM uint32_t in_fifo_dma_en : 1;        /*!< [17..17] Enable DMAC control signals for the input FIFO                   */
      __IOM uint32_t in_fifo_dma_burst_only : 1;/*!< [18..18] Generate DMAC burst signal only (input FIFO). When
                                                     set to '1' the DMAC logic will only generate burst requests
                                                     to the DMAC. This is to overcome limitations of the current
                                                     DMA controller implementation that only accepts burst requests
                                                     for DMAC controlled memory to peripheral transfers.                       */
      __IOM uint32_t out_fifo_dma_en : 1;       /*!< [19..19] Enable DMAC control signals for the output FIFO.                 */
      __IOM uint32_t out_fifo_dma_burst_only : 1;/*!< [20..20] Generate DMAC burst signal only (output FIFO). When
                                                     set to '1' the DMAC logic will only generate burst requests
                                                     to the DMAC. This is not strictly needed for the DMAC implementation,
                                                     but could result in better system performance.                            */
    } aes_cfg_b;
  } ;
  
  union {
    __IM  uint32_t aes_stat;                    /*!< (@ 0x00000004) AES status register                                        */
    
    struct {
      __IM  uint32_t key_exp_ready : 1;         /*!< [0..0] Set when key expansion procedure is done                           */
      __IM  uint32_t op_ready   : 1;            /*!< [1..1] Set when AES operation ready, i.e. AES core not busy
                                                     and input FIFO is empty                                                   */
      __IM  uint32_t in_fifo_fill : 7;          /*!< [8..2] Fill level of input FIFO in bytes (0..64)                          */
      __IM  uint32_t in_fifo_empty : 1;         /*!< [9..9] Input FIFO is empty                                                */
      __IM  uint32_t in_fifo_not_empty : 1;     /*!< [10..10] Input FIFO is not empty                                          */
      __IM  uint32_t in_fifo_full : 1;          /*!< [11..11] Input FIFO is full                                               */
      __IM  uint32_t in_fifo_not_full : 1;      /*!< [12..12] Input FIFO is not full                                           */
      __IM  uint32_t in_fifo_underrun : 1;      /*!< [13..13] Input FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit Note: underrun is only a theoretical FIFO status,
                                                     because the hardware logic of the AES core won't fetch
                                                     data from the FIFO when it's empty.                                       */
      __IM  uint32_t in_fifo_overflow : 1;      /*!< [14..14] Input FIFO was overflown, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IM  uint32_t out_fifo_fill : 7;         /*!< [21..15] Fill level of output FIFO in bytes (0..64)                       */
      __IM  uint32_t out_fifo_empty : 1;        /*!< [22..22] Output FIFO is empty                                             */
      __IM  uint32_t out_fifo_not_empty : 1;    /*!< [23..23] Output FIFO is not empty                                         */
      __IM  uint32_t out_fifo_full : 1;         /*!< [24..24] Output FIFO is full                                              */
      __IM  uint32_t out_fifo_not_full : 1;     /*!< [25..25] Output FIFO is not full                                          */
      __IM  uint32_t out_fifo_underrun : 1;     /*!< [26..26] Output FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IM  uint32_t out_fifo_overflow : 1;     /*!< [27..27] Output FIFO was overflown, set aes_cfg-enable=0 to
                                                     reset this bit Note: overflow is only a theoretical FIFO
                                                     status, because the hardware logic of the AES core won't
                                                     put data into the FIFO when it's full.                                    */
    } aes_stat_b;
  } ;
  
  union {
    __IOM uint32_t aes_irq_raw;                 /*!< (@ 0x00000008) AES raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit.                                                       */
    
    struct {
      __IOM uint32_t key_exp_ready : 1;         /*!< [0..0] Set when key expansion procedure is done                           */
      __IOM uint32_t op_ready   : 1;            /*!< [1..1] Set when AES operation ready, i.e. AES core not busy
                                                     and input FIFO is empty                                                   */
      __IOM uint32_t in_fifo_wm : 1;            /*!< [2..2] Fill level of input FIFO is below or equal watermark
                                                     (see crypt_aes_cfg bits 'in_fifo_wm')                                     */
      __IOM uint32_t in_fifo_empty : 1;         /*!< [3..3] Input FIFO is empty                                                */
      __IOM uint32_t in_fifo_not_empty : 1;     /*!< [4..4] Input FIFO is not empty                                            */
      __IOM uint32_t in_fifo_full : 1;          /*!< [5..5] Input FIFO is full                                                 */
      __IOM uint32_t in_fifo_not_full : 1;      /*!< [6..6] Input FIFO is not full                                             */
      __IOM uint32_t in_fifo_underrun : 1;      /*!< [7..7] Input FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit Note: underrun is only a theoretical FIFO status,
                                                     because the hardware logic of the AES core won't fetch
                                                     data from the FIFO when it's empty.                                       */
      __IOM uint32_t in_fifo_overflow : 1;      /*!< [8..8] Input FIFO was overflown, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t out_fifo_wm : 1;           /*!< [9..9] Fill level of output FIFO is above watermark (see crypt_aes_cfg
                                                     bits 'out_fifo_wm')                                                       */
      __IOM uint32_t out_fifo_empty : 1;        /*!< [10..10] Output FIFO is empty                                             */
      __IOM uint32_t out_fifo_not_empty : 1;    /*!< [11..11] Output FIFO is not empty                                         */
      __IOM uint32_t out_fifo_full : 1;         /*!< [12..12] Output FIFO is full                                              */
      __IOM uint32_t out_fifo_not_full : 1;     /*!< [13..13] Output FIFO is not full                                          */
      __IOM uint32_t out_fifo_underrun : 1;     /*!< [14..14] Output FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t out_fifo_overflow : 1;     /*!< [15..15] Output FIFO was overflown, set aes_cfg-enable=0 to
                                                     reset this bit Note: overflow is only a theoretical FIFO
                                                     status, because the hardware logic of the AES core won't
                                                     put data into the FIFO when it's full.                                    */
    } aes_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t aes_irq_masked;              /*!< (@ 0x0000000C) AES masked IRQ: Shows status of masked IRQs.               */
    
    struct {
      __IM  uint32_t key_exp_ready : 1;         /*!< [0..0] Set when key expansion procedure is done                           */
      __IM  uint32_t op_ready   : 1;            /*!< [1..1] Set when AES operation ready, i.e. AES core not busy
                                                     and input FIFO is empty                                                   */
      __IM  uint32_t in_fifo_wm : 1;            /*!< [2..2] Fill level of input FIFO is below or equal watermark
                                                     (see crypt_aes_cfg bits 'in_fifo_wm')                                     */
      __IM  uint32_t in_fifo_empty : 1;         /*!< [3..3] Input FIFO is empty                                                */
      __IM  uint32_t in_fifo_not_empty : 1;     /*!< [4..4] Input FIFO is not empty                                            */
      __IM  uint32_t in_fifo_full : 1;          /*!< [5..5] Input FIFO is full                                                 */
      __IM  uint32_t in_fifo_not_full : 1;      /*!< [6..6] Input FIFO is not full                                             */
      __IM  uint32_t in_fifo_underrun : 1;      /*!< [7..7] Input FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IM  uint32_t in_fifo_overflow : 1;      /*!< [8..8] Input FIFO was overflown, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IM  uint32_t out_fifo_wm : 1;           /*!< [9..9] Fill level of output FIFO is above watermark (see crypt_aes_cfg
                                                     bits 'out_fifo_wm')                                                       */
      __IM  uint32_t out_fifo_empty : 1;        /*!< [10..10] Output FIFO is empty                                             */
      __IM  uint32_t out_fifo_not_empty : 1;    /*!< [11..11] Output FIFO is not empty                                         */
      __IM  uint32_t out_fifo_full : 1;         /*!< [12..12] Output FIFO is full                                              */
      __IM  uint32_t out_fifo_not_full : 1;     /*!< [13..13] Output FIFO is not full                                          */
      __IM  uint32_t out_fifo_underrun : 1;     /*!< [14..14] Output FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IM  uint32_t out_fifo_overflow : 1;     /*!< [15..15] Output FIFO was overflown, set aes_cfg-enable=0 to
                                                     reset this bit                                                            */
    } aes_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t aes_irq_msk_set;             /*!< (@ 0x00000010) AES IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to crypt_aes_irq_raw.            */
    
    struct {
      __IOM uint32_t key_exp_ready : 1;         /*!< [0..0] Set when key expansion procedure is done                           */
      __IOM uint32_t op_ready   : 1;            /*!< [1..1] Set when AES operation ready, i.e. AES core not busy
                                                     and input FIFO is empty                                                   */
      __IOM uint32_t in_fifo_wm : 1;            /*!< [2..2] Fill level of input FIFO is below or equal watermark
                                                     (see crypt_aes_cfg bits 'in_fifo_wm')                                     */
      __IOM uint32_t in_fifo_empty : 1;         /*!< [3..3] Input FIFO is empty                                                */
      __IOM uint32_t in_fifo_not_empty : 1;     /*!< [4..4] Input FIFO is not empty                                            */
      __IOM uint32_t in_fifo_full : 1;          /*!< [5..5] Input FIFO is full                                                 */
      __IOM uint32_t in_fifo_not_full : 1;      /*!< [6..6] Input FIFO is not full                                             */
      __IOM uint32_t in_fifo_underrun : 1;      /*!< [7..7] Input FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t in_fifo_overflow : 1;      /*!< [8..8] Input FIFO was overflown, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t out_fifo_wm : 1;           /*!< [9..9] Fill level of output FIFO is above watermark (see crypt_aes_cfg
                                                     bits 'out_fifo_wm')                                                       */
      __IOM uint32_t out_fifo_empty : 1;        /*!< [10..10] Output FIFO is empty                                             */
      __IOM uint32_t out_fifo_not_empty : 1;    /*!< [11..11] Output FIFO is not empty                                         */
      __IOM uint32_t out_fifo_full : 1;         /*!< [12..12] Output FIFO is full                                              */
      __IOM uint32_t out_fifo_not_full : 1;     /*!< [13..13] Output FIFO is not full                                          */
      __IOM uint32_t out_fifo_underrun : 1;     /*!< [14..14] Output FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t out_fifo_overflow : 1;     /*!< [15..15] Output FIFO was overflown, set aes_cfg-enable=0 to
                                                     reset this bit                                                            */
    } aes_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t aes_irq_msk_reset;           /*!< (@ 0x00000014) AES IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t key_exp_ready : 1;         /*!< [0..0] Set when key expansion procedure is done                           */
      __IOM uint32_t op_ready   : 1;            /*!< [1..1] Set when AES operation ready, i.e. AES core not busy
                                                     and input FIFO is empty                                                   */
      __IOM uint32_t in_fifo_wm : 1;            /*!< [2..2] Fill level of input FIFO is below or equal watermark
                                                     (see crypt_aes_cfg bits 'in_fifo_wm')                                     */
      __IOM uint32_t in_fifo_empty : 1;         /*!< [3..3] Input FIFO is empty                                                */
      __IOM uint32_t in_fifo_not_empty : 1;     /*!< [4..4] Input FIFO is not empty                                            */
      __IOM uint32_t in_fifo_full : 1;          /*!< [5..5] Input FIFO is full                                                 */
      __IOM uint32_t in_fifo_not_full : 1;      /*!< [6..6] Input FIFO is not full                                             */
      __IOM uint32_t in_fifo_underrun : 1;      /*!< [7..7] Input FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t in_fifo_overflow : 1;      /*!< [8..8] Input FIFO was overflown, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t out_fifo_wm : 1;           /*!< [9..9] Fill level of output FIFO is above watermark (see crypt_aes_cfg
                                                     bits 'out_fifo_wm')                                                       */
      __IOM uint32_t out_fifo_empty : 1;        /*!< [10..10] Output FIFO is empty                                             */
      __IOM uint32_t out_fifo_not_empty : 1;    /*!< [11..11] Output FIFO is not empty                                         */
      __IOM uint32_t out_fifo_full : 1;         /*!< [12..12] Output FIFO is full                                              */
      __IOM uint32_t out_fifo_not_full : 1;     /*!< [13..13] Output FIFO is not full                                          */
      __IOM uint32_t out_fifo_underrun : 1;     /*!< [14..14] Output FIFO was underrun, set aes_cfg-enable=0 to reset
                                                     this bit                                                                  */
      __IOM uint32_t out_fifo_overflow : 1;     /*!< [15..15] Output FIFO was overflown, set aes_cfg-enable=0 to
                                                     reset this bit                                                            */
    } aes_irq_msk_reset_b;
  } ;
  
  union {
    __IOM uint32_t aes_key0;                    /*!< (@ 0x00000018) AES key register 0                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 31..0                                                    */
    } aes_key0_b;
  } ;
  
  union {
    __IOM uint32_t aes_key1;                    /*!< (@ 0x0000001C) AES key register 1                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 63..32                                                   */
    } aes_key1_b;
  } ;
  
  union {
    __IOM uint32_t aes_key2;                    /*!< (@ 0x00000020) AES key register 2                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 95..64                                                   */
    } aes_key2_b;
  } ;
  
  union {
    __IOM uint32_t aes_key3;                    /*!< (@ 0x00000024) AES key register 3                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 127..96                                                  */
    } aes_key3_b;
  } ;
  
  union {
    __IOM uint32_t aes_key4;                    /*!< (@ 0x00000028) AES key register 4                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 159..128                                                 */
    } aes_key4_b;
  } ;
  
  union {
    __IOM uint32_t aes_key5;                    /*!< (@ 0x0000002C) AES key register 5                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 191..160                                                 */
    } aes_key5_b;
  } ;
  
  union {
    __IOM uint32_t aes_key6;                    /*!< (@ 0x00000030) AES key register 6                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 223..192                                                 */
    } aes_key6_b;
  } ;
  
  union {
    __IOM uint32_t aes_key7;                    /*!< (@ 0x00000034) AES key register 7                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] key bits 255..224                                                 */
    } aes_key7_b;
  } ;
  
  union {
    __OM  uint32_t aes_din;                     /*!< (@ 0x00000038) AES FIFO input Unlike all other registers, this
                                                                    address can be written with DWord(32 Bit),
                                                                    Word(16 Bit) or Byte acccss. The FIFO controller
                                                                    will automatically collect data and start
                                                                    AES-calculation, if enough data (4 DWords)
                                                                    are collected.                                             */
    
    struct {
      __OM  uint32_t val        : 32;           /*!< [31..0] data bits                                                         */
    } aes_din_b;
  } ;
  
  union {
    __IM  uint32_t aes_dout;                    /*!< (@ 0x0000003C) AES FIFO output                                            */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data bits                                                         */
    } aes_dout_b;
  } ;
} aes_Type;                                     /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                          random                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief random (random)
  */

typedef struct {                                /*!< (@ 0xFF0800C0) random Structure                                           */
  
  union {
    __IOM uint32_t random_init;                 /*!< (@ 0x00000000) Random initialization value: Write a value depending
                                                                    on Chip ID to this register to generate
                                                                    a random sequence different for each netX.                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] random init value                                                 */
    } random_init_b;
  } ;
  
  union {
    __IM  uint32_t random_random;               /*!< (@ 0x00000004) Random value: This random value sequence is derived
                                                                    from many random events inside netX chip.                  */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] random value                                                      */
    } random_random_b;
  } ;
} random_Type;                                  /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                           mtgy                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief mtgy (mtgy)
  */

typedef struct {                                /*!< (@ 0xFF082000) mtgy Structure                                             */
  
  union {
    __IOM uint32_t mtgy_cmd;                    /*!< (@ 0x00000000) MWMM command register:                                     */
    
    struct {
      __IOM uint32_t start      : 1;            /*!< [0..0] Start Signal of the MWMM Core. Setting this signal will
                                                     instruct the Core to start the operation given by 'op'
                                                     with precision specified by 'precision'. Depending on the
                                                     operation the core will use the RAM location specified
                                                     by 'src_addr', 'dest_addr', 'src_addr_e' and 'src_addr_x'.
                                                     Calculations will be performed in the underlying finite
                                                     field specified by 'f_sel'. After writing '1', this bit
                                                     will automatically be reset.                                              */
      __IOM uint32_t abort      : 1;            /*!< [1..1] Abort Signal of the MWMM Core. A running calculation
                                                     can be aborted by issuing this signal. After writing '1',
                                                     this bit will automatically be reset.                                     */
      __IOM uint32_t f_sel      : 1;            /*!< [2..2] Finite Field Selection signal. Defines if the calculations
                                                     will be performed in 1: GF(p) or 0: GF(2^m).                              */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t precision  : 4;            /*!< [7..4] Precision of executed operations. 0: 192 bit 1: 224 bit
                                                     2: 256 bit 3: 320 bit 4: 384 bit 5: 512 bit 6: 768 bit
                                                     7: 1024 bit 8: 1536 bit 9: 2048 bit 10: 3072 bit 11: 4096
                                                     bit 15 - 12: reserved                                                     */
      __IOM uint32_t op         : 4;            /*!< [11..8] The operation code of the core. Following operations
                                                     codes are supported: 0: MontMult (Montgomery Multiplication
                                                     Step) 1: MontR (Montgomery Parameter R) 2: MontR2 (Montgomery
                                                     Parameter R2 ) 3: MontExp (Montgomery Exponentiation Step)
                                                     4: ModAdd (Modular Addition) 5: ModSub (Modular Subtraction)
                                                     6: CopyH2V (Copy from horizontal to vertical RAM location)
                                                     7: CopyV2V (Copy from vertical to vertical RAM location)
                                                     8: CopyH2H (Copy from horizontal to horizontal RAM location)
                                                     9: CopyV2H (Copy from vertical to horiz                                   */
      __IOM uint32_t src_addr   : 5;            /*!< [16..12] Source Address specification. Depending on the operation
                                                     the source address specification will be interpreted as
                                                     horizontal or vertical RAM location offset.                               */
      __IOM uint32_t dest_addr  : 5;            /*!< [21..17] Destination Address / Source Address A specification.
                                                     Depending on the operation the destination address specification
                                                     will be interpreted as horizontal or vertical RAM location
                                                     offset or as vertical RAM location source address offset
                                                     of operand A.                                                             */
      __IOM uint32_t src_addr_e : 5;            /*!< [26..22] Source Address E specification. The source address
                                                     E specification will be interpreted as vertical RAM location
                                                     source address offset of exponent E.                                      */
      __IOM uint32_t src_addr_x : 5;            /*!< [31..27] Source address X specification. The source address
                                                     X specification will be interpreted as vertical RAM location
                                                     source address offset of auxiliary operand E.                             */
    } mtgy_cmd_b;
  } ;
  
  union {
    __IM  uint32_t mtgy_stat;                   /*!< (@ 0x00000004) MWMM status register:                                      */
    
    struct {
      __IM  uint32_t done       : 1;            /*!< [0..0] Done signal from the MWMM core.                                    */
    } mtgy_stat_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_irq_raw;                /*!< (@ 0x00000008) MWMM raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit.                                                       */
    
    struct {
      __IOM uint32_t done       : 1;            /*!< [0..0] Done signal from the MWMM core. Only a posedge on this
                                                     signal will set the interrupt.                                            */
    } mtgy_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t mtgy_irq_masked;             /*!< (@ 0x0000000C) MWMM masked IRQ: Shows status of masked IRQs.              */
    
    struct {
      __IM  uint32_t done       : 1;            /*!< [0..0] Done signal from the MWMM core.                                    */
    } mtgy_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_irq_msk_set;            /*!< (@ 0x00000010) MWMM IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to mtgy_irq_raw.                 */
    
    struct {
      __IOM uint32_t done       : 1;            /*!< [0..0] Done signal from the MWMM core.                                    */
    } mtgy_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_irq_msk_reset;          /*!< (@ 0x00000014) MWMM IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t done       : 1;            /*!< [0..0] Done signal from the MWMM core.                                    */
    } mtgy_irq_msk_reset_b;
  } ;
  __IM  uint32_t  RESERVED[1018];
  
  union {
    __IOM uint32_t mtgy_op_tc0;                 /*!< (@ 0x00001000) MWMM TC register 0                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } mtgy_op_tc0_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc1;                 /*!< (@ 0x00001004) MWMM TC register 1                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } mtgy_op_tc1_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc2;                 /*!< (@ 0x00001008) MWMM TC register 2                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } mtgy_op_tc2_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc3;                 /*!< (@ 0x0000100C) MWMM TC register 3                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } mtgy_op_tc3_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc4;                 /*!< (@ 0x00001010) MWMM TC register 4                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } mtgy_op_tc4_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc5;                 /*!< (@ 0x00001014) MWMM TC register 5                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } mtgy_op_tc5_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc6;                 /*!< (@ 0x00001018) MWMM TC register 6                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } mtgy_op_tc6_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc7;                 /*!< (@ 0x0000101C) MWMM TC register 7                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } mtgy_op_tc7_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc8;                 /*!< (@ 0x00001020) MWMM TC register 8                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } mtgy_op_tc8_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc9;                 /*!< (@ 0x00001024) MWMM TC register 9                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } mtgy_op_tc9_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc10;                /*!< (@ 0x00001028) MWMM TC register 10                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } mtgy_op_tc10_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc11;                /*!< (@ 0x0000102C) MWMM TC register 11                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } mtgy_op_tc11_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc12;                /*!< (@ 0x00001030) MWMM TC register 12                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } mtgy_op_tc12_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc13;                /*!< (@ 0x00001034) MWMM TC register 13                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } mtgy_op_tc13_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc14;                /*!< (@ 0x00001038) MWMM TC register 14                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } mtgy_op_tc14_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc15;                /*!< (@ 0x0000103C) MWMM TC register 15                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } mtgy_op_tc15_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc16;                /*!< (@ 0x00001040) MWMM TC register 16                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 543..512                                                */
    } mtgy_op_tc16_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc17;                /*!< (@ 0x00001044) MWMM TC register 17                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 575..544                                                */
    } mtgy_op_tc17_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc18;                /*!< (@ 0x00001048) MWMM TC register 18                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 607..576                                                */
    } mtgy_op_tc18_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc19;                /*!< (@ 0x0000104C) MWMM TC register 19                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 639..608                                                */
    } mtgy_op_tc19_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc20;                /*!< (@ 0x00001050) MWMM TC register 20                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 671..640                                                */
    } mtgy_op_tc20_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc21;                /*!< (@ 0x00001054) MWMM TC register 21                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 703..672                                                */
    } mtgy_op_tc21_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc22;                /*!< (@ 0x00001058) MWMM TC register 22                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 735..704                                                */
    } mtgy_op_tc22_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc23;                /*!< (@ 0x0000105C) MWMM TC register 23                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 767..736                                                */
    } mtgy_op_tc23_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc24;                /*!< (@ 0x00001060) MWMM TC register 24                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 799..768                                                */
    } mtgy_op_tc24_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc25;                /*!< (@ 0x00001064) MWMM TC register 25                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 831..800                                                */
    } mtgy_op_tc25_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc26;                /*!< (@ 0x00001068) MWMM TC register 26                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 863..832                                                */
    } mtgy_op_tc26_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc27;                /*!< (@ 0x0000106C) MWMM TC register 27                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 895..864                                                */
    } mtgy_op_tc27_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc28;                /*!< (@ 0x00001070) MWMM TC register 28                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 927..896                                                */
    } mtgy_op_tc28_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc29;                /*!< (@ 0x00001074) MWMM TC register 29                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 959..928                                                */
    } mtgy_op_tc29_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc30;                /*!< (@ 0x00001078) MWMM TC register 30                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 991..960                                                */
    } mtgy_op_tc30_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc31;                /*!< (@ 0x0000107C) MWMM TC register 31                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1023..992                                               */
    } mtgy_op_tc31_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc32;                /*!< (@ 0x00001080) MWMM TC register 32                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1055..1024                                              */
    } mtgy_op_tc32_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc33;                /*!< (@ 0x00001084) MWMM TC register 33                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1087..1056                                              */
    } mtgy_op_tc33_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc34;                /*!< (@ 0x00001088) MWMM TC register 34                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1119..1088                                              */
    } mtgy_op_tc34_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc35;                /*!< (@ 0x0000108C) MWMM TC register 35                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1151..1120                                              */
    } mtgy_op_tc35_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc36;                /*!< (@ 0x00001090) MWMM TC register 36                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1183..1152                                              */
    } mtgy_op_tc36_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc37;                /*!< (@ 0x00001094) MWMM TC register 37                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1215..1184                                              */
    } mtgy_op_tc37_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc38;                /*!< (@ 0x00001098) MWMM TC register 38                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1247..1216                                              */
    } mtgy_op_tc38_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc39;                /*!< (@ 0x0000109C) MWMM TC register 39                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1279..1248                                              */
    } mtgy_op_tc39_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc40;                /*!< (@ 0x000010A0) MWMM TC register 40                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1311..1280                                              */
    } mtgy_op_tc40_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc41;                /*!< (@ 0x000010A4) MWMM TC register 41                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1343..1312                                              */
    } mtgy_op_tc41_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc42;                /*!< (@ 0x000010A8) MWMM TC register 42                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1375..1344                                              */
    } mtgy_op_tc42_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc43;                /*!< (@ 0x000010AC) MWMM TC register 43                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1407..1376                                              */
    } mtgy_op_tc43_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc44;                /*!< (@ 0x000010B0) MWMM TC register 44                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1439..1408                                              */
    } mtgy_op_tc44_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc45;                /*!< (@ 0x000010B4) MWMM TC register 45                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1471..1440                                              */
    } mtgy_op_tc45_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc46;                /*!< (@ 0x000010B8) MWMM TC register 46                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1503..1472                                              */
    } mtgy_op_tc46_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc47;                /*!< (@ 0x000010BC) MWMM TC register 47                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1535..1504                                              */
    } mtgy_op_tc47_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc48;                /*!< (@ 0x000010C0) MWMM TC register 48                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1567..1536                                              */
    } mtgy_op_tc48_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc49;                /*!< (@ 0x000010C4) MWMM TC register 49                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1599..1568                                              */
    } mtgy_op_tc49_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc50;                /*!< (@ 0x000010C8) MWMM TC register 50                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1631..1600                                              */
    } mtgy_op_tc50_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc51;                /*!< (@ 0x000010CC) MWMM TC register 51                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1663..1632                                              */
    } mtgy_op_tc51_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc52;                /*!< (@ 0x000010D0) MWMM TC register 52                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1695..1664                                              */
    } mtgy_op_tc52_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc53;                /*!< (@ 0x000010D4) MWMM TC register 53                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1727..1696                                              */
    } mtgy_op_tc53_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc54;                /*!< (@ 0x000010D8) MWMM TC register 54                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1759..1728                                              */
    } mtgy_op_tc54_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc55;                /*!< (@ 0x000010DC) MWMM TC register 55                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1791..1760                                              */
    } mtgy_op_tc55_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc56;                /*!< (@ 0x000010E0) MWMM TC register 56                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1823..1792                                              */
    } mtgy_op_tc56_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc57;                /*!< (@ 0x000010E4) MWMM TC register 57                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1855..1824                                              */
    } mtgy_op_tc57_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc58;                /*!< (@ 0x000010E8) MWMM TC register 58                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1887..1856                                              */
    } mtgy_op_tc58_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc59;                /*!< (@ 0x000010EC) MWMM TC register 59                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1919..1888                                              */
    } mtgy_op_tc59_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc60;                /*!< (@ 0x000010F0) MWMM TC register 60                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1951..1920                                              */
    } mtgy_op_tc60_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc61;                /*!< (@ 0x000010F4) MWMM TC register 61                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1983..1952                                              */
    } mtgy_op_tc61_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc62;                /*!< (@ 0x000010F8) MWMM TC register 62                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2015..1984                                              */
    } mtgy_op_tc62_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc63;                /*!< (@ 0x000010FC) MWMM TC register 63                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2047..2016                                              */
    } mtgy_op_tc63_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc64;                /*!< (@ 0x00001100) MWMM TC register 64                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2079..2048                                              */
    } mtgy_op_tc64_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc65;                /*!< (@ 0x00001104) MWMM TC register 65                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2111..2080                                              */
    } mtgy_op_tc65_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc66;                /*!< (@ 0x00001108) MWMM TC register 66                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2143..2112                                              */
    } mtgy_op_tc66_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc67;                /*!< (@ 0x0000110C) MWMM TC register 67                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2175..2144                                              */
    } mtgy_op_tc67_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc68;                /*!< (@ 0x00001110) MWMM TC register 68                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2207..2176                                              */
    } mtgy_op_tc68_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc69;                /*!< (@ 0x00001114) MWMM TC register 69                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2239..2208                                              */
    } mtgy_op_tc69_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc70;                /*!< (@ 0x00001118) MWMM TC register 70                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2271..2240                                              */
    } mtgy_op_tc70_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc71;                /*!< (@ 0x0000111C) MWMM TC register 71                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2303..2272                                              */
    } mtgy_op_tc71_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc72;                /*!< (@ 0x00001120) MWMM TC register 72                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2335..2304                                              */
    } mtgy_op_tc72_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc73;                /*!< (@ 0x00001124) MWMM TC register 73                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2367..2336                                              */
    } mtgy_op_tc73_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc74;                /*!< (@ 0x00001128) MWMM TC register 74                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2399..2368                                              */
    } mtgy_op_tc74_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc75;                /*!< (@ 0x0000112C) MWMM TC register 75                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2431..2400                                              */
    } mtgy_op_tc75_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc76;                /*!< (@ 0x00001130) MWMM TC register 76                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2463..2432                                              */
    } mtgy_op_tc76_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc77;                /*!< (@ 0x00001134) MWMM TC register 77                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2495..2464                                              */
    } mtgy_op_tc77_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc78;                /*!< (@ 0x00001138) MWMM TC register 78                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2527..2496                                              */
    } mtgy_op_tc78_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc79;                /*!< (@ 0x0000113C) MWMM TC register 79                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2559..2528                                              */
    } mtgy_op_tc79_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc80;                /*!< (@ 0x00001140) MWMM TC register 80                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2591..2560                                              */
    } mtgy_op_tc80_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc81;                /*!< (@ 0x00001144) MWMM TC register 81                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2623..2592                                              */
    } mtgy_op_tc81_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc82;                /*!< (@ 0x00001148) MWMM TC register 82                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2655..2624                                              */
    } mtgy_op_tc82_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc83;                /*!< (@ 0x0000114C) MWMM TC register 83                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2687..2656                                              */
    } mtgy_op_tc83_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc84;                /*!< (@ 0x00001150) MWMM TC register 84                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2719..2688                                              */
    } mtgy_op_tc84_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc85;                /*!< (@ 0x00001154) MWMM TC register 85                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2751..2720                                              */
    } mtgy_op_tc85_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc86;                /*!< (@ 0x00001158) MWMM TC register 86                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2783..2752                                              */
    } mtgy_op_tc86_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc87;                /*!< (@ 0x0000115C) MWMM TC register 87                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2815..2784                                              */
    } mtgy_op_tc87_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc88;                /*!< (@ 0x00001160) MWMM TC register 88                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2847..2816                                              */
    } mtgy_op_tc88_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc89;                /*!< (@ 0x00001164) MWMM TC register 89                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2879..2848                                              */
    } mtgy_op_tc89_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc90;                /*!< (@ 0x00001168) MWMM TC register 90                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2911..2880                                              */
    } mtgy_op_tc90_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc91;                /*!< (@ 0x0000116C) MWMM TC register 91                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2943..2912                                              */
    } mtgy_op_tc91_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc92;                /*!< (@ 0x00001170) MWMM TC register 92                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2975..2944                                              */
    } mtgy_op_tc92_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc93;                /*!< (@ 0x00001174) MWMM TC register 93                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3007..2976                                              */
    } mtgy_op_tc93_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc94;                /*!< (@ 0x00001178) MWMM TC register 94                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3039..3008                                              */
    } mtgy_op_tc94_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc95;                /*!< (@ 0x0000117C) MWMM TC register 95                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3071..3040                                              */
    } mtgy_op_tc95_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc96;                /*!< (@ 0x00001180) MWMM TC register 96                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3103..3072                                              */
    } mtgy_op_tc96_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc97;                /*!< (@ 0x00001184) MWMM TC register 97                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3135..3104                                              */
    } mtgy_op_tc97_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc98;                /*!< (@ 0x00001188) MWMM TC register 98                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3167..3136                                              */
    } mtgy_op_tc98_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc99;                /*!< (@ 0x0000118C) MWMM TC register 99                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3199..3168                                              */
    } mtgy_op_tc99_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc100;               /*!< (@ 0x00001190) MWMM TC register 100                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3231..3200                                              */
    } mtgy_op_tc100_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc101;               /*!< (@ 0x00001194) MWMM TC register 101                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3263..3232                                              */
    } mtgy_op_tc101_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc102;               /*!< (@ 0x00001198) MWMM TC register 102                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3295..3264                                              */
    } mtgy_op_tc102_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc103;               /*!< (@ 0x0000119C) MWMM TC register 103                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3327..3296                                              */
    } mtgy_op_tc103_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc104;               /*!< (@ 0x000011A0) MWMM TC register 104                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3359..3328                                              */
    } mtgy_op_tc104_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc105;               /*!< (@ 0x000011A4) MWMM TC register 105                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3391..3360                                              */
    } mtgy_op_tc105_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc106;               /*!< (@ 0x000011A8) MWMM TC register 106                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3423..3392                                              */
    } mtgy_op_tc106_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc107;               /*!< (@ 0x000011AC) MWMM TC register 107                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3455..3424                                              */
    } mtgy_op_tc107_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc108;               /*!< (@ 0x000011B0) MWMM TC register 108                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3487..3456                                              */
    } mtgy_op_tc108_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc109;               /*!< (@ 0x000011B4) MWMM TC register 109                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3519..3488                                              */
    } mtgy_op_tc109_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc110;               /*!< (@ 0x000011B8) MWMM TC register 110                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3551..3520                                              */
    } mtgy_op_tc110_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc111;               /*!< (@ 0x000011BC) MWMM TC register 111                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3583..3552                                              */
    } mtgy_op_tc111_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc112;               /*!< (@ 0x000011C0) MWMM TC register 112                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3615..3584                                              */
    } mtgy_op_tc112_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc113;               /*!< (@ 0x000011C4) MWMM TC register 113                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3647..3616                                              */
    } mtgy_op_tc113_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc114;               /*!< (@ 0x000011C8) MWMM TC register 114                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3679..3648                                              */
    } mtgy_op_tc114_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc115;               /*!< (@ 0x000011CC) MWMM TC register 115                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3711..3680                                              */
    } mtgy_op_tc115_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc116;               /*!< (@ 0x000011D0) MWMM TC register 116                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3743..3712                                              */
    } mtgy_op_tc116_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc117;               /*!< (@ 0x000011D4) MWMM TC register 117                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3775..3744                                              */
    } mtgy_op_tc117_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc118;               /*!< (@ 0x000011D8) MWMM TC register 118                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3807..3776                                              */
    } mtgy_op_tc118_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc119;               /*!< (@ 0x000011DC) MWMM TC register 119                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3839..3808                                              */
    } mtgy_op_tc119_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc120;               /*!< (@ 0x000011E0) MWMM TC register 120                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3871..3840                                              */
    } mtgy_op_tc120_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc121;               /*!< (@ 0x000011E4) MWMM TC register 121                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3903..3872                                              */
    } mtgy_op_tc121_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc122;               /*!< (@ 0x000011E8) MWMM TC register 122                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3935..3904                                              */
    } mtgy_op_tc122_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc123;               /*!< (@ 0x000011EC) MWMM TC register 123                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3967..3936                                              */
    } mtgy_op_tc123_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc124;               /*!< (@ 0x000011F0) MWMM TC register 124                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3999..3968                                              */
    } mtgy_op_tc124_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc125;               /*!< (@ 0x000011F4) MWMM TC register 125                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4031..4000                                              */
    } mtgy_op_tc125_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc126;               /*!< (@ 0x000011F8) MWMM TC register 126                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4063..4032                                              */
    } mtgy_op_tc126_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_tc127;               /*!< (@ 0x000011FC) MWMM TC register 127                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4095..4064                                              */
    } mtgy_op_tc127_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts0;                 /*!< (@ 0x00001200) MWMM TS register 0                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } mtgy_op_ts0_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts1;                 /*!< (@ 0x00001204) MWMM TS register 1                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } mtgy_op_ts1_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts2;                 /*!< (@ 0x00001208) MWMM TS register 2                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } mtgy_op_ts2_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts3;                 /*!< (@ 0x0000120C) MWMM TS register 3                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } mtgy_op_ts3_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts4;                 /*!< (@ 0x00001210) MWMM TS register 4                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } mtgy_op_ts4_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts5;                 /*!< (@ 0x00001214) MWMM TS register 5                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } mtgy_op_ts5_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts6;                 /*!< (@ 0x00001218) MWMM TS register 6                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } mtgy_op_ts6_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts7;                 /*!< (@ 0x0000121C) MWMM TS register 7                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } mtgy_op_ts7_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts8;                 /*!< (@ 0x00001220) MWMM TS register 8                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } mtgy_op_ts8_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts9;                 /*!< (@ 0x00001224) MWMM TS register 9                                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } mtgy_op_ts9_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts10;                /*!< (@ 0x00001228) MWMM TS register 10                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } mtgy_op_ts10_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts11;                /*!< (@ 0x0000122C) MWMM TS register 11                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } mtgy_op_ts11_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts12;                /*!< (@ 0x00001230) MWMM TS register 12                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } mtgy_op_ts12_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts13;                /*!< (@ 0x00001234) MWMM TS register 13                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } mtgy_op_ts13_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts14;                /*!< (@ 0x00001238) MWMM TS register 14                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } mtgy_op_ts14_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts15;                /*!< (@ 0x0000123C) MWMM TS register 15                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } mtgy_op_ts15_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts16;                /*!< (@ 0x00001240) MWMM TS register 16                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 543..512                                                */
    } mtgy_op_ts16_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts17;                /*!< (@ 0x00001244) MWMM TS register 17                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 575..544                                                */
    } mtgy_op_ts17_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts18;                /*!< (@ 0x00001248) MWMM TS register 18                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 607..576                                                */
    } mtgy_op_ts18_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts19;                /*!< (@ 0x0000124C) MWMM TS register 19                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 639..608                                                */
    } mtgy_op_ts19_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts20;                /*!< (@ 0x00001250) MWMM TS register 20                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 671..640                                                */
    } mtgy_op_ts20_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts21;                /*!< (@ 0x00001254) MWMM TS register 21                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 703..672                                                */
    } mtgy_op_ts21_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts22;                /*!< (@ 0x00001258) MWMM TS register 22                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 735..704                                                */
    } mtgy_op_ts22_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts23;                /*!< (@ 0x0000125C) MWMM TS register 23                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 767..736                                                */
    } mtgy_op_ts23_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts24;                /*!< (@ 0x00001260) MWMM TS register 24                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 799..768                                                */
    } mtgy_op_ts24_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts25;                /*!< (@ 0x00001264) MWMM TS register 25                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 831..800                                                */
    } mtgy_op_ts25_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts26;                /*!< (@ 0x00001268) MWMM TS register 26                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 863..832                                                */
    } mtgy_op_ts26_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts27;                /*!< (@ 0x0000126C) MWMM TS register 27                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 895..864                                                */
    } mtgy_op_ts27_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts28;                /*!< (@ 0x00001270) MWMM TS register 28                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 927..896                                                */
    } mtgy_op_ts28_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts29;                /*!< (@ 0x00001274) MWMM TS register 29                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 959..928                                                */
    } mtgy_op_ts29_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts30;                /*!< (@ 0x00001278) MWMM TS register 30                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 991..960                                                */
    } mtgy_op_ts30_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts31;                /*!< (@ 0x0000127C) MWMM TS register 31                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1023..992                                               */
    } mtgy_op_ts31_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts32;                /*!< (@ 0x00001280) MWMM TS register 32                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1055..1024                                              */
    } mtgy_op_ts32_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts33;                /*!< (@ 0x00001284) MWMM TS register 33                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1087..1056                                              */
    } mtgy_op_ts33_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts34;                /*!< (@ 0x00001288) MWMM TS register 34                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1119..1088                                              */
    } mtgy_op_ts34_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts35;                /*!< (@ 0x0000128C) MWMM TS register 35                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1151..1120                                              */
    } mtgy_op_ts35_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts36;                /*!< (@ 0x00001290) MWMM TS register 36                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1183..1152                                              */
    } mtgy_op_ts36_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts37;                /*!< (@ 0x00001294) MWMM TS register 37                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1215..1184                                              */
    } mtgy_op_ts37_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts38;                /*!< (@ 0x00001298) MWMM TS register 38                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1247..1216                                              */
    } mtgy_op_ts38_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts39;                /*!< (@ 0x0000129C) MWMM TS register 39                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1279..1248                                              */
    } mtgy_op_ts39_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts40;                /*!< (@ 0x000012A0) MWMM TS register 40                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1311..1280                                              */
    } mtgy_op_ts40_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts41;                /*!< (@ 0x000012A4) MWMM TS register 41                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1343..1312                                              */
    } mtgy_op_ts41_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts42;                /*!< (@ 0x000012A8) MWMM TS register 42                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1375..1344                                              */
    } mtgy_op_ts42_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts43;                /*!< (@ 0x000012AC) MWMM TS register 43                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1407..1376                                              */
    } mtgy_op_ts43_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts44;                /*!< (@ 0x000012B0) MWMM TS register 44                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1439..1408                                              */
    } mtgy_op_ts44_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts45;                /*!< (@ 0x000012B4) MWMM TS register 45                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1471..1440                                              */
    } mtgy_op_ts45_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts46;                /*!< (@ 0x000012B8) MWMM TS register 46                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1503..1472                                              */
    } mtgy_op_ts46_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts47;                /*!< (@ 0x000012BC) MWMM TS register 47                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1535..1504                                              */
    } mtgy_op_ts47_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts48;                /*!< (@ 0x000012C0) MWMM TS register 48                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1567..1536                                              */
    } mtgy_op_ts48_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts49;                /*!< (@ 0x000012C4) MWMM TS register 49                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1599..1568                                              */
    } mtgy_op_ts49_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts50;                /*!< (@ 0x000012C8) MWMM TS register 50                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1631..1600                                              */
    } mtgy_op_ts50_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts51;                /*!< (@ 0x000012CC) MWMM TS register 51                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1663..1632                                              */
    } mtgy_op_ts51_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts52;                /*!< (@ 0x000012D0) MWMM TS register 52                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1695..1664                                              */
    } mtgy_op_ts52_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts53;                /*!< (@ 0x000012D4) MWMM TS register 53                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1727..1696                                              */
    } mtgy_op_ts53_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts54;                /*!< (@ 0x000012D8) MWMM TS register 54                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1759..1728                                              */
    } mtgy_op_ts54_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts55;                /*!< (@ 0x000012DC) MWMM TS register 55                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1791..1760                                              */
    } mtgy_op_ts55_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts56;                /*!< (@ 0x000012E0) MWMM TS register 56                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1823..1792                                              */
    } mtgy_op_ts56_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts57;                /*!< (@ 0x000012E4) MWMM TS register 57                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1855..1824                                              */
    } mtgy_op_ts57_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts58;                /*!< (@ 0x000012E8) MWMM TS register 58                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1887..1856                                              */
    } mtgy_op_ts58_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts59;                /*!< (@ 0x000012EC) MWMM TS register 59                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1919..1888                                              */
    } mtgy_op_ts59_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts60;                /*!< (@ 0x000012F0) MWMM TS register 60                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1951..1920                                              */
    } mtgy_op_ts60_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts61;                /*!< (@ 0x000012F4) MWMM TS register 61                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1983..1952                                              */
    } mtgy_op_ts61_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts62;                /*!< (@ 0x000012F8) MWMM TS register 62                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2015..1984                                              */
    } mtgy_op_ts62_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts63;                /*!< (@ 0x000012FC) MWMM TS register 63                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2047..2016                                              */
    } mtgy_op_ts63_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts64;                /*!< (@ 0x00001300) MWMM TS register 64                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2079..2048                                              */
    } mtgy_op_ts64_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts65;                /*!< (@ 0x00001304) MWMM TS register 65                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2111..2080                                              */
    } mtgy_op_ts65_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts66;                /*!< (@ 0x00001308) MWMM TS register 66                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2143..2112                                              */
    } mtgy_op_ts66_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts67;                /*!< (@ 0x0000130C) MWMM TS register 67                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2175..2144                                              */
    } mtgy_op_ts67_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts68;                /*!< (@ 0x00001310) MWMM TS register 68                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2207..2176                                              */
    } mtgy_op_ts68_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts69;                /*!< (@ 0x00001314) MWMM TS register 69                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2239..2208                                              */
    } mtgy_op_ts69_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts70;                /*!< (@ 0x00001318) MWMM TS register 70                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2271..2240                                              */
    } mtgy_op_ts70_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts71;                /*!< (@ 0x0000131C) MWMM TS register 71                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2303..2272                                              */
    } mtgy_op_ts71_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts72;                /*!< (@ 0x00001320) MWMM TS register 72                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2335..2304                                              */
    } mtgy_op_ts72_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts73;                /*!< (@ 0x00001324) MWMM TS register 73                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2367..2336                                              */
    } mtgy_op_ts73_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts74;                /*!< (@ 0x00001328) MWMM TS register 74                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2399..2368                                              */
    } mtgy_op_ts74_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts75;                /*!< (@ 0x0000132C) MWMM TS register 75                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2431..2400                                              */
    } mtgy_op_ts75_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts76;                /*!< (@ 0x00001330) MWMM TS register 76                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2463..2432                                              */
    } mtgy_op_ts76_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts77;                /*!< (@ 0x00001334) MWMM TS register 77                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2495..2464                                              */
    } mtgy_op_ts77_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts78;                /*!< (@ 0x00001338) MWMM TS register 78                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2527..2496                                              */
    } mtgy_op_ts78_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts79;                /*!< (@ 0x0000133C) MWMM TS register 79                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2559..2528                                              */
    } mtgy_op_ts79_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts80;                /*!< (@ 0x00001340) MWMM TS register 80                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2591..2560                                              */
    } mtgy_op_ts80_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts81;                /*!< (@ 0x00001344) MWMM TS register 81                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2623..2592                                              */
    } mtgy_op_ts81_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts82;                /*!< (@ 0x00001348) MWMM TS register 82                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2655..2624                                              */
    } mtgy_op_ts82_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts83;                /*!< (@ 0x0000134C) MWMM TS register 83                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2687..2656                                              */
    } mtgy_op_ts83_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts84;                /*!< (@ 0x00001350) MWMM TS register 84                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2719..2688                                              */
    } mtgy_op_ts84_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts85;                /*!< (@ 0x00001354) MWMM TS register 85                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2751..2720                                              */
    } mtgy_op_ts85_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts86;                /*!< (@ 0x00001358) MWMM TS register 86                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2783..2752                                              */
    } mtgy_op_ts86_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts87;                /*!< (@ 0x0000135C) MWMM TS register 87                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2815..2784                                              */
    } mtgy_op_ts87_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts88;                /*!< (@ 0x00001360) MWMM TS register 88                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2847..2816                                              */
    } mtgy_op_ts88_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts89;                /*!< (@ 0x00001364) MWMM TS register 89                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2879..2848                                              */
    } mtgy_op_ts89_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts90;                /*!< (@ 0x00001368) MWMM TS register 90                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2911..2880                                              */
    } mtgy_op_ts90_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts91;                /*!< (@ 0x0000136C) MWMM TS register 91                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2943..2912                                              */
    } mtgy_op_ts91_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts92;                /*!< (@ 0x00001370) MWMM TS register 92                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2975..2944                                              */
    } mtgy_op_ts92_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts93;                /*!< (@ 0x00001374) MWMM TS register 93                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3007..2976                                              */
    } mtgy_op_ts93_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts94;                /*!< (@ 0x00001378) MWMM TS register 94                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3039..3008                                              */
    } mtgy_op_ts94_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts95;                /*!< (@ 0x0000137C) MWMM TS register 95                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3071..3040                                              */
    } mtgy_op_ts95_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts96;                /*!< (@ 0x00001380) MWMM TS register 96                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3103..3072                                              */
    } mtgy_op_ts96_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts97;                /*!< (@ 0x00001384) MWMM TS register 97                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3135..3104                                              */
    } mtgy_op_ts97_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts98;                /*!< (@ 0x00001388) MWMM TS register 98                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3167..3136                                              */
    } mtgy_op_ts98_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts99;                /*!< (@ 0x0000138C) MWMM TS register 99                                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3199..3168                                              */
    } mtgy_op_ts99_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts100;               /*!< (@ 0x00001390) MWMM TS register 100                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3231..3200                                              */
    } mtgy_op_ts100_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts101;               /*!< (@ 0x00001394) MWMM TS register 101                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3263..3232                                              */
    } mtgy_op_ts101_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts102;               /*!< (@ 0x00001398) MWMM TS register 102                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3295..3264                                              */
    } mtgy_op_ts102_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts103;               /*!< (@ 0x0000139C) MWMM TS register 103                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3327..3296                                              */
    } mtgy_op_ts103_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts104;               /*!< (@ 0x000013A0) MWMM TS register 104                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3359..3328                                              */
    } mtgy_op_ts104_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts105;               /*!< (@ 0x000013A4) MWMM TS register 105                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3391..3360                                              */
    } mtgy_op_ts105_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts106;               /*!< (@ 0x000013A8) MWMM TS register 106                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3423..3392                                              */
    } mtgy_op_ts106_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts107;               /*!< (@ 0x000013AC) MWMM TS register 107                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3455..3424                                              */
    } mtgy_op_ts107_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts108;               /*!< (@ 0x000013B0) MWMM TS register 108                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3487..3456                                              */
    } mtgy_op_ts108_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts109;               /*!< (@ 0x000013B4) MWMM TS register 109                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3519..3488                                              */
    } mtgy_op_ts109_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts110;               /*!< (@ 0x000013B8) MWMM TS register 110                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3551..3520                                              */
    } mtgy_op_ts110_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts111;               /*!< (@ 0x000013BC) MWMM TS register 111                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3583..3552                                              */
    } mtgy_op_ts111_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts112;               /*!< (@ 0x000013C0) MWMM TS register 112                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3615..3584                                              */
    } mtgy_op_ts112_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts113;               /*!< (@ 0x000013C4) MWMM TS register 113                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3647..3616                                              */
    } mtgy_op_ts113_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts114;               /*!< (@ 0x000013C8) MWMM TS register 114                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3679..3648                                              */
    } mtgy_op_ts114_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts115;               /*!< (@ 0x000013CC) MWMM TS register 115                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3711..3680                                              */
    } mtgy_op_ts115_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts116;               /*!< (@ 0x000013D0) MWMM TS register 116                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3743..3712                                              */
    } mtgy_op_ts116_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts117;               /*!< (@ 0x000013D4) MWMM TS register 117                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3775..3744                                              */
    } mtgy_op_ts117_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts118;               /*!< (@ 0x000013D8) MWMM TS register 118                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3807..3776                                              */
    } mtgy_op_ts118_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts119;               /*!< (@ 0x000013DC) MWMM TS register 119                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3839..3808                                              */
    } mtgy_op_ts119_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts120;               /*!< (@ 0x000013E0) MWMM TS register 120                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3871..3840                                              */
    } mtgy_op_ts120_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts121;               /*!< (@ 0x000013E4) MWMM TS register 121                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3903..3872                                              */
    } mtgy_op_ts121_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts122;               /*!< (@ 0x000013E8) MWMM TS register 122                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3935..3904                                              */
    } mtgy_op_ts122_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts123;               /*!< (@ 0x000013EC) MWMM TS register 123                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3967..3936                                              */
    } mtgy_op_ts123_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts124;               /*!< (@ 0x000013F0) MWMM TS register 124                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3999..3968                                              */
    } mtgy_op_ts124_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts125;               /*!< (@ 0x000013F4) MWMM TS register 125                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4031..4000                                              */
    } mtgy_op_ts125_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts126;               /*!< (@ 0x000013F8) MWMM TS register 126                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4063..4032                                              */
    } mtgy_op_ts126_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_ts127;               /*!< (@ 0x000013FC) MWMM TS register 127                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4095..4064                                              */
    } mtgy_op_ts127_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p0;                  /*!< (@ 0x00001400) MWMM operand P register 0                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } mtgy_op_p0_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p1;                  /*!< (@ 0x00001404) MWMM operand P register 1                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } mtgy_op_p1_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p2;                  /*!< (@ 0x00001408) MWMM operand P register 2                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } mtgy_op_p2_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p3;                  /*!< (@ 0x0000140C) MWMM operand P register 3                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } mtgy_op_p3_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p4;                  /*!< (@ 0x00001410) MWMM operand P register 4                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } mtgy_op_p4_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p5;                  /*!< (@ 0x00001414) MWMM operand P register 5                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } mtgy_op_p5_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p6;                  /*!< (@ 0x00001418) MWMM operand P register 6                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } mtgy_op_p6_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p7;                  /*!< (@ 0x0000141C) MWMM operand P register 7                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } mtgy_op_p7_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p8;                  /*!< (@ 0x00001420) MWMM operand P register 8                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } mtgy_op_p8_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p9;                  /*!< (@ 0x00001424) MWMM operand P register 9                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } mtgy_op_p9_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p10;                 /*!< (@ 0x00001428) MWMM operand P register 10                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } mtgy_op_p10_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p11;                 /*!< (@ 0x0000142C) MWMM operand P register 11                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } mtgy_op_p11_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p12;                 /*!< (@ 0x00001430) MWMM operand P register 12                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } mtgy_op_p12_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p13;                 /*!< (@ 0x00001434) MWMM operand P register 13                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } mtgy_op_p13_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p14;                 /*!< (@ 0x00001438) MWMM operand P register 14                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } mtgy_op_p14_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p15;                 /*!< (@ 0x0000143C) MWMM operand P register 15                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } mtgy_op_p15_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p16;                 /*!< (@ 0x00001440) MWMM operand P register 16                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 543..512                                                */
    } mtgy_op_p16_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p17;                 /*!< (@ 0x00001444) MWMM operand P register 17                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 575..544                                                */
    } mtgy_op_p17_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p18;                 /*!< (@ 0x00001448) MWMM operand P register 18                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 607..576                                                */
    } mtgy_op_p18_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p19;                 /*!< (@ 0x0000144C) MWMM operand P register 19                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 639..608                                                */
    } mtgy_op_p19_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p20;                 /*!< (@ 0x00001450) MWMM operand P register 20                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 671..640                                                */
    } mtgy_op_p20_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p21;                 /*!< (@ 0x00001454) MWMM operand P register 21                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 703..672                                                */
    } mtgy_op_p21_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p22;                 /*!< (@ 0x00001458) MWMM operand P register 22                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 735..704                                                */
    } mtgy_op_p22_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p23;                 /*!< (@ 0x0000145C) MWMM operand P register 23                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 767..736                                                */
    } mtgy_op_p23_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p24;                 /*!< (@ 0x00001460) MWMM operand P register 24                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 799..768                                                */
    } mtgy_op_p24_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p25;                 /*!< (@ 0x00001464) MWMM operand P register 25                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 831..800                                                */
    } mtgy_op_p25_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p26;                 /*!< (@ 0x00001468) MWMM operand P register 26                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 863..832                                                */
    } mtgy_op_p26_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p27;                 /*!< (@ 0x0000146C) MWMM operand P register 27                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 895..864                                                */
    } mtgy_op_p27_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p28;                 /*!< (@ 0x00001470) MWMM operand P register 28                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 927..896                                                */
    } mtgy_op_p28_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p29;                 /*!< (@ 0x00001474) MWMM operand P register 29                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 959..928                                                */
    } mtgy_op_p29_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p30;                 /*!< (@ 0x00001478) MWMM operand P register 30                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 991..960                                                */
    } mtgy_op_p30_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p31;                 /*!< (@ 0x0000147C) MWMM operand P register 31                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1023..992                                               */
    } mtgy_op_p31_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p32;                 /*!< (@ 0x00001480) MWMM operand P register 32                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1055..1024                                              */
    } mtgy_op_p32_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p33;                 /*!< (@ 0x00001484) MWMM operand P register 33                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1087..1056                                              */
    } mtgy_op_p33_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p34;                 /*!< (@ 0x00001488) MWMM operand P register 34                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1119..1088                                              */
    } mtgy_op_p34_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p35;                 /*!< (@ 0x0000148C) MWMM operand P register 35                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1151..1120                                              */
    } mtgy_op_p35_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p36;                 /*!< (@ 0x00001490) MWMM operand P register 36                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1183..1152                                              */
    } mtgy_op_p36_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p37;                 /*!< (@ 0x00001494) MWMM operand P register 37                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1215..1184                                              */
    } mtgy_op_p37_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p38;                 /*!< (@ 0x00001498) MWMM operand P register 38                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1247..1216                                              */
    } mtgy_op_p38_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p39;                 /*!< (@ 0x0000149C) MWMM operand P register 39                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1279..1248                                              */
    } mtgy_op_p39_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p40;                 /*!< (@ 0x000014A0) MWMM operand P register 40                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1311..1280                                              */
    } mtgy_op_p40_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p41;                 /*!< (@ 0x000014A4) MWMM operand P register 41                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1343..1312                                              */
    } mtgy_op_p41_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p42;                 /*!< (@ 0x000014A8) MWMM operand P register 42                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1375..1344                                              */
    } mtgy_op_p42_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p43;                 /*!< (@ 0x000014AC) MWMM operand P register 43                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1407..1376                                              */
    } mtgy_op_p43_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p44;                 /*!< (@ 0x000014B0) MWMM operand P register 44                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1439..1408                                              */
    } mtgy_op_p44_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p45;                 /*!< (@ 0x000014B4) MWMM operand P register 45                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1471..1440                                              */
    } mtgy_op_p45_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p46;                 /*!< (@ 0x000014B8) MWMM operand P register 46                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1503..1472                                              */
    } mtgy_op_p46_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p47;                 /*!< (@ 0x000014BC) MWMM operand P register 47                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1535..1504                                              */
    } mtgy_op_p47_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p48;                 /*!< (@ 0x000014C0) MWMM operand P register 48                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1567..1536                                              */
    } mtgy_op_p48_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p49;                 /*!< (@ 0x000014C4) MWMM operand P register 49                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1599..1568                                              */
    } mtgy_op_p49_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p50;                 /*!< (@ 0x000014C8) MWMM operand P register 50                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1631..1600                                              */
    } mtgy_op_p50_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p51;                 /*!< (@ 0x000014CC) MWMM operand P register 51                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1663..1632                                              */
    } mtgy_op_p51_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p52;                 /*!< (@ 0x000014D0) MWMM operand P register 52                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1695..1664                                              */
    } mtgy_op_p52_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p53;                 /*!< (@ 0x000014D4) MWMM operand P register 53                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1727..1696                                              */
    } mtgy_op_p53_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p54;                 /*!< (@ 0x000014D8) MWMM operand P register 54                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1759..1728                                              */
    } mtgy_op_p54_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p55;                 /*!< (@ 0x000014DC) MWMM operand P register 55                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1791..1760                                              */
    } mtgy_op_p55_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p56;                 /*!< (@ 0x000014E0) MWMM operand P register 56                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1823..1792                                              */
    } mtgy_op_p56_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p57;                 /*!< (@ 0x000014E4) MWMM operand P register 57                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1855..1824                                              */
    } mtgy_op_p57_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p58;                 /*!< (@ 0x000014E8) MWMM operand P register 58                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1887..1856                                              */
    } mtgy_op_p58_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p59;                 /*!< (@ 0x000014EC) MWMM operand P register 59                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1919..1888                                              */
    } mtgy_op_p59_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p60;                 /*!< (@ 0x000014F0) MWMM operand P register 60                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1951..1920                                              */
    } mtgy_op_p60_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p61;                 /*!< (@ 0x000014F4) MWMM operand P register 61                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1983..1952                                              */
    } mtgy_op_p61_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p62;                 /*!< (@ 0x000014F8) MWMM operand P register 62                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2015..1984                                              */
    } mtgy_op_p62_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p63;                 /*!< (@ 0x000014FC) MWMM operand P register 63                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2047..2016                                              */
    } mtgy_op_p63_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p64;                 /*!< (@ 0x00001500) MWMM operand P register 64                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2079..2048                                              */
    } mtgy_op_p64_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p65;                 /*!< (@ 0x00001504) MWMM operand P register 65                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2111..2080                                              */
    } mtgy_op_p65_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p66;                 /*!< (@ 0x00001508) MWMM operand P register 66                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2143..2112                                              */
    } mtgy_op_p66_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p67;                 /*!< (@ 0x0000150C) MWMM operand P register 67                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2175..2144                                              */
    } mtgy_op_p67_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p68;                 /*!< (@ 0x00001510) MWMM operand P register 68                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2207..2176                                              */
    } mtgy_op_p68_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p69;                 /*!< (@ 0x00001514) MWMM operand P register 69                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2239..2208                                              */
    } mtgy_op_p69_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p70;                 /*!< (@ 0x00001518) MWMM operand P register 70                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2271..2240                                              */
    } mtgy_op_p70_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p71;                 /*!< (@ 0x0000151C) MWMM operand P register 71                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2303..2272                                              */
    } mtgy_op_p71_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p72;                 /*!< (@ 0x00001520) MWMM operand P register 72                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2335..2304                                              */
    } mtgy_op_p72_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p73;                 /*!< (@ 0x00001524) MWMM operand P register 73                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2367..2336                                              */
    } mtgy_op_p73_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p74;                 /*!< (@ 0x00001528) MWMM operand P register 74                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2399..2368                                              */
    } mtgy_op_p74_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p75;                 /*!< (@ 0x0000152C) MWMM operand P register 75                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2431..2400                                              */
    } mtgy_op_p75_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p76;                 /*!< (@ 0x00001530) MWMM operand P register 76                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2463..2432                                              */
    } mtgy_op_p76_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p77;                 /*!< (@ 0x00001534) MWMM operand P register 77                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2495..2464                                              */
    } mtgy_op_p77_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p78;                 /*!< (@ 0x00001538) MWMM operand P register 78                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2527..2496                                              */
    } mtgy_op_p78_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p79;                 /*!< (@ 0x0000153C) MWMM operand P register 79                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2559..2528                                              */
    } mtgy_op_p79_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p80;                 /*!< (@ 0x00001540) MWMM operand P register 80                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2591..2560                                              */
    } mtgy_op_p80_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p81;                 /*!< (@ 0x00001544) MWMM operand P register 81                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2623..2592                                              */
    } mtgy_op_p81_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p82;                 /*!< (@ 0x00001548) MWMM operand P register 82                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2655..2624                                              */
    } mtgy_op_p82_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p83;                 /*!< (@ 0x0000154C) MWMM operand P register 83                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2687..2656                                              */
    } mtgy_op_p83_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p84;                 /*!< (@ 0x00001550) MWMM operand P register 84                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2719..2688                                              */
    } mtgy_op_p84_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p85;                 /*!< (@ 0x00001554) MWMM operand P register 85                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2751..2720                                              */
    } mtgy_op_p85_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p86;                 /*!< (@ 0x00001558) MWMM operand P register 86                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2783..2752                                              */
    } mtgy_op_p86_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p87;                 /*!< (@ 0x0000155C) MWMM operand P register 87                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2815..2784                                              */
    } mtgy_op_p87_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p88;                 /*!< (@ 0x00001560) MWMM operand P register 88                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2847..2816                                              */
    } mtgy_op_p88_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p89;                 /*!< (@ 0x00001564) MWMM operand P register 89                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2879..2848                                              */
    } mtgy_op_p89_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p90;                 /*!< (@ 0x00001568) MWMM operand P register 90                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2911..2880                                              */
    } mtgy_op_p90_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p91;                 /*!< (@ 0x0000156C) MWMM operand P register 91                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2943..2912                                              */
    } mtgy_op_p91_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p92;                 /*!< (@ 0x00001570) MWMM operand P register 92                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2975..2944                                              */
    } mtgy_op_p92_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p93;                 /*!< (@ 0x00001574) MWMM operand P register 93                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3007..2976                                              */
    } mtgy_op_p93_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p94;                 /*!< (@ 0x00001578) MWMM operand P register 94                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3039..3008                                              */
    } mtgy_op_p94_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p95;                 /*!< (@ 0x0000157C) MWMM operand P register 95                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3071..3040                                              */
    } mtgy_op_p95_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p96;                 /*!< (@ 0x00001580) MWMM operand P register 96                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3103..3072                                              */
    } mtgy_op_p96_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p97;                 /*!< (@ 0x00001584) MWMM operand P register 97                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3135..3104                                              */
    } mtgy_op_p97_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p98;                 /*!< (@ 0x00001588) MWMM operand P register 98                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3167..3136                                              */
    } mtgy_op_p98_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p99;                 /*!< (@ 0x0000158C) MWMM operand P register 99                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3199..3168                                              */
    } mtgy_op_p99_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p100;                /*!< (@ 0x00001590) MWMM operand P register 100                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3231..3200                                              */
    } mtgy_op_p100_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p101;                /*!< (@ 0x00001594) MWMM operand P register 101                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3263..3232                                              */
    } mtgy_op_p101_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p102;                /*!< (@ 0x00001598) MWMM operand P register 102                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3295..3264                                              */
    } mtgy_op_p102_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p103;                /*!< (@ 0x0000159C) MWMM operand P register 103                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3327..3296                                              */
    } mtgy_op_p103_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p104;                /*!< (@ 0x000015A0) MWMM operand P register 104                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3359..3328                                              */
    } mtgy_op_p104_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p105;                /*!< (@ 0x000015A4) MWMM operand P register 105                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3391..3360                                              */
    } mtgy_op_p105_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p106;                /*!< (@ 0x000015A8) MWMM operand P register 106                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3423..3392                                              */
    } mtgy_op_p106_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p107;                /*!< (@ 0x000015AC) MWMM operand P register 107                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3455..3424                                              */
    } mtgy_op_p107_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p108;                /*!< (@ 0x000015B0) MWMM operand P register 108                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3487..3456                                              */
    } mtgy_op_p108_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p109;                /*!< (@ 0x000015B4) MWMM operand P register 109                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3519..3488                                              */
    } mtgy_op_p109_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p110;                /*!< (@ 0x000015B8) MWMM operand P register 110                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3551..3520                                              */
    } mtgy_op_p110_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p111;                /*!< (@ 0x000015BC) MWMM operand P register 111                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3583..3552                                              */
    } mtgy_op_p111_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p112;                /*!< (@ 0x000015C0) MWMM operand P register 112                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3615..3584                                              */
    } mtgy_op_p112_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p113;                /*!< (@ 0x000015C4) MWMM operand P register 113                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3647..3616                                              */
    } mtgy_op_p113_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p114;                /*!< (@ 0x000015C8) MWMM operand P register 114                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3679..3648                                              */
    } mtgy_op_p114_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p115;                /*!< (@ 0x000015CC) MWMM operand P register 115                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3711..3680                                              */
    } mtgy_op_p115_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p116;                /*!< (@ 0x000015D0) MWMM operand P register 116                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3743..3712                                              */
    } mtgy_op_p116_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p117;                /*!< (@ 0x000015D4) MWMM operand P register 117                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3775..3744                                              */
    } mtgy_op_p117_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p118;                /*!< (@ 0x000015D8) MWMM operand P register 118                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3807..3776                                              */
    } mtgy_op_p118_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p119;                /*!< (@ 0x000015DC) MWMM operand P register 119                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3839..3808                                              */
    } mtgy_op_p119_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p120;                /*!< (@ 0x000015E0) MWMM operand P register 120                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3871..3840                                              */
    } mtgy_op_p120_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p121;                /*!< (@ 0x000015E4) MWMM operand P register 121                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3903..3872                                              */
    } mtgy_op_p121_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p122;                /*!< (@ 0x000015E8) MWMM operand P register 122                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3935..3904                                              */
    } mtgy_op_p122_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p123;                /*!< (@ 0x000015EC) MWMM operand P register 123                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3967..3936                                              */
    } mtgy_op_p123_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p124;                /*!< (@ 0x000015F0) MWMM operand P register 124                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3999..3968                                              */
    } mtgy_op_p124_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p125;                /*!< (@ 0x000015F4) MWMM operand P register 125                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4031..4000                                              */
    } mtgy_op_p125_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p126;                /*!< (@ 0x000015F8) MWMM operand P register 126                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4063..4032                                              */
    } mtgy_op_p126_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_p127;                /*!< (@ 0x000015FC) MWMM operand P register 127                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4095..4064                                              */
    } mtgy_op_p127_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b0;                  /*!< (@ 0x00001600) MWMM operand B register 0                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } mtgy_op_b0_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b1;                  /*!< (@ 0x00001604) MWMM operand B register 1                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } mtgy_op_b1_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b2;                  /*!< (@ 0x00001608) MWMM operand B register 2                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } mtgy_op_b2_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b3;                  /*!< (@ 0x0000160C) MWMM operand B register 3                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } mtgy_op_b3_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b4;                  /*!< (@ 0x00001610) MWMM operand B register 4                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } mtgy_op_b4_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b5;                  /*!< (@ 0x00001614) MWMM operand B register 5                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } mtgy_op_b5_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b6;                  /*!< (@ 0x00001618) MWMM operand B register 6                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } mtgy_op_b6_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b7;                  /*!< (@ 0x0000161C) MWMM operand B register 7                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } mtgy_op_b7_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b8;                  /*!< (@ 0x00001620) MWMM operand B register 8                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } mtgy_op_b8_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b9;                  /*!< (@ 0x00001624) MWMM operand B register 9                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } mtgy_op_b9_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b10;                 /*!< (@ 0x00001628) MWMM operand B register 10                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } mtgy_op_b10_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b11;                 /*!< (@ 0x0000162C) MWMM operand B register 11                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } mtgy_op_b11_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b12;                 /*!< (@ 0x00001630) MWMM operand B register 12                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } mtgy_op_b12_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b13;                 /*!< (@ 0x00001634) MWMM operand B register 13                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } mtgy_op_b13_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b14;                 /*!< (@ 0x00001638) MWMM operand B register 14                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } mtgy_op_b14_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b15;                 /*!< (@ 0x0000163C) MWMM operand B register 15                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } mtgy_op_b15_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b16;                 /*!< (@ 0x00001640) MWMM operand B register 16                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 543..512                                                */
    } mtgy_op_b16_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b17;                 /*!< (@ 0x00001644) MWMM operand B register 17                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 575..544                                                */
    } mtgy_op_b17_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b18;                 /*!< (@ 0x00001648) MWMM operand B register 18                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 607..576                                                */
    } mtgy_op_b18_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b19;                 /*!< (@ 0x0000164C) MWMM operand B register 19                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 639..608                                                */
    } mtgy_op_b19_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b20;                 /*!< (@ 0x00001650) MWMM operand B register 20                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 671..640                                                */
    } mtgy_op_b20_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b21;                 /*!< (@ 0x00001654) MWMM operand B register 21                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 703..672                                                */
    } mtgy_op_b21_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b22;                 /*!< (@ 0x00001658) MWMM operand B register 22                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 735..704                                                */
    } mtgy_op_b22_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b23;                 /*!< (@ 0x0000165C) MWMM operand B register 23                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 767..736                                                */
    } mtgy_op_b23_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b24;                 /*!< (@ 0x00001660) MWMM operand B register 24                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 799..768                                                */
    } mtgy_op_b24_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b25;                 /*!< (@ 0x00001664) MWMM operand B register 25                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 831..800                                                */
    } mtgy_op_b25_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b26;                 /*!< (@ 0x00001668) MWMM operand B register 26                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 863..832                                                */
    } mtgy_op_b26_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b27;                 /*!< (@ 0x0000166C) MWMM operand B register 27                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 895..864                                                */
    } mtgy_op_b27_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b28;                 /*!< (@ 0x00001670) MWMM operand B register 28                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 927..896                                                */
    } mtgy_op_b28_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b29;                 /*!< (@ 0x00001674) MWMM operand B register 29                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 959..928                                                */
    } mtgy_op_b29_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b30;                 /*!< (@ 0x00001678) MWMM operand B register 30                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 991..960                                                */
    } mtgy_op_b30_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b31;                 /*!< (@ 0x0000167C) MWMM operand B register 31                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1023..992                                               */
    } mtgy_op_b31_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b32;                 /*!< (@ 0x00001680) MWMM operand B register 32                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1055..1024                                              */
    } mtgy_op_b32_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b33;                 /*!< (@ 0x00001684) MWMM operand B register 33                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1087..1056                                              */
    } mtgy_op_b33_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b34;                 /*!< (@ 0x00001688) MWMM operand B register 34                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1119..1088                                              */
    } mtgy_op_b34_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b35;                 /*!< (@ 0x0000168C) MWMM operand B register 35                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1151..1120                                              */
    } mtgy_op_b35_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b36;                 /*!< (@ 0x00001690) MWMM operand B register 36                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1183..1152                                              */
    } mtgy_op_b36_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b37;                 /*!< (@ 0x00001694) MWMM operand B register 37                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1215..1184                                              */
    } mtgy_op_b37_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b38;                 /*!< (@ 0x00001698) MWMM operand B register 38                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1247..1216                                              */
    } mtgy_op_b38_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b39;                 /*!< (@ 0x0000169C) MWMM operand B register 39                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1279..1248                                              */
    } mtgy_op_b39_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b40;                 /*!< (@ 0x000016A0) MWMM operand B register 40                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1311..1280                                              */
    } mtgy_op_b40_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b41;                 /*!< (@ 0x000016A4) MWMM operand B register 41                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1343..1312                                              */
    } mtgy_op_b41_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b42;                 /*!< (@ 0x000016A8) MWMM operand B register 42                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1375..1344                                              */
    } mtgy_op_b42_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b43;                 /*!< (@ 0x000016AC) MWMM operand B register 43                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1407..1376                                              */
    } mtgy_op_b43_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b44;                 /*!< (@ 0x000016B0) MWMM operand B register 44                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1439..1408                                              */
    } mtgy_op_b44_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b45;                 /*!< (@ 0x000016B4) MWMM operand B register 45                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1471..1440                                              */
    } mtgy_op_b45_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b46;                 /*!< (@ 0x000016B8) MWMM operand B register 46                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1503..1472                                              */
    } mtgy_op_b46_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b47;                 /*!< (@ 0x000016BC) MWMM operand B register 47                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1535..1504                                              */
    } mtgy_op_b47_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b48;                 /*!< (@ 0x000016C0) MWMM operand B register 48                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1567..1536                                              */
    } mtgy_op_b48_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b49;                 /*!< (@ 0x000016C4) MWMM operand B register 49                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1599..1568                                              */
    } mtgy_op_b49_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b50;                 /*!< (@ 0x000016C8) MWMM operand B register 50                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1631..1600                                              */
    } mtgy_op_b50_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b51;                 /*!< (@ 0x000016CC) MWMM operand B register 51                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1663..1632                                              */
    } mtgy_op_b51_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b52;                 /*!< (@ 0x000016D0) MWMM operand B register 52                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1695..1664                                              */
    } mtgy_op_b52_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b53;                 /*!< (@ 0x000016D4) MWMM operand B register 53                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1727..1696                                              */
    } mtgy_op_b53_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b54;                 /*!< (@ 0x000016D8) MWMM operand B register 54                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1759..1728                                              */
    } mtgy_op_b54_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b55;                 /*!< (@ 0x000016DC) MWMM operand B register 55                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1791..1760                                              */
    } mtgy_op_b55_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b56;                 /*!< (@ 0x000016E0) MWMM operand B register 56                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1823..1792                                              */
    } mtgy_op_b56_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b57;                 /*!< (@ 0x000016E4) MWMM operand B register 57                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1855..1824                                              */
    } mtgy_op_b57_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b58;                 /*!< (@ 0x000016E8) MWMM operand B register 58                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1887..1856                                              */
    } mtgy_op_b58_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b59;                 /*!< (@ 0x000016EC) MWMM operand B register 59                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1919..1888                                              */
    } mtgy_op_b59_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b60;                 /*!< (@ 0x000016F0) MWMM operand B register 60                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1951..1920                                              */
    } mtgy_op_b60_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b61;                 /*!< (@ 0x000016F4) MWMM operand B register 61                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1983..1952                                              */
    } mtgy_op_b61_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b62;                 /*!< (@ 0x000016F8) MWMM operand B register 62                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2015..1984                                              */
    } mtgy_op_b62_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b63;                 /*!< (@ 0x000016FC) MWMM operand B register 63                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2047..2016                                              */
    } mtgy_op_b63_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b64;                 /*!< (@ 0x00001700) MWMM operand B register 64                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2079..2048                                              */
    } mtgy_op_b64_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b65;                 /*!< (@ 0x00001704) MWMM operand B register 65                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2111..2080                                              */
    } mtgy_op_b65_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b66;                 /*!< (@ 0x00001708) MWMM operand B register 66                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2143..2112                                              */
    } mtgy_op_b66_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b67;                 /*!< (@ 0x0000170C) MWMM operand B register 67                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2175..2144                                              */
    } mtgy_op_b67_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b68;                 /*!< (@ 0x00001710) MWMM operand B register 68                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2207..2176                                              */
    } mtgy_op_b68_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b69;                 /*!< (@ 0x00001714) MWMM operand B register 69                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2239..2208                                              */
    } mtgy_op_b69_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b70;                 /*!< (@ 0x00001718) MWMM operand B register 70                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2271..2240                                              */
    } mtgy_op_b70_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b71;                 /*!< (@ 0x0000171C) MWMM operand B register 71                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2303..2272                                              */
    } mtgy_op_b71_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b72;                 /*!< (@ 0x00001720) MWMM operand B register 72                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2335..2304                                              */
    } mtgy_op_b72_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b73;                 /*!< (@ 0x00001724) MWMM operand B register 73                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2367..2336                                              */
    } mtgy_op_b73_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b74;                 /*!< (@ 0x00001728) MWMM operand B register 74                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2399..2368                                              */
    } mtgy_op_b74_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b75;                 /*!< (@ 0x0000172C) MWMM operand B register 75                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2431..2400                                              */
    } mtgy_op_b75_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b76;                 /*!< (@ 0x00001730) MWMM operand B register 76                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2463..2432                                              */
    } mtgy_op_b76_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b77;                 /*!< (@ 0x00001734) MWMM operand B register 77                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2495..2464                                              */
    } mtgy_op_b77_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b78;                 /*!< (@ 0x00001738) MWMM operand B register 78                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2527..2496                                              */
    } mtgy_op_b78_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b79;                 /*!< (@ 0x0000173C) MWMM operand B register 79                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2559..2528                                              */
    } mtgy_op_b79_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b80;                 /*!< (@ 0x00001740) MWMM operand B register 80                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2591..2560                                              */
    } mtgy_op_b80_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b81;                 /*!< (@ 0x00001744) MWMM operand B register 81                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2623..2592                                              */
    } mtgy_op_b81_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b82;                 /*!< (@ 0x00001748) MWMM operand B register 82                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2655..2624                                              */
    } mtgy_op_b82_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b83;                 /*!< (@ 0x0000174C) MWMM operand B register 83                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2687..2656                                              */
    } mtgy_op_b83_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b84;                 /*!< (@ 0x00001750) MWMM operand B register 84                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2719..2688                                              */
    } mtgy_op_b84_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b85;                 /*!< (@ 0x00001754) MWMM operand B register 85                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2751..2720                                              */
    } mtgy_op_b85_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b86;                 /*!< (@ 0x00001758) MWMM operand B register 86                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2783..2752                                              */
    } mtgy_op_b86_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b87;                 /*!< (@ 0x0000175C) MWMM operand B register 87                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2815..2784                                              */
    } mtgy_op_b87_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b88;                 /*!< (@ 0x00001760) MWMM operand B register 88                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2847..2816                                              */
    } mtgy_op_b88_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b89;                 /*!< (@ 0x00001764) MWMM operand B register 89                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2879..2848                                              */
    } mtgy_op_b89_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b90;                 /*!< (@ 0x00001768) MWMM operand B register 90                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2911..2880                                              */
    } mtgy_op_b90_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b91;                 /*!< (@ 0x0000176C) MWMM operand B register 91                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2943..2912                                              */
    } mtgy_op_b91_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b92;                 /*!< (@ 0x00001770) MWMM operand B register 92                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2975..2944                                              */
    } mtgy_op_b92_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b93;                 /*!< (@ 0x00001774) MWMM operand B register 93                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3007..2976                                              */
    } mtgy_op_b93_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b94;                 /*!< (@ 0x00001778) MWMM operand B register 94                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3039..3008                                              */
    } mtgy_op_b94_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b95;                 /*!< (@ 0x0000177C) MWMM operand B register 95                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3071..3040                                              */
    } mtgy_op_b95_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b96;                 /*!< (@ 0x00001780) MWMM operand B register 96                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3103..3072                                              */
    } mtgy_op_b96_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b97;                 /*!< (@ 0x00001784) MWMM operand B register 97                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3135..3104                                              */
    } mtgy_op_b97_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b98;                 /*!< (@ 0x00001788) MWMM operand B register 98                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3167..3136                                              */
    } mtgy_op_b98_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b99;                 /*!< (@ 0x0000178C) MWMM operand B register 99                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3199..3168                                              */
    } mtgy_op_b99_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b100;                /*!< (@ 0x00001790) MWMM operand B register 100                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3231..3200                                              */
    } mtgy_op_b100_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b101;                /*!< (@ 0x00001794) MWMM operand B register 101                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3263..3232                                              */
    } mtgy_op_b101_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b102;                /*!< (@ 0x00001798) MWMM operand B register 102                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3295..3264                                              */
    } mtgy_op_b102_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b103;                /*!< (@ 0x0000179C) MWMM operand B register 103                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3327..3296                                              */
    } mtgy_op_b103_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b104;                /*!< (@ 0x000017A0) MWMM operand B register 104                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3359..3328                                              */
    } mtgy_op_b104_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b105;                /*!< (@ 0x000017A4) MWMM operand B register 105                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3391..3360                                              */
    } mtgy_op_b105_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b106;                /*!< (@ 0x000017A8) MWMM operand B register 106                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3423..3392                                              */
    } mtgy_op_b106_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b107;                /*!< (@ 0x000017AC) MWMM operand B register 107                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3455..3424                                              */
    } mtgy_op_b107_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b108;                /*!< (@ 0x000017B0) MWMM operand B register 108                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3487..3456                                              */
    } mtgy_op_b108_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b109;                /*!< (@ 0x000017B4) MWMM operand B register 109                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3519..3488                                              */
    } mtgy_op_b109_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b110;                /*!< (@ 0x000017B8) MWMM operand B register 110                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3551..3520                                              */
    } mtgy_op_b110_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b111;                /*!< (@ 0x000017BC) MWMM operand B register 111                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3583..3552                                              */
    } mtgy_op_b111_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b112;                /*!< (@ 0x000017C0) MWMM operand B register 112                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3615..3584                                              */
    } mtgy_op_b112_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b113;                /*!< (@ 0x000017C4) MWMM operand B register 113                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3647..3616                                              */
    } mtgy_op_b113_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b114;                /*!< (@ 0x000017C8) MWMM operand B register 114                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3679..3648                                              */
    } mtgy_op_b114_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b115;                /*!< (@ 0x000017CC) MWMM operand B register 115                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3711..3680                                              */
    } mtgy_op_b115_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b116;                /*!< (@ 0x000017D0) MWMM operand B register 116                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3743..3712                                              */
    } mtgy_op_b116_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b117;                /*!< (@ 0x000017D4) MWMM operand B register 117                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3775..3744                                              */
    } mtgy_op_b117_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b118;                /*!< (@ 0x000017D8) MWMM operand B register 118                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3807..3776                                              */
    } mtgy_op_b118_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b119;                /*!< (@ 0x000017DC) MWMM operand B register 119                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3839..3808                                              */
    } mtgy_op_b119_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b120;                /*!< (@ 0x000017E0) MWMM operand B register 120                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3871..3840                                              */
    } mtgy_op_b120_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b121;                /*!< (@ 0x000017E4) MWMM operand B register 121                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3903..3872                                              */
    } mtgy_op_b121_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b122;                /*!< (@ 0x000017E8) MWMM operand B register 122                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3935..3904                                              */
    } mtgy_op_b122_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b123;                /*!< (@ 0x000017EC) MWMM operand B register 123                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3967..3936                                              */
    } mtgy_op_b123_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b124;                /*!< (@ 0x000017F0) MWMM operand B register 124                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3999..3968                                              */
    } mtgy_op_b124_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b125;                /*!< (@ 0x000017F4) MWMM operand B register 125                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4031..4000                                              */
    } mtgy_op_b125_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b126;                /*!< (@ 0x000017F8) MWMM operand B register 126                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4063..4032                                              */
    } mtgy_op_b126_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_b127;                /*!< (@ 0x000017FC) MWMM operand B register 127                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4095..4064                                              */
    } mtgy_op_b127_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a0;                  /*!< (@ 0x00001800) MWMM operand A register 0                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } mtgy_op_a0_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a1;                  /*!< (@ 0x00001804) MWMM operand A register 1                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } mtgy_op_a1_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a2;                  /*!< (@ 0x00001808) MWMM operand A register 2                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } mtgy_op_a2_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a3;                  /*!< (@ 0x0000180C) MWMM operand A register 3                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } mtgy_op_a3_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a4;                  /*!< (@ 0x00001810) MWMM operand A register 4                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } mtgy_op_a4_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a5;                  /*!< (@ 0x00001814) MWMM operand A register 5                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } mtgy_op_a5_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a6;                  /*!< (@ 0x00001818) MWMM operand A register 6                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } mtgy_op_a6_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a7;                  /*!< (@ 0x0000181C) MWMM operand A register 7                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } mtgy_op_a7_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a8;                  /*!< (@ 0x00001820) MWMM operand A register 8                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } mtgy_op_a8_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a9;                  /*!< (@ 0x00001824) MWMM operand A register 9                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } mtgy_op_a9_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a10;                 /*!< (@ 0x00001828) MWMM operand A register 10                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } mtgy_op_a10_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a11;                 /*!< (@ 0x0000182C) MWMM operand A register 11                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } mtgy_op_a11_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a12;                 /*!< (@ 0x00001830) MWMM operand A register 12                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } mtgy_op_a12_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a13;                 /*!< (@ 0x00001834) MWMM operand A register 13                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } mtgy_op_a13_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a14;                 /*!< (@ 0x00001838) MWMM operand A register 14                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } mtgy_op_a14_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a15;                 /*!< (@ 0x0000183C) MWMM operand A register 15                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } mtgy_op_a15_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a16;                 /*!< (@ 0x00001840) MWMM operand A register 16                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 543..512                                                */
    } mtgy_op_a16_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a17;                 /*!< (@ 0x00001844) MWMM operand A register 17                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 575..544                                                */
    } mtgy_op_a17_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a18;                 /*!< (@ 0x00001848) MWMM operand A register 18                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 607..576                                                */
    } mtgy_op_a18_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a19;                 /*!< (@ 0x0000184C) MWMM operand A register 19                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 639..608                                                */
    } mtgy_op_a19_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a20;                 /*!< (@ 0x00001850) MWMM operand A register 20                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 671..640                                                */
    } mtgy_op_a20_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a21;                 /*!< (@ 0x00001854) MWMM operand A register 21                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 703..672                                                */
    } mtgy_op_a21_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a22;                 /*!< (@ 0x00001858) MWMM operand A register 22                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 735..704                                                */
    } mtgy_op_a22_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a23;                 /*!< (@ 0x0000185C) MWMM operand A register 23                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 767..736                                                */
    } mtgy_op_a23_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a24;                 /*!< (@ 0x00001860) MWMM operand A register 24                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 799..768                                                */
    } mtgy_op_a24_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a25;                 /*!< (@ 0x00001864) MWMM operand A register 25                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 831..800                                                */
    } mtgy_op_a25_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a26;                 /*!< (@ 0x00001868) MWMM operand A register 26                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 863..832                                                */
    } mtgy_op_a26_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a27;                 /*!< (@ 0x0000186C) MWMM operand A register 27                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 895..864                                                */
    } mtgy_op_a27_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a28;                 /*!< (@ 0x00001870) MWMM operand A register 28                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 927..896                                                */
    } mtgy_op_a28_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a29;                 /*!< (@ 0x00001874) MWMM operand A register 29                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 959..928                                                */
    } mtgy_op_a29_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a30;                 /*!< (@ 0x00001878) MWMM operand A register 30                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 991..960                                                */
    } mtgy_op_a30_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a31;                 /*!< (@ 0x0000187C) MWMM operand A register 31                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1023..992                                               */
    } mtgy_op_a31_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a32;                 /*!< (@ 0x00001880) MWMM operand A register 32                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1055..1024                                              */
    } mtgy_op_a32_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a33;                 /*!< (@ 0x00001884) MWMM operand A register 33                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1087..1056                                              */
    } mtgy_op_a33_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a34;                 /*!< (@ 0x00001888) MWMM operand A register 34                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1119..1088                                              */
    } mtgy_op_a34_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a35;                 /*!< (@ 0x0000188C) MWMM operand A register 35                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1151..1120                                              */
    } mtgy_op_a35_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a36;                 /*!< (@ 0x00001890) MWMM operand A register 36                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1183..1152                                              */
    } mtgy_op_a36_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a37;                 /*!< (@ 0x00001894) MWMM operand A register 37                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1215..1184                                              */
    } mtgy_op_a37_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a38;                 /*!< (@ 0x00001898) MWMM operand A register 38                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1247..1216                                              */
    } mtgy_op_a38_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a39;                 /*!< (@ 0x0000189C) MWMM operand A register 39                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1279..1248                                              */
    } mtgy_op_a39_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a40;                 /*!< (@ 0x000018A0) MWMM operand A register 40                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1311..1280                                              */
    } mtgy_op_a40_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a41;                 /*!< (@ 0x000018A4) MWMM operand A register 41                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1343..1312                                              */
    } mtgy_op_a41_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a42;                 /*!< (@ 0x000018A8) MWMM operand A register 42                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1375..1344                                              */
    } mtgy_op_a42_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a43;                 /*!< (@ 0x000018AC) MWMM operand A register 43                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1407..1376                                              */
    } mtgy_op_a43_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a44;                 /*!< (@ 0x000018B0) MWMM operand A register 44                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1439..1408                                              */
    } mtgy_op_a44_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a45;                 /*!< (@ 0x000018B4) MWMM operand A register 45                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1471..1440                                              */
    } mtgy_op_a45_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a46;                 /*!< (@ 0x000018B8) MWMM operand A register 46                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1503..1472                                              */
    } mtgy_op_a46_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a47;                 /*!< (@ 0x000018BC) MWMM operand A register 47                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1535..1504                                              */
    } mtgy_op_a47_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a48;                 /*!< (@ 0x000018C0) MWMM operand A register 48                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1567..1536                                              */
    } mtgy_op_a48_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a49;                 /*!< (@ 0x000018C4) MWMM operand A register 49                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1599..1568                                              */
    } mtgy_op_a49_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a50;                 /*!< (@ 0x000018C8) MWMM operand A register 50                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1631..1600                                              */
    } mtgy_op_a50_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a51;                 /*!< (@ 0x000018CC) MWMM operand A register 51                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1663..1632                                              */
    } mtgy_op_a51_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a52;                 /*!< (@ 0x000018D0) MWMM operand A register 52                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1695..1664                                              */
    } mtgy_op_a52_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a53;                 /*!< (@ 0x000018D4) MWMM operand A register 53                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1727..1696                                              */
    } mtgy_op_a53_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a54;                 /*!< (@ 0x000018D8) MWMM operand A register 54                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1759..1728                                              */
    } mtgy_op_a54_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a55;                 /*!< (@ 0x000018DC) MWMM operand A register 55                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1791..1760                                              */
    } mtgy_op_a55_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a56;                 /*!< (@ 0x000018E0) MWMM operand A register 56                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1823..1792                                              */
    } mtgy_op_a56_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a57;                 /*!< (@ 0x000018E4) MWMM operand A register 57                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1855..1824                                              */
    } mtgy_op_a57_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a58;                 /*!< (@ 0x000018E8) MWMM operand A register 58                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1887..1856                                              */
    } mtgy_op_a58_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a59;                 /*!< (@ 0x000018EC) MWMM operand A register 59                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1919..1888                                              */
    } mtgy_op_a59_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a60;                 /*!< (@ 0x000018F0) MWMM operand A register 60                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1951..1920                                              */
    } mtgy_op_a60_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a61;                 /*!< (@ 0x000018F4) MWMM operand A register 61                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1983..1952                                              */
    } mtgy_op_a61_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a62;                 /*!< (@ 0x000018F8) MWMM operand A register 62                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2015..1984                                              */
    } mtgy_op_a62_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a63;                 /*!< (@ 0x000018FC) MWMM operand A register 63                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2047..2016                                              */
    } mtgy_op_a63_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a64;                 /*!< (@ 0x00001900) MWMM operand A register 64                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2079..2048                                              */
    } mtgy_op_a64_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a65;                 /*!< (@ 0x00001904) MWMM operand A register 65                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2111..2080                                              */
    } mtgy_op_a65_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a66;                 /*!< (@ 0x00001908) MWMM operand A register 66                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2143..2112                                              */
    } mtgy_op_a66_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a67;                 /*!< (@ 0x0000190C) MWMM operand A register 67                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2175..2144                                              */
    } mtgy_op_a67_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a68;                 /*!< (@ 0x00001910) MWMM operand A register 68                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2207..2176                                              */
    } mtgy_op_a68_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a69;                 /*!< (@ 0x00001914) MWMM operand A register 69                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2239..2208                                              */
    } mtgy_op_a69_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a70;                 /*!< (@ 0x00001918) MWMM operand A register 70                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2271..2240                                              */
    } mtgy_op_a70_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a71;                 /*!< (@ 0x0000191C) MWMM operand A register 71                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2303..2272                                              */
    } mtgy_op_a71_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a72;                 /*!< (@ 0x00001920) MWMM operand A register 72                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2335..2304                                              */
    } mtgy_op_a72_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a73;                 /*!< (@ 0x00001924) MWMM operand A register 73                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2367..2336                                              */
    } mtgy_op_a73_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a74;                 /*!< (@ 0x00001928) MWMM operand A register 74                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2399..2368                                              */
    } mtgy_op_a74_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a75;                 /*!< (@ 0x0000192C) MWMM operand A register 75                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2431..2400                                              */
    } mtgy_op_a75_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a76;                 /*!< (@ 0x00001930) MWMM operand A register 76                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2463..2432                                              */
    } mtgy_op_a76_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a77;                 /*!< (@ 0x00001934) MWMM operand A register 77                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2495..2464                                              */
    } mtgy_op_a77_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a78;                 /*!< (@ 0x00001938) MWMM operand A register 78                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2527..2496                                              */
    } mtgy_op_a78_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a79;                 /*!< (@ 0x0000193C) MWMM operand A register 79                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2559..2528                                              */
    } mtgy_op_a79_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a80;                 /*!< (@ 0x00001940) MWMM operand A register 80                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2591..2560                                              */
    } mtgy_op_a80_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a81;                 /*!< (@ 0x00001944) MWMM operand A register 81                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2623..2592                                              */
    } mtgy_op_a81_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a82;                 /*!< (@ 0x00001948) MWMM operand A register 82                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2655..2624                                              */
    } mtgy_op_a82_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a83;                 /*!< (@ 0x0000194C) MWMM operand A register 83                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2687..2656                                              */
    } mtgy_op_a83_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a84;                 /*!< (@ 0x00001950) MWMM operand A register 84                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2719..2688                                              */
    } mtgy_op_a84_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a85;                 /*!< (@ 0x00001954) MWMM operand A register 85                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2751..2720                                              */
    } mtgy_op_a85_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a86;                 /*!< (@ 0x00001958) MWMM operand A register 86                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2783..2752                                              */
    } mtgy_op_a86_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a87;                 /*!< (@ 0x0000195C) MWMM operand A register 87                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2815..2784                                              */
    } mtgy_op_a87_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a88;                 /*!< (@ 0x00001960) MWMM operand A register 88                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2847..2816                                              */
    } mtgy_op_a88_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a89;                 /*!< (@ 0x00001964) MWMM operand A register 89                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2879..2848                                              */
    } mtgy_op_a89_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a90;                 /*!< (@ 0x00001968) MWMM operand A register 90                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2911..2880                                              */
    } mtgy_op_a90_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a91;                 /*!< (@ 0x0000196C) MWMM operand A register 91                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2943..2912                                              */
    } mtgy_op_a91_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a92;                 /*!< (@ 0x00001970) MWMM operand A register 92                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2975..2944                                              */
    } mtgy_op_a92_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a93;                 /*!< (@ 0x00001974) MWMM operand A register 93                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3007..2976                                              */
    } mtgy_op_a93_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a94;                 /*!< (@ 0x00001978) MWMM operand A register 94                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3039..3008                                              */
    } mtgy_op_a94_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a95;                 /*!< (@ 0x0000197C) MWMM operand A register 95                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3071..3040                                              */
    } mtgy_op_a95_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a96;                 /*!< (@ 0x00001980) MWMM operand A register 96                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3103..3072                                              */
    } mtgy_op_a96_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a97;                 /*!< (@ 0x00001984) MWMM operand A register 97                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3135..3104                                              */
    } mtgy_op_a97_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a98;                 /*!< (@ 0x00001988) MWMM operand A register 98                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3167..3136                                              */
    } mtgy_op_a98_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a99;                 /*!< (@ 0x0000198C) MWMM operand A register 99                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3199..3168                                              */
    } mtgy_op_a99_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a100;                /*!< (@ 0x00001990) MWMM operand A register 100                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3231..3200                                              */
    } mtgy_op_a100_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a101;                /*!< (@ 0x00001994) MWMM operand A register 101                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3263..3232                                              */
    } mtgy_op_a101_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a102;                /*!< (@ 0x00001998) MWMM operand A register 102                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3295..3264                                              */
    } mtgy_op_a102_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a103;                /*!< (@ 0x0000199C) MWMM operand A register 103                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3327..3296                                              */
    } mtgy_op_a103_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a104;                /*!< (@ 0x000019A0) MWMM operand A register 104                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3359..3328                                              */
    } mtgy_op_a104_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a105;                /*!< (@ 0x000019A4) MWMM operand A register 105                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3391..3360                                              */
    } mtgy_op_a105_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a106;                /*!< (@ 0x000019A8) MWMM operand A register 106                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3423..3392                                              */
    } mtgy_op_a106_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a107;                /*!< (@ 0x000019AC) MWMM operand A register 107                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3455..3424                                              */
    } mtgy_op_a107_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a108;                /*!< (@ 0x000019B0) MWMM operand A register 108                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3487..3456                                              */
    } mtgy_op_a108_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a109;                /*!< (@ 0x000019B4) MWMM operand A register 109                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3519..3488                                              */
    } mtgy_op_a109_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a110;                /*!< (@ 0x000019B8) MWMM operand A register 110                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3551..3520                                              */
    } mtgy_op_a110_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a111;                /*!< (@ 0x000019BC) MWMM operand A register 111                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3583..3552                                              */
    } mtgy_op_a111_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a112;                /*!< (@ 0x000019C0) MWMM operand A register 112                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3615..3584                                              */
    } mtgy_op_a112_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a113;                /*!< (@ 0x000019C4) MWMM operand A register 113                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3647..3616                                              */
    } mtgy_op_a113_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a114;                /*!< (@ 0x000019C8) MWMM operand A register 114                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3679..3648                                              */
    } mtgy_op_a114_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a115;                /*!< (@ 0x000019CC) MWMM operand A register 115                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3711..3680                                              */
    } mtgy_op_a115_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a116;                /*!< (@ 0x000019D0) MWMM operand A register 116                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3743..3712                                              */
    } mtgy_op_a116_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a117;                /*!< (@ 0x000019D4) MWMM operand A register 117                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3775..3744                                              */
    } mtgy_op_a117_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a118;                /*!< (@ 0x000019D8) MWMM operand A register 118                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3807..3776                                              */
    } mtgy_op_a118_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a119;                /*!< (@ 0x000019DC) MWMM operand A register 119                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3839..3808                                              */
    } mtgy_op_a119_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a120;                /*!< (@ 0x000019E0) MWMM operand A register 120                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3871..3840                                              */
    } mtgy_op_a120_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a121;                /*!< (@ 0x000019E4) MWMM operand A register 121                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3903..3872                                              */
    } mtgy_op_a121_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a122;                /*!< (@ 0x000019E8) MWMM operand A register 122                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3935..3904                                              */
    } mtgy_op_a122_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a123;                /*!< (@ 0x000019EC) MWMM operand A register 123                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3967..3936                                              */
    } mtgy_op_a123_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a124;                /*!< (@ 0x000019F0) MWMM operand A register 124                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3999..3968                                              */
    } mtgy_op_a124_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a125;                /*!< (@ 0x000019F4) MWMM operand A register 125                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4031..4000                                              */
    } mtgy_op_a125_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a126;                /*!< (@ 0x000019F8) MWMM operand A register 126                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4063..4032                                              */
    } mtgy_op_a126_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_a127;                /*!< (@ 0x000019FC) MWMM operand A register 127                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4095..4064                                              */
    } mtgy_op_a127_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e0;                  /*!< (@ 0x00001A00) MWMM operand E register 0                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } mtgy_op_e0_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e1;                  /*!< (@ 0x00001A04) MWMM operand E register 1                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } mtgy_op_e1_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e2;                  /*!< (@ 0x00001A08) MWMM operand E register 2                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } mtgy_op_e2_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e3;                  /*!< (@ 0x00001A0C) MWMM operand E register 3                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } mtgy_op_e3_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e4;                  /*!< (@ 0x00001A10) MWMM operand E register 4                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } mtgy_op_e4_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e5;                  /*!< (@ 0x00001A14) MWMM operand E register 5                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } mtgy_op_e5_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e6;                  /*!< (@ 0x00001A18) MWMM operand E register 6                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } mtgy_op_e6_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e7;                  /*!< (@ 0x00001A1C) MWMM operand E register 7                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } mtgy_op_e7_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e8;                  /*!< (@ 0x00001A20) MWMM operand E register 8                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } mtgy_op_e8_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e9;                  /*!< (@ 0x00001A24) MWMM operand E register 9                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } mtgy_op_e9_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e10;                 /*!< (@ 0x00001A28) MWMM operand E register 10                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } mtgy_op_e10_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e11;                 /*!< (@ 0x00001A2C) MWMM operand E register 11                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } mtgy_op_e11_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e12;                 /*!< (@ 0x00001A30) MWMM operand E register 12                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } mtgy_op_e12_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e13;                 /*!< (@ 0x00001A34) MWMM operand E register 13                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } mtgy_op_e13_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e14;                 /*!< (@ 0x00001A38) MWMM operand E register 14                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } mtgy_op_e14_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e15;                 /*!< (@ 0x00001A3C) MWMM operand E register 15                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } mtgy_op_e15_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e16;                 /*!< (@ 0x00001A40) MWMM operand E register 16                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 543..512                                                */
    } mtgy_op_e16_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e17;                 /*!< (@ 0x00001A44) MWMM operand E register 17                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 575..544                                                */
    } mtgy_op_e17_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e18;                 /*!< (@ 0x00001A48) MWMM operand E register 18                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 607..576                                                */
    } mtgy_op_e18_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e19;                 /*!< (@ 0x00001A4C) MWMM operand E register 19                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 639..608                                                */
    } mtgy_op_e19_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e20;                 /*!< (@ 0x00001A50) MWMM operand E register 20                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 671..640                                                */
    } mtgy_op_e20_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e21;                 /*!< (@ 0x00001A54) MWMM operand E register 21                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 703..672                                                */
    } mtgy_op_e21_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e22;                 /*!< (@ 0x00001A58) MWMM operand E register 22                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 735..704                                                */
    } mtgy_op_e22_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e23;                 /*!< (@ 0x00001A5C) MWMM operand E register 23                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 767..736                                                */
    } mtgy_op_e23_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e24;                 /*!< (@ 0x00001A60) MWMM operand E register 24                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 799..768                                                */
    } mtgy_op_e24_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e25;                 /*!< (@ 0x00001A64) MWMM operand E register 25                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 831..800                                                */
    } mtgy_op_e25_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e26;                 /*!< (@ 0x00001A68) MWMM operand E register 26                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 863..832                                                */
    } mtgy_op_e26_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e27;                 /*!< (@ 0x00001A6C) MWMM operand E register 27                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 895..864                                                */
    } mtgy_op_e27_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e28;                 /*!< (@ 0x00001A70) MWMM operand E register 28                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 927..896                                                */
    } mtgy_op_e28_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e29;                 /*!< (@ 0x00001A74) MWMM operand E register 29                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 959..928                                                */
    } mtgy_op_e29_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e30;                 /*!< (@ 0x00001A78) MWMM operand E register 30                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 991..960                                                */
    } mtgy_op_e30_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e31;                 /*!< (@ 0x00001A7C) MWMM operand E register 31                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1023..992                                               */
    } mtgy_op_e31_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e32;                 /*!< (@ 0x00001A80) MWMM operand E register 32                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1055..1024                                              */
    } mtgy_op_e32_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e33;                 /*!< (@ 0x00001A84) MWMM operand E register 33                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1087..1056                                              */
    } mtgy_op_e33_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e34;                 /*!< (@ 0x00001A88) MWMM operand E register 34                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1119..1088                                              */
    } mtgy_op_e34_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e35;                 /*!< (@ 0x00001A8C) MWMM operand E register 35                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1151..1120                                              */
    } mtgy_op_e35_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e36;                 /*!< (@ 0x00001A90) MWMM operand E register 36                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1183..1152                                              */
    } mtgy_op_e36_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e37;                 /*!< (@ 0x00001A94) MWMM operand E register 37                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1215..1184                                              */
    } mtgy_op_e37_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e38;                 /*!< (@ 0x00001A98) MWMM operand E register 38                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1247..1216                                              */
    } mtgy_op_e38_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e39;                 /*!< (@ 0x00001A9C) MWMM operand E register 39                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1279..1248                                              */
    } mtgy_op_e39_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e40;                 /*!< (@ 0x00001AA0) MWMM operand E register 40                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1311..1280                                              */
    } mtgy_op_e40_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e41;                 /*!< (@ 0x00001AA4) MWMM operand E register 41                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1343..1312                                              */
    } mtgy_op_e41_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e42;                 /*!< (@ 0x00001AA8) MWMM operand E register 42                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1375..1344                                              */
    } mtgy_op_e42_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e43;                 /*!< (@ 0x00001AAC) MWMM operand E register 43                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1407..1376                                              */
    } mtgy_op_e43_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e44;                 /*!< (@ 0x00001AB0) MWMM operand E register 44                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1439..1408                                              */
    } mtgy_op_e44_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e45;                 /*!< (@ 0x00001AB4) MWMM operand E register 45                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1471..1440                                              */
    } mtgy_op_e45_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e46;                 /*!< (@ 0x00001AB8) MWMM operand E register 46                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1503..1472                                              */
    } mtgy_op_e46_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e47;                 /*!< (@ 0x00001ABC) MWMM operand E register 47                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1535..1504                                              */
    } mtgy_op_e47_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e48;                 /*!< (@ 0x00001AC0) MWMM operand E register 48                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1567..1536                                              */
    } mtgy_op_e48_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e49;                 /*!< (@ 0x00001AC4) MWMM operand E register 49                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1599..1568                                              */
    } mtgy_op_e49_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e50;                 /*!< (@ 0x00001AC8) MWMM operand E register 50                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1631..1600                                              */
    } mtgy_op_e50_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e51;                 /*!< (@ 0x00001ACC) MWMM operand E register 51                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1663..1632                                              */
    } mtgy_op_e51_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e52;                 /*!< (@ 0x00001AD0) MWMM operand E register 52                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1695..1664                                              */
    } mtgy_op_e52_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e53;                 /*!< (@ 0x00001AD4) MWMM operand E register 53                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1727..1696                                              */
    } mtgy_op_e53_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e54;                 /*!< (@ 0x00001AD8) MWMM operand E register 54                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1759..1728                                              */
    } mtgy_op_e54_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e55;                 /*!< (@ 0x00001ADC) MWMM operand E register 55                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1791..1760                                              */
    } mtgy_op_e55_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e56;                 /*!< (@ 0x00001AE0) MWMM operand E register 56                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1823..1792                                              */
    } mtgy_op_e56_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e57;                 /*!< (@ 0x00001AE4) MWMM operand E register 57                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1855..1824                                              */
    } mtgy_op_e57_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e58;                 /*!< (@ 0x00001AE8) MWMM operand E register 58                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1887..1856                                              */
    } mtgy_op_e58_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e59;                 /*!< (@ 0x00001AEC) MWMM operand E register 59                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1919..1888                                              */
    } mtgy_op_e59_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e60;                 /*!< (@ 0x00001AF0) MWMM operand E register 60                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1951..1920                                              */
    } mtgy_op_e60_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e61;                 /*!< (@ 0x00001AF4) MWMM operand E register 61                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1983..1952                                              */
    } mtgy_op_e61_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e62;                 /*!< (@ 0x00001AF8) MWMM operand E register 62                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2015..1984                                              */
    } mtgy_op_e62_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e63;                 /*!< (@ 0x00001AFC) MWMM operand E register 63                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2047..2016                                              */
    } mtgy_op_e63_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e64;                 /*!< (@ 0x00001B00) MWMM operand E register 64                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2079..2048                                              */
    } mtgy_op_e64_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e65;                 /*!< (@ 0x00001B04) MWMM operand E register 65                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2111..2080                                              */
    } mtgy_op_e65_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e66;                 /*!< (@ 0x00001B08) MWMM operand E register 66                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2143..2112                                              */
    } mtgy_op_e66_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e67;                 /*!< (@ 0x00001B0C) MWMM operand E register 67                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2175..2144                                              */
    } mtgy_op_e67_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e68;                 /*!< (@ 0x00001B10) MWMM operand E register 68                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2207..2176                                              */
    } mtgy_op_e68_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e69;                 /*!< (@ 0x00001B14) MWMM operand E register 69                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2239..2208                                              */
    } mtgy_op_e69_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e70;                 /*!< (@ 0x00001B18) MWMM operand E register 70                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2271..2240                                              */
    } mtgy_op_e70_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e71;                 /*!< (@ 0x00001B1C) MWMM operand E register 71                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2303..2272                                              */
    } mtgy_op_e71_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e72;                 /*!< (@ 0x00001B20) MWMM operand E register 72                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2335..2304                                              */
    } mtgy_op_e72_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e73;                 /*!< (@ 0x00001B24) MWMM operand E register 73                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2367..2336                                              */
    } mtgy_op_e73_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e74;                 /*!< (@ 0x00001B28) MWMM operand E register 74                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2399..2368                                              */
    } mtgy_op_e74_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e75;                 /*!< (@ 0x00001B2C) MWMM operand E register 75                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2431..2400                                              */
    } mtgy_op_e75_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e76;                 /*!< (@ 0x00001B30) MWMM operand E register 76                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2463..2432                                              */
    } mtgy_op_e76_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e77;                 /*!< (@ 0x00001B34) MWMM operand E register 77                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2495..2464                                              */
    } mtgy_op_e77_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e78;                 /*!< (@ 0x00001B38) MWMM operand E register 78                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2527..2496                                              */
    } mtgy_op_e78_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e79;                 /*!< (@ 0x00001B3C) MWMM operand E register 79                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2559..2528                                              */
    } mtgy_op_e79_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e80;                 /*!< (@ 0x00001B40) MWMM operand E register 80                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2591..2560                                              */
    } mtgy_op_e80_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e81;                 /*!< (@ 0x00001B44) MWMM operand E register 81                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2623..2592                                              */
    } mtgy_op_e81_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e82;                 /*!< (@ 0x00001B48) MWMM operand E register 82                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2655..2624                                              */
    } mtgy_op_e82_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e83;                 /*!< (@ 0x00001B4C) MWMM operand E register 83                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2687..2656                                              */
    } mtgy_op_e83_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e84;                 /*!< (@ 0x00001B50) MWMM operand E register 84                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2719..2688                                              */
    } mtgy_op_e84_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e85;                 /*!< (@ 0x00001B54) MWMM operand E register 85                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2751..2720                                              */
    } mtgy_op_e85_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e86;                 /*!< (@ 0x00001B58) MWMM operand E register 86                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2783..2752                                              */
    } mtgy_op_e86_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e87;                 /*!< (@ 0x00001B5C) MWMM operand E register 87                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2815..2784                                              */
    } mtgy_op_e87_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e88;                 /*!< (@ 0x00001B60) MWMM operand E register 88                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2847..2816                                              */
    } mtgy_op_e88_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e89;                 /*!< (@ 0x00001B64) MWMM operand E register 89                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2879..2848                                              */
    } mtgy_op_e89_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e90;                 /*!< (@ 0x00001B68) MWMM operand E register 90                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2911..2880                                              */
    } mtgy_op_e90_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e91;                 /*!< (@ 0x00001B6C) MWMM operand E register 91                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2943..2912                                              */
    } mtgy_op_e91_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e92;                 /*!< (@ 0x00001B70) MWMM operand E register 92                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2975..2944                                              */
    } mtgy_op_e92_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e93;                 /*!< (@ 0x00001B74) MWMM operand E register 93                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3007..2976                                              */
    } mtgy_op_e93_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e94;                 /*!< (@ 0x00001B78) MWMM operand E register 94                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3039..3008                                              */
    } mtgy_op_e94_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e95;                 /*!< (@ 0x00001B7C) MWMM operand E register 95                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3071..3040                                              */
    } mtgy_op_e95_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e96;                 /*!< (@ 0x00001B80) MWMM operand E register 96                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3103..3072                                              */
    } mtgy_op_e96_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e97;                 /*!< (@ 0x00001B84) MWMM operand E register 97                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3135..3104                                              */
    } mtgy_op_e97_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e98;                 /*!< (@ 0x00001B88) MWMM operand E register 98                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3167..3136                                              */
    } mtgy_op_e98_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e99;                 /*!< (@ 0x00001B8C) MWMM operand E register 99                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3199..3168                                              */
    } mtgy_op_e99_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e100;                /*!< (@ 0x00001B90) MWMM operand E register 100                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3231..3200                                              */
    } mtgy_op_e100_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e101;                /*!< (@ 0x00001B94) MWMM operand E register 101                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3263..3232                                              */
    } mtgy_op_e101_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e102;                /*!< (@ 0x00001B98) MWMM operand E register 102                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3295..3264                                              */
    } mtgy_op_e102_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e103;                /*!< (@ 0x00001B9C) MWMM operand E register 103                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3327..3296                                              */
    } mtgy_op_e103_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e104;                /*!< (@ 0x00001BA0) MWMM operand E register 104                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3359..3328                                              */
    } mtgy_op_e104_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e105;                /*!< (@ 0x00001BA4) MWMM operand E register 105                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3391..3360                                              */
    } mtgy_op_e105_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e106;                /*!< (@ 0x00001BA8) MWMM operand E register 106                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3423..3392                                              */
    } mtgy_op_e106_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e107;                /*!< (@ 0x00001BAC) MWMM operand E register 107                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3455..3424                                              */
    } mtgy_op_e107_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e108;                /*!< (@ 0x00001BB0) MWMM operand E register 108                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3487..3456                                              */
    } mtgy_op_e108_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e109;                /*!< (@ 0x00001BB4) MWMM operand E register 109                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3519..3488                                              */
    } mtgy_op_e109_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e110;                /*!< (@ 0x00001BB8) MWMM operand E register 110                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3551..3520                                              */
    } mtgy_op_e110_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e111;                /*!< (@ 0x00001BBC) MWMM operand E register 111                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3583..3552                                              */
    } mtgy_op_e111_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e112;                /*!< (@ 0x00001BC0) MWMM operand E register 112                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3615..3584                                              */
    } mtgy_op_e112_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e113;                /*!< (@ 0x00001BC4) MWMM operand E register 113                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3647..3616                                              */
    } mtgy_op_e113_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e114;                /*!< (@ 0x00001BC8) MWMM operand E register 114                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3679..3648                                              */
    } mtgy_op_e114_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e115;                /*!< (@ 0x00001BCC) MWMM operand E register 115                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3711..3680                                              */
    } mtgy_op_e115_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e116;                /*!< (@ 0x00001BD0) MWMM operand E register 116                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3743..3712                                              */
    } mtgy_op_e116_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e117;                /*!< (@ 0x00001BD4) MWMM operand E register 117                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3775..3744                                              */
    } mtgy_op_e117_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e118;                /*!< (@ 0x00001BD8) MWMM operand E register 118                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3807..3776                                              */
    } mtgy_op_e118_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e119;                /*!< (@ 0x00001BDC) MWMM operand E register 119                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3839..3808                                              */
    } mtgy_op_e119_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e120;                /*!< (@ 0x00001BE0) MWMM operand E register 120                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3871..3840                                              */
    } mtgy_op_e120_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e121;                /*!< (@ 0x00001BE4) MWMM operand E register 121                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3903..3872                                              */
    } mtgy_op_e121_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e122;                /*!< (@ 0x00001BE8) MWMM operand E register 122                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3935..3904                                              */
    } mtgy_op_e122_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e123;                /*!< (@ 0x00001BEC) MWMM operand E register 123                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3967..3936                                              */
    } mtgy_op_e123_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e124;                /*!< (@ 0x00001BF0) MWMM operand E register 124                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3999..3968                                              */
    } mtgy_op_e124_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e125;                /*!< (@ 0x00001BF4) MWMM operand E register 125                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4031..4000                                              */
    } mtgy_op_e125_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e126;                /*!< (@ 0x00001BF8) MWMM operand E register 126                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4063..4032                                              */
    } mtgy_op_e126_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_e127;                /*!< (@ 0x00001BFC) MWMM operand E register 127                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4095..4064                                              */
    } mtgy_op_e127_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x0;                  /*!< (@ 0x00001C00) MWMM operand X register 0                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 31..0                                                   */
    } mtgy_op_x0_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x1;                  /*!< (@ 0x00001C04) MWMM operand X register 1                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 63..32                                                  */
    } mtgy_op_x1_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x2;                  /*!< (@ 0x00001C08) MWMM operand X register 2                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 95..64                                                  */
    } mtgy_op_x2_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x3;                  /*!< (@ 0x00001C0C) MWMM operand X register 3                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 127..96                                                 */
    } mtgy_op_x3_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x4;                  /*!< (@ 0x00001C10) MWMM operand X register 4                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 159..128                                                */
    } mtgy_op_x4_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x5;                  /*!< (@ 0x00001C14) MWMM operand X register 5                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 191..160                                                */
    } mtgy_op_x5_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x6;                  /*!< (@ 0x00001C18) MWMM operand X register 6                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 223..192                                                */
    } mtgy_op_x6_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x7;                  /*!< (@ 0x00001C1C) MWMM operand X register 7                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 255..224                                                */
    } mtgy_op_x7_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x8;                  /*!< (@ 0x00001C20) MWMM operand X register 8                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 287..256                                                */
    } mtgy_op_x8_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x9;                  /*!< (@ 0x00001C24) MWMM operand X register 9                                  */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 319..288                                                */
    } mtgy_op_x9_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x10;                 /*!< (@ 0x00001C28) MWMM operand X register 10                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 351..320                                                */
    } mtgy_op_x10_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x11;                 /*!< (@ 0x00001C2C) MWMM operand X register 11                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 383..352                                                */
    } mtgy_op_x11_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x12;                 /*!< (@ 0x00001C30) MWMM operand X register 12                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 415..384                                                */
    } mtgy_op_x12_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x13;                 /*!< (@ 0x00001C34) MWMM operand X register 13                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 447..416                                                */
    } mtgy_op_x13_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x14;                 /*!< (@ 0x00001C38) MWMM operand X register 14                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 479..448                                                */
    } mtgy_op_x14_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x15;                 /*!< (@ 0x00001C3C) MWMM operand X register 15                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 511..480                                                */
    } mtgy_op_x15_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x16;                 /*!< (@ 0x00001C40) MWMM operand X register 16                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 543..512                                                */
    } mtgy_op_x16_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x17;                 /*!< (@ 0x00001C44) MWMM operand X register 17                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 575..544                                                */
    } mtgy_op_x17_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x18;                 /*!< (@ 0x00001C48) MWMM operand X register 18                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 607..576                                                */
    } mtgy_op_x18_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x19;                 /*!< (@ 0x00001C4C) MWMM operand X register 19                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 639..608                                                */
    } mtgy_op_x19_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x20;                 /*!< (@ 0x00001C50) MWMM operand X register 20                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 671..640                                                */
    } mtgy_op_x20_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x21;                 /*!< (@ 0x00001C54) MWMM operand X register 21                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 703..672                                                */
    } mtgy_op_x21_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x22;                 /*!< (@ 0x00001C58) MWMM operand X register 22                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 735..704                                                */
    } mtgy_op_x22_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x23;                 /*!< (@ 0x00001C5C) MWMM operand X register 23                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 767..736                                                */
    } mtgy_op_x23_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x24;                 /*!< (@ 0x00001C60) MWMM operand X register 24                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 799..768                                                */
    } mtgy_op_x24_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x25;                 /*!< (@ 0x00001C64) MWMM operand X register 25                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 831..800                                                */
    } mtgy_op_x25_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x26;                 /*!< (@ 0x00001C68) MWMM operand X register 26                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 863..832                                                */
    } mtgy_op_x26_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x27;                 /*!< (@ 0x00001C6C) MWMM operand X register 27                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 895..864                                                */
    } mtgy_op_x27_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x28;                 /*!< (@ 0x00001C70) MWMM operand X register 28                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 927..896                                                */
    } mtgy_op_x28_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x29;                 /*!< (@ 0x00001C74) MWMM operand X register 29                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 959..928                                                */
    } mtgy_op_x29_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x30;                 /*!< (@ 0x00001C78) MWMM operand X register 30                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 991..960                                                */
    } mtgy_op_x30_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x31;                 /*!< (@ 0x00001C7C) MWMM operand X register 31                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1023..992                                               */
    } mtgy_op_x31_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x32;                 /*!< (@ 0x00001C80) MWMM operand X register 32                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1055..1024                                              */
    } mtgy_op_x32_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x33;                 /*!< (@ 0x00001C84) MWMM operand X register 33                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1087..1056                                              */
    } mtgy_op_x33_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x34;                 /*!< (@ 0x00001C88) MWMM operand X register 34                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1119..1088                                              */
    } mtgy_op_x34_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x35;                 /*!< (@ 0x00001C8C) MWMM operand X register 35                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1151..1120                                              */
    } mtgy_op_x35_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x36;                 /*!< (@ 0x00001C90) MWMM operand X register 36                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1183..1152                                              */
    } mtgy_op_x36_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x37;                 /*!< (@ 0x00001C94) MWMM operand X register 37                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1215..1184                                              */
    } mtgy_op_x37_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x38;                 /*!< (@ 0x00001C98) MWMM operand X register 38                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1247..1216                                              */
    } mtgy_op_x38_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x39;                 /*!< (@ 0x00001C9C) MWMM operand X register 39                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1279..1248                                              */
    } mtgy_op_x39_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x40;                 /*!< (@ 0x00001CA0) MWMM operand X register 40                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1311..1280                                              */
    } mtgy_op_x40_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x41;                 /*!< (@ 0x00001CA4) MWMM operand X register 41                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1343..1312                                              */
    } mtgy_op_x41_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x42;                 /*!< (@ 0x00001CA8) MWMM operand X register 42                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1375..1344                                              */
    } mtgy_op_x42_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x43;                 /*!< (@ 0x00001CAC) MWMM operand X register 43                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1407..1376                                              */
    } mtgy_op_x43_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x44;                 /*!< (@ 0x00001CB0) MWMM operand X register 44                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1439..1408                                              */
    } mtgy_op_x44_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x45;                 /*!< (@ 0x00001CB4) MWMM operand X register 45                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1471..1440                                              */
    } mtgy_op_x45_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x46;                 /*!< (@ 0x00001CB8) MWMM operand X register 46                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1503..1472                                              */
    } mtgy_op_x46_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x47;                 /*!< (@ 0x00001CBC) MWMM operand X register 47                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1535..1504                                              */
    } mtgy_op_x47_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x48;                 /*!< (@ 0x00001CC0) MWMM operand X register 48                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1567..1536                                              */
    } mtgy_op_x48_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x49;                 /*!< (@ 0x00001CC4) MWMM operand X register 49                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1599..1568                                              */
    } mtgy_op_x49_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x50;                 /*!< (@ 0x00001CC8) MWMM operand X register 50                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1631..1600                                              */
    } mtgy_op_x50_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x51;                 /*!< (@ 0x00001CCC) MWMM operand X register 51                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1663..1632                                              */
    } mtgy_op_x51_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x52;                 /*!< (@ 0x00001CD0) MWMM operand X register 52                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1695..1664                                              */
    } mtgy_op_x52_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x53;                 /*!< (@ 0x00001CD4) MWMM operand X register 53                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1727..1696                                              */
    } mtgy_op_x53_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x54;                 /*!< (@ 0x00001CD8) MWMM operand X register 54                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1759..1728                                              */
    } mtgy_op_x54_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x55;                 /*!< (@ 0x00001CDC) MWMM operand X register 55                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1791..1760                                              */
    } mtgy_op_x55_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x56;                 /*!< (@ 0x00001CE0) MWMM operand X register 56                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1823..1792                                              */
    } mtgy_op_x56_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x57;                 /*!< (@ 0x00001CE4) MWMM operand X register 57                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1855..1824                                              */
    } mtgy_op_x57_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x58;                 /*!< (@ 0x00001CE8) MWMM operand X register 58                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1887..1856                                              */
    } mtgy_op_x58_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x59;                 /*!< (@ 0x00001CEC) MWMM operand X register 59                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1919..1888                                              */
    } mtgy_op_x59_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x60;                 /*!< (@ 0x00001CF0) MWMM operand X register 60                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1951..1920                                              */
    } mtgy_op_x60_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x61;                 /*!< (@ 0x00001CF4) MWMM operand X register 61                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 1983..1952                                              */
    } mtgy_op_x61_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x62;                 /*!< (@ 0x00001CF8) MWMM operand X register 62                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2015..1984                                              */
    } mtgy_op_x62_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x63;                 /*!< (@ 0x00001CFC) MWMM operand X register 63                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2047..2016                                              */
    } mtgy_op_x63_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x64;                 /*!< (@ 0x00001D00) MWMM operand X register 64                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2079..2048                                              */
    } mtgy_op_x64_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x65;                 /*!< (@ 0x00001D04) MWMM operand X register 65                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2111..2080                                              */
    } mtgy_op_x65_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x66;                 /*!< (@ 0x00001D08) MWMM operand X register 66                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2143..2112                                              */
    } mtgy_op_x66_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x67;                 /*!< (@ 0x00001D0C) MWMM operand X register 67                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2175..2144                                              */
    } mtgy_op_x67_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x68;                 /*!< (@ 0x00001D10) MWMM operand X register 68                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2207..2176                                              */
    } mtgy_op_x68_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x69;                 /*!< (@ 0x00001D14) MWMM operand X register 69                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2239..2208                                              */
    } mtgy_op_x69_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x70;                 /*!< (@ 0x00001D18) MWMM operand X register 70                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2271..2240                                              */
    } mtgy_op_x70_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x71;                 /*!< (@ 0x00001D1C) MWMM operand X register 71                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2303..2272                                              */
    } mtgy_op_x71_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x72;                 /*!< (@ 0x00001D20) MWMM operand X register 72                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2335..2304                                              */
    } mtgy_op_x72_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x73;                 /*!< (@ 0x00001D24) MWMM operand X register 73                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2367..2336                                              */
    } mtgy_op_x73_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x74;                 /*!< (@ 0x00001D28) MWMM operand X register 74                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2399..2368                                              */
    } mtgy_op_x74_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x75;                 /*!< (@ 0x00001D2C) MWMM operand X register 75                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2431..2400                                              */
    } mtgy_op_x75_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x76;                 /*!< (@ 0x00001D30) MWMM operand X register 76                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2463..2432                                              */
    } mtgy_op_x76_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x77;                 /*!< (@ 0x00001D34) MWMM operand X register 77                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2495..2464                                              */
    } mtgy_op_x77_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x78;                 /*!< (@ 0x00001D38) MWMM operand X register 78                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2527..2496                                              */
    } mtgy_op_x78_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x79;                 /*!< (@ 0x00001D3C) MWMM operand X register 79                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2559..2528                                              */
    } mtgy_op_x79_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x80;                 /*!< (@ 0x00001D40) MWMM operand X register 80                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2591..2560                                              */
    } mtgy_op_x80_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x81;                 /*!< (@ 0x00001D44) MWMM operand X register 81                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2623..2592                                              */
    } mtgy_op_x81_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x82;                 /*!< (@ 0x00001D48) MWMM operand X register 82                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2655..2624                                              */
    } mtgy_op_x82_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x83;                 /*!< (@ 0x00001D4C) MWMM operand X register 83                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2687..2656                                              */
    } mtgy_op_x83_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x84;                 /*!< (@ 0x00001D50) MWMM operand X register 84                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2719..2688                                              */
    } mtgy_op_x84_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x85;                 /*!< (@ 0x00001D54) MWMM operand X register 85                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2751..2720                                              */
    } mtgy_op_x85_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x86;                 /*!< (@ 0x00001D58) MWMM operand X register 86                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2783..2752                                              */
    } mtgy_op_x86_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x87;                 /*!< (@ 0x00001D5C) MWMM operand X register 87                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2815..2784                                              */
    } mtgy_op_x87_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x88;                 /*!< (@ 0x00001D60) MWMM operand X register 88                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2847..2816                                              */
    } mtgy_op_x88_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x89;                 /*!< (@ 0x00001D64) MWMM operand X register 89                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2879..2848                                              */
    } mtgy_op_x89_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x90;                 /*!< (@ 0x00001D68) MWMM operand X register 90                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2911..2880                                              */
    } mtgy_op_x90_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x91;                 /*!< (@ 0x00001D6C) MWMM operand X register 91                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2943..2912                                              */
    } mtgy_op_x91_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x92;                 /*!< (@ 0x00001D70) MWMM operand X register 92                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 2975..2944                                              */
    } mtgy_op_x92_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x93;                 /*!< (@ 0x00001D74) MWMM operand X register 93                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3007..2976                                              */
    } mtgy_op_x93_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x94;                 /*!< (@ 0x00001D78) MWMM operand X register 94                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3039..3008                                              */
    } mtgy_op_x94_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x95;                 /*!< (@ 0x00001D7C) MWMM operand X register 95                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3071..3040                                              */
    } mtgy_op_x95_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x96;                 /*!< (@ 0x00001D80) MWMM operand X register 96                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3103..3072                                              */
    } mtgy_op_x96_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x97;                 /*!< (@ 0x00001D84) MWMM operand X register 97                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3135..3104                                              */
    } mtgy_op_x97_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x98;                 /*!< (@ 0x00001D88) MWMM operand X register 98                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3167..3136                                              */
    } mtgy_op_x98_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x99;                 /*!< (@ 0x00001D8C) MWMM operand X register 99                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3199..3168                                              */
    } mtgy_op_x99_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x100;                /*!< (@ 0x00001D90) MWMM operand X register 100                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3231..3200                                              */
    } mtgy_op_x100_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x101;                /*!< (@ 0x00001D94) MWMM operand X register 101                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3263..3232                                              */
    } mtgy_op_x101_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x102;                /*!< (@ 0x00001D98) MWMM operand X register 102                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3295..3264                                              */
    } mtgy_op_x102_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x103;                /*!< (@ 0x00001D9C) MWMM operand X register 103                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3327..3296                                              */
    } mtgy_op_x103_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x104;                /*!< (@ 0x00001DA0) MWMM operand X register 104                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3359..3328                                              */
    } mtgy_op_x104_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x105;                /*!< (@ 0x00001DA4) MWMM operand X register 105                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3391..3360                                              */
    } mtgy_op_x105_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x106;                /*!< (@ 0x00001DA8) MWMM operand X register 106                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3423..3392                                              */
    } mtgy_op_x106_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x107;                /*!< (@ 0x00001DAC) MWMM operand X register 107                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3455..3424                                              */
    } mtgy_op_x107_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x108;                /*!< (@ 0x00001DB0) MWMM operand X register 108                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3487..3456                                              */
    } mtgy_op_x108_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x109;                /*!< (@ 0x00001DB4) MWMM operand X register 109                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3519..3488                                              */
    } mtgy_op_x109_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x110;                /*!< (@ 0x00001DB8) MWMM operand X register 110                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3551..3520                                              */
    } mtgy_op_x110_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x111;                /*!< (@ 0x00001DBC) MWMM operand X register 111                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3583..3552                                              */
    } mtgy_op_x111_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x112;                /*!< (@ 0x00001DC0) MWMM operand X register 112                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3615..3584                                              */
    } mtgy_op_x112_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x113;                /*!< (@ 0x00001DC4) MWMM operand X register 113                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3647..3616                                              */
    } mtgy_op_x113_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x114;                /*!< (@ 0x00001DC8) MWMM operand X register 114                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3679..3648                                              */
    } mtgy_op_x114_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x115;                /*!< (@ 0x00001DCC) MWMM operand X register 115                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3711..3680                                              */
    } mtgy_op_x115_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x116;                /*!< (@ 0x00001DD0) MWMM operand X register 116                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3743..3712                                              */
    } mtgy_op_x116_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x117;                /*!< (@ 0x00001DD4) MWMM operand X register 117                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3775..3744                                              */
    } mtgy_op_x117_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x118;                /*!< (@ 0x00001DD8) MWMM operand X register 118                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3807..3776                                              */
    } mtgy_op_x118_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x119;                /*!< (@ 0x00001DDC) MWMM operand X register 119                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3839..3808                                              */
    } mtgy_op_x119_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x120;                /*!< (@ 0x00001DE0) MWMM operand X register 120                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3871..3840                                              */
    } mtgy_op_x120_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x121;                /*!< (@ 0x00001DE4) MWMM operand X register 121                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3903..3872                                              */
    } mtgy_op_x121_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x122;                /*!< (@ 0x00001DE8) MWMM operand X register 122                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3935..3904                                              */
    } mtgy_op_x122_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x123;                /*!< (@ 0x00001DEC) MWMM operand X register 123                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3967..3936                                              */
    } mtgy_op_x123_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x124;                /*!< (@ 0x00001DF0) MWMM operand X register 124                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 3999..3968                                              */
    } mtgy_op_x124_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x125;                /*!< (@ 0x00001DF4) MWMM operand X register 125                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4031..4000                                              */
    } mtgy_op_x125_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x126;                /*!< (@ 0x00001DF8) MWMM operand X register 126                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4063..4032                                              */
    } mtgy_op_x126_b;
  } ;
  
  union {
    __IOM uint32_t mtgy_op_x127;                /*!< (@ 0x00001DFC) MWMM operand X register 127                                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data bits 4095..4064                                              */
    } mtgy_op_x127_b;
  } ;
} mtgy_Type;                                    /*!< Size = 7680 (0x1e00)                                                      */



/* =========================================================================================================================== */
/* ================                                           nfifo                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief nfifo (nfifo)
  */

typedef struct {                                /*!< (@ 0xFF400000) nfifo Structure                                            */
  
  union {
    __IOM uint32_t nfifo_config;                /*!< (@ 0x00000000) NFIFO config register 'base_config' is a pointer
                                                                    to start of NFIFO configuration area in
                                                                    memory. The configuration area must be setup
                                                                    by software, before using a FIFO. Each FIFO-configuration
                                                                    entry consists of 3 DW and contains the
                                                                    following: { | mem-DW0: base(31:2),mas(1:0)
                                                                    mem-DW1: watm(28:16),bottom(12:0) mem-DW2:
                                                                    undr(31),emw(30),empty(29),write(28:16),ovfl(15),fmw(14),f
                                                                    ll(13),fill(12:0) } This allows FIFOs of
                                                                    up to 8k entries each. The first DWords
                                                                    mem-DW0 and mem-DW1 are only re                            */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t base_config : 30;          /*!< [31..2] Pointer to base_config                                            */
    } nfifo_config_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t nfifo_irq_raw;               /*!< (@ 0x0000000C) Raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit.                                                       */
    
    struct {
      __IOM uint32_t ahbl_error : 1;            /*!< [0..0] AHBL returned HRESP=1 (abort)                                      */
      __IOM uint32_t read       : 1;            /*!< [1..1] any read access happened to any FIFO                               */
      __IOM uint32_t write      : 1;            /*!< [2..2] any write access happened to any FIFO                              */
      __IOM uint32_t fifo_active : 1;           /*!< [3..3] any access to fifo_nr/fifo_wr is active (to unlock the
                                                     scheduler after locking_req)                                              */
      __IOM uint32_t observe0   : 1;            /*!< [4..4] access to FIFO as defined in observe0                              */
      __IOM uint32_t observe1   : 1;            /*!< [5..5] access to FIFO as defined in observe1                              */
      __IOM uint32_t observe2   : 1;            /*!< [6..6] access to FIFO as defined in observe2                              */
      __IOM uint32_t observe3   : 1;            /*!< [7..7] access to FIFO as defined in observe3                              */
      __IOM uint32_t observe4   : 1;            /*!< [8..8] access to FIFO as defined in observe4                              */
      __IOM uint32_t observe5   : 1;            /*!< [9..9] access to FIFO as defined in observe5                              */
      __IOM uint32_t observe6   : 1;            /*!< [10..10] access to FIFO as defined in observe6                            */
      __IOM uint32_t observe7   : 1;            /*!< [11..11] access to FIFO as defined in observe7                            */
      __IOM uint32_t observe8   : 1;            /*!< [12..12] access to FIFO as defined in observe8                            */
      __IOM uint32_t observe9   : 1;            /*!< [13..13] access to FIFO as defined in observe9                            */
    } nfifo_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t nfifo_irq_arm_app_masked;    /*!< (@ 0x00000010) Masked IRQ of ARM_APP: Shows status of masked
                                                                    IRQs as connected to application ARM Cortex
                                                                    M4.                                                        */
    
    struct {
      __IM  uint32_t ahbl_error : 1;            /*!< [0..0] AHBL returned HRESP=1 (abort)                                      */
      __IM  uint32_t read       : 1;            /*!< [1..1] any read access happened to any FIFO                               */
      __IM  uint32_t write      : 1;            /*!< [2..2] any write access happened to any FIFO                              */
      __IM  uint32_t fifo_active : 1;           /*!< [3..3] any access to fifo_nr/fifo_wr is active (to unlock the
                                                     scheduler after locking_req)                                              */
      __IM  uint32_t observe0   : 1;            /*!< [4..4] access to FIFO as defined in observe0                              */
      __IM  uint32_t observe1   : 1;            /*!< [5..5] access to FIFO as defined in observe1                              */
      __IM  uint32_t observe2   : 1;            /*!< [6..6] access to FIFO as defined in observe2                              */
      __IM  uint32_t observe3   : 1;            /*!< [7..7] access to FIFO as defined in observe3                              */
      __IM  uint32_t observe4   : 1;            /*!< [8..8] access to FIFO as defined in observe4                              */
      __IM  uint32_t observe5   : 1;            /*!< [9..9] access to FIFO as defined in observe5                              */
      __IM  uint32_t observe6   : 1;            /*!< [10..10] access to FIFO as defined in observe6                            */
      __IM  uint32_t observe7   : 1;            /*!< [11..11] access to FIFO as defined in observe7                            */
      __IM  uint32_t observe8   : 1;            /*!< [12..12] access to FIFO as defined in observe8                            */
      __IM  uint32_t observe9   : 1;            /*!< [13..13] access to FIFO as defined in observe9                            */
    } nfifo_irq_arm_app_masked_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_arm_app_msk_set;   /*!< (@ 0x00000014) ARM_APP Cortex M4 IRQ mask set: The IRQ mask
                                                                    enables interrupt requests for corresponding
                                                                    interrupt sources to the ARM_APP processor.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing t                                               */
    
    struct {
      __IOM uint32_t ahbl_error : 1;            /*!< [0..0] AHBL returned HRESP=1 (abort)                                      */
      __IOM uint32_t read       : 1;            /*!< [1..1] any read access happened to any FIFO                               */
      __IOM uint32_t write      : 1;            /*!< [2..2] any write access happened to any FIFO                              */
      __IOM uint32_t fifo_active : 1;           /*!< [3..3] any access to fifo_nr/fifo_wr is active (to unlock the
                                                     scheduler after locking_req)                                              */
      __IOM uint32_t observe0   : 1;            /*!< [4..4] access to FIFO as defined in observe0                              */
      __IOM uint32_t observe1   : 1;            /*!< [5..5] access to FIFO as defined in observe1                              */
      __IOM uint32_t observe2   : 1;            /*!< [6..6] access to FIFO as defined in observe2                              */
      __IOM uint32_t observe3   : 1;            /*!< [7..7] access to FIFO as defined in observe3                              */
      __IOM uint32_t observe4   : 1;            /*!< [8..8] access to FIFO as defined in observe4                              */
      __IOM uint32_t observe5   : 1;            /*!< [9..9] access to FIFO as defined in observe5                              */
      __IOM uint32_t observe6   : 1;            /*!< [10..10] access to FIFO as defined in observe6                            */
      __IOM uint32_t observe7   : 1;            /*!< [11..11] access to FIFO as defined in observe7                            */
      __IOM uint32_t observe8   : 1;            /*!< [12..12] access to FIFO as defined in observe8                            */
      __IOM uint32_t observe9   : 1;            /*!< [13..13] access to FIFO as defined in observe9                            */
    } nfifo_irq_arm_app_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_arm_app_msk_reset; /*!< (@ 0x00000018) ARM_APP Cortex M4 IRQ mask reset: This is the
                                                                    corresponding reset mask to disable interrupt
                                                                    requests for corresponding interrupt sources:
                                                                    Write access with '1' resets interrupt mask
                                                                    bit. Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t ahbl_error : 1;            /*!< [0..0] AHBL returned HRESP=1 (abort)                                      */
      __IOM uint32_t read       : 1;            /*!< [1..1] any read access happened to any FIFO                               */
      __IOM uint32_t write      : 1;            /*!< [2..2] any write access happened to any FIFO                              */
      __IOM uint32_t fifo_active : 1;           /*!< [3..3] any access to fifo_nr/fifo_wr is active (to unlock the
                                                     scheduler after locking_req)                                              */
      __IOM uint32_t observe0   : 1;            /*!< [4..4] access to FIFO as defined in observe0                              */
      __IOM uint32_t observe1   : 1;            /*!< [5..5] access to FIFO as defined in observe1                              */
      __IOM uint32_t observe2   : 1;            /*!< [6..6] access to FIFO as defined in observe2                              */
      __IOM uint32_t observe3   : 1;            /*!< [7..7] access to FIFO as defined in observe3                              */
      __IOM uint32_t observe4   : 1;            /*!< [8..8] access to FIFO as defined in observe4                              */
      __IOM uint32_t observe5   : 1;            /*!< [9..9] access to FIFO as defined in observe5                              */
      __IOM uint32_t observe6   : 1;            /*!< [10..10] access to FIFO as defined in observe6                            */
      __IOM uint32_t observe7   : 1;            /*!< [11..11] access to FIFO as defined in observe7                            */
      __IOM uint32_t observe8   : 1;            /*!< [12..12] access to FIFO as defined in observe8                            */
      __IOM uint32_t observe9   : 1;            /*!< [13..13] access to FIFO as defined in observe9                            */
    } nfifo_irq_arm_app_msk_reset_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IM  uint32_t nfifo_irq_xpic_app_masked;   /*!< (@ 0x00000028) Masked IRQ of xPIC_APP: Shows status of masked
                                                                    IRQs as connected to xPIC_APP.                             */
    
    struct {
      __IM  uint32_t ahbl_error : 1;            /*!< [0..0] AHBL returned HRESP=1 (abort)                                      */
      __IM  uint32_t read       : 1;            /*!< [1..1] any read access happened to any FIFO                               */
      __IM  uint32_t write      : 1;            /*!< [2..2] any write access happened to any FIFO                              */
      __IM  uint32_t fifo_active : 1;           /*!< [3..3] any access to fifo_nr/fifo_wr is active (to unlock the
                                                     scheduler after locking_req)                                              */
      __IM  uint32_t observe0   : 1;            /*!< [4..4] access to FIFO as defined in observe0                              */
      __IM  uint32_t observe1   : 1;            /*!< [5..5] access to FIFO as defined in observe1                              */
      __IM  uint32_t observe2   : 1;            /*!< [6..6] access to FIFO as defined in observe2                              */
      __IM  uint32_t observe3   : 1;            /*!< [7..7] access to FIFO as defined in observe3                              */
      __IM  uint32_t observe4   : 1;            /*!< [8..8] access to FIFO as defined in observe4                              */
      __IM  uint32_t observe5   : 1;            /*!< [9..9] access to FIFO as defined in observe5                              */
      __IM  uint32_t observe6   : 1;            /*!< [10..10] access to FIFO as defined in observe6                            */
      __IM  uint32_t observe7   : 1;            /*!< [11..11] access to FIFO as defined in observe7                            */
      __IM  uint32_t observe8   : 1;            /*!< [12..12] access to FIFO as defined in observe8                            */
      __IM  uint32_t observe9   : 1;            /*!< [13..13] access to FIFO as defined in observe9                            */
    } nfifo_irq_xpic_app_masked_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_xpic_app_msk_set;  /*!< (@ 0x0000002C) xPIC_APP IRQ mask set: The xPIC_APP IRQ mask
                                                                    enables interrupt requests for corresponding
                                                                    interrupt sources to the xPIC_APP processor.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing                                                 */
    
    struct {
      __IOM uint32_t ahbl_error : 1;            /*!< [0..0] AHBL returned HRESP=1 (abort)                                      */
      __IOM uint32_t read       : 1;            /*!< [1..1] any read access happened to any FIFO                               */
      __IOM uint32_t write      : 1;            /*!< [2..2] any write access happened to any FIFO                              */
      __IOM uint32_t fifo_active : 1;           /*!< [3..3] any access to fifo_nr/fifo_wr is active (to unlock the
                                                     scheduler after locking_req)                                              */
      __IOM uint32_t observe0   : 1;            /*!< [4..4] access to FIFO as defined in observe0                              */
      __IOM uint32_t observe1   : 1;            /*!< [5..5] access to FIFO as defined in observe1                              */
      __IOM uint32_t observe2   : 1;            /*!< [6..6] access to FIFO as defined in observe2                              */
      __IOM uint32_t observe3   : 1;            /*!< [7..7] access to FIFO as defined in observe3                              */
      __IOM uint32_t observe4   : 1;            /*!< [8..8] access to FIFO as defined in observe4                              */
      __IOM uint32_t observe5   : 1;            /*!< [9..9] access to FIFO as defined in observe5                              */
      __IOM uint32_t observe6   : 1;            /*!< [10..10] access to FIFO as defined in observe6                            */
      __IOM uint32_t observe7   : 1;            /*!< [11..11] access to FIFO as defined in observe7                            */
      __IOM uint32_t observe8   : 1;            /*!< [12..12] access to FIFO as defined in observe8                            */
      __IOM uint32_t observe9   : 1;            /*!< [13..13] access to FIFO as defined in observe9                            */
    } nfifo_irq_xpic_app_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_xpic_app_msk_reset;/*!< (@ 0x00000030) xPIC_APP IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t ahbl_error : 1;            /*!< [0..0] AHBL returned HRESP=1 (abort)                                      */
      __IOM uint32_t read       : 1;            /*!< [1..1] any read access happened to any FIFO                               */
      __IOM uint32_t write      : 1;            /*!< [2..2] any write access happened to any FIFO                              */
      __IOM uint32_t fifo_active : 1;           /*!< [3..3] any access to fifo_nr/fifo_wr is active (to unlock the
                                                     scheduler after locking_req)                                              */
      __IOM uint32_t observe0   : 1;            /*!< [4..4] access to FIFO as defined in observe0                              */
      __IOM uint32_t observe1   : 1;            /*!< [5..5] access to FIFO as defined in observe1                              */
      __IOM uint32_t observe2   : 1;            /*!< [6..6] access to FIFO as defined in observe2                              */
      __IOM uint32_t observe3   : 1;            /*!< [7..7] access to FIFO as defined in observe3                              */
      __IOM uint32_t observe4   : 1;            /*!< [8..8] access to FIFO as defined in observe4                              */
      __IOM uint32_t observe5   : 1;            /*!< [9..9] access to FIFO as defined in observe5                              */
      __IOM uint32_t observe6   : 1;            /*!< [10..10] access to FIFO as defined in observe6                            */
      __IOM uint32_t observe7   : 1;            /*!< [11..11] access to FIFO as defined in observe7                            */
      __IOM uint32_t observe8   : 1;            /*!< [12..12] access to FIFO as defined in observe8                            */
      __IOM uint32_t observe9   : 1;            /*!< [13..13] access to FIFO as defined in observe9                            */
    } nfifo_irq_xpic_app_msk_reset_b;
  } ;
  __IM  uint32_t  RESERVED2[9];
  
  union {
    __IOM uint32_t nfifo_irq_observe0;          /*!< (@ 0x00000058) FIFO OBSERVE0: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe0_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe1;          /*!< (@ 0x0000005C) FIFO OBSERVE1: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe1_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe2;          /*!< (@ 0x00000060) FIFO OBSERVE2: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe2_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe3;          /*!< (@ 0x00000064) FIFO OBSERVE3: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe3_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe4;          /*!< (@ 0x00000068) FIFO OBSERVE4: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe4_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe5;          /*!< (@ 0x0000006C) FIFO OBSERVE5: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe5_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe6;          /*!< (@ 0x00000070) FIFO OBSERVE6: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe6_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe7;          /*!< (@ 0x00000074) FIFO OBSERVE7: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe7_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe8;          /*!< (@ 0x00000078) FIFO OBSERVE8: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe8_b;
  } ;
  
  union {
    __IOM uint32_t nfifo_irq_observe9;          /*!< (@ 0x0000007C) FIFO OBSERVE9: This register configures the observation
                                                                    unit that allows to observe one FIFO for
                                                                    special events                                             */
    
    struct {
      __IOM uint32_t fifonr     : 10;           /*!< [9..0] Number of FIFO to be observed                                      */
      __IOM uint32_t reserved0  : 5;            /*!< [14..10] reserved                                                         */
      __IOM uint32_t read       : 1;            /*!< [15..15] Activate IRQ in case of any read access                          */
      __IOM uint32_t undr       : 1;            /*!< [16..16] Activate IRQ in case of FIFO underrun                            */
      __IOM uint32_t emw        : 1;            /*!< [17..17] Activate IRQ in case of Empty-Minus-Watermark is set             */
      __IOM uint32_t empty      : 1;            /*!< [18..18] Activate IRQ in case of FIFO gets empty                          */
      __IOM uint32_t write      : 1;            /*!< [19..19] Activate IRQ in case of any write access                         */
      __IOM uint32_t ovfl       : 1;            /*!< [20..20] Activate IRQ in case of FIFO overflow                            */
      __IOM uint32_t fmw        : 1;            /*!< [21..21] Activate IRQ in case of Full-Minus-Watermark is set              */
      __IOM uint32_t full       : 1;            /*!< [22..22] Activate IRQ in case of FIFO gets full                           */
      __IOM uint32_t reserved1  : 9;            /*!< [31..23] reserved                                                         */
    } nfifo_irq_observe9_b;
  } ;
  __IOM uint32_t* nfifo_fifo_start;             /*!< (@ 0x00000080) Start of NFIFO FIFO access addresses: The following
                                                                    DW-addresses are associated with FIFOs:
                                                                    Read accesses to an address in this area
                                                                    are reading from the appropriate FIFO, write
                                                                    accesses to an address in this area are
                                                                    writing to the appropriate FIFO. The number
                                                                    of FIFOs is limited by this address area
                                                                    to 991.                                                    */
  __IM  uint32_t  RESERVED3[990];
  __IOM uint32_t* nfifo_fifo_end;               /*!< (@ 0x00000FFC) End of NFIFO FIFO access addresses                         */
} nfifo_Type;                                   /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                         pad_ctrl                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief pad_ctrl (pad_ctrl)
  */

typedef struct {                                /*!< (@ 0xFF401000) pad_ctrl Structure                                         */
  
  union {
    __IOM uint32_t pad_ctrl_rdy_n;              /*!< (@ 0x00000000) Pad configuration register of port RDY_N (asic_ctrl_access_key
                                                                    protected). Pad type: PRUW0408SCDG_33 This
                                                                    register is protected by the netX access-key
                                                                    mechanism; changing this register is only
                                                                    possible by the following sequence: 1.:
                                                                    read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register Programable pad functions are:
                                                                    ds: Driving strength: 0: low driving strength
                                                                    (default), 1: high driving st                              */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_rdy_n_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_run_n;              /*!< (@ 0x00000004) Pad configuration register of port RUN_N (asic_ctrl_access_key
                                                                    protected). Pad type: PRUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_run_n_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mled0;              /*!< (@ 0x00000008) Pad configuration register of port MLED0 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408CDG_33(o)
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 27;           /*!< [31..5] reserved                                                          */
    } pad_ctrl_mled0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mled1;              /*!< (@ 0x0000000C) Pad configuration register of port MLED1 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408CDG_33(o)
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 27;           /*!< [31..5] reserved                                                          */
    } pad_ctrl_mled1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mled2;              /*!< (@ 0x00000010) Pad configuration register of port MLED2 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408CDG_33(o)
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 27;           /*!< [31..5] reserved                                                          */
    } pad_ctrl_mled2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mled3;              /*!< (@ 0x00000014) Pad configuration register of port MLED3 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408CDG_33(o)
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 27;           /*!< [31..5] reserved                                                          */
    } pad_ctrl_mled3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_com_io0;            /*!< (@ 0x00000018) Pad configuration register of port COM_IO0 (asic_ctrl_access_ke
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_com_io0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_com_io1;            /*!< (@ 0x0000001C) Pad configuration register of port COM_IO1 (asic_ctrl_access_ke
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_com_io1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_com_io2;            /*!< (@ 0x00000020) Pad configuration register of port COM_IO2 (asic_ctrl_access_ke
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_com_io2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_com_io3;            /*!< (@ 0x00000024) Pad configuration register of port COM_IO3 (asic_ctrl_access_ke
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_com_io3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_rxclk;         /*!< (@ 0x00000028) Pad configuration register of port MII0_RXCLK
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_rxclk_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_rxd0;          /*!< (@ 0x0000002C) Pad configuration register of port MII0_RXD0
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_rxd0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_rxd1;          /*!< (@ 0x00000030) Pad configuration register of port MII0_RXD1
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_rxd1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_rxd2;          /*!< (@ 0x00000034) Pad configuration register of port MII0_RXD2
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_rxd2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_rxd3;          /*!< (@ 0x00000038) Pad configuration register of port MII0_RXD3
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_rxd3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_rxdv;          /*!< (@ 0x0000003C) Pad configuration register of port MII0_RXDV
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_rxdv_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_rxer;          /*!< (@ 0x00000040) Pad configuration register of port MII0_RXER
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_rxer_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_txclk;         /*!< (@ 0x00000044) Pad configuration register of port MII0_TXCLK
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_txclk_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_txd0;          /*!< (@ 0x00000048) Pad configuration register of port MII0_TXD0
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_txd0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_txd1;          /*!< (@ 0x0000004C) Pad configuration register of port MII0_TXD1
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_txd1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_txd2;          /*!< (@ 0x00000050) Pad configuration register of port MII0_TXD2
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_txd2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_txd3;          /*!< (@ 0x00000054) Pad configuration register of port MII0_TXD3
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_txd3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_txen;          /*!< (@ 0x00000058) Pad configuration register of port MII0_TXEN
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_txen_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_col;           /*!< (@ 0x0000005C) Pad configuration register of port MII0_COL (asic_ctrl_access_k
                                                                    y protected). Pad type: PRDW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_col_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii0_crs;           /*!< (@ 0x00000060) Pad configuration register of port MII0_CRS (asic_ctrl_access_k
                                                                    y protected). Pad type: PRDW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii0_crs_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_phy0_led_link_in;   /*!< (@ 0x00000064) Pad configuration register of port PHY0_LED_LINK_IN
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_phy0_led_link_in_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_rxclk;         /*!< (@ 0x00000068) Pad configuration register of port MII1_RXCLK
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_rxclk_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_rxd0;          /*!< (@ 0x0000006C) Pad configuration register of port MII1_RXD0
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i_double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_rxd0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_rxd1;          /*!< (@ 0x00000070) Pad configuration register of port MII1_RXD1
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0408SCDG_33(double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_rxd1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_rxd2;          /*!< (@ 0x00000074) Pad configuration register of port MII1_RXD2
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0408SCDG_33(double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_rxd2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_rxd3;          /*!< (@ 0x00000078) Pad configuration register of port MII1_RXD3
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i_double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_rxd3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_rxdv;          /*!< (@ 0x0000007C) Pad configuration register of port MII1_RXDV
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_rxdv_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_rxer;          /*!< (@ 0x00000080) Pad configuration register of port MII1_RXER
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_rxer_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_txclk;         /*!< (@ 0x00000084) Pad configuration register of port MII1_TXCLK
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_txclk_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_txd0;          /*!< (@ 0x00000088) Pad configuration register of port MII1_TXD0
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33(double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_txd0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_txd1;          /*!< (@ 0x0000008C) Pad configuration register of port MII1_TXD1
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33(double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_txd1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_txd2;          /*!< (@ 0x00000090) Pad configuration register of port MII1_TXD2
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33(double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_txd2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_txd3;          /*!< (@ 0x00000094) Pad configuration register of port MII1_TXD3
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33(double_bond) For details
                                                                    refer to description of register pad_ctrl_rdy_n.           */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, disabled by default)                   */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (disabled by default)                                 */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_txd3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_txen;          /*!< (@ 0x00000098) Pad configuration register of port MII1_TXEN
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_txen_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_col;           /*!< (@ 0x0000009C) Pad configuration register of port MII1_COL (asic_ctrl_access_k
                                                                    y protected). Pad type: PRDW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_col_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii1_crs;           /*!< (@ 0x000000A0) Pad configuration register of port MII1_CRS (asic_ctrl_access_k
                                                                    y protected). Pad type: PRDW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii1_crs_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_phy1_led_link_in;   /*!< (@ 0x000000A4) Pad configuration register of port PHY1_LED_LINK_IN
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDDW0204SCDG_33(i) For details refer to
                                                                    description of register pad_ctrl_rdy_n.                    */
    
    struct {
      __IOM uint32_t reserved0  : 4;            /*!< [3..0] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_phy1_led_link_in_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii_mdc;            /*!< (@ 0x000000A8) Pad configuration register of port MII_MDC (asic_ctrl_access_ke
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii_mdc_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mii_mdio;           /*!< (@ 0x000000AC) Pad configuration register of port MII_MDIO (asic_ctrl_access_k
                                                                    y protected). Pad type: PRDW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mii_mdio_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_rst_out_n;          /*!< (@ 0x000000B0) Pad configuration register of port RST_OUT_N
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PRDW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_rst_out_n_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_clk25out;           /*!< (@ 0x000000B4) Pad configuration register of port CLK25OUT (asic_ctrl_access_k
                                                                    y protected). Pad type: PRDW0408CDG_33(o)
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 27;           /*!< [31..5] reserved                                                          */
    } pad_ctrl_clk25out_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio0;              /*!< (@ 0x000000B8) Pad configuration register of port MMIO0 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio1;              /*!< (@ 0x000000BC) Pad configuration register of port MMIO1 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio2;              /*!< (@ 0x000000C0) Pad configuration register of port MMIO2 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio3;              /*!< (@ 0x000000C4) Pad configuration register of port MMIO3 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio4;              /*!< (@ 0x000000C8) Pad configuration register of port MMIO4 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_ANA_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (shared analog function, disabled by default)         */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio4_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio5;              /*!< (@ 0x000000CC) Pad configuration register of port MMIO5 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_ANA_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (shared analog function, disabled by default)         */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio5_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio6;              /*!< (@ 0x000000D0) Pad configuration register of port MMIO6 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_ANA_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (shared analog function, disabled by default)         */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio6_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_mmio7;              /*!< (@ 0x000000D4) Pad configuration register of port MMIO7 (asic_ctrl_access_key
                                                                    protected). Pad type: PRDW0408SCDG_ANA_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-down pad, enabled by default)                    */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (shared analog function, disabled by default)         */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_mmio7_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_sqi_clk;            /*!< (@ 0x000000D8) Pad configuration register of port SQI_CLK (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_sqi_clk_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_sqi_cs0n;           /*!< (@ 0x000000DC) Pad configuration register of port SQI_CS0N (asic_ctrl_access_k
                                                                    y protected). Pad type: PDUW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_sqi_cs0n_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_sqi_mosi;           /*!< (@ 0x000000E0) Pad configuration register of port SQI_MOSI (asic_ctrl_access_k
                                                                    y protected). Pad type: PDUW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_sqi_mosi_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_sqi_miso;           /*!< (@ 0x000000E4) Pad configuration register of port SQI_MISO (asic_ctrl_access_k
                                                                    y protected). Pad type: PDUW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_sqi_miso_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_sqi_sio2;           /*!< (@ 0x000000E8) Pad configuration register of port SQI_SIO2 (asic_ctrl_access_k
                                                                    y protected). Pad type: PDUW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_sqi_sio2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_sqi_sio3;           /*!< (@ 0x000000EC) Pad configuration register of port SQI_SIO3 (asic_ctrl_access_k
                                                                    y protected). Pad type: PDUW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_sqi_sio3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a0;             /*!< (@ 0x000000F0) Pad configuration register of port HIF_A0 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a1;             /*!< (@ 0x000000F4) Pad configuration register of port HIF_A1 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a2;             /*!< (@ 0x000000F8) Pad configuration register of port HIF_A2 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a3;             /*!< (@ 0x000000FC) Pad configuration register of port HIF_A3 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a4;             /*!< (@ 0x00000100) Pad configuration register of port HIF_A4 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a4_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a5;             /*!< (@ 0x00000104) Pad configuration register of port HIF_A5 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a5_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a6;             /*!< (@ 0x00000108) Pad configuration register of port HIF_A6 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a6_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a7;             /*!< (@ 0x0000010C) Pad configuration register of port HIF_A7 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a7_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a8;             /*!< (@ 0x00000110) Pad configuration register of port HIF_A8 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a8_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a9;             /*!< (@ 0x00000114) Pad configuration register of port HIF_A9 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a9_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a10;            /*!< (@ 0x00000118) Pad configuration register of port HIF_A10 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a10_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a11;            /*!< (@ 0x0000011C) Pad configuration register of port HIF_A11 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a11_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a12;            /*!< (@ 0x00000120) Pad configuration register of port HIF_A12 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a12_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a13;            /*!< (@ 0x00000124) Pad configuration register of port HIF_A13 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a13_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a14;            /*!< (@ 0x00000128) Pad configuration register of port HIF_A14 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a14_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a15;            /*!< (@ 0x0000012C) Pad configuration register of port HIF_A15 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a15_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a16;            /*!< (@ 0x00000130) Pad configuration register of port HIF_A16 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a16_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_a17;            /*!< (@ 0x00000134) Pad configuration register of port HIF_A17 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_a17_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d0;             /*!< (@ 0x00000138) Pad configuration register of port HIF_D0 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d0_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d1;             /*!< (@ 0x0000013C) Pad configuration register of port HIF_D1 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d1_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d2;             /*!< (@ 0x00000140) Pad configuration register of port HIF_D2 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d2_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d3;             /*!< (@ 0x00000144) Pad configuration register of port HIF_D3 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d3_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d4;             /*!< (@ 0x00000148) Pad configuration register of port HIF_D4 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d4_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d5;             /*!< (@ 0x0000014C) Pad configuration register of port HIF_D5 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d5_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d6;             /*!< (@ 0x00000150) Pad configuration register of port HIF_D6 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d6_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d7;             /*!< (@ 0x00000154) Pad configuration register of port HIF_D7 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d7_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d8;             /*!< (@ 0x00000158) Pad configuration register of port HIF_D8 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d8_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d9;             /*!< (@ 0x0000015C) Pad configuration register of port HIF_D9 (asic_ctrl_access_key
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d9_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d10;            /*!< (@ 0x00000160) Pad configuration register of port HIF_D10 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d10_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d11;            /*!< (@ 0x00000164) Pad configuration register of port HIF_D11 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d11_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d12;            /*!< (@ 0x00000168) Pad configuration register of port HIF_D12 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d12_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d13;            /*!< (@ 0x0000016C) Pad configuration register of port HIF_D13 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d13_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d14;            /*!< (@ 0x00000170) Pad configuration register of port HIF_D14 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d14_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_d15;            /*!< (@ 0x00000174) Pad configuration register of port HIF_D15 (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_d15_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_bhen;           /*!< (@ 0x00000178) Pad configuration register of port HIF_BHEN (asic_ctrl_access_k
                                                                    y protected). Pad type: PDUW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_bhen_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_csn;            /*!< (@ 0x0000017C) Pad configuration register of port HIF_CSN (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_csn_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_rdn;            /*!< (@ 0x00000180) Pad configuration register of port HIF_RDN (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_rdn_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_wrn;            /*!< (@ 0x00000184) Pad configuration register of port HIF_WRN (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_wrn_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_rdy;            /*!< (@ 0x00000188) Pad configuration register of port HIF_RDY (asic_ctrl_access_ke
                                                                    protected). Pad type: PDUW0408SCDG_33 For
                                                                    details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_rdy_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_dirq;           /*!< (@ 0x0000018C) Pad configuration register of port HIF_DIRQ (asic_ctrl_access_k
                                                                    y protected). Pad type: PDUW0408SCDG_33
                                                                    For details refer to description of register
                                                                    pad_ctrl_rdy_n.                                            */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_dirq_b;
  } ;
  
  union {
    __IOM uint32_t pad_ctrl_hif_sdclk;          /*!< (@ 0x00000190) Pad configuration register of port HIF_SDCLK
                                                                    (asic_ctrl_access_key protected). Pad type:
                                                                    PDUW0408SCDG_33 For details refer to description
                                                                    of register pad_ctrl_rdy_n.                                */
    
    struct {
      __IOM uint32_t ds         : 1;            /*!< [0..0] driving strength (low by default)                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t pe         : 1;            /*!< [4..4] pull enable (pull-up pad, enabled by default)                      */
      __IOM uint32_t reserved1  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t ie         : 1;            /*!< [6..6] input enable (enabled by default)                                  */
      __IOM uint32_t reserved2  : 25;           /*!< [31..7] reserved                                                          */
    } pad_ctrl_hif_sdclk_b;
  } ;
} pad_ctrl_Type;                                /*!< Size = 404 (0x194)                                                        */



/* =========================================================================================================================== */
/* ================                                         asic_ctrl                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief asic_ctrl (asic_ctrl)
  */

typedef struct {                                /*!< (@ 0xFF401200) asic_ctrl Structure                                        */
  
  union {
    __IM  uint32_t io_config0;                  /*!< (@ 0x00000000) IO Config0 Register: reserved for COM side                 */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] reserved                                                          */
    } io_config0_b;
  } ;
  
  union {
    __IM  uint32_t io_config0_mask;             /*!< (@ 0x00000004) IO Config0 Mask Register: reserved for COM side            */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] reserved                                                          */
    } io_config0_mask_b;
  } ;
  
  union {
    __IM  uint32_t io_config1;                  /*!< (@ 0x00000008) IO Config1 Register: reserved for COM side                 */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] reserved                                                          */
    } io_config1_b;
  } ;
  
  union {
    __IM  uint32_t io_config1_mask;             /*!< (@ 0x0000000C) IO Config1 Mask Register: reserved for COM side            */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] reserved                                                          */
    } io_config1_mask_b;
  } ;
  
  union {
    __IM  uint32_t io_config2;                  /*!< (@ 0x00000010) IO Config2 Register: reserved for COM side                 */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] reserved                                                          */
    } io_config2_b;
  } ;
  
  union {
    __IM  uint32_t io_config2_mask;             /*!< (@ 0x00000014) IO Config2 Mask Register: reserved for COM side            */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] reserved                                                          */
    } io_config2_mask_b;
  } ;
  
  union {
    __IOM uint32_t io_config3;                  /*!< (@ 0x00000018) IO Config3 Register: Selects of output pin multiplexing.
                                                                    See Excel pinning sheet for details. Changes
                                                                    will only have effect if according bit in
                                                                    io_config3_mask-register is set. This register
                                                                    is protected by the netX access-key mechanism;
                                                                    changing this register is only possible
                                                                    by the following sequence: 1.: read out
                                                                    access-key from asic_ctrl_access_key register
                                                                    2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t sel_gpio0  : 1;            /*!< [0..0] select pad for gpio0 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio1  : 1;            /*!< [1..1] select pad for gpio1 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio2  : 1;            /*!< [2..2] select pad for gpio2 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio3  : 1;            /*!< [3..3] select pad for gpio3 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio4  : 1;            /*!< [4..4] select pad for gpio4 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio5  : 1;            /*!< [5..5] select pad for gpio5 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio6  : 1;            /*!< [6..6] select pad for gpio6 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio7  : 1;            /*!< [7..7] select pad for gpio7 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_endat0 : 1;            /*!< [8..8] select pads EnDAT ch 0 (s. pinning table)                          */
      __IOM uint32_t sel_endat0_devel : 1;      /*!< [9..9] select pads EnDAT ch 0 development function (s. pinning
                                                     table) Note: EnDAT development function outputs are delayed
                                                     by one sys-clk.                                                           */
      __IOM uint32_t sel_endat1 : 1;            /*!< [10..10] select pads EnDAT ch 1 (s. pinning table)                        */
      __IOM uint32_t sel_endat1_devel : 1;      /*!< [11..11] select pads EnDAT ch 1 development function (s. pinning
                                                     table) Note: EnDAT development function outputs are delayed
                                                     by one sys-clk.                                                           */
      __IOM uint32_t sel_biss0  : 1;            /*!< [12..12] select pads BISS ch 0 (s. pinning table)                         */
      __IOM uint32_t sel_biss0_mo : 1;          /*!< [13..13] select pad BISS ch 0 MO (s. pinning table)                       */
      __IOM uint32_t sel_biss1  : 1;            /*!< [14..14] select pads BISS ch 1 (s. pinning table)                         */
      __IOM uint32_t sel_biss1_mo : 1;          /*!< [15..15] select pad BISS ch 1 MO (s. pinning table)                       */
    } io_config3_b;
  } ;
  
  union {
    __IOM uint32_t io_config3_mask;             /*!< (@ 0x0000001C) IO Config3 Mask Register: This register might
                                                                    be used to lock special IO configurations
                                                                    for restricted netX devices. Any bit of
                                                                    the io_config3 register can only be set,
                                                                    if the corresponding mask bit in this register
                                                                    is set either. This register is lockable
                                                                    by asic_ctrl_com_netx_lock-lock_register.                  */
    
    struct {
      __IOM uint32_t sel_gpio0  : 1;            /*!< [0..0] select pad for gpio0 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio1  : 1;            /*!< [1..1] select pad for gpio1 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio2  : 1;            /*!< [2..2] select pad for gpio2 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio3  : 1;            /*!< [3..3] select pad for gpio3 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio4  : 1;            /*!< [4..4] select pad for gpio4 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio5  : 1;            /*!< [5..5] select pad for gpio5 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio6  : 1;            /*!< [6..6] select pad for gpio6 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_gpio7  : 1;            /*!< [7..7] select pad for gpio7 (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_endat0 : 1;            /*!< [8..8] select pads EnDAT ch 0 (s. pinning table)                          */
      __IOM uint32_t sel_endat0_devel : 1;      /*!< [9..9] select pads EnDAT ch 0 development function (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_endat1 : 1;            /*!< [10..10] select pads EnDAT ch 1 (s. pinning table)                        */
      __IOM uint32_t sel_endat1_devel : 1;      /*!< [11..11] select pads EnDAT ch 1 development function (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_biss0  : 1;            /*!< [12..12] select pads BISS ch 0 (s. pinning table)                         */
      __IOM uint32_t sel_biss0_mo : 1;          /*!< [13..13] select pad BISS ch 0 MO (s. pinning table)                       */
      __IOM uint32_t sel_biss1  : 1;            /*!< [14..14] select pads BISS ch 1 (s. pinning table)                         */
      __IOM uint32_t sel_biss1_mo : 1;          /*!< [15..15] select pad BISS ch 1 MO (s. pinning table)                       */
    } io_config3_mask_b;
  } ;
  
  union {
    __IOM uint32_t io_config4;                  /*!< (@ 0x00000020) IO Config4 Register: Selects of output pin multiplexing.
                                                                    See Excel pinning sheet for details. Changes
                                                                    will only have effect if according bit in
                                                                    io_config4_mask-register is set. This register
                                                                    is protected by the netX access-key mechanism;
                                                                    changing this register is only possible
                                                                    by the following sequence: 1.: read out
                                                                    access-key from asic_ctrl_access_key register
                                                                    2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t sel_i2c_app : 1;           /*!< [0..0] select pads for i2c_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_uart_app : 1;          /*!< [1..1] select pads for uart_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_uart_app_rctsn : 1;    /*!< [2..2] select pads for uart_app RTS/CTS signals (s. pinning
                                                     table) and deactivate this function via MMIOs                             */
      __IOM uint32_t sel_uart_xpic_app : 1;     /*!< [3..3] select pads for uart_xpic_app (s. pinning table) and
                                                     deactivate this function via MMIOs                                        */
      __IOM uint32_t sel_uart_xpic_app_rctsn : 1;/*!< [4..4] select pads for uart_xpic_app RTS/CTS signals (s. pinning
                                                     table) and deactivate this function via MMIOs                             */
      __IOM uint32_t sel_spi0_app : 1;          /*!< [5..5] select pads for spi0_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_spi0_app_cs1 : 1;      /*!< [6..6] select pad for 2nd chip select of spi0_app (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_spi2_app : 1;          /*!< [7..7] select pads for spi2_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_spi2_app_cs1 : 1;      /*!< [8..8] select pad for 2nd chip select of spi2_app (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_spi2_app_cs2 : 1;      /*!< [9..9] select pad for 3rd chip select of spi2_app (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_can0_app : 1;          /*!< [10..10] select pad for can0_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_can1_app : 1;          /*!< [11..11] select pad for can1_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
    } io_config4_b;
  } ;
  
  union {
    __IOM uint32_t io_config4_mask;             /*!< (@ 0x00000024) IO Config4 Mask Register: This register might
                                                                    be used to lock special IO configurations
                                                                    for restricted netX devices. Any bit of
                                                                    the io_config4 register can only be set,
                                                                    if the corresponding mask bit in this register
                                                                    is set either. This register is lockable
                                                                    by asic_ctrl_com_netx_lock-lock_register.                  */
    
    struct {
      __IOM uint32_t sel_i2c_app : 1;           /*!< [0..0] select pads for i2c_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_uart_app : 1;          /*!< [1..1] select pads for uart_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_uart_app_rctsn : 1;    /*!< [2..2] select pads for uart_app RTS/CTS signals (s. pinning
                                                     table) and deactivate this function via MMIOs                             */
      __IOM uint32_t sel_uart_xpic_app : 1;     /*!< [3..3] select pads for uart_xpic_app (s. pinning table) and
                                                     deactivate this function via MMIOs                                        */
      __IOM uint32_t sel_uart_xpic_app_rctsn : 1;/*!< [4..4] select pads for uart_xpic_app RTS/CTS signals (s. pinning
                                                     table) and deactivate this function via MMIOs                             */
      __IOM uint32_t sel_spi0_app : 1;          /*!< [5..5] select pads for spi0_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_spi0_app_cs1 : 1;      /*!< [6..6] select pad for 2nd chip select of spi0_app (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_spi2_app : 1;          /*!< [7..7] select pads for spi2_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_spi2_app_cs1 : 1;      /*!< [8..8] select pad for 2nd chip select of spi2_app (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_spi2_app_cs2 : 1;      /*!< [9..9] select pad for 3rd chip select of spi2_app (s. pinning
                                                     table)                                                                    */
      __IOM uint32_t sel_can0_app : 1;          /*!< [10..10] select pad for can0_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
      __IOM uint32_t sel_can1_app : 1;          /*!< [11..11] select pad for can1_app (s. pinning table) and deactivate
                                                     this function via MMIOs                                                   */
    } io_config4_mask_b;
  } ;
  
  union {
    __IOM uint32_t io_config5;                  /*!< (@ 0x00000028) IO Config5 Register: Selects of output pin multiplexing.
                                                                    See Excel pinning sheet for details. Changes
                                                                    will only have effect if according bit in
                                                                    io_config5_mask-register is set. This register
                                                                    is protected by the netX access-key mechanism;
                                                                    changing this register is only possible
                                                                    by the following sequence: 1.: read out
                                                                    access-key from asic_ctrl_access_key register
                                                                    2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t sel_pio_app : 8;           /*!< [7..0] select pads for pio_app (s. pinning table)                         */
      __IOM uint32_t sel_mled4  : 1;            /*!< [8..8] select pad for mled4 (s. pinning table)                            */
      __IOM uint32_t sel_mled5  : 1;            /*!< [9..9] select pad for mled5 (s. pinning table)                            */
      __IOM uint32_t sel_mled6  : 1;            /*!< [10..10] select pad for mled6 (s. pinning table)                          */
      __IOM uint32_t sel_mled7  : 1;            /*!< [11..11] select pad for mled7 (s. pinning table)                          */
      __IOM uint32_t sel_mled8  : 1;            /*!< [12..12] select pad for mled8 (s. pinning table)                          */
      __IOM uint32_t sel_mled9  : 1;            /*!< [13..13] select pad for mled9 (s. pinning table)                          */
      __IOM uint32_t sel_mled10 : 1;            /*!< [14..14] select pad for mled10 (s. pinning table)                         */
      __IOM uint32_t sel_mled11 : 1;            /*!< [15..15] select pad for mled11 (s. pinning table)                         */
    } io_config5_b;
  } ;
  
  union {
    __IOM uint32_t io_config5_mask;             /*!< (@ 0x0000002C) IO Config5 Mask Register: This register might
                                                                    be used to lock special IO configurations
                                                                    for restricted netX devices. Any bit of
                                                                    the io_config5 register can only be set,
                                                                    if the corresponding mask bit in this register
                                                                    is set either. This register is lockable
                                                                    by asic_ctrl_com_netx_lock-lock_register.                  */
    
    struct {
      __IOM uint32_t sel_pio_app : 8;           /*!< [7..0] select pads for pio_app (s. pinning table)                         */
      __IOM uint32_t sel_mled4  : 1;            /*!< [8..8] select pad for mled4 (s. pinning table)                            */
      __IOM uint32_t sel_mled5  : 1;            /*!< [9..9] select pad for mled5 (s. pinning table)                            */
      __IOM uint32_t sel_mled6  : 1;            /*!< [10..10] select pad for mled6 (s. pinning table)                          */
      __IOM uint32_t sel_mled7  : 1;            /*!< [11..11] select pad for mled7 (s. pinning table)                          */
      __IOM uint32_t sel_mled8  : 1;            /*!< [12..12] select pad for mled8 (s. pinning table)                          */
      __IOM uint32_t sel_mled9  : 1;            /*!< [13..13] select pad for mled9 (s. pinning table)                          */
      __IOM uint32_t sel_mled10 : 1;            /*!< [14..14] select pad for mled10 (s. pinning table)                         */
      __IOM uint32_t sel_mled11 : 1;            /*!< [15..15] select pad for mled11 (s. pinning table)                         */
    } io_config5_mask_b;
  } ;
  
  union {
    __IOM uint32_t io_config6;                  /*!< (@ 0x00000030) IO Config6 Register: Selects of output pin multiplexing.
                                                                    See Excel pinning sheet for details. Changes
                                                                    will only have effect if according bit in
                                                                    io_config6_mask-register is set. This register
                                                                    is protected by the netX access-key mechanism;
                                                                    changing this register is only possible
                                                                    by the following sequence: 1.: read out
                                                                    access-key from asic_ctrl_access_key register
                                                                    2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t sel_io_link0 : 1;          /*!< [0..0] select pads for IO-Link0 (s. pinning table)                        */
      __IOM uint32_t sel_io_link0b : 1;         /*!< [1..1] select pads for IO-Link0 at position B (s. pinning table)          */
      __IOM uint32_t sel_io_link1 : 1;          /*!< [2..2] select pads for IO-Link1 (s. pinning table)                        */
      __IOM uint32_t sel_io_link1b : 1;         /*!< [3..3] select pads for IO-Link1 at position B (s. pinning table)          */
      __IOM uint32_t sel_io_link2 : 1;          /*!< [4..4] select pads for IO-Link2 (s. pinning table)                        */
      __IOM uint32_t sel_io_link3 : 1;          /*!< [5..5] select pads for IO-Link3 (s. pinning table)                        */
      __IOM uint32_t sel_io_link4 : 1;          /*!< [6..6] select pads for IO-Link4 (s. pinning table)                        */
      __IOM uint32_t sel_io_link5 : 1;          /*!< [7..7] select pads for IO-Link5 (s. pinning table)                        */
      __IOM uint32_t sel_io_link6 : 1;          /*!< [8..8] select pads for IO-Link6 (s. pinning table)                        */
      __IOM uint32_t sel_io_link7 : 1;          /*!< [9..9] select pads for IO-Link7 (s. pinning table)                        */
    } io_config6_b;
  } ;
  
  union {
    __IOM uint32_t io_config6_mask;             /*!< (@ 0x00000034) IO Config6 Mask Register: This register might
                                                                    be used to lock special IO configurations
                                                                    for restricted netX devices. Any bit of
                                                                    the io_config6 register can only be set,
                                                                    if the corresponding mask bit in this register
                                                                    is set either. This register is lockable
                                                                    by asic_ctrl_com_netx_lock-lock_register.                  */
    
    struct {
      __IOM uint32_t sel_io_link0 : 1;          /*!< [0..0] select pads for IO-Link0 (s. pinning table)                        */
      __IOM uint32_t sel_io_link0b : 1;         /*!< [1..1] select pads for IO-Link0 at position B (s. pinning table)          */
      __IOM uint32_t sel_io_link1 : 1;          /*!< [2..2] select pads for IO-Link1 (s. pinning table)                        */
      __IOM uint32_t sel_io_link1b : 1;         /*!< [3..3] select pads for IO-Link1 at position B (s. pinning table)          */
      __IOM uint32_t sel_io_link2 : 1;          /*!< [4..4] select pads for IO-Link2 (s. pinning table)                        */
      __IOM uint32_t sel_io_link3 : 1;          /*!< [5..5] select pads for IO-Link3 (s. pinning table)                        */
      __IOM uint32_t sel_io_link4 : 1;          /*!< [6..6] select pads for IO-Link4 (s. pinning table)                        */
      __IOM uint32_t sel_io_link5 : 1;          /*!< [7..7] select pads for IO-Link5 (s. pinning table)                        */
      __IOM uint32_t sel_io_link6 : 1;          /*!< [8..8] select pads for IO-Link6 (s. pinning table)                        */
      __IOM uint32_t sel_io_link7 : 1;          /*!< [9..9] select pads for IO-Link7 (s. pinning table)                        */
    } io_config6_mask_b;
  } ;
  
  union {
    __IOM uint32_t io_config7;                  /*!< (@ 0x00000038) IO Config7 Register: Selects of output pin multiplexing.
                                                                    See Excel pinning sheet for details. Changes
                                                                    will only have effect if according bit in
                                                                    io_config7_mask-register is set. This register
                                                                    is protected by the netX access-key mechanism;
                                                                    changing this register is only possible
                                                                    by the following sequence: 1.: read out
                                                                    access-key from asic_ctrl_access_key register
                                                                    2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t sel_eth_cfg : 5;           /*!< [4..0] select connection of ETH MII pins: 0: no select 1: select
                                                     pads for ETH RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)
                                                     (s. pinning table: sel_eth_5,2,1 will be active) 2: select
                                                     pads for ETH RX only mode (rxclk, rxd[3:0],rxdv,rxer) (s.
                                                     pinning table: sel_eth_5,3,2,0 will be active) 3: select
                                                     pads for ETH minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen)
                                                     (s. pinning table: sel_eth_4:1 will be active) 4: select
                                                     also pads for ETH rxclk pin for mac mode (rxclk) (s. pinning
                                                     table: sel_eth_4:0 will be ac                                             */
      __IOM uint32_t sel_eth_mdio : 2;          /*!< [6..5] select connection for MIIMU MDIO interface used by ETH
                                                     00: connect to multiplexmatrix 01: connect to external
                                                     eth_mdio position A (s pinning table sel_eth_a_mdio) 10:
                                                     connect to external MII_MDIO/MDC pins (s pinning table)
                                                     11: connect to internal PHY                                               */
      __IOM uint32_t sel_sqi_cs1 : 1;           /*!< [7..7] select pad for 2nd chip select of sqi (s. pinning table)           */
      __IOM uint32_t sel_sqi_cs2 : 1;           /*!< [8..8] select pad for 3rd chip select of sqi (s. pinning table)           */
    } io_config7_b;
  } ;
  
  union {
    __IOM uint32_t io_config7_mask;             /*!< (@ 0x0000003C) IO Config7 Mask Register: This register might
                                                                    be used to lock special IO configurations
                                                                    for restricted netX devices. Any bit of
                                                                    the io_config7 register can only be set,
                                                                    if the corresponding mask bit in this register
                                                                    is set either. This register is lockable
                                                                    by asic_ctrl_com_netx_lock-lock_register.                  */
    
    struct {
      __IOM uint32_t sel_eth_cfg : 5;           /*!< [4..0] select connection of ETH MII pins:                                 */
      __IOM uint32_t sel_eth_mdio : 2;          /*!< [6..5] select connection for MIIMU MDIO interface used by ETH             */
      __IOM uint32_t sel_sqi_cs1 : 1;           /*!< [7..7] select pad for 2nd chip select of sqi (s. pinning table)           */
      __IOM uint32_t sel_sqi_cs2 : 1;           /*!< [8..8] select pad for 3rd chip select of sqi (s. pinning table)           */
    } io_config7_mask_b;
  } ;
  
  union {
    __IOM uint32_t io_config8;                  /*!< (@ 0x00000040) IO Config8 Register: Selects of output pin multiplexing.
                                                                    See Excel pinning sheet for details. Changes
                                                                    will only have effect if according bit in
                                                                    io_config8_mask-register is set. This register
                                                                    is protected by the netX access-key mechanism;
                                                                    changing this register is only possible
                                                                    by the following sequence: 1.: read out
                                                                    access-key from asic_ctrl_access_key register
                                                                    2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t sel_arm_trace_cfg : 2;     /*!< [1..0] select pins for CoreSight Tracing 00: Disable Trace:
                                                     sel_trace = 0, sel_trace_d[3:0] = 0000 01: Trace with 1
                                                     data line: sel_trace = 1, sel_trace_d[3:0] = 0001 10: Trace
                                                     with 2 data lines: sel_trace = 1, sel_trace_d[3:0] = 0011
                                                     11: Trace with 4 data lines: sel_trace = 1, sel_trace_d[3:0]
                                                     = 1111                                                                    */
    } io_config8_b;
  } ;
  
  union {
    __IOM uint32_t io_config8_mask;             /*!< (@ 0x00000044) IO Config8 Mask Register: This register might
                                                                    be used to lock special IO configurations
                                                                    for restricted netX devices. Any bit of
                                                                    the io_config8 register can only be set,
                                                                    if the corresponding mask bit in this register
                                                                    is set either. This register is lockable
                                                                    by asic_ctrl_com_netx_lock-lock_register.                  */
    
    struct {
      __IOM uint32_t sel_arm_trace_cfg : 2;     /*!< [1..0] select pins for CoreSight Tracing                                  */
    } io_config8_mask_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t clock_enable0;               /*!< (@ 0x00000050) Global Clock Enable Register: Use this registers
                                                                    to disable modules completely for power
                                                                    saving purposes. Changes will only have
                                                                    effect if according bit in clock_enable_mask-register
                                                                    is set. Note: For low power consumption
                                                                    at power on, all switchable clocks are disabled
                                                                    after reset and must be enabled before module
                                                                    usage. This register is protected by the
                                                                    netX access-key mechanism; changing this
                                                                    register is only possible by the following
                                                                    sequence: 1.: read out access-key from asic_ctrl_acce      */
    
    struct {
      __IOM uint32_t rpec0      : 1;            /*!< [0..0] enables clock for rPEC0                                            */
      __IOM uint32_t rpec1      : 1;            /*!< [1..1] enables clock for rPEC1                                            */
      __IOM uint32_t tpec0      : 1;            /*!< [2..2] enables clock for tPEC0                                            */
      __IOM uint32_t tpec1      : 1;            /*!< [3..3] enables clock for tPEC1                                            */
      __IOM uint32_t xmac0      : 1;            /*!< [4..4] enables clock for xMAC0                                            */
      __IOM uint32_t xmac1      : 1;            /*!< [5..5] enables clock for xMAC1                                            */
      __IOM uint32_t fb0        : 1;            /*!< [6..6] enables clock for fieldbus0 1: use internally generated
                                                     fb0clk to resample xMAC0 outputs 0: use external xm0_eclk
                                                     to resample xMAC outputs                                                  */
      __IOM uint32_t fb1        : 1;            /*!< [7..7] enables clock for fieldbus1 1: use internally generated
                                                     fb1clk to resample xMAC1 outputs 0: use external xm1_eclk
                                                     to resample xMAC outputs                                                  */
      __IOM uint32_t xc_misc    : 1;            /*!< [8..8] enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN        */
      __IOM uint32_t xpic0      : 1;            /*!< [9..9] enables clock for XPIC0                                            */
      __IOM uint32_t dma_com    : 1;            /*!< [10..10] enables clock for COM DMA-Ctrl                                   */
      __IOM uint32_t arm_app    : 1;            /*!< [11..11] enables clock for ARM-APP                                        */
      __IOM uint32_t debug      : 1;            /*!< [12..12] enables clock for Coresight Debugging                            */
      __IOM uint32_t dpm        : 1;            /*!< [13..13] enables clock for DPM                                            */
    } clock_enable0_b;
  } ;
  
  union {
    __IOM uint32_t clock_enable0_mask;          /*!< (@ 0x00000054) Global Clock Enable Mask Register: This register
                                                                    might be used to lock clock_enable0 register.
                                                                    Any bit of the clock_enable0 register can
                                                                    only be set, if the corresponding mask bit
                                                                    in this register is set either. This register
                                                                    is lockable by asic_ctrl_com_netx_lock-lock_register.      */
    
    struct {
      __IOM uint32_t rpec0      : 1;            /*!< [0..0] enables clock for rPEC0                                            */
      __IOM uint32_t rpec1      : 1;            /*!< [1..1] enables clock for rPEC1                                            */
      __IOM uint32_t tpec0      : 1;            /*!< [2..2] enables clock for tPEC0                                            */
      __IOM uint32_t tpec1      : 1;            /*!< [3..3] enables clock for tPEC1                                            */
      __IOM uint32_t xmac0      : 1;            /*!< [4..4] enables clock for xMAC0                                            */
      __IOM uint32_t xmac1      : 1;            /*!< [5..5] enables clock for xMAC1                                            */
      __IOM uint32_t fb0        : 1;            /*!< [6..6] enables clock for fieldbus0                                        */
      __IOM uint32_t fb1        : 1;            /*!< [7..7] enables clock for fieldbus1                                        */
      __IOM uint32_t xc_misc    : 1;            /*!< [8..8] enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN        */
      __IOM uint32_t xpic0      : 1;            /*!< [9..9] enables clock for XPIC0                                            */
      __IOM uint32_t dma_com    : 1;            /*!< [10..10] enables clock for COM DMA-Ctrl                                   */
      __IOM uint32_t arm_app    : 1;            /*!< [11..11] enables clock for ARM-APP                                        */
      __IOM uint32_t debug      : 1;            /*!< [12..12] enables clock for Coresight Debugging                            */
      __IOM uint32_t dpm        : 1;            /*!< [13..13] enables clock for DPM                                            */
    } clock_enable0_mask_b;
  } ;
  
  union {
    __IOM uint32_t clock_enable1;               /*!< (@ 0x00000058) Global Clock Enable Register: Use this registers
                                                                    to disable modules completely for power
                                                                    saving purposes. Changes will only have
                                                                    effect if according bit in clock_enable_mask-register
                                                                    is set. Note: For low power consumption
                                                                    at power on, all switchable clocks are disabled
                                                                    after reset and must be enabled before module
                                                                    usage. This register is protected by the
                                                                    netX access-key mechanism; changing this
                                                                    register is only possible by the following
                                                                    sequence: 1.: read out access-key from asic_ctrl_acce      */
    
    struct {
      __IOM uint32_t xpic1      : 1;            /*!< [0..0] enables clock for XPIC1                                            */
      __IOM uint32_t dma_app    : 1;            /*!< [1..1] enables clock for APP DMA-Ctrl                                     */
      __IOM uint32_t crypt      : 1;            /*!< [2..2] enables clock for CRYPT Unit                                       */
    } clock_enable1_b;
  } ;
  
  union {
    __IOM uint32_t clock_enable1_mask;          /*!< (@ 0x0000005C) Global Clock Enable Mask Register: This register
                                                                    might be used to lock clock_enable1 register.
                                                                    Any bit of the clock_enable1 register can
                                                                    only be set, if the corresponding mask bit
                                                                    in this register is set either. This register
                                                                    is lockable by asic_ctrl_com_netx_lock-lock_register.      */
    
    struct {
      __IOM uint32_t xpic1      : 1;            /*!< [0..0] enables clock for XPIC1                                            */
      __IOM uint32_t dma_app    : 1;            /*!< [1..1] enables clock for APP DMA-Ctrl                                     */
      __IOM uint32_t crypt      : 1;            /*!< [2..2] enables clock for CRYPT Unit                                       */
    } clock_enable1_mask_b;
  } ;
  
  union {
    __IOM uint32_t reset_ctrl;                  /*!< (@ 0x00000060) Reset Control Register: This register controls
                                                                    the reset functions of the netX chip and
                                                                    indicates the reset state. The reset state
                                                                    shows which resets have occurred, allowing
                                                                    the firmware to detect which resets were
                                                                    active. In order to determine the source
                                                                    of the last reset, the firmware should evaluate
                                                                    and reset these bits during its start sequence.
                                                                    After a power on reset, the RESET_CTRL register
                                                                    is cleared completely. This register is
                                                                    protected by the netX access-key mechanism;
                                                                    changing th                                                */
    
    struct {
      __IOM uint32_t RES_IN     : 1;            /*!< [0..0] Reset status: A reset was performed by the external pin
                                                     (RST_IN_N). After reading write back a '1' to clear the
                                                     status bit.                                                               */
      __IOM uint32_t RES_WDOG   : 1;            /*!< [1..1] Reset status: A reset was performed by the system watchdog.
                                                     After reading write back a '1' to clear the status bit.                   */
      __IOM uint32_t RES_HOST   : 1;            /*!< [2..2] Reset status: A software reset was performed by an external
                                                     host by the DPM interface. After reading write back a '1'
                                                     to clear the status bit.                                                  */
      __IOM uint32_t RES_FIRMWARE : 1;          /*!< [3..3] Reset status: A software reset was performed by the RES_REQ_FIRMWARE
                                                     bit of this register. After reading write back a '1' to
                                                     clear the status bit.                                                     */
      __IOM uint32_t RES_ARM_COM : 1;           /*!< [4..4] Reset status: A reset was performed by the SYSRESETREQ
                                                     of the Com ARM. After reading write back a '1' to clear
                                                     the status bit.                                                           */
      __IOM uint32_t RES_ARM_APP : 1;           /*!< [5..5] Reset status: A reset was performed by the SYSRESETREQ
                                                     of the App ARM. After reading write back a '1' to clear
                                                     the status bit.                                                           */
      __IOM uint32_t reserved0  : 14;           /*!< [19..6] reserved                                                          */
      __IOM uint32_t FIRMWARE_STATUS0 : 1;      /*!< [20..20] Readable and writable bit to save the firmware status;
                                                     only a power-on-reset will clear this bit.                                */
      __IOM uint32_t FIRMWARE_STATUS1 : 1;      /*!< [21..21] Readable and writable bit to save the firmware status;
                                                     only a power-on-reset will clear this bit.                                */
      __IOM uint32_t FIRMWARE_STATUS2 : 1;      /*!< [22..22] Readable and writable bit to save the firmware status;
                                                     only a power-on-reset will clear this bit.                                */
      __IOM uint32_t FIRMWARE_STATUS3 : 1;      /*!< [23..23] Readable and writable bit to save the firmware status;
                                                     only a power-on-reset will clear this bit.                                */
      __IOM uint32_t RES_REQ_FIRMWARE : 1;      /*!< [24..24] Software reset: Writing a '1' will reset the whole
                                                     system - except logic and register bits which are only
                                                     reset on power-on-reset. This bit is reset to 0 by hardware
                                                     during the reset procedure.                                               */
      __IOM uint32_t RES_REQ_OUT : 1;           /*!< [25..25] Software reset for external devices: This bit controls
                                                     the level of the RST_OUT_N output for normal operation.
                                                     For all resets this bit is cleared, however driving of
                                                     RST_OUT_N is also disabled (view EN_RES_REQ_OUT bit).                     */
      __IOM uint32_t EN_RES_REQ_OUT : 1;        /*!< [26..26] This bit enables the driving of the programmable reset
                                                     output RST_OUT_N. When this bit is not set RST_OUT_N will
                                                     be in high impedance state. For all resets this bit is
                                                     cleared. The external level of the RST_OUT_N output during
                                                     the reset must be realized by an external pull up or down
                                                     resistor (when RST_OUT_N function is desired).                            */
      __IOM uint32_t rst_out_n_in_ro : 1;       /*!< [27..27] Status of reset pin (RST_OUT_N). This bit is a read
                                                     only status and indicates the reset state.                                */
      __IOM uint32_t reserved1  : 4;            /*!< [31..28] reserved                                                         */
    } reset_ctrl_b;
  } ;
  
  union {
    __IM  uint32_t ahbl_master_ready;           /*!< (@ 0x00000064) All AHBL master ready signals. Before stop, reset
                                                                    or clockdisable of any master, check that
                                                                    this bit of the appropriate master is 1.
                                                                    If it is 0, a current access of this master
                                                                    to the system is not finished.                             */
    
    struct {
      __IM  uint32_t val        : 19;           /*!< [18..0] netx ahbl_master readys (0-18) M_DPM0 0 M_DPM1 1 M_XC01_d
                                                     2 M_XC01_s 3 M_IPC_MASTER 4 M_IDPM_MASTER 5 M_DEBUG_MASTER
                                                     6 M_XPIC_COM_d 7 M_XPIC_COM_i 8 M_XPIC_APP_d 9 M_XPIC_APP_i
                                                     10 M_ARM_COM_d 11 M_ARM_COM_i 12 M_ARM_COM_s 13 M_ARM_APP_d
                                                     14 M_ARM_APP_i 15 M_ARM_APP_s 16 M_DMAC_COM 17 M_DMAC_APP
                                                     18                                                                        */
    } ahbl_master_ready_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IM  uint32_t system_status;               /*!< (@ 0x00000074) netX System Status Register. This register provides
                                                                    information of special netX system events,
                                                                    e.g: System related interrupt activity,
                                                                    Abort activity. Abort or IRQ status flag
                                                                    can be cleared by writing a '1' to the appropriate
                                                                    bits.                                                      */
    
    struct {
      __IM  uint32_t lic_err_irq_status : 1;    /*!< [0..0] Current status of netX licence error IRQ. Note: This
                                                     IRQ (bit) can only be cleared by running a valid netx licence
                                                     check sequence. Note: Generation of this IRQ is controlled
                                                     by misc_asic_ctrl register. Note: This IRQ is not maskable.               */
      __IM  uint32_t extbus_to_irq_status : 1;  /*!< [1..1] Current status of HIF-Extension Bus Ready Timeout IRQ.
                                                     Note: This IRQ is controlled/cleared by ext_rdy_cfg register
                                                     (area hif_asyncmem_ctrl).                                                 */
      __IM  uint32_t reserved0  : 6;            /*!< [7..2] reserved                                                           */
      __IM  uint32_t testmode   : 1;            /*!< [8..8] sampled netx TESTMODE input for production test purpose            */
      __IM  uint32_t pw_bod_ok  : 1;            /*!< [9..9] Power watch brown-out detection status                             */
      __IM  uint32_t pll_bypass : 1;            /*!< [10..10] Testmode 'pll_bypass' is activated by BSCAN JTAG TAP
                                                     controller -&gt; 400MHz-PLL is bypassed, PLL output is
                                                     unused, 400MHz-Clocks (clk400, clk400_2sdram) is directly
                                                     connected to XTALIN                                                       */
      __IM  uint32_t quick_count : 1;           /*!< [11..11] Testmode 'quick_count' is activated by BSCAN JTAG TAP
                                                     controller -&gt; diverse internal counters count faster
                                                     (RTC-clock-divider, PLL-stby-controller,...)                              */
      __IM  uint32_t reserved1  : 4;            /*!< [15..12] reserved                                                         */
      __IM  uint32_t lic_err_abort_status : 1;  /*!< [16..16] Current status of netX licence abort. Note: This bit
                                                     must be cleared by writing a '1'. It is not cleared automatically
                                                     if ARM Abort mode is left. Note: Generation of this Abort
                                                     is controlled by misc_asic_ctrl register.                                 */
      __IM  uint32_t reserved2  : 15;           /*!< [31..17] reserved                                                         */
    } system_status_b;
  } ;
  
  union {
    __IOM uint32_t systime_feth_ctrl;           /*!< (@ 0x00000078) Select systime for FETH                                    */
    
    struct {
      __IOM uint32_t feth       : 2;            /*!< [1..0] Systime for FETH 00: systime_com 01: systime_com_uc 10:
                                                     systime_app                                                               */
    } systime_feth_ctrl_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t systime_gpio_app_ctrl;       /*!< (@ 0x00000080) Select systime for GPIO_APP                                */
    
    struct {
      __IOM uint32_t gpio_app   : 2;            /*!< [1..0] Systime for GPIO_APP 00: systime_com 01: systime_com_uc
                                                     10: systime_app                                                           */
    } systime_gpio_app_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t only_porn;                   /*!< (@ 0x00000084) Firmware Status register: This register is not
                                                                    Reset by SW resets, only PORn will reset
                                                                    this register. This register is protected
                                                                    by the netX access-key mechanism; changing
                                                                    this register is only possible by the following
                                                                    sequence: 1.: read out access-key from ACCESS_KEY
                                                                    register 2.: write back access-key to ACCESS_KEY
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t only_porn  : 32;           /*!< [31..0] netX Firmware status                                              */
    } only_porn_b;
  } ;
  
  union {
    __IOM uint32_t only_porn_rom;               /*!< (@ 0x00000088) Firmware Status register for handling boot/rom-code
                                                                    issues: This register is not Reset by SW
                                                                    resets, only PORn will reset this register.
                                                                    This register is protected by the netX access-key
                                                                    mechanism; changing this register is only
                                                                    possible by the following sequence: 1.:
                                                                    read out access-key from ACCESS_KEY register
                                                                    2.: write back access-key to ACCESS_KEY
                                                                    register 3.: write desired value to this
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] netX Firmware status                                              */
    } only_porn_rom_b;
  } ;
  
  union {
    __IOM uint32_t netx_version;                /*!< (@ 0x0000008C) netX Revision Register: This register contains
                                                                    information about netX hardware and bootloader
                                                                    revision. This register is lockable by asic_ctrl_com_netx_
                                                                    ock-lock_register.                                         */
    
    struct {
      __IOM uint32_t netx_version : 32;         /*!< [31..0] netX revision number: Hardware reset values of netX
                                                     version register is: 0x01: netx100, netx500 0x01: netx50
                                                     0x02: netx5_mpw 0x41: netx5 0x50: netx10 0x05: netx51/52
                                                     0x06: reserved 0x07: netx6 0x08: netx4000_relaxed 0x09:
                                                     reserved 0x0a: netx4000 0x0b: reserved 0x0c: netx90_mpw
                                                     0x0d: netx90 Further netX revisions should increment (next:
                                                     0x0e). This register is changed to Hilscher netX bootloader
                                                     revision by ROM-code: Hardware reset values should differ
                                                     from Hilscher values! netX50 revision number starts wit                   */
    } netx_version_b;
  } ;
  
  union {
    __IOM uint32_t netx_status;                 /*!< (@ 0x00000090) netX Legacy System Status Configuration Register.
                                                                    This Register was implemented in Hilscher
                                                                    HIF module originally. From Hilscher Program
                                                                    Reference Guide: The general status of a
                                                                    netX based system is usually indicated by
                                                                    the System LED, which can either consist
                                                                    of a dual LED or two single LEDs. Access
                                                                    to this register is not protected by any
                                                                    locking or access protection algorithm.
                                                                    IMPORTANT: netX50/100/500 Change Note: The
                                                                    netX50/100/500 SYS_STA register was byte
                                                                    accessible. This changed: T                                */
    
    struct {
      __IOM uint32_t RDY        : 1;            /*!< [0..0] Signal level of the RDY LED output. Note: This bit is
                                                     read-only-mirrored to DPM/Host Status register dpm_sys_sta
                                                     (DPM_HOST_SYS_STAT) (Area DPM). Changing this bit can produce
                                                     a IRQ to host CPU.                                                        */
      __IOM uint32_t RUN        : 1;            /*!< [1..1] Signal Level of the RUN LED output. Note: This bit is
                                                     read-only-mirrored to DPM/Host Status register dpm_sys_sta
                                                     (DPM_HOST_SYS_STAT) (Area DPM). Changing this bit can produce
                                                     a IRQ to host CPU.                                                        */
      __IOM uint32_t NETX_STATE : 2;            /*!< [3..2] User defined status bits. Note: These bits are read-only-mirrored
                                                     to DPM/Host Status register dpm_sys_sta (DPM_HOST_SYS_STAT)
                                                     (Area DPM). Changing these bits can produce a IRQ to host
                                                     CPU.                                                                      */
      __IOM uint32_t HOST_STATE_ro : 4;         /*!< [7..4] Host Status Code. User defined status is read only here.
                                                     These bits can be programmed by DPM/Host Status register
                                                     dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM).                               */
      __IOM uint32_t NETX_STA_CODE : 8;         /*!< [15..8] netX Status Code. The netX status codes are software
                                                     defined. The predefined code values are: F0h: Status after
                                                     power on reset. Note: These bits are read-only-mirrored
                                                     to DPM/Host Status register dpm_sys_sta (DPM_HOST_SYS_STAT)
                                                     (Area DPM). Changing these bits can produce a IRQ to host
                                                     CPU.                                                                      */
      __IOM uint32_t RDY_IN     : 1;            /*!< [16..16] Physical input signal level at RDY pin (read-only).              */
      __IOM uint32_t RUN_IN     : 1;            /*!< [17..17] Physical input signal level at RUN pin (read-only).              */
      __IOM uint32_t RDY_POL    : 1;            /*!< [18..18] Output polarity RDY LED; outsig = RDY exor RDY_POL.              */
      __IOM uint32_t RUN_POL    : 1;            /*!< [19..19] Output polarity RUN LED; outsig = RUN exor RUN_POL.              */
      __IOM uint32_t reserved0  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t RDY_DRV    : 1;            /*!< [24..24] Driver enable for RDY LED. Enables output driver when
                                                     set.                                                                      */
      __IOM uint32_t RUN_DRV    : 1;            /*!< [25..25] Driver enable for RUN LED. Enables output driver when
                                                     set.                                                                      */
      __IOM uint32_t reserved1  : 6;            /*!< [31..26] reserved                                                         */
    } netx_status_b;
  } ;
  
  union {
    __IOM uint32_t rdy_run_cfg;                 /*!< (@ 0x00000094) netX Legacy RDY/RUN IO System Status Configuration
                                                                    Register. RDY/RUN signal programming was
                                                                    implemented in Hilscher HIF module originally.
                                                                    From Hilscher Program Reference Guide: The
                                                                    general status of a netX based system is
                                                                    usually indicated by the System LED, which
                                                                    can either consist of a dual LED or two
                                                                    single LEDs. Access to this register is
                                                                    not protected by any locking or access protection
                                                                    algorithm. Note: Use this register to change
                                                                    the upper 16 bits of sys_sta (SYS_STA) register
                                                                    witou                                                      */
    
    struct {
      __IOM uint32_t RDY        : 1;            /*!< [0..0] Signal level of the RDY LED output.                                */
      __IOM uint32_t RUN        : 1;            /*!< [1..1] Signal Level of the RUN LED output.                                */
      __IOM uint32_t reserved0  : 14;           /*!< [15..2] reserved                                                          */
      __IOM uint32_t RDY_IN     : 1;            /*!< [16..16] Physical input signal level at RDY pin (read-only).              */
      __IOM uint32_t RUN_IN     : 1;            /*!< [17..17] Physical input signal level at RUN pin (read-only).              */
      __IOM uint32_t RDY_POL    : 1;            /*!< [18..18] Output polarity RDY LED; outsig = RDY exor RDY_POL.              */
      __IOM uint32_t RUN_POL    : 1;            /*!< [19..19] Output polarity RUN LED; outsig = RUN exor RUN_POL.              */
      __IOM uint32_t reserved1  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t RDY_DRV    : 1;            /*!< [24..24] Driver enable for RDY LED. Enables output driver when
                                                     set.                                                                      */
      __IOM uint32_t RUN_DRV    : 1;            /*!< [25..25] Driver enable for RUN LED. Enables output driver when
                                                     set.                                                                      */
      __IOM uint32_t reserved2  : 6;            /*!< [31..26] reserved                                                         */
    } rdy_run_cfg_b;
  } ;
  
  union {
    __IOM uint32_t firewall_cfg_hifmem_sdram;   /*!< (@ 0x00000098) Firewall configuration register for the HIFMEM_SDRAM
                                                                    NETX AHB channel. IMPORTANT: Changing permissions
                                                                    must not be done while any master accesses
                                                                    the slave protected by this register. If
                                                                    permissions are changed during an access
                                                                    a whole system lockup could occur. Note:
                                                                    APP-side masters are: DPM0, DPM1, XC01,
                                                                    XPIC_COM, ARM_COM, DMAC_COM. COM-side masters
                                                                    are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP.
                                                                    Other masters which cannot be filtered but
                                                                    globally disabled are: IPC_MASTER, DEBUG_MASTER.
                                                                                                                               */
    
    struct {
      __IOM uint32_t wp_com     : 1;            /*!< [0..0] write permission for COM side masters. 1: permit write
                                                     access. 0: deny write access.                                             */
      __IOM uint32_t wp_app     : 1;            /*!< [1..1] write permission for APP side masters                              */
      __IOM uint32_t reserved0  : 2;            /*!< [3..2] reserved                                                           */
      __IOM uint32_t rp_com     : 1;            /*!< [4..4] read permission for COM side masters. 1: permit read
                                                     access. 0: deny read access.                                              */
      __IOM uint32_t rp_app     : 1;            /*!< [5..5] read permission for APP side masters.                              */
      __IOM uint32_t reserved1  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t abort_en_com : 1;          /*!< [8..8] TBD: abort enable for COM side masters for denied accesss
                                                     1: ERROR response to COM side masters on denied access
                                                     0: no ERROR response to COM side masters. Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_COM, DMAC_COM                                                         */
      __IOM uint32_t abort_en_app : 1;          /*!< [9..9] TBD: abort enable for APP side masters Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_APP, DMAC_APP                                                         */
      __IOM uint32_t reserved2  : 22;           /*!< [31..10] reserved                                                         */
    } firewall_cfg_hifmem_sdram_b;
  } ;
  
  union {
    __IOM uint32_t firewall_cfg_hifmem_amem;    /*!< (@ 0x0000009C) Firewall configuration register for the HIFMEM_AMEM
                                                                    NETX AHB channel. IMPORTANT: Changing permissions
                                                                    must not be done while any master accesses
                                                                    the slave protected by this register. If
                                                                    permissions are changed during an access
                                                                    a whole system lockup could occur. Note:
                                                                    APP-side masters are: DPM0, DPM1, XC01,
                                                                    XPIC_COM, ARM_COM, DMAC_COM. COM-side masters
                                                                    are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP.
                                                                    Other masters which cannot be filtered but
                                                                    globally disabled are: IPC_MASTER, DEBUG_MASTER.
                                                                    N                                                          */
    
    struct {
      __IOM uint32_t wp_com     : 1;            /*!< [0..0] write permission for COM side masters. 1: permit write
                                                     access. 0: deny write access.                                             */
      __IOM uint32_t wp_app     : 1;            /*!< [1..1] write permission for APP side masters                              */
      __IOM uint32_t reserved0  : 2;            /*!< [3..2] reserved                                                           */
      __IOM uint32_t rp_com     : 1;            /*!< [4..4] read permission for COM side masters. 1: permit read
                                                     access. 0: deny read access.                                              */
      __IOM uint32_t rp_app     : 1;            /*!< [5..5] read permission for APP side masters.                              */
      __IOM uint32_t reserved1  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t abort_en_com : 1;          /*!< [8..8] TBD: abort enable for COM side masters for denied accesss
                                                     1: ERROR response to COM side masters on denied access
                                                     0: no ERROR response to COM side masters. Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_COM, DMAC_COM                                                         */
      __IOM uint32_t abort_en_app : 1;          /*!< [9..9] TBD: abort enable for APP side masters Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_APP, DMAC_APP                                                         */
      __IOM uint32_t reserved2  : 22;           /*!< [31..10] reserved                                                         */
    } firewall_cfg_hifmem_amem_b;
  } ;
  
  union {
    __IOM uint32_t firewall_cfg_sqirom;         /*!< (@ 0x000000A0) Firewall configuration register for the SQIROM
                                                                    NETX AHB channel. IMPORTANT: Changing permissions
                                                                    must not be done while any master accesses
                                                                    the slave protected by this register. If
                                                                    permissions are changed during an access
                                                                    a whole system lockup could occur. Note:
                                                                    APP-side masters are: DPM0, DPM1, XC01,
                                                                    XPIC_COM, ARM_COM, DMAC_COM. COM-side masters
                                                                    are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP.
                                                                    Other masters which cannot be filtered but
                                                                    globally disabled are: IPC_MASTER, DEBUG_MASTER.
                                                                    Note:                                                      */
    
    struct {
      __IOM uint32_t wp_com     : 1;            /*!< [0..0] write permission for COM side masters. 1: permit write
                                                     access. 0: deny write access.                                             */
      __IOM uint32_t wp_app     : 1;            /*!< [1..1] write permission for APP side masters                              */
      __IOM uint32_t reserved0  : 2;            /*!< [3..2] reserved                                                           */
      __IOM uint32_t rp_com     : 1;            /*!< [4..4] read permission for COM side masters. 1: permit read
                                                     access. 0: deny read access.                                              */
      __IOM uint32_t rp_app     : 1;            /*!< [5..5] read permission for APP side masters.                              */
      __IOM uint32_t reserved1  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t abort_en_com : 1;          /*!< [8..8] TBD: abort enable for COM side masters for denied accesss
                                                     1: ERROR response to COM side masters on denied access
                                                     0: no ERROR response to COM side masters. Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_COM, DMAC_COM                                                         */
      __IOM uint32_t abort_en_app : 1;          /*!< [9..9] TBD: abort enable for APP side masters Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_APP, DMAC_APP                                                         */
      __IOM uint32_t reserved2  : 22;           /*!< [31..10] reserved                                                         */
    } firewall_cfg_sqirom_b;
  } ;
  
  union {
    __IOM uint32_t firewall_cfg_crypt;          /*!< (@ 0x000000A4) Firewall configuration register for the CRYPT
                                                                    NETX AHB channel. IMPORTANT: Changing permissions
                                                                    must not be done while any master accesses
                                                                    the slave protected by this register. If
                                                                    permissions are changed during an access
                                                                    a whole system lockup could occur. Note:
                                                                    APP-side masters are: DPM0, DPM1, XC01,
                                                                    XPIC_COM, ARM_COM, DMAC_COM. COM-side masters
                                                                    are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP.
                                                                    Other masters which cannot be filtered but
                                                                    globally disabled are: IPC_MASTER, DEBUG_MASTER.
                                                                    Note: A                                                    */
    
    struct {
      __IOM uint32_t wp_com     : 1;            /*!< [0..0] write permission for COM side masters. 1: permit write
                                                     access. 0: deny write access.                                             */
      __IOM uint32_t wp_app     : 1;            /*!< [1..1] write permission for APP side masters                              */
      __IOM uint32_t reserved0  : 2;            /*!< [3..2] reserved                                                           */
      __IOM uint32_t rp_com     : 1;            /*!< [4..4] read permission for COM side masters. 1: permit read
                                                     access. 0: deny read access.                                              */
      __IOM uint32_t rp_app     : 1;            /*!< [5..5] read permission for APP side masters.                              */
      __IOM uint32_t reserved1  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t abort_en_com : 1;          /*!< [8..8] TBD: abort enable for COM side masters for denied accesss
                                                     1: ERROR response to COM side masters on denied access
                                                     0: no ERROR response to COM side masters. Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_COM, DMAC_COM                                                         */
      __IOM uint32_t abort_en_app : 1;          /*!< [9..9] TBD: abort enable for APP side masters Note: Only the
                                                     following COM-side masters support ERROR-response handling:
                                                     ARM_APP, DMAC_APP                                                         */
      __IOM uint32_t reserved2  : 22;           /*!< [31..10] reserved                                                         */
    } firewall_cfg_crypt_b;
  } ;
  
  union {
    __IOM uint32_t misc_asic_ctrl;              /*!< (@ 0x000000A8) TBD: anpassen/ausbauen Miscellaneous ASIC Control
                                                                    Register: This register is lockable by asic_ctrl_com_netx_
                                                                    ock-lock_register.                                         */
    
    struct {
      __IOM uint32_t lic_err_taint_en : 1;      /*!< [0..0] In case of a detected license error, system clock will
                                                     be reduced to 80MHz Tainted mode can be left when this
                                                     bit is disabled or at unprotected phase after power-on-reset
                                                     by a valid LICCHECK sequence.                                             */
      __IOM uint32_t lic_err_abort_en : 1;      /*!< [1..1] In case of a detected license error, ARM-Abort will be
                                                     generated on the next data write (no data loss caused)                    */
      __IOM uint32_t lic_err_irq_en : 1;        /*!< [2..2] In case of a detected license error, ARM-IRQ will be
                                                     generated                                                                 */
      __IOM uint32_t lic_err_delay_en : 1;      /*!< [3..3] Random Delay between a detected license error and abort-generation/chan
                                                     e to tainted mode                                                         */
    } misc_asic_ctrl_b;
  } ;
  __IM  uint32_t  RESERVED3[5];
  
  union {
    __IOM uint32_t asic_ctrl_access_key;        /*!< (@ 0x000000C0) ASIC Control Locking access-key Register: Writing
                                                                    to any register in the asic_ctrl or mmio_ctrl
                                                                    address area is only possible after setting
                                                                    the correct key here to avoid unmeant changes
                                                                    e.g. by crashed software. ---- Changing
                                                                    a control register in the asic_ctrl or mmio_ctrl
                                                                    address area is only possible by the following
                                                                    sequence: 1.: Read out the Locking access-key
                                                                    from this register. 2.: Write back this
                                                                    Locking access-key to this register. 3.:
                                                                    Write desired value to the control register.
                                                                    --                                                         */
    
    struct {
      __IOM uint32_t access_key : 16;           /*!< [15..0] Locking access-key for next write access.                         */
    } asic_ctrl_access_key_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t asic_ctrl_irq_raw;           /*!< (@ 0x000000C8) ASIC_CTRL raw IRQ: Read access shows status of
                                                                    unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the appropriate IRQ.
                                                                    Write access with '0' does not influence
                                                                    this bit.                                                  */
    
    struct {
      __IOM uint32_t firewall_hifmem_sdram_com : 1;/*!< [0..0] Firewall of hifmem_sdram blocked a request of COM side          */
      __IOM uint32_t firewall_hifmem_sdram_app : 1;/*!< [1..1] Firewall of hifmem_sdram blocked a request of APP side          */
      __IOM uint32_t firewall_hifmem_amem_com : 1;/*!< [2..2] Firewall of hifmem_amem blocked a request of COM side            */
      __IOM uint32_t firewall_hifmem_amem_app : 1;/*!< [3..3] Firewall of hifmem_amem blocked a request of APP side            */
      __IOM uint32_t firewall_sqirom_com : 1;   /*!< [4..4] Firewall of sqirom blocked a request of COM side                   */
      __IOM uint32_t firewall_sqirom_app : 1;   /*!< [5..5] Firewall of sqirom blocked a request of APP side                   */
      __IOM uint32_t firewall_crypt_com : 1;    /*!< [6..6] Firewall of crypt blocked a request of COM side                    */
      __IOM uint32_t firewall_crypt_app : 1;    /*!< [7..7] Firewall of crypt blocked a request of APP side                    */
      __IOM uint32_t bod_fail   : 1;            /*!< [8..8] Voltage at BOD pad dropped below threshold.                        */
    } asic_ctrl_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t asic_ctrl_irq_masked;        /*!< (@ 0x000000CC) ASIC_CTRL masked IRQ: Shows status of masked
                                                                    IRQs.                                                      */
    
    struct {
      __IM  uint32_t firewall_hifmem_sdram_com : 1;/*!< [0..0] Firewall of hifmem_sdram blocked a request of COM side          */
      __IM  uint32_t firewall_hifmem_sdram_app : 1;/*!< [1..1] Firewall of hifmem_sdram blocked a request of APP side          */
      __IM  uint32_t firewall_hifmem_amem_com : 1;/*!< [2..2] Firewall of hifmem_amem blocked a request of COM side            */
      __IM  uint32_t firewall_hifmem_amem_app : 1;/*!< [3..3] Firewall of hifmem_amem blocked a request of APP side            */
      __IM  uint32_t firewall_sqirom_com : 1;   /*!< [4..4] Firewall of sqirom blocked a request of COM side                   */
      __IM  uint32_t firewall_sqirom_app : 1;   /*!< [5..5] Firewall of sqirom blocked a request of APP side                   */
      __IM  uint32_t firewall_crypt_com : 1;    /*!< [6..6] Firewall of crypt blocked a request of COM side                    */
      __IM  uint32_t firewall_crypt_app : 1;    /*!< [7..7] Firewall of crypt blocked a request of APP side                    */
      __IM  uint32_t bod_fail   : 1;            /*!< [8..8] Voltage at BOD pad dropped below threshold                         */
    } asic_ctrl_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t asic_ctrl_irq_mask_set;      /*!< (@ 0x000000D0) ASIC_CTRL IRQ mask set: The IRQ mask enables
                                                                    interrupt requests for corresponding interrupt
                                                                    sources. As its bits might be changed by
                                                                    different software tasks, the IRQ maskq
                                                                    register is not writable directly, but by
                                                                    set and reset masks: Write access with '1'
                                                                    sets interrupt mask bit. Write access with
                                                                    '0' does not influence this bit. Read access
                                                                    shows actual interrupt mask. Attention:
                                                                    Before activating interrupt mask, delete
                                                                    old pending interrupts by writing the same
                                                                    value to bod_irq_raw.                                      */
    
    struct {
      __IOM uint32_t firewall_hifmem_sdram_com : 1;/*!< [0..0] Firewall of hifmem_sdram blocked a request of COM side          */
      __IOM uint32_t firewall_hifmem_sdram_app : 1;/*!< [1..1] Firewall of hifmem_sdram blocked a request of APP side          */
      __IOM uint32_t firewall_hifmem_amem_com : 1;/*!< [2..2] Firewall of hifmem_amem blocked a request of COM side            */
      __IOM uint32_t firewall_hifmem_amem_app : 1;/*!< [3..3] Firewall of hifmem_amem blocked a request of APP side            */
      __IOM uint32_t firewall_sqirom_com : 1;   /*!< [4..4] Firewall of sqirom blocked a request of COM side                   */
      __IOM uint32_t firewall_sqirom_app : 1;   /*!< [5..5] Firewall of sqirom blocked a request of APP side                   */
      __IOM uint32_t firewall_crypt_com : 1;    /*!< [6..6] Firewall of crypt blocked a request of COM side                    */
      __IOM uint32_t firewall_crypt_app : 1;    /*!< [7..7] Firewall of crypt blocked a request of APP side                    */
      __IOM uint32_t bod_fail   : 1;            /*!< [8..8] Voltage at BOD pad dropped below threshold.                        */
    } asic_ctrl_irq_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t asic_ctrl_irq_mask_reset;    /*!< (@ 0x000000D4) ASIC_CTRL IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t firewall_hifmem_sdram_com : 1;/*!< [0..0] Firewall of hifmem_sdram blocked a request of COM side          */
      __IOM uint32_t firewall_hifmem_sdram_app : 1;/*!< [1..1] Firewall of hifmem_sdram blocked a request of APP side          */
      __IOM uint32_t firewall_hifmem_amem_com : 1;/*!< [2..2] Firewall of hifmem_amem blocked a request of COM side            */
      __IOM uint32_t firewall_hifmem_amem_app : 1;/*!< [3..3] Firewall of hifmem_amem blocked a request of APP side            */
      __IOM uint32_t firewall_sqirom_com : 1;   /*!< [4..4] Firewall of sqirom blocked a request of COM side                   */
      __IOM uint32_t firewall_sqirom_app : 1;   /*!< [5..5] Firewall of sqirom blocked a request of APP side                   */
      __IOM uint32_t firewall_crypt_com : 1;    /*!< [6..6] Firewall of crypt blocked a request of COM side                    */
      __IOM uint32_t firewall_crypt_app : 1;    /*!< [7..7] Firewall of crypt blocked a request of APP side                    */
      __IOM uint32_t bod_fail   : 1;            /*!< [8..8] Voltage at BOD pad dropped below threshold.                        */
    } asic_ctrl_irq_mask_reset_b;
  } ;
} asic_ctrl_Type;                               /*!< Size = 216 (0xd8)                                                         */



/* =========================================================================================================================== */
/* ================                                         mmio_ctrl                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief mmio_ctrl (mmio_ctrl)
  */

typedef struct {                                /*!< (@ 0xFF401300) mmio_ctrl Structure                                        */
  
  union {
    __IOM uint32_t mmio0_cfg;                   /*!< (@ 0x00000000) Register description is too long, please enter
                                                                    short descripton                                           */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio0 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio0, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio0, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio0, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio0_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio1_cfg;                   /*!< (@ 0x00000004) Multiplexmatrix Configuration Register for MMIO1
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio1 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio1, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio1, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio1, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio1_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio2_cfg;                   /*!< (@ 0x00000008) Multiplexmatrix Configuration Register for MMIO2
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio2 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio2, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio2, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio2, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio2_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio3_cfg;                   /*!< (@ 0x0000000C) Multiplexmatrix Configuration Register for MMIO3
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio3 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio3, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio3, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio3, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio3_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio4_cfg;                   /*!< (@ 0x00000010) Multiplexmatrix Configuration Register for MMIO4
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio4 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio4, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio4, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio4, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio4_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio5_cfg;                   /*!< (@ 0x00000014) Multiplexmatrix Configuration Register for MMIO5
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio5 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio5, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio5, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio5, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio5_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio6_cfg;                   /*!< (@ 0x00000018) Multiplexmatrix Configuration Register for MMIO6
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio6 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio6, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio6, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio6, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio6_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio7_cfg;                   /*!< (@ 0x0000001C) Multiplexmatrix Configuration Register for MMIO7
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio7 signal selection (default: PIO mode, access-key-protected).  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_oe     : 1;            /*!< [16..16] PIO mode output enable of mmio7, could also be programmd
                                                     by mmio_pio_oe_line_cfg register (not protected) Changing
                                                     this bit will also change according bit in 'mmio_pio_oe_line_cfg
                                                     register'.                                                                */
      __IOM uint32_t pio_out    : 1;            /*!< [17..17] PIO mode output drive level of mmio7, could also be
                                                     programmd by 'mmio_pio_out_line_cfg' register (not protected)
                                                     Changing this bit will also change according bit in 'mmio_pio_out_line_cf
                                                     register'.                                                                */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio7, could also be read from
                                                     'mmio_in_line_status' register                                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio7_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio8_cfg;                   /*!< (@ 0x00000020) Multiplexmatrix Configuration Register for MMIO8
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio8 signal selection and multiplex function enable
                                                     (access-key-protected). mmio8 signal is a multiplex option
                                                     of HIF_D8 and will be selected when this bit-field is programmed
                                                     to non-PIO MMIO function. PIO mode does not exist for this
                                                     mmio8 signal. Default value 0x3f deselects mmio8 multiplex
                                                     option.                                                                   */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio8 port HIF_D8. Could also
                                                     be read from mmio_in_line_status register                                 */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio8_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio9_cfg;                   /*!< (@ 0x00000024) Multiplexmatrix Configuration Register for MMIO9
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    is                                                         */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio9 signal selection and multiplex function enable
                                                     (access-key-protected). mmio9 signal is a multiplex option
                                                     of HIF_D9 and will be selected when this bit-field is programmed
                                                     to non-PIO MMIO function. PIO mode does not exist for this
                                                     mmio9 signal. Default value 0x3f deselects mmio9 multiplex
                                                     option.                                                                   */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio9 port HIF_D9. Could also
                                                     be read from mmio_in_line_status register                                 */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio9_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio10_cfg;                  /*!< (@ 0x00000028) Multiplexmatrix Configuration Register for MMIO10
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    i                                                          */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio10 signal selection and multiplex function enable
                                                     (access-key-protected). mmio10 signal is a multiplex option
                                                     of HIF_D10 and will be selected when this bit-field is
                                                     programmed to non-PIO MMIO function. PIO mode does not
                                                     exist for this mmio10 signal. Default value 0x3f deselects
                                                     mmio10 multiplex option.                                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio10 port HIF_D10. Could
                                                     also be read from mmio_in_line_status register                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio10_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio11_cfg;                  /*!< (@ 0x0000002C) Multiplexmatrix Configuration Register for MMIO11
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    i                                                          */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio11 signal selection and multiplex function enable
                                                     (access-key-protected). mmio11 signal is a multiplex option
                                                     of HIF_D11 and will be selected when this bit-field is
                                                     programmed to non-PIO MMIO function. PIO mode does not
                                                     exist for this mmio11 signal. Default value 0x3f deselects
                                                     mmio11 multiplex option.                                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio11 port HIF_D11. Could
                                                     also be read from mmio_in_line_status register                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio11_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio12_cfg;                  /*!< (@ 0x00000030) Multiplexmatrix Configuration Register for MMIO12
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    i                                                          */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio12 signal selection and multiplex function enable
                                                     (access-key-protected). mmio12 signal is a multiplex option
                                                     of HIF_D12 and will be selected when this bit-field is
                                                     programmed to non-PIO MMIO function. PIO mode does not
                                                     exist for this mmio12 signal. Default value 0x3f deselects
                                                     mmio12 multiplex option.                                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio12 port HIF_D12. Could
                                                     also be read from mmio_in_line_status register                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio12_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio13_cfg;                  /*!< (@ 0x00000034) Multiplexmatrix Configuration Register for MMIO13
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    i                                                          */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio13 signal selection and multiplex function enable
                                                     (access-key-protected). mmio13 signal is a multiplex option
                                                     of HIF_D13 and will be selected when this bit-field is
                                                     programmed to non-PIO MMIO function. PIO mode does not
                                                     exist for this mmio13 signal. Default value 0x3f deselects
                                                     mmio13 multiplex option.                                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio13 port HIF_D13. Could
                                                     also be read from mmio_in_line_status register                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio13_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio14_cfg;                  /*!< (@ 0x00000038) Multiplexmatrix Configuration Register for MMIO14
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    i                                                          */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio14 signal selection and multiplex function enable
                                                     (access-key-protected). mmio14 signal is a multiplex option
                                                     of HIF_D14 and will be selected when this bit-field is
                                                     programmed to non-PIO MMIO function. PIO mode does not
                                                     exist for this mmio14 signal. Default value 0x3f deselects
                                                     mmio14 multiplex option.                                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio14 port HIF_D14. Could
                                                     also be read from mmio_in_line_status register                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio14_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio15_cfg;                  /*!< (@ 0x0000003C) Multiplexmatrix Configuration Register for MMIO15
                                                                    ------------------------------- Some bits
                                                                    of this register is protected by the netX
                                                                    access-key mechanism; changing this register
                                                                    is only possible by the following sequence:
                                                                    1.: read out access-key from asic_ctrl_access_key
                                                                    register 2.: write back access-key to asic_ctrl_access_key
                                                                    register 3.: write desired value to this
                                                                    register -------------------------------
                                                                    Core-inputs not mapped to any MMIO will
                                                                    be assigned to 0. If one core-connection
                                                                    i                                                          */
    
    struct {
      __IOM uint32_t mmio_sel   : 6;            /*!< [5..0] mmio15 signal selection and multiplex function enable
                                                     (access-key-protected). mmio15 signal is a multiplex option
                                                     of HIF_D15 and will be selected when this bit-field is
                                                     programmed to non-PIO MMIO function. PIO mode does not
                                                     exist for this mmio15 signal. Default value 0x3f deselects
                                                     mmio15 multiplex option.                                                  */
      __IOM uint32_t reserved0  : 3;            /*!< [8..6] reserved                                                           */
      __IOM uint32_t mmio_out_inv : 1;          /*!< [9..9] 1: invert output signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t mmio_in_inv : 1;           /*!< [10..10] 1: invert input signal; 0: keep original signal polarity
                                                     (access-key-protected)                                                    */
      __IOM uint32_t reserved1  : 7;            /*!< [17..11] reserved                                                         */
      __IOM uint32_t status_in_ro : 1;          /*!< [18..18] current input status of mmio15 port HIF_D15. Could
                                                     also be read from mmio_in_line_status register                            */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } mmio15_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mmio_pio_out_line_cfg0;      /*!< (@ 0x00000040) MMIO PIO line output level register of MMIO 0
                                                                    to 15. Changing bits here will change 'pio_out'
                                                                    bit of related mmio*_cfg register. Changes
                                                                    there will change related bit inside this
                                                                    register. Note: This register is not protected
                                                                    by netX access-key algorithm. Note MMIO8
                                                                    has no PIO function. The value of bit 8
                                                                    of (assotiated with MMIO8) will be ignored.
                                                                    MMIO9 has no PIO function. The value of
                                                                    bit 9 of (assotiated with MMIO9) will be
                                                                    ignored. MMIO10 has no PIO function. The
                                                                    value of bit 10 of (ass                                    */
    
    struct {
      __IOM uint32_t line       : 16;           /*!< [15..0] MMIO output state if related MMIO is in PIO mode. If
                                                     related MMIO is not in PIO mode, programmed setting is
                                                     ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ...
                                                     bit 15 controlls MMIO15.                                                  */
    } mmio_pio_out_line_cfg0_b;
  } ;
  
  union {
    __IOM uint32_t mmio_pio_out_line_set_cfg0;  /*!< (@ 0x00000044) MMIO PIO line output level set register of MMIO
                                                                    0 to 15. This register is for setting single
                                                                    MMIO PIOs to high level with a single access.
                                                                    In contrast to using the 'mmio_pio_out_line_cfg0'
                                                                    register no read-modify-write sequence (which
                                                                    could be interrupted) is required. Writing
                                                                    '1's here will activate the 'pio_out' bit
                                                                    of related 'mmio*_cfg' register and also
                                                                    activate the related bits in the 'mmio_pio_out_line_cfg0'
                                                                    register. For read this register returns
                                                                    the same value as the 'mmio_pio_out_                       */
    
    struct {
      __IOM uint32_t line       : 16;           /*!< [15..0] Write '1's to set the related MMIO output to high level
                                                     (when it is in PIO mode and output is enabled). If related
                                                     MMIO is not in PIO mode, programmed setting is ignored.
                                                     Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15
                                                     controlls MMIO15. For read the current value of the programmed
                                                     output states is returned (i.e. the value of mmio_pio_out_line_cfg0).     */
    } mmio_pio_out_line_set_cfg0_b;
  } ;
  
  union {
    __IOM uint32_t mmio_pio_out_line_reset_cfg0;/*!< (@ 0x00000048) MMIO PIO line output level reset register of
                                                                    MMIO 0 to 15. This register is for deactivating
                                                                    single MMIO PIOs with a single access. In
                                                                    contrast to using the 'mmio_pio_out_line_cfg0'
                                                                    register no read-modify-write sequence (which
                                                                    could be interrupted) is required. Writing
                                                                    '1's here will clear the 'pio_out' bit of
                                                                    related 'mmio*_cfg' register and also clear
                                                                    the related bits in the 'mmio_pio_out_line_cfg0'
                                                                    register. For read this register returns
                                                                    the same value as the 'mmio_pio_out_line_cfg0'
                                                                    re                                                         */
    
    struct {
      __IOM uint32_t line       : 16;           /*!< [15..0] Write '1's to set the related MMIO output to low level
                                                     (when it is in PIO mode and output is enabled). If related
                                                     MMIO is not in PIO mode, programmed setting is ignored.
                                                     Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15
                                                     controlls MMIO15. For read the current value of the programmed
                                                     output states is returned (i.e. the value of mmio_pio_out_line_cfg0).     */
    } mmio_pio_out_line_reset_cfg0_b;
  } ;
  
  union {
    __IOM uint32_t mmio_pio_oe_line_cfg0;       /*!< (@ 0x0000004C) MMIO PIO line output enable register of MMIO
                                                                    0 to 15. Changing bits here will change
                                                                    'pio_oe' bit of related mmio*_cfg register.
                                                                    Changes there will change related bit inside
                                                                    this register. Note: This register is not
                                                                    protected by netX access-key algorithm.
                                                                    Note MMIO8 has no PIO function. The value
                                                                    of bit 8 of (assotiated with MMIO8) will
                                                                    be ignored. MMIO9 has no PIO function. The
                                                                    value of bit 9 of (assotiated with MMIO9)
                                                                    will be ignored. MMIO10 has no PIO function.
                                                                    The value of bit 10 of (ass                                */
    
    struct {
      __IOM uint32_t line       : 16;           /*!< [15..0] MMIO output enable if related MMIO is in PIO mode. If
                                                     related MMIO is not in PIO mode, programmed setting is
                                                     ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ...
                                                     bit 15 controlls MMIO15.                                                  */
    } mmio_pio_oe_line_cfg0_b;
  } ;
  
  union {
    __IOM uint32_t mmio_pio_oe_line_set_cfg0;   /*!< (@ 0x00000050) MMIO PIO line output enable set register of MMIO
                                                                    0 to 15. This register is for activating
                                                                    single MMIO PIOs with a single access. In
                                                                    contrast to using the 'mmio_pio_oe_line_cfg0'
                                                                    register no read-modify-write sequence (which
                                                                    could be interrupted) is required. Writing
                                                                    '1's here will activate the 'pio_oe' bit
                                                                    of related 'mmio*_cfg' register and also
                                                                    activate the related bits in the 'mmio_pio_oe_line_cfg0'
                                                                    register. For read this register returns
                                                                    the same value as the 'mmio_pio_oe_line_cfg0'
                                                                    reg                                                        */
    
    struct {
      __IOM uint32_t line       : 16;           /*!< [15..0] Write '1's to activate the related MMIO output enable
                                                     (when it is in PIO mode). If related MMIO is not in PIO
                                                     mode, programmed setting is ignored. Bit 0 controls MMIO0,
                                                     bit 1 controls MMIO1, ... bit 15 controlls MMIO15. For
                                                     read the current value of the programmed output enables
                                                     is returned (i.e. the value of mmio_pio_oe_line_cfg0).                    */
    } mmio_pio_oe_line_set_cfg0_b;
  } ;
  
  union {
    __IOM uint32_t mmio_pio_oe_line_reset_cfg0; /*!< (@ 0x00000054) MMIO PIO line output enable reset register of
                                                                    MMIO 0 to 15. This register is for deactivating
                                                                    single MMIO PIOs with a single access. In
                                                                    contrast to using the 'mmio_pio_oe_line_cfg0'
                                                                    register no read-modify-write sequence (which
                                                                    could be interrupted) is required. Writing
                                                                    '1's here will clear the 'pio_oe' bit of
                                                                    related 'mmio*_cfg' register and also clear
                                                                    the related bits in the 'mmio_pio_oe_line_cfg0'
                                                                    register. For read this register returns
                                                                    the same value as the 'mmio_pio_oe_line_cfg0'
                                                                    regis                                                      */
    
    struct {
      __IOM uint32_t line       : 16;           /*!< [15..0] Write '1's to clear the related MMIO output enable (when
                                                     it is in PIO mode). If related MMIO is not in PIO mode,
                                                     programmed setting is ignored. Bit 0 controls MMIO0, bit
                                                     1 controls MMIO1, ... bit 15 controlls MMIO15. For read
                                                     the current value of the programmed output enables is returned
                                                     (i.e. the value of mmio_pio_oe_line_cfg0).                                */
    } mmio_pio_oe_line_reset_cfg0_b;
  } ;
  
  union {
    __IM  uint32_t mmio_in_line_status0;        /*!< (@ 0x00000058) MMIO input line register of MMIO 0 to 15.                  */
    
    struct {
      __IM  uint32_t line       : 16;           /*!< [15..0] sampled MMIO input state. Does not depend whether MMIO
                                                     is in PIO mode or not. Bit 0 monitors MMIO0, Bit 1 monitors
                                                     MMIO1, ... bit 15 monitors MMIO15.                                        */
    } mmio_in_line_status0_b;
  } ;
  
  union {
    __IM  uint32_t mmio_is_pio_status0;         /*!< (@ 0x0000005C) MMIO mode line register of MMIO 0 to 15. Note:
                                                                    PIO Mode can be enabled or disabled in mmio_cfg
                                                                    registers. Note MMIO8 is not a standard-function
                                                                    MMIO and has no PIO function. When bit 8
                                                                    is set, MMIO8-function will be active on
                                                                    HIF_D8. MMIO9 is not a standard-function
                                                                    MMIO and has no PIO function. When bit 9
                                                                    is set, MMIO9-function will be active on
                                                                    HIF_D9. MMIO10 is not a standard-function
                                                                    MMIO and has no PIO function. When bit 10
                                                                    is set, MMIO10-function will be active on
                                                                    HIF_D10. MMIO11 is no                                      */
    
    struct {
      __IM  uint32_t line       : 16;           /*!< [15..0] Bit 0 shows status of MMIO0, Bit 1 shows status of MMIO1,
                                                     ... bit 15 shows MMIO15. If the MMIO is the standard function
                                                     of the netX IO (i.e. the netX pin name is MMIOx), the bit
                                                     of the related MMIO shows whether the MMIO is in PIO mode
                                                     or not. If the MMIO is a multiplex function of a netX IO
                                                     (i.e. the netX pin name is another than MMIOx), a PIO function
                                                     is not available by the MMIO function. In this case the
                                                     bit of the related MMIO shows whether the MMIO function
                                                     is selected or not. {                                                     */
    } mmio_is_pio_status0_b;
  } ;
} mmio_ctrl_Type;                               /*!< Size = 96 (0x60)                                                          */



/* =========================================================================================================================== */
/* ================                                      global_buf_man                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief global_buf_man (global_buf_man)
  */

typedef struct {                                /*!< (@ 0xFF401380) global_buf_man Structure                                   */
  
  union {
    __IOM uint32_t global_read_buffer_0;        /*!< (@ 0x00000000) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_0_b;
  } ;
  
  union {
    __IOM uint32_t global_read_buffer_1;        /*!< (@ 0x00000004) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_1_b;
  } ;
  
  union {
    __IOM uint32_t global_read_buffer_2;        /*!< (@ 0x00000008) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_2_b;
  } ;
  
  union {
    __IOM uint32_t global_read_buffer_3;        /*!< (@ 0x0000000C) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_3_b;
  } ;
  
  union {
    __IOM uint32_t global_read_buffer_4;        /*!< (@ 0x00000010) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_4_b;
  } ;
  
  union {
    __IOM uint32_t global_read_buffer_5;        /*!< (@ 0x00000014) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_5_b;
  } ;
  
  union {
    __IOM uint32_t global_read_buffer_6;        /*!< (@ 0x00000018) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_6_b;
  } ;
  
  union {
    __IOM uint32_t global_read_buffer_7;        /*!< (@ 0x0000001C) read: get read buffer number write reset buffer
                                                                    states                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: read buffer number[0,1,2] , [3] = empty-no buffer            */
    } global_read_buffer_7_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_0;       /*!< (@ 0x00000020) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_0_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_1;       /*!< (@ 0x00000024) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_1_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_2;       /*!< (@ 0x00000028) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_2_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_3;       /*!< (@ 0x0000002C) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_3_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_4;       /*!< (@ 0x00000030) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_4_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_5;       /*!< (@ 0x00000034) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_5_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_6;       /*!< (@ 0x00000038) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_6_b;
  } ;
  
  union {
    __IOM uint32_t global_write_buffer_7;       /*!< (@ 0x0000003C) read: get write buffer number write release write
                                                                    buffer                                                     */
    
    struct {
      __IOM uint32_t val        : 2;            /*!< [1..0] read: write buffer number[0,1,2]                                   */
    } global_write_buffer_7_b;
  } ;
} global_buf_man_Type;                          /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                        iflash_cfg2                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief iflash_cfg2 (iflash_cfg2)
  */

typedef struct {                                /*!< (@ 0xFF401400) iflash_cfg2 Structure                                      */
  
  union {
    __IOM uint32_t buffer_read_ahead_instructions;/*!< (@ 0x00000000) read ahead on instruction channel of flash controller
                                                                    max read ahead = buffer lines - 1                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] read ahead on instruction channel of flash controller             */
    } buffer_read_ahead_instructions_b;
  } ;
  
  union {
    __IOM uint32_t buffer_read_ahead_data;      /*!< (@ 0x00000004) read ahead on data channel of flash controller
                                                                    max read ahead = buffer lines - 1                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] read ahead on data channel of flash controller                    */
    } buffer_read_ahead_data_b;
  } ;
  
  union {
    __IOM uint32_t iflash_signals_cfg;          /*!< (@ 0x00000008) no Register description                                    */
    
    struct {
      __IOM uint32_t xe         : 1;            /*!< [0..0] x address enable                                                   */
      __IOM uint32_t ye         : 1;            /*!< [1..1] y address enable                                                   */
      __IOM uint32_t erase      : 1;            /*!< [2..2] defines erase cycle                                                */
      __IOM uint32_t mas1       : 1;            /*!< [3..3] defines mass erase cycle                                           */
      __IOM uint32_t nvstr      : 1;            /*!< [4..4] defines non-volatile store cycle                                   */
      __IOM uint32_t prog       : 1;            /*!< [5..5] defines program cycle                                              */
      __IOM uint32_t se         : 1;            /*!< [6..6] flash clock                                                        */
    } iflash_signals_cfg_b;
  } ;
  
  union {
    __IOM uint32_t iflash_mode_cfg;             /*!< (@ 0x0000000C) no Register description                                    */
    
    struct {
      __IOM uint32_t iflash_mode : 3;           /*!< [2..0] 3'b000 READ_MODE / 3'b001 PROGRAM_MODE / 3'b010 ERASE_MODE
                                                     / 3'b011 MASS_ERASE_MODE / 3'b100 MANUAL_MODE                             */
    } iflash_mode_cfg_b;
  } ;
  
  union {
    __IM  uint32_t iflash_access;               /*!< (@ 0x00000010) read only for the ready bit, write 1 to start
                                                                    access flash action depends on iflash_mode_cfg             */
    
    struct {
      __IM  uint32_t run        : 1;            /*!< [0..0] write 1 to start accesss, poll until set to 0 for finsh            */
    } iflash_access_b;
  } ;
  
  union {
    __IOM uint32_t iflash_yadr;                 /*!< (@ 0x00000014) Y address of flash controller not all bits are
                                                                    used see: implementation size of flash                     */
    
    struct {
      __IOM uint32_t val        : 5;            /*!< [4..0] Y address of flash controller                                      */
    } iflash_yadr_b;
  } ;
  
  union {
    __IOM uint32_t iflash_xadr;                 /*!< (@ 0x00000018) X address of flash controller not all bits are
                                                                    used see: implementation size of flash                     */
    
    struct {
      __IOM uint32_t val        : 10;           /*!< [9..0] X address of flash controller                                      */
    } iflash_xadr_b;
  } ;
  
  union {
    __IOM uint32_t iflash_din0;                 /*!< (@ 0x0000001C) data[31:0] of din flash controller                         */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data[31:0] of din flash controller                                */
    } iflash_din0_b;
  } ;
  
  union {
    __IOM uint32_t iflash_din1;                 /*!< (@ 0x00000020) data[63:32] of din flash controller                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data[63:32] of din flash controller                               */
    } iflash_din1_b;
  } ;
  
  union {
    __IOM uint32_t iflash_din2;                 /*!< (@ 0x00000024) data[95:64] of din flash controller                        */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data[95:64] of din flash controller                               */
    } iflash_din2_b;
  } ;
  
  union {
    __IOM uint32_t iflash_din3;                 /*!< (@ 0x00000028) data[127:96] of din flash controller                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data[127:96] of din flash controller                              */
    } iflash_din3_b;
  } ;
  
  union {
    __IOM uint32_t iflash_din4;                 /*!< (@ 0x0000002C) in manual mode for din data[143:128] of din flash
                                                                    controller                                                 */
    
    struct {
      __IOM uint32_t val        : 16;           /*!< [15..0] data[143:128] of din flash controller                             */
    } iflash_din4_b;
  } ;
  
  union {
    __IOM uint32_t iflash_reset;                /*!< (@ 0x00000030) reset flash controller                                     */
    
    struct {
      __IOM uint32_t reset      : 1;            /*!< [0..0] 1= reset; 0= release reset                                         */
    } iflash_reset_b;
  } ;
  
  union {
    __IOM uint32_t iflash_red_cfg0;             /*!< (@ 0x00000034) enable redundancy page XADR[9:3]                           */
    
    struct {
      __IOM uint32_t n_enb      : 1;            /*!< [0..0] 0= enable XADR compare; 1= disable XADR compare                    */
      __IOM uint32_t adr0       : 7;            /*!< [7..1] XADR to compare                                                    */
    } iflash_red_cfg0_b;
  } ;
  
  union {
    __IOM uint32_t iflash_red_cfg1;             /*!< (@ 0x00000038) enable redundancy page XADR[9:3]                           */
    
    struct {
      __IOM uint32_t n_enb      : 1;            /*!< [0..0] 0= enable XADR compare; 1= disable XADR compare                    */
      __IOM uint32_t adr1       : 7;            /*!< [7..1] XADR to compare                                                    */
    } iflash_red_cfg1_b;
  } ;
  
  union {
    __IOM uint32_t iflash_ifren_cfg;            /*!< (@ 0x0000003C) no Register description                                    */
    
    struct {
      __IOM uint32_t ifren      : 1;            /*!< [0..0] information block enable                                           */
      __IOM uint32_t ifren1     : 1;            /*!< [1..1] information 1 block enable for read only                           */
    } iflash_ifren_cfg_b;
  } ;
  
  union {
    __IM  uint32_t iflash_din4_ecc;             /*!< (@ 0x00000040) in manual mode for ecc calculation of din3..0              */
    
    struct {
      __IM  uint32_t val        : 16;           /*!< [15..0] ecc of din3..0 flash controller                                   */
    } iflash_din4_ecc_b;
  } ;
  
  union {
    __IOM uint32_t iflash_special_cfg;          /*!< (@ 0x00000044) no Register description                                    */
    
    struct {
      __IOM uint32_t tmr        : 1;            /*!< [0..0] test mode                                                          */
      __IOM uint32_t slm        : 1;            /*!< [1..1] sleep mode                                                         */
    } iflash_special_cfg_b;
  } ;
  
  union {
    __IOM uint32_t iflash_protection_info;      /*!< (@ 0x00000048) no Register description                                    */
    
    struct {
      __IOM uint32_t write_dw   : 1;            /*!< [0..0] protect infopage 0 lower 4k page for write                         */
      __IOM uint32_t write_up   : 1;            /*!< [1..1] protect infopage 0 upper 4k page for write                         */
      __IOM uint32_t read_dw    : 1;            /*!< [2..2] protect infopage 0 lower 4k page for read                          */
      __IOM uint32_t read_up    : 1;            /*!< [3..3] protect infopage 0 upper 4k page for read                          */
    } iflash_protection_info_b;
  } ;
  
  union {
    __IOM uint32_t iflash_write_protection_main;/*!< (@ 0x0000004C) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] protect flash main memory each bit protect 16k (16k
                                                     x 32 = 512 kByte) xadr[9:5]                                               */
    } iflash_write_protection_main_b;
  } ;
} iflash_cfg2_Type;                             /*!< Size = 80 (0x50)                                                          */



/* =========================================================================================================================== */
/* ================                                        hif_io_ctrl                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief hif_io_ctrl (hif_io_ctrl)
  */

typedef struct {                                /*!< (@ 0xFF401480) hif_io_ctrl Structure                                      */
  
  union {
    __IOM uint32_t hif_io_cfg;                  /*!< (@ 0x00000000) IO Config Register: Selects of HIF pin multiplexing.
                                                                    See Excel pinning sheet for details. This
                                                                    configuration must be set up according to
                                                                    external netX connection before any access
                                                                    to external logic. This register is protected
                                                                    by the netX access key mechanism; changing
                                                                    this register is only possible by the following
                                                                    sequence: 1.: read out access key from ACCESS_KEY
                                                                    register (ASIC_CTRL address area) 2.: write
                                                                    back access key to ACCESS_KEY register (ASIC_CTRL
                                                                    address area) 3.: write desired va                         */
    
    struct {
      __IOM uint32_t sel_hif_dpm : 1;           /*!< [0..0] select DPM mode for HIF (serial or parallel) Note: For
                                                     parallel DPM IO configuration use config registers in address
                                                     area DPM. Note: Parallel DPM fast/service IRQ functionality
                                                     (SIRQ/FIQ) on HIF_SDCLK is controlled by en_hif_sdram_mi
                                                     bit Note: For parallel DPM host IRQs can be generated on
                                                     HIF_DIRQ and HIF_SDCLK IOs. Note: For parallel DPM HIF
                                                     PIO function muse be configured inside 'dpm_pio_cfg' registers
                                                     for all HIF IOs.                                                          */
      __IOM uint32_t sel_dpm_serial : 1;        /*!< [1..1] serial (SPI) DPM mode selection (ignored if sel_hif_dpm
                                                     not set). There are 2 independent serial DPM interfaces
                                                     for netX90. They can be used together, e.g. one for cyclic
                                                     and one for acyclic data) or stand-alone. The 1st sDPM
                                                     (sDPM0) can always be used together with external memory
                                                     (even 16bit mode). sDPM1 can only be used with an 8 bit
                                                     MI. The pinning positions of serial DPM interfaces are
                                                     provided by the main pinning table: The pinning-functions
                                                     'dpm0_spi*' represent sDPM0, pinning-functions 'dpm1_spi*'                */
      __IOM uint32_t sel_dpm_serial_sph : 1;    /*!< [2..2] serial DPM mode SPI clock phase selection (sel_hif_dpm
                                                     and sel_dpm_serial must be set) 0: Serial data sampling
                                                     on first serial clock edge. 1: Serial data sampling on
                                                     second serial clock edge.                                                 */
      __IOM uint32_t sel_dpm_serial_spo : 1;    /*!< [3..3] serial DPM mode SPI clock polarity selection (sel_hif_dpm
                                                     and sel_dpm_serial must be set) 0: Serial clock idle state
                                                     is low. 1: Serial clock idle state is high.                               */
      __IOM uint32_t en_sdpm1   : 1;            /*!< [4..4] Enables the 2nd serial DPM for netX90. 0: 2nd serial
                                                     DPM is disabled. 1: 2nd serial DPM is enabled. Note: It
                                                     is possible to enable the 2nd serial DPM stand-alone or
                                                     together with the normal DPM in serial mode (i.e. both
                                                     bits 'sel_hif_dpm' and 'sel_dpm_serial' set). It is not
                                                     possible to use the 2nd serial DPM together with the first
                                                     DPM in parallel mode as they use the same IOs (the 2nd
                                                     DPM does not provide the parallel mode). Note: The mode
                                                     of the 2nd serial DPM is same as for the first DPM (programmed
                                                     by                                                                        */
      __IOM uint32_t hif_mi_cfg : 2;            /*!< [6..5] Global HIF IO Memory Interface usage configuration. Extensionbus/HIF-Me
                                                     ory-Interface and must be enabled and data width selected
                                                     here before memory devices like SRAM/FLASH/SDRAM can be
                                                     used on HIF. Settings: { | 00: HIF IOs are used as 8 bit
                                                     MI. Minimally used HIF IOs: HIF_A0..10, HIF_RDN, HIF_WRN
                                                     + 1 Chip-select. Other HIF IOs can be used for non-MI functions
                                                     (e.g. MMIO8..15, sDPM0 or MLED4..11). Up to 3 Chip-Selects
                                                     are provided (they are PIO by default, view notes): 01:
                                                     HIF IOs are used as 16 bit MI,                                            */
      __IOM uint32_t en_hif_sdram_mi : 1;       /*!< [7..7] Enable HIF IOs for SDRAM Memory Interface configuration.
                                                     HIF-SDRAM Chip-Select is generated on HIF_CSN when this
                                                     bit is set. ExtBus Chip-Select area 0 is not available
                                                     then. Ready-Signal for ExtBus is never available when SDRAM
                                                     is enabled here. If enabled following IOs are used for
                                                     SDRAM (netX90, partial shared with SRAM/FLASH ctrl signals):
                                                     { | | netX90 IO Function Comment HIF_A0..12 SD_A0..12 Shared
                                                     SDRAM/FLASH/SRAM address lines, small SDRAM devices do
                                                     not nee                                                                   */
      __IOM uint32_t sel_hif_a_width : 4;       /*!< [11..8] Select HIF MI address width. Selecting smaller address
                                                     bus width will allow PIO usage on related IOs when not
                                                     used otherwise (e.g. as SDRAM control signals, see en_hif_sdram_mi).
                                                     A0 to A11 are always enabled when the HIF MI is enabled
                                                     by the hif_mi_cfg bits. Following settings are valid for
                                                     8 or 16 bit data modes. Please note: - The lower byte of
                                                     the MI is located on the MII signals (refer to the pinning
                                                     table). - The upper byte of the MI is located on the lower
                                                     HIF_D IOs (HIF_D0..7, not on HIF_D8..15). -                               */
      __IOM uint32_t reserved0  : 12;           /*!< [23..12] reserved                                                         */
      __IOM uint32_t en_hif_rdy_pio_mi : 1;     /*!< [24..24] Enable HIF_RDY for PIO usage (or other netX MUX function)
                                                     when the HIF is in memory-mode. Note: This bit must be
                                                     disabled if HIF_RDY is used as EXT_BUS RDY (extension bus
                                                     ready input). Note: This bit is ignored if HIF is DPM.
                                                     Use DPM RDY configuration if HIF_RDY should be used as
                                                     PIO together with DPM functionality.                                      */
      __IOM uint32_t en_hif_wdg_sys_hif_d19 : 1;/*!< [25..25] Obsolete for netX90, removed by regdef filter script.
                                                     Enable 'wdg_active'/'WDGACT'-signal of netX system watchdog
                                                     on HIF_D19. When this bit is set HIF_D19 will be set to
                                                     output mode and provide watchdog-active signal. However
                                                     this will have no effect when HIF_D19 is used for another
                                                     function. For parallel DPM with watchdog HIF_D19 must be
                                                     set to PIO mode inside DPM module. Note: netX system watch
                                                     can be programmed inside address area 'WATCHDOG'/'NETX_WDG_AREA'.         */
      __IOM uint32_t reserved1  : 6;            /*!< [31..26] reserved                                                         */
    } hif_io_cfg_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_cfg;                 /*!< (@ 0x00000004) HIF PIO Mode configuration register.                       */
    
    struct {
      __IOM uint32_t in_ctrl    : 2;            /*!< [1..0] HIF PIO Input sampling mode. HIF input status registers
                                                     hif_pio_in0,1 can be configured by programming these bits.
                                                     { | Mode Function 00 pio_in registers show HIF IO states
                                                     sampled at power-on-reset release. 01 HIF IO states are
                                                     sampled continuously (each netX system clock cycle) 10
                                                     HIF IO states are sampling is done each system clock cycle
                                                     when enable signal EN_IN (MMIO-function) level is low.
                                                     11 HIF IO states are sampling is done each system clock
                                                     cycle when enable signal EN_IN (MMIO-fun                                  */
      __IOM uint32_t reserved0  : 1;            /*!< [2..2] reserved                                                           */
      __IOM uint32_t filter_en_in : 1;          /*!< [3..3] HIF PIO Input sampling enable (EN_IN) filter. 0 Spikes
                                                     will not be suppressed for EN_IN. 1 Spikes up to 10ns will
                                                     be suppressed by HIF PIO EN_IN sample stages. Note: Spike
                                                     suppression can only done for EN_IN input. There is no
                                                     spike suppression for data inputs of 'hif_pio_in0,1' registers.           */
      __IOM uint32_t reserved1  : 12;           /*!< [15..4] reserved                                                          */
      __IOM uint32_t irq_hif_d12_cfg : 2;       /*!< [17..16] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) IRQ input configuration
                                                     For coding refer to irq_hif_dirq_cfg bit-field.                           */
      __IOM uint32_t irq_hif_a16_cfg : 2;       /*!< [19..18] HIF_A16 IRQ input configuration For coding refer to
                                                     irq_hif_dirq_cfg bit-field.                                               */
      __IOM uint32_t irq_hif_a17_cfg : 2;       /*!< [21..20] HIF_A17 IRQ input configuration For coding refer to
                                                     irq_hif_dirq_cfg bit-field.                                               */
      __IOM uint32_t reserved2  : 4;            /*!< [25..22] reserved                                                         */
      __IOM uint32_t irq_hif_dirq_cfg : 2;      /*!< [27..26] HIF_DIRQ IRQ input configuration { | Mode Function
                                                     00 low level active IRQ 01 high level active IRQ 10 falling
                                                     edge active IRQ 11 rising edge active IRQ } For IRQ usage
                                                     this IO should be in PIO input mode, (programmed in the
                                                     'hif_io_cfg' register or PIO-configuration registers of
                                                     the DPM module). For input its PIO output enable must be
                                                     programmed to '0'. Spikes on related PIO can be suppressed
                                                     by 'filter_irqs' bit. Note: HIF PIO IRQs can be assigned
                                                     and monitored in hif_pio_irq registers                                    */
      __IOM uint32_t reserved3  : 3;            /*!< [30..28] reserved                                                         */
      __IOM uint32_t filter_irqs : 1;           /*!< [31..31] Filtering of HIF PIO inputs for IRQ generation. By
                                                     default filtering is applied on HIF PIO inputs before IRQ
                                                     generation. 0 Spikes on PIOs will not be suppressed for
                                                     HIF PIO IRQ generation. 1 Spikes up to 10ns on HIF PIOs
                                                     will be suppressed by sample stages for HIF PIO IRQ generation.
                                                     That causes 10ns additionally IRQ latency.                                */
    } hif_pio_cfg_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_out0;                /*!< (@ 0x00000008) HIF PIO Output State Configuration Register 0.
                                                                    All unused HIF signals can be used as PIOs.
                                                                    IOs will be driven to the programmed state
                                                                    if appropriate enable bit is set in hif_pio_oe0
                                                                    register. PIO mode driving of HIF-IOs used
                                                                    in current HIF/EXT_BUS Memory Interface
                                                                    configuration is not possible. -----------------------
                                                                    Note: This register can be read or written
                                                                    by 8, 16 or 32 bit access.                                 */
    
    struct {
      __IOM uint32_t hif_d0     : 1;            /*!< [0..0] PIO output drive level of HIF_D0 signal.                           */
      __IOM uint32_t hif_d1     : 1;            /*!< [1..1] PIO output drive level of HIF_D1 signal.                           */
      __IOM uint32_t hif_d2     : 1;            /*!< [2..2] PIO output drive level of HIF_D2 signal.                           */
      __IOM uint32_t hif_d3     : 1;            /*!< [3..3] PIO output drive level of HIF_D3 signal.                           */
      __IOM uint32_t hif_d4     : 1;            /*!< [4..4] PIO output drive level of HIF_D4 signal.                           */
      __IOM uint32_t hif_d5     : 1;            /*!< [5..5] PIO output drive level of HIF_D5 signal.                           */
      __IOM uint32_t hif_d6     : 1;            /*!< [6..6] PIO output drive level of HIF_D6 signal.                           */
      __IOM uint32_t hif_d7     : 1;            /*!< [7..7] PIO output drive level of HIF_D7 signal.                           */
      __IOM uint32_t hif_d8     : 1;            /*!< [8..8] PIO output drive level of HIF_D8 signal.                           */
      __IOM uint32_t hif_d9     : 1;            /*!< [9..9] PIO output drive level of HIF_D9 signal.                           */
      __IOM uint32_t hif_d10    : 1;            /*!< [10..10] PIO output drive level of HIF_D10 signal.                        */
      __IOM uint32_t hif_d11    : 1;            /*!< [11..11] PIO output drive level of HIF_D11 signal.                        */
      __IOM uint32_t hif_d12    : 1;            /*!< [12..12] PIO output drive level of HIF_D12 signal.                        */
      __IOM uint32_t hif_d13    : 1;            /*!< [13..13] PIO output drive level of HIF_D13 signal.                        */
      __IOM uint32_t hif_d14    : 1;            /*!< [14..14] PIO output drive level of HIF_D14 signal.                        */
      __IOM uint32_t hif_d15    : 1;            /*!< [15..15] PIO output drive level of HIF_D15 signal.                        */
    } hif_pio_out0_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_out1;                /*!< (@ 0x0000000C) HIF PIO Output State Configuration Register 1.
                                                                    All unused HIF signals can be used as PIOs.
                                                                    IOs will be driven to the programmed state
                                                                    if appropriate enable bit is set in hif_pio_oe1
                                                                    register. PIO mode driving of HIF-IOs used
                                                                    in current HIF/EXT_BUS Memory Interface
                                                                    configuration is not possible. -----------------------
                                                                    Note: This register can be read or written
                                                                    by 8, 16 or 32 bit access.                                 */
    
    struct {
      __IOM uint32_t hif_a0     : 1;            /*!< [0..0] PIO output drive level of HIF_A0 signal.                           */
      __IOM uint32_t hif_a1     : 1;            /*!< [1..1] PIO output drive level of HIF_A1 signal.                           */
      __IOM uint32_t hif_a2     : 1;            /*!< [2..2] PIO output drive level of HIF_A2 signal.                           */
      __IOM uint32_t hif_a3     : 1;            /*!< [3..3] PIO output drive level of HIF_A3 signal.                           */
      __IOM uint32_t hif_a4     : 1;            /*!< [4..4] PIO output drive level of HIF_A4 signal.                           */
      __IOM uint32_t hif_a5     : 1;            /*!< [5..5] PIO output drive level of HIF_A5 signal.                           */
      __IOM uint32_t hif_a6     : 1;            /*!< [6..6] PIO output drive level of HIF_A6 signal.                           */
      __IOM uint32_t hif_a7     : 1;            /*!< [7..7] PIO output drive level of HIF_A7 signal.                           */
      __IOM uint32_t hif_a8     : 1;            /*!< [8..8] PIO output drive level of HIF_A8 signal.                           */
      __IOM uint32_t hif_a9     : 1;            /*!< [9..9] PIO output drive level of HIF_A9 signal.                           */
      __IOM uint32_t hif_a10    : 1;            /*!< [10..10] PIO output drive level of HIF_A10 signal.                        */
      __IOM uint32_t hif_a11    : 1;            /*!< [11..11] PIO output drive level of HIF_A11 signal.                        */
      __IOM uint32_t hif_a12    : 1;            /*!< [12..12] PIO output drive level of HIF_A12 signal.                        */
      __IOM uint32_t hif_a13    : 1;            /*!< [13..13] PIO output drive level of HIF_A13 signal.                        */
      __IOM uint32_t hif_a14    : 1;            /*!< [14..14] PIO output drive level of HIF_A14 signal.                        */
      __IOM uint32_t hif_a15    : 1;            /*!< [15..15] PIO output drive level of HIF_A15 signal.                        */
      __IOM uint32_t hif_a16    : 1;            /*!< [16..16] PIO output drive level of HIF_A16 signal.                        */
      __IOM uint32_t hif_a17    : 1;            /*!< [17..17] PIO output drive level of HIF_A17 signal.                        */
      __IOM uint32_t reserved0  : 7;            /*!< [24..18] reserved                                                         */
      __IOM uint32_t hif_bhen   : 1;            /*!< [25..25] PIO output drive level of HIF_BHEN signals.                      */
      __IOM uint32_t hif_rdn    : 1;            /*!< [26..26] PIO output drive level of HIF_RDN signal.                        */
      __IOM uint32_t hif_wrn    : 1;            /*!< [27..27] PIO output drive level of HIF_WRN signal.                        */
      __IOM uint32_t hif_csn    : 1;            /*!< [28..28] PIO output drive level of HIF_CSN signal.                        */
      __IOM uint32_t hif_rdy    : 1;            /*!< [29..29] PIO output drive level of HIF_RDY signal.                        */
      __IOM uint32_t hif_dirq   : 1;            /*!< [30..30] PIO output drive level of HIF_DIRQ signal.                       */
      __IOM uint32_t hif_sdclk  : 1;            /*!< [31..31] PIO output drive level of HIF_SDCLK signal.                      */
    } hif_pio_out1_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_oe0;                 /*!< (@ 0x00000010) HIF PIO Output Enable Configuration Register
                                                                    0. All unused HIF signals can be used as
                                                                    PIOs. IOs will be driven to the output state
                                                                    programmed in in hif_pio_out0 register.
                                                                    PIO mode driving of HIF-IOs used in current
                                                                    HIF/EXT_BUS Memory Interface configuration
                                                                    is not possible. -----------------------
                                                                    Note: This register can be read or written
                                                                    by 8, 16 or 32 bit access.                                 */
    
    struct {
      __IOM uint32_t hif_d0     : 1;            /*!< [0..0] PIO output enable of HIF_D0 signal.                                */
      __IOM uint32_t hif_d1     : 1;            /*!< [1..1] PIO output enable of HIF_D1 signal.                                */
      __IOM uint32_t hif_d2     : 1;            /*!< [2..2] PIO output enable of HIF_D2 signal.                                */
      __IOM uint32_t hif_d3     : 1;            /*!< [3..3] PIO output enable of HIF_D3 signal.                                */
      __IOM uint32_t hif_d4     : 1;            /*!< [4..4] PIO output enable of HIF_D4 signal.                                */
      __IOM uint32_t hif_d5     : 1;            /*!< [5..5] PIO output enable of HIF_D5 signal.                                */
      __IOM uint32_t hif_d6     : 1;            /*!< [6..6] PIO output enable of HIF_D6 signal.                                */
      __IOM uint32_t hif_d7     : 1;            /*!< [7..7] PIO output enable of HIF_D7 signal.                                */
      __IOM uint32_t hif_d8     : 1;            /*!< [8..8] PIO output enable of HIF_D8 signal.                                */
      __IOM uint32_t hif_d9     : 1;            /*!< [9..9] PIO output enable of HIF_D9 signal.                                */
      __IOM uint32_t hif_d10    : 1;            /*!< [10..10] PIO output enable of HIF_D10 signal.                             */
      __IOM uint32_t hif_d11    : 1;            /*!< [11..11] PIO output enable of HIF_D11 signal.                             */
      __IOM uint32_t hif_d12    : 1;            /*!< [12..12] PIO output enable of HIF_D12 signal.                             */
      __IOM uint32_t hif_d13    : 1;            /*!< [13..13] PIO output enable of HIF_D13 signal.                             */
      __IOM uint32_t hif_d14    : 1;            /*!< [14..14] PIO output enable of HIF_D14 signal.                             */
      __IOM uint32_t hif_d15    : 1;            /*!< [15..15] PIO output enable of HIF_D15 signal.                             */
    } hif_pio_oe0_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_oe1;                 /*!< (@ 0x00000014) HIF PIO Output Enable Configuration Register
                                                                    1. All unused HIF signals can be used as
                                                                    PIOs. IOs will be driven to the output state
                                                                    programmed in in hif_pio_out1 register.
                                                                    PIO mode driving of HIF-IOs used in current
                                                                    HIF/EXT_BUS Memory Interface configuration
                                                                    is not possible. -----------------------
                                                                    Note: This register can be read or written
                                                                    by 8, 16 or 32 bit access.                                 */
    
    struct {
      __IOM uint32_t hif_a0     : 1;            /*!< [0..0] PIO output enable of HIF_A0 signal.                                */
      __IOM uint32_t hif_a1     : 1;            /*!< [1..1] PIO output enable of HIF_A1 signal.                                */
      __IOM uint32_t hif_a2     : 1;            /*!< [2..2] PIO output enable of HIF_A2 signal.                                */
      __IOM uint32_t hif_a3     : 1;            /*!< [3..3] PIO output enable of HIF_A3 signal.                                */
      __IOM uint32_t hif_a4     : 1;            /*!< [4..4] PIO output enable of HIF_A4 signal.                                */
      __IOM uint32_t hif_a5     : 1;            /*!< [5..5] PIO output enable of HIF_A5 signal.                                */
      __IOM uint32_t hif_a6     : 1;            /*!< [6..6] PIO output enable of HIF_A6 signal.                                */
      __IOM uint32_t hif_a7     : 1;            /*!< [7..7] PIO output enable of HIF_A7 signal.                                */
      __IOM uint32_t hif_a8     : 1;            /*!< [8..8] PIO output enable of HIF_A8 signal.                                */
      __IOM uint32_t hif_a9     : 1;            /*!< [9..9] PIO output enable of HIF_A9 signal.                                */
      __IOM uint32_t hif_a10    : 1;            /*!< [10..10] PIO output enable of HIF_A10 signal.                             */
      __IOM uint32_t hif_a11    : 1;            /*!< [11..11] PIO output enable of HIF_A11 signal.                             */
      __IOM uint32_t hif_a12    : 1;            /*!< [12..12] PIO output enable of HIF_A12 signal.                             */
      __IOM uint32_t hif_a13    : 1;            /*!< [13..13] PIO output enable of HIF_A13 signal.                             */
      __IOM uint32_t hif_a14    : 1;            /*!< [14..14] PIO output enable of HIF_A14 signal.                             */
      __IOM uint32_t hif_a15    : 1;            /*!< [15..15] PIO output enable of HIF_A15 signal.                             */
      __IOM uint32_t hif_a16    : 1;            /*!< [16..16] PIO output enable of HIF_A16 signal.                             */
      __IOM uint32_t hif_a17    : 1;            /*!< [17..17] PIO output enable of HIF_A17 signal.                             */
      __IOM uint32_t reserved0  : 7;            /*!< [24..18] reserved                                                         */
      __IOM uint32_t hif_bhen   : 1;            /*!< [25..25] PIO output enable of HIF_BHEN signals.                           */
      __IOM uint32_t hif_rdn    : 1;            /*!< [26..26] PIO output enable of HIF_RDN signal.                             */
      __IOM uint32_t hif_wrn    : 1;            /*!< [27..27] PIO output enable of HIF_WRN signal.                             */
      __IOM uint32_t hif_csn    : 1;            /*!< [28..28] PIO output enable of HIF_CSN signal.                             */
      __IOM uint32_t hif_rdy    : 1;            /*!< [29..29] PIO output enable of HIF_RDY signal.                             */
      __IOM uint32_t hif_dirq   : 1;            /*!< [30..30] PIO output enable of HIF_DIRQ signal.                            */
      __IOM uint32_t hif_sdclk  : 1;            /*!< [31..31] PIO output enable of HIF_SDCLK signal.                           */
    } hif_pio_oe1_b;
  } ;
  
  union {
    __IM  uint32_t hif_pio_in0;                 /*!< (@ 0x00000018) HIF PIO Input State Register 0. IO input states
                                                                    can be read here regardless whether IO is
                                                                    used in current HIF/EXT_BUS Memory Interface
                                                                    configuration. HIF IO sampling behaviour
                                                                    can be programmed by 'in_ctrl' bits of 'hif_pio_cfg'
                                                                    register.                                                  */
    
    struct {
      __IM  uint32_t hif_d0     : 1;            /*!< [0..0] PIO input state of HIF_D0 signal.                                  */
      __IM  uint32_t hif_d1     : 1;            /*!< [1..1] PIO input state of HIF_D1 signal.                                  */
      __IM  uint32_t hif_d2     : 1;            /*!< [2..2] PIO input state of HIF_D2 signal.                                  */
      __IM  uint32_t hif_d3     : 1;            /*!< [3..3] PIO input state of HIF_D3 signal.                                  */
      __IM  uint32_t hif_d4     : 1;            /*!< [4..4] PIO input state of HIF_D4 signal.                                  */
      __IM  uint32_t hif_d5     : 1;            /*!< [5..5] PIO input state of HIF_D5 signal.                                  */
      __IM  uint32_t hif_d6     : 1;            /*!< [6..6] PIO input state of HIF_D6 signal.                                  */
      __IM  uint32_t hif_d7     : 1;            /*!< [7..7] PIO input state of HIF_D7 signal.                                  */
      __IM  uint32_t hif_d8     : 1;            /*!< [8..8] PIO input state of HIF_D8 signal.                                  */
      __IM  uint32_t hif_d9     : 1;            /*!< [9..9] PIO input state of HIF_D9 signal.                                  */
      __IM  uint32_t hif_d10    : 1;            /*!< [10..10] PIO input state of HIF_D10 signal.                               */
      __IM  uint32_t hif_d11    : 1;            /*!< [11..11] PIO input state of HIF_D11 signal.                               */
      __IM  uint32_t hif_d12    : 1;            /*!< [12..12] PIO input state of HIF_D12 signal.                               */
      __IM  uint32_t hif_d13    : 1;            /*!< [13..13] PIO input state of HIF_D13 signal.                               */
      __IM  uint32_t hif_d14    : 1;            /*!< [14..14] PIO input state of HIF_D14 signal.                               */
      __IM  uint32_t hif_d15    : 1;            /*!< [15..15] PIO input state of HIF_D15 signal.                               */
    } hif_pio_in0_b;
  } ;
  
  union {
    __IM  uint32_t hif_pio_in1;                 /*!< (@ 0x0000001C) HIF PIO Input State Register 1. IO input states
                                                                    can be read here regardless whether IO is
                                                                    used in current HIF/EXT_BUS Memory Interface
                                                                    configuration.                                             */
    
    struct {
      __IM  uint32_t hif_a0     : 1;            /*!< [0..0] PIO input state of HIF_A0 signal.                                  */
      __IM  uint32_t hif_a1     : 1;            /*!< [1..1] PIO input state of HIF_A1 signal.                                  */
      __IM  uint32_t hif_a2     : 1;            /*!< [2..2] PIO input state of HIF_A2 signal.                                  */
      __IM  uint32_t hif_a3     : 1;            /*!< [3..3] PIO input state of HIF_A3 signal.                                  */
      __IM  uint32_t hif_a4     : 1;            /*!< [4..4] PIO input state of HIF_A4 signal.                                  */
      __IM  uint32_t hif_a5     : 1;            /*!< [5..5] PIO input state of HIF_A5 signal.                                  */
      __IM  uint32_t hif_a6     : 1;            /*!< [6..6] PIO input state of HIF_A6 signal.                                  */
      __IM  uint32_t hif_a7     : 1;            /*!< [7..7] PIO input state of HIF_A7 signal.                                  */
      __IM  uint32_t hif_a8     : 1;            /*!< [8..8] PIO input state of HIF_A8 signal.                                  */
      __IM  uint32_t hif_a9     : 1;            /*!< [9..9] PIO input state of HIF_A9 signal.                                  */
      __IM  uint32_t hif_a10    : 1;            /*!< [10..10] PIO input state of HIF_A10 signal.                               */
      __IM  uint32_t hif_a11    : 1;            /*!< [11..11] PIO input state of HIF_A11 signal.                               */
      __IM  uint32_t hif_a12    : 1;            /*!< [12..12] PIO input state of HIF_A12 signal.                               */
      __IM  uint32_t hif_a13    : 1;            /*!< [13..13] PIO input state of HIF_A13 signal.                               */
      __IM  uint32_t hif_a14    : 1;            /*!< [14..14] PIO input state of HIF_A14 signal.                               */
      __IM  uint32_t hif_a15    : 1;            /*!< [15..15] PIO input state of HIF_A15 signal.                               */
      __IM  uint32_t hif_a16    : 1;            /*!< [16..16] PIO input state of HIF_A16 signal                                */
      __IM  uint32_t hif_a17    : 1;            /*!< [17..17] PIO input state of HIF_A17 signal                                */
      __IM  uint32_t reserved0  : 7;            /*!< [24..18] reserved                                                         */
      __IM  uint32_t hif_bhen   : 1;            /*!< [25..25] PIO input state of HIF_BHEN signal.                              */
      __IM  uint32_t hif_rdn    : 1;            /*!< [26..26] PIO input state of HIF_RDN signal.                               */
      __IM  uint32_t hif_wrn    : 1;            /*!< [27..27] PIO input state of HIF_WRN signal.                               */
      __IM  uint32_t hif_csn    : 1;            /*!< [28..28] PIO input state of HIF_CSN signal.                               */
      __IM  uint32_t hif_rdy    : 1;            /*!< [29..29] PIO input state of HIF_RDY signal.                               */
      __IM  uint32_t hif_dirq   : 1;            /*!< [30..30] PIO input state of HIF_DIRQ signal.                              */
      __IM  uint32_t hif_sdclk  : 1;            /*!< [31..31] PIO input state of HIF_SDCLK signal.                             */
    } hif_pio_in1_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t hif_pio_irq_raw;             /*!< (@ 0x00000024) HIF PIO Raw (before masking) IRQ Status Register.
                                                                    If bit is set, the according interrupt is
                                                                    asserted. Interrupt status can be cleared
                                                                    by writing ones to this register. Each IRQ
                                                                    source can be assigned either to xPIC or
                                                                    to ARM (or to both) by the following registers.
                                                                    IRQ clearing has lower priority than IRQ
                                                                    set when done simultaneously. Note: Spikes
                                                                    up to 10ns will be suppressed by HIF PIO
                                                                    IRQ sample stages. Note: HIF PIO interrupt
                                                                    function can be configured in the hif_pio_cfg
                                                                    register. Note:                                            */
    
    struct {
      __IOM uint32_t irq_hif_d12 : 1;           /*!< [0..0] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ)                                    */
      __IOM uint32_t irq_hif_a16 : 1;           /*!< [1..1] HIF_A16 IRQ                                                        */
      __IOM uint32_t irq_hif_a17 : 1;           /*!< [2..2] HIF_A17 IRQ                                                        */
      __IOM uint32_t irq_hif_dirq : 1;          /*!< [3..3] HIF_DIRQ IRQ                                                       */
    } hif_pio_irq_raw_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_irq_arm_mask_set;    /*!< (@ 0x00000028) HIF PIO Interrupt Mask Register for netX internal
                                                                    ARM. Write access with '1' sets interrupt
                                                                    mask bit (enables interrupt request for
                                                                    corresponding interrupt source). Write access
                                                                    with '0' does not influence this bit. Read
                                                                    access shows actual interrupt mask. If bit
                                                                    is set, the according interrupt will activate
                                                                    the IRQ for netX internal ARM. Interrupt
                                                                    status can be cleared by writing ones to
                                                                    the hif_pio_irq_raw register. To release
                                                                    IRQ for netX internal ARM without clearing
                                                                    interrupt in module,                                       */
    
    struct {
      __IOM uint32_t irq_hif_d12 : 1;           /*!< [0..0] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ)                                    */
      __IOM uint32_t irq_hif_a16 : 1;           /*!< [1..1] HIF_A16 IRQ                                                        */
      __IOM uint32_t irq_hif_a17 : 1;           /*!< [2..2] HIF_A17 IRQ                                                        */
      __IOM uint32_t irq_hif_dirq : 1;          /*!< [3..3] HIF_DIRQ IRQ                                                       */
    } hif_pio_irq_arm_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_irq_arm_mask_reset;  /*!< (@ 0x0000002C) HIF PIO Interrupt Mask Reset Register for netX
                                                                    internal ARM. Write access with '1' resets
                                                                    interrupt mask bit (disables interrupt request
                                                                    for corresponding interrupt source). Write
                                                                    access with '0' does not influence this
                                                                    bit. Read access shows actual interrupt
                                                                    mask. If bit is set, the according interrupt
                                                                    will activate the IRQ for netX internal
                                                                    ARM if asserted. Interrupt status can be
                                                                    cleared by writing ones to the hif_pio_irq_raw
                                                                    register. To release IRQ for netX internal
                                                                    ARM without clearing                                       */
    
    struct {
      __IOM uint32_t irq_hif_d12 : 1;           /*!< [0..0] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ)                                    */
      __IOM uint32_t irq_hif_a16 : 1;           /*!< [1..1] HIF_A16 IRQ                                                        */
      __IOM uint32_t irq_hif_a17 : 1;           /*!< [2..2] HIF_A17 IRQ                                                        */
      __IOM uint32_t irq_hif_dirq : 1;          /*!< [3..3] HIF_DIRQ IRQ                                                       */
    } hif_pio_irq_arm_mask_reset_b;
  } ;
  
  union {
    __IM  uint32_t hif_pio_irq_arm_masked;      /*!< (@ 0x00000030) HIF PIO Masked Interrupt Status Register for
                                                                    netX internal ARM. If bit is set, if the
                                                                    according mask bit is set in hif_pio_irq_arm_mask-register
                                                                    and the according interrupt is asserted.
                                                                    IRQ for netX internal ARM signal is asserted
                                                                    if at least one bit is set here. Interrupt
                                                                    status can be cleared by writing ones to
                                                                    the hif_pio_irq_raw register. To release
                                                                    IRQ for netX internal ARM signal without
                                                                    clearing interrupt in module, reset according
                                                                    mask bit to 0. Note: Spikes up to 10ns will
                                                                    be suppre                                                  */
    
    struct {
      __IM  uint32_t irq_hif_d12 : 1;           /*!< [0..0] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ)                                    */
      __IM  uint32_t irq_hif_a16 : 1;           /*!< [1..1] HIF_A16 IRQ                                                        */
      __IM  uint32_t irq_hif_a17 : 1;           /*!< [2..2] HIF_A17 IRQ                                                        */
      __IM  uint32_t irq_hif_dirq : 1;          /*!< [3..3] HIF_DIRQ IRQ                                                       */
    } hif_pio_irq_arm_masked_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_irq_xpic_mask_set;   /*!< (@ 0x00000034) HIF PIO Interrupt Mask Register for netX internal
                                                                    xPIC. Write access with '1' sets interrupt
                                                                    mask bit (enables interrupt request for
                                                                    corresponding interrupt source). Write access
                                                                    with '0' does not influence this bit. Read
                                                                    access shows actual interrupt mask. If bit
                                                                    is set, the according interrupt will activate
                                                                    the IRQ for netX internal xPIC. Interrupt
                                                                    status can be cleared by writing ones to
                                                                    the hif_pio_irq_raw register. To release
                                                                    IRQ for netX internal xPIC without clearing
                                                                    interrupt in modu                                          */
    
    struct {
      __IOM uint32_t irq_hif_d12 : 1;           /*!< [0..0] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ)                                    */
      __IOM uint32_t irq_hif_a16 : 1;           /*!< [1..1] HIF_A16 IRQ                                                        */
      __IOM uint32_t irq_hif_a17 : 1;           /*!< [2..2] HIF_A17 IRQ                                                        */
      __IOM uint32_t irq_hif_dirq : 1;          /*!< [3..3] HIF_DIRQ IRQ                                                       */
    } hif_pio_irq_xpic_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t hif_pio_irq_xpic_mask_reset; /*!< (@ 0x00000038) HIF PIO Interrupt Mask Reset Register for netX
                                                                    internal xPIC. Write access with '1' resets
                                                                    interrupt mask bit (disables interrupt request
                                                                    for corresponding interrupt source). Write
                                                                    access with '0' does not influence this
                                                                    bit. Read access shows actual interrupt
                                                                    mask. If bit is set, the according interrupt
                                                                    will activate the IRQ for netX internal
                                                                    xPIC if asserted. Interrupt status can be
                                                                    cleared by writing ones to the hif_pio_irq_raw
                                                                    register. To release IRQ for netX internal
                                                                    xPIC without clear                                         */
    
    struct {
      __IOM uint32_t irq_hif_d12 : 1;           /*!< [0..0] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ)                                    */
      __IOM uint32_t irq_hif_a16 : 1;           /*!< [1..1] HIF_A16 IRQ                                                        */
      __IOM uint32_t irq_hif_a17 : 1;           /*!< [2..2] HIF_A17 IRQ                                                        */
      __IOM uint32_t irq_hif_dirq : 1;          /*!< [3..3] HIF_DIRQ IRQ                                                       */
    } hif_pio_irq_xpic_mask_reset_b;
  } ;
  
  union {
    __IM  uint32_t hif_pio_irq_xpic_masked;     /*!< (@ 0x0000003C) HIF PIO Masked Interrupt Status Register for
                                                                    netX internal xPIC. If bit is set, if the
                                                                    according mask bit is set in hif_pio_irq_xpic_mask-registe
                                                                    and the according interrupt is asserted.
                                                                    IRQ for netX internal xPIC signal is asserted
                                                                    if at least one bit is set here. Interrupt
                                                                    status can be cleared by writing ones to
                                                                    the hif_pio_irq_raw register. To release
                                                                    IRQ for netX internal xPIC signal without
                                                                    clearing interrupt in module, reset according
                                                                    mask bit to 0. Note: Spikes up to 10ns will
                                                                    be su                                                      */
    
    struct {
      __IM  uint32_t irq_hif_d12 : 1;           /*!< [0..0] HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ)                                    */
      __IM  uint32_t irq_hif_a16 : 1;           /*!< [1..1] HIF_A16 IRQ                                                        */
      __IM  uint32_t irq_hif_a17 : 1;           /*!< [2..2] HIF_A17 IRQ                                                        */
      __IM  uint32_t irq_hif_dirq : 1;          /*!< [3..3] HIF_DIRQ IRQ                                                       */
    } hif_pio_irq_xpic_masked_b;
  } ;
} hif_io_ctrl_Type;                             /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                     hif_asyncmem_ctrl                                     ================ */
/* =========================================================================================================================== */


/**
  * @brief hif_asyncmem_ctrl (hif_asyncmem_ctrl)
  */

typedef struct {                                /*!< (@ 0xFF401500) hif_asyncmem_ctrl Structure                                */
  
  union {
    __IOM uint32_t extsram0_ctrl;               /*!< (@ 0x00000000) Control Register for external bus interface and
                                                                    wait-states for chip-select 0 area. External
                                                                    addresses always be byte addresses. For
                                                                    additional byte-enables/DQM signals view
                                                                    netX pinout documentation. For all wait
                                                                    state configuration 1 cycle is 1 netx system
                                                                    clock cycle, i.e. 10ns for netX running
                                                                    on 100MHz at normal operation. Note: Pause
                                                                    and data width configuration is compatible
                                                                    to netx500/100 and netx50. Note: This register
                                                                    can be protected by the register MODULE_FIREWALL_CTRL.fire
                                                                    all_c                                                      */
    
    struct {
      __IOM uint32_t ws         : 6;            /*!< [5..0] Wait-States (0 - 63 cycles) of ExtMem0 area. During read
                                                     access nRD-signal active low phase is ws+1. During write
                                                     access nWR-signal active low phase is ws+1.. Address, chip-select
                                                     and byte-enable signals remain stable in this phase. After
                                                     ws wait-cycles have passed signals remain stable and final
                                                     data-access cycle is done. To match memory device data
                                                     access time tACC: program WS=ceil(tACC/10ns)-1.                           */
      __IOM uint32_t reserved0  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t p_pre      : 2;            /*!< [9..8] Pre-Pause (0 - 3 cycles) of ExtMem0 area. Additional
                                                     wait-states to match memory device setup times. If programmed
                                                     value is not 0, this Pre-Pause will be inserted at external
                                                     access start before Wait-State phase is started. Address,
                                                     chip-select and byte-enable signals will be stable in this
                                                     phase. but nRD-signal and nWR-signal remains inactive high.
                                                     Note: The Pre-Pause could be extended by 1 cycle under
                                                     certain conditions by netX memory controller. E.g. this
                                                     becomes necessary for some access sequences (e.g                          */
      __IOM uint32_t reserved1  : 6;            /*!< [15..10] reserved                                                         */
      __IOM uint32_t p_post     : 2;            /*!< [17..16] Post-Pause (0 - 3 cycles) of ExtMem0 area. Additional
                                                     wait-states to match memory device Output-Disable or Address-Hold
                                                     times. If programmed value is not 0, this Post-Pause will
                                                     be inserted at external access end after Wait-State phase
                                                     and data access cycle. Address, chip-select and byte-enable
                                                     signals will remain stable in this phase. but nRD-signal
                                                     and nWR-signal will become inactive high. After write access
                                                     netX memory controller will always insert at least 1 Post-Pause
                                                     cycle to generate positive edge o                                         */
      __IOM uint32_t reserved2  : 6;            /*!< [23..18] reserved                                                         */
      __IOM uint32_t dwidth     : 2;            /*!< [25..24] Data bus width of ExtMem0 area. 00 : 8bit memory device
                                                     connected to this chip-select address area. 01 : 16bit
                                                     memory device connected to this chip-select address area.
                                                     10 : reserved. 11 : memory is disabled, related chip-select
                                                     signal can be used for other purpose (e.g. as PIO). Note:
                                                     Chip-selects are disabled by default. However it could
                                                     be possible that they are enabled during netX boot phase
                                                     to search for boot device. View bootloader information
                                                     for this. Note: When chip-select is disabled related net                  */
      __IOM uint32_t reserved3  : 2;            /*!< [27..26] reserved                                                         */
      __IOM uint32_t no_p_pre_seq_rd : 1;       /*!< [28..28] No Pre-Pause insertion between sequential reads. 0:
                                                     Pre-Pause will be inserted after each read access. 1: Disable
                                                     Pre-Pause between sequential reads. Note: default setting
                                                     '0' is for netx100/50 compatibility only. Typically there
                                                     is no need of Pre-Pause insertion between sequential reads.               */
      __IOM uint32_t no_p_post_seq_rd : 1;      /*!< [29..29] No Post-Pause insertion between sequential reads. 0:
                                                     Post-Pause will be inserted after each read access. 1:
                                                     Disable Post-Pause between sequential reads. Note: Default
                                                     setting '0' is for netx100/50 compatibility only. Typically
                                                     there is no need of Post-Pause insertion between sequential
                                                     reads. A Post-Pause will always be inserted if the next
                                                     access addresses another chip-select area, is a write access
                                                     or is not predictable by the memory controller.                           */
      __IOM uint32_t static_cs  : 1;            /*!< [30..30] Static chip-select signal generation. 0: No static
                                                     chip-select signal generation 1: Static chip-select signal
                                                     generation enabled (e.g. for i80 displays). All chip-select
                                                     signals will return to inactive (high) level when no access
                                                     is performed by default (when this bit is not set). However
                                                     some devices (e.g. some i80 displays) require subsequent
                                                     access without chip-select becoming inactive in between.
                                                     For that purpose 'static_cs' bit can be set. Chip-select
                                                     will remain active once an access was performed to                        */
      __IOM uint32_t ready_en   : 1;            /*!< [31..31] Ready Signal Enable. 0: Access timing is only controlled
                                                     by Wait-State and Pre/Post-Pause configuration above. 1:
                                                     Use external ready input to stretch Wait-State phase. Wait-States
                                                     and Pre/Post-Pauses will be done according to configuration
                                                     above. However Wait-State phase can be extended by an external
                                                     device by holding netX ready input inactive. Data access
                                                     cycle is done after external device sets netX ready input
                                                     to active state. Note: An external device must assert ready
                                                     to inactive state while Wait-Stat                                         */
    } extsram0_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t extsram1_ctrl;               /*!< (@ 0x00000004) Control Register for external bus interface and
                                                                    wait-states for chip-select 1 area. For
                                                                    detailed register description view extsram0_ctrl
                                                                    register. Note: This register can be protected
                                                                    by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemct
                                                                    l.                                                         */
    
    struct {
      __IOM uint32_t ws         : 6;            /*!< [5..0] Wait-States (0 - 63 cycles) of ExtMem1 area.                       */
      __IOM uint32_t reserved0  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t p_pre      : 2;            /*!< [9..8] Pre-Pause (0 - 3 cycles) of ExtMem1 area.                          */
      __IOM uint32_t reserved1  : 6;            /*!< [15..10] reserved                                                         */
      __IOM uint32_t p_post     : 2;            /*!< [17..16] Post-Pause (0 - 3 cycles) of ExtMem1 area.                       */
      __IOM uint32_t reserved2  : 6;            /*!< [23..18] reserved                                                         */
      __IOM uint32_t dwidth     : 2;            /*!< [25..24] Data bus width of ExtMem1 area. Note: This chip-select
                                                     is disabled by default and may be shared with other functions.
                                                     View memory interface multiplex options for more information.             */
      __IOM uint32_t reserved3  : 2;            /*!< [27..26] reserved                                                         */
      __IOM uint32_t no_p_pre_seq_rd : 1;       /*!< [28..28] No Pre-Pause insertion between sequential reads.                 */
      __IOM uint32_t no_p_post_seq_rd : 1;      /*!< [29..29] No Post-Pause insertion between sequential reads.                */
      __IOM uint32_t static_cs  : 1;            /*!< [30..30] Static chip-select signal generation.                            */
      __IOM uint32_t ready_en   : 1;            /*!< [31..31] Ready Signal Enable.                                             */
    } extsram1_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t extsram2_ctrl;               /*!< (@ 0x00000008) Control Register for external bus interface and
                                                                    wait-states for chip-select 2 area. For
                                                                    detailed register description view extsram0_ctrl
                                                                    register. Note: This register can be protected
                                                                    by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemct
                                                                    l.                                                         */
    
    struct {
      __IOM uint32_t ws         : 6;            /*!< [5..0] Wait-States (0 - 63 cycles) of ExtMem2 area.                       */
      __IOM uint32_t reserved0  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t p_pre      : 2;            /*!< [9..8] Pre-Pause (0 - 3 cycles) of ExtMem2 area.                          */
      __IOM uint32_t reserved1  : 6;            /*!< [15..10] reserved                                                         */
      __IOM uint32_t p_post     : 2;            /*!< [17..16] Post-Pause (0 - 3 cycles) of ExtMem2 area.                       */
      __IOM uint32_t reserved2  : 6;            /*!< [23..18] reserved                                                         */
      __IOM uint32_t dwidth     : 2;            /*!< [25..24] Data bus width of ExtMem2 area. Note: This chip-select
                                                     is disabled by default and may be shared with other functions.
                                                     View memory interface multiplex options for more information.             */
      __IOM uint32_t reserved3  : 2;            /*!< [27..26] reserved                                                         */
      __IOM uint32_t no_p_pre_seq_rd : 1;       /*!< [28..28] No Pre-Pause insertion between sequential reads.                 */
      __IOM uint32_t no_p_post_seq_rd : 1;      /*!< [29..29] No Post-Pause insertion between sequential reads.                */
      __IOM uint32_t static_cs  : 1;            /*!< [30..30] Static chip-select signal generation.                            */
      __IOM uint32_t ready_en   : 1;            /*!< [31..31] Ready Signal Enable.                                             */
    } extsram2_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t extsram3_ctrl;               /*!< (@ 0x0000000C) Control Register for external bus interface and
                                                                    wait-states for ExtMem1 chip-select 3 area.
                                                                    For detailed register description view extsram0_ctrl
                                                                    register. Note: This register can be protected
                                                                    by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemct
                                                                    l.                                                         */
    
    struct {
      __IOM uint32_t ws         : 6;            /*!< [5..0] Wait-States (0 - 63 cycles) of ExtMem3 area.                       */
      __IOM uint32_t reserved0  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t p_pre      : 2;            /*!< [9..8] Pre-Pause (0 - 3 cycles) of ExtMem3 area.                          */
      __IOM uint32_t reserved1  : 6;            /*!< [15..10] reserved                                                         */
      __IOM uint32_t p_post     : 2;            /*!< [17..16] Post-Pause (0 - 3 cycles) of ExtMem3 area.                       */
      __IOM uint32_t reserved2  : 6;            /*!< [23..18] reserved                                                         */
      __IOM uint32_t dwidth     : 2;            /*!< [25..24] Data bus width of ExtMem3 area. Note: This chip-select
                                                     is disabled by default and may be shared with other functions.
                                                     View memory interface multiplex options for more information.             */
      __IOM uint32_t reserved3  : 2;            /*!< [27..26] reserved                                                         */
      __IOM uint32_t no_p_pre_seq_rd : 1;       /*!< [28..28] No Pre-Pause insertion between sequential reads.                 */
      __IOM uint32_t no_p_post_seq_rd : 1;      /*!< [29..29] No Post-Pause insertion between sequential reads.                */
      __IOM uint32_t static_cs  : 1;            /*!< [30..30] Static chip-select signal generation.                            */
      __IOM uint32_t ready_en   : 1;            /*!< [31..31] Ready Signal Enable.                                             */
    } extsram3_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ext_cs0_apm_ctrl;            /*!< (@ 0x00000010) Asynchronous Page Mode (APM) Control Register
                                                                    for ExtMem0 chip-select area. Only ExtMem0
                                                                    chip-select area supports fast Asynchronous-Page-Mode
                                                                    (APM) Access. Note: This register can be
                                                                    protected by the register MODULE_FIREWALL_CTRL.firewall_cf
                                                                    _hifmemctrl.                                               */
    
    struct {
      __IOM uint32_t ws_apm     : 4;            /*!< [3..0] APM read burst wait-states (0 - 15 cycles). If APM is
                                                     enabled by apm_cfg-bits, first read access is done with
                                                     number of wait-states programmed in extsram0_ctrl register.
                                                     Following read accesses to ExtMem0 chip-select area are
                                                     done with wait-states programmed here until APM-accesses
                                                     are terminated. If netX runs internal read bursts only
                                                     netX address lines will change. chip-select and nRD signals
                                                     will remain active low. APM accesses are terminated if
                                                     chip-select of ExtMem0 address area becomes inactive, if
                                                     w                                                                         */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t apm_cfg    : 3;            /*!< [10..8] APM configuration. 000 : read bursts are disabled 001
                                                     : 1 D-word (4 byte) address boundary for APM 010 : 2 D-word
                                                     (8 byte) address boundary for APM 011 : 4 D-word (16 byte)
                                                     address boundary for APM 100 : 8 D-word (32 byte) address
                                                     boundary for APM 101 : 16 D-word (64 byte) address boundary
                                                     for APM 110 : 32 D-word (128 byte) address boundary for
                                                     APM all other settings are reserved. APM burst length programming
                                                     is related to system address boundaries. For correct programming
                                                     device data width and page si                                             */
      __IOM uint32_t reserved1  : 21;           /*!< [31..11] reserved                                                         */
    } ext_cs0_apm_ctrl_b;
  } ;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t ext_rdy_cfg;                 /*!< (@ 0x00000020) External Memory Ready Control Register. Note:
                                                                    Timeout is generated if ready usage is enabled
                                                                    by the extsramX_ctrl registers and is not
                                                                    asserted to active state within 10us. Note:
                                                                    This register can be protected by the register
                                                                    MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl.              */
    
    struct {
      __IOM uint32_t rdy_act_level : 1;         /*!< [0..0] Ready Active Level 0: Ready is active low / stall access
                                                     while ready input is high. 1: Ready is active high / stall
                                                     access while ready input is low.                                          */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t rdy_filter : 2;            /*!< [5..4] Ready Input Filter. Ready input filtering is implemented
                                                     to avoid false ready active detection especially if ready
                                                     signal is not always driven and ready active state is realized
                                                     by pull-up or down resistors. 00: Ready active state is
                                                     detected after ready signal is sampled once in active state
                                                     (no filtering). 01: Ready active state is detected after
                                                     ready signal is consecutively sampled twice in active state.
                                                     10: Ready active state is detected after ready signal is
                                                     consecutively sampled 3 times in active st                                */
      __IOM uint32_t reserved1  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t rdy_to_irq_en : 1;         /*!< [8..8] Ready Timeout IRQ Enable 0: No IRQ generation in case
                                                     of ready timeout. 1: generate an IRQ in case of ready timeout.
                                                     Note: Ready Timeout IRQ is part of netX System Status IRQ
                                                     (view system_status register in area asic_ctrl and VIC
                                                     registers)                                                                */
      __IOM uint32_t reserved2  : 2;            /*!< [10..9] reserved                                                          */
      __IOM uint32_t rdy_to_dis : 1;            /*!< [11..11] Ready Timeout Disable By default ready timeout is enabled.
                                                     Timeout is generated if ready usage is enabled by the extsramX_ctrl
                                                     registers and is not asserted to active state within 10us
                                                     (1024 system clocks). If an external device requires even
                                                     longer response time, ready timeout can be disabled by
                                                     setting this bit. However be careful: If ready is not asserted
                                                     anytime, netX system will stall. Escape from this can only
                                                     be achieved by Hardware Reset (e.g. by system watchdog
                                                     timeout). 0: Ready timeout is enable                                      */
      __IOM uint32_t reserved3  : 20;           /*!< [31..12] reserved                                                         */
    } ext_rdy_cfg_b;
  } ;
  
  union {
    __IOM uint32_t ext_rdy_status;              /*!< (@ 0x00000024) External Memory Ready Status Register. Note:
                                                                    Timeout is generated if ready usage is enabled
                                                                    by the extsramX_ctrl registers and is not
                                                                    asserted to active state within 10us. Note:
                                                                    This register can be protected by the register
                                                                    MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl.              */
    
    struct {
      __IOM uint32_t rdy_to_err_adr : 27;       /*!< [26..0] Ready timeout error address logging.                              */
      __IOM uint32_t reserved0  : 1;            /*!< [27..27] reserved                                                         */
      __IOM uint32_t rdy_to_err_cs : 2;         /*!< [29..28] Ready timeout error chip-select logging.                         */
      __IOM uint32_t reserved1  : 1;            /*!< [30..30] reserved                                                         */
      __IOM uint32_t rdy_to_err : 1;            /*!< [31..31] Ready Timeout Error. This bit is set if a ready timeout
                                                     error is detected. The external address and chip-select
                                                     will be logged then in the lower bits of this register.
                                                     An IRQ/Abort will be generated if enabled by the ext_rdy_cfg
                                                     register. Writing a '1' here will reset this bit and the
                                                     IRQ. Note: If multiple timeouts are detected, the first
                                                     timeout address and chip-select will be logged. Note: Ready
                                                     Timeout IRQ is part of netX System Status IRQ (view system_status
                                                     register in area asic_ctrl and VIC register                               */
    } ext_rdy_status_b;
  } ;
} hif_asyncmem_ctrl_Type;                       /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                      hif_sdram_ctrl                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief hif_sdram_ctrl (hif_sdram_ctrl)
  */

typedef struct {                                /*!< (@ 0xFF401540) hif_sdram_ctrl Structure                                   */
  
  union {
    __IOM uint32_t sdram_general_ctrl;          /*!< (@ 0x00000000) Control Register for external SDRAM access. For
                                                                    initializing procedure netX SDRAM controller
                                                                    view description of 'ctrl_en' bit inside
                                                                    this register. Note: This register can be
                                                                    protected by the register MODULE_FIREWALL_CTRL.firewall_cf
                                                                    _hifmemctrl.                                               */
    
    struct {
      __IOM uint32_t banks      : 2;            /*!< [1..0] Number of SDRAM device banks and address lines. 00 :
                                                     2 banks, address (BA0) 01 : 4 banks, address lines (BA1,
                                                     BA0)(default) All others: reserved                                        */
      __IOM uint32_t reserved0  : 2;            /*!< [3..2] reserved                                                           */
      __IOM uint32_t rows       : 2;            /*!< [5..4] Number of SDRAM device rows and address lines. 00 : 2k
                                                     rows, address lines A0..A10 (default) 01 : 4k rows, address
                                                     lines A0..A11 10 : 8k rows, address lines A0..A12                         */
      __IOM uint32_t reserved1  : 2;            /*!< [7..6] reserved                                                           */
      __IOM uint32_t columns    : 3;            /*!< [10..8] Number of SDRAM device columns and address lines. 000
                                                     : 256 columns, address lines A0..A7 (default) 001 : 512
                                                     columns, address lines A0..A8 010 : 1k columns, address
                                                     lines A0..A9 011 : 2k columns, address lines A0..A9,A11
                                                     100 : 4k columns, address lines A0..A9,A11,A12 All others:
                                                     reserved                                                                  */
      __IOM uint32_t reserved2  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t dbus16     : 1;            /*!< [16..16] SDRAM data bus width 0 : SDRAM data bus is 8 bit wide
                                                     (default) 1 : SDRAM data bus is 16 bit wide                               */
      __IOM uint32_t sdram_pwdn : 1;            /*!< [17..17] SDRAM power down If this bit is set, the controller
                                                     will move SDRAM to power down self refresh mode (no data
                                                     loss) and stop the external SDRAM clock. Return from power-down
                                                     mode can be done by clearing this bit.                                    */
      __IOM uint32_t extclk_en  : 1;            /*!< [18..18] external SDRAM clock enable 0 : SDRAM clock disabled
                                                     (default) 1 : SDRAM clock enabled Note: The external SDRAM
                                                     clock will not run if the controller is disabled.                         */
      __IOM uint32_t ctrl_en    : 1;            /*!< [19..19] Global SDRAM controller enable. Note: The sdram_timing_ctrl
                                                     and the sdram_mr register can only be changed while this
                                                     bit is 0. Initializing and enabling SDRAM should be done
                                                     as follows: { | A. Special attention must be done before
                                                     enabling SDRAM after netX reset without power supply was
                                                     disabled (e.g. pressing some kind of reset button). In
                                                     this case a reset could be done while a SDRAM read burst
                                                     was performed. As SDRAM clock will be disabled immediately
                                                     in case of reset external SDRAM device will keep dr                       */
      __IOM uint32_t reserved3  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t refresh_mode : 2;          /*!< [25..24] Refresh request generation mode. Refresh behaviour
                                                     changed from netx100/500/50: SDRAM controller now has an
                                                     additional high priority refresh mode. Refresh generation
                                                     has lower priority than accesses on external memory interface
                                                     normally. That means refreshes do not block data access.
                                                     To avoid data loss under all conditions without checking
                                                     critical situations by software a high priority refresh
                                                     mode is implemented for netX10 and later: If there was
                                                     too much traffic to SDRAM to run refreshes according to
                                                     pr                                                                        */
      __IOM uint32_t reserved4  : 4;            /*!< [29..26] reserved                                                         */
      __IOM uint32_t sdram_ready : 1;           /*!< [30..30] SDRAM ready. This bit is set to 1 if SDRAM is ready
                                                     for access. If sdram_general_ctrl.ctrl_en == 0 or sdram_general_ctrl.sdra
                                                     _pwdn == 0 sdram_ready will be low. It will be set to 1
                                                     after SDRAM has been initialized or after power down wake
                                                     up. Note: This bit is a read only status flag.                            */
      __IOM uint32_t refresh_status : 1;        /*!< [31..31] Refresh status flag. Refresh behaviour changed from
                                                     netx100/500/50: SDRAM controller now has an additional
                                                     high priority refresh mode (view refresh_mode bit description).
                                                     There is no need to guarantee sufficient SDRAM refresh
                                                     generation by checking this bit by software any longer
                                                     (necessary for netx100/500/50 depending on application).
                                                     It is only for information purpose for netX10 or later.
                                                     This bit can be reset by writing '0' to it. Note: This
                                                     bit is writable but can also be changed by hardware.                      */
    } sdram_general_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t sdram_timing_ctrl;           /*!< (@ 0x00000004) Control Register for external SDRAM access. Changes
                                                                    can only be done, if the SDRAM controller
                                                                    is disabled (sdram_general_ctrl.ctrl_en
                                                                    == 0) to avoid configuration problems. Please
                                                                    view description of 'ctrl_en' bit inside
                                                                    sdram_general_ctrl register for initializing-procedure
                                                                    of netX SDRAM controller. Note: This register
                                                                    can be protected by the register MODULE_FIREWALL_CTRL.fire
                                                                    all_cfg_hifmemctrl. Note: For some registers
                                                                    the reset-value is a reserved value. I.e.
                                                                    these registers must be prog                               */
    
    struct {
      __IOM uint32_t t_RCD      : 2;            /*!< [1..0] ACTIVE to READ or WRITE time (RAS to CAS, clk = t_RCD)
                                                     This value will be also taken as t_RRD (ACTIVE bank A to
                                                     ACTIVE bank B time) 00 : 1 clk 01 : 2 clks 10 : 3 clks
                                                     (default) 11 : reserved                                                   */
      __IOM uint32_t reserved0  : 2;            /*!< [3..2] reserved                                                           */
      __IOM uint32_t t_WR       : 2;            /*!< [5..4] Write recovery time (last write data to PRECHARGE) 00
                                                     : 1 clk 01 : 2 clks 10 : 3 clks (default) 11 : reserved                   */
      __IOM uint32_t t_RP       : 2;            /*!< [7..6] Precharge command period time (PRECHARGE to next command)
                                                     00 : 1 clk 01 : 2 clks 10 : 3 clks (default) 11 : reserved
                                                     Note: For Active-to-Active-command-period (t_RC) view note
                                                     at t_RAS.                                                                 */
      __IOM uint32_t t_RAS      : 3;            /*!< [10..8] ACTIVE to PRECHARGE command time (clk = t_RAS + 3) 000
                                                     : 3 clks 001 : 4 clks and so on 111 : 10 clks (default)
                                                     Note: If Active-to-Active-command-period (t_RC) exceeds
                                                     t_RAS+t_RP, set t_RAS and t_RP in a way that the following
                                                     condition is met: t_RAS+t_RP&gt;=t_RC.                                    */
      __IOM uint32_t reserved1  : 1;            /*!< [11..11] reserved                                                         */
      __IOM uint32_t t_RFC      : 4;            /*!< [15..12] REFRESH to next command time (clk = tRFC + 4) 0000
                                                     : 4 clks 0001 : 5 clks and so on 1111 : 19 clks (default)                 */
      __IOM uint32_t t_REFI     : 2;            /*!< [17..16] Average periodic refresh interval (3.90 us * 2^t_REFI
                                                     00 : 3.90 us 01 : 7.80 us (default) 10 : 15.60 us 11 :
                                                     31.20 us Note: Typically refresh of SDRAM devices is specified
                                                     by a certain number of refreshes that must be performed
                                                     within a certain time. E.g. 8192 refreshes for 64ms. Dividing
                                                     the time by the number of refreshes leads to the average
                                                     periodic refresh interval. E.g. 64ms/8192 = 7.8us. Please
                                                     view also description of 'refresh_mode' of 'sdram_general_ctrl'
                                                     register for details.                                                     */
      __IOM uint32_t reserved2  : 2;            /*!< [19..18] reserved                                                         */
      __IOM uint32_t mem_sdclk_phase : 3;       /*!< [22..20] MEM_SDCLK phase shift. 0..5: adjustable phase-shift
                                                     for external SDRAM clock depending on external capacitive
                                                     load on MEM_SDCLK-signal to match SDRAM signals setup times.
                                                     The phase can be shifted in 1.25ns steps. MEM_SDCLK will
                                                     internally rise at the mem_sdclk_phase+1st clk400 edge
                                                     after internal changes of SDRAM signals (MEM_SD*-signals,
                                                     MI address and data buses driven by clk_memsig) For correct
                                                     settings delays depending on external capacitive load have
                                                     to be respected. Note: The phase shift logic was op                       */
      __IOM uint32_t reserved3  : 1;            /*!< [23..23] reserved                                                         */
      __IOM uint32_t data_sample_phase : 3;     /*!< [26..24] Data sample clock phase shift. 0..5: adjustable phase-shift
                                                     for data sampling SDRAM loopback clock (clk_sdloopback)
                                                     depending on external capacitive load and SDRAM access
                                                     time (t_AC). The phase can be shifted in 1.25ns steps.
                                                     clk_sdloopback will internally rise (sample SDRAM read
                                                     data) at the data_sample_phase+4th clk400 edge after rise
                                                     of external MEM_SDCLK (including external capacitive load).
                                                     For correct settings, the delays depending on external
                                                     capacitive have to be respected. Data sampling has to be
                                                                                                                               */
      __IOM uint32_t reserved4  : 1;            /*!< [27..27] reserved                                                         */
      __IOM uint32_t bypass_neg_delay : 1;      /*!< [28..28] Bypass data sample clock phase shift. 0: use phase
                                                     shifted (negative delayed) SDRAM loopback clock for data
                                                     sampling. 1: bypass phase shift logic for SDRAM data sampling.
                                                     Use SDRAM loopback clock for data sampling. Bypass must
                                                     be used for system clock frequencies &lt;= 80MHz (rate_mull_add
                                                     &lt;= 0xC0). If this bit is programmed with '0' by software
                                                     but system clock frequency is below 80MHz, it will be changed
                                                     to '1' to enable bypass automatically. When system frequency
                                                     is changed to a rate more than 80MHz,                                     */
      __IOM uint32_t reserved5  : 3;            /*!< [31..29] reserved                                                         */
    } sdram_timing_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t sdram_mr;                    /*!< (@ 0x00000008) Mode Register for SDRAM device. Changes can only
                                                                    be done, if the SDRAM controller is disabled
                                                                    (sdram_general_ctrl.ctrl_en == 0) to avoid
                                                                    configuration problems. The SDRAM Mode Registers
                                                                    of the used SDRAM device will be set after
                                                                    enabling the SDRAM controller in the 200us
                                                                    SDRAM memory initialisation procedure. It
                                                                    is part of the SDRAM device and programmed
                                                                    by the LOAD MODE REGISTER command. For details
                                                                    of SDRAM Mode Register view datasheet of
                                                                    used SDRAM device. Please view description
                                                                    of 'ctrl                                                   */
    
    struct {
      __IOM uint32_t MR         : 14;           /*!< [13..0] SDRAM Mode Register. CAS latency bits are typically
                                                     located in MR[6:4]. Only CL2 and CL3 are supported, not
                                                     CL1; default is CL3 Burst Length in MR[2:0] is read only
                                                     here. Burst length depends on data bus width programmed
                                                     in sdram_general_ctrl.dbus16 register bit The netX10 controller
                                                     supports only Burst Length 8 (default) for 8bit SDRAM interface
                                                     and 4 for 16bit SDRAM interface. Note: SDRAM devices where
                                                     burst length is not located in Mode Register bits MR[2:0]
                                                     are not supported by netX SDRAM controller. H                             */
    } sdram_mr_b;
  } ;
} hif_sdram_ctrl_Type;                          /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                   hifmem_priority_ctrl                                    ================ */
/* =========================================================================================================================== */


/**
  * @brief hifmem_priority_ctrl (hifmem_priority_ctrl)
  */

typedef struct {                                /*!< (@ 0xFF401580) hifmem_priority_ctrl Structure                             */
  
  union {
    __IOM uint32_t extmem_prio_timslot_ctrl;    /*!< (@ 0x00000000) Memory interface master timeslot priority control
                                                                    register. Note: Any master can access in
                                                                    one timeslot ((ts_accessrate_mX*ts_length_mX)/64)
                                                                    + 1 times (i.e. at maximum (ts_accessrate_mX)/64
                                                                    bandwidth on external memory bus, ts_accessrate_mX
                                                                    is programmed by extmem_prio_accesstime_ctrl-register).
                                                                    Priority control will watch data accesses
                                                                    on external memory data bus (SDRAM and non
                                                                    SDRAM), including pauses on non SDRAM-accesses,
                                                                    not including control commands to SDRAM.
                                                                    Any master requesting mor                                  */
    
    struct {
      __IOM uint32_t ts_length_arm_com_d : 3;   /*!< [2..0] 0..7: the timeslot of hifmem-master 0 is on external
                                                     memory interface 64*2^ts_length_arm_com_d systen clock
                                                     cycles                                                                    */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t ts_length_arm_com_i : 3;   /*!< [6..4] 0..7: the timeslot of hifmem-master 1 is on external
                                                     memory interface 64*2^ts_length_arm_com_i systen clock
                                                     cycles                                                                    */
      __IOM uint32_t reserved1  : 1;            /*!< [7..7] reserved                                                           */
      __IOM uint32_t ts_length_arm_app_d : 3;   /*!< [10..8] 0..7: the timeslot of hifmem-master 2 is on external
                                                     memory interface 64*2^ts_length_arm_app_d systen clock
                                                     cycles                                                                    */
      __IOM uint32_t reserved2  : 1;            /*!< [11..11] reserved                                                         */
      __IOM uint32_t ts_length_arm_app_i : 3;   /*!< [14..12] 0..7: the timeslot of hifmem-master 3 is on external
                                                     memory interface 64*2^ts_length_arm_app_i systen clock
                                                     cycles                                                                    */
      __IOM uint32_t reserved3  : 1;            /*!< [15..15] reserved                                                         */
      __IOM uint32_t ts_length_shared_mi : 3;   /*!< [18..16] 0..7: the timeslot of hifmem-master 4 is on external
                                                     memory interface 64*2^ts_length_shared_mi systen clock
                                                     cycles                                                                    */
      __IOM uint32_t reserved4  : 13;           /*!< [31..19] reserved                                                         */
    } extmem_prio_timslot_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t extmem_prio_accesstime_ctrl; /*!< (@ 0x00000004) Control Register for master channel accesses
                                                                    per timeslot on external meory interface.
                                                                    For detailed priority controlling read note
                                                                    at extmem_prio_timslot_ctrl-register description.
                                                                    --------------------------------------------------------
                                                                    For netX90 only SDRAM accesses are regarded
                                                                    for timeslot priority, SRAM/FLASH accesses
                                                                    are not. Note: This register can be protected
                                                                    by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemct
                                                                    l.                                                         */
    
    struct {
      __IOM uint32_t ts_accessrate_arm_com_d : 6;/*!< [5..0] 0..63: hifmem-master 0 is alowed to request ((ts_accessrate_arm_com_d*t
                                                     _length_arm_com_d)/64) + 1 accesses on external memory                    */
      __IOM uint32_t ts_accessrate_arm_com_i : 6;/*!< [11..6] 0..63: hifmem-master 1 is alowed to request ((ts_accessrate_arm_com_i*
                                                     s_length_arm_com_i)/64) + 1 accesses on external memory                   */
      __IOM uint32_t ts_accessrate_arm_app_d : 6;/*!< [17..12] 0..63: hifmem-master 2 is alowed to request ((ts_accessrate_arm_app_d
                                                     ts_length_arm_app_d)/64) + 1 accesses on external memory                  */
      __IOM uint32_t ts_accessrate_arm_app_i : 6;/*!< [23..18] 0..63: hifmem-master 3 is alowed to request ((ts_accessrate_arm_app_i
                                                     ts_length_arm_app_i)/64) + 1 accesses on external memory                  */
      __IOM uint32_t ts_accessrate_shared_mi : 6;/*!< [29..24] 0..63: hifmem-master 4 is alowed to request ((ts_accessrate_shared_mi
                                                     ts_length_shared_mi)/64) + 1 accesses on external memory                  */
    } extmem_prio_accesstime_ctrl_b;
  } ;
} hifmem_priority_ctrl_Type;                    /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                           abort                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief abort (abort)
  */

typedef struct {                                /*!< (@ 0xFF401600) abort Structure                                            */
  __IOM uint32_t  abort_base;                   /*!< (@ 0x00000000) Start-address of abort generating address area.
                                                                    Area size: 16Bytes Abort (AHB: HRESP=ERROR)
                                                                    will be generated by access to this area.
                                                                    Write access will be ignored. Read access
                                                                    returns 0xdeadbeef.                                        */
  __IM  uint32_t  RESERVED[2];
  __IOM uint32_t  abort_end;                    /*!< (@ 0x0000000C) End-address of abort generating address area.              */
} abort_Type;                                   /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            sqi                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief sqi (sqi)
  */

typedef struct {                                /*!< (@ 0xFF401640) sqi Structure                                              */
  
  union {
    __IOM uint32_t sqi_cr0;                     /*!< (@ 0x00000000) SQI control register 0 This register is compatible
                                                                    with the netX50 and netX10 SPI module, but
                                                                    some additional settings are possible. The
                                                                    SQI module provides master function only.
                                                                    Slave settings are omitted. The SQI module
                                                                    does not support the compatible mode for
                                                                    netX100.                                                   */
    
    struct {
      __IOM uint32_t datasize   : 4;            /*!< [3..0] Data size select for standard Motorola SPI mode This
                                                     bit field is unused in 2-bit and 4-bit SPI modes (i.e.
                                                     data size fixed to 8 bit). The actual transfer size is
                                                     'datasize' + 1 bit. { | 0000...0010: reserved 0011: 4 bit
                                                     0100: 5 bit ... 0111: 8 bit ... 1111: 16 bit }                            */
      __IOM uint32_t reserved0  : 2;            /*!< [5..4] reserved                                                           */
      __IOM uint32_t sck_pol    : 1;            /*!< [6..6] Serial clock polarity 0: idle: clock is low, first edge
                                                     is rising 1: idle: clock is high, first edge is falling
                                                     Note: sck_pol value equals bit 1 of SPI mode value (mode
                                                     = (sck_pol, sck_phase)).                                                  */
      __IOM uint32_t sck_phase  : 1;            /*!< [7..7] Serial clock phase 1: Sample data at second clock edge,
                                                     data is generated half a clock phase before sampling 0:
                                                     Sample data at first clock edge, data is generated half
                                                     a clock phase before sampling Note: sck_phase value equals
                                                     bit 0 of SPI mode value (mode = (sck_pol, sck_phase)).                    */
      __IOM uint32_t sck_muladd : 12;           /*!< [19..8] Serial clock rate multiply add value for sck generation
                                                     sck-frequency: f_sck = (sck_muladd * 100)/4096 [MHz]. Programmed
                                                     value of sck_muladd must be &lt;= 0x800. Default value
                                                     0x800 equals 50 MHz clock rate. Note: If sck_muladd is
                                                     set to zero, transfer will freeze. Note: SQIROM (XiP) serial
                                                     clock rate must be programmed in register 'sqi_sqirom_cfg'.               */
      __IOM uint32_t reserved1  : 2;            /*!< [21..20] reserved                                                         */
      __IOM uint32_t sio_cfg    : 2;            /*!< [23..22] SQI IO configuration Default: All additional SQI-IOs
                                                     (SIO2+3) are in PIO input mode. Coding 00: only SIO2+3
                                                     are controllable as PIOs (2-bit SPI or standard Motorola
                                                     SPI) 01: all SQI IOs are used for transfers (4-bit SPI/SQI)
                                                     10: reserved 11: all SQI IOs are controllable as PIOs                     */
      __IOM uint32_t reserved2  : 3;            /*!< [26..24] reserved                                                         */
      __IOM uint32_t filter_in  : 1;            /*!< [27..27] Input filtering Receive data is sampled every 10 ns
                                                     (100 MHz system clock). If this bit is set, the stored
                                                     receive value will be the result of a majority decision
                                                     of the three sampling points around an sck clock edge (if
                                                     two or more '1's have been sampled, a '1' will be stored.
                                                     If this bit is not set, a '0' will be stored). Input filtering
                                                     should be used for sck_muladd&lt;=0x200 (i.e. below 12.5
                                                     MHz). For higher frequencies, stable signal phases are
                                                     too short for filtering.                                                  */
      __IOM uint32_t reserved3  : 4;            /*!< [31..28] reserved                                                         */
    } sqi_cr0_b;
  } ;
  
  union {
    __IOM uint32_t sqi_cr1;                     /*!< (@ 0x00000004) SQI control register 1 This register is compatible
                                                                    with the netX50 and netX10 SPI module, but
                                                                    some additional settings are possible. The
                                                                    SQI module provides master function only.
                                                                    Slave settings are omitted.                                */
    
    struct {
      __IOM uint32_t reserved0  : 1;            /*!< [0..0] reserved                                                           */
      __IOM uint32_t sqi_en     : 1;            /*!< [1..1] SQI enable 0: Interface disabled 1: Interface enabled
                                                     Note: If you select the SQIROM/XiP function by bit 'enable'
                                                     of register 'sqi_sqirom_cfg' (see description of register
                                                     'sqi_sqirom_cfg'), the standard SQI/SPI function will not
                                                     be available.                                                             */
      __IOM uint32_t reserved1  : 6;            /*!< [7..2] reserved                                                           */
      __IOM uint32_t fss        : 3;            /*!< [10..8] Frame slave select Up to 3 devices can be assigned directly.
                                                     Up to 8 devices can be assigned if an external de-multiplexer
                                                     is used. This signal is active low, i.e. the bits will
                                                     be inverted before they are output to the SQI pins.                       */
      __IOM uint32_t fss_static : 1;            /*!< [11..11] SQI static chip select 0: Chip select will be generated
                                                     automatically at data frame begin/end according to fss
                                                     and datasize. 1: Chip select will be set statically according
                                                     to 'fss' bits (see below). If fss is set to static mode,
                                                     fss must be toggled manually after each data frame in Motorola
                                                     SPI mode when sck_phase is 0 for compatibility with the
                                                     specification! Note: This bit is used only in standard
                                                     Motorola SPI mode. For SQI modes, chip select is never
                                                     generated automatically.                                                  */
      __IOM uint32_t spi_trans_ctrl : 1;        /*!< [12..12] Transfer control for standard Motorola SPI (default:
                                                     disabled) This bit is used only for standard Motorola SPI
                                                     (bits 'mode' of register 'sqi_tcr') in full-duplex and
                                                     half-duplex mode. If this bit is set, SPI transfers will
                                                     be controlled by 'start_transfer' and 'transfer_size' of
                                                     register 'sqi_tcr'. If this bit is not set (default), SPI
                                                     transfers start immediately after transfer data has been
                                                     written to TX FIFO (this is compatible with the SPI module).
                                                     Settings of 'start_transfer' and 'transfer_size' of                       */
      __IOM uint32_t reserved2  : 3;            /*!< [15..13] reserved                                                         */
      __IOM uint32_t tx_fifo_wm : 4;            /*!< [19..16] Transmit FIFO watermark for IRQ generation                       */
      __IOM uint32_t tx_fifo_clr : 1;           /*!< [20..20] Transmit FIFO clear Writing '1' to this bit will clear
                                                     the transmit FIFO. The hardware will automatically reset
                                                     this bit. This bit is always '0' when read.                               */
      __IOM uint32_t reserved3  : 3;            /*!< [23..21] reserved                                                         */
      __IOM uint32_t rx_fifo_wm : 4;            /*!< [27..24] Receive FIFO watermark for IRQ generation If the receive
                                                     FIFO watermark IRQ is enabled (bit 'RXIM' is set in register
                                                     'sqi_irq_mask'), transfers will stop when the receive FIFO
                                                     runs full. Transfers will continue after the receive data
                                                     is read from the receive FIFO to avoid an overflow of the
                                                     receive FIFO. If the receive FIFO watermark IRQ is disabled
                                                     (bit 'RXIM' is not set in register 'sqi_irq_mask'), transfers
                                                     will not stop when the receive FIFO runs full. This may
                                                     cause an overflow of the receive FIF                                      */
      __IOM uint32_t rx_fifo_clr : 1;           /*!< [28..28] Receive FIFO clear Writing '1' to this bit will clear
                                                     the receive FIFO. The hardware will automatically reset
                                                     this bit. This bit is always '0' when read.                               */
      __IOM uint32_t reserved4  : 3;            /*!< [31..29] reserved                                                         */
    } sqi_cr1_b;
  } ;
  
  union {
    __IOM uint32_t sqi_dr;                      /*!< (@ 0x00000008) SQI data register (DR) Read access: Received
                                                                    data word is delivered from receive FIFO.
                                                                    Write access: Data word to be sent is written
                                                                    to send FIFO. Receive and transmit FIFO
                                                                    both have a depth of 16 words (standard
                                                                    SPI mode). The SQI mode combines both FIFOs,
                                                                    i.e. 64 bytes are available.                               */
    
    struct {
      __IOM uint32_t data       : 32;           /*!< [31..0] Transmit data The data must be right-aligned during
                                                     writing. In Standard SPI mode only bits according to sqi_cr0.datasize
                                                     are transferred. In SQI mode data must be written in full
                                                     DWords (i.e. the software has to collect four bytes prior
                                                     to writing). Unused bytes will not be transferred and may
                                                     be padded at will (number of transferred bytes depends
                                                     on sqi_tcr.transfer_size). Receive data will always be
                                                     right-aligned; unused bits will be '0'.                                   */
    } sqi_dr_b;
  } ;
  
  union {
    __IM  uint32_t sqi_sr;                      /*!< (@ 0x0000000C) Read-only SQI status register Shows the current
                                                                    status of the SQI interface.                               */
    
    struct {
      __IM  uint32_t tx_fifo_empty : 1;         /*!< [0..0] Transmit FIFO is empty (1 if empty).                               */
      __IM  uint32_t tx_fifo_not_full : 1;      /*!< [1..1] Transmit FIFO is not full (0 if full).                             */
      __IM  uint32_t rx_fifo_not_empty : 1;     /*!< [2..2] Receive FIFO is not empty (0 if empty).                            */
      __IM  uint32_t rx_fifo_full : 1;          /*!< [3..3] Receive FIFO is full (1 if full).                                  */
      __IM  uint32_t busy       : 1;            /*!< [4..4] Device is busy 1 if data is currently transmitted/received
                                                     or the transmit FIFO is not empty.                                        */
      __IM  uint32_t reserved0  : 8;            /*!< [12..5] reserved                                                          */
      __IM  uint32_t sqirom_timeout_err : 1;    /*!< [13..13] Timeout during a read of the SQIROM area has occurred.
                                                     A timeout results from a fix level of the netX serial clock
                                                     IO. Check IO multiplexing configuration and make sure that
                                                     the serial clock output is not externally clamped. This
                                                     bit can be used to determine why the IRQ 'sqirom_error'
                                                     has occurred. Clearing this status flag is possible only
                                                     by writing a '1' here. The SQIROM function must be disabled
                                                     and enabled again to reset module-internal state machines
                                                     after this bit has been set (register 'sqirom_c                           */
      __IM  uint32_t sqirom_write_err : 1;      /*!< [14..14] Write access to the read-only SQIROM area has occurred.
                                                     This bit can be used to determine why the IRQ 'sqirom_error'
                                                     has occurred. Clearing this status flag is possible only
                                                     by writing a '1' here.                                                    */
      __IM  uint32_t sqirom_disabled_err : 1;   /*!< [15..15] Access to the disabled SQIROM area has occurred. To
                                                     enable the SQIROM function, set bit 'enable' in register
                                                     'sqi_sqirom_cfg'. This bit can be used to determine why
                                                     the IRQ 'sqirom_error' has occurred. Clearing this status
                                                     flag is possible only by writing a '1' here.                              */
      __IM  uint32_t tx_fifo_level : 5;         /*!< [20..16] Transmit FIFO level (number of words to be transmitted
                                                     are left in the FIFO).                                                    */
      __IM  uint32_t reserved1  : 1;            /*!< [21..21] reserved                                                         */
      __IM  uint32_t tx_fifo_err_ovfl : 1;      /*!< [22..22] Transmit FIFO overflow error occurred, data is lost.
                                                     To clear this status flag, clear TX FIFO (register 'sqi_cr1').            */
      __IM  uint32_t tx_fifo_err_undr : 1;      /*!< [23..23] Transmit FIFO underrun error has occurred, unexpected
                                                     data has been sent. To clear this status flag, clear TX
                                                     FIFO (register 'sqi_cr1').                                                */
      __IM  uint32_t rx_fifo_level : 5;         /*!< [28..24] Receive FIFO level (number of received words to be
                                                     read from the FIFO).                                                      */
      __IM  uint32_t reserved2  : 1;            /*!< [29..29] reserved                                                         */
      __IM  uint32_t rx_fifo_err_ovfl : 1;      /*!< [30..30] Receive FIFO overflow error occurred, data is lost.
                                                     To clear this status flag, clear RX FIFO (register 'sqi_cr1').            */
      __IM  uint32_t rx_fifo_err_undr : 1;      /*!< [31..31] Receive FIFO underrun error has occurred, unexpected
                                                     data has been read. To clear this status flag, clear RX
                                                     FIFO (register 'sqi_cr1').                                                */
    } sqi_sr_b;
  } ;
  
  union {
    __IOM uint32_t sqi_tcr;                     /*!< (@ 0x00000010) SQI transfer control This register must not be
                                                                    changed during a transfer (bit 'busy' of
                                                                    register 'sqi_sr' is '1') to avoid corrupted
                                                                    transfers causing damage to the hardware.
                                                                    Module address offset 0x10 is reserved in
                                                                    the netX10/50 SPI module. Thus, no compatibility
                                                                    problems will result from using this address
                                                                    for extended transfer control features.                    */
    
    struct {
      __IOM uint32_t transfer_size : 19;        /*!< [18..0] Number of bytes within the current SQI transaction Program
                                                     (number of bytes - 1) or (number of dummy clock cycles
                                                     - 1). Example: { | 0x00000: one byte/dummy cycle ... 0x7ffff:
                                                     512k bytes/dummy cycles } This bit field counts down during
                                                     transfers with each transferred word/byte or dummy cycle.
                                                     This bit field is writable only after a transfer sequence
                                                     is finished or if it has been terminated by a FIFO clear.
                                                     Hence, this bit is writable, but it can also be changed
                                                     by hardware. A running transfer sequ                                      */
      __IOM uint32_t reserved0  : 2;            /*!< [20..19] reserved                                                         */
      __IOM uint32_t tx_out     : 1;            /*!< [21..21] Output level in dummy or standard SPI receive-only
                                                     mode This bit selects the output level when the output
                                                     driver is enabled in the dummy mode.                                      */
      __IOM uint32_t tx_oe      : 1;            /*!< [22..22] Output driver enable in dummy or standard SPI receive-only
                                                     mode Writing a '1' enables the output drivers of the data
                                                     pins in the dummy mode.                                                   */
      __IOM uint32_t start_transfer : 1;        /*!< [23..23] Transfer start signal Writing a '1' starts the transfer
                                                     of transfer_size bytes or dummy cycles. The hardware will
                                                     automatically reset this bit. This bit is always '0' when
                                                     read. This bit is writable only after a transfer sequence
                                                     is finished or if it has been terminated by a FIFO clear.
                                                     Note: A transfer sequence is finished completely when 'busy'
                                                     of register 'sqi_sr' is not set. Note: In standard Motorola
                                                     SPI mode, this function can be controlled by bit 'spi_trans_ctrl'
                                                     of register 'sqi_cr1' (for SPI mo                                         */
      __IOM uint32_t mode       : 2;            /*!< [25..24] SPI/SQI mode selection 00: Standard Motorola SPI mode.
                                                     01: 2-bit SPI mode 10: 4-bit SPI mode 11: reserved                        */
      __IOM uint32_t duplex     : 2;            /*!< [27..26] Transfer type selection Default is '11' for standard
                                                     SPI compatibility. 00: dummy Generates 'transfer_size'
                                                     + 1 serial clock periods. No change of RX and TX FIFOs.
                                                     Data lines (standard Motorola SPI mode: SPI_MOSI) are controlled
                                                     by 'tx_oe' and 'tx_out'. 01: half-duplex receive Receives
                                                     'transfer_size' + 1 words. In 2-bit and 4-bit mode, TX-FIFO
                                                     will be cleared and is not available during receive. In
                                                     standard SPI mode, SPI_MOSI is controlled by 'tx_oe' and
                                                     'tx_out'. You need not fill the TX-FIFO with dummy                        */
      __IOM uint32_t ms_bit_first : 1;          /*!< [28..28] Most significant bit first 2- and 4-bit mode: Writing
                                                     '1' to this bit will transfer most significant bit first
                                                     (default). In standard Motorola SPI mode this bit is ignored.             */
      __IOM uint32_t ms_byte_first : 1;         /*!< [29..29] Most significant byte first 2- and 4-bit mode: Writing
                                                     '1' to this bit will use most significant byte first in
                                                     DWords (big endian). Default is little endian In standard
                                                     Motorola SPI mode this bit is ignored.                                    */
      __IOM uint32_t reserved1  : 2;            /*!< [31..30] reserved                                                         */
    } sqi_tcr_b;
  } ;
  
  union {
    __IOM uint32_t sqi_irq_mask;                /*!< (@ 0x00000014) SQI interrupt mask register: IRQ mask is an AND-mask:
                                                                    Only raw interrupts with mask bit set can
                                                                    generate a module IRQ to CPU. For detailed
                                                                    IRQ behavior and function, see register
                                                                    'sqi_irq_raw'. The functionality of this
                                                                    register is similar to that of the corresponding
                                                                    SPI register spi_imsc. In contrast to this
                                                                    register, setting bits in spi_imsc also
                                                                    clears the corresponding raw interrupts.                   */
    
    struct {
      __IOM uint32_t RORIM      : 1;            /*!< [0..0] Receive FIFO overrun interrupt mask                                */
      __IOM uint32_t RTIM       : 1;            /*!< [1..1] Receive timeout interrupt mask                                     */
      __IOM uint32_t RXIM       : 1;            /*!< [2..2] Receive FIFO interrupt mask                                        */
      __IOM uint32_t TXIM       : 1;            /*!< [3..3] Transmit FIFO interrupt mask                                       */
      __IOM uint32_t rxneim     : 1;            /*!< [4..4] Receive FIFO not empty interrupt mask (for compatibility
                                                     with netx100/500)                                                         */
      __IOM uint32_t rxfim      : 1;            /*!< [5..5] Receive FIFO full interrupt mask (for compatibility with
                                                     netx100/500)                                                              */
      __IOM uint32_t txeim      : 1;            /*!< [6..6] Transmit FIFO empty interrupt mask (for compatibility
                                                     with netx100/500)                                                         */
      __IOM uint32_t trans_end  : 1;            /*!< [7..7] Transfer end interrupt mask                                        */
      __IOM uint32_t sqirom_error : 1;          /*!< [8..8] SQIROM error interrupt mask                                        */
    } sqi_irq_mask_b;
  } ;
  
  union {
    __IOM uint32_t sqi_irq_raw;                 /*!< (@ 0x00000018) SQI interrupt state before masking register (raw
                                                                    interrupt). Writing a '1' to a bit clears
                                                                    this interrupt. IRQ flags can also be cleared
                                                                    by using 'sqi_irq_clear' for SPI module
                                                                    compatibility.                                             */
    
    struct {
      __IOM uint32_t RORRIS     : 1;            /*!< [0..0] Unmasked receive FIFO overrun interrupt state 1: receive
                                                     FIFO overrun error occurred 0: no receive FIFO overrun
                                                     error occurred                                                            */
      __IOM uint32_t RTRIS      : 1;            /*!< [1..1] Unmasked receive timeout interrupt state Timeout period
                                                     is 32 serial clock periods (depending on adr_sqi_cr0.sck_muladd).
                                                     1: receive FIFO is not empty and has not been read out
                                                     during the timeout period 0: receive FIFO is empty or read
                                                     during the last timeout period                                            */
      __IOM uint32_t RXRIS      : 1;            /*!< [2..2] Unmasked receive FIFO interrupt state 1: receive FIFO
                                                     is higher than sqi_cr1.rx_fifo_wm 0: receive FIFO is equal
                                                     or below sqi_cr1.rx_fifo_wm Note: Before programming this
                                                     IRQ, see description of bits 'spi_trans_ctrl' and 'rx_fifo_wm'
                                                     of register 'sqi_cr1' for receive FIFO behavior.                          */
      __IOM uint32_t TXRIS      : 1;            /*!< [3..3] Unmasked transmit FIFO interrupt state 1: transmit FIFO
                                                     level is below sqi_cr1.tx_fifo_wm 0: transmit FIFO is equal
                                                     or higher than sqi_cr1.tx_fifo_wm                                         */
      __IOM uint32_t rxneris    : 1;            /*!< [4..4] Unmasked receive FIFO not empty interrupt state (for
                                                     compatibility with netx100/500) 1: receive FIFO is not
                                                     empty 0: receive FIFO is empty                                            */
      __IOM uint32_t rxfris     : 1;            /*!< [5..5] Unmasked receive FIFO full interrupt state (for compatibility
                                                     with netx100/500) 1: receive FIFO is full 0: receive FIFO
                                                     is not full                                                               */
      __IOM uint32_t txeris     : 1;            /*!< [6..6] Unmasked transmit FIFO empty interrupt state (for compatibility
                                                     with netx100/500) 1: transmit FIFO is empty 0: transmit
                                                     FIFO is not empty                                                         */
      __IOM uint32_t trans_end  : 1;            /*!< [7..7] Unmasked transfer end interrupt state (related to bit
                                                     'busy' of register 'sqi_sr') 1: transfer finished. Bit
                                                     'busy' of register 'sqi_sr' has become inactive. 0: transfer
                                                     not finished. Bit 'busy' of register 'sqi_sr' is active.                  */
      __IOM uint32_t sqirom_error : 1;          /*!< [8..8] Unmasked SQIROM error interrupt state 1: SQIROM access
                                                     error detected. This IRQ will be set if an error occurs
                                                     during an SQIROM access. For detailed information on the
                                                     error, see SQIROM error bits in register 'sqi_sr'. For
                                                     error handling, clear this IRQ bit and the bits of register
                                                     'sqi_sr'. 0: no SQIROM error detected.                                    */
    } sqi_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t sqi_irq_masked;              /*!< (@ 0x0000001C) SQI masked interrupt status register For detailed
                                                                    IRQ behavior and function, see register
                                                                    'sqi_irq_raw'.                                             */
    
    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< [0..0] Masked receive FIFO overrun interrupt state                        */
      __IM  uint32_t RTMIS      : 1;            /*!< [1..1] Masked receive timeout interrupt state                             */
      __IM  uint32_t RXMIS      : 1;            /*!< [2..2] Masked receive FIFO interrupt state                                */
      __IM  uint32_t TXMIS      : 1;            /*!< [3..3] Masked transmit FIFO interrupt state                               */
      __IM  uint32_t rxnemis    : 1;            /*!< [4..4] Masked receive FIFO not empty interrupt state (for compatibility
                                                     with netx100/500)                                                         */
      __IM  uint32_t rxfmis     : 1;            /*!< [5..5] Masked receive FIFO full interrupt state (for compatibility
                                                     with netx100/500)                                                         */
      __IM  uint32_t txemis     : 1;            /*!< [6..6] Masked transmit FIFO empty interrupt state (for compatibility
                                                     with netx100/500)                                                         */
      __IM  uint32_t trans_end  : 1;            /*!< [7..7] Masked transfer end interrupt state                                */
      __IM  uint32_t sqirom_error : 1;          /*!< [8..8] Masked SQIROM error interrupt state                                */
    } sqi_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t sqi_irq_clear;               /*!< (@ 0x00000020) SQI interrupt clear register (for compatibility
                                                                    with netX10/50 SPI module). This register
                                                                    is always '0' on read. IRQ flags can also
                                                                    be cleared by writing register 'sqi_irq_raw'.              */
    
    struct {
      __IOM uint32_t RORIC      : 1;            /*!< [0..0] Clear receive FIFO overrun interrupt                               */
      __IOM uint32_t RTIC       : 1;            /*!< [1..1] Clear receive timeout interrupt                                    */
      __IOM uint32_t RXIC       : 1;            /*!< [2..2] Clear receive FIFO interrupt                                       */
      __IOM uint32_t TXIC       : 1;            /*!< [3..3] Clear transmit FIFO interrupt                                      */
      __IOM uint32_t rxneic     : 1;            /*!< [4..4] Clear receive FIFO not empty interrupt (for compatibility
                                                     with netx100/500)                                                         */
      __IOM uint32_t rxfic      : 1;            /*!< [5..5] Clear receive FIFO full interrupt (for compatibility
                                                     with netx100/500)                                                         */
      __IOM uint32_t txeic      : 1;            /*!< [6..6] Clear transmit FIFO empty interrupt (for compatibility
                                                     with netx100/500)                                                         */
      __IOM uint32_t trans_end  : 1;            /*!< [7..7] Clear transfer end interrupt                                       */
      __IOM uint32_t sqirom_error : 1;          /*!< [8..8] Clear SQIROM error interrupt                                       */
    } sqi_irq_clear_b;
  } ;
  
  union {
    __IOM uint32_t sqi_dmacr;                   /*!< (@ 0x00000024) SQI DMA control register This module generates
                                                                    normal transfer requests only (i.e. no last
                                                                    requests will be issued). In consequence,
                                                                    you can use DMAC-controlled transfers only
                                                                    (no peripheral-controlled mode).                           */
    
    struct {
      __IOM uint32_t rx_dma_en  : 1;            /*!< [0..0] Enable DMA for SQI-receive data A request will be generated
                                                     if RX-FIFO is not empty and sqi_cr1.sqi_en (module enable)
                                                     is set. If the RX-FIFO contains at least 4 words, there
                                                     will be a burst request to the DMAC. Set dmac_chctrl.SBSize
                                                     = 1 (i.e. burst size: 4) in the DMAC module. If this bit
                                                     is reset or the module is disabled, DMA request will also
                                                     be reset.                                                                 */
      __IOM uint32_t tx_dma_en  : 1;            /*!< [1..1] Enable DMA for SQI-transmit data A request will be generated
                                                     if TX-FIFO is not full and sqi_cr1.sqi_en (module enable)
                                                     is set. If at least 4 words are writable to the TX-FIFO,
                                                     there will be a burst request to the DMAC. Set dmac_chctrl.DBSize
                                                     = 1 (i.e. burst size: 4) in the DMAC module. If this bit
                                                     is reset or the module is disabled, DMA request will also
                                                     be reset.                                                                 */
    } sqi_dmacr_b;
  } ;
  
  union {
    __IOM uint32_t sqi_pio_out;                 /*!< (@ 0x00000028) SQI PIO output level control register Bits 'sio_cfg'
                                                                    of register 'sqi_cr0' control the IO PIO
                                                                    mode. Bit 'sqi_en' of register 'sqi_cr0'
                                                                    has to be set to drive the SQI IOs in the
                                                                    PIO mode. PIO input signal states are never
                                                                    filtered (bit 'filter_in' of register 'sqi_cr0').          */
    
    struct {
      __IOM uint32_t sclk       : 1;            /*!< [0..0] Serial SPI clock output state                                      */
      __IOM uint32_t csn        : 3;            /*!< [3..1] Chip select/FSS output state {CS2, CS1, CS0}                       */
      __IOM uint32_t mosi       : 1;            /*!< [4..4] MOSI/SIO0 output state                                             */
      __IOM uint32_t miso       : 1;            /*!< [5..5] MISO/SIO1 output state                                             */
      __IOM uint32_t sio2       : 1;            /*!< [6..6] SIO2 output state                                                  */
      __IOM uint32_t sio3       : 1;            /*!< [7..7] SIO3 output state                                                  */
    } sqi_pio_out_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t sqi_pio_oe;                  /*!< (@ 0x00000030) SQI PIO output enable control register Bits 'sio_cfg'
                                                                    of register 'sqi_cr0' control the IO PIO
                                                                    mode. Bit 'sqi_en' of register 'sqi_cr0'
                                                                    has to be set to drive the SQI IOs in the
                                                                    PIO mode.                                                  */
    
    struct {
      __IOM uint32_t sclk       : 1;            /*!< [0..0] Serial SPI clock output enable                                     */
      __IOM uint32_t csn        : 3;            /*!< [3..1] Chip select/FSS output enable {CS2, CS1, CS0}                      */
      __IOM uint32_t mosi       : 1;            /*!< [4..4] MOSI/SIO0 output enable                                            */
      __IOM uint32_t miso       : 1;            /*!< [5..5] MISO/SIO1 output enable                                            */
      __IOM uint32_t sio2       : 1;            /*!< [6..6] SIO2 output enable                                                 */
      __IOM uint32_t sio3       : 1;            /*!< [7..7] SIO3 output enable                                                 */
    } sqi_pio_oe_b;
  } ;
  
  union {
    __IM  uint32_t sqi_pio_in;                  /*!< (@ 0x00000034) SQI PIO input status register Bits 'sio_cfg'
                                                                    of register 'sqi_cr0' control the IO PIO
                                                                    mode.                                                      */
    
    struct {
      __IM  uint32_t sclk       : 1;            /*!< [0..0] Serial SPI clock input state                                       */
      __IM  uint32_t csn        : 3;            /*!< [3..1] Chip select/FSS input state {CS2, CS1, CS0}                        */
      __IM  uint32_t mosi       : 1;            /*!< [4..4] MOSI/SIO0 input state                                              */
      __IM  uint32_t miso       : 1;            /*!< [5..5] MISO/SIO1 input state                                              */
      __IM  uint32_t sio2       : 1;            /*!< [6..6] SIO2 input state                                                   */
      __IM  uint32_t sio3       : 1;            /*!< [7..7] SIO3 input state                                                   */
    } sqi_pio_in_b;
  } ;
  
  union {
    __IOM uint32_t sqi_sqirom_cfg;              /*!< (@ 0x00000038) SQIROM mode configuration This mode supports
                                                                    the 'eXecute in Place' (XiP) feature of
                                                                    SQI flash chips. This register serves to
                                                                    configure the position of command byte and
                                                                    address nibbles as well as the number of
                                                                    address nibbles and dummy cycles. To support
                                                                    a wide range of frequencies for the serial
                                                                    clock output, you can also change the clock
                                                                    divider. Notes: 1. Before enabling this
                                                                    mode, make sure that the SQI flash chip
                                                                    is in 4-bit command mode, otherwise the
                                                                    module is not able to fetch data                           */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] Enables the SQIROM mode of the SQI module. The SQI chip
                                                     needs to be initialized to accept 4-bit read-command before
                                                     you activate the SQIROM mode. This bit is also used to
                                                     switch between the SQIROM/XiP and the standard SQI/SPI
                                                     function. If this bit is set, the standard SQI/SPI function
                                                     is not available. The SQIROM/XiP function does not depend
                                                     on the programmed value of bit 'sqi_en' of register 'sqi_cr1'.
                                                     If the multiplex matrix provides the SQI function, it is
                                                     available only in standard SQI/SPI, but not                               */
      __IOM uint32_t addr_before_cmd : 1;       /*!< [1..1] Address before command When set to '1', the address nibbles
                                                     will be transferred before the command byte. Otherwise,
                                                     the command will be transferred first (default).                          */
      __IOM uint32_t addr_nibbles : 2;          /*!< [3..2] The number of nibbles to be transferred as the address
                                                     to the SQI chip. This setting depends on the command format
                                                     of the SQI chip. Bit 'addr_before_cmd' controls the address
                                                     command order. The most significant address bits will be
                                                     transmitted in the first address nibble. The least significant
                                                     address bits will be transmitted in the last address nibble.
                                                     00: 5 nibbles 01: 6 nibbles (default) 10: 7 nibbles 11:
                                                     8 nibbles                                                                 */
      __IOM uint32_t addr_bits  : 3;            /*!< [6..4] The number of address bits of the access address considered
                                                     to generate the address for the SQI chip. This setting
                                                     depends on the size of the SQI chip. { | 000: 20 bits (1-MByte/8-MBit
                                                     device) (default) 001: 21 bits (2-MByte/16-MBit device)
                                                     010: 22 bits (4-MByte/32-MBit device) 011: 23 bits (8-MByte/64-MBit
                                                     device) 100: 24 bits (16-MByte/128-MBit device) 101: 25
                                                     bits (32-MByte/256-MBit device) 110: 26 bits (64-MByte/512-MBit
                                                     device) 111: reserved }                                                   */
      __IOM uint32_t reserved0  : 1;            /*!< [7..7] reserved                                                           */
      __IOM uint32_t cmd_byte   : 8;            /*!< [15..8] This byte is transferred to the SQI chip as the command
                                                     sequence. Bit 'addr_before_cmd' controls the address command
                                                     order.                                                                    */
      __IOM uint32_t dummy_cycles : 4;          /*!< [19..16] Selects the number of dummy cycles before data will
                                                     be sampled from the SQI chip. { | 0000: 0 cycles 0001:
                                                     1 cycle 0010: 2 cycles (default) ... 1111: 15 cycles }                    */
      __IOM uint32_t t_csh      : 2;            /*!< [21..20] Min. SQI chip select high (idle) time: (t_csh+1) *
                                                     t_sck (according to clk_div_val). Programmable values are
                                                     0 to 3. Change this parameter if the SQI device used requires
                                                     min. chip select high times exceeding 1 serial clock period.
                                                     The data sheet of the SQI device used provides the required
                                                     timing. Note: Serial clock will not toggle if the device
                                                     is not selected. Hence, only chip select active timing
                                                     has to be considered.                                                     */
      __IOM uint32_t reserved1  : 2;            /*!< [23..22] reserved                                                         */
      __IOM uint32_t clk_div_val : 8;           /*!< [31..24] clk400 will be divided by (clk_div_val+3) for sqirom_clk
                                                     generation. Default setting '2' is 80 MHz. Maximum serial
                                                     clock rate (programming '0') is 133 MHz. Serial clock period
                                                     (t_sck) will be (clk_div_val+3) * 2.5 ns. Clock high and
                                                     low phase will be generated symmetrically.                                */
    } sqi_sqirom_cfg_b;
  } ;
} sqi_Type;                                     /*!< Size = 60 (0x3c)                                                          */



/* =========================================================================================================================== */
/* ================                                    sample_at_porn_stat                                    ================ */
/* =========================================================================================================================== */


/**
  * @brief sample_at_porn_stat (sample_at_porn_stat)
  */

typedef struct {                                /*!< (@ 0xFF401680) sample_at_porn_stat Structure                              */
  
  union {
    __IM  uint32_t sample_at_porn_stat_in0;     /*!< (@ 0x00000000) Status of inputs sampled at power-on-reset (PORn)
                                                                    register 0. This register shows the status
                                                                    of the inputs sampled at power-on-reset.
                                                                    It will not change on normal system reset.                 */
    
    struct {
      __IM  uint32_t hif_d0     : 1;            /*!< [0..0] Input status of pin 'hif_d0' sampled at power-on-reset             */
      __IM  uint32_t hif_d1     : 1;            /*!< [1..1] Input status of pin 'hif_d1' sampled at power-on-reset             */
      __IM  uint32_t hif_d2     : 1;            /*!< [2..2] Input status of pin 'hif_d2' sampled at power-on-reset             */
      __IM  uint32_t hif_d3     : 1;            /*!< [3..3] Input status of pin 'hif_d3' sampled at power-on-reset             */
      __IM  uint32_t hif_d4     : 1;            /*!< [4..4] Input status of pin 'hif_d4' sampled at power-on-reset             */
      __IM  uint32_t hif_d5     : 1;            /*!< [5..5] Input status of pin 'hif_d5' sampled at power-on-reset             */
      __IM  uint32_t hif_d6     : 1;            /*!< [6..6] Input status of pin 'hif_d6' sampled at power-on-reset             */
      __IM  uint32_t hif_d7     : 1;            /*!< [7..7] Input status of pin 'hif_d7' sampled at power-on-reset             */
      __IM  uint32_t hif_d8     : 1;            /*!< [8..8] Input status of pin 'hif_d8' sampled at power-on-reset             */
      __IM  uint32_t hif_d9     : 1;            /*!< [9..9] Input status of pin 'hif_d9' sampled at power-on-reset             */
      __IM  uint32_t hif_d10    : 1;            /*!< [10..10] Input status of pin 'hif_d10' sampled at power-on-reset          */
      __IM  uint32_t hif_d11    : 1;            /*!< [11..11] Input status of pin 'hif_d11' sampled at power-on-reset          */
      __IM  uint32_t hif_d12    : 1;            /*!< [12..12] Input status of pin 'hif_d12' sampled at power-on-reset          */
      __IM  uint32_t hif_d13    : 1;            /*!< [13..13] Input status of pin 'hif_d13' sampled at power-on-reset          */
      __IM  uint32_t hif_d14    : 1;            /*!< [14..14] Input status of pin 'hif_d14' sampled at power-on-reset          */
      __IM  uint32_t hif_d15    : 1;            /*!< [15..15] Input status of pin 'hif_d15' sampled at power-on-reset          */
      __IM  uint32_t hif_a0     : 1;            /*!< [16..16] Input status of pin 'hif_a0' sampled at power-on-reset           */
      __IM  uint32_t hif_a1     : 1;            /*!< [17..17] Input status of pin 'hif_a1' sampled at power-on-reset           */
      __IM  uint32_t hif_a2     : 1;            /*!< [18..18] Input status of pin 'hif_a2' sampled at power-on-reset           */
      __IM  uint32_t hif_a3     : 1;            /*!< [19..19] Input status of pin 'hif_a3' sampled at power-on-reset           */
      __IM  uint32_t hif_a4     : 1;            /*!< [20..20] Input status of pin 'hif_a4' sampled at power-on-reset           */
      __IM  uint32_t hif_a5     : 1;            /*!< [21..21] Input status of pin 'hif_a5' sampled at power-on-reset           */
      __IM  uint32_t hif_a6     : 1;            /*!< [22..22] Input status of pin 'hif_a6' sampled at power-on-reset           */
      __IM  uint32_t hif_a7     : 1;            /*!< [23..23] Input status of pin 'hif_a7' sampled at power-on-reset           */
      __IM  uint32_t hif_a8     : 1;            /*!< [24..24] Input status of pin 'hif_a8' sampled at power-on-reset           */
      __IM  uint32_t hif_a9     : 1;            /*!< [25..25] Input status of pin 'hif_a9' sampled at power-on-reset           */
      __IM  uint32_t hif_a10    : 1;            /*!< [26..26] Input status of pin 'hif_a10' sampled at power-on-reset          */
      __IM  uint32_t hif_a11    : 1;            /*!< [27..27] Input status of pin 'hif_a11' sampled at power-on-reset          */
      __IM  uint32_t hif_a12    : 1;            /*!< [28..28] Input status of pin 'hif_a12' sampled at power-on-reset          */
      __IM  uint32_t hif_a13    : 1;            /*!< [29..29] Input status of pin 'hif_a13' sampled at power-on-reset          */
      __IM  uint32_t hif_a14    : 1;            /*!< [30..30] Input status of pin 'hif_a14' sampled at power-on-reset          */
      __IM  uint32_t hif_a15    : 1;            /*!< [31..31] Input status of pin 'hif_a15' sampled at power-on-reset          */
    } sample_at_porn_stat_in0_b;
  } ;
  
  union {
    __IM  uint32_t sample_at_porn_stat_in1;     /*!< (@ 0x00000004) Status of inputs sampled at power-on-reset (PORn)
                                                                    register 1. This register shows the status
                                                                    of the inputs sampled at power-on-reset.
                                                                    It will not change on normal system reset.                 */
    
    struct {
      __IM  uint32_t hif_a16    : 1;            /*!< [0..0] Input status of pin 'hif_a16' sampled at power-on-reset            */
      __IM  uint32_t hif_a17    : 1;            /*!< [1..1] Input status of pin 'hif_a17' sampled at power-on-reset            */
      __IM  uint32_t hif_bhen   : 1;            /*!< [2..2] Input status of pin 'hif_bhen' sampled at power-on-reset           */
      __IM  uint32_t hif_rdn    : 1;            /*!< [3..3] Input status of pin 'hif_rdn' sampled at power-on-reset            */
      __IM  uint32_t hif_wrn    : 1;            /*!< [4..4] Input status of pin 'hif_wrn' sampled at power-on-reset            */
      __IM  uint32_t hif_csn    : 1;            /*!< [5..5] Input status of pin 'hif_csn' sampled at power-on-reset            */
      __IM  uint32_t hif_rdy    : 1;            /*!< [6..6] Input status of pin 'hif_rdy' sampled at power-on-reset            */
      __IM  uint32_t hif_dirq   : 1;            /*!< [7..7] Input status of pin 'hif_dirq' sampled at power-on-reset           */
      __IM  uint32_t hif_sdclk  : 1;            /*!< [8..8] Input status of pin 'hif_sdclk' sampled at power-on-reset          */
      __IM  uint32_t rdy_n      : 1;            /*!< [9..9] Input status of pin 'rdy_n' sampled at power-on-reset              */
      __IM  uint32_t run_n      : 1;            /*!< [10..10] Input status of pin 'run_n' sampled at power-on-reset            */
      __IM  uint32_t sqi_clk    : 1;            /*!< [11..11] Input status of pin 'sqi_clk' sampled at power-on-reset          */
      __IM  uint32_t sqi_cs0n   : 1;            /*!< [12..12] Input status of pin 'sqi_cs0n' sampled at power-on-reset         */
      __IM  uint32_t sqi_mosi   : 1;            /*!< [13..13] Input status of pin 'sqi_mosi' sampled at power-on-reset         */
      __IM  uint32_t sqi_miso   : 1;            /*!< [14..14] Input status of pin 'sqi_miso' sampled at power-on-reset         */
      __IM  uint32_t sqi_sio2   : 1;            /*!< [15..15] Input status of pin 'sqi_sio2' sampled at power-on-reset         */
      __IM  uint32_t sqi_sio3   : 1;            /*!< [16..16] Input status of pin 'sqi_sio3' sampled at power-on-reset         */
    } sample_at_porn_stat_in1_b;
  } ;
} sample_at_porn_stat_Type;                     /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                          adc_seq                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief adc_seq (adc_seq)
  */

typedef struct {                                /*!< (@ 0xFF4016C0) adc_seq Structure                                          */
  
  union {
    __IOM uint32_t adc_seq_start;               /*!< (@ 0x00000000) ADC start register: The bits start_adc0 and start_adc1
                                                                    are write enables for the preceeding bits,
                                                                    respectively. Setting one or both of these
                                                                    bits to 1 starts ADC control state machine
                                                                    for the appropriate ADC using the configuration
                                                                    defined by the preceeding bits (sel_adc,
                                                                    ref_adc, tt_add_adc). The configuration
                                                                    bits can only be changed in the write cycles
                                                                    starting the appropriate ADC. This register
                                                                    is writable but can also be changed by hardware
                                                                    (reset).                                                   */
    
    struct {
      __IOM uint32_t start_adc0 : 1;            /*!< [0..0] Start ADC0: Setting this bit to 1 starts ADC control
                                                     state machine for ADC0. It will reset automatically after
                                                     sampling phase. If it is reset, it can be set for next
                                                     conversion. If start_adc0 and start_adc1 are set, the next
                                                     conversion will be started after both ADCs are finished.
                                                     Otherwise the next conversion will start directly after
                                                     current conversion of ADC0 is finished.                                   */
      __IOM uint32_t sel_adc0   : 2;            /*!< [2..1] Multiplexer Input Select of ADC0: 00: Vin0 01: Vin1 10:
                                                     Temperature Diode 11: Vref                                                */
      __IOM uint32_t ref_adc0   : 1;            /*!< [3..3] Reference Select of ADC0: 0: use internal reference 1:
                                                     use VREF_ADC as reference                                                 */
      __IOM uint32_t tt_add_adc0 : 6;           /*!< [9..4] Tracking Time Addon of ADC0: Time that 3rd ADC_CLK edge
                                                     is delayed (in steps of cfg_clock-period). The capacitor
                                                     inside ADC needs time to be charged depending on the driving
                                                     strength of the external signal. For 12 bit precision,
                                                     this time should be 9*(Rint+Rext)*C, with Rint=1kOhm and
                                                     C=7.5pF. The ADC already waits for 2 ADC_CLK cycles, so
                                                     the total formular for this value is: tt_add = ceil((((67,5pF
                                                     x Rext) + 67,5ns) / period) - 2) Set tt_add=0 if calculated
                                                     value is negative.                                                        */
      __IOM uint32_t reserved0  : 6;            /*!< [15..10] reserved                                                         */
      __IOM uint32_t start_adc1 : 1;            /*!< [16..16] Start ADC1: Setting this bit to 1 starts ADC control
                                                     state machine for ADC1. It will reset automatically after
                                                     sampling phase. If it is reset, it can be set for next
                                                     conversion. If start_adc0 and start_adc1 are set, the next
                                                     conversion will be started after both ADCs are finished.
                                                     Otherwise the next conversion will start directly after
                                                     current conversion of ADC1 is finished.                                   */
      __IOM uint32_t sel_adc1   : 2;            /*!< [18..17] Multiplexer Input Select of ADC1: 00: Vin2 01: Vin3
                                                     10: Vref/2 (for voltage monitoring) 11: Vref                              */
      __IOM uint32_t ref_adc1   : 1;            /*!< [19..19] Reference Select of ADC1: 0: use internal reference
                                                     1: use VREF_ADC as reference                                              */
      __IOM uint32_t tt_add_adc1 : 6;           /*!< [25..20] Tracking Time Addon of ADC1: Time that 3rd ADC_CLK
                                                     edge is delayed (in steps of cfg_clock-period). The capacitor
                                                     inside ADC needs time to be charged depending on the driving
                                                     strength of the external signal. For 12 bit precision,
                                                     this time should be 9*(Rint+Rext)*C, with Rint=1kOhm and
                                                     C=7.5pF. The ADC already waits for 2 ADC_CLK cycles, so
                                                     the total formular for this value is: tt_add = ceil((((67,5pF
                                                     x Rext) + 67,5ns) / period) - 2) Set tt_add=0 if calculated
                                                     value is negative.                                                        */
      __IOM uint32_t reserved1  : 6;            /*!< [31..26] reserved                                                         */
    } adc_seq_start_b;
  } ;
  
  union {
    __IOM uint32_t adc_seq_cfg;                 /*!< (@ 0x00000004) ADC general config register: This register is
                                                                    for static config values of ADC.                           */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] Power-down mode of ADC: 1: Enable ADC (Power up) 0: Disable
                                                     ADC (Power-down)                                                          */
      __IOM uint32_t reset_n    : 1;            /*!< [1..1] Low active reset of ADC and state machine: There are
                                                     no constraints on reset length. 1: Soft-Reset is inactive.
                                                     0: Soft-Reset is active.                                                  */
      __IOM uint32_t buffer_enable : 1;         /*!< [2..2] Enable of Vref at ADCs                                             */
      __IOM uint32_t debug      : 1;            /*!< [3..3] Debug mode: Activate Debug Mode, which directly controls
                                                     ADC via debug register. 1: Debug Mode is active. 0: Debug
                                                     is inactive.                                                              */
      __IOM uint32_t sync_sample_start_if_restart_both : 1;/*!< [4..4] Synchronous start of sampling at restart of both ADCs:
                                                     This option should be activated for debug purposes only!
                                                     Due to cfg_clock-adc1_shift the sampling times of ADC0
                                                     and ADC1 might be a bit longer than defined in start-tt_add_adc1.
                                                     The difference is in the beginning of the sampling phase.
                                                     Both ADCs will always finish their sampling phase synchronously.
                                                     To overcome this unbeautiful behaviour, this mode allows
                                                     to include a wait state between data-output and start-of-sample.
                                                     It will only affect the case, whe                                         */
    } adc_seq_cfg_b;
  } ;
  
  union {
    __IOM uint32_t adc_seq_cfg_clock;           /*!< (@ 0x00000008) ADC config register for ADC clock (same for both
                                                                    ADCs):                                                     */
    
    struct {
      __IOM uint32_t period     : 3;            /*!< [2..0] Clock Period: 000: 20ns 001: 30ns 010: 40ns 011: 50ns
                                                     100: 60ns 101: 70ns 110: 80ns 111: 90ns                                   */
      __IOM uint32_t adc1_shift : 3;            /*!< [5..3] ADC1 Shift: To avoid cross-talk the posedge of ADC1 will
                                                     be shifted. This happens only during conversion (4..15th
                                                     ADC_CLK posedge). ADC1 Shift must be smaller than Clock
                                                     Period! 000: 0ns 001: 10ns 010: 20ns 011: 30ns 100: 40ns
                                                     101: 50ns 110: 60ns 111: 70ns                                             */
    } adc_seq_cfg_clock_b;
  } ;
  
  union {
    __IM  uint32_t adc_seq_status;              /*!< (@ 0x0000000C) ADC status register                                        */
    
    struct {
      __IM  uint32_t adc0_sample : 1;           /*!< [0..0] ADC0 is sampling data.                                             */
      __IM  uint32_t adc1_sample : 1;           /*!< [1..1] ADC1 is sampling data                                              */
      __IM  uint32_t adc0_running : 1;          /*!< [2..2] ADC0 is running.                                                   */
      __IM  uint32_t adc1_running : 1;          /*!< [3..3] ADC1 is running.                                                   */
      __IM  uint32_t adc0_data  : 1;            /*!< [4..4] ADC0 data is ready to be read. Reset automatically at
                                                     read of data0.                                                            */
      __IM  uint32_t adc1_data  : 1;            /*!< [5..5] ADC1 data is ready to be read. Reset automatically at
                                                     read of data1.                                                            */
      __IM  uint32_t adc_clock_running : 1;     /*!< [6..6] at least one ADC_CLK is running                                    */
    } adc_seq_status_b;
  } ;
  
  union {
    __IM  uint32_t adc_seq_adc_data0;           /*!< (@ 0x00000010) ADC0 value                                                 */
    
    struct {
      __IM  uint32_t val        : 12;           /*!< [11..0] Sampled value                                                     */
    } adc_seq_adc_data0_b;
  } ;
  
  union {
    __IM  uint32_t adc_seq_adc_data1;           /*!< (@ 0x00000014) ADC1 value                                                 */
    
    struct {
      __IM  uint32_t val        : 12;           /*!< [11..0] Sampled value                                                     */
    } adc_seq_adc_data1_b;
  } ;
  
  union {
    __IOM uint32_t adc_seq_debug;               /*!< (@ 0x00000018) Debug Mode register: If cgf-debug is enabled,
                                                                    this register directly controls inputs of
                                                                    both ADCs. Output data of both ADCs will
                                                                    still be at data0 and data1. In debug mode,
                                                                    a software reset (cfg-reset_n) will not
                                                                    influence these values (only directly signal
                                                                    ADC_NRES).                                                 */
    
    struct {
      __IOM uint32_t adc0_clk   : 1;            /*!< [0..0] ADC0 is sampling data.                                             */
      __IOM uint32_t adc0_soc   : 1;            /*!< [1..1] ADC0_SOC signal                                                    */
      __IOM uint32_t adc0_use_ref_vdd3 : 1;     /*!< [2..2] ADC0_USE_REF_VDD3 signal                                           */
      __IOM uint32_t adc0_set_mux0 : 1;         /*!< [3..3] ADC0_SET_MUX0 signal                                               */
      __IOM uint32_t adc0_set_mux1 : 1;         /*!< [4..4] ADC0_SET_MUX1 signal                                               */
      __IOM uint32_t adc0_set_mux2 : 1;         /*!< [5..5] ADC0_SET_MUX2 signal                                               */
      __IOM uint32_t adc0_set_mux3 : 1;         /*!< [6..6] ADC0_SET_MUX3 signal                                               */
      __IOM uint32_t reserved0  : 1;            /*!< [7..7] reserved                                                           */
      __IOM uint32_t adc1_clk   : 1;            /*!< [8..8] ADC1 is sampling data.                                             */
      __IOM uint32_t adc1_soc   : 1;            /*!< [9..9] ADC1_SOC signal                                                    */
      __IOM uint32_t adc1_use_ref_vdd3 : 1;     /*!< [10..10] ADC1_USE_REF_VDD3 signal                                         */
      __IOM uint32_t adc1_set_mux0 : 1;         /*!< [11..11] ADC1_SET_MUX0 signal                                             */
      __IOM uint32_t adc1_set_mux1 : 1;         /*!< [12..12] ADC1_SET_MUX1 signal                                             */
      __IOM uint32_t adc1_set_mux2 : 1;         /*!< [13..13] ADC1_SET_MUX2 signal                                             */
      __IOM uint32_t adc1_set_mux3 : 1;         /*!< [14..14] ADC1_SET_MUX3 signal                                             */
      __IOM uint32_t reserved1  : 17;           /*!< [31..15] reserved                                                         */
    } adc_seq_debug_b;
  } ;
  
  union {
    __IOM uint32_t adc_seq_irq_raw;             /*!< (@ 0x0000001C) Raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit.                                                       */
    
    struct {
      __IOM uint32_t adc0_sample_finish : 1;    /*!< [0..0] Sampling phase of ADC0 is finished, ADC0 can be restarted.         */
      __IOM uint32_t adc1_sample_finish : 1;    /*!< [1..1] Sampling phase of ADC1 is finished, ADC1 can be restarted.         */
      __IOM uint32_t adc0_data_finish : 1;      /*!< [2..2] Data of ADC0 is ready to be read.                                  */
      __IOM uint32_t adc1_data_finish : 1;      /*!< [3..3] Data of ADC1 is ready to be read.                                  */
    } adc_seq_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t adc_seq_irq_masked;          /*!< (@ 0x00000020) Masked IRQ: Shows status of masked IRQs (as connected
                                                                    to ARM/xPIC).                                              */
    
    struct {
      __IM  uint32_t adc0_sample_finish : 1;    /*!< [0..0] Sampling phase of ADC0 is finished, ADC0 can be restarted.         */
      __IM  uint32_t adc1_sample_finish : 1;    /*!< [1..1] Sampling phase of ADC1 is finished, ADC1 can be restarted.         */
      __IM  uint32_t adc0_data_finish : 1;      /*!< [2..2] Data of ADC0 is ready to be read.                                  */
      __IM  uint32_t adc1_data_finish : 1;      /*!< [3..3] Data of ADC1 is ready to be read.                                  */
    } adc_seq_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t adc_seq_irq_mask_set;        /*!< (@ 0x00000024) IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit (enables interrupt request for
                                                                    corresponding interrupt source). Write access
                                                                    with '0' does not influence this bit. Read
                                                                    access shows actual interrupt mask. Attention:
                                                                    Before activating interrupt mask, delete
                                                                    old pending int                                            */
    
    struct {
      __IOM uint32_t adc0_sample_finish : 1;    /*!< [0..0] Sampling phase of ADC0 is finished, ADC0 can be restarted.         */
      __IOM uint32_t adc1_sample_finish : 1;    /*!< [1..1] Sampling phase of ADC1 is finished, ADC1 can be restarted.         */
      __IOM uint32_t adc0_data_finish : 1;      /*!< [2..2] Data of ADC0 is ready to be read.                                  */
      __IOM uint32_t adc1_data_finish : 1;      /*!< [3..3] Data of ADC1 is ready to be read.                                  */
    } adc_seq_irq_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t adc_seq_irq_mask_reset;      /*!< (@ 0x00000028) IRQ mask reset: This is the corresponding reset
                                                                    mask to disable interrupt requests for corresponding
                                                                    interrupt sources: Write access with '1'
                                                                    resets interrupt mask bit (disables interrupt
                                                                    request for corresponding interrupt source).
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t adc0_sample_finish : 1;    /*!< [0..0] Sampling phase of ADC0 is finished, ADC0 can be restarted.         */
      __IOM uint32_t adc1_sample_finish : 1;    /*!< [1..1] Sampling phase of ADC1 is finished, ADC1 can be restarted.         */
      __IOM uint32_t adc0_data_finish : 1;      /*!< [2..2] Data of ADC0 is ready to be read.                                  */
      __IOM uint32_t adc1_data_finish : 1;      /*!< [3..3] Data of ADC1 is ready to be read.                                  */
    } adc_seq_irq_mask_reset_b;
  } ;
} adc_seq_Type;                                 /*!< Size = 44 (0x2c)                                                          */



/* =========================================================================================================================== */
/* ================                                           miimu                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief miimu (miimu)
  */

typedef struct {                                /*!< (@ 0xFF401700) miimu Structure                                            */
  
  union {
    __IOM uint32_t miimu;                       /*!< (@ 0x00000000) MDIO FSM interface controlling for netX external
                                                                    PHY. Note: Loopback for purpose is provided
                                                                    by miimu_sw register and also performed
                                                                    in non-software-mode when enabled. Note:
                                                                    Prior phy_nres-bit was removed. PHY reset
                                                                    must be done by register ASIC_CTRL.phy_control.            */
    
    struct {
      __IOM uint32_t snrdy      : 1;            /*!< [0..0] Start not ready                                                    */
      __IOM uint32_t preamble   : 1;            /*!< [1..1] Send preamble                                                      */
      __IOM uint32_t opmode     : 1;            /*!< [2..2] Operation mode: 1: write 0: read                                   */
      __IOM uint32_t mdc_period : 1;            /*!< [3..3] MDC period: 1: 800ns 0: 400ns                                      */
      __IOM uint32_t reserved0  : 1;            /*!< [4..4] reserved                                                           */
      __IOM uint32_t rta        : 1;            /*!< [5..5] Read Turn Around field: 0: one bit 1: two bits                     */
      __IOM uint32_t regaddr    : 5;            /*!< [10..6] Register address                                                  */
      __IOM uint32_t phyaddr    : 5;            /*!< [15..11] PHY address                                                      */
      __IOM uint32_t data       : 16;           /*!< [31..16] Data to or from PHY register                                     */
    } miimu_b;
  } ;
  
  union {
    __IOM uint32_t miimu_sw;                    /*!< (@ 0x00000004) MDIO software interface controlling for netX
                                                                    internal PHY. Note: Function is similar
                                                                    to old MIIMU unit register 'miimu_sw', however
                                                                    data output enable was removed as it is
                                                                    not necessary for MDIO interface to internal
                                                                    PHY (due to non-bidirectional data signal).                */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] Enables software mode: MDC, MDO and MDOE are set by software.      */
      __IOM uint32_t reserved0  : 3;            /*!< [3..1] reserved                                                           */
      __IOM uint32_t mdc        : 1;            /*!< [4..4] MDC value for software mode                                        */
      __IOM uint32_t mdo        : 1;            /*!< [5..5] MDO value for software mode                                        */
      __IOM uint32_t mdoe       : 1;            /*!< [6..6] MDOE value for software mode                                       */
      __IOM uint32_t mdi_ro     : 1;            /*!< [7..7] current MDI value                                                  */
      __IOM uint32_t loopback   : 1;            /*!< [8..8] MDIO-data-out to data-in loopback for test purpose. 0:
                                                     no loopback, MDIO-data-in comes from internal PHY. 1: loopback,
                                                     MDIO-data-in comes from current MDIO-data-out. Note: Loopback
                                                     can also be used in non-software-mode.                                    */
      __IOM uint32_t reserved1  : 23;           /*!< [31..9] reserved                                                          */
    } miimu_sw_b;
  } ;
} miimu_Type;                                   /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                            eth                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief eth (eth)
  */

typedef struct {                                /*!< (@ 0xFF480000) eth Structure                                              */
  
  union {
    __IOM uint32_t eth_config;                  /*!< (@ 0x00000000) ETH config register                                        */
    
    struct {
      __IOM uint32_t rx_watermark_irq : 4;      /*!< [3..0] Watermark for RX-FIFO, that generates interrupt This
                                                     number of DWords is available inside RX-FIFO                              */
      __IOM uint32_t rx_sample_phase : 3;       /*!< [6..4] clk-phase in which rxd is sampled: PHY mode (phy_mode=1):
                                                     { | 0,4: sample at posedge tx_clk 1,5: sample at posedge
                                                     tx_clk + 1cc 2,6: sample at posedge tx_clk + 2cc 3,7: sample
                                                     at posedge tx_clk + 3cc} MAC mode (phy_mode=0): { | 0:
                                                     sample at posedge rx_clk + 1cc 1: sample at posedge rx_clk
                                                     + 2cc 2: sample at posedge rx_clk + 3cc 3: sample at posedge
                                                     rx_clk + 4cc 4: sample at negedge rx_clk + 3cc 5: sample
                                                     at negedge rx_clk + 4cc 6: sample at negedge rx_clk + 1cc
                                                     7: sample at negedge rx_clk + 2cc}                                        */
      __IOM uint32_t rx_delay_inputs : 1;       /*!< [7..7] Delay mii inputs (rx_d, rx_dv, rx_err, crs, col) by 1
                                                     clockcycle before sampling them. This leads to inputs fitting
                                                     to sampled rxclk. Enable this in MAC mode, disable in PHY
                                                     mode.                                                                     */
      __IOM uint32_t rx_allow_jumbo_packets : 1;/*!< [8..8] Receive frames &gt; 1522 bytes. If jumbo_packets are
                                                     not allowed, the receive frame buffer must be 1524 bytes.
                                                     Warning: Frames with len &gt; 2047 will be received, but
                                                     rx_frame_len has only 11 bit.                                             */
      __IOM uint32_t rx_exact_preamble : 1;     /*!< [9..9] Accept only packages with exact preamble, rx_preamble_error
                                                     IRQ will be generated independant on this setting.                        */
      __IOM uint32_t rx_no_preamble : 1;        /*!< [10..10] receive starts, when rxdv gets active                            */
      __IOM uint32_t rx_dma_mode : 1;           /*!< [11..11] Receive DMA mode: Each received frame needs 2 DMA-transfers,
                                                     one for package data and one for rx_len/status. In rx_dma_mode
                                                     irq_raw-rx_frame_finished is reset automatically.                         */
      __IOM uint32_t rx_systime_sfd : 1;        /*!< [12..12] Sample systime at SFD of received frame: 1: Sample
                                                     systime_ns to eth_rx_systime_ns at SFD (+constant offset)
                                                     0: Sample systime_ns to eth_rx_systime_ns when rxdv gets
                                                     active (+constant offset)                                                 */
      __IOM uint32_t rx_enable  : 1;            /*!< [13..13] Enable of receive state machine: When disabled, receive
                                                     state machine is reset. After enabling, receive state machine
                                                     waits for rxdv going down. If rxdv is already down, proper
                                                     IFG is expected.                                                          */
      __IOM uint32_t reserved0  : 13;           /*!< [26..14] reserved                                                         */
      __IOM uint32_t frequency  : 1;            /*!< [27..27] MII clock frequency: 1: 50MHz (use in PHY mode only)
                                                     0: 25MHz                                                                  */
      __IOM uint32_t hd_suppress_loopback : 1;  /*!< [28..28] Suppress loopback in half_duplex mode: 1: don't start
                                                     RX-process, if txen is active. 0: RX and TX work indepentently.           */
      __IOM uint32_t phy_mode   : 1;            /*!< [29..29] PHY mode: 0: behave like an ethernet MAC, sync to external
                                                     rxclk/txclk 1: behave like an ethernet PHY, generate txclk
                                                     (=rxclk), signals change their function: { | rxclk: not
                                                     used rxd[3:0]: data input, to be connected to txd[3:0]
                                                     of MAC device rxdv: Data valid input, to be connected to
                                                     txen of MAC device rxer: Error input, to be connected to
                                                     txer of MAC device txclk: Clock output, to be connected
                                                     to rxclk and txclk of MAC device txd[3:0]: Data output,
                                                     to be connected to rxd[3:0] of                                            */
      __IOM uint32_t reserved1  : 2;            /*!< [31..30] reserved                                                         */
    } eth_config_b;
  } ;
  
  union {
    __IOM uint32_t eth_tx_config;               /*!< (@ 0x00000004) ETH config register                                        */
    
    struct {
      __IOM uint32_t tx_watermark_irq : 4;      /*!< [3..0] Watermark for TX-FIFO, that generates IRQ. This number
                                                     of DWords is free inside TX-FIFO                                          */
      __IOM uint32_t tx_watermark_start : 4;    /*!< [7..4] Watermark for TX-FIFO, that starts transmission. This
                                                     number of DWords is inside TX-FIFO                                        */
      __IOM uint32_t tx_output_phase : 3;       /*!< [10..8] clk-phase in which txd, txen, txer is changed at output
                                                     PHY mode (phy_mode=1): { | 0,4: change output at negedge
                                                     tx_clk 1,5: change output at negedge tx_clk + 1cc 2,6:
                                                     change output at negedge tx_clk + 2cc 3,7: change output
                                                     at negedge tx_clk + 3cc} MAC mode (phy_mode=0): { | 0:
                                                     change output at posedge tx_clk + 2cc 1: change output
                                                     at posedge tx_clk + 3cc 2: change output at posedge tx_clk
                                                     + 4cc 3: change output at posedge tx_clk + 5cc 4: change
                                                     output at negedge tx_clk + 4cc 5: change output at neged                  */
      __IOM uint32_t tx_preamble_len : 5;       /*!< [15..11] Length of TX-preamble in nibbles (incl. SFD)                     */
      __IOM uint32_t tx_min_ifg_cycles : 5;     /*!< [20..16] minimum IFG in txclk-cycles In half_duplex mode reduce
                                                     value by 2 to compensate cycles for sampling of mii_crs.                  */
      __IOM uint32_t tx_crs_low_cycles : 5;     /*!< [25..21] txclk-cycles with mii_crs low, before free carrier
                                                     is detected (only used in half_duplex mode): Value range:
                                                     [0,tx_min_ifg_cycles]. For details s. half_duplex mode.                   */
      __IOM uint32_t tx_abort_frame : 3;        /*!< [28..26] Different abort mechanisms: 000: no abort: Transmit
                                                     frame from TX-FIFO until tx_len and append correct FCS.
                                                     001: standard abort: Abort transmission, send wrong FCS,
                                                     activate mii_txer. SW should keep bit active until irq-tx_frame_finished,
                                                     then reset TX-FIFO. 010: abort with dribble nibble: Like
                                                     standard abort, but append dribble nibble after wrong FCS
                                                     (needed by some PHYs to detect error condition) SW should
                                                     keep bit active until irq-tx_frame_finished, then reset
                                                     TX-FIFO. 011: no FCS mode: Transmit frame f                               */
      __IOM uint32_t tx_systime_sfd : 1;        /*!< [29..29] Sample systime at SFD: 1: Sample systime_ns to eth_tx_systime_ns
                                                     at SFD (-constant offset) 0: Sample systime_ns to eth_tx_systime_ns
                                                     when txen gets active (-constant offset)                                  */
      __IOM uint32_t tx_dma_mode : 1;           /*!< [30..30] In tx_dma_mode tx_len comes from DMAC automatically.
                                                     An extra tx_lsreq will be generated to request tx_len,
                                                     before frame data is requested (and after previous frame
                                                     is finished). In tx_dma_mode irq_raw-tx_frame_finished
                                                     is reset automatically.                                                   */
      __IOM uint32_t half_duplex : 1;           /*!< [31..31] Half Duplex Mode: 1: In half duplex mode transmission
                                                     of a frame starts after the following sequence: - tx_watermark_start
                                                     was reached - mii_crs became low and stayed low for tx_crs_low_cycles
                                                     - (tx_min_ifg_cycles - tx_crs_low_cycles) are passed 0:
                                                     In full duplex mode transmission of a frame starts after
                                                     the following sequence: - tx_min_ifg_cycles are passed
                                                     after the last transmitted frame - tx_watermark_start was
                                                     reached                                                                   */
    } eth_tx_config_b;
  } ;
  
  union {
    __IM  uint32_t eth_status;                  /*!< (@ 0x00000008) ETH status register:                                       */
    
    struct {
      __IM  uint32_t rx_fill    : 5;            /*!< [4..0] Fill-level of RX-FIFO                                              */
      __IM  uint32_t reserved0  : 2;            /*!< [6..5] reserved                                                           */
      __IM  uint32_t tx_fill    : 5;            /*!< [11..7] Fill-level of TX-FIFO                                             */
      __IM  uint32_t reserved1  : 20;           /*!< [31..12] reserved                                                         */
    } eth_status_b;
  } ;
  
  union {
    __IOM uint32_t eth_tx_data;                 /*!< (@ 0x0000000C) Data to TX-FIFO: returns 0xdeadbeef on read                */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] data to TX-FIFO                                                   */
    } eth_tx_data_b;
  } ;
  
  union {
    __IM  uint32_t eth_rx_data;                 /*!< (@ 0x00000010) Data from RX-FIFO:                                         */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] data from RX-FIFO                                                 */
    } eth_rx_data_b;
  } ;
  
  union {
    __IOM uint32_t eth_tx_len;                  /*!< (@ 0x00000014) Length of data inside transmitted frame (between
                                                                    SFD and FCS) Note: Set this value after
                                                                    previous frame is completely transmitted
                                                                    (irq-tx_frame_finished).                                   */
    
    struct {
      __IOM uint32_t val        : 11;           /*!< [10..0] To be transmitted data length (excluding SFD and excluding
                                                     FCS)                                                                      */
    } eth_tx_len_b;
  } ;
  
  union {
    __IM  uint32_t eth_rx_len_stat;             /*!< (@ 0x00000018) Length and status information of lastly received
                                                                    frame                                                      */
    
    struct {
      __IM  uint32_t rx_len     : 11;           /*!< [10..0] Received data (excluding SFD and including FCS)                   */
      __IM  uint32_t reserved0  : 16;           /*!< [26..11] reserved                                                         */
      __IM  uint32_t rx_short_ifg : 1;          /*!< [27..27] IFG shorter 960ns detected (preceeding this frame).              */
      __IM  uint32_t rx_jumbo_packet : 1;       /*!< [28..28] rx_frame_len &gt; 1522 detected: In case of eth_config-allow_jumbo_pa
                                                     kets=1, this frame was received, but rx_len will overflow
                                                     at 2048. In case of eth_config-allow_jumbo_packets=0, frame
                                                     is stopped after 1522, but other status information (rxerr,
                                                     crc, dribble_nibble) will be checked anyway.                              */
      __IM  uint32_t rx_dribble_nibble : 1;     /*!< [29..29] frame finished at non-even nibble count, last nibble
                                                     was dropped                                                               */
      __IM  uint32_t rx_crc_error : 1;          /*!< [30..30] wrong RX FCS detected                                            */
      __IM  uint32_t rx_mii_rxerr : 1;          /*!< [31..31] external rxerr signal was active in last frame                   */
    } eth_rx_len_stat_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IM  uint32_t eth_rx_systime_ns;           /*!< (@ 0x00000020) Systime_ns sampled at start of received frame.
                                                                    Exact position of start of frame is defined
                                                                    in eth_config-systime_sfd.                                 */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] Sampled systime_ns                                                */
    } eth_rx_systime_ns_b;
  } ;
  
  union {
    __IM  uint32_t eth_tx_systime_ns;           /*!< (@ 0x00000024) Systime_ns sampled at start of transmitted frame.
                                                                    Exact position of start of frame is defined
                                                                    in eth_tx_config-systime_sfd.                              */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] Sampled systime_ns                                                */
    } eth_tx_systime_ns_b;
  } ;
  
  union {
    __IOM uint32_t eth_irq_raw;                 /*!< (@ 0x00000028) Raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit. Write access with '1' to rx_/tx_fifo_undr/_ovfl
                                                                    resets RX-FIFO/TX-FIFO. Bits rx_data and
                                                                    tx_fifo are cleared by reading from/filling
                                                                    the appropriate FIFO.                                      */
    
    struct {
      __IOM uint32_t tx_fifo    : 1;            /*!< [0..0] TX-FIFO has free entries                                           */
      __IOM uint32_t tx_frame_finished : 1;     /*!< [1..1] TX frame finished: In tx_dma_mode this bit is handled
                                                     automatically, demask it to the CPU.                                      */
      __IOM uint32_t rx_data    : 1;            /*!< [2..2] RX Data is available                                               */
      __IOM uint32_t rx_frame_finished : 1;     /*!< [3..3] RX frame finished: Clearing this bit tells the module,
                                                     that the CPU has read rx_len_stat and the next frame can
                                                     be received. In rx_dma_mode this bit is handled automatically,
                                                     demask it to the CPU.                                                     */
      __IOM uint32_t tx_fifo_undr : 1;          /*!< [4..4] TX-FIFO underrun                                                   */
      __IOM uint32_t tx_fifo_ovfl : 1;          /*!< [5..5] TX-FIFO overflow (debug only, can never happen in ASIC)            */
      __IOM uint32_t rx_fifo_undr : 1;          /*!< [6..6] RX-FIFO underrun (debug only, can never happen in ASIC)            */
      __IOM uint32_t rx_fifo_ovfl : 1;          /*!< [7..7] RX-FIFO overflow                                                   */
      __IOM uint32_t rx_cpu_too_slow : 1;       /*!< [8..8] next frame started before irq_raw_rx_frame_finished was
                                                     cleared                                                                   */
      __IOM uint32_t rx_short_dv : 1;           /*!< [9..9] mii_rxdv becomes low before SFD                                    */
      __IOM uint32_t rx_preamble_error : 1;     /*!< [10..10] data &lt;&gt; 0x5 during preamble or wrong length of
                                                     preamble                                                                  */
      __IOM uint32_t tx_col     : 1;            /*!< [11..11] collision detected in half_duplex mode, started sending
                                                     jam                                                                       */
      __IOM uint32_t tx_late_col : 1;           /*!< [12..12] late colision detected in half_duplex mode, started
                                                     sending jam                                                               */
    } eth_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t eth_irq_masked;              /*!< (@ 0x0000002C) Masked IRQ: Shows status of masked IRQs as connected
                                                                    to ARM/xPIC.                                               */
    
    struct {
      __IM  uint32_t tx_fifo    : 1;            /*!< [0..0] TX-FIFO has free entries                                           */
      __IM  uint32_t tx_frame_finished : 1;     /*!< [1..1] TX frame finished                                                  */
      __IM  uint32_t rx_data    : 1;            /*!< [2..2] RX Data is available                                               */
      __IM  uint32_t rx_frame_finished : 1;     /*!< [3..3] RX frame finished                                                  */
      __IM  uint32_t tx_fifo_undr : 1;          /*!< [4..4] TX-FIFO underrun                                                   */
      __IM  uint32_t tx_fifo_ovfl : 1;          /*!< [5..5] TX-FIFO overflow (debug only, can never happen in ASIC)            */
      __IM  uint32_t rx_fifo_undr : 1;          /*!< [6..6] RX-FIFO underrun (debug only, can never happen in ASIC)            */
      __IM  uint32_t rx_fifo_ovfl : 1;          /*!< [7..7] RX-FIFO overflow                                                   */
      __IM  uint32_t rx_cpu_too_slow : 1;       /*!< [8..8] next frame started before irq_raw_rx_frame_finished was
                                                     cleared                                                                   */
      __IM  uint32_t rx_short_dv : 1;           /*!< [9..9] mii_rxdv becomes low before SFD                                    */
      __IM  uint32_t rx_preamble_error : 1;     /*!< [10..10] data &lt;&gt; 0x5 during preamble or wrong length of
                                                     preamble                                                                  */
      __IM  uint32_t tx_col     : 1;            /*!< [11..11] collision detected in half_duplex mode, started sending
                                                     jam                                                                       */
      __IM  uint32_t tx_late_col : 1;           /*!< [12..12] late colision detected in half_duplex mode, started
                                                     sending jam                                                               */
    } eth_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t eth_irq_msk_set;             /*!< (@ 0x00000030) IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to adr_eth_irq_raw.              */
    
    struct {
      __IOM uint32_t tx_fifo    : 1;            /*!< [0..0] TX-FIFO has free entries                                           */
      __IOM uint32_t tx_frame_finished : 1;     /*!< [1..1] TX frame finished                                                  */
      __IOM uint32_t rx_data    : 1;            /*!< [2..2] RX Data is available                                               */
      __IOM uint32_t rx_frame_finished : 1;     /*!< [3..3] RX frame finished                                                  */
      __IOM uint32_t tx_fifo_undr : 1;          /*!< [4..4] TX-FIFO underrun                                                   */
      __IOM uint32_t tx_fifo_ovfl : 1;          /*!< [5..5] TX-FIFO overflow (debug only, can never happen in ASIC)            */
      __IOM uint32_t rx_fifo_undr : 1;          /*!< [6..6] RX-FIFO underrun (debug only, can never happen in ASIC)            */
      __IOM uint32_t rx_fifo_ovfl : 1;          /*!< [7..7] RX-FIFO overflow                                                   */
      __IOM uint32_t rx_cpu_too_slow : 1;       /*!< [8..8] next frame started before irq_raw_rx_frame_finished was
                                                     cleared                                                                   */
      __IOM uint32_t rx_short_dv : 1;           /*!< [9..9] mii_rxdv becomes low before SFD                                    */
      __IOM uint32_t rx_preamble_error : 1;     /*!< [10..10] data &lt;&gt; 0x5 during preamble or wrong length of
                                                     preamble                                                                  */
      __IOM uint32_t tx_col     : 1;            /*!< [11..11] collision detected in half_duplex mode, started sending
                                                     jam                                                                       */
      __IOM uint32_t tx_late_col : 1;           /*!< [12..12] late colision detected in half_duplex mode, started
                                                     sending jam                                                               */
    } eth_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t eth_irq_msk_reset;           /*!< (@ 0x00000034) IRQ mask reset: This is the corresponding reset
                                                                    mask to disable interrupt requests for corresponding
                                                                    interrupt sources: Write access with '1'
                                                                    resets interrupt mask bit. Write access
                                                                    with '0' does not influence this bit. Read
                                                                    access shows actual interrupt mask.                        */
    
    struct {
      __IOM uint32_t tx_fifo    : 1;            /*!< [0..0] TX-FIFO has free entries                                           */
      __IOM uint32_t tx_frame_finished : 1;     /*!< [1..1] TX frame finished                                                  */
      __IOM uint32_t rx_data    : 1;            /*!< [2..2] RX Data is available                                               */
      __IOM uint32_t rx_frame_finished : 1;     /*!< [3..3] RX frame finished                                                  */
      __IOM uint32_t tx_fifo_undr : 1;          /*!< [4..4] TX-FIFO underrun                                                   */
      __IOM uint32_t tx_fifo_ovfl : 1;          /*!< [5..5] TX-FIFO overflow (debug only, can never happen in ASIC)            */
      __IOM uint32_t rx_fifo_undr : 1;          /*!< [6..6] RX-FIFO underrun (debug only, can never happen in ASIC)            */
      __IOM uint32_t rx_fifo_ovfl : 1;          /*!< [7..7] RX-FIFO overflow                                                   */
      __IOM uint32_t rx_cpu_too_slow : 1;       /*!< [8..8] next frame started before irq_raw_rx_frame_finished was
                                                     cleared                                                                   */
      __IOM uint32_t rx_short_dv : 1;           /*!< [9..9] mii_rxdv becomes low before SFD                                    */
      __IOM uint32_t rx_preamble_error : 1;     /*!< [10..10] data &lt;&gt; 0x5 during preamble or wrong length of
                                                     preamble                                                                  */
      __IOM uint32_t tx_col     : 1;            /*!< [11..11] collision detected in half_duplex mode, started sending
                                                     jam                                                                       */
      __IOM uint32_t tx_late_col : 1;           /*!< [12..12] late colision detected in half_duplex mode, started
                                                     sending jam                                                               */
    } eth_irq_msk_reset_b;
  } ;
} eth_Type;                                     /*!< Size = 56 (0x38)                                                          */



/* =========================================================================================================================== */
/* ================                                        dmac_app_ch                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief dmac_app_ch (dmac_app_ch)
  */

typedef struct {                                /*!< (@ 0xFF800100) dmac_app_ch Structure                                      */
  
  union {
    __IOM uint32_t* dmac_chsrc_ad;              /*!< (@ 0x00000000) channel source address registers                           */
    
    struct {
      __IOM uint32_t DMACCHSRCADDR : 32;        /*!< [31..0] DMA source address                                                */
    } dmac_chsrc_ad_b;
  } ;
  
  union {
    __IOM uint32_t* dmac_chdest_ad;             /*!< (@ 0x00000004) channel destination address registers                      */
    
    struct {
      __IOM uint32_t DMACCHDESTADDR : 32;       /*!< [31..0] DMA destination address                                           */
    } dmac_chdest_ad_b;
  } ;
  
  union {
    __IOM uint32_t* dmac_chlink;                /*!< (@ 0x00000008) channel linked list item register                          */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t LLIADDR    : 30;           /*!< [31..2] Linked list item. Bits [31:2] of the address for the
                                                     next LLI. Address bits [1:0] are 0.                                       */
    } dmac_chlink_b;
  } ;
  
  union {
    __IOM uint32_t dmac_chctrl;                 /*!< (@ 0x0000000C) channel control registers                                  */
    
    struct {
      __IOM uint32_t TransferSize : 12;         /*!< [11..0] Transfer size: For writes, this field indicates the
                                                     number of (Source width) transfers to perform when the
                                                     DMAC is the flow controller. For reads, the transfer size
                                                     indicates the number of transfers completed on the destination
                                                     bus. Reading the register when the channel is active does
                                                     not give useful information, as by the time that the software
                                                     has processed the value read, the channel might have progressed.
                                                     It is intended to be used only when a channel is enabled
                                                     and then disabled. If the DMAC controller                                 */
      __IOM uint32_t SBSize     : 3;            /*!< [14..12] Source burst size: Indicates the number of transfers
                                                     which make up a source burst. This value must be set to
                                                     the burst size of the source peripheral, or if the source
                                                     is memory, to the memory boundary size. The burst size
                                                     is the amount of data that is transferred when the DMACxBREQ
                                                     signal goes active in the source peripheral. The burst
                                                     size is not related to the AHB HBURST signal. ___________________________
                                                     ____ bit_value burst_transfer_size --------------------------------
                                                     000 1 001 4                                                               */
      __IOM uint32_t DBSize     : 3;            /*!< [17..15] Destination burst size: Indicates the number of transfers
                                                     which make up a destination burst transfer request. This
                                                     value must be set to the burst size of the destination
                                                     peripheral, or if the destination is memory, to the memory
                                                     boundary size. The burst size is the amount of data that
                                                     is transferred when the DMACxBREQ signal goes active in
                                                     the destination peripheral. The burst size is not related
                                                     to the AHB HBURST signal. Note: If flow controller is DMAC
                                                     and destination is a peripheral, only bursts are tra                      */
      __IOM uint32_t SWidth     : 3;            /*!< [20..18] Source transfer width: The source and destination widths
                                                     can be different from each other. The hardware automatically
                                                     packs and unpacks the data as required. _________________________
                                                     bit_value data_width ------------------------- 000 8 bit
                                                     001 16 bit 010 32 bit =========================                           */
      __IOM uint32_t DWidth     : 3;            /*!< [23..21] Destination transfer width: The source and destination
                                                     widths can be different from each other. The hardware automatically
                                                     packs and unpacks the data as required. _________________________
                                                     bit_value data_width ------------------------- 000 8 bit
                                                     001 16 bit 010 32 bit =========================                           */
      __IOM uint32_t ARM_EQ     : 1;            /*!< [24..24] Set equal behaviour to arm implementation This bit
                                                     should always be set to 1 (default of 0 is from historical
                                                     reasons). This bit changes 2 behavioural details: 1. ARM_EQ=1:
                                                     ignore single requests in DMA-controlled Memory-to-Peripheral
                                                     accesses. ARM_EQ=0: handle single requests like burst requests
                                                     (in this case DBSize should be 1 access). Note: In DMA-controlled
                                                     Memory-to-Peripheral mode only burst request signals are
                                                     allowed. The behaviour of single requests (from peripheral
                                                     to DMAC) is not defined. Module                                           */
      __IOM uint32_t reserved0  : 1;            /*!< [25..25] reserved                                                         */
      __IOM uint32_t SI         : 1;            /*!< [26..26] Source increment. When set the source address is incremented
                                                     after each transfer.                                                      */
      __IOM uint32_t DI         : 1;            /*!< [27..27] Destination increment. When set the destination address
                                                     is incremented after each transfer.                                       */
      __IOM uint32_t Prot       : 3;            /*!< [30..28] Protection.                                                      */
      __IOM uint32_t I          : 1;            /*!< [31..31] Terminal count interrupt enable bit. It controls whether
                                                     the current LLI is expected to trigger the terminal count
                                                     interrupt.                                                                */
    } dmac_chctrl_b;
  } ;
  
  union {
    __IOM uint32_t dmac_chcfg;                  /*!< (@ 0x00000010) channel configuration registers                            */
    
    struct {
      __IOM uint32_t E          : 1;            /*!< [0..0] Channel enable. Reading this bit indicates whether a
                                                     channel is currently enabled or disabled: 0 = channel disabled
                                                     1 = channel enabled. The Channel Enable bit status can
                                                     also be found by reading the DMACEnbldChns register. A
                                                     channel is enabled by setting this bit. Before enabling
                                                     a single channel the DMA controller must be enabled globally
                                                     by setting the DMACENABLE bit in the dmac_config register.
                                                     Enabling a channel while the controller is disabled leads
                                                     to undefined behaviour. A channel can be disabled b                       */
      __IOM uint32_t SrcPeripheral : 4;         /*!< [4..1] Source peripheral. This value selects the DMA source
                                                     request peripheral. This field is ignored if the source
                                                     of the transfer is from memory. Note: The mapping of peripherals
                                                     to App-side DMAC inputs is done within the DMAC_MUX_APP
                                                     module. See 'dmac_mux_peripheral_input_sel*' registers
                                                     for default mapping / current mapping. { | | value Com-side
                                                     App-side 0 uart_rx dmac_mux_peripheral_input_sel0 1 uart_tx
                                                     dmac_mux_peripheral_input_sel1 2                                          */
      __IOM uint32_t reserved0  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t DestPeripheral : 4;        /*!< [9..6] Destination peripheral. This value selects the DMA destination
                                                     request peripheral. This field is ignored if the destination
                                                     of the transfer is to memory. For mapping of peripheral
                                                     to value see 'SrcPeripheral' bit-field in this register.                  */
      __IOM uint32_t reserved1  : 1;            /*!< [10..10] reserved                                                         */
      __IOM uint32_t FlowCntrl  : 3;            /*!< [13..11] Flow control and transfer type. This value is used
                                                     to indicate the flow controller and transfer type. The
                                                     flow controller can be the DMAC, the source peripheral,
                                                     or the destination peripheral. The transfer type can be
                                                     either memory-to-memory, memory-to-peripheral, peripheral-to-memory,
                                                     or peripheral-to-peripheral. ____________________________________________
                                                     __________________________ bit_value transfer_type controller
                                                     ---------------------------------------------------                       */
      __IOM uint32_t IE         : 1;            /*!< [14..14] Interrupt error mask. When cleared this bit masks out
                                                     the error interrupt of the relevant channel.                              */
      __IOM uint32_t ITC        : 1;            /*!< [15..15] Terminal count interrupt mask. When cleared this bit
                                                     masks out the terminal count interrupt of the relevant
                                                     channel.                                                                  */
      __IOM uint32_t L          : 1;            /*!< [16..16] Lock. When set this bit enables locked transfers.                */
      __IOM uint32_t A          : 1;            /*!< [17..17] Active: 0 = there is no data in the FIFO of the channel
                                                     1 = the FIFO of the channel has data. (ro) This value can
                                                     be used with the Halt and Channel Enable bits to cleanly
                                                     disable a DMA channel.                                                    */
      __IOM uint32_t H          : 1;            /*!< [18..18] Halt: 0 = allow DMA requests 1 = ignore further source
                                                     DMA requests. The contents of the channels FIFO are drained.
                                                     This value can be used with the Active and Channel Enable
                                                     bits to cleanly disable a DMA channel.                                    */
      __IOM uint32_t reserved2  : 13;           /*!< [31..19] reserved                                                         */
    } dmac_chcfg_b;
  } ;
  __IM  uint32_t  RESERVED[3];
} dmac_app_ch_Type;                             /*!< Size = 20 (0x14)                                                          */
typedef dmac_app_ch_Type  dmac_app_ch_ARRAYType[1];/*!< max. 3 instances available                                             */



/* =========================================================================================================================== */
/* ================                                       dmac_app_reg                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief dmac_app_reg (dmac_app_reg)
  */

typedef struct {                                /*!< (@ 0xFF800800) dmac_app_reg Structure                                     */
  
  union {
    __IM  uint32_t dmac_int_status;             /*!< (@ 0x00000000) interrupt status register                                  */
    
    struct {
      __IM  uint32_t DMACINT_ch0 : 1;           /*!< [0..0] Status of DMA channel 0 - interrupt after masking. 1'b1
                                                     indicates an active interrupt request.                                    */
      __IM  uint32_t DMACINT_ch1 : 1;           /*!< [1..1] Status of DMA channel 1 - interrupt after masking. 1'b1
                                                     indicates an active interrupt request.                                    */
      __IM  uint32_t DMACINT_ch2 : 1;           /*!< [2..2] Status of DMA channel 2 - interrupt after masking. 1'b1
                                                     indicates an active interrupt request.                                    */
    } dmac_int_status_b;
  } ;
  
  union {
    __IM  uint32_t dmac_inttc_status;           /*!< (@ 0x00000004) interrupt terminal count status register                   */
    
    struct {
      __IM  uint32_t DMACINTTC_ch0 : 1;         /*!< [0..0] Status of DMA channel 0 - terminal count interrupt after
                                                     masking. 1'b1 indicates an active interrupt request.                      */
      __IM  uint32_t DMACINTTC_ch1 : 1;         /*!< [1..1] Status of DMA channel 1 - terminal count interrupt after
                                                     masking. 1'b1 indicates an active interrupt request.                      */
      __IM  uint32_t DMACINTTC_ch2 : 1;         /*!< [2..2] Status of DMA channel 2 - terminal count interrupt after
                                                     masking. 1'b1 indicates an active interrupt request.                      */
    } dmac_inttc_status_b;
  } ;
  
  union {
    __OM  uint32_t dmac_inttc_clear;            /*!< (@ 0x00000008) interrupt terminal count clear register                    */
    
    struct {
      __OM  uint32_t DMACINTTCCLR_ch0 : 1;      /*!< [0..0] Writing a 1'b1 Bit clears the terminal count interrupt
                                                     of the specific channel 0 ,1'b0 have no effect.                           */
      __OM  uint32_t DMACINTTCCLR_ch1 : 1;      /*!< [1..1] Writing a 1'b1 Bit clears the terminal count interrupt
                                                     of the specific channel 1 ,1'b0 have no effect.                           */
      __OM  uint32_t DMACINTTCCLR_ch2 : 1;      /*!< [2..2] Writing a 1'b1 Bit clears the terminal count interrupt
                                                     of the specific channel 2 ,1'b0 have no effect.                           */
    } dmac_inttc_clear_b;
  } ;
  
  union {
    __IM  uint32_t dmac_interr_status;          /*!< (@ 0x0000000C) interrupt error status register                            */
    
    struct {
      __IM  uint32_t DMACINTERR_ch0 : 1;        /*!< [0..0] Status of DMA channel 0 - error interrupt after masking.
                                                     1'b1 indicates an active interrupt request.                               */
      __IM  uint32_t DMACINTERR_ch1 : 1;        /*!< [1..1] Status of DMA channel 1 - error interrupt after masking.
                                                     1'b1 indicates an active interrupt request.                               */
      __IM  uint32_t DMACINTERR_ch2 : 1;        /*!< [2..2] Status of DMA channel 2 - error interrupt after masking.
                                                     1'b1 indicates an active interrupt request.                               */
    } dmac_interr_status_b;
  } ;
  
  union {
    __OM  uint32_t dmac_interr_clear;           /*!< (@ 0x00000010) interrupt error clear register                             */
    
    struct {
      __OM  uint32_t DMACINTERRCLR_ch0 : 1;     /*!< [0..0] Writing a 1'b1 Bit clears the error interrupt of the
                                                     specific channel 0 ,1'b0 have no effect.                                  */
      __OM  uint32_t DMACINTERRCLR_ch1 : 1;     /*!< [1..1] Writing a 1'b1 Bit clears the error interrupt of the
                                                     specific channel 1 ,1'b0 have no effect.                                  */
      __OM  uint32_t DMACINTERRCLR_ch2 : 1;     /*!< [2..2] Writing a 1'b1 Bit clears the error interrupt of the
                                                     specific channel 2 ,1'b0 have no effect.                                  */
    } dmac_interr_clear_b;
  } ;
  
  union {
    __IM  uint32_t dmac_rawinttc_status;        /*!< (@ 0x00000014) raw interrupt terminal count status register               */
    
    struct {
      __IM  uint32_t DMACRAWINTTC_ch0 : 1;      /*!< [0..0] Status of DMA channel 0 - terminal count interrupt prior
                                                     to masking. 1'b1 indicates an active interrupt request.                   */
      __IM  uint32_t DMACRAWINTTC_ch1 : 1;      /*!< [1..1] Status of DMA channel 1 - terminal count interrupt prior
                                                     to masking. 1'b1 indicates an active interrupt request.                   */
      __IM  uint32_t DMACRAWINTTC_ch2 : 1;      /*!< [2..2] Status of DMA channel 2 - terminal count interrupt prior
                                                     to masking. 1'b1 indicates an active interrupt request.                   */
    } dmac_rawinttc_status_b;
  } ;
  
  union {
    __IM  uint32_t dmac_rawinterr_status;       /*!< (@ 0x00000018) raw interrupt error status register                        */
    
    struct {
      __IM  uint32_t DMACRAWINTERR_ch0 : 1;     /*!< [0..0] Status of DMA channel 0 - error interrupt prior to masking.
                                                     1'b1 indicates an active interrupt request.                               */
      __IM  uint32_t DMACRAWINTERR_ch1 : 1;     /*!< [1..1] Status of DMA channel 1 - error interrupt prior to masking.
                                                     1'b1 indicates an active interrupt request.                               */
      __IM  uint32_t DMACRAWINTERR_ch2 : 1;     /*!< [2..2] Status of DMA channel 2 - error interrupt prior to masking.
                                                     1'b1 indicates an active interrupt request.                               */
    } dmac_rawinterr_status_b;
  } ;
  
  union {
    __IM  uint32_t dmac_enabled_channel;        /*!< (@ 0x0000001C) channel enable register                                    */
    
    struct {
      __IM  uint32_t DMACENABLEDCHNS_ch0 : 1;   /*!< [0..0] Status DMA channel 0 enable                                        */
      __IM  uint32_t DMACENABLEDCHNS_ch1 : 1;   /*!< [1..1] Status DMA channel 1 enable                                        */
      __IM  uint32_t DMACENABLEDCHNS_ch2 : 1;   /*!< [2..2] Status DMA channel 2 enable                                        */
    } dmac_enabled_channel_b;
  } ;
  
  union {
    __IOM uint32_t dmac_softb_req;              /*!< (@ 0x00000020) software burst request register                            */
    
    struct {
      __IOM uint32_t DMACSoftBReq : 16;         /*!< [15..0] Software burst request. A DMA request can be generated
                                                     for each source by writing a 1'b1 to the corresponding
                                                     register bit. Reading the register indicates which sources
                                                     are requesting DMA burst transfers.                                       */
    } dmac_softb_req_b;
  } ;
  
  union {
    __IOM uint32_t dmac_softs_req;              /*!< (@ 0x00000024) software single request register                           */
    
    struct {
      __IOM uint32_t DMACSoftSReq : 16;         /*!< [15..0] Software single request. A DMA request can be generated
                                                     for each source by writing a 1'b1 to the corresponding
                                                     register bit. Reading the register indicates which sources
                                                     are requesting DMA single transfers.                                      */
    } dmac_softs_req_b;
  } ;
  
  union {
    __IOM uint32_t dmac_softlb_req;             /*!< (@ 0x00000028) software last burst request register                       */
    
    struct {
      __IOM uint32_t DMACSoftLBReq : 16;        /*!< [15..0] Software last burst request. A DMA request can be generated
                                                     for each source by writing a 1'b1 to the corresponding
                                                     register bit. Reading the register indicates which sources
                                                     are requesting DMA last burst transfers.                                  */
    } dmac_softlb_req_b;
  } ;
  
  union {
    __IOM uint32_t dmac_softls_req;             /*!< (@ 0x0000002C) software last single request register                      */
    
    struct {
      __IOM uint32_t DMACSoftLSReq : 16;        /*!< [15..0] Software last single request. A DMA request can be generated
                                                     for each source by writing a 1'b1 to the corresponding
                                                     register bit. Reading the register indicates which sources
                                                     are requesting DMA last single transfers.                                 */
    } dmac_softls_req_b;
  } ;
  
  union {
    __IOM uint32_t dmac_config;                 /*!< (@ 0x00000030) configuration register                                     */
    
    struct {
      __IOM uint32_t DMACENABLE : 1;            /*!< [0..0] DMAC enable: 0 = disabled 1 = enabled. This bit is reset
                                                     to 0. Disabling the DMAC reduces power consumption.                       */
    } dmac_config_b;
  } ;
  
  union {
    __IOM uint32_t dmac_sync;                   /*!< (@ 0x00000034) sync register DMA synchronization logic for DMA
                                                                    request signals enabled or disabled A 1'b0
                                                                    bit indicates that the synchronization logic
                                                                    for the DMACBREQ[15:0], DMACSREQ[15:0],
                                                                    DMACLBREQ[15:0], and DMACLSREQ[15:0] request
                                                                    signals is enabled. A HIGH bit indicates
                                                                    that the synchronization logic is disabled.
                                                                    Note: Within the netX system all peripherals
                                                                    and the DMAC are running in the same clock-domain.
                                                                    Therefore, it is recommended to disable
                                                                    the synchronisation for all channels (i.e.
                                                                    write 0xfff                                                */
    
    struct {
      __IOM uint32_t DIS_SYNC   : 16;           /*!< [15..0] Disable sync register peripheral requests.                        */
    } dmac_sync_b;
  } ;
} dmac_app_reg_Type;                            /*!< Size = 56 (0x38)                                                          */



/* =========================================================================================================================== */
/* ================                                       dmac_mux_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief dmac_mux_app (dmac_mux_app)
  */

typedef struct {                                /*!< (@ 0xFF801000) dmac_mux_app Structure                                     */
  
  union {
    __IOM uint32_t dmac_mux_peripheral_input_sel0;/*!< (@ 0x00000000) Peripheral input select for DMAC input channel
                                                                    0 This register configures which peripheral
                                                                    should be connected to DMAC's input channel
                                                                    0. Note: This should not be changed while
                                                                    any of the DMA channels are performing DMA
                                                                    transfers.                                                 */
    
    struct {
      __IOM uint32_t index      : 6;            /*!< [5..0] Index of the peripheral to be connected to DMAC's input
                                                     channel 0. Default connected peripheral: uart_app_rx {
                                                     | Number Peripheral 0 uart_app_rx (default on DMAC input
                                                     channel 0) 1 uart_app_tx (default on DMAC input channel
                                                     1) 2 i2c_app_master (default on DMAC input channel 2) 3
                                                     i2c_app_slave (default on DMAC input channel 3) 4 spi0_app_rx
                                                     (default on DMAC input channel 4) 5 spi0_app_tx (default
                                                     on DMAC input channel 5) 6 spi1_app_rx 7 spi1_app_tx 8
                                                                                                                               */
    } dmac_mux_peripheral_input_sel0_b;
  } ;
  
  union {
    __IOM uint32_t dmac_mux_peripheral_input_sel1;/*!< (@ 0x00000004) Peripheral input select for DMAC input channel
                                                                    1 This register configures which peripheral
                                                                    should be connected to DMAC's input channel
                                                                    1. Note: This should not be changed while
                                                                    any of the DMA channels are performing DMA
                                                                    transfers.                                                 */
    
    struct {
      __IOM uint32_t index      : 6;            /*!< [5..0] Index of the peripheral to be connected to DMAC's input
                                                     channel 1. Default connected peripheral: uart_app_tx For
                                                     a list of available peripheral indices, see dmac_mux_peripheral_input_sel
                                                     .                                                                         */
    } dmac_mux_peripheral_input_sel1_b;
  } ;
  
  union {
    __IOM uint32_t dmac_mux_peripheral_input_sel2;/*!< (@ 0x00000008) Peripheral input select for DMAC input channel
                                                                    2 This register configures which peripheral
                                                                    should be connected to DMAC's input channel
                                                                    2. Note: This should not be changed while
                                                                    any of the DMA channels are performing DMA
                                                                    transfers.                                                 */
    
    struct {
      __IOM uint32_t index      : 6;            /*!< [5..0] Index of the peripheral to be connected to DMAC's input
                                                     channel 2. Default connected peripheral: i2c_app_master
                                                     For a list of available peripheral indices, see dmac_mux_peripheral_input
                                                     sel0.                                                                     */
    } dmac_mux_peripheral_input_sel2_b;
  } ;
  
  union {
    __IOM uint32_t dmac_mux_peripheral_input_sel3;/*!< (@ 0x0000000C) Peripheral input select for DMAC input channel
                                                                    3 This register configures which peripheral
                                                                    should be connected to DMAC's input channel
                                                                    3. Note: This should not be changed while
                                                                    any of the DMA channels are performing DMA
                                                                    transfers.                                                 */
    
    struct {
      __IOM uint32_t index      : 6;            /*!< [5..0] Index of the peripheral to be connected to DMAC's input
                                                     channel 3. Default connected peripheral: i2c_app_slave
                                                     For a list of available peripheral indices, see dmac_mux_peripheral_input
                                                     sel0.                                                                     */
    } dmac_mux_peripheral_input_sel3_b;
  } ;
  
  union {
    __IOM uint32_t dmac_mux_peripheral_input_sel4;/*!< (@ 0x00000010) Peripheral input select for DMAC input channel
                                                                    4 This register configures which peripheral
                                                                    should be connected to DMAC's input channel
                                                                    4. Note: This should not be changed while
                                                                    any of the DMA channels are performing DMA
                                                                    transfers.                                                 */
    
    struct {
      __IOM uint32_t index      : 6;            /*!< [5..0] Index of the peripheral to be connected to DMAC's input
                                                     channel 4. Default connected peripheral: spi0_app_rx For
                                                     a list of available peripheral indices, see dmac_mux_peripheral_input_sel
                                                     .                                                                         */
    } dmac_mux_peripheral_input_sel4_b;
  } ;
  
  union {
    __IOM uint32_t dmac_mux_peripheral_input_sel5;/*!< (@ 0x00000014) Peripheral input select for DMAC input channel
                                                                    5 This register configures which peripheral
                                                                    should be connected to DMAC's input channel
                                                                    5. Note: This should not be changed while
                                                                    any of the DMA channels are performing DMA
                                                                    transfers.                                                 */
    
    struct {
      __IOM uint32_t index      : 6;            /*!< [5..0] Index of the peripheral to be connected to DMAC's input
                                                     channel 5. Default connected peripheral: spi0_app_tx For
                                                     a list of available peripheral indices, see dmac_mux_peripheral_input_sel
                                                     .                                                                         */
    } dmac_mux_peripheral_input_sel5_b;
  } ;
} dmac_mux_app_Type;                            /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                         uart_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief uart_app (uart_app)
  */

typedef struct {                                /*!< (@ 0xFF801040) uart_app Structure                                         */
  
  union {
    __IOM uint32_t uartdr;                      /*!< (@ 0x00000000) data read or written from the interface                    */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] data read or written from the interface                            */
      __IOM uint32_t FE         : 1;            /*!< [8..8] Framing Error, read only, mirrored from uartrsr, to handle
                                                     in DMA-read-out data                                                      */
      __IOM uint32_t PE         : 1;            /*!< [9..9] Parity Error, read only, mirrored from uartrsr, to handle
                                                     in DMA-read-out data                                                      */
      __IOM uint32_t BE         : 1;            /*!< [10..10] Break Error, read only, mirrored from uartrsr, to handle
                                                     in DMA-read-out data                                                      */
    } uartdr_b;
  } ;
  
  union {
    __IOM uint32_t uartrsr;                     /*!< (@ 0x00000004) receive status register (read) / Error Clear
                                                                    Register (write)                                           */
    
    struct {
      __IOM uint32_t FE         : 1;            /*!< [0..0] Framing Error                                                      */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Parity Error                                                       */
      __IOM uint32_t BE         : 1;            /*!< [2..2] Break Error                                                        */
      __IOM uint32_t OE         : 1;            /*!< [3..3] Overrun Error                                                      */
    } uartrsr_b;
  } ;
  
  union {
    __IOM uint32_t uartlcr_h;                   /*!< (@ 0x00000008) Line control Register, high byte                           */
    
    struct {
      __IOM uint32_t BRK        : 1;            /*!< [0..0] Send Break                                                         */
      __IOM uint32_t PEN        : 1;            /*!< [1..1] Parity Enalble                                                     */
      __IOM uint32_t EPS        : 1;            /*!< [2..2] Even Parity Select                                                 */
      __IOM uint32_t STP2       : 1;            /*!< [3..3] 2 Stop Bits Select                                                 */
      __IOM uint32_t FEN        : 1;            /*!< [4..4] FIFO Enable                                                        */
      __IOM uint32_t WLEN       : 2;            /*!< [6..5] Word Length '00' 5 bits '01' 6 bits '10' 7 bits '11'
                                                     8 bits                                                                    */
    } uartlcr_h_b;
  } ;
  
  union {
    __IOM uint32_t uartlcr_m;                   /*!< (@ 0x0000000C) Line control Register, middle byte                         */
    
    struct {
      __IOM uint32_t BAUDDIVMS  : 8;            /*!< [7..0] bauddiv : Baud Divisor Most Significant Byte use higher
                                                     byte of bauddiv = (system clk / (16 * baud rate)) - 1 if
                                                     not alternative settings by register uartcr_2 are done                    */
    } uartlcr_m_b;
  } ;
  
  union {
    __IOM uint32_t uartlcr_l;                   /*!< (@ 0x00000010) Line control Register, low byte                            */
    
    struct {
      __IOM uint32_t BAUDDIVLS  : 8;            /*!< [7..0] Baud Divisor Least Significant Byte use lower byte of
                                                     bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative
                                                     settings by register uartcr_2 are done                                    */
    } uartlcr_l_b;
  } ;
  
  union {
    __IOM uint32_t uartcr;                      /*!< (@ 0x00000014) uart control Register                                      */
    
    struct {
      __IOM uint32_t uartEN     : 1;            /*!< [0..0] uart Enable                                                        */
      __IOM uint32_t SIREN      : 1;            /*!< [1..1] SIR Enable                                                         */
      __IOM uint32_t SIRLP      : 1;            /*!< [2..2] IrDA SIR Low Power Mode                                            */
      __IOM uint32_t MSIE       : 1;            /*!< [3..3] Modem Status Interrupt Enable                                      */
      __IOM uint32_t RIE        : 1;            /*!< [4..4] Receive Interrupt Enable                                           */
      __IOM uint32_t TIE        : 1;            /*!< [5..5] Transmit Interrupt Enable                                          */
      __IOM uint32_t RTIE       : 1;            /*!< [6..6] Receive Timeout Interrupt Enable                                   */
      __IOM uint32_t LBE        : 1;            /*!< [7..7] Loop Back Enable for IrDA mode                                     */
      __IOM uint32_t TX_RX_LOOP : 1;            /*!< [8..8] internal loop (TX -&gt; RX) (test purpose only)                    */
    } uartcr_b;
  } ;
  
  union {
    __IM  uint32_t uartfr;                      /*!< (@ 0x00000018) uart Flag Register                                         */
    
    struct {
      __IM  uint32_t CTS        : 1;            /*!< [0..0] Clear To Send                                                      */
      __IM  uint32_t DSR        : 1;            /*!< [1..1] Data Set Ready                                                     */
      __IM  uint32_t DCD        : 1;            /*!< [2..2] Data Carrier Detect                                                */
      __IM  uint32_t BUSY       : 1;            /*!< [3..3] uart BUSY                                                          */
      __IM  uint32_t RXFE       : 1;            /*!< [4..4] Receive FIFO Empty                                                 */
      __IM  uint32_t TXFF       : 1;            /*!< [5..5] Transmit FIFO Full                                                 */
      __IM  uint32_t RXFF       : 1;            /*!< [6..6] Receive FIFO Full                                                  */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO Empty                                                */
    } uartfr_b;
  } ;
  
  union {
    __IOM uint32_t uartiir;                     /*!< (@ 0x0000001C) Interrupt Identification (read) / interrupt clear
                                                                    (write)                                                    */
    
    struct {
      __IOM uint32_t MIS        : 1;            /*!< [0..0] Modem Interrupt Status                                             */
      __IOM uint32_t RIS        : 1;            /*!< [1..1] Receive Interrupt Status                                           */
      __IOM uint32_t TIS        : 1;            /*!< [2..2] Transmit Interrupt Status                                          */
      __IOM uint32_t RTIS       : 1;            /*!< [3..3] Receive Timeout Interrupt Status                                   */
    } uartiir_b;
  } ;
  
  union {
    __IOM uint32_t uartilpr;                    /*!< (@ 0x00000020) IrDA Low Power Counter Register                            */
    
    struct {
      __IOM uint32_t ILPDVSR    : 8;            /*!< [7..0] IrDA Low Power Divisor                                             */
    } uartilpr_b;
  } ;
  
  union {
    __IOM uint32_t uartrts;                     /*!< (@ 0x00000024) RTS Control Register                                       */
    
    struct {
      __IOM uint32_t AUTO       : 1;            /*!< [0..0] automatic or controlled by the next bit (RTS)                      */
      __IOM uint32_t RTS        : 1;            /*!< [1..1] if AUTO=0: controlled by this bit                                  */
      __IOM uint32_t COUNT      : 1;            /*!< [2..2] count base: 1=system clocks, 0=time in bauds                       */
      __IOM uint32_t MOD2       : 1;            /*!< [3..3] mode1/mode2                                                        */
      __IOM uint32_t RTS_pol    : 1;            /*!< [4..4] RTS polarity: 1=active high                                        */
      __IOM uint32_t CTS_ctr    : 1;            /*!< [5..5] nUARTCTS control                                                   */
      __IOM uint32_t CTS_pol    : 1;            /*!< [6..6] nUARTCTS polarity: 1=active high                                   */
      __IOM uint32_t STICK      : 1;            /*!< [7..7] stick parity                                                       */
    } uartrts_b;
  } ;
  
  union {
    __IOM uint32_t uartforerun;                 /*!< (@ 0x00000028) RTS forerun cycles                                         */
    
    struct {
      __IOM uint32_t FORERUN    : 8;            /*!< [7..0] number of forerun cycles in system clocks or bauds                 */
    } uartforerun_b;
  } ;
  
  union {
    __IOM uint32_t uarttrail;                   /*!< (@ 0x0000002C) RTS trail cycles                                           */
    
    struct {
      __IOM uint32_t TRAIL      : 8;            /*!< [7..0] number of trail cycles in system clocks or bauds                   */
    } uarttrail_b;
  } ;
  
  union {
    __IOM uint32_t uartdrvout;                  /*!< (@ 0x00000030) Drive Output                                               */
    
    struct {
      __IOM uint32_t DRVTX      : 1;            /*!< [0..0] enable driver for TX                                               */
      __IOM uint32_t DRVRTS     : 1;            /*!< [1..1] enable driver for RTS                                              */
    } uartdrvout_b;
  } ;
  
  union {
    __IOM uint32_t uartcr_2;                    /*!< (@ 0x00000034) Control Register 2                                         */
    
    struct {
      __IOM uint32_t Baud_Rate_Mode : 1;        /*!< [0..0] If this bit is set the baud rate is generated more exactly
                                                     by the following formula: value = ( (Baud Rate * 16) /
                                                     System Frequency ) * 2^16 . You have to write this 16-bit
                                                     value in register uartlcr_l and uartlcr_m.                                */
    } uartcr_2_b;
  } ;
  
  union {
    __IOM uint32_t uartrxiflsel;                /*!< (@ 0x00000038) RX FIFO trigger level and RX-DMA enable                    */
    
    struct {
      __IOM uint32_t RXIFLSEL   : 5;            /*!< [4..0] Choose a number between 1 and 16. It defines the IRQ
                                                     trigger level of the receive fifo. The IRQ (UARTRXINTR)
                                                     will be set if the number of received bytes in the receive
                                                     fifo are greater than or equal RXIFLSEL.                                  */
      __IOM uint32_t RXDMA      : 1;            /*!< [5..5] Enable DMA-requests for RX-fifo-data. A request will
                                                     be generated if RX-FIFO is not empty and uartcr.uartEN
                                                     (module enable) is set. Burst request to DMA-Ctrl will
                                                     be done if the RX-FIFO contains at least 4 words (set DMA-burst-size
                                                     to 4) If this bit is reset or the module is disabled, DMA-request
                                                     will also be reset. single transfer request: RX-FIFO contains
                                                     1 byte or more, burst request: 4 bytes or more note: set
                                                     adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the
                                                     DMA module                                                                */
    } uartrxiflsel_b;
  } ;
  
  union {
    __IOM uint32_t uarttxiflsel;                /*!< (@ 0x0000003C) TX FIFO trigger level and TX-DMA enable                    */
    
    struct {
      __IOM uint32_t TXIFLSEL   : 5;            /*!< [4..0] Choose a number between 1 and 16. It defines the IRQ
                                                     trigger level of the transmit fifo. The IRQ (UARTTXINTR)
                                                     will be set if the number of transmitted bytes in the transmit
                                                     fifo are less than TXIFLSEL.                                              */
      __IOM uint32_t TXDMA      : 1;            /*!< [5..5] Enable DMA-requests for TX-fifo-data. A request will
                                                     be generated if TX-FIFO is not full and uartcr.uartEN (module
                                                     enable) is set. Burst request to DMA-Ctrl will be done
                                                     if at least 4 words are writable to the TX-FIFO (set DMA-burst-size
                                                     to 4) If this bit is reset or the module is disabled, DMA-request
                                                     will also be reset. note: set adr_dmac_chctrl.DBSize =
                                                     1 (i.e. burst size: 4) in the DMA module                                  */
    } uarttxiflsel_b;
  } ;
} uart_app_Type;                                /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                          i2c_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief i2c_app (i2c_app)
  */

typedef struct {                                /*!< (@ 0xFF801080) i2c_app Structure                                          */
  
  union {
    __IOM uint32_t i2c_mcr;                     /*!< (@ 0x00000000) I2C master control register:                               */
    
    struct {
      __IOM uint32_t en_i2c     : 1;            /*!< [0..0] Global I2C controller enable 1: Enable I2C controller
                                                     0: Disable I2C controller Disabling the I2C module during
                                                     a transfer will immediately disconnect the I2C module from
                                                     the bus without generating a STOP. The internal I2C state
                                                     machine will be set back to initial/idle state. The I2C
                                                     bus-state-detection for the bits i2c_sr.bus_master and
                                                     i2c_sr.started are performed even if the module is disabled.
                                                     For details, see these bits.                                              */
      __IOM uint32_t mode       : 3;            /*!< [3..1] I2C-speed-mode: If this device is used as a slave only,
                                                     the mode should be set to the data rate generated by the
                                                     fastest master on the I2C-bus for appropriate input filtering
                                                     and spike suppression. 000: Fast/Standard mode, 50 kbit/s
                                                     001: Fast/Standard mode, 100 kbit/s 010: Fast/Standard
                                                     mode, 200 kbit/s 011: Fast/Standard mode, 400 kbit/s 100:
                                                     High-speed mode, 800 kbit/s 101: High-speed mode, 1.2 Mbit/s
                                                     110: High-speed mode, 1.7 Mbit/s 111: High-speed mode,
                                                     3.4 Mbit/s)                                                               */
      __IOM uint32_t sadr       : 7;            /*!< [10..4] 7-bit slave address sent after (r)START: For 10-bit
                                                     addressing, the first byte (10-bit start '11110', address
                                                     bits[9:8] must be programmed here. The second start byte
                                                     (lower slave address bits) must be on top of the master
                                                     FIFO (i2c_mdr). This register must be rewritten (even if
                                                     the value does not change) to address another slave in
                                                     the 10-bit mode (run 2-byte start sequence). The register
                                                     must not be rewritten before a repeated START on the same
                                                     10-bit addressed slave (run 1-byte start sequence e.g.
                                                     write                                                                     */
      __IOM uint32_t reserved0  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_mode   : 1;            /*!< [16..16] If this bit is set, SCL and SDA can be controlled directly
                                                     by register i2c_pio (e.g. to access devices being incompatible
                                                     with I2C). In PIO mode, the I2C controller state machine
                                                     is disabled: FIFOs are not used, no IRQs will be set, and
                                                     no DMA controlling is possible.                                           */
      __IOM uint32_t rst_i2c    : 1;            /*!< [17..17] Reset the I2C bus-state-detection logic. To avoid conflicts
                                                     with other masters, some I2C bus states, which are important
                                                     when there are multiple masters on the I2C bus, are always
                                                     monitored, even if the I2C module is disabled. For details,
                                                     see bits i2c_sr.started and i2c.bus_master. However, it
                                                     may happen that bus states are detected which lock up the
                                                     I2C module. E.g. hazards during power-up or IO configuration
                                                     or sequences, which are not I2C compliant, can cause a
                                                     lock-up. This bit can be used to escap                                    */
      __IOM uint32_t en_timeout : 1;            /*!< [18..18] Enable I2C command timeout detection. Enabling the
                                                     timeout detection is recommended to prevent the module
                                                     from stalling if another device holds the I2C signals permanently
                                                     low. For details, see the description of bit i2s_sr.timeout.              */
      __IOM uint32_t reserved1  : 13;           /*!< [31..19] reserved                                                         */
    } i2c_mcr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_scr;                     /*!< (@ 0x00000004) I2C slave control register:                                */
    
    struct {
      __IOM uint32_t sid        : 10;           /*!< [9..0] Slave device ID/address: External masters can address
                                                     this device (this I2C module in slave mode) by the ID/address
                                                     programmed here. If sid10 is not set, bits 9 to 7 will
                                                     be ignored.                                                               */
      __IOM uint32_t sid10      : 1;            /*!< [10..10] 10-bit slave device ID/address: 0: Wait for 7-bit slave
                                                     address after (r)START 1: Wait for 10-bit slave address
                                                     after (r)START                                                            */
      __IOM uint32_t reserved0  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t ac_srx     : 1;            /*!< [16..16] Enable slave-receive-data acknowledge: 0: Do not acknowledge
                                                     receive bytes 1: Acknowledge receive bytes If the slave
                                                     FIFO is full, receive data will not be acknowledged.                      */
      __IOM uint32_t ac_start   : 1;            /*!< [17..17] Enable start sequence acknowledge: If the received
                                                     address matches the sid-bits, the start-byte (2 bytes if
                                                     sid10 is set) will be acknowledged. If the master requests
                                                     a read transfer, a slave FIFO read access will be carried
                                                     out immediately after the acknowledge, i.e. valid data
                                                     must be present in the slave FIFO before enabling the acknowledge.
                                                     If autoreset_ac_start is enabled, the controller will automatically
                                                     reset this bit. If it is not enabled, the software should
                                                     reset this bit after the start sequenc                                    */
      __IOM uint32_t ac_gcall   : 1;            /*!< [18..18] General call acknowledge: 0: Do not generate an acknowledge
                                                     after a general call 1: Generate an acknowledge after a
                                                     general call                                                              */
      __IOM uint32_t reserved1  : 1;            /*!< [19..19] reserved                                                         */
      __IOM uint32_t autoreset_ac_start : 1;    /*!< [20..20] Auto reset ac_start (ac_start must be set again after
                                                     any (r)START): 0: ac_start will not be reset automatically
                                                     (netX 50-compatible, but not recommended) 1: Reset ac_start
                                                     after this slave acknowledged a start sequence (recommended)              */
      __IOM uint32_t reserved2  : 11;           /*!< [31..21] reserved                                                         */
    } i2c_scr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_cmd;                     /*!< (@ 0x00000008) I2C master command register:                               */
    
    struct {
      __IOM uint32_t nwr        : 1;            /*!< [0..0] Transfer direction (not-write/read): 0: cmd will be executed
                                                     as write 1: cmd will be executed as read Master FIFO-requests
                                                     (IRQ and DMA) are generated depending on this direction
                                                     flag.                                                                     */
      __IOM uint32_t cmd        : 3;            /*!< [3..1] I2C sequence command: All commands will generate IRQ
                                                     cmd_ok or IRQ cmd_err. A successful command termination
                                                     will always generate IRQ cmd_ok. In case of an unsuccessful
                                                     command termination, IRQ cmd_err will be set. { | | 000
                                                     START Generate (r)START-condition 001 S_AC Acknowledge-polling:
                                                     generate up to acpollmax+1 START-sequences (until acknowledged
                                                     by slave) 010 S_AC_T Run S_AC, then transfer tsize+1 bytes
                                                     from/to master FIFO. Not to be continued 011 S_AC_TC Run
                                                     S_AC, then tr                                                             */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t tsize      : 10;           /*!< [17..8] Transfer tsize+1 bytes (1...1024): If no acknowledge
                                                     is generated by the slave (receiver), write transfers will
                                                     be terminated and IRQ cmd_err will be generated. For 10-bit-addressing,
                                                     the second start-byte (lower address bits) must be on top
                                                     of the master FIFO. For subsequent transfers, the value
                                                     programmed here has to ignore this byte. This value will
                                                     count down during transfers after each byte. This bit is
                                                     writable, but can also be changed by hardware.                            */
      __IOM uint32_t reserved1  : 2;            /*!< [19..18] reserved                                                         */
      __IOM uint32_t acpollmax  : 8;            /*!< [27..20] Number of tries (acpollmax+1, i.e. 1 to 256) for start
                                                     sequence acknowledge polling: For 7-bit addressing, acknowledge
                                                     polling START and the first byte containing the slave address
                                                     (i2c_mcr.sadr) will be repeated up to acpollmax+1 times
                                                     until a slave generates an acknowledge. If no acknowledge
                                                     is received within acpollmax+1 tries, IRQ cmd_err will
                                                     be generated. For 10-bit-addressing, the 2-byte start sequence
                                                     is performed. The second address byte (lower address bits)
                                                     must be on top of the master FIFO (i2c_                                   */
      __IOM uint32_t reserved2  : 4;            /*!< [31..28] reserved                                                         */
    } i2c_cmd_b;
  } ;
  
  union {
    __IOM uint32_t i2c_mdr;                     /*!< (@ 0x0000000C) I2C master data register (master FIFO): There
                                                                    is only one FIFO for both receive and transmit
                                                                    master data with a depth of 16 bytes. For
                                                                    master write access, data sent by the master
                                                                    is delivered from the FIFO. For master read
                                                                    access, data received by the master is stored
                                                                    in the FIFO. In case of imminent data transfer
                                                                    failure (read transfer and FIFO is full
                                                                    or write transfer and FIFO is empty), the
                                                                    transfer will be interrupted. To continue
                                                                    the transfer, the FIFO must be handled first
                                                                    (filled fo                                                 */
    
    struct {
      __IOM uint32_t mdata      : 8;            /*!< [7..0] I2C master transmit or receive data: Write data will
                                                     be removed from the FIFO after the receiving slave has
                                                     generated the corresponding acknowledge. Write data that
                                                     has not been acknowledged will not be removed from the
                                                     FIFO.                                                                     */
    } i2c_mdr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_sdr;                     /*!< (@ 0x00000010) I2C slave data register (slave FIFO): There is
                                                                    only one FIFO for both receive and transmit
                                                                    slave data with a depth of 16 bytes. For
                                                                    master read access, data sent by the slave
                                                                    is delivered from the FIFO. For master write
                                                                    access, data received by the slave is stored
                                                                    in the FIFO. A transfer is initiated after
                                                                    the detection of I2C-start-sequence to the
                                                                    device address (i2c_scr.sid, sreq IRQ) which
                                                                    is acknowledged by this device (i2c_scr.ac_start).
                                                                    For read transfers, sent data is read from
                                                                    the FI                                                     */
    
    struct {
      __IOM uint32_t sdata      : 8;            /*!< [7..0] I2C slave transmit or receive data: The software must
                                                     handle i2c_scr.ac_start correctly to avoid FIFO errors
                                                     after (r)START.                                                           */
    } i2c_sdr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_mfifo_cr;                /*!< (@ 0x00000014) I2C master FIFO control register:                          */
    
    struct {
      __IOM uint32_t mfifo_wm   : 4;            /*!< [3..0] Master FIFO watermark for the generation of IRQ mfifo_req:
                                                     If the master is the transmitter (enabled and i2c_cmd.nwr
                                                     is 0), IRQ mfifo_req is generated if mfifo_level&lt;mfifo_wm.
                                                     If the master is the receiver (enabled and i2c_cmd.nwr
                                                     is 1), IRQ mfifo_req is generated if mfifo_level&gt;mfifo_wm.
                                                     Note: Set the watermark to 0 at transfer end to avoid further
                                                     IRQ generation.                                                           */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t mfifo_clr  : 1;            /*!< [8..8] Clear master data FIFO, write only bit. This bit is writable,
                                                     but can also be changed by hardware.                                      */
      __IOM uint32_t reserved1  : 23;           /*!< [31..9] reserved                                                          */
    } i2c_mfifo_cr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_sfifo_cr;                /*!< (@ 0x00000018) I2C slave FIFO control register:                           */
    
    struct {
      __IOM uint32_t sfifo_wm   : 4;            /*!< [3..0] Slave FIFO watermark for the generation of IRQ sfifo_req:
                                                     If the slave is the transmitter (start sequence with set
                                                     read bit was acknowledged by this slave), IRQ sfifo_req
                                                     is generated if sfifo_level&lt;sfifo_wm. If the slave is
                                                     not the transmitter (is receiver or not selected), IRQ
                                                     sfifo_req is generated if sfifo_level&gt;sfifo_wm.                        */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t sfifo_clr  : 1;            /*!< [8..8] Clear slave data FIFO, write only bit. This bit is writable,
                                                     but can also be changed by hardware.                                      */
      __IOM uint32_t reserved1  : 23;           /*!< [31..9] reserved                                                          */
    } i2c_sfifo_cr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_sr;                      /*!< (@ 0x0000001C) I2C status register:                                       */
    
    struct {
      __IOM uint32_t mfifo_level : 5;           /*!< [4..0] Master FIFO level (0..16) This is a read-only status
                                                     bit field.                                                                */
      __IOM uint32_t reserved0  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t mfifo_empty : 1;           /*!< [6..6] Master FIFO is empty (1 if empty) This is a read-only
                                                     status bit.                                                               */
      __IOM uint32_t mfifo_full : 1;            /*!< [7..7] Master FIFO is full (1 if full) This is a read-only status
                                                     bit.                                                                      */
      __IOM uint32_t mfifo_err_ovfl : 1;        /*!< [8..8] Master FIFO overflow error occurred. Data is lost and
                                                     the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr.
                                                     Clearing the master FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t mfifo_err_undr : 1;        /*!< [9..9] Master FIFO underrun error occurred. Data is lost and
                                                     the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr.
                                                     Clearing the master FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_level : 5;           /*!< [14..10] Slave FIFO level (0..16) This is a read-only status
                                                     bit field.                                                                */
      __IOM uint32_t reserved1  : 1;            /*!< [15..15] reserved                                                         */
      __IOM uint32_t sfifo_empty : 1;           /*!< [16..16] Slave FIFO is empty (1 if empty) This is a read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_full : 1;            /*!< [17..17] Slave FIFO is full (1 if full) This is a read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_err_ovfl : 1;        /*!< [18..18] Slave FIFO overflow error occurred. Data is lost and
                                                     the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr.
                                                     Clearing the slave FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_err_undr : 1;        /*!< [19..19] Slave FIFO underrun error occurred. Data is lost and
                                                     the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr.
                                                     Clearing the slave FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t bus_master : 1;            /*!< [20..20] Bus arbitration state. 0: Master lost I2C bus arbitration,
                                                     bus is busy by another master. 1: Master gains I2C bus
                                                     arbitration or bus is idle. This read-only status bit is
                                                     set when the monitored bus state does not match the bus
                                                     state expected by the I2C module. The bit is reset, when
                                                     a STOP is detected. This detection will also take place
                                                     while the module is disabled. This is important if there
                                                     are multiple I2C masters on the bus: If another master
                                                     occupies the bus while the I2C module is disabled, the
                                                     I2C                                                                       */
      __IOM uint32_t nwr        : 1;            /*!< [21..21] Transfer direction detected after last (r)START. 0:
                                                     The last start-byte defined a write transfer. 1: The last
                                                     start-byte defined a read transfer. This read-only status
                                                     bit is always reset to 0 during (r)START. This bit is forced
                                                     to '0' when bit i2c_mcr.rst_i2c performs a reset of the
                                                     bus-state-detection logic. Note: This bit does not depend
                                                     on whether the start-byte has been acknowledged or not.                   */
      __IOM uint32_t started    : 1;            /*!< [22..22] START condition detection: 0: The bus is idle (STOP
                                                     was detected, not started). 1: (r)START was detected on
                                                     the bus. The bus is occupied. This detection will also
                                                     take place while the module is disabled. This is important
                                                     if there are multiple I2C masters on the bus: If another
                                                     master occupies the bus while the I2C module is disabled,
                                                     the I2C module must not start a transfer, before the other
                                                     master has released the bus. Use bit i2c_mcr.rst_i2c to
                                                     force this read-only status bit to '0', e.g. in order to
                                                     es                                                                        */
      __IOM uint32_t slave_access : 1;          /*!< [23..23] Slave access state. 0: No slave access to this device.
                                                     1: A master addressed this slave device. This read-only
                                                     status bit is set if a start-byte (2 bytes for 10-bit address)
                                                     containing the address programmed in register i2c_scr.sid
                                                     has been received. This bit is always reset to 0 during
                                                     START or STOP. This bit is forced to '0' when bit i2c_mcr.rst_i2c
                                                     performs a reset of the bus-state-detection logic. Note:
                                                     This bit does not depend on whether the start-byte has
                                                     been acknowledged or not.                                                 */
      __IOM uint32_t last_ac    : 1;            /*!< [24..24] Last acknowledge detected on bus. 0: SDA was high at
                                                     the last acknowledge, i.e. no acknowledge. 1: SDA was low
                                                     at the last acknowledge, i.e. acknowledge. This read-only
                                                     status bit is forced to '0' when bit i2c_mcr.rst_i2c performs
                                                     a reset of the bus-state-detection logic.                                 */
      __IOM uint32_t nwr_aced   : 1;            /*!< [25..25] Transfer direction (nwr-bit) of the last acknowledged
                                                     start-byte (or 2-byte start sequence for 10-bit addressing).
                                                     0: The last acknowledged start-byte defined a write transfer.
                                                     1: The last acknowledged start-byte defined a read transfer.
                                                     Slave FIFO requests generating IRQ and DMA requests depend
                                                     on this direction flag. This read-only status bit is forced
                                                     to '0' when bit i2c_mcr.rst_i2c performs a reset of the
                                                     bus-state-detection logic.                                                */
      __IOM uint32_t gcall_aced : 1;            /*!< [26..26] General call acknowledge state. 0: No general call
                                                     start-byte, or general call start-byte was not acknowledged.
                                                     1: The slave side of the i2c module received and acknowledged
                                                     a general call. Bit i2c_scr.ac_gcall controls the acknowledging
                                                     of a general call. This read-only status bit will be cleared
                                                     automatically if the last start-byte is not a general call
                                                     or if it is a general call but bit i2c_scr.ac_gcall is
                                                     not set. This bit is forced to '0' when the bit i2c_mcr.rst_i2c
                                                     performs a reset of the bus-stat                                          */
      __IOM uint32_t sid10_aced : 1;            /*!< [27..27] 10-bit slave address acknowledge state. { | 0: There
                                                     was no 10-bit slave address or it was not acknowledged.
                                                     1: A 10-bit slave address was broadcasted and a slave acknowledged
                                                     this broadcast. I.e. for the master side: A 10-bit slave
                                                     was addressed and the slave acknowledged. I.e. for the
                                                     slave side: A master broadcasted a start with the address
                                                     programmed in register i2c_scr.sid and the i2c module acknowledged
                                                     this broadcast as bit i2c_scr.ac_start is set.} This read-only
                                                     status bit is cleared automaticall                                        */
      __IOM uint32_t timeout    : 1;            /*!< [28..28] I2C command timeout detection (for I2C master). I2C
                                                     slaves can stretch low SCL phases by holding the SCL line
                                                     low. The master must detect this and wait until the SCL
                                                     line is released before the current transfer can continue.
                                                     In error cases, the I2C bus can be blocked permanently
                                                     by a low signal state of SCL. The reason for the blocking
                                                     can be e.g. a crashed I2C slave or a false I/O configuration.
                                                     To escape from such a situation, a timeout watchdog is
                                                     implemented: A timeout will be detected if the SCL line
                                                                                                                               */
      __IOM uint32_t reserved2  : 1;            /*!< [29..29] reserved                                                         */
      __IOM uint32_t scl_state  : 1;            /*!< [30..30] SCL signal state sampled and filtered from bus (e.g.
                                                     to detect bus blockings) This is a read-only status bit.                  */
      __IOM uint32_t sda_state  : 1;            /*!< [31..31] SDA signal state sampled and filtered from bus (e.g.
                                                     to detect bus blockings) This is a read-only status bit.                  */
    } i2c_sr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_irqmsk;                  /*!< (@ 0x00000020) I2C interrupt mask set or clear register: These
                                                                    bits have AND-mask character. The corresponding
                                                                    IRQ will generate the module IRQ only if
                                                                    the mask bit is set. Changing a mask bit
                                                                    from '0' to '1' will clear the corresponding
                                                                    raw IRQ state. For a detailed IRQ description,
                                                                    see i2c_irqraw.                                            */
    
    struct {
      __IOM uint32_t cmd_ok     : 1;            /*!< [0..0] Command OK interrupt mask                                          */
      __IOM uint32_t cmd_err    : 1;            /*!< [1..1] Command error interrupt mask                                       */
      __IOM uint32_t fifo_err   : 1;            /*!< [2..2] FIFO error interrupt mask                                          */
      __IOM uint32_t bus_busy   : 1;            /*!< [3..3] External I2C-bus is busy interrupt mask                            */
      __IOM uint32_t mfifo_req  : 1;            /*!< [4..4] Master FIFO action request interrupt mask                          */
      __IOM uint32_t sfifo_req  : 1;            /*!< [5..5] Slave FIFO action request interrupt mask                           */
      __IOM uint32_t sreq       : 1;            /*!< [6..6] Slave request interrupt mask                                       */
    } i2c_irqmsk_b;
  } ;
  
  union {
    __IOM uint32_t i2c_irqsr;                   /*!< (@ 0x00000024) I2C interrupt state register (raw interrupt before
                                                                    masking): Writing '1' will clear the corresponding
                                                                    IRQ.                                                       */
    
    struct {
      __IOM uint32_t cmd_ok     : 1;            /*!< [0..0] Unmasked command OK interrupt state: Purpose: Check last
                                                     command termination 1: Last command finished successfully
                                                     0: Command not finished, no command or command finished
                                                     erroneously                                                               */
      __IOM uint32_t cmd_err    : 1;            /*!< [1..1] Unmasked command error interrupt state: Purpose: Check
                                                     last command termination 1: Last command finished erroneously
                                                     0: Command not finished, no command or command finished
                                                     successfully                                                              */
      __IOM uint32_t fifo_err   : 1;            /*!< [2..2] Unmasked FIFO error interrupt state: Purpose: Detect
                                                     FIFO errors/transfer failures 1: FIFO error occurred, check
                                                     register i2c_sr 0: FIFOs ok                                               */
      __IOM uint32_t bus_busy   : 1;            /*!< [3..3] Unmasked external I2C-bus is busy interrupt state: Purpose:
                                                     Detect I2C-bus arbitration loss 1: Master did not gain
                                                     the requested bus access because another master accessed
                                                     the bus 0: Bus is idle or no transfer is requested by this
                                                     master                                                                    */
      __IOM uint32_t mfifo_req  : 1;            /*!< [4..4] Unmasked master FIFO action request interrupt state:
                                                     Purpose: Master FIFO should be updated 1: Master FIFO request:
                                                     i2c_sr.mfifo_level is above or below i2c_mfifo_cr.mfifo_wm
                                                     (see description i2c_mfifo_cr) 0: Master FIFO state not
                                                     critical                                                                  */
      __IOM uint32_t sfifo_req  : 1;            /*!< [5..5] Unmasked slave FIFO action request interrupt state: Purpose:
                                                     Slave FIFO should be updated 1: Slave FIFO request: i2c_sr.sfifo_level
                                                     is above or below i2c_sfifo_cr.sfifo_wm (see description
                                                     i2c_sfifo_cr) 0: Slave FIFO state not critical                            */
      __IOM uint32_t sreq       : 1;            /*!< [6..6] Unmasked slave request interrupt state: Purpose: Set
                                                     up slave FIFO 1: External master was running START-sequence
                                                     and requested this slave 0: Slave is not requested                        */
    } i2c_irqsr_b;
  } ;
  
  union {
    __IM  uint32_t i2c_irqmsked;                /*!< (@ 0x00000028) I2C masked interrupt state register: If one of
                                                                    these bits is set, the I2C IRQ will be set
                                                                    to the interrupt controller. For a detailed
                                                                    IRQ description, see i2c_irqraw.                           */
    
    struct {
      __IM  uint32_t cmd_ok     : 1;            /*!< [0..0] Masked command OK interrupt state                                  */
      __IM  uint32_t cmd_err    : 1;            /*!< [1..1] Masked command error interrupt state                               */
      __IM  uint32_t fifo_err   : 1;            /*!< [2..2] Masked FIFO error interrupt state                                  */
      __IM  uint32_t bus_busy   : 1;            /*!< [3..3] Masked external I2C-bus is busy interrupt state                    */
      __IM  uint32_t mfifo_req  : 1;            /*!< [4..4] Masked master FIFO action request interrupt state                  */
      __IM  uint32_t sfifo_req  : 1;            /*!< [5..5] Masked slave FIFO action request interrupt state                   */
      __IM  uint32_t sreq       : 1;            /*!< [6..6] Masked slave request interrupt state                               */
    } i2c_irqmsked_b;
  } ;
  
  union {
    __IOM uint32_t i2c_dmacr;                   /*!< (@ 0x0000002C) I2C DMA control register: Required settings for
                                                                    the DMA controller: - DMA transfer size
                                                                    to/from I2C module: Byte - DMA burst length
                                                                    to/from I2C module: 4 DMA burst requests
                                                                    will be generated if the corresponding FIFO
                                                                    contains more than 4 bytes (receive case)
                                                                    or if more than 4 bytes are writable to
                                                                    the corresponding FIFO (transmit case).
                                                                    DMA single transfer requests will be generated
                                                                    if the corresponding FIFO contains more
                                                                    than 1 byte (receive case) or if more than
                                                                    1 byte is writable to the c                                */
    
    struct {
      __IOM uint32_t mdmas_en   : 1;            /*!< [0..0] Enable DMA single requests for I2C master data. The I2C
                                                     module is the flow controller (i.e. peripheral-controlled
                                                     flow control). Both, single and burst requests must be
                                                     enabled. This bit is writable, but can also be changed
                                                     by hardware.                                                              */
      __IOM uint32_t mdmab_en   : 1;            /*!< [1..1] Enable DMA burst requests for I2C master data. The I2C
                                                     module is the flow controller (i.e. peripheral-controlled
                                                     flow control). Both, single and burst requests must be
                                                     enabled. This bit is writable, but can also be changed
                                                     by hardware.                                                              */
      __IOM uint32_t sdmas_en   : 1;            /*!< [2..2] Enable DMA single requests for I2C slave data. The DMA
                                                     controller must be the flow controller. This bit is writable,
                                                     but can also be changed by hardware.                                      */
      __IOM uint32_t sdmab_en   : 1;            /*!< [3..3] Enable DMA burst requests for I2C slave data. The DMA
                                                     controller must be the flow controller. This bit is writable,
                                                     but can also be changed by hardware.                                      */
    } i2c_dmacr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_pio;                     /*!< (@ 0x00000030) PIO mode register: This register can directly
                                                                    control the I2C signals SCL and SDA if pio_mode
                                                                    is enabled in register i2c_mcr. In PIO mode,
                                                                    the I2C controller state machine is disabled,
                                                                    thus, no FIFO action takes place, no IRQs
                                                                    will be set, and no DMA-controlling is possible.
                                                                    Note: To avoid external driving conflicts,
                                                                    the I2C signals SCL and SDA are never driven
                                                                    active-high according to the I2C bus specification.
                                                                    The high level of these signals is realized
                                                                    by a pull-up (of the pad or external                       */
    
    struct {
      __IOM uint32_t scl_out    : 1;            /*!< [0..0] Driving level of SCL (1: high, 0: low) if output is enabled
                                                     (scl_oe is set)                                                           */
      __IOM uint32_t scl_oe     : 1;            /*!< [1..1] SCL output enable 0: Do not drive SCL, switch pad to
                                                     high-z. 1: Drive SCL, switch pad to programmed scl_out-state              */
      __IOM uint32_t scl_in_ro  : 1;            /*!< [2..2] SCL input state (read-only)                                        */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t sda_out    : 1;            /*!< [4..4] Driving level of SDA (1: high, 0: low) if output is enabled
                                                     (sda_oe is set)                                                           */
      __IOM uint32_t sda_oe     : 1;            /*!< [5..5] SDA output enable 0: Do not drive SDA, switch pad to
                                                     high-z. 1: Drive SDA, switch pad to programmed sda_out-state              */
      __IOM uint32_t sda_in_ro  : 1;            /*!< [6..6] SDA input state (read-only)                                        */
      __IOM uint32_t reserved1  : 25;           /*!< [31..7] reserved                                                          */
    } i2c_pio_b;
  } ;
} i2c_app_Type;                                 /*!< Size = 52 (0x34)                                                          */



/* =========================================================================================================================== */
/* ================                                       mled_ctrl_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief mled_ctrl_app (mled_ctrl_app)
  */

typedef struct {                                /*!< (@ 0xFF801100) mled_ctrl_app Structure                                    */
  
  union {
    __IOM uint32_t mled_ctrl_app_cfg;           /*!< (@ 0x00000000) Global configuration register. This register
                                                                    controls global configuration options for
                                                                    all Multi-LED outputs. Description of Multi-LED
                                                                    control module operation: a) Time-multiplexed
                                                                    PWM mode: Each output drives two LEDs: Low-side
                                                                    and high-side LED. Three states of the output
                                                                    pin are possible: High (i.e. the low-side
                                                                    LED is on), low (i.e. the high-side LED
                                                                    is on), or high-z (i.e. both LEDs are off).
                                                                    The PWM period, determined by bit field
                                                                    prescale_counter_max, is the same for all
                                                                    outputs. The                                               */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] Writing a '1' to this bit will enable the MLED_CTRL_APP
                                                     module. When disabled, all counters will be stopped to
                                                     save power and outputs will be switched to high-z state.                  */
      __IOM uint32_t prescale_counter_max : 10; /*!< [10..1] Maximum value the prescale counter will count to. The
                                                     prescale counter determines the PWM frequency of all outputs:
                                                     f_pwm = f_clk / (512 * (prescale_counter_max + 1)) prescale_counter_max
                                                     = (f_clk / (512 * f_pwm)) - 1 with f_clk = 100 MHz (netX
                                                     system frequency). The range of the PWM frequency is therefore
                                                     within ~191 Hz and ~195 kHz.                                              */
      __IOM uint32_t blink_counter_max : 9;     /*!< [19..11] Maximum value the blink counter will count to. The
                                                     blink counter determines the blink frequency: f_blink =
                                                     50 Hz / (blink_counter_max + 1) blink_counter_max = (50
                                                     Hz / f_blink) - 1. The range of the blink frequency is
                                                     therefore within ~0.1 Hz and 50 Hz.                                       */
    } mled_ctrl_app_cfg_b;
  } ;
  
  union {
    __IOM uint32_t mled_ctrl_app_output_sel[16];/*!< (@ 0x00000004) Output 0 phase 0 (high-side LED) configuration.            */
    
    struct {
      __IOM uint32_t inv        : 1;            /*!< [0..0] Invert input signal.                                               */
      __IOM uint32_t sel        : 2;            /*!< [2..1] Selection of the signal connected to this output. { |
                                                     Value Input 0 always off 1 line register 2 MLED_CTRL blink
                                                     3 pass-through (for phase 0 registers) / reserved (for
                                                     phase 1 registers) }                                                      */
    } mled_ctrl_app_output_sel_b[16];
  } ;
  
  union {
    __IOM uint32_t mled_ctrl_app_output_on_time[16];/*!< (@ 0x00000044) Output 0 phase 0 (high-side LED) switch-on time.       */
    
    struct {
      __IOM uint32_t val        : 8;            /*!< [7..0] Switch-on time of this LED. This value determines the
                                                     period during which the output is active. The value helps
                                                     achieve a consistent brightness of different LED types.
                                                     Dimming individual LEDs is also possible. Possible values
                                                     are 0 (off) to 255 (on for the full phase minus one PWM
                                                     tick).                                                                    */
    } mled_ctrl_app_output_on_time_b[16];
  } ;
  
  union {
    __IOM uint32_t mled_ctrl_app_line;          /*!< (@ 0x00000084) Line register. The line register allows changing
                                                                    all LEDs (configured to line mode) at once
                                                                    to a new value. Note: The change will take
                                                                    effect at the start of the next PWM period
                                                                    (when the output operates in time-multiplexed
                                                                    PWM mode). In pass-through mode, the change
                                                                    will take effect immediately.                              */
    
    struct {
      __IOM uint32_t val        : 16;           /*!< [15..0] MLED output values 15..0 when line mode is selected
                                                     in the corresponding 'sel' register.                                      */
    } mled_ctrl_app_line_b;
  } ;
} mled_ctrl_app_Type;                           /*!< Size = 136 (0x88)                                                         */



/* =========================================================================================================================== */
/* ================                                       ecc_ctrl_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief ecc_ctrl_app (ecc_ctrl_app)
  */

typedef struct {                                /*!< (@ 0xFF801200) ecc_ctrl_app Structure                                     */
  
  union {
    __IOM uint32_t ecc_ctrl_intram0_ctrl;       /*!< (@ 0x00000000) INTRAM0 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram0_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intram1_ctrl;       /*!< (@ 0x00000004) INTRAM1 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram1_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intram2_ctrl;       /*!< (@ 0x00000008) INTRAM2 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram2_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intram3_ctrl;       /*!< (@ 0x0000000C) INTRAM3 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 5;          /*!< [5..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram3_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intram4_ctrl;       /*!< (@ 0x00000010) INTRAM4 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 5;          /*!< [5..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram4_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intram5_ctrl;       /*!< (@ 0x00000014) INTRAM5 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram5_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intram6_ctrl;       /*!< (@ 0x00000018) INTRAM6 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram6_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intram7_ctrl;       /*!< (@ 0x0000001C) INTRAM7 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intram7_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_intramhs_ctrl;      /*!< (@ 0x00000020) INTRAMHS syndrome manipulation register                    */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_intramhs_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_rpec0_pram_ctrl;/*!< (@ 0x00000024) XC0_RPEC0_PRAM syndrome manipulation register              */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_rpec0_pram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_rpec1_pram_ctrl;/*!< (@ 0x00000028) XC0_RPEC1_PRAM syndrome manipulation register              */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_rpec1_pram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_tpec0_pram_ctrl;/*!< (@ 0x0000002C) XC0_TPEC0_PRAM syndrome manipulation register              */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_tpec0_pram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_tpec1_pram_ctrl;/*!< (@ 0x00000030) XC0_TPEC1_PRAM syndrome manipulation register              */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_tpec1_pram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_dpram0_ctrl;    /*!< (@ 0x00000034) XC0_DPRAM0 syndrome manipulation register                  */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 5;          /*!< [5..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_dpram0_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_dpram1_ctrl;    /*!< (@ 0x00000038) XC0_DPRAM1 syndrome manipulation register                  */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 5;          /*!< [5..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_dpram1_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_rpu0_ram_ctrl;  /*!< (@ 0x0000003C) XC0_RPU0_RAM syndrome manipulation register                */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 8;          /*!< [8..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_rpu0_ram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_rpu1_ram_ctrl;  /*!< (@ 0x00000040) XC0_RPU1_RAM syndrome manipulation register                */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 8;          /*!< [8..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_rpu1_ram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_tpu0_ram_ctrl;  /*!< (@ 0x00000044) XC0_TPU0_RAM syndrome manipulation register                */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 8;          /*!< [8..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_tpu0_ram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_tpu1_ram_ctrl;  /*!< (@ 0x00000048) XC0_TPU1_RAM syndrome manipulation register                */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 8;          /*!< [8..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_tpu1_ram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xc0_pfifo_ctrl;     /*!< (@ 0x0000004C) XC0_PFIFO syndrome manipulation register                   */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xc0_pfifo_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xpic0_pram_ctrl;    /*!< (@ 0x00000050) XPIC0_PRAM syndrome manipulation register                  */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xpic0_pram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xpic1_pram_ctrl;    /*!< (@ 0x00000054) XPIC1_PRAM syndrome manipulation register                  */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 7;          /*!< [7..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xpic1_pram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xpic0_dram_ctrl;    /*!< (@ 0x00000058) XPIC0_DRAM syndrome manipulation register                  */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 5;          /*!< [5..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xpic0_dram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_xpic1_dram_ctrl;    /*!< (@ 0x0000005C) XPIC1_DRAM syndrome manipulation register                  */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 5;          /*!< [5..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_xpic1_dram_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_iflash0_ctrl;       /*!< (@ 0x00000060) IFLASH0 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 8;          /*!< [8..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_iflash0_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_iflash1_ctrl;       /*!< (@ 0x00000064) IFLASH1 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 8;          /*!< [8..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_iflash1_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_iflash2_ctrl;       /*!< (@ 0x00000068) IFLASH2 syndrome manipulation register                     */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] enable ECC                                                         */
      __IOM uint32_t syndrome_inv : 8;          /*!< [8..1] Inverts syndrome bits for ECC testing                              */
    } ecc_ctrl_iflash2_ctrl_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram0_addr_sbe;   /*!< (@ 0x0000006C) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [20..15] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram0_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram1_addr_sbe;   /*!< (@ 0x00000070) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [20..15] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram1_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram2_addr_sbe;   /*!< (@ 0x00000074) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [20..15] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram2_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram3_addr_sbe;   /*!< (@ 0x00000078) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 14;           /*!< [13..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 5;            /*!< [18..14] Number of master that started errorneous RAM access              */
    } ecc_ctrl_intram3_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram4_addr_sbe;   /*!< (@ 0x0000007C) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 14;           /*!< [13..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 5;            /*!< [18..14] Number of master that started errorneous RAM access              */
    } ecc_ctrl_intram4_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram5_addr_sbe;   /*!< (@ 0x00000080) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram5_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram6_addr_sbe;   /*!< (@ 0x00000084) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram6_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram7_addr_sbe;   /*!< (@ 0x00000088) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram7_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intramhs_addr_sbe;  /*!< (@ 0x0000008C) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC single bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intramhs_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpec0_pram_addr_sbe;/*!< (@ 0x00000090) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xc0_rpec0_pram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpec1_pram_addr_sbe;/*!< (@ 0x00000094) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xc0_rpec1_pram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpec0_pram_addr_sbe;/*!< (@ 0x00000098) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xc0_tpec0_pram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpec1_pram_addr_sbe;/*!< (@ 0x0000009C) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xc0_tpec1_pram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpu0_ram_addr_sbe;/*!< (@ 0x000000A0) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC single bit error                               */
    } ecc_ctrl_xc0_rpu0_ram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpu1_ram_addr_sbe;/*!< (@ 0x000000A4) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC single bit error                               */
    } ecc_ctrl_xc0_rpu1_ram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpu0_ram_addr_sbe;/*!< (@ 0x000000A8) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC single bit error                               */
    } ecc_ctrl_xc0_tpu0_ram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpu1_ram_addr_sbe;/*!< (@ 0x000000AC) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC single bit error                               */
    } ecc_ctrl_xc0_tpu1_ram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic0_pram_addr_sbe;/*!< (@ 0x000000B0) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xpic0_pram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic1_pram_addr_sbe;/*!< (@ 0x000000B4) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xpic1_pram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic0_dram_addr_sbe;/*!< (@ 0x000000B8) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xpic0_dram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic1_dram_addr_sbe;/*!< (@ 0x000000BC) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC single bit error                              */
    } ecc_ctrl_xpic1_dram_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_iflash0_addr_sbe;   /*!< (@ 0x000000C0) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC single bit error                              */
    } ecc_ctrl_iflash0_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_iflash1_addr_sbe;   /*!< (@ 0x000000C4) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC single bit error                              */
    } ecc_ctrl_iflash1_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_iflash2_addr_sbe;   /*!< (@ 0x000000C8) RAM Address of ECC single bit error (SBE): This
                                                                    register logs the RAM address where first
                                                                    ECC SBE occured. This first SBE address
                                                                    will be stored (even in case of further
                                                                    SBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC single bit error                              */
    } ecc_ctrl_iflash2_addr_sbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram0_addr_dbe;   /*!< (@ 0x000000CC) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [20..15] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram0_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram1_addr_dbe;   /*!< (@ 0x000000D0) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [20..15] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram1_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram2_addr_dbe;   /*!< (@ 0x000000D4) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [20..15] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram2_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram3_addr_dbe;   /*!< (@ 0x000000D8) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 14;           /*!< [13..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 5;            /*!< [18..14] Number of master that started errorneous RAM access              */
    } ecc_ctrl_intram3_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram4_addr_dbe;   /*!< (@ 0x000000DC) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 14;           /*!< [13..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 5;            /*!< [18..14] Number of master that started errorneous RAM access              */
    } ecc_ctrl_intram4_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram5_addr_dbe;   /*!< (@ 0x000000E0) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram5_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram6_addr_dbe;   /*!< (@ 0x000000E4) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram6_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intram7_addr_dbe;   /*!< (@ 0x000000E8) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intram7_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_intramhs_addr_dbe;  /*!< (@ 0x000000EC) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 13;           /*!< [12..0] Address of last ECC double bit error                              */
      __IM  uint32_t add_addr   : 6;            /*!< [18..13] RAM readmodwrite(1) and number of master that started
                                                     errorneous RAM access(5)                                                  */
    } ecc_ctrl_intramhs_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpec0_pram_addr_dbe;/*!< (@ 0x000000F0) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xc0_rpec0_pram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpec1_pram_addr_dbe;/*!< (@ 0x000000F4) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xc0_rpec1_pram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpec0_pram_addr_dbe;/*!< (@ 0x000000F8) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xc0_tpec0_pram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpec1_pram_addr_dbe;/*!< (@ 0x000000FC) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xc0_tpec1_pram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpu0_ram_addr_dbe;/*!< (@ 0x00000100) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC double bit error                               */
    } ecc_ctrl_xc0_rpu0_ram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_rpu1_ram_addr_dbe;/*!< (@ 0x00000104) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC double bit error                               */
    } ecc_ctrl_xc0_rpu1_ram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpu0_ram_addr_dbe;/*!< (@ 0x00000108) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC double bit error                               */
    } ecc_ctrl_xc0_tpu0_ram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xc0_tpu1_ram_addr_dbe;/*!< (@ 0x0000010C) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 7;            /*!< [6..0] Address of last ECC double bit error                               */
    } ecc_ctrl_xc0_tpu1_ram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic0_pram_addr_dbe;/*!< (@ 0x00000110) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xpic0_pram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic1_pram_addr_dbe;/*!< (@ 0x00000114) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xpic1_pram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic0_dram_addr_dbe;/*!< (@ 0x00000118) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xpic0_dram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_xpic1_dram_addr_dbe;/*!< (@ 0x0000011C) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 11;           /*!< [10..0] Address of last ECC double bit error                              */
    } ecc_ctrl_xpic1_dram_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_iflash0_addr_dbe;   /*!< (@ 0x00000120) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC double bit error                              */
    } ecc_ctrl_iflash0_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_iflash1_addr_dbe;   /*!< (@ 0x00000124) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC double bit error                              */
    } ecc_ctrl_iflash1_addr_dbe_b;
  } ;
  
  union {
    __IM  uint32_t ecc_ctrl_iflash2_addr_dbe;   /*!< (@ 0x00000128) RAM Address of ECC single bit error (DBE): This
                                                                    register logs the RAM address where first
                                                                    ECC DBE occured. This first DBE address
                                                                    will be stored (even in case of further
                                                                    DBEs) until the appropriate bit in status_sbe
                                                                    register was cleared. Note1: Not all RAM
                                                                    ECCs support error address logging, e.g.
                                                                    dual-port RAMs Note2: This is the real RAM
                                                                    address, i.e. a 32-bit address except at
                                                                    xMAC 64-bit RAMs or RAMs that are not directly
                                                                    accessible by CPU.                                         */
    
    struct {
      __IM  uint32_t address    : 15;           /*!< [14..0] Address of last ECC double bit error                              */
    } ecc_ctrl_iflash2_addr_dbe_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_status_sbe;         /*!< (@ 0x0000012C) ECC status SBE: This register collects single
                                                                    bit error (SBE) status information. In case
                                                                    of ECC SBE, a bit in this register will
                                                                    be set. Bits can be reset by writing '1'
                                                                    to the apprpriate bit position (write to
                                                                    clear). If a SBE or DBE bit is set, IRQ
                                                                    signal will be asserted. Note: No mask register
                                                                    is required, as error correction can be
                                                                    enabled for each RAM separately.                           */
    
    struct {
      __IOM uint32_t intram0    : 1;            /*!< [0..0] INTRAM0 Single Bit Error occured                                   */
      __IOM uint32_t intram1    : 1;            /*!< [1..1] INTRAM1 Single Bit Error occured                                   */
      __IOM uint32_t intram2    : 1;            /*!< [2..2] INTRAM2 Single Bit Error occured                                   */
      __IOM uint32_t intram3    : 1;            /*!< [3..3] INTRAM3 Single Bit Error occured                                   */
      __IOM uint32_t intram4    : 1;            /*!< [4..4] INTRAM4 Single Bit Error occured                                   */
      __IOM uint32_t intram5    : 1;            /*!< [5..5] INTRAM5 Single Bit Error occured                                   */
      __IOM uint32_t intram6    : 1;            /*!< [6..6] INTRAM6 Single Bit Error occured                                   */
      __IOM uint32_t intram7    : 1;            /*!< [7..7] INTRAM7 Single Bit Error occured                                   */
      __IOM uint32_t intramhs   : 1;            /*!< [8..8] INTRAMHS Single Bit Error occured                                  */
      __IOM uint32_t xc0_rpec0_pram : 1;        /*!< [9..9] XC0_RPEC0_PRAM Single Bit Error occured                            */
      __IOM uint32_t xc0_rpec1_pram : 1;        /*!< [10..10] XC0_RPEC1_PRAM Single Bit Error occured                          */
      __IOM uint32_t xc0_tpec0_pram : 1;        /*!< [11..11] XC0_TPEC0_PRAM Single Bit Error occured                          */
      __IOM uint32_t xc0_tpec1_pram : 1;        /*!< [12..12] XC0_TPEC1_PRAM Single Bit Error occured                          */
      __IOM uint32_t xc0_dpram0 : 1;            /*!< [13..13] XC0_DPRAM0 Single Bit Error occured                              */
      __IOM uint32_t xc0_dpram1 : 1;            /*!< [14..14] XC0_DPRAM1 Single Bit Error occured                              */
      __IOM uint32_t xc0_rpu0_ram : 1;          /*!< [15..15] XC0_RPU0_RAM Single Bit Error occured                            */
      __IOM uint32_t xc0_rpu1_ram : 1;          /*!< [16..16] XC0_RPU1_RAM Single Bit Error occured                            */
      __IOM uint32_t xc0_tpu0_ram : 1;          /*!< [17..17] XC0_TPU0_RAM Single Bit Error occured                            */
      __IOM uint32_t xc0_tpu1_ram : 1;          /*!< [18..18] XC0_TPU1_RAM Single Bit Error occured                            */
      __IOM uint32_t xc0_pfifo  : 1;            /*!< [19..19] XC0_PFIFO Single Bit Error occured                               */
      __IOM uint32_t xpic0_pram : 1;            /*!< [20..20] XPIC0_PRAM Single Bit Error occured                              */
      __IOM uint32_t xpic1_pram : 1;            /*!< [21..21] XPIC1_PRAM Single Bit Error occured                              */
      __IOM uint32_t xpic0_dram : 1;            /*!< [22..22] XPIC0_DRAM Single Bit Error occured                              */
      __IOM uint32_t xpic1_dram : 1;            /*!< [23..23] XPIC1_DRAM Single Bit Error occured                              */
      __IOM uint32_t iflash0    : 1;            /*!< [24..24] IFLASH0 Single Bit Error occured                                 */
      __IOM uint32_t iflash1    : 1;            /*!< [25..25] IFLASH1 Single Bit Error occured                                 */
      __IOM uint32_t iflash2    : 1;            /*!< [26..26] IFLASH2 Single Bit Error occured                                 */
    } ecc_ctrl_status_sbe_b;
  } ;
  
  union {
    __IOM uint32_t ecc_ctrl_status_dbe;         /*!< (@ 0x00000130) ECC status DBE: This register collects double
                                                                    bit error (DBE) status information. In case
                                                                    of ECC DBE, a bit of the appropriate RAM
                                                                    in this register will be set. Bits can be
                                                                    reset by writing '1' to the apprpriate bit
                                                                    position (write to clear). If a SBE or DBE
                                                                    bit is set, IRQ signal will be asserted.
                                                                    Note: No mask register is required, as error
                                                                    correction can be enabled for each RAM separately.         */
    
    struct {
      __IOM uint32_t intram0    : 1;            /*!< [0..0] INTRAM0 Double Bit Error occured                                   */
      __IOM uint32_t intram1    : 1;            /*!< [1..1] INTRAM1 Double Bit Error occured                                   */
      __IOM uint32_t intram2    : 1;            /*!< [2..2] INTRAM2 Double Bit Error occured                                   */
      __IOM uint32_t intram3    : 1;            /*!< [3..3] INTRAM3 Double Bit Error occured                                   */
      __IOM uint32_t intram4    : 1;            /*!< [4..4] INTRAM4 Double Bit Error occured                                   */
      __IOM uint32_t intram5    : 1;            /*!< [5..5] INTRAM5 Double Bit Error occured                                   */
      __IOM uint32_t intram6    : 1;            /*!< [6..6] INTRAM6 Double Bit Error occured                                   */
      __IOM uint32_t intram7    : 1;            /*!< [7..7] INTRAM7 Double Bit Error occured                                   */
      __IOM uint32_t intramhs   : 1;            /*!< [8..8] INTRAMHS Double Bit Error occured                                  */
      __IOM uint32_t xc0_rpec0_pram : 1;        /*!< [9..9] XC0_RPEC0_PRAM Double Bit Error occured                            */
      __IOM uint32_t xc0_rpec1_pram : 1;        /*!< [10..10] XC0_RPEC1_PRAM Double Bit Error occured                          */
      __IOM uint32_t xc0_tpec0_pram : 1;        /*!< [11..11] XC0_TPEC0_PRAM Double Bit Error occured                          */
      __IOM uint32_t xc0_tpec1_pram : 1;        /*!< [12..12] XC0_TPEC1_PRAM Double Bit Error occured                          */
      __IOM uint32_t xc0_dpram0 : 1;            /*!< [13..13] XC0_DPRAM0 Double Bit Error occured                              */
      __IOM uint32_t xc0_dpram1 : 1;            /*!< [14..14] XC0_DPRAM1 Double Bit Error occured                              */
      __IOM uint32_t xc0_rpu0_ram : 1;          /*!< [15..15] XC0_RPU0_RAM Double Bit Error occured                            */
      __IOM uint32_t xc0_rpu1_ram : 1;          /*!< [16..16] XC0_RPU1_RAM Double Bit Error occured                            */
      __IOM uint32_t xc0_tpu0_ram : 1;          /*!< [17..17] XC0_TPU0_RAM Double Bit Error occured                            */
      __IOM uint32_t xc0_tpu1_ram : 1;          /*!< [18..18] XC0_TPU1_RAM Double Bit Error occured                            */
      __IOM uint32_t xc0_pfifo  : 1;            /*!< [19..19] XC0_PFIFO Double Bit Error occured                               */
      __IOM uint32_t xpic0_pram : 1;            /*!< [20..20] XPIC0_PRAM Double Bit Error occured                              */
      __IOM uint32_t xpic1_pram : 1;            /*!< [21..21] XPIC1_PRAM Double Bit Error occured                              */
      __IOM uint32_t xpic0_dram : 1;            /*!< [22..22] XPIC0_DRAM Double Bit Error occured                              */
      __IOM uint32_t xpic1_dram : 1;            /*!< [23..23] XPIC1_DRAM Double Bit Error occured                              */
      __IOM uint32_t iflash0    : 1;            /*!< [24..24] IFLASH0 Double Bit Error occured                                 */
      __IOM uint32_t iflash1    : 1;            /*!< [25..25] IFLASH1 Double Bit Error occured                                 */
      __IOM uint32_t iflash2    : 1;            /*!< [26..26] IFLASH2 Double Bit Error occured                                 */
    } ecc_ctrl_status_dbe_b;
  } ;
} ecc_ctrl_app_Type;                            /*!< Size = 308 (0x134)                                                        */



/* =========================================================================================================================== */
/* ================                                         gpio_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief gpio_app (gpio_app)
  */

typedef struct {                                /*!< (@ 0xFF801400) gpio_app Structure                                         */
  
  union {
    __IOM uint32_t gpio_app_cfg[8];             /*!< (@ 0x00000000) GPIO_APP pin 0 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] defines the gp input or output mode - depends on io_cfg
                                                     Input modes: 0000: read mode 0001: capture continued at
                                                     rising edge (allows gpio_app_irq on each capture) 0010:
                                                     capture once at rising edge (reset gpio_app_irq to capture
                                                     again) 0011: capture once at high level (reset gpio_app_irq
                                                     to capture again) Output modes: 0100: set to 0 0101: set
                                                     to 1 0110: set to gpio_app_line[0] 0111: pwm mode, direct
                                                     threshold update (might cause hazards on output) 1000:
                                                     blink mode Multi pin modes: 1111: pwm2-mode with thres                    */
      __IOM uint32_t inv        : 1;            /*!< [4..4] 1: invert input/output value 0: do not invert input/output         */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] counter reference 00: counter 0 01: counter 1 10: counter
                                                     2 11: sys_time (global system time)                                       */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] Length of blink sequence minus 1 (blink mode only) 00000:
                                                     use bit 0 of gpio_app_tc 00001: use bits 0..1 of gpio_app_tc
                                                     00010: use bits 0..2 of gpio_app_tc ... 11111: use bits
                                                     0..31 of gpio_app_tc                                                      */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] Run blink sequence only once (blink mode only)                   */
    } gpio_app_cfg_b[8];
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc[8];              /*!< (@ 0x00000020) GPIO_APP pin 0 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Threshold/Capture register: PWM mode (threshold): {
                                                     | The counter threshold value equals the number of inactive
                                                     clock cycles per period (cycles with pwm=0). Therefore
                                                     it is interpreted differently in symmetrical and asymmetrical
                                                     counter mode: Asymmetrical mode (sawtooth): pwm = (counter
                                                     &gt;= gpio_app_tc) Symmetrical mode (triangle) : Counter
                                                     is compared with gpio_app_tc[31:1], gpio_app_tc[0] extends
                                                     the inactive phase by 1 clock cycle only while counting
                                                     up. This allows running a 10 ns resolution even in                        */
    } gpio_app_tc_b[8];
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter_ctrl[3];    /*!< (@ 0x00000040) GPIO_APP counter0 control register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t run        : 1;            /*!< [0..0] 1: start counter, counter is running 0: stop counter               */
      __IOM uint32_t sym_nasym  : 1;            /*!< [1..1] 1: symmetric mode (triangle) 0: asymmetric mode (sawtooth)         */
      __IOM uint32_t irq_en     : 1;            /*!< [2..2] 1: enable interrupt request on sel_event 0: disable interrupt
                                                     request                                                                   */
      __IOM uint32_t sel_event  : 1;            /*!< [3..3] select external event 0: high level, invert gpio in register
                                                     gpio_app_cfg to select low level 1: pos. edge, invert gpio
                                                     in register gpio_app_cfg to select neg. edge                              */
      __IOM uint32_t once       : 1;            /*!< [4..4] 1: count once (reset run bit after 1 period) 0: count
                                                     continuously                                                              */
      __IOM uint32_t event_act  : 2;            /*!< [6..5] Define action of selected external event (dependent on
                                                     sel_event, gpio_ref) 00: count every clock cycle, ignore
                                                     external events 01: count only external events (edge or
                                                     level according to bit sel_event) 10: enable watchdog mode
                                                     of counter (external event will be reset without IRQ, overflow
                                                     generates IRQ). 11: enable automatic run mode (external
                                                     event sets run bit, used for DC-DC PWM in combination with
                                                     bit once=1)                                                               */
      __IOM uint32_t gpio_ref   : 3;            /*!< [9..7] gpio reference (0 - 7)                                             */
    } gpio_app_counter_ctrl_b[3];
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter_max[3];     /*!< (@ 0x0000004C) GPIO_APP counter0 max value: This register is
                                                                    accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Asymmetric mode: Counting period in cc + 1 Symmetric
                                                     mode: Counting period in cc                                               */
    } gpio_app_counter_max_b[3];
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter_cnt[3];     /*!< (@ 0x00000058) GPIO_APP counter0 current value: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] current counter value                                             */
    } gpio_app_counter_cnt_b[3];
  } ;
  
  union {
    __IOM uint32_t gpio_app_line;               /*!< (@ 0x00000064) GPIO_APP line register This register is accessible
                                                                    via address areas inlogic_app and xpic_app_system.         */
    
    struct {
      __IOM uint32_t val        : 8;            /*!< [7..0] gpio_app output values                                             */
    } gpio_app_line_b;
  } ;
  
  union {
    __IM  uint32_t gpio_app_in;                 /*!< (@ 0x00000068) GPIO_APP latched inputs register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IM  uint32_t val        : 8;            /*!< [7..0] gpio_app input values                                              */
    } gpio_app_in_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_irq_raw;            /*!< (@ 0x0000006C) GPIO_APP raw IRQ register: Read access shows
                                                                    the status of unmasked IRQs. IRQs are set
                                                                    automatically and reset by writing to this
                                                                    register: Write access with '1' resets the
                                                                    corresponding IRQ. Write access with '0'
                                                                    does not influence this bit. This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IOM uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IOM uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IOM uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IOM uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IOM uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IOM uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IOM uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t gpio_app_irq_masked;         /*!< (@ 0x00000070) GPIO_APP masked IRQ register: This register exists
                                                                    2x for the different system busses (address
                                                                    areas) it is connected to. This allows 2
                                                                    CPUs to work in parallel on this module:
                                                                    ARM_APP, xPIC_APP.                                         */
    
    struct {
      __IM  uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IM  uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IM  uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IM  uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IM  uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IM  uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IM  uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IM  uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_irq_mask_set;       /*!< (@ 0x00000074) GPIO_APP interrupt mask set: The interrupt mask
                                                                    register exists 2x for the different system
                                                                    busses (address areas) it is connected to.
                                                                    This allows 2 CPUs to work in parallel on
                                                                    this module: ARM_APP, xPIC_APP. The inlogic_app
                                                                    IRQ mask enables interrupt requests for
                                                                    ARM_APP. The xpic_app_system IRQ mask enables
                                                                    interrupt requests for xPIC_APP. Since different
                                                                    software tasks might change its bits, the
                                                                    IRQ mask register is not writable directly,
                                                                    but by set and reset masks: Write access
                                                                    with                                                       */
    
    struct {
      __IOM uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IOM uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IOM uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IOM uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IOM uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IOM uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IOM uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IOM uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_irq_mask_rst;       /*!< (@ 0x00000078) GPIO_APP interrupt mask reset: This reset mask
                                                                    serves to disable the interrupt requests
                                                                    for the corresponding interrupt sources.
                                                                    Like irq_msk_set, this address exists for
                                                                    the following address areas: inlogic_app,
                                                                    xpic_app_system. Write access with '1' resets
                                                                    the interrupt mask bit (disables the interrupt
                                                                    request for the corresponding interrupt
                                                                    source). Write access with '0' does not
                                                                    influence this bit. Read access shows the
                                                                    current interrupt mask.                                    */
    
    struct {
      __IOM uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IOM uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IOM uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IOM uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IOM uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IOM uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IOM uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IOM uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_mask_rst_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cnt_irq_raw;        /*!< (@ 0x0000007C) Counter raw IRQ register: Read access shows the
                                                                    status of unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the corresponding
                                                                    IRQ. Write access with '0' does not influence
                                                                    this bit. This register is accessible via
                                                                    address areas inlogic_app and xpic_app_system.             */
    
    struct {
      __IOM uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IOM uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IOM uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t gpio_app_cnt_irq_masked;     /*!< (@ 0x00000080) Counter masked IRQ register: Read access shows
                                                                    the status of masked IRQs (cnt_irq_raw AND
                                                                    cnt_irq_mask). This register exists 2x for
                                                                    the different system busses (address areas)
                                                                    it is connected to. This allows 2 CPUs to
                                                                    work in parallel on this module: ARM_APP,
                                                                    xPIC_APP.                                                  */
    
    struct {
      __IM  uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IM  uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IM  uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cnt_irq_mask_set;   /*!< (@ 0x00000084) Counter interrupt mask set: The interrupt mask
                                                                    register exists 2x for the different system
                                                                    busses (address areas) it is connected to.
                                                                    This allows 2 CPUs to work in parallel on
                                                                    this module: ARM_APP, xPIC_APP. The inlogic_app
                                                                    IRQ mask enables interrupt requests for
                                                                    ARM_APP. The xpic_app_system IRQ mask enables
                                                                    interrupt requests for xPIC_APP. Since different
                                                                    software tasks might change its bits, the
                                                                    IRQ mask register is not writable directly,
                                                                    but by set and reset masks: Write access
                                                                    with '                                                     */
    
    struct {
      __IOM uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IOM uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IOM uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cnt_irq_mask_rst;   /*!< (@ 0x00000088) Counter interrupt mask reset: This reset mask
                                                                    serves to disable the interrupt requests
                                                                    for the corresponding interrupt sources.
                                                                    Like cnt_irq_msk_set, this address exists
                                                                    for the following address areas: inlogic_app,
                                                                    xpic_app_system. Write access with '1' resets
                                                                    the interrupt mask bit (disables the interrupt
                                                                    request for the corresponding interrupt
                                                                    source). Write access with '0' does not
                                                                    influence this bit. Read access shows the
                                                                    current interrupt mask.                                    */
    
    struct {
      __IOM uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IOM uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IOM uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_mask_rst_b;
  } ;
} gpio_app_Type;                                /*!< Size = 140 (0x8c)                                                         */



/* =========================================================================================================================== */
/* ================                                      systime_lt_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief systime_lt_app (systime_lt_app)
  */

typedef struct {                                /*!< (@ 0xFF801540) systime_lt_app Structure                                   */
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_ns;  /*!< (@ 0x00000000) systime_com_ns last latched value                          */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_ns last latched value                                 */
    } intlogic_lt_systime_com_ns_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_s;   /*!< (@ 0x00000004) systime_com_s last latched value                           */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_s last latched value                                  */
    } intlogic_lt_systime_com_s_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_uc_ns;/*!< (@ 0x00000008) systime_com_uc_ns last latched value                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_uc_ns last latched value                              */
    } intlogic_lt_systime_com_uc_ns_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_uc_s;/*!< (@ 0x0000000C) systime_com_uc_s last latched value                        */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_uc_s last latched value                               */
    } intlogic_lt_systime_com_uc_s_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_app_ns;  /*!< (@ 0x00000010) systime_app_ns last latched value                          */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_app_ns last latched value                                 */
    } intlogic_lt_systime_app_ns_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_app_s;   /*!< (@ 0x00000014) systime_app_s last latched value                           */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_app_s last latched value                                  */
    } intlogic_lt_systime_app_s_b;
  } ;
  
  union {
    __OM  uint32_t intlogic_lt_systimes_latch;  /*!< (@ 0x00000018) latch systimes by writing 1'b1 to the assigned
                                                                    bit                                                        */
    
    struct {
      __OM  uint32_t systime_com_ns : 1;        /*!< [0..0] no field descpription                                              */
      __OM  uint32_t systime_com_s : 1;         /*!< [1..1] no field descpription                                              */
      __OM  uint32_t systime_com_uc_ns : 1;     /*!< [2..2] no field descpription                                              */
      __OM  uint32_t systime_com_uc_s : 1;      /*!< [3..3] no field descpription                                              */
      __OM  uint32_t systime_app_ns : 1;        /*!< [4..4] no field descpription                                              */
      __OM  uint32_t systime_app_s : 1;         /*!< [5..5] no field descpription                                              */
    } intlogic_lt_systimes_latch_b;
  } ;
} systime_lt_app_Type;                          /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                         timer_app                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief timer_app (timer_app)
  */

typedef struct {                                /*!< (@ 0xFF801580) timer_app Structure                                        */
  
  union {
    __IOM uint32_t timer_config_timer[3];       /*!< (@ 0x00000000) ARM TIMER Config register[0..2]                            */
    
    struct {
      __IOM uint32_t mode       : 2;            /*!< [1..0] Timer0 2'b00 : Timer stops at 0 2'b01 : Timer is preload
                                                     with value from preload register at 0 2'b10 : Timer (value)
                                                     compare with systime (once) 2'b11 : reserved                              */
      __IOM uint32_t systime_config : 2;        /*!< [3..2] systime for timer (2'b00.. systime_com, 2'b01.. systime_com_uc,
                                                     2'b10.. systime_app)                                                      */
    } timer_config_timer_b[3];
  } ;
  
  union {
    __IOM uint32_t timer_preload_timer[3];      /*!< (@ 0x0000000C) ARM TIMER Timer [0..2]                                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] preload value                                                     */
    } timer_preload_timer_b[3];
  } ;
  
  union {
    __IOM uint32_t timer_timer[3];              /*!< (@ 0x00000018) ARM TIMER Timer [0..2]                                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] actual value of timer / systime compare value                     */
    } timer_timer_b[3];
  } ;
  
  union {
    __IM  uint32_t timer_systime_s;             /*!< (@ 0x00000024) ARM_TIMER upper SYSTIME register To allow consistent
                                                                    values of systime_s and systime_ns, lower
                                                                    bits of systime is latched to systime_ns,
                                                                    when systime_s is read. This register should
                                                                    be dedicated to accesses via ARM. xPIC software
                                                                    should access systime via xpic_timer_systime_s.
                                                                    Host software should access systime via
                                                                    DPM at systime_s.                                          */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] Systime high: Sample systime_ns at read access to systime_s.
                                                     Value is incremented, if systime_ns reaches systime_border.               */
    } timer_systime_s_b;
  } ;
  
  union {
    __IM  uint32_t timer_systime_ns;            /*!< (@ 0x00000028) ARM_TIMER lower SYSTIME register To allow consistent
                                                                    values of systime_s and systime_ns, lower
                                                                    bits of systime is latched to systime_ns,
                                                                    when systime_s is read. If no systime_s
                                                                    is read before (e.g. at 2nd read access
                                                                    of systime_ns), the actual value of systime_ns
                                                                    is read. This register should be dedicated
                                                                    to accesses via ARM. xPIC software should
                                                                    access systime via xpic_timer_systime_ns.
                                                                    Host software should access systime via
                                                                    DPM at systime_ns.                                         */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] Systime low: Sample systime_ns at read access to systime_s.
                                                     Without sample read systime_s, read the actual value of
                                                     systime_ns.                                                               */
    } timer_systime_ns_b;
  } ;
  
  union {
    __IOM uint32_t timer_compare_systime_s_value;/*!< (@ 0x0000002C) SYSTIME sec compare value                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Compare value with systime_s (seconds): Systime_s_compare_irq
                                                     is set, if systime_s matches.                                             */
    } timer_compare_systime_s_value_b;
  } ;
  
  union {
    __IOM uint32_t timer_irq_raw;               /*!< (@ 0x00000030) ARM_TIMER Raw IRQ register: Read access shows
                                                                    status of unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the appropriate IRQ.
                                                                    Write access with '0' does not influence
                                                                    this bit.                                                  */
    
    struct {
      __IOM uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IOM uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IOM uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IOM uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t timer_irq_masked;            /*!< (@ 0x00000034) ARM_TIMER Masked IRQ register: Shows status of
                                                                    masked IRQs (as connected to ARM/xPIC)                     */
    
    struct {
      __IM  uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IM  uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IM  uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IM  uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t timer_irq_msk_set;           /*!< (@ 0x00000038) ARM_TIMER interrupt mask set: The IRQ mask enables
                                                                    interrupt requests for corresponding interrupt
                                                                    sources. As its bits might be changed by
                                                                    different software tasks, the IRQ mask register
                                                                    is not writable directly, but by set and
                                                                    reset masks: Write access with '1' sets
                                                                    interrupt mask bit (enables interrupt request
                                                                    for corresponding interrupt source). Write
                                                                    access with '0' does not influence this
                                                                    bit. Read access shows actual interrupt
                                                                    mask. Attention: Before activating interrupt
                                                                    mask, delete                                               */
    
    struct {
      __IOM uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IOM uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IOM uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IOM uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t timer_irq_msk_reset;         /*!< (@ 0x0000003C) ARM_TIMER interrupt mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit
                                                                    (disables interrupt request for corresponding
                                                                    interrupt source). Write access with '0'
                                                                    does not influence this bit. Read access
                                                                    shows actual interrupt mask.                               */
    
    struct {
      __IOM uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IOM uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IOM uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IOM uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_msk_reset_b;
  } ;
  
  union {
    __IOM uint32_t timer_systime_config;        /*!< (@ 0x00000040) Select systime for arm_timer_systime_(ns)s functions       */
    
    struct {
      __IOM uint32_t systime_config : 2;        /*!< [1..0] systime for timer (2'b00.. systime_com, 2'b01.. systime_com_uc,
                                                     2'b10.. systime_app)                                                      */
    } timer_systime_config_b;
  } ;
} timer_app_Type;                               /*!< Size = 68 (0x44)                                                          */



/* =========================================================================================================================== */
/* ================                                        systime_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief systime_app (systime_app)
  */

typedef struct {                                /*!< (@ 0xFF801600) systime_app Structure                                      */
  
  union {
    __IOM uint32_t systime_s;                   /*!< (@ 0x00000000) Upper SYSTIME register: To allow consistent values
                                                                    of systime_s and systime_ns, lower bits
                                                                    of systime is latched to systime_ns, when
                                                                    systime_s is read. This register should
                                                                    be dedicated to accesses via DPM. ARM software
                                                                    should access systime via arm_timer_systime_s.
                                                                    xPIC software should access systime via
                                                                    xpic_timer_systime_s.                                      */
    
    struct {
      __IOM uint32_t systime_s  : 32;           /*!< [31..0] systime high value is incremented, if systime_ns reaches
                                                     systime_border Sample systime_ns at read access to systime_s.             */
    } systime_s_b;
  } ;
  
  union {
    __IOM uint32_t systime_ns;                  /*!< (@ 0x00000004) Lower SYSTIME register: To allow consistent values
                                                                    of systime_s and systime_ns, lower bits
                                                                    of systime is latched to systime_ns, when
                                                                    systime_s is read. If no systime_s is read
                                                                    before (or at 2nd read access of systime_ns),
                                                                    the actual value of systime_ns is read.
                                                                    This register should be dedicated to accesses
                                                                    via DPM. ARM software should access systime
                                                                    via arm_timer_systime_ns. xPIC software
                                                                    should access systime via xpic_timer_systime_ns.           */
    
    struct {
      __IOM uint32_t systime_ns : 32;           /*!< [31..0] Systime low: Sample systime_ns at read access to systime_s.
                                                     Without sample read systime_s, read the actual value of
                                                     systime_ns.                                                               */
    } systime_ns_b;
  } ;
  
  union {
    __IOM uint32_t systime_border;              /*!< (@ 0x00000008) SYSTIME border register                                    */
    
    struct {
      __IOM uint32_t systime_border : 32;       /*!< [31..0] Systime border for lower systime: systime_ns counts
                                                     from 0 to this value (inlcuded), i.e. systime_ns counts
                                                     modulo (systime_border + 1) Attention: the border value
                                                     Bit 3 to 1 must be b'1111 (hex f) for all netX systime
                                                     - match functions                                                         */
    } systime_border_b;
  } ;
  
  union {
    __IOM uint32_t systime_count_value;         /*!< (@ 0x0000000C) SYSTIME count register                                     */
    
    struct {
      __IOM uint32_t systime_count_value : 32;  /*!< [31..0] Each clock cycle (systime_count_value &gt;&gt; 28) will
                                                     be added to systime (rate multiplier for IEEE1588). Value
                                                     0x10000000 can be used for counting in 10ns (ethernet clock)
                                                     steps.                                                                    */
    } systime_count_value_b;
  } ;
} systime_app_Type;                             /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          mcp_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief mcp_app (mcp_app)
  */

typedef struct {                                /*!< (@ 0xFF801620) mcp_app Structure                                          */
  
  union {
    __IOM uint32_t hs_irq_set_raw;              /*!< (@ 0x00000000) read: hs_iq_reg value write: hs_iq_reg set bit(s)          */
    
    struct {
      __IOM uint32_t hs_irq_set_bits : 32;      /*!< [31..0] IRQs for Inter-CPU-Communication                                  */
    } hs_irq_set_raw_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_reset_raw;            /*!< (@ 0x00000004) read: hs_iq_reg value write: hs_iq_reg reset
                                                                    bit(s)                                                     */
    
    struct {
      __IOM uint32_t hs_irq_reset_bits : 32;    /*!< [31..0] IRQs for Inter-CPU-Communication                                  */
    } hs_irq_reset_raw_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_set_mask;             /*!< (@ 0x00000008) read: mask value                                           */
    
    struct {
      __IOM uint32_t hs_irq_set_mask : 32;      /*!< [31..0] IRQs for Inter-CPU-Communication                                  */
    } hs_irq_set_mask_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_reset_mask;           /*!< (@ 0x0000000C) read: mask value                                           */
    
    struct {
      __IOM uint32_t hs_irq_reset_mask : 32;    /*!< [31..0] reset IRQs for Inter-CPU-Communication                            */
    } hs_irq_reset_mask_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_masked;               /*!< (@ 0x00000010) read: hs_iq_reg masked value                               */
    
    struct {
      __IOM uint32_t hs_irq_masked : 32;        /*!< [31..0] mask IRQs for Inter-CPU-Communication                             */
    } hs_irq_masked_b;
  } ;
} mcp_app_Type;                                 /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                          wdg_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief wdg_app (wdg_app)
  */

typedef struct {                                /*!< (@ 0xFF801640) wdg_app Structure                                          */
  
  union {
    __IOM uint32_t netx_sys_wdg_ctrl;           /*!< (@ 0x00000000) netX System Watchdog Trigger Register. The watchdog
                                                                    access code is generated by a pseudo random
                                                                    generator. It must be written correctly
                                                                    for a valid write access to this register
                                                                    (not only for triggering e.g. also for IRQ
                                                                    clearing). Note: WDGACT signal is available
                                                                    as MMIO function..                                         */
    
    struct {
      __IOM uint32_t wdg_access_code : 20;      /*!< [19..0] Watchdog trigger and control register access code. A
                                                     read access gives the next 16 bit code for writing the
                                                     'netx_sys_wdg_ctrl' register. A write access with correct
                                                     access code will trigger the watchdog counter.                            */
      __IOM uint32_t reserved0  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t irq_req_watchdog : 1;      /*!< [24..24] IRQ request of watchdog, writing 1 deletes IRQ                   */
      __IOM uint32_t reserved1  : 3;            /*!< [27..25] reserved                                                         */
      __IOM uint32_t wdg_counter_trigger_w : 1; /*!< [28..28] Watchdog trigger bit: Bit must be set to trigger the
                                                     watchdog counter. When read, this bit is always '0'                       */
      __IOM uint32_t reserved2  : 2;            /*!< [30..29] reserved                                                         */
      __IOM uint32_t write_enable : 1;          /*!< [31..31] Write enable bit for timeout register: As long as this
                                                     bit is not set all write accesses to the timeout register
                                                     are ignored.                                                              */
    } netx_sys_wdg_ctrl_b;
  } ;
  
  union {
    __IM  uint32_t netx_sys_wdg;                /*!< (@ 0x00000004) netX System Watchdog Register The counter value
                                                                    is decremented each 10000 system clock cycles.             */
    
    struct {
      __IM  uint32_t wdg_counter : 17;          /*!< [16..0] Actual watchdog counter value                                     */
    } netx_sys_wdg_b;
  } ;
  
  union {
    __IOM uint32_t netx_sys_wdg_irq_timeout;    /*!< (@ 0x00000008) netX System Wachtdog Interrupt Timout Register             */
    
    struct {
      __IOM uint32_t wdg_irq_timeout : 16;      /*!< [15..0] Watchdog interrupt timeout The total netx_sys_irq timeout
                                                     for a netX clock of 100MHz is: wdg_irq_timeout * 100us
                                                     Note: The watchdog can be stopped by programming a 0.                     */
    } netx_sys_wdg_irq_timeout_b;
  } ;
  
  union {
    __IOM uint32_t netx_sys_wdg_res_timeout;    /*!< (@ 0x0000000C) netX System Watchdog Reset Timeout Register                */
    
    struct {
      __IOM uint32_t wdg_res_timeout : 16;      /*!< [15..0] Watchdog reset request timeout The total reset timeout
                                                     for a netX clock of 100MHz is: (wdg_irq_timeout + wdg_res_timeout)
                                                     * 100us Note: The watchdog can be stopped by programming
                                                     a 0.                                                                      */
    } netx_sys_wdg_res_timeout_b;
  } ;
  
  union {
    __IOM uint32_t netx_sys_wdg_irq_raw;        /*!< (@ 0x00000010) netX System Wachtdog IRQ raw register: Read access
                                                                    shows status of unmasked IRQs. IRQs are
                                                                    set automatically and reset by writing to
                                                                    this register: Write access with '1' resets
                                                                    the appropriate IRQ. Write access with '0'
                                                                    does not influence this bit.                               */
    
    struct {
      __IOM uint32_t wdg_res_irq : 1;           /*!< [0..0] Watchdog reset request timeout interrupt                           */
    } netx_sys_wdg_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t netx_sys_wdg_irq_masked;     /*!< (@ 0x00000014) netX System Wachtdog Masked IRQ register: Read
                                                                    access shows status of masked IRQs.                        */
    
    struct {
      __IM  uint32_t wdg_res_irq : 1;           /*!< [0..0] Watchdog reset request timeout interrupt                           */
    } netx_sys_wdg_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t netx_sys_wdg_irq_msk_set;    /*!< (@ 0x00000018) netX System Wachtdog interrupt mask enable: The
                                                                    IRQ mask enables interrupt requests for
                                                                    corresponding interrupt sources. As its
                                                                    bits might be changed by different software
                                                                    tasks, the IRQ mask register is not writable
                                                                    directly, but by set and reset masks: Write
                                                                    access with '1' sets interrupt mask bit
                                                                    (enables interrupt request for corresponding
                                                                    interrupt source). Write access with '0'
                                                                    does not influence this bit. Read access
                                                                    shows actual interrupt mask. Attention:
                                                                    Before activating interrup                                 */
    
    struct {
      __IOM uint32_t wdg_res_irq : 1;           /*!< [0..0] Watchdog reset request timeout interrupt                           */
    } netx_sys_wdg_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t netx_sys_wdg_irq_msk_reset;  /*!< (@ 0x0000001C) netX System Wachtdog interrupt mask disable:
                                                                    This is the corresponding reset mask to
                                                                    disable interrupt requests for corresponding
                                                                    interrupt sources: Write access with '1'
                                                                    resets interrupt mask bit (disables interrupt
                                                                    request for corresponding interrupt source).
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t wdg_res_irq : 1;           /*!< [0..0] Watchdog reset request timeout interrupt                           */
    } netx_sys_wdg_irq_msk_reset_b;
  } ;
} wdg_app_Type;                                 /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                      trigger_irq_app                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief trigger_irq_app (trigger_irq_app)
  */

typedef struct {                                /*!< (@ 0xFF801660) trigger_irq_app Structure                                  */
  
  union {
    __IOM uint32_t trigger_irq_cfg;             /*!< (@ 0x00000000) Trigger IRQ configuration register.                        */
    
    struct {
      __IOM uint32_t xc_trigger_out_polarity : 2;/*!< [1..0] Polarity of xc_trigger_out signals for edge detection.
                                                     0: Use pos-edge on xc_trigger_out signals to trigger an
                                                     IRQ. 1: Use neg-edge on xc_trigger_out signals to trigger
                                                     an IRQ. Note: Changing the polarity will trigger set an
                                                     IRQ in the raw register (and when the mask is set also
                                                     the IRQ signal to the CPU) due to the edge detection logic.               */
    } trigger_irq_cfg_b;
  } ;
  
  union {
    __IOM uint32_t trigger_irq_raw;             /*!< (@ 0x00000004) Trigger raw IRQ: Read access shows status of
                                                                    unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the appropriate IRQ.
                                                                    Write access with '0' does not influence
                                                                    this bit.                                                  */
    
    struct {
      __IOM uint32_t xc_trigger_out_edge : 2;   /*!< [1..0] Edge detected on xc_trigger_out.                                   */
    } trigger_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t trigger_irq_masked;          /*!< (@ 0x00000008) Trigger masked IRQ: Shows status of masked IRQs.           */
    
    struct {
      __IM  uint32_t xc_trigger_out_edge : 2;   /*!< [1..0] Edge detected on xc_trigger_out.                                   */
    } trigger_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t trigger_irq_msk_set;         /*!< (@ 0x0000000C) Trigger IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to bod_irq_raw.                  */
    
    struct {
      __IOM uint32_t xc_trigger_out_edge : 2;   /*!< [1..0] Edge detected on xc_trigger_out.                                   */
    } trigger_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t trigger_irq_msk_reset;       /*!< (@ 0x00000010) Trigger IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t xc_trigger_out_edge : 2;   /*!< [1..0] Edge detected on xc_trigger_out.                                   */
    } trigger_irq_msk_reset_b;
  } ;
} trigger_irq_app_Type;                         /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                        endat0_app                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief endat0_app (endat0_app)
  */

typedef struct {                                /*!< (@ 0xFF801700) endat0_app Structure                                       */
  
  union {
    __IOM uint32_t endat_send;                  /*!< (@ 0x00000000) Send register The send register contains data
                                                                    to be transmitted to the EnDat encoder.
                                                                    Mode command MRS code/address/port address
                                                                    (depends on the mode command) Parameters/instructions
                                                                    (depends on the mode command)                              */
    
    struct {
      __IOM uint32_t byte1      : 8;            /*!< [7..0] Parameters / Instructions D[7:0]                                   */
      __IOM uint32_t byte2      : 8;            /*!< [15..8] Parameters / Instructions D[15:0]                                 */
      __IOM uint32_t byte3      : 8;            /*!< [23..16] MRS code / Address / Port address A[7:0]                         */
      __IOM uint32_t byte4      : 6;            /*!< [29..24] Mode bits M[5:0]                                                 */
    } endat_send_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive1_0;            /*!< (@ 0x00000004) Receive register 1 Depending on the transmitted
                                                                    type 2.1 mode command, receive register
                                                                    1 contains different data. With EnDat type
                                                                    2.2 mode commands and with SSI, the position
                                                                    value is always entered into receive-Reg
                                                                    1.                                                         */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive1_0_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive1_1;            /*!< (@ 0x00000008) Receive register 1                                         */
    
    struct {
      __IM  uint32_t byte5      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte6      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte7      : 8;            /*!< [23..16] ...                                                              */
    } endat_receive1_1_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive2;              /*!< (@ 0x0000000C) Receive register 2 If a type 2.2 mode command
                                                                    was sent, receive register 2 will contain
                                                                    the contents of additional information 2
                                                                    and its CRC. This data is to be interpreted
                                                                    in accordance with the EnDat Interface Description.
                                                                    In SSI protocol mode with double-word transmission,
                                                                    the redundant position value is stored here
                                                                    (right-aligned).                                           */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive2_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive3;              /*!< (@ 0x00000010) Receive register 3 If a type 2.2 mode command
                                                                    was sent, receive register 3 will contain
                                                                    the contents of additional information 1
                                                                    and its CRC. This data is to be interpreted
                                                                    in accordance with the EnDat Interface Description.        */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive3_b;
  } ;
  
  union {
    __IOM uint32_t endat_conf1;                 /*!< (@ 0x00000014) Configuration register 1                                   */
    
    struct {
      __IOM uint32_t hw_strobe  : 1;            /*!< [0..0] 1: Enables external /STR signal as strobe signal                   */
      __IOM uint32_t uncond_transfer : 1;       /*!< [1..1] This bit defines the unconditional data transfer to receive
                                                     registers 1, 2, 3, 4 on completion of a data transmission
                                                     process, despite a flag being set in the status register.
                                                     Data transfer according to flag set in the status register
                                                     = 0 Data transfer despite the flag in the status register
                                                     = 1 For safety applications uncond_transfer = 1 must be
                                                     set.                                                                      */
      __IOM uint32_t endat_cont_clk_mode : 1;   /*!< [2..2] This bit is used to select the EnDat continuous clock
                                                     mode. Continuous clock off = 0 Continuous clock on = 1                    */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t f_tclk     : 4;            /*!< [7..4] Setting (4 bit) of transmission rate for EnDat and SSI
                                                     from 100 kHz to 1 MHz (SSI) or 16 MHz (EnDat). Transmission
                                                     frequency = 100kHz = 1111 Transmission frequency = 200kHz
                                                     = 1110 Transmission frequency = 1MHz = 1101 Transmission
                                                     frequency = 2MHz = 1100 Transmission frequency = 4.16MHz
                                                     = 1011 Transmission frequency = 8.33MHz = 0110 Transmission
                                                     frequency = 16.67MHz = 0000..0011                                         */
      __IOM uint32_t data_word_len : 6;         /*!< [13..8] Here the data word length is set binary with 6 bits
                                                     for EnDat or SSI. The permissible setting range for EnDat
                                                     is from 8 bits to 48 bits. The permissible setting range
                                                     for SSI is from 8 bits to 48 bits. Data word length = 0
                                                     bits = 00 1000 : Data word length = 13 bits = 00 1101 :
                                                     Data word length = 48 bits = 11 0000 Note: The Data word
                                                     length has to set to 40/d bit while using mode command
                                                     'encoder transmit test values'. Note: In SSI mode the additionally
                                                     required clock cycle for the parity bit is generated                      */
      __IOM uint32_t reset_window : 1;          /*!< [14..14] The set bit allows resetting of the status and error
                                                     register only within a defined time period. Reset window
                                                     = 0 Resetting of the registers mentioned above can be performed
                                                     anytime (i.e. without considering malfunctions). Reset
                                                     Window = 1 Resetting of the registers mentioned above must
                                                     be performed within a defined time period for acceptance
                                                     by the protocol engine. For safety applications: reset
                                                     window = 1                                                                */
      __IOM uint32_t auto_reset : 1;            /*!< [15..15] Autom. reset (automatic reset). If this bit is set,
                                                     resetting of the status register and error register is
                                                     performed automatically Autom. reset = 0 Resetting of the
                                                     above-mentioned registers must be performed by the application.
                                                     Autom. reset = 1 Resetting of the above-mentioned registers
                                                     is done automatically. However, this resetting only occurs
                                                     in the next EnDat transmission with the start of data reception.
                                                     For safety applications: autom. reset = 0                                 */
      __IOM uint32_t cable_prop_time : 8;       /*!< [23..16] The cable propagation time determined by the interface
                                                     component is stored here. (The application may change this
                                                     value. If that is the case the status registers propagation
                                                     time measurement (LZM) bit will automatically be reset).
                                                     The binary value has a step width of one system clock.
                                                     At a system clock of 64 MHz, this corresponds to a setting
                                                     range from 0 us to 3.98 us in steps of 15.6 ns. The basic
                                                     setting is 00 hex                                                         */
      __IOM uint32_t delay_comp : 1;            /*!< [24..24] Delay compensation. This bit switches propagation delay
                                                     compensation on. When this bit is set, propagation time
                                                     measurement is performed with the next data transmission
                                                     to the EnDat encoder. The interface component determines
                                                     the cable propagation time and saves this in conf_reg1.
                                                     This value is used to determine propagation delay compensation.
                                                     To measure the propagation time again, the delay compensation
                                                     bit must be reset and set again. For 16-bit access it must
                                                     be considered that the measured cable propag                              */
      __IOM uint32_t reserved1  : 1;            /*!< [25..25] reserved                                                         */
      __IOM uint32_t f_sys      : 3;            /*!< [28..26] The system frequency actually used must be selected
                                                     here. 64/48/32/50/100 MHz = 000/010/100/101/110                           */
      __IOM uint32_t ic_reset   : 1;            /*!< [29..29] Setting of this bit has the effect that the entire
                                                     interface component is reset to its initial state. IC reset
                                                     inactive = 0 IC reset active = 1                                          */
      __IOM uint32_t endat_ssi  : 2;            /*!< [31..30] These two bits set either the EnDat (0x2) or the SSI
                                                     (0x1) transmission mode. Values 0x0 and 0x3 are not permitted.
                                                     Note: For debugging purposes, this function may also be
                                                     used to perform an internal status engine software reset
                                                     without clearing of the other internal registers.                         */
    } endat_conf1_b;
  } ;
  
  union {
    __IOM uint32_t endat_conf2;                 /*!< (@ 0x00000018) Configuration register 2                                   */
    
    struct {
      __IOM uint32_t timer_for_sampling_rate : 8;/*!< [7..0] 256 different sampling rates can be set. In the default
                                                     setting 00 hex or 80 hex the timer is off.                                */
      __IOM uint32_t watchdog   : 8;            /*!< [15..8] 256 different watchdog time values can be set. In the
                                                     default setting 00 hex or 80 hex the watchdog is off.                     */
      __IOM uint32_t t_st       : 3;            /*!< [18..16] This time is to be set in accordance with EnDat specification.
                                                     The set time has an accuracy of 0.1 us. Setting 000 = 0.5
                                                     * TCLK Setting 001 = 0.5 us Setting 010 = 1 us Setting
                                                     011 = 1.5 us Setting 100 = 2 us Setting 101 = 4 us Setting
                                                     110 = 8 us Setting 111 = 10 us                                            */
      __IOM uint32_t filter     : 3;            /*!< [21..19] The digital filter for the Data_RC data input can be
                                                     adjusted in eight steps (3 bits) as shown in the table
                                                     below. The filter setting value corresponds to system clock
                                                     cycles. Setting 000 = Off Setting 001 = 3 Setting 010 =
                                                     4 Setting 011 = 5 Setting 100 = 6 Setting 101 = 10 Setting
                                                     110 = 20 Setting 111 = 40 Setting 000 001 010 011 100 101
                                                     110 111 Note on the application: The filter must be set
                                                     according to the transmission rate of the serial interface
                                                     to the encoder.                                                           */
      __IOM uint32_t rtm        : 1;            /*!< [22..22] Activates the recovery time measurement that is then
                                                     performed after each EnDat transmission with the mode command
                                                     1-1 'Encoder transmit position value and selection of memory
                                                     area' with MRS code 0x43 (selection of 2nd word of position
                                                     value 2). RTM=0 Recovery time measurement is deactivated
                                                     (default setting after reset) RTM=1 Recovery time measurement
                                                     is activated                                                              */
      __IOM uint32_t reserved0  : 1;            /*!< [23..23] reserved                                                         */
      __IOM uint32_t hw_strobe_delay : 8;       /*!< [31..24] Here the application can enter a value for the HW strobe
                                                     delay. The binary value has a step width of one system
                                                     clock. Setting 00 = Off, 3..255=3..255 system clock cycles
                                                     The values 1, 2 are not permissible. At a system clock
                                                     of 64 MHz, this corresponds to a value range from 46.88
                                                     ns to 3.98 us in steps of 15.6 ns.                                        */
    } endat_conf2_b;
  } ;
  
  union {
    __IOM uint32_t endat_conf3;                 /*!< (@ 0x0000001C) Configuration register 3                                   */
    
    struct {
      __IOM uint32_t parity     : 1;            /*!< [0..0] Here the parity check for SSI transmission is selected.
                                                     Parity off = 0 Parity on = 1                                              */
      __IOM uint32_t format     : 1;            /*!< [1..1] Here the transmission format for SSI transmission is
                                                     selected. Fir tree: 0 Serial, right-aligned = 1                           */
      __IOM uint32_t gray_to_binary : 1;        /*!< [2..2] In SSI transmission mode, Gray code values can be converted
                                                     here to binary code values. Gray-to-binary conversion inactive
                                                     = 0 Gray-to-binary conversion inactive = 1                                */
      __IOM uint32_t singleturn_res : 5;        /*!< [7..3] Here the number of steps per revolution is set to binary
                                                     with 5 bits. This setting is only required for the fir
                                                     tree format. Singleturn resolution = 13 bits = 0 1101                     */
      __IOM uint32_t dw         : 1;            /*!< [8..8] This bit allows a double-word query to be selected with
                                                     SSI transmission. Double-word query off = 0 Double word
                                                     query on = 1                                                              */
      __IOM uint32_t reserved0  : 6;            /*!< [14..9] reserved                                                          */
      __IOM uint32_t speed      : 1;            /*!< [15..15] (optional) This bit allows selection of the register
                                                     width for velocity. 64-bit = 0 32-Bit = 1                                 */
      __IOM uint32_t reserved1  : 16;           /*!< [31..16] reserved                                                         */
    } endat_conf3_b;
  } ;
  
  union {
    __IOM uint32_t endat_stat;                  /*!< (@ 0x00000020) Status register The status bits are created by
                                                                    the sequencing controller of the interface
                                                                    component, as required. Status information
                                                                    remains set until it is reset by the application.
                                                                    The application can selectively reset status
                                                                    information with a write command. This occurs
                                                                    by writing 1 to the selected bits. In the
                                                                    event of concurrent access, the internal
                                                                    sequencing controller has priority. This
                                                                    ensures that status information is not 'lost'.
                                                                    The status bits (15:11) are only valid when
                                                                    additio                                                    */
    
    struct {
      __IOM uint32_t receive1_reg : 1;          /*!< [0..0] This status flag indicates that the data in Receive-Reg
                                                     1 has been updated. It must be cleared after Receive-Reg1
                                                     has been read to allow the interface component to rewrite
                                                     data there. Receive-Reg1 not updated = 0 Receive-Reg1 updated
                                                     = 1 Note: This flag is ignored if the uncond_transfer bit
                                                     is enabled in conf-Reg 1.                                                 */
      __IOM uint32_t error1     : 1;            /*!< [1..1] The status bit error1 from the EnDat protocol is entered
                                                     here. Error1 did not occur = 0 Error1 occurred = 1                        */
      __IOM uint32_t crcpw_parity : 1;          /*!< [2..2] This bit has two meanings. With EnDat transmission it
                                                     represents the result of the CRC check of the received
                                                     value (position value, parameter or test value). With SSI
                                                     transmission it shows the result of the parity check. Condition:
                                                     parity check in conf-Reg1 is switched on. CRC check or
                                                     parity check okay = 0 CRC and parity check faulty = 1                     */
      __IOM uint32_t f_type1    : 1;            /*!< [3..3] Shows type I error handling in accordance with the EnDat
                                                     specification at Annex A2. A type I error did not occur
                                                     = 0 A type I error occurred = 1                                           */
      __IOM uint32_t f_type2    : 1;            /*!< [4..4] Shows type II error handling in accordance with the EnDat
                                                     specification at Annex A2. A type II error did not occur
                                                     = 0 A type II error occurred = 1                                          */
      __IOM uint32_t mrs_adr    : 1;            /*!< [5..5] The occurrence of an addressing or acknowledgement error
                                                     is shown here as described in the EnDat Interface specification.
                                                     The errors (F type I / II) are special cases of MRS/address
                                                     errors, i.e. they are a sub-quantity of these. Accordingly,
                                                     whenever a type I or type II error is identified, the MRS/Adr
                                                     bit is set. For example, if an MRS/address bit is recognized
                                                     incorrectly due to a disturbance, only the MRS/Adr status
                                                     bit will be set, not the F TYP I/II bits. No acknowledgement
                                                     or addressing error has occ                                               */
      __IOM uint32_t ir6        : 1;            /*!< [6..6] This bit indicates an H/L edge at input pin /IR6. No
                                                     H/L edge transition at input /IR6 = 0 H/L edge transition
                                                     has occurred at input /IR6R6 = 1                                          */
      __IOM uint32_t ir7        : 1;            /*!< [7..7] This bit indicates the state of input pin /IR7. Input
                                                     /IR7 is at high level = 0 Input /IR7 is at low level =
                                                     1                                                                         */
      __IOM uint32_t receive2_reg : 1;          /*!< [8..8] This status flag indicates that the data in Receive-Reg
                                                     2 (3) has been updated. It must be cleared after Receive-Reg2
                                                     (3) has been read to allow the interface component to rewrite
                                                     data. Receive-Reg2 (3) not updated = 0 Receive-Reg2 (3)
                                                     updated = 1                                                               */
      __IOM uint32_t receive3_reg : 1;          /*!< [9..9] This status flag indicates that the data in Receive-Reg3
                                                     has been updated. It must be cleared after Receive-Reg3
                                                     has been read to allow the interface component to rewrite
                                                     data. Receive-Reg3 not updated = 0 Receive-Reg3 updated
                                                     = 1                                                                       */
      __IOM uint32_t error2     : 1;            /*!< [10..10] Contains the /Error 2 status bit from the EnDat protocol
                                                     (only with EnDat2.2 commands). /Error2 occurred = 0 /Error2
                                                     did not occur = 1                                                         */
      __IOM uint32_t crc_zi1    : 1;            /*!< [11..11] During EnDat transmissions, this bit indicates the
                                                     result of the CRC checking of additional information (ZI1).
                                                     CRC check of ZI2 okay = 0 CRC check of ZI2 faulty = 1                     */
      __IOM uint32_t crc_zi2    : 1;            /*!< [12..12] During EnDat transmissions, this bit indicates the
                                                     result of the CRC checking of additional information (ZI2).
                                                     CRC check of ZI2 okay = 0 CRC check of ZI2 faulty = 1                     */
      __IOM uint32_t busy       : 1;            /*!< [13..13] Contains the Busy status bit as transmitted in the
                                                     EnDat protocol. Busy = 0 Busy = 1                                         */
      __IOM uint32_t rm         : 1;            /*!< [14..14] Contains the RM status bit as transmitted in the EnDat
                                                     protocol. RM = 0 RM = 1                                                   */
      __IOM uint32_t wrn        : 1;            /*!< [15..15] Contains the WRN status bit as transmitted in the EnDat
                                                     protocol. WRN = 0 WRN = 1                                                 */
      __IOM uint32_t spike      : 1;            /*!< [16..16] Reports that a Spike was detected at the data input
                                                     port. Condition: filter in conf_reg1 is set. No spike =
                                                     0 Spike occurred = 1                                                      */
      __IOM uint32_t watchdog   : 1;            /*!< [17..17] Reports triggering of the watchdog. Condition: watchdog
                                                     in conf_reg2 is set. Watchdog not triggered = 0 Watchdog
                                                     triggered = 1                                                             */
      __IOM uint32_t f_type3    : 1;            /*!< [18..18] Type II error (transmission layer) triggers F type
                                                     III. Error recognition occurs in the EnDat master. The
                                                     error did not occur = 0 The error occurred = 1                            */
      __IOM uint32_t reserved0  : 3;            /*!< [21..19] reserved                                                         */
      __IOM uint32_t delay_comp : 1;            /*!< [22..22] (LZK). This bit reports if propagation delay compensation
                                                     is active. If propagation delay compensation in configuration
                                                     register 1 is switched off, this bit and propagation time
                                                     measurement will automatically be reset. LZK inactive =
                                                     0 LZK active = 1 Neither the LZM nor the LZK bit can be
                                                     reset by writing a 1 to the respective bit as this is a
                                                     status display of the current conditions of internal automation
                                                     engines. Neither of the two bits can cause an interrupt.                  */
      __IOM uint32_t prop_time_measurement : 1; /*!< [23..23] (LZM). This bit reports that propagation time measurement
                                                     was successfully completed. Condition: propagation delay
                                                     compensation LZK in conf_reg1 is set. If the value for
                                                     propagation delay compensation in configuration register
                                                     1 is corrected by the application, this bit will automatically
                                                     be reset. LZM incomplete = 0 LZM complete = 1                             */
      __IOM uint32_t reserved1  : 3;            /*!< [26..24] reserved                                                         */
      __IOM uint32_t rtm_start  : 1;            /*!< [27..27] This bit indicates the beginning of the recovery time,
                                                     if conf2(22)=1 during EnDat transmission with mode command
                                                     1-1 'Encoder transmit position value and selection of memory
                                                     area' with MRS code 0x43 (selection of 2nd word of position
                                                     value 2)                                                                  */
      __IOM uint32_t rtm_stop   : 1;            /*!< [28..28] This bit indicates the end of the recovery time, if
                                                     conf2(22)=1 during EnDat transmission with mode command
                                                     1-1 'Encoder transmit position value and selection of memory
                                                     area' with MRS code 0x43 (selection of 2nd word of position
                                                     value 2)                                                                  */
      __IOM uint32_t speed_ready : 1;           /*!< [29..29] (optional). This bit reports that a new velocity value
                                                     has been calculated. No new velocity value calculated =
                                                     0 New velocity value calculated = 1                                       */
      __IOM uint32_t ready_for_strobe : 1;      /*!< [30..30] This bit reports that data transmission has ended and
                                                     that the EnDat protocol automation machine is ready for
                                                     the next transmission. The time values Recovery time 1
                                                     (tm) and Recovery time 2 (tR) as specified in the EnDat
                                                     specification are completed. No Ready = 0 Ready = 1 This
                                                     bit cannot be reset by writing a 1 to the respective bit
                                                     as this is a status display of the current conditions of
                                                     internal automation engines. The bit cannot cause an interrupt.           */
      __IOM uint32_t ready      : 1;            /*!< [31..31] If the ready bit is set, the status register is completely
                                                     updated. All checks have been performed. Data transmission
                                                     is not yet completed, however, meaning that the EnDat protocol
                                                     automation machine is not yet ready again. No Ready = 0
                                                     Ready = 1                                                                 */
    } endat_stat_b;
  } ;
  
  union {
    __IOM uint32_t endat_int;                   /*!< (@ 0x00000024) Interrupt mask The interrupt mask register is
                                                                    for the masking of the status registers
                                                                    interrupt sources. All bits shown in the
                                                                    status register (except for LZM, LZK, Ready
                                                                    for Strobe) can generate an interrupt. The
                                                                    bit assignments of the interrupt mask register
                                                                    are identical to those of the status register.
                                                                    An interrupt is allowed by setting the corresponding
                                                                    bit to 1. The INT output changes from three-state
                                                                    to low.                                                    */
    
    struct {
      __IOM uint32_t receive1_reg : 1;          /*!< [0..0] ...                                                                */
      __IOM uint32_t error1     : 1;            /*!< [1..1] ...                                                                */
      __IOM uint32_t crcpw_parity : 1;          /*!< [2..2] ...                                                                */
      __IOM uint32_t f_type1    : 1;            /*!< [3..3] ...                                                                */
      __IOM uint32_t f_type2    : 1;            /*!< [4..4] ...                                                                */
      __IOM uint32_t mrs_adr    : 1;            /*!< [5..5] ...                                                                */
      __IOM uint32_t ir6        : 1;            /*!< [6..6] ...                                                                */
      __IOM uint32_t ir7        : 1;            /*!< [7..7] ...                                                                */
      __IOM uint32_t receive2_reg : 1;          /*!< [8..8] ...                                                                */
      __IOM uint32_t receive3_reg : 1;          /*!< [9..9] ...                                                                */
      __IOM uint32_t error2     : 1;            /*!< [10..10] ...                                                              */
      __IOM uint32_t crc_zi1    : 1;            /*!< [11..11] ...                                                              */
      __IOM uint32_t crc_zi2    : 1;            /*!< [12..12] ...                                                              */
      __IOM uint32_t busy       : 1;            /*!< [13..13] ...                                                              */
      __IOM uint32_t RM         : 1;            /*!< [14..14] ...                                                              */
      __IOM uint32_t wrn        : 1;            /*!< [15..15] ...                                                              */
      __IOM uint32_t spike      : 1;            /*!< [16..16] ...                                                              */
      __IOM uint32_t watchdog   : 1;            /*!< [17..17] ...                                                              */
      __IOM uint32_t f_type3    : 1;            /*!< [18..18] ...                                                              */
      __IOM uint32_t reserved0  : 10;           /*!< [28..19] reserved                                                         */
      __IOM uint32_t speed_ready : 1;           /*!< [29..29] ...                                                              */
      __IOM uint32_t reserved1  : 1;            /*!< [30..30] reserved                                                         */
      __IOM uint32_t ready      : 1;            /*!< [31..31] ...                                                              */
    } endat_int_b;
  } ;
  
  union {
    __IM  uint32_t endat_test1;                 /*!< (@ 0x00000028) Test register 1                                            */
    
    struct {
      __IM  uint32_t dl_high    : 1;            /*!< [0..0] For control of the EnDat automation machine.                       */
      __IM  uint32_t status_zi  : 2;            /*!< [2..1] Allows testing of the IC-internal automation machine.
                                                     IC sends no clocks for additional information = 00 IC sends
                                                     clocks for one unit of additional information 1 = 01 IC
                                                     sends clocks for one unit of additional information 2 =
                                                     10 IC sends clocks for two units of additional information
                                                     (1+2) = 11                                                                */
      __IM  uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IM  uint32_t enDat_automation_engine : 6;/*!< [9..4] ...                                                               */
      __IM  uint32_t ic_test_values : 22;       /*!< [31..10] ...                                                              */
    } endat_test1_b;
  } ;
  
  union {
    __IOM uint32_t endat_test2;                 /*!< (@ 0x0000002C) Test register 2                                            */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t selection_tst_out : 1;     /*!< [2..2] For testing, the TST_OUT_PIN pin is assigned as follows:
                                                     Internal (delayed by synchronization) DATA_RC_INT = 0 This
                                                     signal is the signal that belongs to data strobe pulse.                   */
      __IOM uint32_t test_receive_reg : 1;      /*!< [3..3] Standard operating mode = TST receive_reg = 0 Test mode
                                                     for receive register = TST receive_reg = 1 By writing to
                                                     the address of the receive registers, the content of test
                                                     register 2 (bits (31:16) is transferred them. It is not
                                                     possible to directly write to a receive register via the
                                                     parallel port.                                                            */
      __IOM uint32_t sel_test_mux : 2;          /*!< [5..4] (for testing at IC manufacturing site, internal resources
                                                     can be read) Standard operating mode = 00 Central pre-dividers
                                                     = 01 Start bit counter = 10 Delay counter and register,
                                                     additional information bit = 11                                           */
      __IOM uint32_t reserved1  : 1;            /*!< [6..6] reserved                                                           */
      __IOM uint32_t ic_test_mode : 1;          /*!< [7..7] The IC can be switched to a special test mode, allowing
                                                     the testing of internal modules Standard application mode
                                                     = 0 Special test mode = 1                                                 */
      __IOM uint32_t selection_add_info : 3;    /*!< [10..8] The number of required additional information units
                                                     (ZI) can also be selected manually(alternatively to implemented
                                                     ZI automation resources) Automated resources active = 0
                                                     00 IC sends clocks for one unit of additional information
                                                     1 = 0 01 IC sends clocks for one unit of additional information
                                                     2 = 0 10 IC sends clocks for two units of additional information
                                                     (1+2) = 0 11 IC sends no clocks for additional information
                                                     = 1 xx                                                                    */
      __IOM uint32_t test_mode_divider : 1;     /*!< [11..11] (For testing at IC manufacturing site, internal resources
                                                     can be read via test register 4) Standard operating mode
                                                     = 0 Test mode active = 1                                                  */
      __IOM uint32_t sel_test_mux2 : 2;         /*!< [13..12] (For testing at IC manufacturing site, internal resources
                                                     can be read via test register 4) Test_Mode_Divider = 0:
                                                     Selection of test multiplexer 2: Test value Pos1b (Pos1
                                                     - Off2) = 00 Test value Pos1c (Pos1 DIV nsrPos1) = 01 Test
                                                     value Pos1d (Pos1 MOD srM) = 10 Test value Pos2 = 11 Test_Mode_Divider
                                                     = 1 Selection of test multiplexer 2: Test value quotient
                                                     (divider) = 00 Test value remainder (divider) = 01                        */
      __IOM uint32_t sel_test_mux3 : 2;         /*!< [15..14] (For testing at IC manufacturing site, internal resources
                                                     can be read via test register 3) Write value test register
                                                     3 = 00 (Content written to test register 3 via the I/O
                                                     port.) Test values counter TM measurement = 01 TM_High_Err
                                                     & TM_low_Err & F_TM & TM_CT2 &TM_CT1 Limit values for TM
                                                     measurement = 10 C_WT_HIGH & C_WT_LOW & C_HIGH & C_LOW
                                                     Test values internal OEM Reg = 11 (only available in customer-specific
                                                     versions)                                                                 */
      __IOM uint32_t ic_test_data : 16;         /*!< [31..16] RTM value - Counter value of the recovery time measurement
                                                     if conf2(22)=1. Updated after the completion of the recovery
                                                     time tm measurement during the EnDat transmission with
                                                     mode command 1-1 'Encoder transmit position value and selection
                                                     of memory area' with MRS code 0x43 (selection of 2nd word
                                                     of position value 2). With conf2(22)=0, data for the recovery
                                                     time measurement tm are not valid. Writing to the test
                                                     register sets the internal counter of the recovery time
                                                     measurement to the value of the 'write                                    */
    } endat_test2_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive4_0;            /*!< (@ 0x00000030) Receive register 4 Receive register 4 contains
                                                                    position value 2 (Pos2), which is put together
                                                                    from the additional information 1 of Cycles
                                                                    2, 3 and 4. Test function: with the test
                                                                    register 2 bits (13:12), internal test values
                                                                    can be read                                                */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive4_0_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive4_1;            /*!< (@ 0x00000034) Receive register 4                                         */
    
    struct {
      __IM  uint32_t byte5      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte6      : 8;            /*!< [15..8] ...                                                               */
    } endat_receive4_1_b;
  } ;
  
  union {
    __OM  uint32_t endat_sw_strobe;             /*!< (@ 0x00000038) SW strobe                                                  */
    
    struct {
      __OM  uint32_t sw_strobe  : 32;           /*!< [31..0] Writing this register will in each case cause the first
                                                     H/L transition of the TCLK transmission clock signal.                     */
    } endat_sw_strobe_b;
  } ;
  
  union {
    __IM  uint32_t endat_id;                    /*!< (@ 0x0000003C) Identification register The soft-macro specification
                                                                    (ID) is stored here. This information is
                                                                    helpful for automated configuration by higher-level
                                                                    user software. E22: Designates the latest
                                                                    EnDat 2.2 protocol generation 6: MAZeT-internal
                                                                    designation (E6) xxxx: Consecutive version
                                                                    number (this document is valid for all versions
                                                                    as of xx13.)                                               */
    
    struct {
      __IM  uint32_t id         : 32;           /*!< [31..0] ...                                                               */
    } endat_id_b;
  } ;
} endat0_app_Type;                              /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                        endat1_app                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief endat1_app (endat1_app)
  */

typedef struct {                                /*!< (@ 0xFF801740) endat1_app Structure                                       */
  
  union {
    __IOM uint32_t endat_send;                  /*!< (@ 0x00000000) Send register The send register contains data
                                                                    to be transmitted to the EnDat encoder.
                                                                    Mode command MRS code/address/port address
                                                                    (depends on the mode command) Parameters/instructions
                                                                    (depends on the mode command)                              */
    
    struct {
      __IOM uint32_t byte1      : 8;            /*!< [7..0] Parameters / Instructions D[7:0]                                   */
      __IOM uint32_t byte2      : 8;            /*!< [15..8] Parameters / Instructions D[15:0]                                 */
      __IOM uint32_t byte3      : 8;            /*!< [23..16] MRS code / Address / Port address A[7:0]                         */
      __IOM uint32_t byte4      : 6;            /*!< [29..24] Mode bits M[5:0]                                                 */
    } endat_send_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive1_0;            /*!< (@ 0x00000004) Receive register 1 Depending on the transmitted
                                                                    type 2.1 mode command, receive register
                                                                    1 contains different data. With EnDat type
                                                                    2.2 mode commands and with SSI, the position
                                                                    value is always entered into receive-Reg
                                                                    1.                                                         */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive1_0_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive1_1;            /*!< (@ 0x00000008) Receive register 1                                         */
    
    struct {
      __IM  uint32_t byte5      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte6      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte7      : 8;            /*!< [23..16] ...                                                              */
    } endat_receive1_1_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive2;              /*!< (@ 0x0000000C) Receive register 2 If a type 2.2 mode command
                                                                    was sent, receive register 2 will contain
                                                                    the contents of additional information 2
                                                                    and its CRC. This data is to be interpreted
                                                                    in accordance with the EnDat Interface Description.
                                                                    In SSI protocol mode with double-word transmission,
                                                                    the redundant position value is stored here
                                                                    (right-aligned).                                           */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive2_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive3;              /*!< (@ 0x00000010) Receive register 3 If a type 2.2 mode command
                                                                    was sent, receive register 3 will contain
                                                                    the contents of additional information 1
                                                                    and its CRC. This data is to be interpreted
                                                                    in accordance with the EnDat Interface Description.        */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive3_b;
  } ;
  
  union {
    __IOM uint32_t endat_conf1;                 /*!< (@ 0x00000014) Configuration register 1                                   */
    
    struct {
      __IOM uint32_t hw_strobe  : 1;            /*!< [0..0] 1: Enables external /STR signal as strobe signal                   */
      __IOM uint32_t uncond_transfer : 1;       /*!< [1..1] This bit defines the unconditional data transfer to receive
                                                     registers 1, 2, 3, 4 on completion of a data transmission
                                                     process, despite a flag being set in the status register.
                                                     Data transfer according to flag set in the status register
                                                     = 0 Data transfer despite the flag in the status register
                                                     = 1 For safety applications uncond_transfer = 1 must be
                                                     set.                                                                      */
      __IOM uint32_t endat_cont_clk_mode : 1;   /*!< [2..2] This bit is used to select the EnDat continuous clock
                                                     mode. Continuous clock off = 0 Continuous clock on = 1                    */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t f_tclk     : 4;            /*!< [7..4] Setting (4 bit) of transmission rate for EnDat and SSI
                                                     from 100 kHz to 1 MHz (SSI) or 16 MHz (EnDat). Transmission
                                                     frequency = 100kHz = 1111 Transmission frequency = 200kHz
                                                     = 1110 Transmission frequency = 1MHz = 1101 Transmission
                                                     frequency = 2MHz = 1100 Transmission frequency = 4.16MHz
                                                     = 1011 Transmission frequency = 8.33MHz = 0110 Transmission
                                                     frequency = 16.67MHz = 0000..0011                                         */
      __IOM uint32_t data_word_len : 6;         /*!< [13..8] Here the data word length is set binary with 6 bits
                                                     for EnDat or SSI. The permissible setting range for EnDat
                                                     is from 8 bits to 48 bits. The permissible setting range
                                                     for SSI is from 8 bits to 48 bits. Data word length = 0
                                                     bits = 00 1000 : Data word length = 13 bits = 00 1101 :
                                                     Data word length = 48 bits = 11 0000 Note: The Data word
                                                     length has to set to 40/d bit while using mode command
                                                     'encoder transmit test values'. Note: In SSI mode the additionally
                                                     required clock cycle for the parity bit is generated                      */
      __IOM uint32_t reset_window : 1;          /*!< [14..14] The set bit allows resetting of the status and error
                                                     register only within a defined time period. Reset window
                                                     = 0 Resetting of the registers mentioned above can be performed
                                                     anytime (i.e. without considering malfunctions). Reset
                                                     Window = 1 Resetting of the registers mentioned above must
                                                     be performed within a defined time period for acceptance
                                                     by the protocol engine. For safety applications: reset
                                                     window = 1                                                                */
      __IOM uint32_t auto_reset : 1;            /*!< [15..15] Autom. reset (automatic reset). If this bit is set,
                                                     resetting of the status register and error register is
                                                     performed automatically Autom. reset = 0 Resetting of the
                                                     above-mentioned registers must be performed by the application.
                                                     Autom. reset = 1 Resetting of the above-mentioned registers
                                                     is done automatically. However, this resetting only occurs
                                                     in the next EnDat transmission with the start of data reception.
                                                     For safety applications: autom. reset = 0                                 */
      __IOM uint32_t cable_prop_time : 8;       /*!< [23..16] The cable propagation time determined by the interface
                                                     component is stored here. (The application may change this
                                                     value. If that is the case the status registers propagation
                                                     time measurement (LZM) bit will automatically be reset).
                                                     The binary value has a step width of one system clock.
                                                     At a system clock of 64 MHz, this corresponds to a setting
                                                     range from 0 us to 3.98 us in steps of 15.6 ns. The basic
                                                     setting is 00 hex                                                         */
      __IOM uint32_t delay_comp : 1;            /*!< [24..24] Delay compensation. This bit switches propagation delay
                                                     compensation on. When this bit is set, propagation time
                                                     measurement is performed with the next data transmission
                                                     to the EnDat encoder. The interface component determines
                                                     the cable propagation time and saves this in conf_reg1.
                                                     This value is used to determine propagation delay compensation.
                                                     To measure the propagation time again, the delay compensation
                                                     bit must be reset and set again. For 16-bit access it must
                                                     be considered that the measured cable propag                              */
      __IOM uint32_t reserved1  : 1;            /*!< [25..25] reserved                                                         */
      __IOM uint32_t f_sys      : 3;            /*!< [28..26] The system frequency actually used must be selected
                                                     here. 64/48/32/50/100 MHz = 000/010/100/101/110                           */
      __IOM uint32_t ic_reset   : 1;            /*!< [29..29] Setting of this bit has the effect that the entire
                                                     interface component is reset to its initial state. IC reset
                                                     inactive = 0 IC reset active = 1                                          */
      __IOM uint32_t endat_ssi  : 2;            /*!< [31..30] These two bits set either the EnDat (0x2) or the SSI
                                                     (0x1) transmission mode. Values 0x0 and 0x3 are not permitted.
                                                     Note: For debugging purposes, this function may also be
                                                     used to perform an internal status engine software reset
                                                     without clearing of the other internal registers.                         */
    } endat_conf1_b;
  } ;
  
  union {
    __IOM uint32_t endat_conf2;                 /*!< (@ 0x00000018) Configuration register 2                                   */
    
    struct {
      __IOM uint32_t timer_for_sampling_rate : 8;/*!< [7..0] 256 different sampling rates can be set. In the default
                                                     setting 00 hex or 80 hex the timer is off.                                */
      __IOM uint32_t watchdog   : 8;            /*!< [15..8] 256 different watchdog time values can be set. In the
                                                     default setting 00 hex or 80 hex the watchdog is off.                     */
      __IOM uint32_t t_st       : 3;            /*!< [18..16] This time is to be set in accordance with EnDat specification.
                                                     The set time has an accuracy of 0.1 us. Setting 000 = 0.5
                                                     * TCLK Setting 001 = 0.5 us Setting 010 = 1 us Setting
                                                     011 = 1.5 us Setting 100 = 2 us Setting 101 = 4 us Setting
                                                     110 = 8 us Setting 111 = 10 us                                            */
      __IOM uint32_t filter     : 3;            /*!< [21..19] The digital filter for the Data_RC data input can be
                                                     adjusted in eight steps (3 bits) as shown in the table
                                                     below. The filter setting value corresponds to system clock
                                                     cycles. Setting 000 = Off Setting 001 = 3 Setting 010 =
                                                     4 Setting 011 = 5 Setting 100 = 6 Setting 101 = 10 Setting
                                                     110 = 20 Setting 111 = 40 Setting 000 001 010 011 100 101
                                                     110 111 Note on the application: The filter must be set
                                                     according to the transmission rate of the serial interface
                                                     to the encoder.                                                           */
      __IOM uint32_t rtm        : 1;            /*!< [22..22] Activates the recovery time measurement that is then
                                                     performed after each EnDat transmission with the mode command
                                                     1-1 'Encoder transmit position value and selection of memory
                                                     area' with MRS code 0x43 (selection of 2nd word of position
                                                     value 2). RTM=0 Recovery time measurement is deactivated
                                                     (default setting after reset) RTM=1 Recovery time measurement
                                                     is activated                                                              */
      __IOM uint32_t reserved0  : 1;            /*!< [23..23] reserved                                                         */
      __IOM uint32_t hw_strobe_delay : 8;       /*!< [31..24] Here the application can enter a value for the HW strobe
                                                     delay. The binary value has a step width of one system
                                                     clock. Setting 00 = Off, 3..255=3..255 system clock cycles
                                                     The values 1, 2 are not permissible. At a system clock
                                                     of 64 MHz, this corresponds to a value range from 46.88
                                                     ns to 3.98 us in steps of 15.6 ns.                                        */
    } endat_conf2_b;
  } ;
  
  union {
    __IOM uint32_t endat_conf3;                 /*!< (@ 0x0000001C) Configuration register 3                                   */
    
    struct {
      __IOM uint32_t parity     : 1;            /*!< [0..0] Here the parity check for SSI transmission is selected.
                                                     Parity off = 0 Parity on = 1                                              */
      __IOM uint32_t format     : 1;            /*!< [1..1] Here the transmission format for SSI transmission is
                                                     selected. Fir tree: 0 Serial, right-aligned = 1                           */
      __IOM uint32_t gray_to_binary : 1;        /*!< [2..2] In SSI transmission mode, Gray code values can be converted
                                                     here to binary code values. Gray-to-binary conversion inactive
                                                     = 0 Gray-to-binary conversion inactive = 1                                */
      __IOM uint32_t singleturn_res : 5;        /*!< [7..3] Here the number of steps per revolution is set to binary
                                                     with 5 bits. This setting is only required for the fir
                                                     tree format. Singleturn resolution = 13 bits = 0 1101                     */
      __IOM uint32_t dw         : 1;            /*!< [8..8] This bit allows a double-word query to be selected with
                                                     SSI transmission. Double-word query off = 0 Double word
                                                     query on = 1                                                              */
      __IOM uint32_t reserved0  : 6;            /*!< [14..9] reserved                                                          */
      __IOM uint32_t speed      : 1;            /*!< [15..15] (optional) This bit allows selection of the register
                                                     width for velocity. 64-bit = 0 32-Bit = 1                                 */
      __IOM uint32_t reserved1  : 16;           /*!< [31..16] reserved                                                         */
    } endat_conf3_b;
  } ;
  
  union {
    __IOM uint32_t endat_stat;                  /*!< (@ 0x00000020) Status register The status bits are created by
                                                                    the sequencing controller of the interface
                                                                    component, as required. Status information
                                                                    remains set until it is reset by the application.
                                                                    The application can selectively reset status
                                                                    information with a write command. This occurs
                                                                    by writing 1 to the selected bits. In the
                                                                    event of concurrent access, the internal
                                                                    sequencing controller has priority. This
                                                                    ensures that status information is not 'lost'.
                                                                    The status bits (15:11) are only valid when
                                                                    additio                                                    */
    
    struct {
      __IOM uint32_t receive1_reg : 1;          /*!< [0..0] This status flag indicates that the data in Receive-Reg
                                                     1 has been updated. It must be cleared after Receive-Reg1
                                                     has been read to allow the interface component to rewrite
                                                     data there. Receive-Reg1 not updated = 0 Receive-Reg1 updated
                                                     = 1 Note: This flag is ignored if the uncond_transfer bit
                                                     is enabled in conf-Reg 1.                                                 */
      __IOM uint32_t error1     : 1;            /*!< [1..1] The status bit error1 from the EnDat protocol is entered
                                                     here. Error1 did not occur = 0 Error1 occurred = 1                        */
      __IOM uint32_t crcpw_parity : 1;          /*!< [2..2] This bit has two meanings. With EnDat transmission it
                                                     represents the result of the CRC check of the received
                                                     value (position value, parameter or test value). With SSI
                                                     transmission it shows the result of the parity check. Condition:
                                                     parity check in conf-Reg1 is switched on. CRC check or
                                                     parity check okay = 0 CRC and parity check faulty = 1                     */
      __IOM uint32_t f_type1    : 1;            /*!< [3..3] Shows type I error handling in accordance with the EnDat
                                                     specification at Annex A2. A type I error did not occur
                                                     = 0 A type I error occurred = 1                                           */
      __IOM uint32_t f_type2    : 1;            /*!< [4..4] Shows type II error handling in accordance with the EnDat
                                                     specification at Annex A2. A type II error did not occur
                                                     = 0 A type II error occurred = 1                                          */
      __IOM uint32_t mrs_adr    : 1;            /*!< [5..5] The occurrence of an addressing or acknowledgement error
                                                     is shown here as described in the EnDat Interface specification.
                                                     The errors (F type I / II) are special cases of MRS/address
                                                     errors, i.e. they are a sub-quantity of these. Accordingly,
                                                     whenever a type I or type II error is identified, the MRS/Adr
                                                     bit is set. For example, if an MRS/address bit is recognized
                                                     incorrectly due to a disturbance, only the MRS/Adr status
                                                     bit will be set, not the F TYP I/II bits. No acknowledgement
                                                     or addressing error has occ                                               */
      __IOM uint32_t ir6        : 1;            /*!< [6..6] This bit indicates an H/L edge at input pin /IR6. No
                                                     H/L edge transition at input /IR6 = 0 H/L edge transition
                                                     has occurred at input /IR6R6 = 1                                          */
      __IOM uint32_t ir7        : 1;            /*!< [7..7] This bit indicates the state of input pin /IR7. Input
                                                     /IR7 is at high level = 0 Input /IR7 is at low level =
                                                     1                                                                         */
      __IOM uint32_t receive2_reg : 1;          /*!< [8..8] This status flag indicates that the data in Receive-Reg
                                                     2 (3) has been updated. It must be cleared after Receive-Reg2
                                                     (3) has been read to allow the interface component to rewrite
                                                     data. Receive-Reg2 (3) not updated = 0 Receive-Reg2 (3)
                                                     updated = 1                                                               */
      __IOM uint32_t receive3_reg : 1;          /*!< [9..9] This status flag indicates that the data in Receive-Reg3
                                                     has been updated. It must be cleared after Receive-Reg3
                                                     has been read to allow the interface component to rewrite
                                                     data. Receive-Reg3 not updated = 0 Receive-Reg3 updated
                                                     = 1                                                                       */
      __IOM uint32_t error2     : 1;            /*!< [10..10] Contains the /Error 2 status bit from the EnDat protocol
                                                     (only with EnDat2.2 commands). /Error2 occurred = 0 /Error2
                                                     did not occur = 1                                                         */
      __IOM uint32_t crc_zi1    : 1;            /*!< [11..11] During EnDat transmissions, this bit indicates the
                                                     result of the CRC checking of additional information (ZI1).
                                                     CRC check of ZI2 okay = 0 CRC check of ZI2 faulty = 1                     */
      __IOM uint32_t crc_zi2    : 1;            /*!< [12..12] During EnDat transmissions, this bit indicates the
                                                     result of the CRC checking of additional information (ZI2).
                                                     CRC check of ZI2 okay = 0 CRC check of ZI2 faulty = 1                     */
      __IOM uint32_t busy       : 1;            /*!< [13..13] Contains the Busy status bit as transmitted in the
                                                     EnDat protocol. Busy = 0 Busy = 1                                         */
      __IOM uint32_t rm         : 1;            /*!< [14..14] Contains the RM status bit as transmitted in the EnDat
                                                     protocol. RM = 0 RM = 1                                                   */
      __IOM uint32_t wrn        : 1;            /*!< [15..15] Contains the WRN status bit as transmitted in the EnDat
                                                     protocol. WRN = 0 WRN = 1                                                 */
      __IOM uint32_t spike      : 1;            /*!< [16..16] Reports that a Spike was detected at the data input
                                                     port. Condition: filter in conf_reg1 is set. No spike =
                                                     0 Spike occurred = 1                                                      */
      __IOM uint32_t watchdog   : 1;            /*!< [17..17] Reports triggering of the watchdog. Condition: watchdog
                                                     in conf_reg2 is set. Watchdog not triggered = 0 Watchdog
                                                     triggered = 1                                                             */
      __IOM uint32_t f_type3    : 1;            /*!< [18..18] Type II error (transmission layer) triggers F type
                                                     III. Error recognition occurs in the EnDat master. The
                                                     error did not occur = 0 The error occurred = 1                            */
      __IOM uint32_t reserved0  : 3;            /*!< [21..19] reserved                                                         */
      __IOM uint32_t delay_comp : 1;            /*!< [22..22] (LZK). This bit reports if propagation delay compensation
                                                     is active. If propagation delay compensation in configuration
                                                     register 1 is switched off, this bit and propagation time
                                                     measurement will automatically be reset. LZK inactive =
                                                     0 LZK active = 1 Neither the LZM nor the LZK bit can be
                                                     reset by writing a 1 to the respective bit as this is a
                                                     status display of the current conditions of internal automation
                                                     engines. Neither of the two bits can cause an interrupt.                  */
      __IOM uint32_t prop_time_measurement : 1; /*!< [23..23] (LZM). This bit reports that propagation time measurement
                                                     was successfully completed. Condition: propagation delay
                                                     compensation LZK in conf_reg1 is set. If the value for
                                                     propagation delay compensation in configuration register
                                                     1 is corrected by the application, this bit will automatically
                                                     be reset. LZM incomplete = 0 LZM complete = 1                             */
      __IOM uint32_t reserved1  : 3;            /*!< [26..24] reserved                                                         */
      __IOM uint32_t rtm_start  : 1;            /*!< [27..27] This bit indicates the beginning of the recovery time,
                                                     if conf2(22)=1 during EnDat transmission with mode command
                                                     1-1 'Encoder transmit position value and selection of memory
                                                     area' with MRS code 0x43 (selection of 2nd word of position
                                                     value 2)                                                                  */
      __IOM uint32_t rtm_stop   : 1;            /*!< [28..28] This bit indicates the end of the recovery time, if
                                                     conf2(22)=1 during EnDat transmission with mode command
                                                     1-1 'Encoder transmit position value and selection of memory
                                                     area' with MRS code 0x43 (selection of 2nd word of position
                                                     value 2)                                                                  */
      __IOM uint32_t speed_ready : 1;           /*!< [29..29] (optional). This bit reports that a new velocity value
                                                     has been calculated. No new velocity value calculated =
                                                     0 New velocity value calculated = 1                                       */
      __IOM uint32_t ready_for_strobe : 1;      /*!< [30..30] This bit reports that data transmission has ended and
                                                     that the EnDat protocol automation machine is ready for
                                                     the next transmission. The time values Recovery time 1
                                                     (tm) and Recovery time 2 (tR) as specified in the EnDat
                                                     specification are completed. No Ready = 0 Ready = 1 This
                                                     bit cannot be reset by writing a 1 to the respective bit
                                                     as this is a status display of the current conditions of
                                                     internal automation engines. The bit cannot cause an interrupt.           */
      __IOM uint32_t ready      : 1;            /*!< [31..31] If the ready bit is set, the status register is completely
                                                     updated. All checks have been performed. Data transmission
                                                     is not yet completed, however, meaning that the EnDat protocol
                                                     automation machine is not yet ready again. No Ready = 0
                                                     Ready = 1                                                                 */
    } endat_stat_b;
  } ;
  
  union {
    __IOM uint32_t endat_int;                   /*!< (@ 0x00000024) Interrupt mask The interrupt mask register is
                                                                    for the masking of the status registers
                                                                    interrupt sources. All bits shown in the
                                                                    status register (except for LZM, LZK, Ready
                                                                    for Strobe) can generate an interrupt. The
                                                                    bit assignments of the interrupt mask register
                                                                    are identical to those of the status register.
                                                                    An interrupt is allowed by setting the corresponding
                                                                    bit to 1. The INT output changes from three-state
                                                                    to low.                                                    */
    
    struct {
      __IOM uint32_t receive1_reg : 1;          /*!< [0..0] ...                                                                */
      __IOM uint32_t error1     : 1;            /*!< [1..1] ...                                                                */
      __IOM uint32_t crcpw_parity : 1;          /*!< [2..2] ...                                                                */
      __IOM uint32_t f_type1    : 1;            /*!< [3..3] ...                                                                */
      __IOM uint32_t f_type2    : 1;            /*!< [4..4] ...                                                                */
      __IOM uint32_t mrs_adr    : 1;            /*!< [5..5] ...                                                                */
      __IOM uint32_t ir6        : 1;            /*!< [6..6] ...                                                                */
      __IOM uint32_t ir7        : 1;            /*!< [7..7] ...                                                                */
      __IOM uint32_t receive2_reg : 1;          /*!< [8..8] ...                                                                */
      __IOM uint32_t receive3_reg : 1;          /*!< [9..9] ...                                                                */
      __IOM uint32_t error2     : 1;            /*!< [10..10] ...                                                              */
      __IOM uint32_t crc_zi1    : 1;            /*!< [11..11] ...                                                              */
      __IOM uint32_t crc_zi2    : 1;            /*!< [12..12] ...                                                              */
      __IOM uint32_t busy       : 1;            /*!< [13..13] ...                                                              */
      __IOM uint32_t RM         : 1;            /*!< [14..14] ...                                                              */
      __IOM uint32_t wrn        : 1;            /*!< [15..15] ...                                                              */
      __IOM uint32_t spike      : 1;            /*!< [16..16] ...                                                              */
      __IOM uint32_t watchdog   : 1;            /*!< [17..17] ...                                                              */
      __IOM uint32_t f_type3    : 1;            /*!< [18..18] ...                                                              */
      __IOM uint32_t reserved0  : 10;           /*!< [28..19] reserved                                                         */
      __IOM uint32_t speed_ready : 1;           /*!< [29..29] ...                                                              */
      __IOM uint32_t reserved1  : 1;            /*!< [30..30] reserved                                                         */
      __IOM uint32_t ready      : 1;            /*!< [31..31] ...                                                              */
    } endat_int_b;
  } ;
  
  union {
    __IM  uint32_t endat_test1;                 /*!< (@ 0x00000028) Test register 1                                            */
    
    struct {
      __IM  uint32_t dl_high    : 1;            /*!< [0..0] For control of the EnDat automation machine.                       */
      __IM  uint32_t status_zi  : 2;            /*!< [2..1] Allows testing of the IC-internal automation machine.
                                                     IC sends no clocks for additional information = 00 IC sends
                                                     clocks for one unit of additional information 1 = 01 IC
                                                     sends clocks for one unit of additional information 2 =
                                                     10 IC sends clocks for two units of additional information
                                                     (1+2) = 11                                                                */
      __IM  uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IM  uint32_t enDat_automation_engine : 6;/*!< [9..4] ...                                                               */
      __IM  uint32_t ic_test_values : 22;       /*!< [31..10] ...                                                              */
    } endat_test1_b;
  } ;
  
  union {
    __IOM uint32_t endat_test2;                 /*!< (@ 0x0000002C) Test register 2                                            */
    
    struct {
      __IOM uint32_t reserved0  : 2;            /*!< [1..0] reserved                                                           */
      __IOM uint32_t selection_tst_out : 1;     /*!< [2..2] For testing, the TST_OUT_PIN pin is assigned as follows:
                                                     Internal (delayed by synchronization) DATA_RC_INT = 0 This
                                                     signal is the signal that belongs to data strobe pulse.                   */
      __IOM uint32_t test_receive_reg : 1;      /*!< [3..3] Standard operating mode = TST receive_reg = 0 Test mode
                                                     for receive register = TST receive_reg = 1 By writing to
                                                     the address of the receive registers, the content of test
                                                     register 2 (bits (31:16) is transferred them. It is not
                                                     possible to directly write to a receive register via the
                                                     parallel port.                                                            */
      __IOM uint32_t sel_test_mux : 2;          /*!< [5..4] (for testing at IC manufacturing site, internal resources
                                                     can be read) Standard operating mode = 00 Central pre-dividers
                                                     = 01 Start bit counter = 10 Delay counter and register,
                                                     additional information bit = 11                                           */
      __IOM uint32_t reserved1  : 1;            /*!< [6..6] reserved                                                           */
      __IOM uint32_t ic_test_mode : 1;          /*!< [7..7] The IC can be switched to a special test mode, allowing
                                                     the testing of internal modules Standard application mode
                                                     = 0 Special test mode = 1                                                 */
      __IOM uint32_t selection_add_info : 3;    /*!< [10..8] The number of required additional information units
                                                     (ZI) can also be selected manually(alternatively to implemented
                                                     ZI automation resources) Automated resources active = 0
                                                     00 IC sends clocks for one unit of additional information
                                                     1 = 0 01 IC sends clocks for one unit of additional information
                                                     2 = 0 10 IC sends clocks for two units of additional information
                                                     (1+2) = 0 11 IC sends no clocks for additional information
                                                     = 1 xx                                                                    */
      __IOM uint32_t test_mode_divider : 1;     /*!< [11..11] (For testing at IC manufacturing site, internal resources
                                                     can be read via test register 4) Standard operating mode
                                                     = 0 Test mode active = 1                                                  */
      __IOM uint32_t sel_test_mux2 : 2;         /*!< [13..12] (For testing at IC manufacturing site, internal resources
                                                     can be read via test register 4) Test_Mode_Divider = 0:
                                                     Selection of test multiplexer 2: Test value Pos1b (Pos1
                                                     - Off2) = 00 Test value Pos1c (Pos1 DIV nsrPos1) = 01 Test
                                                     value Pos1d (Pos1 MOD srM) = 10 Test value Pos2 = 11 Test_Mode_Divider
                                                     = 1 Selection of test multiplexer 2: Test value quotient
                                                     (divider) = 00 Test value remainder (divider) = 01                        */
      __IOM uint32_t sel_test_mux3 : 2;         /*!< [15..14] (For testing at IC manufacturing site, internal resources
                                                     can be read via test register 3) Write value test register
                                                     3 = 00 (Content written to test register 3 via the I/O
                                                     port.) Test values counter TM measurement = 01 TM_High_Err
                                                     & TM_low_Err & F_TM & TM_CT2 &TM_CT1 Limit values for TM
                                                     measurement = 10 C_WT_HIGH & C_WT_LOW & C_HIGH & C_LOW
                                                     Test values internal OEM Reg = 11 (only available in customer-specific
                                                     versions)                                                                 */
      __IOM uint32_t ic_test_data : 16;         /*!< [31..16] RTM value - Counter value of the recovery time measurement
                                                     if conf2(22)=1. Updated after the completion of the recovery
                                                     time tm measurement during the EnDat transmission with
                                                     mode command 1-1 'Encoder transmit position value and selection
                                                     of memory area' with MRS code 0x43 (selection of 2nd word
                                                     of position value 2). With conf2(22)=0, data for the recovery
                                                     time measurement tm are not valid. Writing to the test
                                                     register sets the internal counter of the recovery time
                                                     measurement to the value of the 'write                                    */
    } endat_test2_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive4_0;            /*!< (@ 0x00000030) Receive register 4 Receive register 4 contains
                                                                    position value 2 (Pos2), which is put together
                                                                    from the additional information 1 of Cycles
                                                                    2, 3 and 4. Test function: with the test
                                                                    register 2 bits (13:12), internal test values
                                                                    can be read                                                */
    
    struct {
      __IM  uint32_t byte1      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte2      : 8;            /*!< [15..8] ...                                                               */
      __IM  uint32_t byte3      : 8;            /*!< [23..16] ...                                                              */
      __IM  uint32_t byte4      : 8;            /*!< [31..24] ...                                                              */
    } endat_receive4_0_b;
  } ;
  
  union {
    __IM  uint32_t endat_receive4_1;            /*!< (@ 0x00000034) Receive register 4                                         */
    
    struct {
      __IM  uint32_t byte5      : 8;            /*!< [7..0] ...                                                                */
      __IM  uint32_t byte6      : 8;            /*!< [15..8] ...                                                               */
    } endat_receive4_1_b;
  } ;
  
  union {
    __OM  uint32_t endat_sw_strobe;             /*!< (@ 0x00000038) SW strobe                                                  */
    
    struct {
      __OM  uint32_t sw_strobe  : 32;           /*!< [31..0] Writing this register will in each case cause the first
                                                     H/L transition of the TCLK transmission clock signal.                     */
    } endat_sw_strobe_b;
  } ;
  
  union {
    __IM  uint32_t endat_id;                    /*!< (@ 0x0000003C) Identification register The soft-macro specification
                                                                    (ID) is stored here. This information is
                                                                    helpful for automated configuration by higher-level
                                                                    user software. E22: Designates the latest
                                                                    EnDat 2.2 protocol generation 6: MAZeT-internal
                                                                    designation (E6) xxxx: Consecutive version
                                                                    number (this document is valid for all versions
                                                                    as of xx13.)                                               */
    
    struct {
      __IM  uint32_t id         : 32;           /*!< [31..0] ...                                                               */
    } endat_id_b;
  } ;
} endat1_app_Type;                              /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                      endat_ctrl0_app                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief endat_ctrl0_app (endat_ctrl0_app)
  */

typedef struct {                                /*!< (@ 0xFF801780) endat_ctrl0_app Structure                                  */
  
  union {
    __IOM uint32_t endat_ctrl_trigger_cfg;      /*!< (@ 0x00000000) EnDat trigger configuration                                */
    
    struct {
      __IOM uint32_t sel        : 4;            /*!< [3..0] Trigger source select This bit field configures which
                                                     event is connected to the strobe signal of the EnDat core.
                                                     A rising edge of the selected event will generate an event
                                                     to the core according to the configuration in the strobe_cfg
                                                     register. Note: When ntimer or n_si are selected, they
                                                     are routed directly to the EnDat core (i.e. they are not
                                                     connected to the pulse former). { | Value trigger event
                                                     0 none 1 manual 2 xc_trigger_out0 3 xc_trigger_out0 (inverted)
                                                     4 xc_t                                                                    */
    } endat_ctrl_trigger_cfg_b;
  } ;
  
  union {
    __IOM uint32_t endat_ctrl_trigger;          /*!< (@ 0x00000004) EnDat trigger                                              */
    
    struct {
      __IOM uint32_t manual     : 1;            /*!< [0..0] Manual trigger. Writing '1' to this bit will trigger
                                                     the EnDat core immediately in case the trigger_cfg.sel
                                                     bit field is set to manual mode and the EnDat core is setup
                                                     for external triggering by the strobe signal.                             */
    } endat_ctrl_trigger_b;
  } ;
  
  union {
    __IOM uint32_t endat_ctrl_strobe_cfg;       /*!< (@ 0x00000008) EnDat strobe pulse form configuration                      */
    
    struct {
      __IOM uint32_t low_len    : 8;            /*!< [7..0] Length of the low phase (i.e. active phase) of the strobe
                                                     signal The low phase will be the programmed value + 1 clock
                                                     cycle. Note: EnDat spec requires the low phase to be at
                                                     least 4 clock cycles long, therefore 0 - 2 are illegal
                                                     settings. Note: If a strobe delay is configured in the
                                                     EnDat core, the minimum length is strobe delay + 1 (i.e.
                                                     program low_len = strobe delay).                                          */
      __IOM uint32_t high_len   : 8;            /*!< [15..8] Length of the high phase (i.e. inactive phase) of the
                                                     strobe signal The high phase will be the programmed value
                                                     + 1 clock cycle. Note: EnDat spec requires the high phase
                                                     to be at least 4 clock cycles long, therefore 0 - 2 are
                                                     illegal settings. Note: There is no other requirement on
                                                     the high phase. This bit field is for debug and test only
                                                     and should be kept at its default setting.                                */
    } endat_ctrl_strobe_cfg_b;
  } ;
} endat_ctrl0_app_Type;                         /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                      endat_ctrl1_app                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief endat_ctrl1_app (endat_ctrl1_app)
  */

typedef struct {                                /*!< (@ 0xFF801790) endat_ctrl1_app Structure                                  */
  
  union {
    __IOM uint32_t endat_ctrl_trigger_cfg;      /*!< (@ 0x00000000) EnDat trigger configuration                                */
    
    struct {
      __IOM uint32_t sel        : 4;            /*!< [3..0] Trigger source select This bit field configures which
                                                     event is connected to the strobe signal of the EnDat core.
                                                     A rising edge of the selected event will generate an event
                                                     to the core according to the configuration in the strobe_cfg
                                                     register. Note: When ntimer or n_si are selected, they
                                                     are routed directly to the EnDat core (i.e. they are not
                                                     connected to the pulse former). { | Value trigger event
                                                     0 none 1 manual 2 xc_trigger_out0 3 xc_trigger_out0 (inverted)
                                                     4 xc_t                                                                    */
    } endat_ctrl_trigger_cfg_b;
  } ;
  
  union {
    __IOM uint32_t endat_ctrl_trigger;          /*!< (@ 0x00000004) EnDat trigger                                              */
    
    struct {
      __IOM uint32_t manual     : 1;            /*!< [0..0] Manual trigger. Writing '1' to this bit will trigger
                                                     the EnDat core immediately in case the trigger_cfg.sel
                                                     bit field is set to manual mode and the EnDat core is setup
                                                     for external triggering by the strobe signal.                             */
    } endat_ctrl_trigger_b;
  } ;
  
  union {
    __IOM uint32_t endat_ctrl_strobe_cfg;       /*!< (@ 0x00000008) EnDat strobe pulse form configuration                      */
    
    struct {
      __IOM uint32_t low_len    : 8;            /*!< [7..0] Length of the low phase (i.e. active phase) of the strobe
                                                     signal The low phase will be the programmed value + 1 clock
                                                     cycle. Note: EnDat spec requires the low phase to be at
                                                     least 4 clock cycles long, therefore 0 - 2 are illegal
                                                     settings. Note: If a strobe delay is configured in the
                                                     EnDat core, the minimum length is strobe delay + 1 (i.e.
                                                     program low_len = strobe delay).                                          */
      __IOM uint32_t high_len   : 8;            /*!< [15..8] Length of the high phase (i.e. inactive phase) of the
                                                     strobe signal The high phase will be the programmed value
                                                     + 1 clock cycle. Note: EnDat spec requires the high phase
                                                     to be at least 4 clock cycles long, therefore 0 - 2 are
                                                     illegal settings. Note: There is no other requirement on
                                                     the high phase. This bit field is for debug and test only
                                                     and should be kept at its default setting.                                */
    } endat_ctrl_strobe_cfg_b;
  } ;
} endat_ctrl1_app_Type;                         /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                       can_ctrl0_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief can_ctrl0_app (can_ctrl0_app)
  */

typedef struct {                                /*!< (@ 0xFF801900) can_ctrl0_app Structure                                    */
  
  union {
    __IOM uint32_t canctrl_mode;                /*!< (@ 0x00000000) CAN mode register                                          */
    
    struct {
      __IOM uint32_t reset_mode : 1;            /*!< [0..0] Reset Mode 1 reset; detection of a set reset mode bit
                                                     results in aborting the current transmission/reception
                                                     of a message and entering the reset mode 0 normal; on the
                                                     `1-to-0' transition of the reset mode bit, the CAN controller
                                                     returns to the operating mode                                             */
      __IOM uint32_t listen_mode : 1;           /*!< [1..1] Listen Only Mode 1 listen only; in this mode the CAN
                                                     controller would give no acknowledge to the CAN-bus, even
                                                     if a message is received successfully; the error counters
                                                     are stopped at the current value 0 normal                                 */
      __IOM uint32_t selftest   : 1;            /*!< [2..2] Self Test Mode 1 self test; in this mode a full node
                                                     test is possible without any other active node on the bus
                                                     using the self reception request command; the CAN controller
                                                     will perform a successful transmission, even if there is
                                                     no acknowledge received 0 normal; an acknowledge is required
                                                     for successful transmission                                               */
      __IOM uint32_t acceptance_mode : 1;       /*!< [3..3] Acceptance Filter Mode 1 single; the single acceptance
                                                     filter option is enabled (one filter with the length of
                                                     32 bit is active) 0 dual; the dual acceptance filter option
                                                     is enabled (two filters, each with the length of 16 bit
                                                     are active)                                                               */
    } canctrl_mode_b;
  } ;
  
  union {
    __OM  uint32_t canctrl_command;             /*!< (@ 0x00000004) CAN command register                                       */
    
    struct {
      __OM  uint32_t tx_request : 1;            /*!< [0..0] Transmission Request, self-clearing 1 present; a message
                                                     shall be transmitted                                                      */
      __OM  uint32_t abort_tx   : 1;            /*!< [1..1] Abort Transmission, self-clearing 1 present; if not already
                                                     in progress, a pending transmission request is cancelled
                                                     Setting the command bits tx_request and abort_tx simultaneously
                                                     results in sending the transmit message once. No re-transmission
                                                     will be performed in the event of an error or arbitration
                                                     lost (single-shot transmission).                                          */
      __OM  uint32_t release_rx_buf : 1;        /*!< [2..2] Release Receive Buffer, self-clearing 1 released; the
                                                     receive buffer, representing the message memory space in
                                                     the RXFIFO is released                                                    */
      __OM  uint32_t clr_overrun : 1;           /*!< [3..3] Clear Data Overrun, self-clearing 1 clear; the data overrun
                                                     status bit is cleared, shall be used together with release_rx_buf
                                                     to release invalid buffer                                                 */
      __OM  uint32_t self_rx_request : 1;       /*!< [4..4] Self Reception Request, self-clearing 1 present; a message
                                                     shall be transmitted and received simultaneously Setting
                                                     tx_request and self_rx_request simultaneously will ignore
                                                     the set self_rx_request bit.                                              */
    } canctrl_command_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_status;              /*!< (@ 0x00000008) CAN status register                                        */
    
    struct {
      __IM  uint32_t rx_buf_status : 1;         /*!< [0..0] Receive Buffer Status 1 full; one or more complete messages
                                                     are available in the RXFIFO 0 empty; no message is available              */
      __IM  uint32_t overrun    : 1;            /*!< [1..1] Data Overrun Status 1 overrun; a message was lost because
                                                     there was not enough space for that message in the RXFIFO
                                                     0 absent; no data overrun has occurred since the last clear
                                                     data overrun command was given                                            */
      __IM  uint32_t tx_buf_status : 1;         /*!< [2..2] Transmit Buffer Status 1 released; the CPU may write
                                                     a message into the transmit buffer 0 locked; the CPU cannot
                                                     access the transmit buffer ; a message is either waiting
                                                     for transmission or is in the process of being transmitted                */
      __IM  uint32_t tx_complete : 1;           /*!< [3..3] Transmission Complete 1 complete; last requested transmission
                                                     has been successfully completed 0 incomplete; previously
                                                     requested transmission is not yet completed                               */
      __IM  uint32_t rx_status  : 1;            /*!< [4..4] Receive Status 1 receive; the CAN controller is receiving
                                                     a message 0 idle                                                          */
      __IM  uint32_t tx_status  : 1;            /*!< [5..5] Transmit Status 1 transmit; the CAN controller is transmitting
                                                     a message 0 idle                                                          */
      __IM  uint32_t error_status : 1;          /*!< [6..6] Error Status 1 error; at least one of the error counters
                                                     has reached or exceeded the CPU warning limit defined by
                                                     the Error Warning Limit Register (EWLR) 0 ok; both error
                                                     counters are below the warning limit                                      */
      __IM  uint32_t bus_status : 1;            /*!< [7..7] Bus Status 1 bus-off; the CAN controller is not involved
                                                     in bus activities 0 bus-on; the CAN controller is involved
                                                     in bus activities                                                         */
    } canctrl_status_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_irq;                 /*!< (@ 0x0000000C) CAN interrupt register reading the register will
                                                                    clear all bits except rx_irq                               */
    
    struct {
      __IM  uint32_t rx_irq     : 1;            /*!< [0..0] Receive Interrupt 1 set; this bit is set while the receive
                                                     FIFO is not empty and the rx_irq_en bit is set within the
                                                     interrupt enable register 0 reset; no more message is available
                                                     within the RXFIFO                                                         */
      __IM  uint32_t tx_irq     : 1;            /*!< [1..1] Transmit Interrupt 1 set; this bit is set whenever the
                                                     transmit buffer status changes from `0-to-1' (released)
                                                     and the tx_irq_en bit is set within the interrupt enable
                                                     register 0 reset                                                          */
      __IM  uint32_t warning_irq : 1;           /*!< [2..2] Error Warning Interrupt 1 set; this bit is set on every
                                                     change (set and clear) of either the error status or bus
                                                     status bits and the warning_irq_en bit is set within the
                                                     interrupt enable register 0 reset                                         */
      __IM  uint32_t overrun_irq : 1;           /*!< [3..3] Data Overrun Interrup 1 set; this bit is set on a `0-to-1'
                                                     transition of the data overrun status bit and the overrun_irq_en
                                                     bit is set within the interrupt enable register 0 reset                   */
      __IM  uint32_t reserved0  : 1;            /*!< [4..4] reserved                                                           */
      __IM  uint32_t err_passive_irq : 1;       /*!< [5..5] Error Passive Interrupt 1 set; this bit is set whenever
                                                     the CAN controller has reached the error passive status
                                                     (at least one error counter exceeds the protocol-defined
                                                     level of 127) or if the CAN controller is in the error
                                                     passive status and enters the error active status again
                                                     and the err_passive_irq_en bit is set within the interrupt
                                                     enable register 0 reset                                                   */
      __IM  uint32_t arb_lost_irq : 1;          /*!< [6..6] Arbitration Lost Interrupt 1 set; this bit is set when
                                                     the CAN controller lost the arbitration and becomes a receiver
                                                     and the arb_lost_irq_en bit is set within the interrupt
                                                     enable register, will only get active again if canctrl_arb_lost_capture
                                                     register is read 0 reset                                                  */
      __IM  uint32_t bus_error_irq : 1;         /*!< [7..7] Bus Error Interrupt 1 set; this bit is set when the CAN
                                                     controller detects an error on the CAN-bus and the bus_error_irq_en
                                                     bit is set within the interrupt enable register, will only
                                                     get active again if canctrl_err_code_capture register is
                                                     read 0 reset                                                              */
      __IM  uint32_t reserved1  : 24;           /*!< [31..8] reserved                                                          */
    } canctrl_irq_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_irq_en;              /*!< (@ 0x00000010) CAN interrupt enable register in not extended
                                                                    mode: acceptance_code_0                                    */
    
    struct {
      __IOM uint32_t rx_irq_en  : 1;            /*!< [0..0] Receive Interrupt Enable 1 enabled; when the receive
                                                     buffer status is `full' the CAN controller requests the
                                                     respective interrupt 0 disabled                                           */
      __IOM uint32_t tx_irq_en  : 1;            /*!< [1..1] Transmit Interrupt Enable 1 enabled; when a message has
                                                     been successfully transmitted or the transmit buffer is
                                                     accessible again (e.g. after an abort transmission command),
                                                     the CAN controller requests the respective interrupt 0
                                                     disabled                                                                  */
      __IOM uint32_t warning_irq_en : 1;        /*!< [2..2] Error Warning Interrupt Enable 1 enabled; if the error
                                                     or bus status change (see status register), the CAN controller
                                                     requests the respective interrupt 0 disabled                              */
      __IOM uint32_t overrun_irq_en : 1;        /*!< [3..3] Data Overrun Interrupt Enable 1 enabled; if the data
                                                     overrun status bit is set (see status register; Table 14),
                                                     the CAN controller requests the respective interrupt 0
                                                     disabled                                                                  */
      __IOM uint32_t reserved0  : 1;            /*!< [4..4] reserved                                                           */
      __IOM uint32_t err_passive_irq_en : 1;    /*!< [5..5] Error Passive Interrupt Enable 1 enabled; if the error
                                                     status of the CAN controller changes from error active
                                                     to error passive or vice versa, the respective interrupt
                                                     is requested 0 disabled                                                   */
      __IOM uint32_t arb_lost_irq_en : 1;       /*!< [6..6] Arbitration Lost Interrupt Enable 1 enabled; if the CAN
                                                     controller has lost arbitration, the respective interrupt
                                                     is requested 0 disabled                                                   */
      __IOM uint32_t bus_error_irq_en : 1;      /*!< [7..7] Bus Error Interrupt Enable 1 enabled; if an bus error
                                                     has been detected, the CAN controller requests the respective
                                                     interrupt 0 disabled                                                      */
      __IOM uint32_t reserved1  : 24;           /*!< [31..8] reserved                                                          */
    } canctrl_irq_en_b;
  } ;
  __IOM uint32_t  canctrl_not_extended_acceptance_mask0;/*!< (@ 0x00000014) CAN not extended acceptance mask register          */
  
  union {
    __IOM uint32_t canctrl_bus_timing0;         /*!< (@ 0x00000018) CAN bus timing register 0, only writable in reset
                                                                    mode in not extended mode: acceptance_mask_0               */
    
    struct {
      __IOM uint32_t prescaler  : 9;            /*!< [8..0] Baud Rate Prescaler The period of the CAN system clock
                                                     tscl is programmable and determines the individual bit
                                                     timing. The CAN system clock is calculated using the following
                                                     equation: tscl = tCLK * prescaler with tCLK = 10 ns                       */
      __IOM uint32_t sync_jump_width : 2;       /*!< [10..9] Synchronization Jump Width To compensate for phase shifts
                                                     between clock oscillators of different bus controllers,
                                                     any bus controller must re-synchronize on any relevant
                                                     signal edge of the current transmission. The synchronization
                                                     jump width defines the maximum number of clock cycles a
                                                     bit period may be shortened or lengthened by one re-synchronization:
                                                     tSJW = tscl * (sync_jump_width + 1)                                       */
    } canctrl_bus_timing0_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_bus_timing1;         /*!< (@ 0x0000001C) CAN bus timing register 1, only writable in reset
                                                                    mode                                                       */
    
    struct {
      __IOM uint32_t tseg1      : 6;            /*!< [5..0] Time Segment 1 (TSEG1) TSEG1 determine the number of
                                                     clock cycles per bit period and the location of the sample
                                                     point, where: tSYNCSEG = 1 * tscl tTSEG1 = tscl * (tseg1
                                                     + 1)                                                                      */
      __IOM uint32_t reserved0  : 1;            /*!< [6..6] reserved                                                           */
      __IOM uint32_t oversampling : 1;          /*!< [7..7] Sampling 1 triple; the bus is sampled three times; recommended
                                                     for low/medium speed buses (class A and B) where filtering
                                                     spikes on the bus line is beneficial 0 single; the bus
                                                     is sampled once; recommended for high speed buses (SAE
                                                     class C)                                                                  */
      __IOM uint32_t tseg2      : 5;            /*!< [12..8] Time Segment 2 (TSEG2) TSEG2 determine the number of
                                                     clock cycles per bit period and the location of the sample
                                                     point, where: tTSEG2 = tscl * (tseg2 + 1)                                 */
      __IOM uint32_t reserved1  : 19;           /*!< [31..13] reserved                                                         */
    } canctrl_bus_timing1_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  __IOM uint32_t  canctrl_not_extended_data0;   /*!< (@ 0x00000028) CAN not extended data register                             */
  
  union {
    __IM  uint32_t canctrl_arb_lost_capture;    /*!< (@ 0x0000002C) CAN arbitration lost capture register This register
                                                                    contains information about the bit position
                                                                    of losing arbitration. reading the register
                                                                    will clear all bits in not extended mode:
                                                                    data1                                                      */
    
    struct {
      __IM  uint32_t position   : 5;            /*!< [4..0] Positon where arbitration was lost { | Decimal value
                                                     Position 00 arbitration lost in bit 1 of identifier 01
                                                     arbitration lost in bit 2 of identifier 02 arbitration
                                                     lost in bit 3 of identifier 03 arbitration lost in bit
                                                     4 of identifier 04 arbitration lost in bit 5 of identifier
                                                     05 arbitration lost in bit 6 of identifier 06 arbitration
                                                     lost in bit 7 of identifier 07 arbitration lost in bit
                                                     8 of identifier 08 arbitration lo                                         */
    } canctrl_arb_lost_capture_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_err_code_capture;    /*!< (@ 0x00000030) CAN error code capture register This register
                                                                    contains information about the type and
                                                                    location of errors on the bus. reading the
                                                                    register will clear all bits in not extended
                                                                    mode: data2                                                */
    
    struct {
      __IM  uint32_t segment    : 5;            /*!< [4..0] Frame segment where error was detected { | Binary value
                                                     Segment 00011 start of frame 00010 ID.28 to ID.21 00110
                                                     ID.20 to ID.18 00100 bit SRTR 00101 bit IDE 00111 ID.17
                                                     to ID.13 01111 ID.12 to ID.5 01110 ID.4 to ID.0 01100 bit
                                                     RTR 01101 reser ved bit 1 01001 reser ved bit 0 01011 data
                                                     length code 01010 data field 01000 CRC sequence 11000                     */
      __IM  uint32_t direction  : 1;            /*!< [5..5] Direction 1 RX; error occurred during reception 0 TX;
                                                     error occurred during transmission                                        */
      __IM  uint32_t err_code   : 2;            /*!< [7..6] Error code { | Binary value Code 00 bit error 01 form
                                                     error 10 stuff error 11 other type of error }                             */
    } canctrl_err_code_capture_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_err_warning_limit;   /*!< (@ 0x00000034) CAN error warning limit register, only writable
                                                                    in reset mode in not extended mode: data3                  */
    
    struct {
      __IOM uint32_t limit      : 8;            /*!< [7..0] error warning limit                                                */
    } canctrl_err_warning_limit_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_rx_error_cnt;        /*!< (@ 0x00000038) CAN RX error counter register, only writable
                                                                    in reset mode The RX error counter register
                                                                    reflects the current value of the receive
                                                                    error counter. If a bus-off event occurs,
                                                                    the RX error counter is initialized to logic
                                                                    0. The time bus-off is valid, writing to
                                                                    this register has no effect. Note, that
                                                                    a CPU-forced content change of the RX error
                                                                    counter is only possible, if the reset mode
                                                                    was entered previously. An error status
                                                                    change (see status register), an error warning
                                                                    or an error passive in                                     */
    
    struct {
      __IOM uint32_t rx_err     : 8;            /*!< [7..0] rx error counter                                                   */
    } canctrl_rx_error_cnt_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_tx_error_cnt;        /*!< (@ 0x0000003C) CAN TX error counter register, only writable
                                                                    in reset mode The TX error counter register
                                                                    reflects the current value of the transmit
                                                                    error counter. If a bus-off event occurs,
                                                                    the TX error counter is initialized to 127
                                                                    to count the minimum protocol-defined time
                                                                    (128 occurrences of the bus-free signal).
                                                                    Reading the TX error counter during this
                                                                    time gives information about the status
                                                                    of the bus-off recovery. If bus-off is active,
                                                                    a write access to TXERR in the range from
                                                                    0 to 254 clears the bus-                                   */
    
    struct {
      __IOM uint32_t tx_err     : 8;            /*!< [7..0] tx error counter                                                   */
    } canctrl_tx_error_cnt_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data0;               /*!< (@ 0x00000040) CAN data register 0 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 0 Operating
                                                                    mode: R: Standard frame: Read RX frame information
                                                                    Extended frame: Read RX frame information
                                                                    W: Standard frame: Write TX frame information
                                                                    Extended frame: Write TX frame information
                                                                    } in not extended mode: data6                              */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data0_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data1;               /*!< (@ 0x00000044) CAN data register 1 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 1 Operating
                                                                    mode: R: Standard frame: Read RX identifier
                                                                    1 Extended frame: Read RX identifier 1 W:
                                                                    Standard frame: Write TX identifier 1 Extended
                                                                    frame: Write TX identifier 1 } in not extended
                                                                    mode: data7                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data1_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data2;               /*!< (@ 0x00000048) CAN data register 2 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 2 Operating
                                                                    mode: R: Standard frame: Read RX identifier
                                                                    2 Extended frame: Read RX identifier 2 W:
                                                                    Standard frame: Write TX identifier 2 Extended
                                                                    frame: Write TX identifier 2 } in not extended
                                                                    mode: data8                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data2_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data3;               /*!< (@ 0x0000004C) CAN data register 3 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 3 Operating
                                                                    mode: R: Standard frame: Read RX data 1
                                                                    Extended frame: Read RX identifier 3 W:
                                                                    Standard frame: Write TX data 1 Extended
                                                                    frame: Write TX identifier 3 } in not extended
                                                                    mode: data9                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data3_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data4;               /*!< (@ 0x00000050) CAN data register 4 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 0 Operating
                                                                    mode: R: Standard frame: Read RX data 2
                                                                    Extended frame: Read RX identifier 4 W:
                                                                    Standard frame: Write TX data 2 Extended
                                                                    frame: Write TX identifier 4 }                             */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data4_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data5;               /*!< (@ 0x00000054) CAN data register 5 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 1 Operating
                                                                    mode: R: Standard frame: Read RX data 3
                                                                    Extended frame: Read RX data 1 W: Standard
                                                                    frame: Write TX data 3 Extended frame: Write
                                                                    TX data 1 }                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data5_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data6;               /*!< (@ 0x00000058) CAN data register 6 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 2 Operating
                                                                    mode: R: Standard frame: Read RX data 4
                                                                    Extended frame: Read RX data 2 W: Standard
                                                                    frame: Write TX data 4 Extended frame: Write
                                                                    TX data 2 }                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data6_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data7;               /*!< (@ 0x0000005C) CAN data register 7 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 3 Operating
                                                                    mode: R: Standard frame: Read RX data 5
                                                                    Extended frame: Read RX data 3 W: Standard
                                                                    frame: Write TX data 5 Extended frame: Write
                                                                    TX data 3 }                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data7_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data8;               /*!< (@ 0x00000060) CAN data register 8 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    Read RX data 6 Extended frame: Read RX data
                                                                    4 W: Standard frame: Write TX data 6 Extended
                                                                    frame: Write TX data 4 }                                   */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data8_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data9;               /*!< (@ 0x00000064) CAN data register 9 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    Read RX data 7 Extended frame: Read RX data
                                                                    5 W: Standard frame: Write TX data 7 Extended
                                                                    frame: Write TX data 5 }                                   */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data9_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data10;              /*!< (@ 0x00000068) CAN data register 10 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    Read RX data 8 Extended frame: Read RX data
                                                                    6 W: Standard frame: Write TX data 8 Extended
                                                                    frame: Write TX data 6 }                                   */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data10_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data11;              /*!< (@ 0x0000006C) CAN data register 11 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    reserved Extended frame: Read RX data 7
                                                                    W: Standard frame: reserved Extended frame:
                                                                    Write TX data 7 }                                          */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data11_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data12;              /*!< (@ 0x00000070) CAN data register 12 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    reserved Extended frame: Read RX data 8
                                                                    W: Standard frame: reserved Extended frame:
                                                                    Write TX data 8 }                                          */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data12_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_rx_message_cnt;      /*!< (@ 0x00000074) CAN RX message counter register Reflects the
                                                                    number of messages available within the
                                                                    RXFIFO. The value is incremented with each
                                                                    receive event and decremented by the release
                                                                    receive buffer command. After any reset
                                                                    event, this register is cleared.                           */
    
    struct {
      __IM  uint32_t rx_msg_cnt : 7;            /*!< [6..0] rx message counter                                                 */
    } canctrl_rx_message_cnt_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t canctrl_mode_control;        /*!< (@ 0x0000007C) CAN mode control register, only writable in reset
                                                                    mode                                                       */
    
    struct {
      __IM  uint32_t reserved0  : 7;            /*!< [6..0] reserved                                                           */
      __IM  uint32_t mode       : 1;            /*!< [7..7] 0: BasicCAN mode, 1: PeliCAN mode recommended value is
                                                     1 (PeliCAN mode), The here given register map of all registers
                                                     of the CAN controller is valid for PeliCAN only.                          */
      __IM  uint32_t reserved1  : 24;           /*!< [31..8] reserved                                                          */
    } canctrl_mode_control_b;
  } ;
} can_ctrl0_app_Type;                           /*!< Size = 128 (0x80)                                                         */



/* =========================================================================================================================== */
/* ================                                       can_ctrl1_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief can_ctrl1_app (can_ctrl1_app)
  */

typedef struct {                                /*!< (@ 0xFF801980) can_ctrl1_app Structure                                    */
  
  union {
    __IOM uint32_t canctrl_mode;                /*!< (@ 0x00000000) CAN mode register                                          */
    
    struct {
      __IOM uint32_t reset_mode : 1;            /*!< [0..0] Reset Mode 1 reset; detection of a set reset mode bit
                                                     results in aborting the current transmission/reception
                                                     of a message and entering the reset mode 0 normal; on the
                                                     `1-to-0' transition of the reset mode bit, the CAN controller
                                                     returns to the operating mode                                             */
      __IOM uint32_t listen_mode : 1;           /*!< [1..1] Listen Only Mode 1 listen only; in this mode the CAN
                                                     controller would give no acknowledge to the CAN-bus, even
                                                     if a message is received successfully; the error counters
                                                     are stopped at the current value 0 normal                                 */
      __IOM uint32_t selftest   : 1;            /*!< [2..2] Self Test Mode 1 self test; in this mode a full node
                                                     test is possible without any other active node on the bus
                                                     using the self reception request command; the CAN controller
                                                     will perform a successful transmission, even if there is
                                                     no acknowledge received 0 normal; an acknowledge is required
                                                     for successful transmission                                               */
      __IOM uint32_t acceptance_mode : 1;       /*!< [3..3] Acceptance Filter Mode 1 single; the single acceptance
                                                     filter option is enabled (one filter with the length of
                                                     32 bit is active) 0 dual; the dual acceptance filter option
                                                     is enabled (two filters, each with the length of 16 bit
                                                     are active)                                                               */
    } canctrl_mode_b;
  } ;
  
  union {
    __OM  uint32_t canctrl_command;             /*!< (@ 0x00000004) CAN command register                                       */
    
    struct {
      __OM  uint32_t tx_request : 1;            /*!< [0..0] Transmission Request, self-clearing 1 present; a message
                                                     shall be transmitted                                                      */
      __OM  uint32_t abort_tx   : 1;            /*!< [1..1] Abort Transmission, self-clearing 1 present; if not already
                                                     in progress, a pending transmission request is cancelled
                                                     Setting the command bits tx_request and abort_tx simultaneously
                                                     results in sending the transmit message once. No re-transmission
                                                     will be performed in the event of an error or arbitration
                                                     lost (single-shot transmission).                                          */
      __OM  uint32_t release_rx_buf : 1;        /*!< [2..2] Release Receive Buffer, self-clearing 1 released; the
                                                     receive buffer, representing the message memory space in
                                                     the RXFIFO is released                                                    */
      __OM  uint32_t clr_overrun : 1;           /*!< [3..3] Clear Data Overrun, self-clearing 1 clear; the data overrun
                                                     status bit is cleared, shall be used together with release_rx_buf
                                                     to release invalid buffer                                                 */
      __OM  uint32_t self_rx_request : 1;       /*!< [4..4] Self Reception Request, self-clearing 1 present; a message
                                                     shall be transmitted and received simultaneously Setting
                                                     tx_request and self_rx_request simultaneously will ignore
                                                     the set self_rx_request bit.                                              */
    } canctrl_command_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_status;              /*!< (@ 0x00000008) CAN status register                                        */
    
    struct {
      __IM  uint32_t rx_buf_status : 1;         /*!< [0..0] Receive Buffer Status 1 full; one or more complete messages
                                                     are available in the RXFIFO 0 empty; no message is available              */
      __IM  uint32_t overrun    : 1;            /*!< [1..1] Data Overrun Status 1 overrun; a message was lost because
                                                     there was not enough space for that message in the RXFIFO
                                                     0 absent; no data overrun has occurred since the last clear
                                                     data overrun command was given                                            */
      __IM  uint32_t tx_buf_status : 1;         /*!< [2..2] Transmit Buffer Status 1 released; the CPU may write
                                                     a message into the transmit buffer 0 locked; the CPU cannot
                                                     access the transmit buffer ; a message is either waiting
                                                     for transmission or is in the process of being transmitted                */
      __IM  uint32_t tx_complete : 1;           /*!< [3..3] Transmission Complete 1 complete; last requested transmission
                                                     has been successfully completed 0 incomplete; previously
                                                     requested transmission is not yet completed                               */
      __IM  uint32_t rx_status  : 1;            /*!< [4..4] Receive Status 1 receive; the CAN controller is receiving
                                                     a message 0 idle                                                          */
      __IM  uint32_t tx_status  : 1;            /*!< [5..5] Transmit Status 1 transmit; the CAN controller is transmitting
                                                     a message 0 idle                                                          */
      __IM  uint32_t error_status : 1;          /*!< [6..6] Error Status 1 error; at least one of the error counters
                                                     has reached or exceeded the CPU warning limit defined by
                                                     the Error Warning Limit Register (EWLR) 0 ok; both error
                                                     counters are below the warning limit                                      */
      __IM  uint32_t bus_status : 1;            /*!< [7..7] Bus Status 1 bus-off; the CAN controller is not involved
                                                     in bus activities 0 bus-on; the CAN controller is involved
                                                     in bus activities                                                         */
    } canctrl_status_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_irq;                 /*!< (@ 0x0000000C) CAN interrupt register reading the register will
                                                                    clear all bits except rx_irq                               */
    
    struct {
      __IM  uint32_t rx_irq     : 1;            /*!< [0..0] Receive Interrupt 1 set; this bit is set while the receive
                                                     FIFO is not empty and the rx_irq_en bit is set within the
                                                     interrupt enable register 0 reset; no more message is available
                                                     within the RXFIFO                                                         */
      __IM  uint32_t tx_irq     : 1;            /*!< [1..1] Transmit Interrupt 1 set; this bit is set whenever the
                                                     transmit buffer status changes from `0-to-1' (released)
                                                     and the tx_irq_en bit is set within the interrupt enable
                                                     register 0 reset                                                          */
      __IM  uint32_t warning_irq : 1;           /*!< [2..2] Error Warning Interrupt 1 set; this bit is set on every
                                                     change (set and clear) of either the error status or bus
                                                     status bits and the warning_irq_en bit is set within the
                                                     interrupt enable register 0 reset                                         */
      __IM  uint32_t overrun_irq : 1;           /*!< [3..3] Data Overrun Interrup 1 set; this bit is set on a `0-to-1'
                                                     transition of the data overrun status bit and the overrun_irq_en
                                                     bit is set within the interrupt enable register 0 reset                   */
      __IM  uint32_t reserved0  : 1;            /*!< [4..4] reserved                                                           */
      __IM  uint32_t err_passive_irq : 1;       /*!< [5..5] Error Passive Interrupt 1 set; this bit is set whenever
                                                     the CAN controller has reached the error passive status
                                                     (at least one error counter exceeds the protocol-defined
                                                     level of 127) or if the CAN controller is in the error
                                                     passive status and enters the error active status again
                                                     and the err_passive_irq_en bit is set within the interrupt
                                                     enable register 0 reset                                                   */
      __IM  uint32_t arb_lost_irq : 1;          /*!< [6..6] Arbitration Lost Interrupt 1 set; this bit is set when
                                                     the CAN controller lost the arbitration and becomes a receiver
                                                     and the arb_lost_irq_en bit is set within the interrupt
                                                     enable register, will only get active again if canctrl_arb_lost_capture
                                                     register is read 0 reset                                                  */
      __IM  uint32_t bus_error_irq : 1;         /*!< [7..7] Bus Error Interrupt 1 set; this bit is set when the CAN
                                                     controller detects an error on the CAN-bus and the bus_error_irq_en
                                                     bit is set within the interrupt enable register, will only
                                                     get active again if canctrl_err_code_capture register is
                                                     read 0 reset                                                              */
      __IM  uint32_t reserved1  : 24;           /*!< [31..8] reserved                                                          */
    } canctrl_irq_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_irq_en;              /*!< (@ 0x00000010) CAN interrupt enable register in not extended
                                                                    mode: acceptance_code_0                                    */
    
    struct {
      __IOM uint32_t rx_irq_en  : 1;            /*!< [0..0] Receive Interrupt Enable 1 enabled; when the receive
                                                     buffer status is `full' the CAN controller requests the
                                                     respective interrupt 0 disabled                                           */
      __IOM uint32_t tx_irq_en  : 1;            /*!< [1..1] Transmit Interrupt Enable 1 enabled; when a message has
                                                     been successfully transmitted or the transmit buffer is
                                                     accessible again (e.g. after an abort transmission command),
                                                     the CAN controller requests the respective interrupt 0
                                                     disabled                                                                  */
      __IOM uint32_t warning_irq_en : 1;        /*!< [2..2] Error Warning Interrupt Enable 1 enabled; if the error
                                                     or bus status change (see status register), the CAN controller
                                                     requests the respective interrupt 0 disabled                              */
      __IOM uint32_t overrun_irq_en : 1;        /*!< [3..3] Data Overrun Interrupt Enable 1 enabled; if the data
                                                     overrun status bit is set (see status register; Table 14),
                                                     the CAN controller requests the respective interrupt 0
                                                     disabled                                                                  */
      __IOM uint32_t reserved0  : 1;            /*!< [4..4] reserved                                                           */
      __IOM uint32_t err_passive_irq_en : 1;    /*!< [5..5] Error Passive Interrupt Enable 1 enabled; if the error
                                                     status of the CAN controller changes from error active
                                                     to error passive or vice versa, the respective interrupt
                                                     is requested 0 disabled                                                   */
      __IOM uint32_t arb_lost_irq_en : 1;       /*!< [6..6] Arbitration Lost Interrupt Enable 1 enabled; if the CAN
                                                     controller has lost arbitration, the respective interrupt
                                                     is requested 0 disabled                                                   */
      __IOM uint32_t bus_error_irq_en : 1;      /*!< [7..7] Bus Error Interrupt Enable 1 enabled; if an bus error
                                                     has been detected, the CAN controller requests the respective
                                                     interrupt 0 disabled                                                      */
      __IOM uint32_t reserved1  : 24;           /*!< [31..8] reserved                                                          */
    } canctrl_irq_en_b;
  } ;
  __IOM uint32_t  canctrl_not_extended_acceptance_mask0;/*!< (@ 0x00000014) CAN not extended acceptance mask register          */
  
  union {
    __IOM uint32_t canctrl_bus_timing0;         /*!< (@ 0x00000018) CAN bus timing register 0, only writable in reset
                                                                    mode in not extended mode: acceptance_mask_0               */
    
    struct {
      __IOM uint32_t prescaler  : 9;            /*!< [8..0] Baud Rate Prescaler The period of the CAN system clock
                                                     tscl is programmable and determines the individual bit
                                                     timing. The CAN system clock is calculated using the following
                                                     equation: tscl = tCLK * prescaler with tCLK = 10 ns                       */
      __IOM uint32_t sync_jump_width : 2;       /*!< [10..9] Synchronization Jump Width To compensate for phase shifts
                                                     between clock oscillators of different bus controllers,
                                                     any bus controller must re-synchronize on any relevant
                                                     signal edge of the current transmission. The synchronization
                                                     jump width defines the maximum number of clock cycles a
                                                     bit period may be shortened or lengthened by one re-synchronization:
                                                     tSJW = tscl * (sync_jump_width + 1)                                       */
    } canctrl_bus_timing0_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_bus_timing1;         /*!< (@ 0x0000001C) CAN bus timing register 1, only writable in reset
                                                                    mode                                                       */
    
    struct {
      __IOM uint32_t tseg1      : 6;            /*!< [5..0] Time Segment 1 (TSEG1) TSEG1 determine the number of
                                                     clock cycles per bit period and the location of the sample
                                                     point, where: tSYNCSEG = 1 * tscl tTSEG1 = tscl * (tseg1
                                                     + 1)                                                                      */
      __IOM uint32_t reserved0  : 1;            /*!< [6..6] reserved                                                           */
      __IOM uint32_t oversampling : 1;          /*!< [7..7] Sampling 1 triple; the bus is sampled three times; recommended
                                                     for low/medium speed buses (class A and B) where filtering
                                                     spikes on the bus line is beneficial 0 single; the bus
                                                     is sampled once; recommended for high speed buses (SAE
                                                     class C)                                                                  */
      __IOM uint32_t tseg2      : 5;            /*!< [12..8] Time Segment 2 (TSEG2) TSEG2 determine the number of
                                                     clock cycles per bit period and the location of the sample
                                                     point, where: tTSEG2 = tscl * (tseg2 + 1)                                 */
      __IOM uint32_t reserved1  : 19;           /*!< [31..13] reserved                                                         */
    } canctrl_bus_timing1_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  __IOM uint32_t  canctrl_not_extended_data0;   /*!< (@ 0x00000028) CAN not extended data register                             */
  
  union {
    __IM  uint32_t canctrl_arb_lost_capture;    /*!< (@ 0x0000002C) CAN arbitration lost capture register This register
                                                                    contains information about the bit position
                                                                    of losing arbitration. reading the register
                                                                    will clear all bits in not extended mode:
                                                                    data1                                                      */
    
    struct {
      __IM  uint32_t position   : 5;            /*!< [4..0] Positon where arbitration was lost { | Decimal value
                                                     Position 00 arbitration lost in bit 1 of identifier 01
                                                     arbitration lost in bit 2 of identifier 02 arbitration
                                                     lost in bit 3 of identifier 03 arbitration lost in bit
                                                     4 of identifier 04 arbitration lost in bit 5 of identifier
                                                     05 arbitration lost in bit 6 of identifier 06 arbitration
                                                     lost in bit 7 of identifier 07 arbitration lost in bit
                                                     8 of identifier 08 arbitration lo                                         */
    } canctrl_arb_lost_capture_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_err_code_capture;    /*!< (@ 0x00000030) CAN error code capture register This register
                                                                    contains information about the type and
                                                                    location of errors on the bus. reading the
                                                                    register will clear all bits in not extended
                                                                    mode: data2                                                */
    
    struct {
      __IM  uint32_t segment    : 5;            /*!< [4..0] Frame segment where error was detected { | Binary value
                                                     Segment 00011 start of frame 00010 ID.28 to ID.21 00110
                                                     ID.20 to ID.18 00100 bit SRTR 00101 bit IDE 00111 ID.17
                                                     to ID.13 01111 ID.12 to ID.5 01110 ID.4 to ID.0 01100 bit
                                                     RTR 01101 reser ved bit 1 01001 reser ved bit 0 01011 data
                                                     length code 01010 data field 01000 CRC sequence 11000                     */
      __IM  uint32_t direction  : 1;            /*!< [5..5] Direction 1 RX; error occurred during reception 0 TX;
                                                     error occurred during transmission                                        */
      __IM  uint32_t err_code   : 2;            /*!< [7..6] Error code { | Binary value Code 00 bit error 01 form
                                                     error 10 stuff error 11 other type of error }                             */
    } canctrl_err_code_capture_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_err_warning_limit;   /*!< (@ 0x00000034) CAN error warning limit register, only writable
                                                                    in reset mode in not extended mode: data3                  */
    
    struct {
      __IOM uint32_t limit      : 8;            /*!< [7..0] error warning limit                                                */
    } canctrl_err_warning_limit_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_rx_error_cnt;        /*!< (@ 0x00000038) CAN RX error counter register, only writable
                                                                    in reset mode The RX error counter register
                                                                    reflects the current value of the receive
                                                                    error counter. If a bus-off event occurs,
                                                                    the RX error counter is initialized to logic
                                                                    0. The time bus-off is valid, writing to
                                                                    this register has no effect. Note, that
                                                                    a CPU-forced content change of the RX error
                                                                    counter is only possible, if the reset mode
                                                                    was entered previously. An error status
                                                                    change (see status register), an error warning
                                                                    or an error passive in                                     */
    
    struct {
      __IOM uint32_t rx_err     : 8;            /*!< [7..0] rx error counter                                                   */
    } canctrl_rx_error_cnt_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_tx_error_cnt;        /*!< (@ 0x0000003C) CAN TX error counter register, only writable
                                                                    in reset mode The TX error counter register
                                                                    reflects the current value of the transmit
                                                                    error counter. If a bus-off event occurs,
                                                                    the TX error counter is initialized to 127
                                                                    to count the minimum protocol-defined time
                                                                    (128 occurrences of the bus-free signal).
                                                                    Reading the TX error counter during this
                                                                    time gives information about the status
                                                                    of the bus-off recovery. If bus-off is active,
                                                                    a write access to TXERR in the range from
                                                                    0 to 254 clears the bus-                                   */
    
    struct {
      __IOM uint32_t tx_err     : 8;            /*!< [7..0] tx error counter                                                   */
    } canctrl_tx_error_cnt_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data0;               /*!< (@ 0x00000040) CAN data register 0 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 0 Operating
                                                                    mode: R: Standard frame: Read RX frame information
                                                                    Extended frame: Read RX frame information
                                                                    W: Standard frame: Write TX frame information
                                                                    Extended frame: Write TX frame information
                                                                    } in not extended mode: data6                              */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data0_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data1;               /*!< (@ 0x00000044) CAN data register 1 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 1 Operating
                                                                    mode: R: Standard frame: Read RX identifier
                                                                    1 Extended frame: Read RX identifier 1 W:
                                                                    Standard frame: Write TX identifier 1 Extended
                                                                    frame: Write TX identifier 1 } in not extended
                                                                    mode: data7                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data1_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data2;               /*!< (@ 0x00000048) CAN data register 2 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 2 Operating
                                                                    mode: R: Standard frame: Read RX identifier
                                                                    2 Extended frame: Read RX identifier 2 W:
                                                                    Standard frame: Write TX identifier 2 Extended
                                                                    frame: Write TX identifier 2 } in not extended
                                                                    mode: data8                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data2_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data3;               /*!< (@ 0x0000004C) CAN data register 3 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance code 3 Operating
                                                                    mode: R: Standard frame: Read RX data 1
                                                                    Extended frame: Read RX identifier 3 W:
                                                                    Standard frame: Write TX data 1 Extended
                                                                    frame: Write TX identifier 3 } in not extended
                                                                    mode: data9                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance code)             */
    } canctrl_data3_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data4;               /*!< (@ 0x00000050) CAN data register 4 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 0 Operating
                                                                    mode: R: Standard frame: Read RX data 2
                                                                    Extended frame: Read RX identifier 4 W:
                                                                    Standard frame: Write TX data 2 Extended
                                                                    frame: Write TX identifier 4 }                             */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data4_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data5;               /*!< (@ 0x00000054) CAN data register 5 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 1 Operating
                                                                    mode: R: Standard frame: Read RX data 3
                                                                    Extended frame: Read RX data 1 W: Standard
                                                                    frame: Write TX data 3 Extended frame: Write
                                                                    TX data 1 }                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data5_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data6;               /*!< (@ 0x00000058) CAN data register 6 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 2 Operating
                                                                    mode: R: Standard frame: Read RX data 4
                                                                    Extended frame: Read RX data 2 W: Standard
                                                                    frame: Write TX data 4 Extended frame: Write
                                                                    TX data 2 }                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data6_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data7;               /*!< (@ 0x0000005C) CAN data register 7 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    Read or write acceptance mask 3 Operating
                                                                    mode: R: Standard frame: Read RX data 5
                                                                    Extended frame: Read RX data 3 W: Standard
                                                                    frame: Write TX data 5 Extended frame: Write
                                                                    TX data 3 }                                                */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data, tx data or acceptance mask)             */
    } canctrl_data7_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data8;               /*!< (@ 0x00000060) CAN data register 8 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    Read RX data 6 Extended frame: Read RX data
                                                                    4 W: Standard frame: Write TX data 6 Extended
                                                                    frame: Write TX data 4 }                                   */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data8_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data9;               /*!< (@ 0x00000064) CAN data register 9 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    Read RX data 7 Extended frame: Read RX data
                                                                    5 W: Standard frame: Write TX data 7 Extended
                                                                    frame: Write TX data 5 }                                   */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data9_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data10;              /*!< (@ 0x00000068) CAN data register 10 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    Read RX data 8 Extended frame: Read RX data
                                                                    6 W: Standard frame: Write TX data 8 Extended
                                                                    frame: Write TX data 6 }                                   */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data10_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data11;              /*!< (@ 0x0000006C) CAN data register 11 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    reserved Extended frame: Read RX data 7
                                                                    W: Standard frame: reserved Extended frame:
                                                                    Write TX data 7 }                                          */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data11_b;
  } ;
  
  union {
    __IOM uint32_t canctrl_data12;              /*!< (@ 0x00000070) CAN data register 12 This register has multiple
                                                                    functions depending on reset mode and read
                                                                    or write access. { | | Reset mode: R/W:
                                                                    reserved Operating mode: R: Standard frame:
                                                                    reserved Extended frame: Read RX data 8
                                                                    W: Standard frame: reserved Extended frame:
                                                                    Write TX data 8 }                                          */
    
    struct {
      __IOM uint32_t data       : 8;            /*!< [7..0] register content (rx data or tx data)                              */
    } canctrl_data12_b;
  } ;
  
  union {
    __IM  uint32_t canctrl_rx_message_cnt;      /*!< (@ 0x00000074) CAN RX message counter register Reflects the
                                                                    number of messages available within the
                                                                    RXFIFO. The value is incremented with each
                                                                    receive event and decremented by the release
                                                                    receive buffer command. After any reset
                                                                    event, this register is cleared.                           */
    
    struct {
      __IM  uint32_t rx_msg_cnt : 7;            /*!< [6..0] rx message counter                                                 */
    } canctrl_rx_message_cnt_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t canctrl_mode_control;        /*!< (@ 0x0000007C) CAN mode control register, only writable in reset
                                                                    mode                                                       */
    
    struct {
      __IM  uint32_t reserved0  : 7;            /*!< [6..0] reserved                                                           */
      __IM  uint32_t mode       : 1;            /*!< [7..7] 0: BasicCAN mode, 1: PeliCAN mode recommended value is
                                                     1 (PeliCAN mode), The here given register map of all registers
                                                     of the CAN controller is valid for PeliCAN only.                          */
      __IM  uint32_t reserved1  : 24;           /*!< [31..8] reserved                                                          */
    } canctrl_mode_control_b;
  } ;
} can_ctrl1_app_Type;                           /*!< Size = 128 (0x80)                                                         */



/* =========================================================================================================================== */
/* ================                                         spi0_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief spi0_app (spi0_app)
  */

typedef struct {                                /*!< (@ 0xFF801A00) spi0_app Structure                                         */
  
  union {
    __IOM uint32_t spi_cr0;                     /*!< (@ 0x00000000) SPI control register 0 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t datasize   : 4;            /*!< [3..0] DSS: data size select (transfer size = datasize + 1 bits):
                                                     { | 0000...0010: reserved 0011: 4 bit 0100: 5 bit ... 0111:
                                                     8 bit ... 1111: 16 bit } Note: 16 bit TX-data-loss bug
                                                     of netX50/netX5 is fixed since netX10.                                    */
      __IOM uint32_t reserved0  : 2;            /*!< [5..4] reserved                                                           */
      __IOM uint32_t SPO        : 1;            /*!< [6..6] Serial clock polarity (netx500: CR_cpol): 0: idle: clock
                                                     is low, first edge is rising 1: idle: clock is high, first
                                                     edge is falling                                                           */
      __IOM uint32_t SPH        : 1;            /*!< [7..7] Serial clock phase (netx500: CR_ncpha): 1: sample data
                                                     at second clock edge, data is generated half a clock phase
                                                     before sampling 0: sample data at first clock edge, data
                                                     is generated half a clock phase before sampling                           */
      __IOM uint32_t sck_muladd : 12;           /*!< [19..8] Serial clock rate multiply add value for master SCK
                                                     generation. The SPI clock frequency is: f_spi_sck = (sck_muladd
                                                     * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI
                                                     clock rate. All serial clock rates are derived from 100MHz
                                                     netX system clock. Hence, all serial clock phases are multiples
                                                     of 10ns. This leads to non-constant serial clock phases
                                                     when a clock rate is programmed which cannot be generated
                                                     by 100MHz/(2*n) without remainder. E.g. programming 0x4CC
                                                     here will lead to a mean clock-rate of 30MHz                              */
      __IOM uint32_t reserved1  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t format     : 2;            /*!< [25..24] Frame format: 00: Motorola SPI frame format 01..11:
                                                     reserved                                                                  */
      __IOM uint32_t reserved2  : 1;            /*!< [26..26] reserved                                                         */
      __IOM uint32_t filter_in  : 1;            /*!< [27..27] Receive data is sampled every 10ns (100MHz system clock).
                                                     If this bit is set, the stored receive value will be the
                                                     result of a majority decision of the three sampling points
                                                     around a SPI-clock edge (if two or more '1s! were sampled
                                                     a '1' will be stored, else a '0' will be stored. In slave
                                                     mode chip-select and SCK edges will also be detected by
                                                     oversampling if this bit is set: An edge will be detected
                                                     if the majority-result of 3 subsequent sampled values toggles.
                                                     Input filtering should be used for sck_mulad                              */
      __IOM uint32_t slave_sig_early : 1;       /*!< [28..28] Generate MISO in slave mode 1 SCK clock edge earlier
                                                     than defined in the SPI specification. This is to compensate
                                                     pad or sampling delays on fast data rates. However, hold
                                                     timing problems could come up as MISO is generated very
                                                     fast after the sampling SPI clock edge. If filter_in is
                                                     enabled, it takes at least 3 system clocks to generate
                                                     MISO after SCK. If filter_in is disabled, it takes at least
                                                     2 system clocks to generate MISO after SCK.                               */
      __IOM uint32_t reserved3  : 2;            /*!< [30..29] reserved                                                         */
      __IOM uint32_t netx100_comp : 1;          /*!< [31..31] Use netx100/500-compatible SPI mode: 0: start transfer
                                                     after writing data 1: start transfer after setting CR_write
                                                     or CR_read                                                                */
    } spi_cr0_b;
  } ;
  
  union {
    __IOM uint32_t spi_cr1;                     /*!< (@ 0x00000004) SPI control register 1 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t LBM        : 1;            /*!< [0..0] Loop back mode: 0: Internal loop back disabled 1: Internal
                                                     loop back enabled, spi_cr0.filter_in must be set for loopback
                                                     function                                                                  */
      __IOM uint32_t SSE        : 1;            /*!< [1..1] SPI enable: 0: Module disabled 1: Module enabled                   */
      __IOM uint32_t MS         : 1;            /*!< [2..2] Mode select: 0: Module is configured as master 1: Module
                                                     is configured as slave                                                    */
      __IOM uint32_t SOD        : 1;            /*!< [3..3] Slave mode output disable (to connect multiple slaves
                                                     to one master): 0: MISO can be driven in slave mode 1:
                                                     MISO is not driven in slave mode                                          */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t fss        : 3;            /*!< [10..8] Frame or slave select. There are up to 3 external SPI
                                                     chip-select signals. In master mode, the fss bits define
                                                     the states of the chip-select signals. The inversion for
                                                     low-active chip-selects (e.g. for Motorola SPI frame format)
                                                     is done automatically depending on the value programmed
                                                     to the 'format' bits. Example: To use the netX IO CS1 as
                                                     chip-select, program '010' here, regardless whether the
                                                     external chip-select is low or high active. In slave mode,
                                                     the fss bits are a mask to select which netX input sho                    */
      __IOM uint32_t fss_static : 1;            /*!< [11..11] SPI static chip-select: { | 0: SPI chip-select will
                                                     be toggled automatically before and after each transferred
                                                     word according to fss and datasize. 1: SPI chip-select
                                                     will be set statically according to the fss bits. }                       */
      __IOM uint32_t reserved1  : 4;            /*!< [15..12] reserved                                                         */
      __IOM uint32_t tx_fifo_wm : 4;            /*!< [19..16] Transmit FIFO watermark for IRQ generation                       */
      __IOM uint32_t tx_fifo_clr : 1;           /*!< [20..20] Writing '1' to this bit will clear the transmit FIFOs.
                                                     Note: There must be at least 1 system clock idle after
                                                     clear before writing new data to the FIFO. This is guaranteed
                                                     by the netX internal bus structure and needs not being
                                                     considered by software.                                                   */
      __IOM uint32_t reserved2  : 3;            /*!< [23..21] reserved                                                         */
      __IOM uint32_t rx_fifo_wm : 4;            /*!< [27..24] Receive FIFO watermark for IRQ generation                        */
      __IOM uint32_t rx_fifo_clr : 1;           /*!< [28..28] Writing '1' to this bit will clear the receive FIFOs.            */
      __IOM uint32_t reserved3  : 3;            /*!< [31..29] reserved                                                         */
    } spi_cr1_b;
  } ;
  
  union {
    __IOM uint32_t spi_dr;                      /*!< (@ 0x00000008) SPI data register Registers 0x30..0x3C can be
                                                                    used instead of registers 0x00...0x24 to
                                                                    keep netx50 software compliant to netx100/500.
                                                                    The SPI module has 2 FIFOs: One for transmit
                                                                    data and one for receive data. Read access:
                                                                    Received data byte is delivered from receive
                                                                    FIFO. Write access: Transmit data byte is
                                                                    written to send FIFO. Both FIFOs (receive
                                                                    and transmit) have a depth of 16. SPI master
                                                                    mode: MISO input data will be stored in
                                                                    the receive FIFO; transmit FIFO generates
                                                                    MOSI output data.                                          */
    
    struct {
      __IOM uint32_t data       : 17;           /*!< [16..0] Transmit data: Only lowest bits according to spi_cr0.datasize
                                                     will be sent. Receive data will be delivered on the lowest
                                                     bits, unused bits (above spi_cr0.datasize) will be '0'.
                                                     In slave mode transmit data is requested from the FIFO
                                                     when the last bit of the currently transferred word is
                                                     set to the MISO signal. If no next transmit data can be
                                                     read from the FIFO until the current word's last bit was
                                                     transferred, a FIFO underrun will occur in case chip-select
                                                     does not go inactive at the next detected SCK edge.                       */
    } spi_dr_b;
  } ;
  
  union {
    __IM  uint32_t spi_sr;                      /*!< (@ 0x0000000C) SPI status register Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t TFE        : 1;            /*!< [0..0] Transmit FIFO is empty (1 if empty)                                */
      __IM  uint32_t TNF        : 1;            /*!< [1..1] Transmit FIFO is not full (0 if full)                              */
      __IM  uint32_t RNE        : 1;            /*!< [2..2] Receive FIFO is not empty (0 if empty)                             */
      __IM  uint32_t RFF        : 1;            /*!< [3..3] Receive FIFO is full (1 if full)                                   */
      __IM  uint32_t BSY        : 1;            /*!< [4..4] Device busy (1 if data is currently transmitted/received
                                                     or the transmit FIFO is not empty)                                        */
      __IM  uint32_t reserved0  : 11;           /*!< [15..5] reserved                                                          */
      __IM  uint32_t tx_fifo_level : 5;         /*!< [20..16] Transmit FIFO level (number of words to transmit are
                                                     left in FIFO)                                                             */
      __IM  uint32_t reserved1  : 1;            /*!< [21..21] reserved                                                         */
      __IM  uint32_t tx_fifo_err_ovfl : 1;      /*!< [22..22] Transmit FIFO overflow error occurred, data is lost              */
      __IM  uint32_t tx_fifo_err_undr : 1;      /*!< [23..23] Transmit FIFO underrun error occurred, data is lost              */
      __IM  uint32_t rx_fifo_level : 5;         /*!< [28..24] Receive FIFO level (number of received words to read
                                                     out are left in FIFO)                                                     */
      __IM  uint32_t reserved2  : 1;            /*!< [29..29] reserved                                                         */
      __IM  uint32_t rx_fifo_err_ovfl : 1;      /*!< [30..30] Receive FIFO overflow error occurred, data is lost               */
      __IM  uint32_t rx_fifo_err_undr : 1;      /*!< [31..31] Receive FIFO underrun error occurred, data is lost               */
    } spi_sr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t spi_imsc;                    /*!< (@ 0x00000014) SPI Interrupt Mask Set and Clear register: Registers
                                                                    0x30..0x3C can be used instead of registers
                                                                    0x00...0x24 to keep netx50 software compliant
                                                                    to netx100/500. IRQ mask is an AND-mask:
                                                                    only raw interrupts with mask bit set can
                                                                    generate a module IRQ. When writing this
                                                                    register, the corresponding interrupt is
                                                                    cleared similar to writing the register
                                                                    spi_icr. Note: The functionality of this
                                                                    register is similar to the corresponding
                                                                    SQI register sqi_irq_mask. However, in contrast
                                                                    to this register,                                          */
    
    struct {
      __IOM uint32_t RORIM      : 1;            /*!< [0..0] Receive FIFO overrun interrupt mask                                */
      __IOM uint32_t RTIM       : 1;            /*!< [1..1] Receive timeout interrupt mask                                     */
      __IOM uint32_t RXIM       : 1;            /*!< [2..2] Receive FIFO interrupt mask                                        */
      __IOM uint32_t TXIM       : 1;            /*!< [3..3] Transmit FIFO interrupt mask                                       */
      __IOM uint32_t rxneim     : 1;            /*!< [4..4] Receive FIFO not empty interrupt mask (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfim      : 1;            /*!< [5..5] Receive FIFO full interrupt mask (for netx100/500 compliance)      */
      __IOM uint32_t txeim      : 1;            /*!< [6..6] Transmit FIFO empty interrupt mask (for netx100/500 compliance)    */
    } spi_imsc_b;
  } ;
  
  union {
    __IM  uint32_t spi_ris;                     /*!< (@ 0x00000018) SPI interrupt state before masking register (raw
                                                                    interrupt) Registers 0x30..0x3C can be used
                                                                    instead of registers 0x00...0x24 to keep
                                                                    netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORRIS     : 1;            /*!< [0..0] Unmasked receive FIFO overrun interrupt state 1: receive
                                                     FIFO overrun error occurred 0: no receive FIFO overrun
                                                     error occurred                                                            */
      __IM  uint32_t RTRIS      : 1;            /*!< [1..1] Unmasked receive timeout interrupt state Timeout period
                                                     are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd
                                                     1: receive FIFO is not empty and not read out in the passed
                                                     timeout period 0: receive FIFO is empty or read during
                                                     the last timeout period                                                   */
      __IM  uint32_t RXRIS      : 1;            /*!< [2..2] Unmasked receive FIFO interrupt state 1: receive FIFO
                                                     is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals
                                                     or is below spi_cr1.rx_fifo_wm                                            */
      __IM  uint32_t TXRIS      : 1;            /*!< [3..3] Unmasked transmit FIFO interrupt state 1: transmit FIFO
                                                     level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals
                                                     or is higher than spi_cr1.tx_fifo_wm                                      */
      __IM  uint32_t rxneris    : 1;            /*!< [4..4] Unmasked receive FIFO not empty interrupt state (for
                                                     netx100/500 compliance) 1: receive FIFO is not empty 0:
                                                     receive FIFO is empty                                                     */
      __IM  uint32_t rxfris     : 1;            /*!< [5..5] Unmasked receive FIFO full interrupt state (for netx100/500
                                                     compliance) 1: receive FIFO is full 0: receive FIFO is
                                                     not full                                                                  */
      __IM  uint32_t txeris     : 1;            /*!< [6..6] Unmasked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance) 1: transmit FIFO is empty 0: transmit FIFO
                                                     is not empty                                                              */
    } spi_ris_b;
  } ;
  
  union {
    __IM  uint32_t spi_mis;                     /*!< (@ 0x0000001C) SPI interrupt status register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< [0..0] Masked receive FIFO overrun interrupt state                        */
      __IM  uint32_t RTMIS      : 1;            /*!< [1..1] Masked receive timeout interrupt state                             */
      __IM  uint32_t RXMIS      : 1;            /*!< [2..2] Masked receive FIFO interrupt state                                */
      __IM  uint32_t TXMIS      : 1;            /*!< [3..3] Masked transmit FIFO interrupt state                               */
      __IM  uint32_t rxnemis    : 1;            /*!< [4..4] Masked receive FIFO not empty interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t rxfmis     : 1;            /*!< [5..5] Masked receive FIFO full interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t txemis     : 1;            /*!< [6..6] Masked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance)                                                               */
    } spi_mis_b;
  } ;
  
  union {
    __IOM uint32_t spi_icr;                     /*!< (@ 0x00000020) SPI interrupt clear register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    An interrupt is cleared by writing '1' to
                                                                    the according bit. Note: Both FIFOs (receive
                                                                    and transmit) have a depth of 16.                          */
    
    struct {
      __IOM uint32_t RORIC      : 1;            /*!< [0..0] Clear receive FIFO overrun interrupt Writing '1' here
                                                     will clear the receive FIFO                                               */
      __IOM uint32_t RTIC       : 1;            /*!< [1..1] Clear receive FIFO overrun interrupt                               */
      __IOM uint32_t RXIC       : 1;            /*!< [2..2] PL022 extension: clear receive FIFO interrupt                      */
      __IOM uint32_t TXIC       : 1;            /*!< [3..3] PL022 extension: clear transmit FIFO interrupt                     */
      __IOM uint32_t rxneic     : 1;            /*!< [4..4] Clear receive FIFO not empty interrupt (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfic      : 1;            /*!< [5..5] Clear receive FIFO full interrupt (for netx100/500 compliance)     */
      __IOM uint32_t txeic      : 1;            /*!< [6..6] Clear transmit FIFO empty interrupt (for netx100/500
                                                     compliance)                                                               */
    } spi_icr_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t spi_dmacr;                   /*!< (@ 0x00000028) SPI DMA control register                                   */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Enable DMA for SPI receive data. A single request will
                                                     be generated if the receive FIFO is not empty and spi_cr1.SSE
                                                     (module enable) is set. Burst request to the DMA controller
                                                     will be generated if the receive FIFO contains at least
                                                     4 words (set DMA burst size to 4). If this bit is reset
                                                     or the module is disabled, the DMA request signals will
                                                     also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst
                                                     size: 4) in the DMA controller.                                           */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Enable DMA for SPI transmit data. A single request will
                                                     be generated if the transmit FIFO is not full and spi_cr1.SSE
                                                     (module enable) is set. Burst requests to the DMA controller
                                                     will be generated if at least 4 words are writable to the
                                                     transmit FIFO (set DMA burst size to 4). If this bit is
                                                     reset or the module is disabled, the DMA request signals
                                                     will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e.
                                                     burst size: 4) in the DMA controller.                                     */
    } spi_dmacr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t spi_data_register;           /*!< (@ 0x00000030) netx100/500 compliant SPI data register (DR)
                                                                    Registers 0x30..0x3C can be used instead
                                                                    of registers 0x00...0x24 to keep netx50
                                                                    software compliant to netx100/500. 2 data
                                                                    bytes with valid bits. During a write access
                                                                    data_byte_1 and dr_valid1 must not be used.
                                                                    dr_valid0 must be set. In netx50 and later
                                                                    versions both FIFOs (receive and transmit)
                                                                    have a depth of 16, fill values are fixed
                                                                    to 4. To keep software compatible, not more
                                                                    than 8 bytes should be in netx100/500 FIFOs.               */
    
    struct {
      __IOM uint32_t data_byte_0 : 8;           /*!< [7..0] Data byte 0                                                        */
      __IOM uint32_t data_byte_1 : 8;           /*!< [15..8] Obsolete, don't use                                               */
      __IOM uint32_t dr_valid0  : 1;            /*!< [16..16] Valid bit for data_byte_0 This bit shows if data_byte_0
                                                     is valid and must be set during a FIFO write access.                      */
      __IOM uint32_t dr_valid1  : 1;            /*!< [17..17] Obsolete, always 0                                               */
    } spi_data_register_b;
  } ;
  
  union {
    __IM  uint32_t spi_status_register;         /*!< (@ 0x00000034) netx100/500 compliant SPI status register (SR):
                                                                    Shows the actual status of the SPI interface.
                                                                    Bits 24..18 show occurred interrupts; writing
                                                                    ones into these bits clears the interrupts.
                                                                    Writing into other bits has no effect. In
                                                                    netx50 and later versions both FIFOs (receive
                                                                    and transmit) have a depth of 16, fill values
                                                                    are fixed to 4. To keep software compatible,
                                                                    not more than 8 bytes should be in netx100/500
                                                                    FIFOs.                                                     */
    
    struct {
      __IM  uint32_t SR_in_fuel_val : 9;        /*!< [8..0] Input FIFO fill value (number of bytes)                            */
      __IM  uint32_t SR_out_fuel_val : 9;       /*!< [17..9] Output FIFO fill value (number of bytes)                          */
      __IM  uint32_t SR_in_fuel : 1;            /*!< [18..18] Adjustable fill value of input FIFO reached (equals
                                                     spi_ris.RXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_in_recdata : 1;         /*!< [19..19] Valid data bytes in input FIFO (equals spi_ris.rxneris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_in_full : 1;            /*!< [20..20] Input FIFO is full (equals spi_ris.rxfris in netx50
                                                     and later versions)                                                       */
      __IM  uint32_t SR_out_fuel : 1;           /*!< [21..21] Adjustable fill value of output FIFO reached (equals
                                                     spi_ris.TXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_out_fw  : 1;            /*!< [22..22] netX is writing data too fast into output FIFO. Available
                                                     as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl
                                                     in netx50 and later versions).                                            */
      __IM  uint32_t SR_out_empty : 1;          /*!< [23..23] Output FIFO is empty in slave mode (equals spi_ris.txeris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_out_full : 1;           /*!< [24..24] Output FIFO is full. This is only with netx100/500
                                                     an IRQ.                                                                   */
      __IM  uint32_t SR_selected : 1;           /*!< [25..25] External master has access to SPI interface                      */
    } spi_status_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_control_register;        /*!< (@ 0x00000038) netx100/500 compliant SPI control register (CR)            */
    
    struct {
      __IOM uint32_t CR_softreset : 1;          /*!< [0..0] write only: no function in netx100/netx500; later versions:
                                                     clears IRQs and FIFOs                                                     */
      __IOM uint32_t CR_speed   : 4;            /*!< [4..1] Clock divider for SPI clock (2 - 2^16) If SPI clock rate
                                                     is changed using spi_cr0.sck_muladd, this value will not
                                                     be updated and may be incorrect There are 16 different
                                                     SPI clocks frequencies to choose: 0000: 0.025 MHz (Note:
                                                     Not compatible to netx100/500. '0000' freezes SCK in netx100/500.)
                                                     0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz
                                                     0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001:
                                                     3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101:
                                                     16.6666 MHz 1110: 25 MHz 1111: 50 MHz                                     */
      __IOM uint32_t reserved0  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t CR_read    : 1;            /*!< [6..6] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface read data                                            */
      __IOM uint32_t CR_write   : 1;            /*!< [7..7] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface write data                                           */
      __IOM uint32_t CR_ss      : 3;            /*!< [10..8] External slave select                                             */
      __IOM uint32_t CS_mode    : 1;            /*!< [11..11] 1: chip select is generated automatically by the internal
                                                     state machine 0: chip select is directly controlled by
                                                     software (see bits CR_ss).                                                */
      __IOM uint32_t reserved1  : 8;            /*!< [19..12] reserved                                                         */
      __IOM uint32_t CR_clr_infifo : 1;         /*!< [20..20] Clear input FIFO                                                 */
      __IOM uint32_t CR_clr_outfifo : 1;        /*!< [21..21] Clear output FIFO                                                */
      __IOM uint32_t CR_burstdelay : 3;         /*!< [24..22] netx100/netx500 only, obsolete in later versions: delay
                                                     between transmission of 2 data bytes (0 to 7 SCK cycles)                  */
      __IOM uint32_t CR_burst   : 3;            /*!< [27..25] netx100/netx500 only, obsolete in later versions: burst
                                                     length = 2^CR_burst                                                       */
      __IOM uint32_t CR_ncpha   : 1;            /*!< [28..28] SPI clock phase mode (Note: meaning of this bit is
                                                     inverted to functionality of bit spi_cr0.SPH): { | 0: change
                                                     data on secondary SCK edge data is active on primary SCK
                                                     edge 1: change data on primary SCK edge data is active
                                                     on secondary SCK edge }                                                   */
      __IOM uint32_t CR_cpol    : 1;            /*!< [29..29] 1: falling edge of SCK is primary 0: rising edge of
                                                     SCK is primary                                                            */
      __IOM uint32_t CR_ms      : 1;            /*!< [30..30] 1: master mode 0:slave mode                                      */
      __IOM uint32_t CR_en      : 1;            /*!< [31..31] 1: enable 0: disable SPI interface                               */
    } spi_control_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_interrupt_control_register;/*!< (@ 0x0000003C) netx100/500 compliant SPI interrupt control register
                                                                    (IR) In netx50 and later versions both FIFOs
                                                                    (receive and transmit) have a depth of 16,
                                                                    fill values are fixed to 4. To keep software
                                                                    compatible, not more than 8 bytes should
                                                                    be in netx100/500 FIFOs.                                   */
    
    struct {
      __IOM uint32_t IR_in_fuel : 9;            /*!< [8..0] Adjustable watermark level of input FIFO                           */
      __IOM uint32_t IR_out_fuel : 9;           /*!< [17..9] Adjustable watermark level of output FIFO                         */
      __IOM uint32_t IR_in_fuel_en : 1;         /*!< [18..18] IRQ enable for irq_spi(0) (equals spi_imsc.RXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_recdata_en : 1;      /*!< [19..19] IRQ enable for irq_spi(1) (equals spi_imsc.txneim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_full_en : 1;         /*!< [20..20] IRQ enable for irq_spi(2) (equals spi_imsc.txfim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fuel_en : 1;        /*!< [21..21] IRQ enable for irq_spi(3) (equals spi_imsc.TXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fw_en : 1;          /*!< [22..22] IRQ enable for irq_spi(4), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
      __IOM uint32_t IR_out_empty_en : 1;       /*!< [23..23] IRQ enable for irq_spi(5) (equals spi_imsc.rxeim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_full_en : 1;        /*!< [24..24] IRQ enable for irq_spi(6), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
    } spi_interrupt_control_register_b;
  } ;
} spi0_app_Type;                                /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                         spi1_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief spi1_app (spi1_app)
  */

typedef struct {                                /*!< (@ 0xFF801A40) spi1_app Structure                                         */
  
  union {
    __IOM uint32_t spi_cr0;                     /*!< (@ 0x00000000) SPI control register 0 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t datasize   : 4;            /*!< [3..0] DSS: data size select (transfer size = datasize + 1 bits):
                                                     { | 0000...0010: reserved 0011: 4 bit 0100: 5 bit ... 0111:
                                                     8 bit ... 1111: 16 bit } Note: 16 bit TX-data-loss bug
                                                     of netX50/netX5 is fixed since netX10.                                    */
      __IOM uint32_t reserved0  : 2;            /*!< [5..4] reserved                                                           */
      __IOM uint32_t SPO        : 1;            /*!< [6..6] Serial clock polarity (netx500: CR_cpol): 0: idle: clock
                                                     is low, first edge is rising 1: idle: clock is high, first
                                                     edge is falling                                                           */
      __IOM uint32_t SPH        : 1;            /*!< [7..7] Serial clock phase (netx500: CR_ncpha): 1: sample data
                                                     at second clock edge, data is generated half a clock phase
                                                     before sampling 0: sample data at first clock edge, data
                                                     is generated half a clock phase before sampling                           */
      __IOM uint32_t sck_muladd : 12;           /*!< [19..8] Serial clock rate multiply add value for master SCK
                                                     generation. The SPI clock frequency is: f_spi_sck = (sck_muladd
                                                     * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI
                                                     clock rate. All serial clock rates are derived from 100MHz
                                                     netX system clock. Hence, all serial clock phases are multiples
                                                     of 10ns. This leads to non-constant serial clock phases
                                                     when a clock rate is programmed which cannot be generated
                                                     by 100MHz/(2*n) without remainder. E.g. programming 0x4CC
                                                     here will lead to a mean clock-rate of 30MHz                              */
      __IOM uint32_t reserved1  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t format     : 2;            /*!< [25..24] Frame format: 00: Motorola SPI frame format 01..11:
                                                     reserved                                                                  */
      __IOM uint32_t reserved2  : 1;            /*!< [26..26] reserved                                                         */
      __IOM uint32_t filter_in  : 1;            /*!< [27..27] Receive data is sampled every 10ns (100MHz system clock).
                                                     If this bit is set, the stored receive value will be the
                                                     result of a majority decision of the three sampling points
                                                     around a SPI-clock edge (if two or more '1s! were sampled
                                                     a '1' will be stored, else a '0' will be stored. In slave
                                                     mode chip-select and SCK edges will also be detected by
                                                     oversampling if this bit is set: An edge will be detected
                                                     if the majority-result of 3 subsequent sampled values toggles.
                                                     Input filtering should be used for sck_mulad                              */
      __IOM uint32_t slave_sig_early : 1;       /*!< [28..28] Generate MISO in slave mode 1 SCK clock edge earlier
                                                     than defined in the SPI specification. This is to compensate
                                                     pad or sampling delays on fast data rates. However, hold
                                                     timing problems could come up as MISO is generated very
                                                     fast after the sampling SPI clock edge. If filter_in is
                                                     enabled, it takes at least 3 system clocks to generate
                                                     MISO after SCK. If filter_in is disabled, it takes at least
                                                     2 system clocks to generate MISO after SCK.                               */
      __IOM uint32_t reserved3  : 2;            /*!< [30..29] reserved                                                         */
      __IOM uint32_t netx100_comp : 1;          /*!< [31..31] Use netx100/500-compatible SPI mode: 0: start transfer
                                                     after writing data 1: start transfer after setting CR_write
                                                     or CR_read                                                                */
    } spi_cr0_b;
  } ;
  
  union {
    __IOM uint32_t spi_cr1;                     /*!< (@ 0x00000004) SPI control register 1 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t LBM        : 1;            /*!< [0..0] Loop back mode: 0: Internal loop back disabled 1: Internal
                                                     loop back enabled, spi_cr0.filter_in must be set for loopback
                                                     function                                                                  */
      __IOM uint32_t SSE        : 1;            /*!< [1..1] SPI enable: 0: Module disabled 1: Module enabled                   */
      __IOM uint32_t MS         : 1;            /*!< [2..2] Mode select: 0: Module is configured as master 1: Module
                                                     is configured as slave                                                    */
      __IOM uint32_t SOD        : 1;            /*!< [3..3] Slave mode output disable (to connect multiple slaves
                                                     to one master): 0: MISO can be driven in slave mode 1:
                                                     MISO is not driven in slave mode                                          */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t fss        : 3;            /*!< [10..8] Frame or slave select. There are up to 3 external SPI
                                                     chip-select signals. In master mode, the fss bits define
                                                     the states of the chip-select signals. The inversion for
                                                     low-active chip-selects (e.g. for Motorola SPI frame format)
                                                     is done automatically depending on the value programmed
                                                     to the 'format' bits. Example: To use the netX IO CS1 as
                                                     chip-select, program '010' here, regardless whether the
                                                     external chip-select is low or high active. In slave mode,
                                                     the fss bits are a mask to select which netX input sho                    */
      __IOM uint32_t fss_static : 1;            /*!< [11..11] SPI static chip-select: { | 0: SPI chip-select will
                                                     be toggled automatically before and after each transferred
                                                     word according to fss and datasize. 1: SPI chip-select
                                                     will be set statically according to the fss bits. }                       */
      __IOM uint32_t reserved1  : 4;            /*!< [15..12] reserved                                                         */
      __IOM uint32_t tx_fifo_wm : 4;            /*!< [19..16] Transmit FIFO watermark for IRQ generation                       */
      __IOM uint32_t tx_fifo_clr : 1;           /*!< [20..20] Writing '1' to this bit will clear the transmit FIFOs.
                                                     Note: There must be at least 1 system clock idle after
                                                     clear before writing new data to the FIFO. This is guaranteed
                                                     by the netX internal bus structure and needs not being
                                                     considered by software.                                                   */
      __IOM uint32_t reserved2  : 3;            /*!< [23..21] reserved                                                         */
      __IOM uint32_t rx_fifo_wm : 4;            /*!< [27..24] Receive FIFO watermark for IRQ generation                        */
      __IOM uint32_t rx_fifo_clr : 1;           /*!< [28..28] Writing '1' to this bit will clear the receive FIFOs.            */
      __IOM uint32_t reserved3  : 3;            /*!< [31..29] reserved                                                         */
    } spi_cr1_b;
  } ;
  
  union {
    __IOM uint32_t spi_dr;                      /*!< (@ 0x00000008) SPI data register Registers 0x30..0x3C can be
                                                                    used instead of registers 0x00...0x24 to
                                                                    keep netx50 software compliant to netx100/500.
                                                                    The SPI module has 2 FIFOs: One for transmit
                                                                    data and one for receive data. Read access:
                                                                    Received data byte is delivered from receive
                                                                    FIFO. Write access: Transmit data byte is
                                                                    written to send FIFO. Both FIFOs (receive
                                                                    and transmit) have a depth of 16. SPI master
                                                                    mode: MISO input data will be stored in
                                                                    the receive FIFO; transmit FIFO generates
                                                                    MOSI output data.                                          */
    
    struct {
      __IOM uint32_t data       : 17;           /*!< [16..0] Transmit data: Only lowest bits according to spi_cr0.datasize
                                                     will be sent. Receive data will be delivered on the lowest
                                                     bits, unused bits (above spi_cr0.datasize) will be '0'.
                                                     In slave mode transmit data is requested from the FIFO
                                                     when the last bit of the currently transferred word is
                                                     set to the MISO signal. If no next transmit data can be
                                                     read from the FIFO until the current word's last bit was
                                                     transferred, a FIFO underrun will occur in case chip-select
                                                     does not go inactive at the next detected SCK edge.                       */
    } spi_dr_b;
  } ;
  
  union {
    __IM  uint32_t spi_sr;                      /*!< (@ 0x0000000C) SPI status register Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t TFE        : 1;            /*!< [0..0] Transmit FIFO is empty (1 if empty)                                */
      __IM  uint32_t TNF        : 1;            /*!< [1..1] Transmit FIFO is not full (0 if full)                              */
      __IM  uint32_t RNE        : 1;            /*!< [2..2] Receive FIFO is not empty (0 if empty)                             */
      __IM  uint32_t RFF        : 1;            /*!< [3..3] Receive FIFO is full (1 if full)                                   */
      __IM  uint32_t BSY        : 1;            /*!< [4..4] Device busy (1 if data is currently transmitted/received
                                                     or the transmit FIFO is not empty)                                        */
      __IM  uint32_t reserved0  : 11;           /*!< [15..5] reserved                                                          */
      __IM  uint32_t tx_fifo_level : 5;         /*!< [20..16] Transmit FIFO level (number of words to transmit are
                                                     left in FIFO)                                                             */
      __IM  uint32_t reserved1  : 1;            /*!< [21..21] reserved                                                         */
      __IM  uint32_t tx_fifo_err_ovfl : 1;      /*!< [22..22] Transmit FIFO overflow error occurred, data is lost              */
      __IM  uint32_t tx_fifo_err_undr : 1;      /*!< [23..23] Transmit FIFO underrun error occurred, data is lost              */
      __IM  uint32_t rx_fifo_level : 5;         /*!< [28..24] Receive FIFO level (number of received words to read
                                                     out are left in FIFO)                                                     */
      __IM  uint32_t reserved2  : 1;            /*!< [29..29] reserved                                                         */
      __IM  uint32_t rx_fifo_err_ovfl : 1;      /*!< [30..30] Receive FIFO overflow error occurred, data is lost               */
      __IM  uint32_t rx_fifo_err_undr : 1;      /*!< [31..31] Receive FIFO underrun error occurred, data is lost               */
    } spi_sr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t spi_imsc;                    /*!< (@ 0x00000014) SPI Interrupt Mask Set and Clear register: Registers
                                                                    0x30..0x3C can be used instead of registers
                                                                    0x00...0x24 to keep netx50 software compliant
                                                                    to netx100/500. IRQ mask is an AND-mask:
                                                                    only raw interrupts with mask bit set can
                                                                    generate a module IRQ. When writing this
                                                                    register, the corresponding interrupt is
                                                                    cleared similar to writing the register
                                                                    spi_icr. Note: The functionality of this
                                                                    register is similar to the corresponding
                                                                    SQI register sqi_irq_mask. However, in contrast
                                                                    to this register,                                          */
    
    struct {
      __IOM uint32_t RORIM      : 1;            /*!< [0..0] Receive FIFO overrun interrupt mask                                */
      __IOM uint32_t RTIM       : 1;            /*!< [1..1] Receive timeout interrupt mask                                     */
      __IOM uint32_t RXIM       : 1;            /*!< [2..2] Receive FIFO interrupt mask                                        */
      __IOM uint32_t TXIM       : 1;            /*!< [3..3] Transmit FIFO interrupt mask                                       */
      __IOM uint32_t rxneim     : 1;            /*!< [4..4] Receive FIFO not empty interrupt mask (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfim      : 1;            /*!< [5..5] Receive FIFO full interrupt mask (for netx100/500 compliance)      */
      __IOM uint32_t txeim      : 1;            /*!< [6..6] Transmit FIFO empty interrupt mask (for netx100/500 compliance)    */
    } spi_imsc_b;
  } ;
  
  union {
    __IM  uint32_t spi_ris;                     /*!< (@ 0x00000018) SPI interrupt state before masking register (raw
                                                                    interrupt) Registers 0x30..0x3C can be used
                                                                    instead of registers 0x00...0x24 to keep
                                                                    netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORRIS     : 1;            /*!< [0..0] Unmasked receive FIFO overrun interrupt state 1: receive
                                                     FIFO overrun error occurred 0: no receive FIFO overrun
                                                     error occurred                                                            */
      __IM  uint32_t RTRIS      : 1;            /*!< [1..1] Unmasked receive timeout interrupt state Timeout period
                                                     are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd
                                                     1: receive FIFO is not empty and not read out in the passed
                                                     timeout period 0: receive FIFO is empty or read during
                                                     the last timeout period                                                   */
      __IM  uint32_t RXRIS      : 1;            /*!< [2..2] Unmasked receive FIFO interrupt state 1: receive FIFO
                                                     is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals
                                                     or is below spi_cr1.rx_fifo_wm                                            */
      __IM  uint32_t TXRIS      : 1;            /*!< [3..3] Unmasked transmit FIFO interrupt state 1: transmit FIFO
                                                     level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals
                                                     or is higher than spi_cr1.tx_fifo_wm                                      */
      __IM  uint32_t rxneris    : 1;            /*!< [4..4] Unmasked receive FIFO not empty interrupt state (for
                                                     netx100/500 compliance) 1: receive FIFO is not empty 0:
                                                     receive FIFO is empty                                                     */
      __IM  uint32_t rxfris     : 1;            /*!< [5..5] Unmasked receive FIFO full interrupt state (for netx100/500
                                                     compliance) 1: receive FIFO is full 0: receive FIFO is
                                                     not full                                                                  */
      __IM  uint32_t txeris     : 1;            /*!< [6..6] Unmasked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance) 1: transmit FIFO is empty 0: transmit FIFO
                                                     is not empty                                                              */
    } spi_ris_b;
  } ;
  
  union {
    __IM  uint32_t spi_mis;                     /*!< (@ 0x0000001C) SPI interrupt status register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< [0..0] Masked receive FIFO overrun interrupt state                        */
      __IM  uint32_t RTMIS      : 1;            /*!< [1..1] Masked receive timeout interrupt state                             */
      __IM  uint32_t RXMIS      : 1;            /*!< [2..2] Masked receive FIFO interrupt state                                */
      __IM  uint32_t TXMIS      : 1;            /*!< [3..3] Masked transmit FIFO interrupt state                               */
      __IM  uint32_t rxnemis    : 1;            /*!< [4..4] Masked receive FIFO not empty interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t rxfmis     : 1;            /*!< [5..5] Masked receive FIFO full interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t txemis     : 1;            /*!< [6..6] Masked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance)                                                               */
    } spi_mis_b;
  } ;
  
  union {
    __IOM uint32_t spi_icr;                     /*!< (@ 0x00000020) SPI interrupt clear register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    An interrupt is cleared by writing '1' to
                                                                    the according bit. Note: Both FIFOs (receive
                                                                    and transmit) have a depth of 16.                          */
    
    struct {
      __IOM uint32_t RORIC      : 1;            /*!< [0..0] Clear receive FIFO overrun interrupt Writing '1' here
                                                     will clear the receive FIFO                                               */
      __IOM uint32_t RTIC       : 1;            /*!< [1..1] Clear receive FIFO overrun interrupt                               */
      __IOM uint32_t RXIC       : 1;            /*!< [2..2] PL022 extension: clear receive FIFO interrupt                      */
      __IOM uint32_t TXIC       : 1;            /*!< [3..3] PL022 extension: clear transmit FIFO interrupt                     */
      __IOM uint32_t rxneic     : 1;            /*!< [4..4] Clear receive FIFO not empty interrupt (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfic      : 1;            /*!< [5..5] Clear receive FIFO full interrupt (for netx100/500 compliance)     */
      __IOM uint32_t txeic      : 1;            /*!< [6..6] Clear transmit FIFO empty interrupt (for netx100/500
                                                     compliance)                                                               */
    } spi_icr_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t spi_dmacr;                   /*!< (@ 0x00000028) SPI DMA control register                                   */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Enable DMA for SPI receive data. A single request will
                                                     be generated if the receive FIFO is not empty and spi_cr1.SSE
                                                     (module enable) is set. Burst request to the DMA controller
                                                     will be generated if the receive FIFO contains at least
                                                     4 words (set DMA burst size to 4). If this bit is reset
                                                     or the module is disabled, the DMA request signals will
                                                     also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst
                                                     size: 4) in the DMA controller.                                           */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Enable DMA for SPI transmit data. A single request will
                                                     be generated if the transmit FIFO is not full and spi_cr1.SSE
                                                     (module enable) is set. Burst requests to the DMA controller
                                                     will be generated if at least 4 words are writable to the
                                                     transmit FIFO (set DMA burst size to 4). If this bit is
                                                     reset or the module is disabled, the DMA request signals
                                                     will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e.
                                                     burst size: 4) in the DMA controller.                                     */
    } spi_dmacr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t spi_data_register;           /*!< (@ 0x00000030) netx100/500 compliant SPI data register (DR)
                                                                    Registers 0x30..0x3C can be used instead
                                                                    of registers 0x00...0x24 to keep netx50
                                                                    software compliant to netx100/500. 2 data
                                                                    bytes with valid bits. During a write access
                                                                    data_byte_1 and dr_valid1 must not be used.
                                                                    dr_valid0 must be set. In netx50 and later
                                                                    versions both FIFOs (receive and transmit)
                                                                    have a depth of 16, fill values are fixed
                                                                    to 4. To keep software compatible, not more
                                                                    than 8 bytes should be in netx100/500 FIFOs.               */
    
    struct {
      __IOM uint32_t data_byte_0 : 8;           /*!< [7..0] Data byte 0                                                        */
      __IOM uint32_t data_byte_1 : 8;           /*!< [15..8] Obsolete, don't use                                               */
      __IOM uint32_t dr_valid0  : 1;            /*!< [16..16] Valid bit for data_byte_0 This bit shows if data_byte_0
                                                     is valid and must be set during a FIFO write access.                      */
      __IOM uint32_t dr_valid1  : 1;            /*!< [17..17] Obsolete, always 0                                               */
    } spi_data_register_b;
  } ;
  
  union {
    __IM  uint32_t spi_status_register;         /*!< (@ 0x00000034) netx100/500 compliant SPI status register (SR):
                                                                    Shows the actual status of the SPI interface.
                                                                    Bits 24..18 show occurred interrupts; writing
                                                                    ones into these bits clears the interrupts.
                                                                    Writing into other bits has no effect. In
                                                                    netx50 and later versions both FIFOs (receive
                                                                    and transmit) have a depth of 16, fill values
                                                                    are fixed to 4. To keep software compatible,
                                                                    not more than 8 bytes should be in netx100/500
                                                                    FIFOs.                                                     */
    
    struct {
      __IM  uint32_t SR_in_fuel_val : 9;        /*!< [8..0] Input FIFO fill value (number of bytes)                            */
      __IM  uint32_t SR_out_fuel_val : 9;       /*!< [17..9] Output FIFO fill value (number of bytes)                          */
      __IM  uint32_t SR_in_fuel : 1;            /*!< [18..18] Adjustable fill value of input FIFO reached (equals
                                                     spi_ris.RXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_in_recdata : 1;         /*!< [19..19] Valid data bytes in input FIFO (equals spi_ris.rxneris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_in_full : 1;            /*!< [20..20] Input FIFO is full (equals spi_ris.rxfris in netx50
                                                     and later versions)                                                       */
      __IM  uint32_t SR_out_fuel : 1;           /*!< [21..21] Adjustable fill value of output FIFO reached (equals
                                                     spi_ris.TXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_out_fw  : 1;            /*!< [22..22] netX is writing data too fast into output FIFO. Available
                                                     as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl
                                                     in netx50 and later versions).                                            */
      __IM  uint32_t SR_out_empty : 1;          /*!< [23..23] Output FIFO is empty in slave mode (equals spi_ris.txeris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_out_full : 1;           /*!< [24..24] Output FIFO is full. This is only with netx100/500
                                                     an IRQ.                                                                   */
      __IM  uint32_t SR_selected : 1;           /*!< [25..25] External master has access to SPI interface                      */
    } spi_status_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_control_register;        /*!< (@ 0x00000038) netx100/500 compliant SPI control register (CR)            */
    
    struct {
      __IOM uint32_t CR_softreset : 1;          /*!< [0..0] write only: no function in netx100/netx500; later versions:
                                                     clears IRQs and FIFOs                                                     */
      __IOM uint32_t CR_speed   : 4;            /*!< [4..1] Clock divider for SPI clock (2 - 2^16) If SPI clock rate
                                                     is changed using spi_cr0.sck_muladd, this value will not
                                                     be updated and may be incorrect There are 16 different
                                                     SPI clocks frequencies to choose: 0000: 0.025 MHz (Note:
                                                     Not compatible to netx100/500. '0000' freezes SCK in netx100/500.)
                                                     0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz
                                                     0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001:
                                                     3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101:
                                                     16.6666 MHz 1110: 25 MHz 1111: 50 MHz                                     */
      __IOM uint32_t reserved0  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t CR_read    : 1;            /*!< [6..6] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface read data                                            */
      __IOM uint32_t CR_write   : 1;            /*!< [7..7] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface write data                                           */
      __IOM uint32_t CR_ss      : 3;            /*!< [10..8] External slave select                                             */
      __IOM uint32_t CS_mode    : 1;            /*!< [11..11] 1: chip select is generated automatically by the internal
                                                     state machine 0: chip select is directly controlled by
                                                     software (see bits CR_ss).                                                */
      __IOM uint32_t reserved1  : 8;            /*!< [19..12] reserved                                                         */
      __IOM uint32_t CR_clr_infifo : 1;         /*!< [20..20] Clear input FIFO                                                 */
      __IOM uint32_t CR_clr_outfifo : 1;        /*!< [21..21] Clear output FIFO                                                */
      __IOM uint32_t CR_burstdelay : 3;         /*!< [24..22] netx100/netx500 only, obsolete in later versions: delay
                                                     between transmission of 2 data bytes (0 to 7 SCK cycles)                  */
      __IOM uint32_t CR_burst   : 3;            /*!< [27..25] netx100/netx500 only, obsolete in later versions: burst
                                                     length = 2^CR_burst                                                       */
      __IOM uint32_t CR_ncpha   : 1;            /*!< [28..28] SPI clock phase mode (Note: meaning of this bit is
                                                     inverted to functionality of bit spi_cr0.SPH): { | 0: change
                                                     data on secondary SCK edge data is active on primary SCK
                                                     edge 1: change data on primary SCK edge data is active
                                                     on secondary SCK edge }                                                   */
      __IOM uint32_t CR_cpol    : 1;            /*!< [29..29] 1: falling edge of SCK is primary 0: rising edge of
                                                     SCK is primary                                                            */
      __IOM uint32_t CR_ms      : 1;            /*!< [30..30] 1: master mode 0:slave mode                                      */
      __IOM uint32_t CR_en      : 1;            /*!< [31..31] 1: enable 0: disable SPI interface                               */
    } spi_control_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_interrupt_control_register;/*!< (@ 0x0000003C) netx100/500 compliant SPI interrupt control register
                                                                    (IR) In netx50 and later versions both FIFOs
                                                                    (receive and transmit) have a depth of 16,
                                                                    fill values are fixed to 4. To keep software
                                                                    compatible, not more than 8 bytes should
                                                                    be in netx100/500 FIFOs.                                   */
    
    struct {
      __IOM uint32_t IR_in_fuel : 9;            /*!< [8..0] Adjustable watermark level of input FIFO                           */
      __IOM uint32_t IR_out_fuel : 9;           /*!< [17..9] Adjustable watermark level of output FIFO                         */
      __IOM uint32_t IR_in_fuel_en : 1;         /*!< [18..18] IRQ enable for irq_spi(0) (equals spi_imsc.RXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_recdata_en : 1;      /*!< [19..19] IRQ enable for irq_spi(1) (equals spi_imsc.txneim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_full_en : 1;         /*!< [20..20] IRQ enable for irq_spi(2) (equals spi_imsc.txfim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fuel_en : 1;        /*!< [21..21] IRQ enable for irq_spi(3) (equals spi_imsc.TXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fw_en : 1;          /*!< [22..22] IRQ enable for irq_spi(4), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
      __IOM uint32_t IR_out_empty_en : 1;       /*!< [23..23] IRQ enable for irq_spi(5) (equals spi_imsc.rxeim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_full_en : 1;        /*!< [24..24] IRQ enable for irq_spi(6), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
    } spi_interrupt_control_register_b;
  } ;
} spi1_app_Type;                                /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                         spi2_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief spi2_app (spi2_app)
  */

typedef struct {                                /*!< (@ 0xFF801A80) spi2_app Structure                                         */
  
  union {
    __IOM uint32_t spi_cr0;                     /*!< (@ 0x00000000) SPI control register 0 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t datasize   : 4;            /*!< [3..0] DSS: data size select (transfer size = datasize + 1 bits):
                                                     { | 0000...0010: reserved 0011: 4 bit 0100: 5 bit ... 0111:
                                                     8 bit ... 1111: 16 bit } Note: 16 bit TX-data-loss bug
                                                     of netX50/netX5 is fixed since netX10.                                    */
      __IOM uint32_t reserved0  : 2;            /*!< [5..4] reserved                                                           */
      __IOM uint32_t SPO        : 1;            /*!< [6..6] Serial clock polarity (netx500: CR_cpol): 0: idle: clock
                                                     is low, first edge is rising 1: idle: clock is high, first
                                                     edge is falling                                                           */
      __IOM uint32_t SPH        : 1;            /*!< [7..7] Serial clock phase (netx500: CR_ncpha): 1: sample data
                                                     at second clock edge, data is generated half a clock phase
                                                     before sampling 0: sample data at first clock edge, data
                                                     is generated half a clock phase before sampling                           */
      __IOM uint32_t sck_muladd : 12;           /*!< [19..8] Serial clock rate multiply add value for master SCK
                                                     generation. The SPI clock frequency is: f_spi_sck = (sck_muladd
                                                     * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI
                                                     clock rate. All serial clock rates are derived from 100MHz
                                                     netX system clock. Hence, all serial clock phases are multiples
                                                     of 10ns. This leads to non-constant serial clock phases
                                                     when a clock rate is programmed which cannot be generated
                                                     by 100MHz/(2*n) without remainder. E.g. programming 0x4CC
                                                     here will lead to a mean clock-rate of 30MHz                              */
      __IOM uint32_t reserved1  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t format     : 2;            /*!< [25..24] Frame format: 00: Motorola SPI frame format 01..11:
                                                     reserved                                                                  */
      __IOM uint32_t reserved2  : 1;            /*!< [26..26] reserved                                                         */
      __IOM uint32_t filter_in  : 1;            /*!< [27..27] Receive data is sampled every 10ns (100MHz system clock).
                                                     If this bit is set, the stored receive value will be the
                                                     result of a majority decision of the three sampling points
                                                     around a SPI-clock edge (if two or more '1s! were sampled
                                                     a '1' will be stored, else a '0' will be stored. In slave
                                                     mode chip-select and SCK edges will also be detected by
                                                     oversampling if this bit is set: An edge will be detected
                                                     if the majority-result of 3 subsequent sampled values toggles.
                                                     Input filtering should be used for sck_mulad                              */
      __IOM uint32_t slave_sig_early : 1;       /*!< [28..28] Generate MISO in slave mode 1 SCK clock edge earlier
                                                     than defined in the SPI specification. This is to compensate
                                                     pad or sampling delays on fast data rates. However, hold
                                                     timing problems could come up as MISO is generated very
                                                     fast after the sampling SPI clock edge. If filter_in is
                                                     enabled, it takes at least 3 system clocks to generate
                                                     MISO after SCK. If filter_in is disabled, it takes at least
                                                     2 system clocks to generate MISO after SCK.                               */
      __IOM uint32_t reserved3  : 2;            /*!< [30..29] reserved                                                         */
      __IOM uint32_t netx100_comp : 1;          /*!< [31..31] Use netx100/500-compatible SPI mode: 0: start transfer
                                                     after writing data 1: start transfer after setting CR_write
                                                     or CR_read                                                                */
    } spi_cr0_b;
  } ;
  
  union {
    __IOM uint32_t spi_cr1;                     /*!< (@ 0x00000004) SPI control register 1 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t LBM        : 1;            /*!< [0..0] Loop back mode: 0: Internal loop back disabled 1: Internal
                                                     loop back enabled, spi_cr0.filter_in must be set for loopback
                                                     function                                                                  */
      __IOM uint32_t SSE        : 1;            /*!< [1..1] SPI enable: 0: Module disabled 1: Module enabled                   */
      __IOM uint32_t MS         : 1;            /*!< [2..2] Mode select: 0: Module is configured as master 1: Module
                                                     is configured as slave                                                    */
      __IOM uint32_t SOD        : 1;            /*!< [3..3] Slave mode output disable (to connect multiple slaves
                                                     to one master): 0: MISO can be driven in slave mode 1:
                                                     MISO is not driven in slave mode                                          */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t fss        : 3;            /*!< [10..8] Frame or slave select. There are up to 3 external SPI
                                                     chip-select signals. In master mode, the fss bits define
                                                     the states of the chip-select signals. The inversion for
                                                     low-active chip-selects (e.g. for Motorola SPI frame format)
                                                     is done automatically depending on the value programmed
                                                     to the 'format' bits. Example: To use the netX IO CS1 as
                                                     chip-select, program '010' here, regardless whether the
                                                     external chip-select is low or high active. In slave mode,
                                                     the fss bits are a mask to select which netX input sho                    */
      __IOM uint32_t fss_static : 1;            /*!< [11..11] SPI static chip-select: { | 0: SPI chip-select will
                                                     be toggled automatically before and after each transferred
                                                     word according to fss and datasize. 1: SPI chip-select
                                                     will be set statically according to the fss bits. }                       */
      __IOM uint32_t reserved1  : 4;            /*!< [15..12] reserved                                                         */
      __IOM uint32_t tx_fifo_wm : 4;            /*!< [19..16] Transmit FIFO watermark for IRQ generation                       */
      __IOM uint32_t tx_fifo_clr : 1;           /*!< [20..20] Writing '1' to this bit will clear the transmit FIFOs.
                                                     Note: There must be at least 1 system clock idle after
                                                     clear before writing new data to the FIFO. This is guaranteed
                                                     by the netX internal bus structure and needs not being
                                                     considered by software.                                                   */
      __IOM uint32_t reserved2  : 3;            /*!< [23..21] reserved                                                         */
      __IOM uint32_t rx_fifo_wm : 4;            /*!< [27..24] Receive FIFO watermark for IRQ generation                        */
      __IOM uint32_t rx_fifo_clr : 1;           /*!< [28..28] Writing '1' to this bit will clear the receive FIFOs.            */
      __IOM uint32_t reserved3  : 3;            /*!< [31..29] reserved                                                         */
    } spi_cr1_b;
  } ;
  
  union {
    __IOM uint32_t spi_dr;                      /*!< (@ 0x00000008) SPI data register Registers 0x30..0x3C can be
                                                                    used instead of registers 0x00...0x24 to
                                                                    keep netx50 software compliant to netx100/500.
                                                                    The SPI module has 2 FIFOs: One for transmit
                                                                    data and one for receive data. Read access:
                                                                    Received data byte is delivered from receive
                                                                    FIFO. Write access: Transmit data byte is
                                                                    written to send FIFO. Both FIFOs (receive
                                                                    and transmit) have a depth of 16. SPI master
                                                                    mode: MISO input data will be stored in
                                                                    the receive FIFO; transmit FIFO generates
                                                                    MOSI output data.                                          */
    
    struct {
      __IOM uint32_t data       : 17;           /*!< [16..0] Transmit data: Only lowest bits according to spi_cr0.datasize
                                                     will be sent. Receive data will be delivered on the lowest
                                                     bits, unused bits (above spi_cr0.datasize) will be '0'.
                                                     In slave mode transmit data is requested from the FIFO
                                                     when the last bit of the currently transferred word is
                                                     set to the MISO signal. If no next transmit data can be
                                                     read from the FIFO until the current word's last bit was
                                                     transferred, a FIFO underrun will occur in case chip-select
                                                     does not go inactive at the next detected SCK edge.                       */
    } spi_dr_b;
  } ;
  
  union {
    __IM  uint32_t spi_sr;                      /*!< (@ 0x0000000C) SPI status register Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t TFE        : 1;            /*!< [0..0] Transmit FIFO is empty (1 if empty)                                */
      __IM  uint32_t TNF        : 1;            /*!< [1..1] Transmit FIFO is not full (0 if full)                              */
      __IM  uint32_t RNE        : 1;            /*!< [2..2] Receive FIFO is not empty (0 if empty)                             */
      __IM  uint32_t RFF        : 1;            /*!< [3..3] Receive FIFO is full (1 if full)                                   */
      __IM  uint32_t BSY        : 1;            /*!< [4..4] Device busy (1 if data is currently transmitted/received
                                                     or the transmit FIFO is not empty)                                        */
      __IM  uint32_t reserved0  : 11;           /*!< [15..5] reserved                                                          */
      __IM  uint32_t tx_fifo_level : 5;         /*!< [20..16] Transmit FIFO level (number of words to transmit are
                                                     left in FIFO)                                                             */
      __IM  uint32_t reserved1  : 1;            /*!< [21..21] reserved                                                         */
      __IM  uint32_t tx_fifo_err_ovfl : 1;      /*!< [22..22] Transmit FIFO overflow error occurred, data is lost              */
      __IM  uint32_t tx_fifo_err_undr : 1;      /*!< [23..23] Transmit FIFO underrun error occurred, data is lost              */
      __IM  uint32_t rx_fifo_level : 5;         /*!< [28..24] Receive FIFO level (number of received words to read
                                                     out are left in FIFO)                                                     */
      __IM  uint32_t reserved2  : 1;            /*!< [29..29] reserved                                                         */
      __IM  uint32_t rx_fifo_err_ovfl : 1;      /*!< [30..30] Receive FIFO overflow error occurred, data is lost               */
      __IM  uint32_t rx_fifo_err_undr : 1;      /*!< [31..31] Receive FIFO underrun error occurred, data is lost               */
    } spi_sr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t spi_imsc;                    /*!< (@ 0x00000014) SPI Interrupt Mask Set and Clear register: Registers
                                                                    0x30..0x3C can be used instead of registers
                                                                    0x00...0x24 to keep netx50 software compliant
                                                                    to netx100/500. IRQ mask is an AND-mask:
                                                                    only raw interrupts with mask bit set can
                                                                    generate a module IRQ. When writing this
                                                                    register, the corresponding interrupt is
                                                                    cleared similar to writing the register
                                                                    spi_icr. Note: The functionality of this
                                                                    register is similar to the corresponding
                                                                    SQI register sqi_irq_mask. However, in contrast
                                                                    to this register,                                          */
    
    struct {
      __IOM uint32_t RORIM      : 1;            /*!< [0..0] Receive FIFO overrun interrupt mask                                */
      __IOM uint32_t RTIM       : 1;            /*!< [1..1] Receive timeout interrupt mask                                     */
      __IOM uint32_t RXIM       : 1;            /*!< [2..2] Receive FIFO interrupt mask                                        */
      __IOM uint32_t TXIM       : 1;            /*!< [3..3] Transmit FIFO interrupt mask                                       */
      __IOM uint32_t rxneim     : 1;            /*!< [4..4] Receive FIFO not empty interrupt mask (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfim      : 1;            /*!< [5..5] Receive FIFO full interrupt mask (for netx100/500 compliance)      */
      __IOM uint32_t txeim      : 1;            /*!< [6..6] Transmit FIFO empty interrupt mask (for netx100/500 compliance)    */
    } spi_imsc_b;
  } ;
  
  union {
    __IM  uint32_t spi_ris;                     /*!< (@ 0x00000018) SPI interrupt state before masking register (raw
                                                                    interrupt) Registers 0x30..0x3C can be used
                                                                    instead of registers 0x00...0x24 to keep
                                                                    netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORRIS     : 1;            /*!< [0..0] Unmasked receive FIFO overrun interrupt state 1: receive
                                                     FIFO overrun error occurred 0: no receive FIFO overrun
                                                     error occurred                                                            */
      __IM  uint32_t RTRIS      : 1;            /*!< [1..1] Unmasked receive timeout interrupt state Timeout period
                                                     are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd
                                                     1: receive FIFO is not empty and not read out in the passed
                                                     timeout period 0: receive FIFO is empty or read during
                                                     the last timeout period                                                   */
      __IM  uint32_t RXRIS      : 1;            /*!< [2..2] Unmasked receive FIFO interrupt state 1: receive FIFO
                                                     is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals
                                                     or is below spi_cr1.rx_fifo_wm                                            */
      __IM  uint32_t TXRIS      : 1;            /*!< [3..3] Unmasked transmit FIFO interrupt state 1: transmit FIFO
                                                     level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals
                                                     or is higher than spi_cr1.tx_fifo_wm                                      */
      __IM  uint32_t rxneris    : 1;            /*!< [4..4] Unmasked receive FIFO not empty interrupt state (for
                                                     netx100/500 compliance) 1: receive FIFO is not empty 0:
                                                     receive FIFO is empty                                                     */
      __IM  uint32_t rxfris     : 1;            /*!< [5..5] Unmasked receive FIFO full interrupt state (for netx100/500
                                                     compliance) 1: receive FIFO is full 0: receive FIFO is
                                                     not full                                                                  */
      __IM  uint32_t txeris     : 1;            /*!< [6..6] Unmasked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance) 1: transmit FIFO is empty 0: transmit FIFO
                                                     is not empty                                                              */
    } spi_ris_b;
  } ;
  
  union {
    __IM  uint32_t spi_mis;                     /*!< (@ 0x0000001C) SPI interrupt status register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< [0..0] Masked receive FIFO overrun interrupt state                        */
      __IM  uint32_t RTMIS      : 1;            /*!< [1..1] Masked receive timeout interrupt state                             */
      __IM  uint32_t RXMIS      : 1;            /*!< [2..2] Masked receive FIFO interrupt state                                */
      __IM  uint32_t TXMIS      : 1;            /*!< [3..3] Masked transmit FIFO interrupt state                               */
      __IM  uint32_t rxnemis    : 1;            /*!< [4..4] Masked receive FIFO not empty interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t rxfmis     : 1;            /*!< [5..5] Masked receive FIFO full interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t txemis     : 1;            /*!< [6..6] Masked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance)                                                               */
    } spi_mis_b;
  } ;
  
  union {
    __IOM uint32_t spi_icr;                     /*!< (@ 0x00000020) SPI interrupt clear register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    An interrupt is cleared by writing '1' to
                                                                    the according bit. Note: Both FIFOs (receive
                                                                    and transmit) have a depth of 16.                          */
    
    struct {
      __IOM uint32_t RORIC      : 1;            /*!< [0..0] Clear receive FIFO overrun interrupt Writing '1' here
                                                     will clear the receive FIFO                                               */
      __IOM uint32_t RTIC       : 1;            /*!< [1..1] Clear receive FIFO overrun interrupt                               */
      __IOM uint32_t RXIC       : 1;            /*!< [2..2] PL022 extension: clear receive FIFO interrupt                      */
      __IOM uint32_t TXIC       : 1;            /*!< [3..3] PL022 extension: clear transmit FIFO interrupt                     */
      __IOM uint32_t rxneic     : 1;            /*!< [4..4] Clear receive FIFO not empty interrupt (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfic      : 1;            /*!< [5..5] Clear receive FIFO full interrupt (for netx100/500 compliance)     */
      __IOM uint32_t txeic      : 1;            /*!< [6..6] Clear transmit FIFO empty interrupt (for netx100/500
                                                     compliance)                                                               */
    } spi_icr_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t spi_dmacr;                   /*!< (@ 0x00000028) SPI DMA control register                                   */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Enable DMA for SPI receive data. A single request will
                                                     be generated if the receive FIFO is not empty and spi_cr1.SSE
                                                     (module enable) is set. Burst request to the DMA controller
                                                     will be generated if the receive FIFO contains at least
                                                     4 words (set DMA burst size to 4). If this bit is reset
                                                     or the module is disabled, the DMA request signals will
                                                     also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst
                                                     size: 4) in the DMA controller.                                           */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Enable DMA for SPI transmit data. A single request will
                                                     be generated if the transmit FIFO is not full and spi_cr1.SSE
                                                     (module enable) is set. Burst requests to the DMA controller
                                                     will be generated if at least 4 words are writable to the
                                                     transmit FIFO (set DMA burst size to 4). If this bit is
                                                     reset or the module is disabled, the DMA request signals
                                                     will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e.
                                                     burst size: 4) in the DMA controller.                                     */
    } spi_dmacr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t spi_data_register;           /*!< (@ 0x00000030) netx100/500 compliant SPI data register (DR)
                                                                    Registers 0x30..0x3C can be used instead
                                                                    of registers 0x00...0x24 to keep netx50
                                                                    software compliant to netx100/500. 2 data
                                                                    bytes with valid bits. During a write access
                                                                    data_byte_1 and dr_valid1 must not be used.
                                                                    dr_valid0 must be set. In netx50 and later
                                                                    versions both FIFOs (receive and transmit)
                                                                    have a depth of 16, fill values are fixed
                                                                    to 4. To keep software compatible, not more
                                                                    than 8 bytes should be in netx100/500 FIFOs.               */
    
    struct {
      __IOM uint32_t data_byte_0 : 8;           /*!< [7..0] Data byte 0                                                        */
      __IOM uint32_t data_byte_1 : 8;           /*!< [15..8] Obsolete, don't use                                               */
      __IOM uint32_t dr_valid0  : 1;            /*!< [16..16] Valid bit for data_byte_0 This bit shows if data_byte_0
                                                     is valid and must be set during a FIFO write access.                      */
      __IOM uint32_t dr_valid1  : 1;            /*!< [17..17] Obsolete, always 0                                               */
    } spi_data_register_b;
  } ;
  
  union {
    __IM  uint32_t spi_status_register;         /*!< (@ 0x00000034) netx100/500 compliant SPI status register (SR):
                                                                    Shows the actual status of the SPI interface.
                                                                    Bits 24..18 show occurred interrupts; writing
                                                                    ones into these bits clears the interrupts.
                                                                    Writing into other bits has no effect. In
                                                                    netx50 and later versions both FIFOs (receive
                                                                    and transmit) have a depth of 16, fill values
                                                                    are fixed to 4. To keep software compatible,
                                                                    not more than 8 bytes should be in netx100/500
                                                                    FIFOs.                                                     */
    
    struct {
      __IM  uint32_t SR_in_fuel_val : 9;        /*!< [8..0] Input FIFO fill value (number of bytes)                            */
      __IM  uint32_t SR_out_fuel_val : 9;       /*!< [17..9] Output FIFO fill value (number of bytes)                          */
      __IM  uint32_t SR_in_fuel : 1;            /*!< [18..18] Adjustable fill value of input FIFO reached (equals
                                                     spi_ris.RXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_in_recdata : 1;         /*!< [19..19] Valid data bytes in input FIFO (equals spi_ris.rxneris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_in_full : 1;            /*!< [20..20] Input FIFO is full (equals spi_ris.rxfris in netx50
                                                     and later versions)                                                       */
      __IM  uint32_t SR_out_fuel : 1;           /*!< [21..21] Adjustable fill value of output FIFO reached (equals
                                                     spi_ris.TXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_out_fw  : 1;            /*!< [22..22] netX is writing data too fast into output FIFO. Available
                                                     as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl
                                                     in netx50 and later versions).                                            */
      __IM  uint32_t SR_out_empty : 1;          /*!< [23..23] Output FIFO is empty in slave mode (equals spi_ris.txeris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_out_full : 1;           /*!< [24..24] Output FIFO is full. This is only with netx100/500
                                                     an IRQ.                                                                   */
      __IM  uint32_t SR_selected : 1;           /*!< [25..25] External master has access to SPI interface                      */
    } spi_status_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_control_register;        /*!< (@ 0x00000038) netx100/500 compliant SPI control register (CR)            */
    
    struct {
      __IOM uint32_t CR_softreset : 1;          /*!< [0..0] write only: no function in netx100/netx500; later versions:
                                                     clears IRQs and FIFOs                                                     */
      __IOM uint32_t CR_speed   : 4;            /*!< [4..1] Clock divider for SPI clock (2 - 2^16) If SPI clock rate
                                                     is changed using spi_cr0.sck_muladd, this value will not
                                                     be updated and may be incorrect There are 16 different
                                                     SPI clocks frequencies to choose: 0000: 0.025 MHz (Note:
                                                     Not compatible to netx100/500. '0000' freezes SCK in netx100/500.)
                                                     0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz
                                                     0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001:
                                                     3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101:
                                                     16.6666 MHz 1110: 25 MHz 1111: 50 MHz                                     */
      __IOM uint32_t reserved0  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t CR_read    : 1;            /*!< [6..6] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface read data                                            */
      __IOM uint32_t CR_write   : 1;            /*!< [7..7] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface write data                                           */
      __IOM uint32_t CR_ss      : 3;            /*!< [10..8] External slave select                                             */
      __IOM uint32_t CS_mode    : 1;            /*!< [11..11] 1: chip select is generated automatically by the internal
                                                     state machine 0: chip select is directly controlled by
                                                     software (see bits CR_ss).                                                */
      __IOM uint32_t reserved1  : 8;            /*!< [19..12] reserved                                                         */
      __IOM uint32_t CR_clr_infifo : 1;         /*!< [20..20] Clear input FIFO                                                 */
      __IOM uint32_t CR_clr_outfifo : 1;        /*!< [21..21] Clear output FIFO                                                */
      __IOM uint32_t CR_burstdelay : 3;         /*!< [24..22] netx100/netx500 only, obsolete in later versions: delay
                                                     between transmission of 2 data bytes (0 to 7 SCK cycles)                  */
      __IOM uint32_t CR_burst   : 3;            /*!< [27..25] netx100/netx500 only, obsolete in later versions: burst
                                                     length = 2^CR_burst                                                       */
      __IOM uint32_t CR_ncpha   : 1;            /*!< [28..28] SPI clock phase mode (Note: meaning of this bit is
                                                     inverted to functionality of bit spi_cr0.SPH): { | 0: change
                                                     data on secondary SCK edge data is active on primary SCK
                                                     edge 1: change data on primary SCK edge data is active
                                                     on secondary SCK edge }                                                   */
      __IOM uint32_t CR_cpol    : 1;            /*!< [29..29] 1: falling edge of SCK is primary 0: rising edge of
                                                     SCK is primary                                                            */
      __IOM uint32_t CR_ms      : 1;            /*!< [30..30] 1: master mode 0:slave mode                                      */
      __IOM uint32_t CR_en      : 1;            /*!< [31..31] 1: enable 0: disable SPI interface                               */
    } spi_control_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_interrupt_control_register;/*!< (@ 0x0000003C) netx100/500 compliant SPI interrupt control register
                                                                    (IR) In netx50 and later versions both FIFOs
                                                                    (receive and transmit) have a depth of 16,
                                                                    fill values are fixed to 4. To keep software
                                                                    compatible, not more than 8 bytes should
                                                                    be in netx100/500 FIFOs.                                   */
    
    struct {
      __IOM uint32_t IR_in_fuel : 9;            /*!< [8..0] Adjustable watermark level of input FIFO                           */
      __IOM uint32_t IR_out_fuel : 9;           /*!< [17..9] Adjustable watermark level of output FIFO                         */
      __IOM uint32_t IR_in_fuel_en : 1;         /*!< [18..18] IRQ enable for irq_spi(0) (equals spi_imsc.RXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_recdata_en : 1;      /*!< [19..19] IRQ enable for irq_spi(1) (equals spi_imsc.txneim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_full_en : 1;         /*!< [20..20] IRQ enable for irq_spi(2) (equals spi_imsc.txfim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fuel_en : 1;        /*!< [21..21] IRQ enable for irq_spi(3) (equals spi_imsc.TXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fw_en : 1;          /*!< [22..22] IRQ enable for irq_spi(4), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
      __IOM uint32_t IR_out_empty_en : 1;       /*!< [23..23] IRQ enable for irq_spi(5) (equals spi_imsc.rxeim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_full_en : 1;        /*!< [24..24] IRQ enable for irq_spi(6), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
    } spi_interrupt_control_register_b;
  } ;
} spi2_app_Type;                                /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                          pio_app                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief pio_app (pio_app)
  */

typedef struct {                                /*!< (@ 0xFF801AC0) pio_app Structure                                          */
  
  union {
    __IM  uint32_t pio_in;                      /*!< (@ 0x00000000) PIO input line status register. Each PIO input
                                                                    status can also be read from dedicated PIOx
                                                                    input state register.                                      */
    
    struct {
      __IM  uint32_t val        : 8;            /*!< [7..0] PIO input states (LSB: PIO0).                                      */
    } pio_in_b;
  } ;
  
  union {
    __IOM uint32_t pio_out;                     /*!< (@ 0x00000004) PIO output drive level line register. Each PIOs
                                                                    output drive level can also be programmed
                                                                    by dedicated PIOx output drive level register.             */
    
    struct {
      __IOM uint32_t val        : 8;            /*!< [7..0] PIO output drive levels (LSB: PIO0).                               */
    } pio_out_b;
  } ;
  
  union {
    __IOM uint32_t pio_oe;                      /*!< (@ 0x00000008) PIO output enable line register. Each PIOs output
                                                                    enable can also be programmed by dedicated
                                                                    PIOx output enable register.                               */
    
    struct {
      __IOM uint32_t val        : 8;            /*!< [7..0] PIO output enables (LSB: PIO0).                                    */
    } pio_oe_b;
  } ;
} pio_app_Type;                                 /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                         biss0_app                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief biss0_app (biss0_app)
  */

typedef struct {                                /*!< (@ 0xFF801B00) biss0_app Structure                                        */
  
  union {
    __IOM uint32_t biss_scdata0_0;              /*!< (@ 0x00000000) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA0_0  : 32;           /*!< [31..0] Slave0 (SCD)single cycle data[31:0]                               */
    } biss_scdata0_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata0_1;              /*!< (@ 0x00000004) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA0_1  : 32;           /*!< [31..0] Slave0 (SCD)single cycle data[63:32]                              */
    } biss_scdata0_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata1_0;              /*!< (@ 0x00000008) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA1_0  : 32;           /*!< [31..0] Slave1 (SCD)single cycle data[31:0]                               */
    } biss_scdata1_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata1_1;              /*!< (@ 0x0000000C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA1_1  : 32;           /*!< [31..0] Slave1 (SCD)single cycle data[63:32]                              */
    } biss_scdata1_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata2_0;              /*!< (@ 0x00000010) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA2_0  : 32;           /*!< [31..0] Slave2 (SCD)single cycle data[31:0]                               */
    } biss_scdata2_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata2_1;              /*!< (@ 0x00000014) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA2_1  : 32;           /*!< [31..0] Slave2 (SCD)single cycle data[63:32]                              */
    } biss_scdata2_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata3_0;              /*!< (@ 0x00000018) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA3_0  : 32;           /*!< [31..0] Slave3 (SCD)single cycle data[31:0]                               */
    } biss_scdata3_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata3_1;              /*!< (@ 0x0000001C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA3_1  : 32;           /*!< [31..0] Slave3 (SCD)single cycle data[63:32]                              */
    } biss_scdata3_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata4_0;              /*!< (@ 0x00000020) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA4_0  : 32;           /*!< [31..0] Slave4 (SCD)single cycle data[31:0]                               */
    } biss_scdata4_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata4_1;              /*!< (@ 0x00000024) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA4_1  : 32;           /*!< [31..0] Slave4 (SCD)single cycle data[63:32]                              */
    } biss_scdata4_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata5_0;              /*!< (@ 0x00000028) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA5_0  : 32;           /*!< [31..0] Slave5 (SCD)single cycle data[31:0]                               */
    } biss_scdata5_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata5_1;              /*!< (@ 0x0000002C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA5_1  : 32;           /*!< [31..0] Slave5 (SCD)single cycle data[63:32]                              */
    } biss_scdata5_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata6_0;              /*!< (@ 0x00000030) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA6_0  : 32;           /*!< [31..0] Slave6 (SCD)single cycle data[31:0]                               */
    } biss_scdata6_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata6_1;              /*!< (@ 0x00000034) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA6_1  : 32;           /*!< [31..0] Slave6 (SCD)single cycle data[63:32]                              */
    } biss_scdata6_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata7_0;              /*!< (@ 0x00000038) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA7_0  : 32;           /*!< [31..0] Slave0 (SCD)single cycle data[31:0]                               */
    } biss_scdata7_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata7_1;              /*!< (@ 0x0000003C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA7_1  : 32;           /*!< [31..0] Slave7 (SCD)single cycle data[63:32]                              */
    } biss_scdata7_1_b;
  } ;
  __IM  uint32_t  RESERVED[16];
  
  union {
    __IOM uint32_t biss_rdata0;                 /*!< (@ 0x00000080) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA0     : 32;           /*!< [31..0] - Using register access in control communication RDATA0:
                                                     register data DWord0 - Using command/instructions in control
                                                     communication IDS: ID-Select, command/instruction addressing
                                                     combinable                                                                */
    } biss_rdata0_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata1;                 /*!< (@ 0x00000084) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA1     : 32;           /*!< [31..0] register data DWord1                                              */
    } biss_rdata1_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata2;                 /*!< (@ 0x00000088) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA2     : 32;           /*!< [31..0] register data DWord2                                              */
    } biss_rdata2_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata3;                 /*!< (@ 0x0000008C) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA3     : 32;           /*!< [31..0] register data DWord3                                              */
    } biss_rdata3_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata4;                 /*!< (@ 0x00000090) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA4     : 32;           /*!< [31..0] register data DWord4                                              */
    } biss_rdata4_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata5;                 /*!< (@ 0x00000094) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA5     : 32;           /*!< [31..0] register data DWord5                                              */
    } biss_rdata5_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata6;                 /*!< (@ 0x00000098) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA6     : 32;           /*!< [31..0] register data DWord6                                              */
    } biss_rdata6_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata7;                 /*!< (@ 0x0000009C) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA7     : 32;           /*!< [31..0] register data DWord7                                              */
    } biss_rdata7_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata8;                 /*!< (@ 0x000000A0) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA8     : 32;           /*!< [31..0] register data DWord8                                              */
    } biss_rdata8_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata9;                 /*!< (@ 0x000000A4) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA9     : 32;           /*!< [31..0] register data DWord9                                              */
    } biss_rdata9_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata10;                /*!< (@ 0x000000A8) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA10    : 32;           /*!< [31..0] register data DWord10                                             */
    } biss_rdata10_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata11;                /*!< (@ 0x000000AC) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA11    : 32;           /*!< [31..0] register data DWord11                                             */
    } biss_rdata11_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata12;                /*!< (@ 0x000000B0) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA12    : 32;           /*!< [31..0] register data DWord12                                             */
    } biss_rdata12_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata13;                /*!< (@ 0x000000B4) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA13    : 32;           /*!< [31..0] register data DWord13                                             */
    } biss_rdata13_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata14;                /*!< (@ 0x000000B8) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA14    : 32;           /*!< [31..0] register data DWord14                                             */
    } biss_rdata14_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata15;                /*!< (@ 0x000000BC) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA15    : 32;           /*!< [31..0] register data DWord15                                             */
    } biss_rdata15_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc0;                    /*!< (@ 0x000000C0) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN0    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD0     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP0     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY0  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS0   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART0 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc0_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc1;                    /*!< (@ 0x000000C4) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN1    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD1     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP1     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY1  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS1   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART1 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc1_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc2;                    /*!< (@ 0x000000C8) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN2    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD2     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP2     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY2  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS2   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART2 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc2_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc3;                    /*!< (@ 0x000000CC) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN3    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD3     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP3     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY3  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS3   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART3 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc3_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc4;                    /*!< (@ 0x000000D0) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN4    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD4     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP4     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY4  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS4   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART4 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc4_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc5;                    /*!< (@ 0x000000D4) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN5    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD5     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP5     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY5  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS5   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART5 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc5_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc6;                    /*!< (@ 0x000000D8) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN6    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD6     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP6     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY6  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS6   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART6 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc6_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc7;                    /*!< (@ 0x000000DC) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN7    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSC7      : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP7     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY7  : 7;            /*!< [14..8] - SELCRCx == 0 (SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with S                                     */
      __IOM uint32_t SELCRCS7   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART7 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc7_b;
  } ;
  
  union {
    __IOM uint32_t biss_ccc0;                   /*!< (@ 0x000000E0) Register Communication Configuration                       */
    
    struct {
      __IOM uint32_t reserved0  : 16;           /*!< [15..0] reserved                                                          */
      __IOM uint32_t REGADR     : 7;            /*!< [22..16] Register access start address 0x00 .. 0x7f                       */
      __IOM uint32_t WNR        : 1;            /*!< [23..23] Register access read/write selector 0: read register
                                                     data 1: write register data                                               */
      __IOM uint32_t REGNUM     : 6;            /*!< [29..24] Register data count 0x00 : register count = 1 0x01
                                                     ..0x3f: register count = REGNUM(5:0)+1                                    */
      __IOM uint32_t reserved1  : 2;            /*!< [31..30] reserved                                                         */
    } biss_ccc0_b;
  } ;
  
  union {
    __IOM uint32_t biss_ccc1_mc0;               /*!< (@ 0x000000E4) Register Communication Configuration / Master
                                                                    Configuration                                              */
    
    struct {
      __IOM uint32_t CHSEL      : 2;            /*!< [1..0] Channel selector 0: channel 1 used for control communication,
                                                     channel 2 not used 1: channel 1 used for control communication,
                                                     channel 2 not used 2: channel 2 used for control communication,
                                                     channel 1 not used. Note: Channel 2 is not available with
                                                     IC-MB4 TSSOP24 3: channel 1,2 used for control communication.
                                                     Note: Channel 2 is not available with IC-MB4 TSSOP24                      */
      __IOM uint32_t reserved0  : 6;            /*!< [7..2] reserved                                                           */
      __IOM uint32_t HOLDCDM    : 1;            /*!< [8..8] Hold CDM(control data master) 0: clock line high at end
                                                     of cycle 1: clock line constant with CDM bit until start
                                                     of next cycle                                                             */
      __IOM uint32_t EN_MO      : 1;            /*!< [9..9] Enable output at MOx for actuator data or delayed start
                                                     bit 0: MO forced to low 1: Parameterized processing time
                                                     by master on MO signal active (length: MO_BUSY)                           */
      __IOM uint32_t reserved1  : 1;            /*!< [10..10] reserved                                                         */
      __IOM uint32_t IDA_TEST   : 1;            /*!< [11..11] - Using register access in control communication SLAVEID[0]:
                                                     slave selector bit0 - Using command/instructions in control
                                                     communication IDA_TEST: command/instruction execution control
                                                     0: the slaves feedback (IDA) is tested before execution
                                                     (EX bit after IDA) 1: immediate execution                                 */
      __IOM uint32_t CMD        : 2;            /*!< [13..12] - Using register access in control communication SLAVEID[2:1]:
                                                     slave selector bit2_1 - Using command/instructions in control
                                                     communication Command of access slave 0x00 .. 0x03: command/instruction
                                                     0b00 .. 0b11                                                              */
      __IOM uint32_t REGVERS    : 1;            /*!< [14..14] BiSS model A/B or C selector - Using register access
                                                     in control communication 0: register communication BiSS
                                                     A/B 1: register communication BiSS C - Using command/instructions
                                                     in control communication 0: not applicable with command/instruction
                                                     communication 1: command communication BiSS C                             */
      __IOM uint32_t CTS        : 1;            /*!< [15..15] Register transmission or instruction selector 0: command/instruction
                                                     communication 1: register communication                                   */
      __IOM uint32_t FREQS      : 5;            /*!< [20..16] Frequency division 0x00: fCLK/2 0x01: fCLK/4 0x02:
                                                     fCLK/6 0x03: fCLK/8 ... 0x09: fCLK/20 ... 0x0d: fCLK/28
                                                     0x0e: fCLK/30 0x0f: fCLK/32 0x10: not permitted 0x11: fCLK/40
                                                     0x12: fCLK/60 0x13: fCLK/80 ... 0x1d: fCLK/280 0x1e: fCLK/300
                                                     0x1f: fCLK/320                                                            */
      __IOM uint32_t FREQR      : 3;            /*!< [23..21] Frequency division register communication BiSS B 0
                                                     .. 7: freqSens/(2*(FREQ(7:5)+1)) 0: FreqSens/2 1: FreqSens/4
                                                     2: FreqSens/8 3: FreqSens/16 4: FreqSens/32 5: FreqSens/64
                                                     6: FreqSens/128 7: FreqSens/256                                           */
      __IOM uint32_t SINGLEBANK : 1;            /*!< [24..24] Use of only one RAM bank for SCD 0: two RAM banks are
                                                     used for SCD 1: one RAM bank is used for SCD                              */
      __IOM uint32_t NOCRC      : 1;            /*!< [25..25] CRC for SCD not to be stored in RAM 0: CRC of SCD is
                                                     stored RAM (only applicable with active CRC verification
                                                     and CRC polynome &gt; 0) 1: CRC of SCD not to be stored
                                                     in RAM                                                                    */
      __IOM uint32_t reserved2  : 6;            /*!< [31..26] reserved                                                         */
    } biss_ccc1_mc0_b;
  } ;
  
  union {
    __IOM uint32_t biss_mc1;                    /*!< (@ 0x000000E8) Master Configuration                                       */
    
    struct {
      __IOM uint32_t FREQAGS    : 8;            /*!< [7..0] AutoGetSens Frequency division 0x00.. 0x7b: fCLK/(20*(FREQAGS(6:0)+1))
                                                     0x7c : AGSMIN( the master automatically restarts the next
                                                     cycle after the prior was finished. AGSMIN is the fastest
                                                     SCD rate with complete SCD cycles. ) 0x7d.. 0x7f: AGSINFINITE(
                                                     the master does not automatically restart the next cycle
                                                     after the prior one was finished. AGSINFINITE requires
                                                     a trigger event to start the next SCD cycle. ) 0x80.. 0xff:
                                                     fCLK/(625*(FREQAGS(6:0)+1))                                               */
      __IOM uint32_t MO_BUSY    : 8;            /*!< [15..8] Delay of start bit at output MOx 0x00 .. 0xff: count
                                                     of MA clocks as the parameterized processing time by master
                                                     on MO signal Premise: EN_MO = 1                                           */
      __IOM uint32_t REVISION   : 8;            /*!< [23..16] Revision 0x10: Z(first revision) 0x11: Z1 0x12: Y ..
                                                     0xff                                                                      */
      __IOM uint32_t VERSION    : 8;            /*!< [31..24] Device identifier 0x83: iC-MB3 0x84: iC-MB4 .. 0xff              */
    } biss_mc1_b;
  } ;
  
  union {
    __IOM uint32_t biss_cc_sl;                  /*!< (@ 0x000000EC) Channel Configuration                                      */
    
    struct {
      __IOM uint32_t cc_sl_reserved1 : 4;       /*!< [3..0] no field descpription                                              */
      __IOM uint32_t SLAVELOC5  : 1;            /*!< [4..4] Slave location 0: slaves 4-7 are connected to channel
                                                     1 1: slaves 4-7 are connected to channel 2(only available
                                                     with iC-MB4 QFN28)                                                        */
      __IOM uint32_t reserved0  : 3;            /*!< [7..5] reserved                                                           */
      __IOM uint32_t CFGCH1     : 2;            /*!< [9..8] Channel 1 configuration 0x00: BiSS B 0x01: BiSS C 0x02:
                                                     SSI 0x03: channel is not used                                             */
      __IOM uint32_t CFGCH2     : 2;            /*!< [11..10] Channel 2 configuration 0x00: BiSS B 0x01: BiSS C 0x02:
                                                     SSI 0x03: channel is not used                                             */
      __IOM uint32_t reserved1  : 12;           /*!< [23..12] reserved                                                         */
      __IOM uint32_t ACTnSENS   : 8;            /*!< [31..24] Sensor or actuator data selector 0x00: all slaves are
                                                     sensors 0x01: slave 0 is actuator 0x02: slave 1 is actuator
                                                     0x04: slave 2 is actuator 0x08: slave 3 is actuator 0x10:
                                                     slave 4 is actuator 0x20: slave 5 is actuator 0x40: slave
                                                     6 is actuator 0x80: slave 7 is actuator 0xff: all slaves
                                                     are actuators                                                             */
    } biss_cc_sl_b;
  } ;
  
  union {
    __IM  uint32_t biss_status0;                /*!< (@ 0x000000F0) Status Information                                         */
    
    struct {
      __IM  uint32_t EOT        : 1;            /*!< [0..0] Data transmission completed 0: data transmission active
                                                     1: data transmission finished                                             */
      __IM  uint32_t status0_reserved1 : 1;     /*!< [1..1] reserved                                                           */
      __IM  uint32_t REGEND     : 1;            /*!< [2..2] Register data transmission completed 0: no valid register
                                                     data available 1: register data transmission completed                    */
      __IM  uint32_t nREGERR    : 1;            /*!< [3..3] Error in register data transmission 0: error in last
                                                     register data transmission 1: no error in last register
                                                     data transmission                                                         */
      __IM  uint32_t nSCDERR    : 1;            /*!< [4..4] Error in single cycle data transmission 0: error in last
                                                     single cycle data transmission 1: no error in last single
                                                     cycle data transmission                                                   */
      __IM  uint32_t nDELAYERR  : 1;            /*!< [5..5] Missing start bit during register communication 0: delay
                                                     error 1: no delay error                                                   */
      __IM  uint32_t nAGSERR    : 1;            /*!< [6..6] AGS error 0: AGS(Automatic Get Sensor data) watchdog
                                                     error 1: no AGS watchdog error An AGS watchdog error is
                                                     set during the automatic transmission of sensor data if
                                                     no new cycle could be initiated; bit AGS in the command
                                                     register is reset and the automatic request of sensor data
                                                     aborted.                                                                  */
      __IM  uint32_t nERR       : 1;            /*!< [7..7] Transmission error (error at NER pin) 0: error 1: no
                                                     error It is possible to connect other components to pin
                                                     NER which can also generate an error message; this can
                                                     then be read out via this bit.                                            */
      __IM  uint32_t reserved0  : 1;            /*!< [8..8] reserved                                                           */
      __IM  uint32_t SVALID0    : 1;            /*!< [9..9] SCDATA0 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved1  : 1;            /*!< [10..10] reserved                                                         */
      __IM  uint32_t SVALID1    : 1;            /*!< [11..11] SCDATA1 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved2  : 1;            /*!< [12..12] reserved                                                         */
      __IM  uint32_t SVALID2    : 1;            /*!< [13..13] SCDATA2 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved3  : 1;            /*!< [14..14] reserved                                                         */
      __IM  uint32_t SVALID3    : 1;            /*!< [15..15] SCDATA3 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved4  : 1;            /*!< [16..16] reserved                                                         */
      __IM  uint32_t SVALID4    : 1;            /*!< [17..17] SCDATA4 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved5  : 1;            /*!< [18..18] reserved                                                         */
      __IM  uint32_t SVALID5    : 1;            /*!< [19..19] SCDATA5 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved6  : 1;            /*!< [20..20] reserved                                                         */
      __IM  uint32_t SVALID6    : 1;            /*!< [21..21] SCDATA6 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved7  : 1;            /*!< [22..22] reserved                                                         */
      __IM  uint32_t SVALID7    : 1;            /*!< [23..23] SCDATA7 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t REGBYTES   : 6;            /*!< [29..24] Number of valid register data transmission in case
                                                     of error 0x00 : after transfer: no register communication
                                                     error 0x01 . 0x3f: after transfer: number of successfully
                                                     transferred registers before register communication error                 */
      __IM  uint32_t CDSSEL     : 1;            /*!< [30..30] CDS(Control Data Slave) bit from the selected channel            */
      __IM  uint32_t CDMTIMEOUT : 1;            /*!< [31..31] CDM(Control Data Master) timeout reached 0: CDMTIMEOUT
                                                     not reached 1: CDMTIMEOUT reached                                         */
    } biss_status0_b;
  } ;
  
  union {
    __IOM uint32_t biss_ir;                     /*!< (@ 0x000000F4) Instruction Register                                       */
    
    struct {
      __IOM uint32_t AGS        : 1;            /*!< [0..0] AutoGetSens(Automatic Get Sensordata) 0: no automatic
                                                     data transmission 1: - start of data transmission after
                                                     TIMEOUTSENS condition: FREQAGS = AGSMIN - start of data
                                                     transmission triggered by pin condition: FREQAGS = AGSINFINITE
                                                     - start of data transmission after timeout With AGS = 0
                                                     the master starts the data transmission after finishing
                                                     writing the instruction register(rising edge of NWR). A
                                                     nAGSERR error will be generated if the SL line is low,
                                                     TIMEOUTSENS has not exceeded. If an AGS bit has been set
                                                     se                                                                        */
      __IOM uint32_t INSTR      : 3;            /*!< [3..1] SCD control instruction 0b010 : CDM = 0 0b001 : CDM =
                                                     1 0b100, 0b110: register communication condition: CDMTIMEOUT
                                                     = 1 0b111 : register communication(reduced protocol) condition:
                                                     CDMTIMEOUT = 1 The transmission of sensor data can be triggered
                                                     via INSTR. With INSTR=0b010 the ccle finishes with a CDM=0.
                                                     With INSTR= 0b001 the cycle finishes with a CDM=1. A BiSS
                                                     C register access to a slave can be operated by INSTR=0b100.
                                                     A reduced protocol for a shorter BiSS C register access
                                                     to a slave can                                                            */
      __IOM uint32_t INIT       : 1;            /*!< [4..4] Start INIT sequence 0: no changes on the data channel
                                                     1: initialize data channel                                                */
      __IOM uint32_t SWBANK     : 1;            /*!< [5..5] Switch RAM banks 0: RAM banks are not switched 1: RAM
                                                     banks are switched                                                        */
      __IOM uint32_t HOLDBANK   : 1;            /*!< [6..6] RAM bank control 0: no bank switching lock permitted
                                                     1: bank switching lock permitted During the readout of
                                                     more than one sensor data register by the controller it
                                                     is possible that the RAM banks in the master could be swapped
                                                     over once a sensor data transmission is completed. So that
                                                     the controller only reads related values bit HOLDBANK should
                                                     be set at the start of the readout and reset at the end;
                                                     this suppresses the RAM swap. With the start of a new sensor
                                                     data cycle previous values are then overwritten                           */
      __IOM uint32_t BREAK      : 1;            /*!< [7..7] Data transmission interrupt 0: no change 1: abort data
                                                     transmission nSCDERR, nREGERR, nDELAYERR, nAGSERR = 1,
                                                     REGEND = 0 All current actions can be aborted using the
                                                     BREAK command so that a defined state can be resumed if
                                                     one of the sensors proves faulty, for example. BREAK= 1
                                                     aborts the active data transmission and all status information
                                                     will be reset.                                                            */
      __IOM uint32_t CLKENI     : 1;            /*!< [8..8] Enable internal clock 0: the master clock is generated
                                                     by an external clock oscillator 1: the master clock is
                                                     generated by the basic clock of the internal 20MHz oscillator             */
      __IOM uint32_t ENTEST     : 1;            /*!< [9..9] Enable test interface 0: device in normal operation mode
                                                     1: device in test mode                                                    */
      __IOM uint32_t CFGIF      : 2;            /*!< [11..10] Configure physical interface 0x00: TTL 0x01: CMOS 0x02:
                                                     RS422 0x03: LVDS                                                          */
      __IOM uint32_t MAFS       : 1;            /*!< [12..12] Selected MA line control selection 0: controlling selected/CHSEL)
                                                     MA clock line: using MA signal 1: controlling selected(CHSEL)
                                                     MA clock line: using MAVS level                                           */
      __IOM uint32_t MAVS       : 1;            /*!< [13..13] Selected MA line control level 0: low definition of
                                                     selected(CHSEL) MA clock lines 1: high definition of selected(CHSEL)
                                                     MA clock lines                                                            */
      __IOM uint32_t MAFO       : 1;            /*!< [14..14] Not selected MA line control selection 0: controlling
                                                     unselected(CHSEL) MA clock line: using MA signal 1: controlling
                                                     unselected(CHSEL) MA clock line: using MAVS level                         */
      __IOM uint32_t MAVO       : 1;            /*!< [15..15] Not selected MA line control level 0: low definition
                                                     of unselected(CHSEL) MA clock lines 1: high definition
                                                     of unselected(CHSEL) MA clock lines                                       */
    } biss_ir_b;
  } ;
  
  union {
    __IM  uint32_t biss_status1;                /*!< (@ 0x000000F8) Status Information                                         */
    
    struct {
      __IM  uint32_t SL1        : 1;            /*!< [0..0] Current SL line level of channel 1 0: SL line level low
                                                     1: SL line level high                                                     */
      __IM  uint32_t CDS1       : 1;            /*!< [1..1] CDS bit of channel 1 0: CDS = 0 1: CDS = 1                         */
      __IM  uint32_t reserved0  : 22;           /*!< [23..2] reserved                                                          */
      __IM  uint32_t SWBANKFAILS : 1;           /*!< [24..24] Bank switching status 0: bank switching(SCD) successful
                                                     1: bank switching(SCD) not successful                                     */
      __IM  uint32_t reserved1  : 7;            /*!< [31..25] reserved                                                         */
    } biss_status1_b;
  } ;
} biss0_app_Type;                               /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                         biss1_app                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief biss1_app (biss1_app)
  */

typedef struct {                                /*!< (@ 0xFF801C00) biss1_app Structure                                        */
  
  union {
    __IOM uint32_t biss_scdata0_0;              /*!< (@ 0x00000000) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA0_0  : 32;           /*!< [31..0] Slave0 (SCD)single cycle data[31:0]                               */
    } biss_scdata0_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata0_1;              /*!< (@ 0x00000004) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA0_1  : 32;           /*!< [31..0] Slave0 (SCD)single cycle data[63:32]                              */
    } biss_scdata0_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata1_0;              /*!< (@ 0x00000008) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA1_0  : 32;           /*!< [31..0] Slave1 (SCD)single cycle data[31:0]                               */
    } biss_scdata1_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata1_1;              /*!< (@ 0x0000000C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA1_1  : 32;           /*!< [31..0] Slave1 (SCD)single cycle data[63:32]                              */
    } biss_scdata1_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata2_0;              /*!< (@ 0x00000010) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA2_0  : 32;           /*!< [31..0] Slave2 (SCD)single cycle data[31:0]                               */
    } biss_scdata2_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata2_1;              /*!< (@ 0x00000014) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA2_1  : 32;           /*!< [31..0] Slave2 (SCD)single cycle data[63:32]                              */
    } biss_scdata2_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata3_0;              /*!< (@ 0x00000018) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA3_0  : 32;           /*!< [31..0] Slave3 (SCD)single cycle data[31:0]                               */
    } biss_scdata3_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata3_1;              /*!< (@ 0x0000001C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA3_1  : 32;           /*!< [31..0] Slave3 (SCD)single cycle data[63:32]                              */
    } biss_scdata3_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata4_0;              /*!< (@ 0x00000020) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA4_0  : 32;           /*!< [31..0] Slave4 (SCD)single cycle data[31:0]                               */
    } biss_scdata4_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata4_1;              /*!< (@ 0x00000024) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA4_1  : 32;           /*!< [31..0] Slave4 (SCD)single cycle data[63:32]                              */
    } biss_scdata4_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata5_0;              /*!< (@ 0x00000028) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA5_0  : 32;           /*!< [31..0] Slave5 (SCD)single cycle data[31:0]                               */
    } biss_scdata5_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata5_1;              /*!< (@ 0x0000002C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA5_1  : 32;           /*!< [31..0] Slave5 (SCD)single cycle data[63:32]                              */
    } biss_scdata5_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata6_0;              /*!< (@ 0x00000030) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA6_0  : 32;           /*!< [31..0] Slave6 (SCD)single cycle data[31:0]                               */
    } biss_scdata6_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata6_1;              /*!< (@ 0x00000034) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA6_1  : 32;           /*!< [31..0] Slave6 (SCD)single cycle data[63:32]                              */
    } biss_scdata6_1_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata7_0;              /*!< (@ 0x00000038) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA7_0  : 32;           /*!< [31..0] Slave0 (SCD)single cycle data[31:0]                               */
    } biss_scdata7_0_b;
  } ;
  
  union {
    __IOM uint32_t biss_scdata7_1;              /*!< (@ 0x0000003C) Sensor and Actuator Data                                   */
    
    struct {
      __IOM uint32_t SCDATA7_1  : 32;           /*!< [31..0] Slave7 (SCD)single cycle data[63:32]                              */
    } biss_scdata7_1_b;
  } ;
  __IM  uint32_t  RESERVED[16];
  
  union {
    __IOM uint32_t biss_rdata0;                 /*!< (@ 0x00000080) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA0     : 32;           /*!< [31..0] - Using register access in control communication RDATA0:
                                                     register data DWord0 - Using command/instructions in control
                                                     communication IDS: ID-Select, command/instruction addressing
                                                     combinable                                                                */
    } biss_rdata0_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata1;                 /*!< (@ 0x00000084) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA1     : 32;           /*!< [31..0] register data DWord1                                              */
    } biss_rdata1_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata2;                 /*!< (@ 0x00000088) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA2     : 32;           /*!< [31..0] register data DWord2                                              */
    } biss_rdata2_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata3;                 /*!< (@ 0x0000008C) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA3     : 32;           /*!< [31..0] register data DWord3                                              */
    } biss_rdata3_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata4;                 /*!< (@ 0x00000090) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA4     : 32;           /*!< [31..0] register data DWord4                                              */
    } biss_rdata4_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata5;                 /*!< (@ 0x00000094) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA5     : 32;           /*!< [31..0] register data DWord5                                              */
    } biss_rdata5_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata6;                 /*!< (@ 0x00000098) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA6     : 32;           /*!< [31..0] register data DWord6                                              */
    } biss_rdata6_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata7;                 /*!< (@ 0x0000009C) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA7     : 32;           /*!< [31..0] register data DWord7                                              */
    } biss_rdata7_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata8;                 /*!< (@ 0x000000A0) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA8     : 32;           /*!< [31..0] register data DWord8                                              */
    } biss_rdata8_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata9;                 /*!< (@ 0x000000A4) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA9     : 32;           /*!< [31..0] register data DWord9                                              */
    } biss_rdata9_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata10;                /*!< (@ 0x000000A8) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA10    : 32;           /*!< [31..0] register data DWord10                                             */
    } biss_rdata10_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata11;                /*!< (@ 0x000000AC) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA11    : 32;           /*!< [31..0] register data DWord11                                             */
    } biss_rdata11_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata12;                /*!< (@ 0x000000B0) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA12    : 32;           /*!< [31..0] register data DWord12                                             */
    } biss_rdata12_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata13;                /*!< (@ 0x000000B4) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA13    : 32;           /*!< [31..0] register data DWord13                                             */
    } biss_rdata13_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata14;                /*!< (@ 0x000000B8) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA14    : 32;           /*!< [31..0] register data DWord14                                             */
    } biss_rdata14_b;
  } ;
  
  union {
    __IOM uint32_t biss_rdata15;                /*!< (@ 0x000000BC) Register Data                                              */
    
    struct {
      __IOM uint32_t RDATA15    : 32;           /*!< [31..0] register data DWord15                                             */
    } biss_rdata15_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc0;                    /*!< (@ 0x000000C0) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN0    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD0     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP0     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY0  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS0   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART0 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc0_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc1;                    /*!< (@ 0x000000C4) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN1    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD1     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP1     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY1  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS1   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART1 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc1_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc2;                    /*!< (@ 0x000000C8) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN2    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD2     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP2     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY2  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS2   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART2 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc2_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc3;                    /*!< (@ 0x000000CC) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN3    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD3     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP3     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY3  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS3   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART3 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc3_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc4;                    /*!< (@ 0x000000D0) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN4    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD4     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP4     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY4  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS4   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART4 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc4_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc5;                    /*!< (@ 0x000000D4) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN5    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD5     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP5     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY5  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS5   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART5 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc5_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc6;                    /*!< (@ 0x000000D8) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN6    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSCD6     : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP6     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY6  : 7;            /*!< [14..8] - SELCRCx == 0 ( SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with                                       */
      __IOM uint32_t SELCRCS6   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART6 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc6_b;
  } ;
  
  union {
    __IOM uint32_t biss_sc7;                    /*!< (@ 0x000000DC) Slave Configuration                                        */
    
    struct {
      __IOM uint32_t SCDLEN7    : 6;            /*!< [5..0] Single cycle data length 0 : single cycle data length
                                                     = 1 1 : single cycle data length = 2 ... single cycle data
                                                     length = SCDLENx + 1 62: single cycle data length = 63
                                                     63: single cycle data length = 64                                         */
      __IOM uint32_t ENSC7      : 1;            /*!< [6..6] Enable single cycle data 0: single cycle data not available
                                                     1: single cycle data available                                            */
      __IOM uint32_t LSTOP7     : 1;            /*!< [7..7] - BISS mode(LSTOPx = Actuator stop bit control) 0: no
                                                     leading STOP bit on single cycle actuator data 1: leading
                                                     STOP bit on single cycle actuator data - SSI mode(GRAYSx
                                                     = Enable SCD gray to binary conversion) 0: SSI single cycle
                                                     data binary coded 1: SSI single cycle data gray coded                     */
      __IOM uint32_t SCRCPOLY7  : 7;            /*!< [14..8] - SELCRCx == 0 (SCRCLENx: polynomial selection by length
                                                     for SCD CRC check) 0: CRC for single cycle data not present,
                                                     CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial
                                                     = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25
                                                     6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC
                                                     polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other
                                                     CRC length are not permitted with SELCRCSx = 0 - SELCRCx
                                                     == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00 : CRC
                                                     polynomial 0x00 not applicable with S                                     */
      __IOM uint32_t SELCRCS7   : 1;            /*!< [15..15] Selection between polynomial or length for SCD CRC
                                                     polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx)
                                                     apply dedicated CRC polynomials 1: CRC polynomial(7:1)
                                                     in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial
                                                     SCRCPOLYx(7:0) = 0x00                                                     */
      __IOM uint32_t SCRCSTART7 : 16;           /*!< [31..16] Start value for polynomial SCD CRC calculation                   */
    } biss_sc7_b;
  } ;
  
  union {
    __IOM uint32_t biss_ccc0;                   /*!< (@ 0x000000E0) Register Communication Configuration                       */
    
    struct {
      __IOM uint32_t reserved0  : 16;           /*!< [15..0] reserved                                                          */
      __IOM uint32_t REGADR     : 7;            /*!< [22..16] Register access start address 0x00 .. 0x7f                       */
      __IOM uint32_t WNR        : 1;            /*!< [23..23] Register access read/write selector 0: read register
                                                     data 1: write register data                                               */
      __IOM uint32_t REGNUM     : 6;            /*!< [29..24] Register data count 0x00 : register count = 1 0x01
                                                     ..0x3f: register count = REGNUM(5:0)+1                                    */
      __IOM uint32_t reserved1  : 2;            /*!< [31..30] reserved                                                         */
    } biss_ccc0_b;
  } ;
  
  union {
    __IOM uint32_t biss_ccc1_mc0;               /*!< (@ 0x000000E4) Register Communication Configuration / Master
                                                                    Configuration                                              */
    
    struct {
      __IOM uint32_t CHSEL      : 2;            /*!< [1..0] Channel selector 0: channel 1 used for control communication,
                                                     channel 2 not used 1: channel 1 used for control communication,
                                                     channel 2 not used 2: channel 2 used for control communication,
                                                     channel 1 not used. Note: Channel 2 is not available with
                                                     IC-MB4 TSSOP24 3: channel 1,2 used for control communication.
                                                     Note: Channel 2 is not available with IC-MB4 TSSOP24                      */
      __IOM uint32_t reserved0  : 6;            /*!< [7..2] reserved                                                           */
      __IOM uint32_t HOLDCDM    : 1;            /*!< [8..8] Hold CDM(control data master) 0: clock line high at end
                                                     of cycle 1: clock line constant with CDM bit until start
                                                     of next cycle                                                             */
      __IOM uint32_t EN_MO      : 1;            /*!< [9..9] Enable output at MOx for actuator data or delayed start
                                                     bit 0: MO forced to low 1: Parameterized processing time
                                                     by master on MO signal active (length: MO_BUSY)                           */
      __IOM uint32_t reserved1  : 1;            /*!< [10..10] reserved                                                         */
      __IOM uint32_t IDA_TEST   : 1;            /*!< [11..11] - Using register access in control communication SLAVEID[0]:
                                                     slave selector bit0 - Using command/instructions in control
                                                     communication IDA_TEST: command/instruction execution control
                                                     0: the slaves feedback (IDA) is tested before execution
                                                     (EX bit after IDA) 1: immediate execution                                 */
      __IOM uint32_t CMD        : 2;            /*!< [13..12] - Using register access in control communication SLAVEID[2:1]:
                                                     slave selector bit2_1 - Using command/instructions in control
                                                     communication Command of access slave 0x00 .. 0x03: command/instruction
                                                     0b00 .. 0b11                                                              */
      __IOM uint32_t REGVERS    : 1;            /*!< [14..14] BiSS model A/B or C selector - Using register access
                                                     in control communication 0: register communication BiSS
                                                     A/B 1: register communication BiSS C - Using command/instructions
                                                     in control communication 0: not applicable with command/instruction
                                                     communication 1: command communication BiSS C                             */
      __IOM uint32_t CTS        : 1;            /*!< [15..15] Register transmission or instruction selector 0: command/instruction
                                                     communication 1: register communication                                   */
      __IOM uint32_t FREQS      : 5;            /*!< [20..16] Frequency division 0x00: fCLK/2 0x01: fCLK/4 0x02:
                                                     fCLK/6 0x03: fCLK/8 ... 0x09: fCLK/20 ... 0x0d: fCLK/28
                                                     0x0e: fCLK/30 0x0f: fCLK/32 0x10: not permitted 0x11: fCLK/40
                                                     0x12: fCLK/60 0x13: fCLK/80 ... 0x1d: fCLK/280 0x1e: fCLK/300
                                                     0x1f: fCLK/320                                                            */
      __IOM uint32_t FREQR      : 3;            /*!< [23..21] Frequency division register communication BiSS B 0
                                                     .. 7: freqSens/(2*(FREQ(7:5)+1)) 0: FreqSens/2 1: FreqSens/4
                                                     2: FreqSens/8 3: FreqSens/16 4: FreqSens/32 5: FreqSens/64
                                                     6: FreqSens/128 7: FreqSens/256                                           */
      __IOM uint32_t SINGLEBANK : 1;            /*!< [24..24] Use of only one RAM bank for SCD 0: two RAM banks are
                                                     used for SCD 1: one RAM bank is used for SCD                              */
      __IOM uint32_t NOCRC      : 1;            /*!< [25..25] CRC for SCD not to be stored in RAM 0: CRC of SCD is
                                                     stored RAM (only applicable with active CRC verification
                                                     and CRC polynome &gt; 0) 1: CRC of SCD not to be stored
                                                     in RAM                                                                    */
      __IOM uint32_t reserved2  : 6;            /*!< [31..26] reserved                                                         */
    } biss_ccc1_mc0_b;
  } ;
  
  union {
    __IOM uint32_t biss_mc1;                    /*!< (@ 0x000000E8) Master Configuration                                       */
    
    struct {
      __IOM uint32_t FREQAGS    : 8;            /*!< [7..0] AutoGetSens Frequency division 0x00.. 0x7b: fCLK/(20*(FREQAGS(6:0)+1))
                                                     0x7c : AGSMIN( the master automatically restarts the next
                                                     cycle after the prior was finished. AGSMIN is the fastest
                                                     SCD rate with complete SCD cycles. ) 0x7d.. 0x7f: AGSINFINITE(
                                                     the master does not automatically restart the next cycle
                                                     after the prior one was finished. AGSINFINITE requires
                                                     a trigger event to start the next SCD cycle. ) 0x80.. 0xff:
                                                     fCLK/(625*(FREQAGS(6:0)+1))                                               */
      __IOM uint32_t MO_BUSY    : 8;            /*!< [15..8] Delay of start bit at output MOx 0x00 .. 0xff: count
                                                     of MA clocks as the parameterized processing time by master
                                                     on MO signal Premise: EN_MO = 1                                           */
      __IOM uint32_t REVISION   : 8;            /*!< [23..16] Revision 0x10: Z(first revision) 0x11: Z1 0x12: Y ..
                                                     0xff                                                                      */
      __IOM uint32_t VERSION    : 8;            /*!< [31..24] Device identifier 0x83: iC-MB3 0x84: iC-MB4 .. 0xff              */
    } biss_mc1_b;
  } ;
  
  union {
    __IOM uint32_t biss_cc_sl;                  /*!< (@ 0x000000EC) Channel Configuration                                      */
    
    struct {
      __IOM uint32_t cc_sl_reserved1 : 4;       /*!< [3..0] no field descpription                                              */
      __IOM uint32_t SLAVELOC5  : 1;            /*!< [4..4] Slave location 0: slaves 4-7 are connected to channel
                                                     1 1: slaves 4-7 are connected to channel 2(only available
                                                     with iC-MB4 QFN28)                                                        */
      __IOM uint32_t reserved0  : 3;            /*!< [7..5] reserved                                                           */
      __IOM uint32_t CFGCH1     : 2;            /*!< [9..8] Channel 1 configuration 0x00: BiSS B 0x01: BiSS C 0x02:
                                                     SSI 0x03: channel is not used                                             */
      __IOM uint32_t CFGCH2     : 2;            /*!< [11..10] Channel 2 configuration 0x00: BiSS B 0x01: BiSS C 0x02:
                                                     SSI 0x03: channel is not used                                             */
      __IOM uint32_t reserved1  : 12;           /*!< [23..12] reserved                                                         */
      __IOM uint32_t ACTnSENS   : 8;            /*!< [31..24] Sensor or actuator data selector 0x00: all slaves are
                                                     sensors 0x01: slave 0 is actuator 0x02: slave 1 is actuator
                                                     0x04: slave 2 is actuator 0x08: slave 3 is actuator 0x10:
                                                     slave 4 is actuator 0x20: slave 5 is actuator 0x40: slave
                                                     6 is actuator 0x80: slave 7 is actuator 0xff: all slaves
                                                     are actuators                                                             */
    } biss_cc_sl_b;
  } ;
  
  union {
    __IM  uint32_t biss_status0;                /*!< (@ 0x000000F0) Status Information                                         */
    
    struct {
      __IM  uint32_t EOT        : 1;            /*!< [0..0] Data transmission completed 0: data transmission active
                                                     1: data transmission finished                                             */
      __IM  uint32_t status0_reserved1 : 1;     /*!< [1..1] reserved                                                           */
      __IM  uint32_t REGEND     : 1;            /*!< [2..2] Register data transmission completed 0: no valid register
                                                     data available 1: register data transmission completed                    */
      __IM  uint32_t nREGERR    : 1;            /*!< [3..3] Error in register data transmission 0: error in last
                                                     register data transmission 1: no error in last register
                                                     data transmission                                                         */
      __IM  uint32_t nSCDERR    : 1;            /*!< [4..4] Error in single cycle data transmission 0: error in last
                                                     single cycle data transmission 1: no error in last single
                                                     cycle data transmission                                                   */
      __IM  uint32_t nDELAYERR  : 1;            /*!< [5..5] Missing start bit during register communication 0: delay
                                                     error 1: no delay error                                                   */
      __IM  uint32_t nAGSERR    : 1;            /*!< [6..6] AGS error 0: AGS(Automatic Get Sensor data) watchdog
                                                     error 1: no AGS watchdog error An AGS watchdog error is
                                                     set during the automatic transmission of sensor data if
                                                     no new cycle could be initiated; bit AGS in the command
                                                     register is reset and the automatic request of sensor data
                                                     aborted.                                                                  */
      __IM  uint32_t nERR       : 1;            /*!< [7..7] Transmission error (error at NER pin) 0: error 1: no
                                                     error It is possible to connect other components to pin
                                                     NER which can also generate an error message; this can
                                                     then be read out via this bit.                                            */
      __IM  uint32_t reserved0  : 1;            /*!< [8..8] reserved                                                           */
      __IM  uint32_t SVALID0    : 1;            /*!< [9..9] SCDATA0 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved1  : 1;            /*!< [10..10] reserved                                                         */
      __IM  uint32_t SVALID1    : 1;            /*!< [11..11] SCDATA1 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved2  : 1;            /*!< [12..12] reserved                                                         */
      __IM  uint32_t SVALID2    : 1;            /*!< [13..13] SCDATA2 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved3  : 1;            /*!< [14..14] reserved                                                         */
      __IM  uint32_t SVALID3    : 1;            /*!< [15..15] SCDATA3 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved4  : 1;            /*!< [16..16] reserved                                                         */
      __IM  uint32_t SVALID4    : 1;            /*!< [17..17] SCDATA4 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved5  : 1;            /*!< [18..18] reserved                                                         */
      __IM  uint32_t SVALID5    : 1;            /*!< [19..19] SCDATA5 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved6  : 1;            /*!< [20..20] reserved                                                         */
      __IM  uint32_t SVALID6    : 1;            /*!< [21..21] SCDATA6 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t reserved7  : 1;            /*!< [22..22] reserved                                                         */
      __IM  uint32_t SVALID7    : 1;            /*!< [23..23] SCDATA7 validity indication 0: SCD invalid 1: SCD valid
                                                     The SVALIDx bit indicates the validity of each slaves SCD
                                                     CRC verification. A prior set SVALIDx bit can be reset
                                                     by writing 0 into the register.                                           */
      __IM  uint32_t REGBYTES   : 6;            /*!< [29..24] Number of valid register data transmission in case
                                                     of error 0x00 : after transfer: no register communication
                                                     error 0x01 . 0x3f: after transfer: number of successfully
                                                     transferred registers before register communication error                 */
      __IM  uint32_t CDSSEL     : 1;            /*!< [30..30] CDS(Control Data Slave) bit from the selected channel            */
      __IM  uint32_t CDMTIMEOUT : 1;            /*!< [31..31] CDM(Control Data Master) timeout reached 0: CDMTIMEOUT
                                                     not reached 1: CDMTIMEOUT reached                                         */
    } biss_status0_b;
  } ;
  
  union {
    __IOM uint32_t biss_ir;                     /*!< (@ 0x000000F4) Instruction Register                                       */
    
    struct {
      __IOM uint32_t AGS        : 1;            /*!< [0..0] AutoGetSens(Automatic Get Sensordata) 0: no automatic
                                                     data transmission 1: - start of data transmission after
                                                     TIMEOUTSENS condition: FREQAGS = AGSMIN - start of data
                                                     transmission triggered by pin condition: FREQAGS = AGSINFINITE
                                                     - start of data transmission after timeout With AGS = 0
                                                     the master starts the data transmission after finishing
                                                     writing the instruction register(rising edge of NWR). A
                                                     nAGSERR error will be generated if the SL line is low,
                                                     TIMEOUTSENS has not exceeded. If an AGS bit has been set
                                                     se                                                                        */
      __IOM uint32_t INSTR      : 3;            /*!< [3..1] SCD control instruction 0b010 : CDM = 0 0b001 : CDM =
                                                     1 0b100, 0b110: register communication condition: CDMTIMEOUT
                                                     = 1 0b111 : register communication(reduced protocol) condition:
                                                     CDMTIMEOUT = 1 The transmission of sensor data can be triggered
                                                     via INSTR. With INSTR=0b010 the ccle finishes with a CDM=0.
                                                     With INSTR= 0b001 the cycle finishes with a CDM=1. A BiSS
                                                     C register access to a slave can be operated by INSTR=0b100.
                                                     A reduced protocol for a shorter BiSS C register access
                                                     to a slave can                                                            */
      __IOM uint32_t INIT       : 1;            /*!< [4..4] Start INIT sequence 0: no changes on the data channel
                                                     1: initialize data channel                                                */
      __IOM uint32_t SWBANK     : 1;            /*!< [5..5] Switch RAM banks 0: RAM banks are not switched 1: RAM
                                                     banks are switched                                                        */
      __IOM uint32_t HOLDBANK   : 1;            /*!< [6..6] RAM bank control 0: no bank switching lock permitted
                                                     1: bank switching lock permitted During the readout of
                                                     more than one sensor data register by the controller it
                                                     is possible that the RAM banks in the master could be swapped
                                                     over once a sensor data transmission is completed. So that
                                                     the controller only reads related values bit HOLDBANK should
                                                     be set at the start of the readout and reset at the end;
                                                     this suppresses the RAM swap. With the start of a new sensor
                                                     data cycle previous values are then overwritten                           */
      __IOM uint32_t BREAK      : 1;            /*!< [7..7] Data transmission interrupt 0: no change 1: abort data
                                                     transmission nSCDERR, nREGERR, nDELAYERR, nAGSERR = 1,
                                                     REGEND = 0 All current actions can be aborted using the
                                                     BREAK command so that a defined state can be resumed if
                                                     one of the sensors proves faulty, for example. BREAK= 1
                                                     aborts the active data transmission and all status information
                                                     will be reset.                                                            */
      __IOM uint32_t CLKENI     : 1;            /*!< [8..8] Enable internal clock 0: the master clock is generated
                                                     by an external clock oscillator 1: the master clock is
                                                     generated by the basic clock of the internal 20MHz oscillator             */
      __IOM uint32_t ENTEST     : 1;            /*!< [9..9] Enable test interface 0: device in normal operation mode
                                                     1: device in test mode                                                    */
      __IOM uint32_t CFGIF      : 2;            /*!< [11..10] Configure physical interface 0x00: TTL 0x01: CMOS 0x02:
                                                     RS422 0x03: LVDS                                                          */
      __IOM uint32_t MAFS       : 1;            /*!< [12..12] Selected MA line control selection 0: controlling selected/CHSEL)
                                                     MA clock line: using MA signal 1: controlling selected(CHSEL)
                                                     MA clock line: using MAVS level                                           */
      __IOM uint32_t MAVS       : 1;            /*!< [13..13] Selected MA line control level 0: low definition of
                                                     selected(CHSEL) MA clock lines 1: high definition of selected(CHSEL)
                                                     MA clock lines                                                            */
      __IOM uint32_t MAFO       : 1;            /*!< [14..14] Not selected MA line control selection 0: controlling
                                                     unselected(CHSEL) MA clock line: using MA signal 1: controlling
                                                     unselected(CHSEL) MA clock line: using MAVS level                         */
      __IOM uint32_t MAVO       : 1;            /*!< [15..15] Not selected MA line control level 0: low definition
                                                     of unselected(CHSEL) MA clock lines 1: high definition
                                                     of unselected(CHSEL) MA clock lines                                       */
    } biss_ir_b;
  } ;
  
  union {
    __IM  uint32_t biss_status1;                /*!< (@ 0x000000F8) Status Information                                         */
    
    struct {
      __IM  uint32_t SL1        : 1;            /*!< [0..0] Current SL line level of channel 1 0: SL line level low
                                                     1: SL line level high                                                     */
      __IM  uint32_t CDS1       : 1;            /*!< [1..1] CDS bit of channel 1 0: CDS = 0 1: CDS = 1                         */
      __IM  uint32_t reserved0  : 22;           /*!< [23..2] reserved                                                          */
      __IM  uint32_t SWBANKFAILS : 1;           /*!< [24..24] Bank switching status 0: bank switching(SCD) successful
                                                     1: bank switching(SCD) not successful                                     */
      __IM  uint32_t reserved1  : 7;            /*!< [31..25] reserved                                                         */
    } biss_status1_b;
  } ;
} biss1_app_Type;                               /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                      biss_ctrl0_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief biss_ctrl0_app (biss_ctrl0_app)
  */

typedef struct {                                /*!< (@ 0xFF801D00) biss_ctrl0_app Structure                                   */
  
  union {
    __IOM uint32_t biss_ctrl_trigger_cfg;       /*!< (@ 0x00000000) BiSS trigger configuration                                 */
    
    struct {
      __IOM uint32_t sel        : 4;            /*!< [3..0] Trigger source select This bit field configures which
                                                     event is connected to the GETSENS signal of the BiSS core.
                                                     A rising edge of the selected event will generate an event
                                                     to the core. { | Value trigger event 0 none 1 manual 2
                                                     xc_trigger_out0 3 xc_trigger_out0 (inverted) 4 xc_trigger_out1
                                                     5 xc_trigger_out1 (inverted) 6 xc_sample_in0 7 xc_sample_in0
                                                     (inverted) 8 xc_sample_in1 9 xc_sample_in1 (inverted) 10
                                                     gpio_app_counter_zero0 11                                                 */
    } biss_ctrl_trigger_cfg_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_trigger;           /*!< (@ 0x00000004) BiSS trigger                                               */
    
    struct {
      __IOM uint32_t manual     : 1;            /*!< [0..0] Manual trigger. Writing '1' to this bit will trigger
                                                     the BiSS core immediately in case the trigger_cfg.sel bit
                                                     field is set to manual mode and the BiSS core is setup
                                                     for external triggering by the GETSENS signal.                            */
    } biss_ctrl_trigger_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_irq_raw;           /*!< (@ 0x00000008) BiSS raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit.                                                       */
    
    struct {
      __IOM uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core. Only a
                                                     rising edge on the EOT signal will set the interrupt.                     */
      __IOM uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core. Only a falling edge
                                                     on the NER signal will set the interrupt.                                 */
    } biss_ctrl_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t biss_ctrl_irq_masked;        /*!< (@ 0x0000000C) BiSS masked IRQ: Shows status of masked IRQs.              */
    
    struct {
      __IM  uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core.                     */
      __IM  uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core.                                   */
    } biss_ctrl_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_irq_msk_set;       /*!< (@ 0x00000010) BiSS IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to mtgy_irq_raw.                 */
    
    struct {
      __IOM uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core.                     */
      __IOM uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core.                                   */
    } biss_ctrl_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_irq_msk_reset;     /*!< (@ 0x00000014) BiSS IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core.                     */
      __IOM uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core.                                   */
    } biss_ctrl_irq_msk_reset_b;
  } ;
} biss_ctrl0_app_Type;                          /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                      biss_ctrl1_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief biss_ctrl1_app (biss_ctrl1_app)
  */

typedef struct {                                /*!< (@ 0xFF801D20) biss_ctrl1_app Structure                                   */
  
  union {
    __IOM uint32_t biss_ctrl_trigger_cfg;       /*!< (@ 0x00000000) BiSS trigger configuration                                 */
    
    struct {
      __IOM uint32_t sel        : 4;            /*!< [3..0] Trigger source select This bit field configures which
                                                     event is connected to the GETSENS signal of the BiSS core.
                                                     A rising edge of the selected event will generate an event
                                                     to the core. { | Value trigger event 0 none 1 manual 2
                                                     xc_trigger_out0 3 xc_trigger_out0 (inverted) 4 xc_trigger_out1
                                                     5 xc_trigger_out1 (inverted) 6 xc_sample_in0 7 xc_sample_in0
                                                     (inverted) 8 xc_sample_in1 9 xc_sample_in1 (inverted) 10
                                                     gpio_app_counter_zero0 11                                                 */
    } biss_ctrl_trigger_cfg_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_trigger;           /*!< (@ 0x00000004) BiSS trigger                                               */
    
    struct {
      __IOM uint32_t manual     : 1;            /*!< [0..0] Manual trigger. Writing '1' to this bit will trigger
                                                     the BiSS core immediately in case the trigger_cfg.sel bit
                                                     field is set to manual mode and the BiSS core is setup
                                                     for external triggering by the GETSENS signal.                            */
    } biss_ctrl_trigger_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_irq_raw;           /*!< (@ 0x00000008) BiSS raw IRQ: Read access shows status of unmasked
                                                                    IRQs. IRQs are set automatically and reset
                                                                    by writing to this register: Write access
                                                                    with '1' resets the appropriate IRQ. Write
                                                                    access with '0' does not influence this
                                                                    bit.                                                       */
    
    struct {
      __IOM uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core. Only a
                                                     rising edge on the EOT signal will set the interrupt.                     */
      __IOM uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core. Only a falling edge
                                                     on the NER signal will set the interrupt.                                 */
    } biss_ctrl_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t biss_ctrl_irq_masked;        /*!< (@ 0x0000000C) BiSS masked IRQ: Shows status of masked IRQs.              */
    
    struct {
      __IM  uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core.                     */
      __IM  uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core.                                   */
    } biss_ctrl_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_irq_msk_set;       /*!< (@ 0x00000010) BiSS IRQ mask set: The IRQ mask enables interrupt
                                                                    requests for corresponding interrupt sources.
                                                                    As its bits might be changed by different
                                                                    software tasks, the IRQ mask register is
                                                                    not writable directly, but by set and reset
                                                                    masks: Write access with '1' sets interrupt
                                                                    mask bit. Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, delete old pending interrupts
                                                                    by writing the same value to mtgy_irq_raw.                 */
    
    struct {
      __IOM uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core.                     */
      __IOM uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core.                                   */
    } biss_ctrl_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t biss_ctrl_irq_msk_reset;     /*!< (@ 0x00000014) BiSS IRQ mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit.
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t eot        : 1;            /*!< [0..0] End-Of-Transmission signal from the BiSS core.                     */
      __IOM uint32_t err        : 1;            /*!< [1..1] Error signal from the BiSS core.                                   */
    } biss_ctrl_irq_msk_reset_b;
  } ;
} biss_ctrl1_app_Type;                          /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                       xpic_app_regs                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief xpic_app_regs (xpic_app_regs)
  */

typedef struct {                                /*!< (@ 0xFF884000) xpic_app_regs Structure                                    */
  
  union {
    __IOM uint32_t xpic_r0;                     /*!< (@ 0x00000000) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r0         : 32;           /*!< [31..0] Work Register 0                                                   */
    } xpic_r0_b;
  } ;
  
  union {
    __IOM uint32_t xpic_r1;                     /*!< (@ 0x00000004) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r1         : 32;           /*!< [31..0] Work Register 1                                                   */
    } xpic_r1_b;
  } ;
  
  union {
    __IOM uint32_t xpic_r2;                     /*!< (@ 0x00000008) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r2         : 32;           /*!< [31..0] Work Register 2                                                   */
    } xpic_r2_b;
  } ;
  
  union {
    __IOM uint32_t xpic_r3;                     /*!< (@ 0x0000000C) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r3         : 32;           /*!< [31..0] Work Register 3                                                   */
    } xpic_r3_b;
  } ;
  
  union {
    __IOM uint32_t xpic_r4;                     /*!< (@ 0x00000010) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r4         : 32;           /*!< [31..0] Work Register 4                                                   */
    } xpic_r4_b;
  } ;
  
  union {
    __IOM uint32_t xpic_r5;                     /*!< (@ 0x00000014) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r5         : 32;           /*!< [31..0] Work Register 5                                                   */
    } xpic_r5_b;
  } ;
  
  union {
    __IOM uint32_t xpic_r6;                     /*!< (@ 0x00000018) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r6         : 32;           /*!< [31..0] Work Register 6                                                   */
    } xpic_r6_b;
  } ;
  
  union {
    __IOM uint32_t xpic_r7;                     /*!< (@ 0x0000001C) xPIC work register for indirect addressing                 */
    
    struct {
      __IOM uint32_t r7         : 32;           /*!< [31..0] Work Register 7                                                   */
    } xpic_r7_b;
  } ;
  
  union {
    __IOM uint32_t xpic_usr0;                   /*!< (@ 0x00000020) xPIC user Register additional work register                */
    
    struct {
      __IOM uint32_t usr0       : 32;           /*!< [31..0] User Register 0                                                   */
    } xpic_usr0_b;
  } ;
  
  union {
    __IOM uint32_t xpic_usr1;                   /*!< (@ 0x00000024) xPIC user Register additional work register                */
    
    struct {
      __IOM uint32_t usr1       : 32;           /*!< [31..0] User Register 1                                                   */
    } xpic_usr1_b;
  } ;
  
  union {
    __IOM uint32_t xpic_usr2;                   /*!< (@ 0x00000028) xPIC user Register additional work register                */
    
    struct {
      __IOM uint32_t usr2       : 32;           /*!< [31..0] User Register 2                                                   */
    } xpic_usr2_b;
  } ;
  
  union {
    __IOM uint32_t xpic_usr3;                   /*!< (@ 0x0000002C) xPIC user Register additional work register                */
    
    struct {
      __IOM uint32_t usr3       : 32;           /*!< [31..0] User Register 3                                                   */
    } xpic_usr3_b;
  } ;
  
  union {
    __IOM uint32_t xpic_usr4;                   /*!< (@ 0x00000030) xPIC user Register additional work register                */
    
    struct {
      __IOM uint32_t usr4       : 32;           /*!< [31..0] User Register 4                                                   */
    } xpic_usr4_b;
  } ;
  
  union {
    __IOM uint32_t xpic_pc;                     /*!< (@ 0x00000034) xPIC Program Counter Shared in xPIC 64_BIT_MUL_TARGET
                                                                    mode with usr32 (w mode)                                   */
    
    struct {
      __IOM uint32_t pc         : 32;           /*!< [31..0] Program Counter (dword address inside DPRAM)                      */
    } xpic_pc_b;
  } ;
  
  union {
    __IOM uint32_t xpic_stat;                   /*!< (@ 0x00000038) Processor Status Register                                  */
    
    struct {
      __IOM uint32_t stat       : 32;           /*!< [31..0] no field descpription                                             */
    } xpic_stat_b;
  } ;
  
  union {
    __IOM uint32_t xpic_zero;                   /*!< (@ 0x0000003C) Zero Register Shared in xPIC 64_BIT_MUL_TARGET
                                                                    mode with usr10 (w mode)                                   */
    
    struct {
      __IOM uint32_t zero       : 32;           /*!< [31..0] Always Zero                                                       */
    } xpic_zero_b;
  } ;
} xpic_app_regs_Type;                           /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                      xpic_app_debug                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief xpic_app_debug (xpic_app_debug)
  */

typedef struct {                                /*!< (@ 0xFF884080) xpic_app_debug Structure                                   */
  
  union {
    __IOM uint32_t xpic_hold_pc;                /*!< (@ 0x00000000) no Register description                                    */
    
    struct {
      __IOM uint32_t hold       : 1;            /*!< [0..0] 0: Start xPIC 1: Hold xPIC                                         */
      __IOM uint32_t single_step : 1;           /*!< [1..1] 0: Disable single step mode 1: xPIC processes a single
                                                     pipeline step then stops and triggers the single_step_irq.
                                                     Write '1' into xpic_break_irq_raw.single_step_irq to continue.            */
      __IOM uint32_t monitor_mode : 1;          /*!< [2..2] 0: xPIC stops when hardware breakpoint is triggered.
                                                     Write '1' into xpic_break_irq_raw.break0_irq or break1_irq
                                                     to continue. 1: Hardware breakpoints still generate irqs
                                                     but do not stop the xPIC.                                                 */
      __IOM uint32_t disable_int : 1;           /*!< [3..3] disable interrupts                                                 */
      __IOM uint32_t misalignment_hold : 1;     /*!< [4..4] 0: xPIC triggers misalignment_irq on misaligned memory
                                                     accesses but does not stop. 1: xPIC stops after a misaligned
                                                     memory accesses and triggers misalignment_irq. Write '1'
                                                     into xpic_break_irq_raw.misalignment_irq to continue.                     */
      __IOM uint32_t bank_select : 1;           /*!< [5..5] Select register bank (0: default bank, 1: fiq bank) Access
                                                     registers in xpic_regs area (xpic_r0 .. xpic_r7, xpic_stat)               */
      __IOM uint32_t bank_control : 1;          /*!< [6..6] control over the register bank selection WARNING: reset
                                                     this BIT to 0 BEFORE start xPIC (clear hold bits)                         */
      __IOM uint32_t reset_xpic : 1;            /*!< [7..7] REQUEST reset all internal internal states and the pipeline
                                                     EXCEPT: the internal register (r0-r7, usr0-4), bank0 and
                                                     bank1 reset this registers manually EXCEPT: xpic hard_breaker/debug
                                                     registers 1 - xPIC reset request                                          */
    } xpic_hold_pc_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break0_addr;            /*!< (@ 0x00000004) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 0 address value                                        */
    } xpic_break0_addr_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break0_addr_mask;       /*!< (@ 0x00000008) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 0 address mask                                         */
    } xpic_break0_addr_mask_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break0_data;            /*!< (@ 0x0000000C) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 0 data value (for data access only)                    */
    } xpic_break0_data_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break0_data_mask;       /*!< (@ 0x00000010) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 0 data mask (for data access only)                     */
    } xpic_break0_data_mask_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break0_contr;           /*!< (@ 0x00000014) no Register description                                    */
    
    struct {
      __IOM uint32_t write      : 1;            /*!< [0..0] Breakpoint 0 write/read access                                     */
      __IOM uint32_t mas        : 2;            /*!< [2..1] Breakpoint 0 memory access size (00: byte. 01: word,
                                                     10 dword, 11 reserved)                                                    */
      __IOM uint32_t data_access : 1;           /*!< [3..3] Breakpoint 0 (1: data access, 0: instruction fetch)                */
      __IOM uint32_t fiq_mode   : 1;            /*!< [4..4] Breakpoint 0 xPIC in FIQ Mode                                      */
      __IOM uint32_t irq_mode   : 1;            /*!< [5..5] Breakpoint 0 xPIC in IRQ Mode                                      */
      __IOM uint32_t chain      : 1;            /*!< [6..6] Breakpoint 0 input from Breakpoint 1                               */
      __IOM uint32_t range      : 1;            /*!< [7..7] Breakpoint 0 input from Breakpoint 1                               */
      __IOM uint32_t enable     : 1;            /*!< [8..8] Breakpoint 0                                                       */
    } xpic_break0_contr_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break0_contr_mask;      /*!< (@ 0x00000018) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 8;            /*!< [7..0] Breakpoint 0 control mask                                          */
    } xpic_break0_contr_mask_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break1_addr;            /*!< (@ 0x0000001C) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 1 address value                                        */
    } xpic_break1_addr_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break1_addr_mask;       /*!< (@ 0x00000020) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 1 address mask                                         */
    } xpic_break1_addr_mask_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break1_data;            /*!< (@ 0x00000024) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 1 data value (for data access only)                    */
    } xpic_break1_data_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break1_data_mask;       /*!< (@ 0x00000028) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Breakpoint 1 data mask (for data access only)                     */
    } xpic_break1_data_mask_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break1_contr;           /*!< (@ 0x0000002C) no Register description                                    */
    
    struct {
      __IOM uint32_t write      : 1;            /*!< [0..0] Breakpoint 1 write/read access                                     */
      __IOM uint32_t mas        : 2;            /*!< [2..1] Breakpoint 1 memory access size (00: byte. 01: word,
                                                     10 dword, 11 reserved)                                                    */
      __IOM uint32_t data_access : 1;           /*!< [3..3] Breakpoint 1 (1: data access, 0: instruction fetch)                */
      __IOM uint32_t fiq_mode   : 1;            /*!< [4..4] Breakpoint 1 xPIC in FIQ Mode                                      */
      __IOM uint32_t irq_mode   : 1;            /*!< [5..5] Breakpoint 1 xPIC in IRQ Mode                                      */
      __IOM uint32_t chain      : 1;            /*!< [6..6] reserved                                                           */
      __IOM uint32_t range      : 1;            /*!< [7..7] reserved                                                           */
      __IOM uint32_t enable     : 1;            /*!< [8..8] Breakpoint 1                                                       */
    } xpic_break1_contr_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break1_contr_mask;      /*!< (@ 0x00000030) no Register description                                    */
    
    struct {
      __IOM uint32_t val        : 8;            /*!< [7..0] Breakpoint 1 control mask                                          */
    } xpic_break1_contr_mask_b;
  } ;
  
  union {
    __IM  uint32_t xpic_break_last_pc;          /*!< (@ 0x00000034) no Register description                                    */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] last PC                                                           */
    } xpic_break_last_pc_b;
  } ;
  
  union {
    __IM  uint32_t xpic_break_status;           /*!< (@ 0x00000038) Read access shows the reason why xPIC is in HOLD
                                                                    / BREAK                                                    */
    
    struct {
      __IM  uint32_t xpic_in_hold : 1;          /*!< [0..0] xPIC is in Break or Hold (read only)                               */
      __IM  uint32_t hold       : 1;            /*!< [1..1] global HOLD BIT status 0- start xPIC, 1- hold xPIC (read
                                                     only)                                                                     */
      __IM  uint32_t break0     : 1;            /*!< [2..2] Breakpoint 0 is active(read only)                                  */
      __IM  uint32_t break1     : 1;            /*!< [3..3] Breakpoint 1 is active(read only)                                  */
      __IM  uint32_t soft_break : 1;            /*!< [4..4] Software Break is active(read only)                                */
      __IM  uint32_t single_step : 1;           /*!< [5..5] Single Step Break is active(read only)                             */
      __IM  uint32_t data_misalignment : 1;     /*!< [6..6] Data Misaligment is active(read only)                              */
      __IM  uint32_t break0_read_data : 1;      /*!< [7..7] Breakpoint 0 last load access (read only)                          */
      __IM  uint32_t break1_read_data : 1;      /*!< [8..8] Breakpoint 1 last load access (read only)                          */
      __IM  uint32_t xpic_reset_status : 1;     /*!< [9..9] 1 = XPIC ist in Reset(read only)                                   */
    } xpic_break_status_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break_irq_raw;          /*!< (@ 0x0000003C) xPIC_DEBUG Raw IRQ register: Read access shows
                                                                    status of unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the appropriate IRQ.
                                                                    Write access with '0' does not influence
                                                                    this bit.                                                  */
    
    struct {
      __IOM uint32_t break0_irq : 1;            /*!< [0..0] Breakpoint 0 Interrupt                                             */
      __IOM uint32_t break1_irq : 1;            /*!< [1..1] Breakpoint 1 Interrupt                                             */
      __IOM uint32_t soft_break_irq : 1;        /*!< [2..2] Software Breakpoint Interrupt                                      */
      __IOM uint32_t single_step_irq : 1;       /*!< [3..3] single step Breakpoint Interrupt                                   */
      __IOM uint32_t misalignment_irq : 1;      /*!< [4..4] Data Misalignment Error Interrupt                                  */
    } xpic_break_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t xpic_break_irq_masked;       /*!< (@ 0x00000040) xPIC_DEBUG Masked IRQ register for other CPU
                                                                    (ARM): Shows status of masked IRQs (as connected
                                                                    to ARM)                                                    */
    
    struct {
      __IM  uint32_t break0_irq : 1;            /*!< [0..0] Breakpoint 0 Interrupt                                             */
      __IM  uint32_t break1_irq : 1;            /*!< [1..1] Breakpoint 1 Interrupt                                             */
      __IM  uint32_t soft_break_irq : 1;        /*!< [2..2] Software Breakpoint Interrupt                                      */
      __IM  uint32_t single_step_irq : 1;       /*!< [3..3] single step Breakpoint Interrupt                                   */
      __IM  uint32_t misalignment_irq : 1;      /*!< [4..4] Data Misalignment Error Interrupt                                  */
    } xpic_break_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break_irq_msk_set;      /*!< (@ 0x00000044) xPIC_DEBUG interrupt mask set for other CPU (ARM):
                                                                    The IRQ mask enables interrupt requests
                                                                    for corresponding interrupt sources. As
                                                                    its bits might be changed by different software
                                                                    tasks, the IRQ mask register is not writable
                                                                    directly, but by set and reset masks: Write
                                                                    access with '1' sets interrupt mask bit
                                                                    (enables interrupt request for corresponding
                                                                    interrupt source). Write access with '0'
                                                                    does not influence this bit. Read access
                                                                    shows actual interrupt mask. Attention:
                                                                    Before activating i                                        */
    
    struct {
      __IOM uint32_t break0_irq : 1;            /*!< [0..0] Breakpoint 0 Interrupt                                             */
      __IOM uint32_t break1_irq : 1;            /*!< [1..1] Breakpoint 1 Interrupt                                             */
      __IOM uint32_t soft_break_irq : 1;        /*!< [2..2] Software Breakpoint Interrupt                                      */
      __IOM uint32_t single_step_irq : 1;       /*!< [3..3] single step Breakpoint Interrupt                                   */
      __IOM uint32_t misalignment_irq : 1;      /*!< [4..4] Data Misalignment Error Interrupt                                  */
    } xpic_break_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break_irq_msk_reset;    /*!< (@ 0x00000048) xPIC_DEBUG interrupt mask reset for other CPU
                                                                    (ARM): This is the corresponding reset mask
                                                                    to disable interrupt requests for corresponding
                                                                    interrupt sources: Write access with '1'
                                                                    resets interrupt mask bit (disables interrupt
                                                                    request for corresponding interrupt source).
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t break0_irq : 1;            /*!< [0..0] Breakpoint 0 Interrupt                                             */
      __IOM uint32_t break1_irq : 1;            /*!< [1..1] Breakpoint 1 Interrupt                                             */
      __IOM uint32_t soft_break_irq : 1;        /*!< [2..2] Software Breakpoint Interrupt                                      */
      __IOM uint32_t single_step_irq : 1;       /*!< [3..3] single step Breakpoint Interrupt                                   */
      __IOM uint32_t misalignment_irq : 1;      /*!< [4..4] Data Misalignment Error Interrupt                                  */
    } xpic_break_irq_msk_reset_b;
  } ;
  
  union {
    __IM  uint32_t xpic_break_own_irq_masked;   /*!< (@ 0x0000004C) xPIC_DEBUG own Masked IRQ register (for xPIC):
                                                                    Shows status of masked IRQs (as connected
                                                                    to xPIC)                                                   */
    
    struct {
      __IM  uint32_t misalignment_irq : 1;      /*!< [0..0] Data Misalignment Error Interrupt                                  */
    } xpic_break_own_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break_own_irq_msk_set;  /*!< (@ 0x00000050) xPIC_DEBUG own interrupt mask set (for xPIC):
                                                                    The IRQ mask enables interrupt requests
                                                                    for corresponding interrupt sources. As
                                                                    its bits might be changed by different software
                                                                    tasks, the IRQ mask register is not writable
                                                                    directly, but by set and reset masks: Write
                                                                    access with '1' sets interrupt mask bit
                                                                    (enables interrupt request for corresponding
                                                                    interrupt source). Write access with '0'
                                                                    does not influence this bit. Read access
                                                                    shows actual interrupt mask. Attention:
                                                                    Before activating interr                                   */
    
    struct {
      __IOM uint32_t misalignment_irq : 1;      /*!< [0..0] Data Misalignment Error Interrupt                                  */
    } xpic_break_own_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t xpic_break_own_irq_msk_reset;/*!< (@ 0x00000054) xPIC_DEBUG own interrupt mask reset (for XPIC):
                                                                    This is the corresponding reset mask to
                                                                    disable interrupt requests for corresponding
                                                                    interrupt sources: Write access with '1'
                                                                    resets interrupt mask bit (disables interrupt
                                                                    request for corresponding interrupt source).
                                                                    Write access with '0' does not influence
                                                                    this bit. Read access shows actual interrupt
                                                                    mask.                                                      */
    
    struct {
      __IOM uint32_t misalignment_irq : 1;      /*!< [0..0] Data Misalignment Error Interrupt                                  */
    } xpic_break_own_irq_msk_reset_b;
  } ;
  
  union {
    __IM  uint32_t xpic_break_return_fiq_pc;    /*!< (@ 0x00000058) xPIC_DEBUG information FIQ return PC value valid
                                                                    if xPIC is in FIQ                                          */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] xPIC FIQ return value                                             */
    } xpic_break_return_fiq_pc_b;
  } ;
  
  union {
    __IM  uint32_t xpic_break_return_irq_pc;    /*!< (@ 0x0000005C) xPIC_DEBUG information last IRQ return PC value
                                                                    valid if xPIC is in IRQ                                    */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] xPIC last IRQ return value                                        */
    } xpic_break_return_irq_pc_b;
  } ;
  
  union {
    __IM  uint32_t xpic_irq_status;             /*!< (@ 0x00000060) Read access shows the xpic irq status and the
                                                                    xpic irq enable bits                                       */
    
    struct {
      __IM  uint32_t irq_status : 1;            /*!< [0..0] IRQ status                                                         */
      __IM  uint32_t fiq_status : 1;            /*!< [1..1] FIQ status                                                         */
      __IM  uint32_t irq_enable : 1;            /*!< [2..2] IRQ enable bit                                                     */
      __IM  uint32_t fiq_enable : 1;            /*!< [3..3] FIQ enable bit                                                     */
    } xpic_irq_status_b;
  } ;
} xpic_app_debug_Type;                          /*!< Size = 100 (0x64)                                                         */



/* =========================================================================================================================== */
/* ================                                       vic_xpic_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief vic_xpic_app (vic_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF900000) vic_xpic_app Structure                                     */
  
  union {
    __IOM uint32_t xpic_vic_config;             /*!< (@ 0x00000000) XPIC VIC Configuration register                            */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] global enable of xPIC VIC (0: disable/ 1: enable)                  */
      __IOM uint32_t table      : 1;            /*!< [1..1] use far or near Table 0 = Base Pointer Addr for IRQ Jmp
                                                     Table + (n*4) DWORD Table 1 = Base Pointer Addr for IRQ
                                                     Jmp Table + (n*16) 4 DWORD Table n = IRQ vector number                    */
    } xpic_vic_config_b;
  } ;
  
  union {
    __IM  uint32_t xpic_vic_raw_intr0;          /*!< (@ 0x00000004) XPIC VIC Raw0 interrupt status register see netx4000_irq
                                                                    doc                                                        */
    
    struct {
      __IM  uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_raw_intr0_b;
  } ;
  
  union {
    __IM  uint32_t xpic_vic_raw_intr1;          /*!< (@ 0x00000008) XPIC VIC Raw1 interrupt status register see netx4000_irq
                                                                    doc                                                        */
    
    struct {
      __IM  uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_raw_intr1_b;
  } ;
  
  union {
    __IM  uint32_t xpic_vic_raw_intr2;          /*!< (@ 0x0000000C) XPIC VIC Raw2 interrupt status register see netx4000_irq
                                                                    doc                                                        */
    
    struct {
      __IM  uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_raw_intr2_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_softint0_set;       /*!< (@ 0x00000010) XPIC VIC Software0 interrupt set register: Read
                                                                    status or set IRQ by writing '1' to the
                                                                    appropriate bit.                                           */
    
    struct {
      __IOM uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_softint0_set_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_softint1_set;       /*!< (@ 0x00000014) XPIC VIC Software1 interrupt set register: Read
                                                                    status or set IRQ by writing '1' to the
                                                                    appropriate bit.                                           */
    
    struct {
      __IOM uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_softint1_set_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_softint2_set;       /*!< (@ 0x00000018) XPIC VIC Software2 interrupt set register: Read
                                                                    status or set IRQ by writing '1' to the
                                                                    appropriate bit.                                           */
    
    struct {
      __IOM uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_softint2_set_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_softint0_reset;     /*!< (@ 0x0000001C) XPIC VIC Software0 interrupt reset register:
                                                                    Read status or reset IRQ by writing '1'
                                                                    to the appropriate bit.                                    */
    
    struct {
      __IOM uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_softint0_reset_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_softint1_reset;     /*!< (@ 0x00000020) XPIC VIC Software1 interrupt reset register:
                                                                    Read status or reset IRQ by writing '1'
                                                                    to the appropriate bit.                                    */
    
    struct {
      __IOM uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_softint1_reset_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_softint2_reset;     /*!< (@ 0x00000024) XPIC VIC Software2 interrupt reset register:
                                                                    Read status or reset IRQ by writing '1'
                                                                    to the appropriate bit.                                    */
    
    struct {
      __IOM uint32_t irqs       : 32;           /*!< [31..0] see netx doc                                                      */
    } xpic_vic_softint2_reset_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_fiq_addr;           /*!< (@ 0x00000028) XPIC VIC FIQ Vector address 0 register                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] FIQ handler address                                               */
    } xpic_vic_fiq_addr_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_irq_addr;           /*!< (@ 0x0000002C) XPIC VIC normal IRQ address register                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] IRQ handler address                                               */
    } xpic_vic_irq_addr_b;
  } ;
  
  union {
    __IM  uint32_t xpic_vic_vector_addr;        /*!< (@ 0x00000030) XPIC VIC IRQ Vector address                                */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] IRQ vector address read access get actuel highest prior
                                                     IRQ read access get adr_xpic_vic_table_base_addr + IRQ
                                                     Number * (4/16)                                                           */
    } xpic_vic_vector_addr_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_table_base_addr;    /*!< (@ 0x00000034) XPIC VIC IRQ TABLE ADDRESS BASE POINTER                    */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] IRQ Table base address the Base Pointer Addr for IRQ
                                                     Jmp Table                                                                 */
    } xpic_vic_table_base_addr_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_fiq_vect_config;    /*!< (@ 0x00000038) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 23;           /*!< [29..7] reserved                                                          */
      __IOM uint32_t select_fiq_default : 1;    /*!< [30..30] 1 = select default vector for fiq (overwrite the int_source
                                                     selection)                                                                */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_fiq_vect_config_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config0;       /*!< (@ 0x0000003C) highest priority                                           */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config0_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config1;       /*!< (@ 0x00000040) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config1_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config2;       /*!< (@ 0x00000044) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config2_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config3;       /*!< (@ 0x00000048) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config3_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config4;       /*!< (@ 0x0000004C) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config4_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config5;       /*!< (@ 0x00000050) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config5_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config6;       /*!< (@ 0x00000054) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config6_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config7;       /*!< (@ 0x00000058) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config7_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config8;       /*!< (@ 0x0000005C) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config8_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config9;       /*!< (@ 0x00000060) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config9_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config10;      /*!< (@ 0x00000064) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config10_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config11;      /*!< (@ 0x00000068) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config11_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config12;      /*!< (@ 0x0000006C) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config12_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config13;      /*!< (@ 0x00000070) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config13_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config14;      /*!< (@ 0x00000074) no Register description                                    */
    
    struct {
      __IOM uint32_t int_source : 7;            /*!< [6..0] INT_SOURCE 0-95                                                    */
      __IOM uint32_t reserved0  : 24;           /*!< [30..7] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config14_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_vect_config15;      /*!< (@ 0x00000078) XPIC default interrupt vector, all interrupt
                                                                    sources (wired-OR) select with default interrupt
                                                                    vector register lowest priority                            */
    
    struct {
      __IOM uint32_t reserved0  : 31;           /*!< [30..0] reserved                                                          */
      __IOM uint32_t enable     : 1;            /*!< [31..31] vector interrupt enable                                          */
    } xpic_vic_vect_config15_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_default0;           /*!< (@ 0x0000007C) XPIC default interrupt vector select0                      */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] select int0 - int31 (wired-OR) 1-selected 0-not selected          */
    } xpic_vic_default0_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_default1;           /*!< (@ 0x00000080) XPIC default interrupt vector select1                      */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] select int32 - int63 (wired-OR) 1-selected 0-not selected         */
    } xpic_vic_default1_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_default2;           /*!< (@ 0x00000084) XPIC default interrupt vector select1                      */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] select int64 - int95 (wired-OR) 1-selected 0-not selected         */
    } xpic_vic_default2_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_fiq_default0;       /*!< (@ 0x00000088) XPIC default interrupt vector select0 for fiq              */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] select int0 - int31 (wired-OR) 1-selected 0-not selected          */
    } xpic_vic_fiq_default0_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_fiq_default1;       /*!< (@ 0x0000008C) XPIC default interrupt vector select1 for fiq              */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] select int32 - int63 (wired-OR) 1-selected 0-not selected         */
    } xpic_vic_fiq_default1_b;
  } ;
  
  union {
    __IOM uint32_t xpic_vic_fiq_default2;       /*!< (@ 0x00000090) XPIC default interrupt vector select1 for fiq              */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] select int64 - int95 (wired-OR) 1-selected 0-not selected         */
    } xpic_vic_fiq_default2_b;
  } ;
} vic_xpic_app_Type;                            /*!< Size = 148 (0x94)                                                         */



/* =========================================================================================================================== */
/* ================                                      timer_xpic_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief timer_xpic_app (timer_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF900100) timer_xpic_app Structure                                   */
  
  union {
    __IOM uint32_t timer_config_timer0;         /*!< (@ 0x00000000) ARM TIMER Config register0                                 */
    
    struct {
      __IOM uint32_t mode       : 2;            /*!< [1..0] Timer0 2'b00 : Timer stops at 0 2'b01 : Timer is preload
                                                     with value from preload register at 0 2'b10 : Timer (value)
                                                     compare with systime (once) 2'b11 : reserved                              */
      __IOM uint32_t systime_config : 2;        /*!< [3..2] systime for timer (2'b00.. systime_com, 2'b01.. systime_com_uc,
                                                     2'b10.. systime_app)                                                      */
    } timer_config_timer0_b;
  } ;
  
  union {
    __IOM uint32_t timer_config_timer1;         /*!< (@ 0x00000004) ARM TIMER Config register1                                 */
    
    struct {
      __IOM uint32_t mode       : 2;            /*!< [1..0] Timer1 2'b00 : Timer stops at 0 2'b01 : Timer is preload
                                                     with value from preload register at 0 2'b10 : Timer (value)
                                                     compare with systime (once) 2'b11 : reserved                              */
      __IOM uint32_t systime_config : 2;        /*!< [3..2] systime for timer (2'b00.. systime_com, 2'b01.. systime_com_uc,
                                                     2'b10.. systime_app)                                                      */
    } timer_config_timer1_b;
  } ;
  
  union {
    __IOM uint32_t timer_config_timer2;         /*!< (@ 0x00000008) ARM TIMER Config register2                                 */
    
    struct {
      __IOM uint32_t mode       : 2;            /*!< [1..0] Timer2 2'b00 : Timer stops at 0 2'b01 : Timer is preload
                                                     with value from preload register at 0 2'b10 : Timer (value)
                                                     compare with systime (once) 2'b11 : reserved                              */
      __IOM uint32_t systime_config : 2;        /*!< [3..2] systime for timer (2'b00.. systime_com, 2'b01.. systime_com_uc,
                                                     2'b10.. systime_app)                                                      */
    } timer_config_timer2_b;
  } ;
  
  union {
    __IOM uint32_t timer_preload_timer0;        /*!< (@ 0x0000000C) ARM TIMER Timer 0                                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] preload value                                                     */
    } timer_preload_timer0_b;
  } ;
  
  union {
    __IOM uint32_t timer_preload_timer1;        /*!< (@ 0x00000010) ARM TIMER Timer 1                                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] preload value                                                     */
    } timer_preload_timer1_b;
  } ;
  
  union {
    __IOM uint32_t timer_preload_timer2;        /*!< (@ 0x00000014) ARM TIMER Timer 2                                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] preload value                                                     */
    } timer_preload_timer2_b;
  } ;
  
  union {
    __IOM uint32_t timer_timer0;                /*!< (@ 0x00000018) ARM TIMER Timer 0                                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] actual value of timer / systime compare value                     */
    } timer_timer0_b;
  } ;
  
  union {
    __IOM uint32_t timer_timer1;                /*!< (@ 0x0000001C) ARM TIMER Timer 1                                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] actual value of timer / systime compare value                     */
    } timer_timer1_b;
  } ;
  
  union {
    __IOM uint32_t timer_timer2;                /*!< (@ 0x00000020) ARM TIMER Timer 2                                          */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] actual value of timer / systime compare value                     */
    } timer_timer2_b;
  } ;
  
  union {
    __IM  uint32_t timer_systime_s;             /*!< (@ 0x00000024) ARM_TIMER upper SYSTIME register To allow consistent
                                                                    values of systime_s and systime_ns, lower
                                                                    bits of systime is latched to systime_ns,
                                                                    when systime_s is read. This register should
                                                                    be dedicated to accesses via ARM. xPIC software
                                                                    should access systime via xpic_timer_systime_s.
                                                                    Host software should access systime via
                                                                    DPM at systime_s.                                          */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] Systime high: Sample systime_ns at read access to systime_s.
                                                     Value is incremented, if systime_ns reaches systime_border.               */
    } timer_systime_s_b;
  } ;
  
  union {
    __IM  uint32_t timer_systime_ns;            /*!< (@ 0x00000028) ARM_TIMER lower SYSTIME register To allow consistent
                                                                    values of systime_s and systime_ns, lower
                                                                    bits of systime is latched to systime_ns,
                                                                    when systime_s is read. If no systime_s
                                                                    is read before (e.g. at 2nd read access
                                                                    of systime_ns), the actual value of systime_ns
                                                                    is read. This register should be dedicated
                                                                    to accesses via ARM. xPIC software should
                                                                    access systime via xpic_timer_systime_ns.
                                                                    Host software should access systime via
                                                                    DPM at systime_ns.                                         */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] Systime low: Sample systime_ns at read access to systime_s.
                                                     Without sample read systime_s, read the actual value of
                                                     systime_ns.                                                               */
    } timer_systime_ns_b;
  } ;
  
  union {
    __IOM uint32_t timer_compare_systime_s_value;/*!< (@ 0x0000002C) SYSTIME sec compare value                                 */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Compare value with systime_s (seconds): Systime_s_compare_irq
                                                     is set, if systime_s matches.                                             */
    } timer_compare_systime_s_value_b;
  } ;
  
  union {
    __IOM uint32_t timer_irq_raw;               /*!< (@ 0x00000030) ARM_TIMER Raw IRQ register: Read access shows
                                                                    status of unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the appropriate IRQ.
                                                                    Write access with '0' does not influence
                                                                    this bit.                                                  */
    
    struct {
      __IOM uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IOM uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IOM uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IOM uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t timer_irq_masked;            /*!< (@ 0x00000034) ARM_TIMER Masked IRQ register: Shows status of
                                                                    masked IRQs (as connected to ARM/xPIC)                     */
    
    struct {
      __IM  uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IM  uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IM  uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IM  uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t timer_irq_msk_set;           /*!< (@ 0x00000038) ARM_TIMER interrupt mask set: The IRQ mask enables
                                                                    interrupt requests for corresponding interrupt
                                                                    sources. As its bits might be changed by
                                                                    different software tasks, the IRQ mask register
                                                                    is not writable directly, but by set and
                                                                    reset masks: Write access with '1' sets
                                                                    interrupt mask bit (enables interrupt request
                                                                    for corresponding interrupt source). Write
                                                                    access with '0' does not influence this
                                                                    bit. Read access shows actual interrupt
                                                                    mask. Attention: Before activating interrupt
                                                                    mask, delete                                               */
    
    struct {
      __IOM uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IOM uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IOM uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IOM uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t timer_irq_msk_reset;         /*!< (@ 0x0000003C) ARM_TIMER interrupt mask reset: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit
                                                                    (disables interrupt request for corresponding
                                                                    interrupt source). Write access with '0'
                                                                    does not influence this bit. Read access
                                                                    shows actual interrupt mask.                               */
    
    struct {
      __IOM uint32_t timer0_irq : 1;            /*!< [0..0] Timer 0 Interrupt                                                  */
      __IOM uint32_t timer1_irq : 1;            /*!< [1..1] Timer 1 Interrupt                                                  */
      __IOM uint32_t timer2_irq : 1;            /*!< [2..2] Timer 2 Interrupt                                                  */
      __IOM uint32_t systime_s_irq : 1;         /*!< [3..3] Systime sec Interrupt                                              */
    } timer_irq_msk_reset_b;
  } ;
  
  union {
    __IOM uint32_t timer_systime_config;        /*!< (@ 0x00000040) Select systime for arm_timer_systime_(ns)s functions       */
    
    struct {
      __IOM uint32_t systime_config : 2;        /*!< [1..0] systime for timer (2'b00.. systime_com, 2'b01.. systime_com_uc,
                                                     2'b10.. systime_app)                                                      */
    } timer_systime_config_b;
  } ;
} timer_xpic_app_Type;                          /*!< Size = 68 (0x44)                                                          */



/* =========================================================================================================================== */
/* ================                                       wdg_xpic_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief wdg_xpic_app (wdg_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF900180) wdg_xpic_app Structure                                     */
  
  union {
    __IOM uint32_t xpic_wdg_trig;               /*!< (@ 0x00000000) netX xPIC Watchdog Trigger Register. The watchdog
                                                                    access code is generated by a pseudo random
                                                                    generator.                                                 */
    
    struct {
      __IOM uint32_t wdg_access_code : 20;      /*!< [19..0] Watchdog access code for triggering. A read access gives
                                                     the next 16 bit code for trigger. A write access with correct
                                                     access code will trigger the watchdog counter.                            */
      __IOM uint32_t reserved0  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t irq_req_watchdog : 1;      /*!< [24..24] xPIC IRQ request of watchdog, writing 1 deletes IRQ
                                                     to xPIC                                                                   */
      __IOM uint32_t reserved1  : 3;            /*!< [27..25] reserved                                                         */
      __IOM uint32_t wdg_counter_trigger_w : 1; /*!< [28..28] Watchdog trigger bit: Bit must be set to trigger the
                                                     watchdog counter. When read, this bit is always '0'                       */
      __IOM uint32_t reserved2  : 2;            /*!< [30..29] reserved                                                         */
      __IOM uint32_t write_enable : 1;          /*!< [31..31] Write enable bit for timeout register: As long as this
                                                     bit is not set all write accesses to the timeout register
                                                     are ignored.                                                              */
    } xpic_wdg_trig_b;
  } ;
  
  union {
    __IM  uint32_t xpic_wdg_counter;            /*!< (@ 0x00000004) netX xPIC Watchdog Counter Register The counter
                                                                    value is decremented each 10000 system clock
                                                                    cycles.                                                    */
    
    struct {
      __IM  uint32_t val        : 17;           /*!< [16..0] Actual watchdog counter value: Bit 16 shows: 1: Watchdog
                                                     is counting down from xpic_irq_timeout to 0 for xPIC-IRQ
                                                     0: Watchdog is counting down from arm_irq_timeout to 0
                                                     for ARM-IRQ                                                               */
    } xpic_wdg_counter_b;
  } ;
  
  union {
    __IOM uint32_t xpic_wdg_xpic_irq_timeout;   /*!< (@ 0x00000008) netX xPIC Watchdog xPIC interrupt timout register:
                                                                    xpic_irq_timeout or arm_irq_timeout must
                                                                    be nonzero to enable watchdog                              */
    
    struct {
      __IOM uint32_t val        : 16;           /*!< [15..0] Watchdog interrupt timeout The total xpic_irq timeout
                                                     for a netX clock of 100MHz is: xpic_wdg_xpic_irq_timeout
                                                     * 100us                                                                   */
    } xpic_wdg_xpic_irq_timeout_b;
  } ;
  
  union {
    __IOM uint32_t xpic_wdg_arm_irq_timeout;    /*!< (@ 0x0000000C) netX xPIC Watchdog ARM interrupt timout register:
                                                                    xpic_irq_timeout or arm_irq_timeout must
                                                                    be nonzero to enable watchdog                              */
    
    struct {
      __IOM uint32_t val        : 16;           /*!< [15..0] Watchdog ARM interrupt timeout The total arm_irq timeout
                                                     for a netX clock of 100MHz is: (xpic_wdg_xpic_irq_timeout
                                                     + xpic_wdg_arm_irq_timeout) * 100us                                       */
    } xpic_wdg_arm_irq_timeout_b;
  } ;
  
  union {
    __IOM uint32_t xpic_wdg_irq_raw;            /*!< (@ 0x00000010) Read access shows status of unmasked IRQs. IRQs
                                                                    are set automatically and reset by writing
                                                                    to this register: Write access with '1'
                                                                    resets the appropriate IRQ. Write access
                                                                    with '0' does not influence this bit.                      */
    
    struct {
      __IOM uint32_t wdg_arm_irq : 1;           /*!< [0..0] Interrupt from xPIC Watchdog to ARM                                */
    } xpic_wdg_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t xpic_wdg_irq_masked;         /*!< (@ 0x00000014) xpic_wdg Masked IRQ register: Shows status of
                                                                    masked IRQs (as connected to xPIC).                        */
    
    struct {
      __IM  uint32_t wdg_arm_irq : 1;           /*!< [0..0] Interrupt from xPIC Watchdog to ARM                                */
    } xpic_wdg_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t xpic_wdg_irq_msk_set;        /*!< (@ 0x00000018) xpic_wdg interrupt mask enable: The IRQ mask
                                                                    enables interrupt requests for corresponding
                                                                    interrupt sources. As its bits might be
                                                                    changed by different software tasks, the
                                                                    IRQ mask register is not writable directly,
                                                                    but by set and reset masks: Write access
                                                                    with '1' sets interrupt mask bit (enables
                                                                    interrupt request for corresponding interrupt
                                                                    source). Write access with '0' does not
                                                                    influence this bit. Read access shows actual
                                                                    interrupt mask. Attention: Before activating
                                                                    interrupt mask, dele                                       */
    
    struct {
      __IOM uint32_t wdg_arm_irq : 1;           /*!< [0..0] Interrupt from xPIC Watchdog to ARM                                */
    } xpic_wdg_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t xpic_wdg_irq_msk_reset;      /*!< (@ 0x0000001C) xpic_wdg interrupt mask disable: This is the
                                                                    corresponding reset mask to disable interrupt
                                                                    requests for corresponding interrupt sources:
                                                                    Write access with '1' resets interrupt mask
                                                                    bit (disables interrupt request for corresponding
                                                                    interrupt source). Write access with '0'
                                                                    does not influence this bit. Read access
                                                                    shows actual interrupt mask.                               */
    
    struct {
      __IOM uint32_t wdg_arm_irq : 1;           /*!< [0..0] Interrupt from xPIC Watchdog to ARM                                */
    } xpic_wdg_irq_msk_reset_b;
  } ;
} wdg_xpic_app_Type;                            /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                       mcp_xpic_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief mcp_xpic_app (mcp_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF9001A0) mcp_xpic_app Structure                                     */
  
  union {
    __IOM uint32_t hs_irq_set_raw;              /*!< (@ 0x00000000) read: hs_iq_reg value write: hs_iq_reg set bit(s)          */
    
    struct {
      __IOM uint32_t hs_irq_set_bits : 32;      /*!< [31..0] IRQs for Inter-CPU-Communication                                  */
    } hs_irq_set_raw_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_reset_raw;            /*!< (@ 0x00000004) read: hs_iq_reg value write: hs_iq_reg reset
                                                                    bit(s)                                                     */
    
    struct {
      __IOM uint32_t hs_irq_reset_bits : 32;    /*!< [31..0] IRQs for Inter-CPU-Communication                                  */
    } hs_irq_reset_raw_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_set_mask;             /*!< (@ 0x00000008) read: mask value                                           */
    
    struct {
      __IOM uint32_t hs_irq_set_mask : 32;      /*!< [31..0] IRQs for Inter-CPU-Communication                                  */
    } hs_irq_set_mask_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_reset_mask;           /*!< (@ 0x0000000C) read: mask value                                           */
    
    struct {
      __IOM uint32_t hs_irq_reset_mask : 32;    /*!< [31..0] reset IRQs for Inter-CPU-Communication                            */
    } hs_irq_reset_mask_b;
  } ;
  
  union {
    __IOM uint32_t hs_irq_masked;               /*!< (@ 0x00000010) read: hs_iq_reg masked value                               */
    
    struct {
      __IOM uint32_t hs_irq_masked : 32;        /*!< [31..0] mask IRQs for Inter-CPU-Communication                             */
    } hs_irq_masked_b;
  } ;
} mcp_xpic_app_Type;                            /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                    systime_lt_xpic_app                                    ================ */
/* =========================================================================================================================== */


/**
  * @brief systime_lt_xpic_app (systime_lt_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF9001C0) systime_lt_xpic_app Structure                              */
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_ns;  /*!< (@ 0x00000000) systime_com_ns last latched value                          */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_ns last latched value                                 */
    } intlogic_lt_systime_com_ns_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_s;   /*!< (@ 0x00000004) systime_com_s last latched value                           */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_s last latched value                                  */
    } intlogic_lt_systime_com_s_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_uc_ns;/*!< (@ 0x00000008) systime_com_uc_ns last latched value                      */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_uc_ns last latched value                              */
    } intlogic_lt_systime_com_uc_ns_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_com_uc_s;/*!< (@ 0x0000000C) systime_com_uc_s last latched value                        */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_com_uc_s last latched value                               */
    } intlogic_lt_systime_com_uc_s_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_app_ns;  /*!< (@ 0x00000010) systime_app_ns last latched value                          */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_app_ns last latched value                                 */
    } intlogic_lt_systime_app_ns_b;
  } ;
  
  union {
    __IM  uint32_t intlogic_lt_systime_app_s;   /*!< (@ 0x00000014) systime_app_s last latched value                           */
    
    struct {
      __IM  uint32_t val        : 32;           /*!< [31..0] systime_app_s last latched value                                  */
    } intlogic_lt_systime_app_s_b;
  } ;
  
  union {
    __OM  uint32_t intlogic_lt_systimes_latch;  /*!< (@ 0x00000018) latch systimes by writing 1'b1 to the assigned
                                                                    bit                                                        */
    
    struct {
      __OM  uint32_t systime_com_ns : 1;        /*!< [0..0] no field descpription                                              */
      __OM  uint32_t systime_com_s : 1;         /*!< [1..1] no field descpription                                              */
      __OM  uint32_t systime_com_uc_ns : 1;     /*!< [2..2] no field descpription                                              */
      __OM  uint32_t systime_com_uc_s : 1;      /*!< [3..3] no field descpription                                              */
      __OM  uint32_t systime_app_ns : 1;        /*!< [4..4] no field descpription                                              */
      __OM  uint32_t systime_app_s : 1;         /*!< [5..5] no field descpription                                              */
    } intlogic_lt_systimes_latch_b;
  } ;
} systime_lt_xpic_app_Type;                     /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                       gpio_xpic_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief gpio_xpic_app (gpio_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF900200) gpio_xpic_app Structure                                    */
  
  union {
    __IOM uint32_t gpio_app_cfg0;               /*!< (@ 0x00000000) GPIO_APP pin 0 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] defines the gp input or output mode - depends on io_cfg
                                                     Input modes: 0000: read mode 0001: capture continued at
                                                     rising edge (allows gpio_app_irq on each capture) 0010:
                                                     capture once at rising edge (reset gpio_app_irq to capture
                                                     again) 0011: capture once at high level (reset gpio_app_irq
                                                     to capture again) Output modes: 0100: set to 0 0101: set
                                                     to 1 0110: set to gpio_app_line[0] 0111: pwm mode, direct
                                                     threshold update (might cause hazards on output) 1000:
                                                     blink mode Multi pin modes: 1111: pwm2-mode with thres                    */
      __IOM uint32_t inv        : 1;            /*!< [4..4] 1: invert input/output value 0: do not invert input/output         */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] counter reference 00: counter 0 01: counter 1 10: counter
                                                     2 11: sys_time (global system time)                                       */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] Length of blink sequence minus 1 (blink mode only) 00000:
                                                     use bit 0 of gpio_app_tc 00001: use bits 0..1 of gpio_app_tc
                                                     00010: use bits 0..2 of gpio_app_tc ... 11111: use bits
                                                     0..31 of gpio_app_tc                                                      */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] Run blink sequence only once (blink mode only)                   */
    } gpio_app_cfg0_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cfg1;               /*!< (@ 0x00000004) GPIO_APP pin 1 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] analog to gpio_app_cfg0                                            */
      __IOM uint32_t inv        : 1;            /*!< [4..4] analog to gpio_app_cfg0                                            */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] analog to gpio_app_cfg0                                            */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] analog to gpio_app_cfg0                                           */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] analog to gpio_app_cfg0                                          */
    } gpio_app_cfg1_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cfg2;               /*!< (@ 0x00000008) GPIO_APP pin 2 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] analog to gpio_app_cfg0                                            */
      __IOM uint32_t inv        : 1;            /*!< [4..4] analog to gpio_app_cfg0                                            */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] analog to gpio_app_cfg0                                            */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] analog to gpio_app_cfg0                                           */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] analog to gpio_app_cfg0                                          */
    } gpio_app_cfg2_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cfg3;               /*!< (@ 0x0000000C) GPIO_APP pin 3 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] analog to gpio_app_cfg0                                            */
      __IOM uint32_t inv        : 1;            /*!< [4..4] analog to gpio_app_cfg0                                            */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] analog to gpio_app_cfg0                                            */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] analog to gpio_app_cfg0                                           */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] analog to gpio_app_cfg0                                          */
    } gpio_app_cfg3_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cfg4;               /*!< (@ 0x00000010) GPIO_APP pin 4 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] analog to gpio_app_cfg0                                            */
      __IOM uint32_t inv        : 1;            /*!< [4..4] analog to gpio_app_cfg0                                            */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] analog to gpio_app_cfg0                                            */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] analog to gpio_app_cfg0                                           */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] analog to gpio_app_cfg0                                          */
    } gpio_app_cfg4_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cfg5;               /*!< (@ 0x00000014) GPIO_APP pin 5 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] analog to gpio_app_cfg0                                            */
      __IOM uint32_t inv        : 1;            /*!< [4..4] analog to gpio_app_cfg0                                            */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] analog to gpio_app_cfg0                                            */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] analog to gpio_app_cfg0                                           */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] analog to gpio_app_cfg0                                          */
    } gpio_app_cfg5_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cfg6;               /*!< (@ 0x00000018) GPIO_APP pin 6 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] analog to gpio_app_cfg0                                            */
      __IOM uint32_t inv        : 1;            /*!< [4..4] analog to gpio_app_cfg0                                            */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] analog to gpio_app_cfg0                                            */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] analog to gpio_app_cfg0                                           */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] analog to gpio_app_cfg0                                          */
    } gpio_app_cfg6_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cfg7;               /*!< (@ 0x0000001C) GPIO_APP pin 7 config register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t mode       : 4;            /*!< [3..0] analog to gpio_app_cfg0                                            */
      __IOM uint32_t inv        : 1;            /*!< [4..4] analog to gpio_app_cfg0                                            */
      __IOM uint32_t count_ref  : 2;            /*!< [6..5] analog to gpio_app_cfg0                                            */
      __IOM uint32_t blink_len  : 5;            /*!< [11..7] analog to gpio_app_cfg0                                           */
      __IOM uint32_t blink_once : 1;            /*!< [12..12] analog to gpio_app_cfg0                                          */
    } gpio_app_cfg7_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc0;                /*!< (@ 0x00000020) GPIO_APP pin 0 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Threshold/Capture register: PWM mode (threshold): {
                                                     | The counter threshold value equals the number of inactive
                                                     clock cycles per period (cycles with pwm=0). Therefore
                                                     it is interpreted differently in symmetrical and asymmetrical
                                                     counter mode: Asymmetrical mode (sawtooth): pwm = (counter
                                                     &gt;= gpio_app_tc) Symmetrical mode (triangle) : Counter
                                                     is compared with gpio_app_tc[31:1], gpio_app_tc[0] extends
                                                     the inactive phase by 1 clock cycle only while counting
                                                     up. This allows running a 10 ns resolution even in                        */
    } gpio_app_tc0_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc1;                /*!< (@ 0x00000024) GPIO_APP pin 1 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] analog to gpio_app_tc0                                            */
    } gpio_app_tc1_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc2;                /*!< (@ 0x00000028) GPIO_APP pin 2 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] analog to gpio_app_tc0                                            */
    } gpio_app_tc2_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc3;                /*!< (@ 0x0000002C) GPIO_APP pin 3 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] analog to gpio_app_tc0                                            */
    } gpio_app_tc3_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc4;                /*!< (@ 0x00000030) GPIO_APP pin 4 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] analog to gpio_app_tc0                                            */
    } gpio_app_tc4_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc5;                /*!< (@ 0x00000034) GPIO_APP pin 5 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] analog to gpio_app_tc0                                            */
    } gpio_app_tc5_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc6;                /*!< (@ 0x00000038) GPIO_APP pin 6 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] analog to gpio_app_tc0                                            */
    } gpio_app_tc6_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_tc7;                /*!< (@ 0x0000003C) GPIO_APP pin 7 threshold or capture register:
                                                                    This register is accessible via address
                                                                    areas inlogic_app and xpic_app_system.                     */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] analog to gpio_app_tc0                                            */
    } gpio_app_tc7_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter0_ctrl;      /*!< (@ 0x00000040) GPIO_APP counter0 control register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t run        : 1;            /*!< [0..0] 1: start counter, counter is running 0: stop counter               */
      __IOM uint32_t sym_nasym  : 1;            /*!< [1..1] 1: symmetric mode (triangle) 0: asymmetric mode (sawtooth)         */
      __IOM uint32_t irq_en     : 1;            /*!< [2..2] 1: enable interrupt request on sel_event 0: disable interrupt
                                                     request                                                                   */
      __IOM uint32_t sel_event  : 1;            /*!< [3..3] select external event 0: high level, invert gpio in register
                                                     gpio_app_cfg to select low level 1: pos. edge, invert gpio
                                                     in register gpio_app_cfg to select neg. edge                              */
      __IOM uint32_t once       : 1;            /*!< [4..4] 1: count once (reset run bit after 1 period) 0: count
                                                     continuously                                                              */
      __IOM uint32_t event_act  : 2;            /*!< [6..5] Define action of selected external event (dependent on
                                                     sel_event, gpio_ref) 00: count every clock cycle, ignore
                                                     external events 01: count only external events (edge or
                                                     level according to bit sel_event) 10: enable watchdog mode
                                                     of counter (external event will be reset without IRQ, overflow
                                                     generates IRQ). 11: enable automatic run mode (external
                                                     event sets run bit, used for DC-DC PWM in combination with
                                                     bit once=1)                                                               */
      __IOM uint32_t gpio_ref   : 3;            /*!< [9..7] gpio reference (0 - 7)                                             */
    } gpio_app_counter0_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter1_ctrl;      /*!< (@ 0x00000044) GPIO_APP counter1 control register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t run        : 1;            /*!< [0..0] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t sym_nasym  : 1;            /*!< [1..1] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t irq_en     : 1;            /*!< [2..2] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t sel_event  : 1;            /*!< [3..3] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t once       : 1;            /*!< [4..4] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t event_act  : 2;            /*!< [6..5] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t gpio_ref   : 3;            /*!< [9..7] analog to gpio_app_counter0_ctrl                                   */
    } gpio_app_counter1_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter2_ctrl;      /*!< (@ 0x00000048) GPIO_APP counter2 control register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t run        : 1;            /*!< [0..0] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t sym_nasym  : 1;            /*!< [1..1] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t irq_en     : 1;            /*!< [2..2] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t sel_event  : 1;            /*!< [3..3] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t once       : 1;            /*!< [4..4] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t event_act  : 2;            /*!< [6..5] analog to gpio_app_counter0_ctrl                                   */
      __IOM uint32_t gpio_ref   : 3;            /*!< [9..7] analog to gpio_app_counter0_ctrl                                   */
    } gpio_app_counter2_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter0_max;       /*!< (@ 0x0000004C) GPIO_APP counter0 max value: This register is
                                                                    accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Asymmetric mode: Counting period in cc + 1 Symmetric
                                                     mode: Counting period in cc                                               */
    } gpio_app_counter0_max_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter1_max;       /*!< (@ 0x00000050) GPIO_APP counter1 max value: This register is
                                                                    accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Asymmetric mode: Counting period in cc + 1 Symmetric
                                                     mode: Counting period in cc                                               */
    } gpio_app_counter1_max_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter2_max;       /*!< (@ 0x00000054) GPIO_APP counter2 max value: This register is
                                                                    accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] Asymmetric mode: Counting period in cc + 1 Symmetric
                                                     mode: Counting period in cc                                               */
    } gpio_app_counter2_max_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter0_cnt;       /*!< (@ 0x00000058) GPIO_APP counter0 current value: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] current counter value                                             */
    } gpio_app_counter0_cnt_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter1_cnt;       /*!< (@ 0x0000005C) GPIO_APP counter1 current value: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] current counter value                                             */
    } gpio_app_counter1_cnt_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_counter2_cnt;       /*!< (@ 0x00000060) GPIO_APP counter2 current value: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t val        : 32;           /*!< [31..0] current counter value                                             */
    } gpio_app_counter2_cnt_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_line;               /*!< (@ 0x00000064) GPIO_APP line register This register is accessible
                                                                    via address areas inlogic_app and xpic_app_system.         */
    
    struct {
      __IOM uint32_t val        : 8;            /*!< [7..0] gpio_app output values                                             */
    } gpio_app_line_b;
  } ;
  
  union {
    __IM  uint32_t gpio_app_in;                 /*!< (@ 0x00000068) GPIO_APP latched inputs register: This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IM  uint32_t val        : 8;            /*!< [7..0] gpio_app input values                                              */
    } gpio_app_in_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_irq_raw;            /*!< (@ 0x0000006C) GPIO_APP raw IRQ register: Read access shows
                                                                    the status of unmasked IRQs. IRQs are set
                                                                    automatically and reset by writing to this
                                                                    register: Write access with '1' resets the
                                                                    corresponding IRQ. Write access with '0'
                                                                    does not influence this bit. This register
                                                                    is accessible via address areas inlogic_app
                                                                    and xpic_app_system.                                       */
    
    struct {
      __IOM uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IOM uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IOM uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IOM uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IOM uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IOM uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IOM uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IOM uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t gpio_app_irq_masked;         /*!< (@ 0x00000070) GPIO_APP masked IRQ register: This register exists
                                                                    2x for the different system busses (address
                                                                    areas) it is connected to. This allows 2
                                                                    CPUs to work in parallel on this module:
                                                                    ARM_APP, xPIC_APP.                                         */
    
    struct {
      __IM  uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IM  uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IM  uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IM  uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IM  uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IM  uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IM  uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IM  uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_irq_mask_set;       /*!< (@ 0x00000074) GPIO_APP interrupt mask set: The interrupt mask
                                                                    register exists 2x for the different system
                                                                    busses (address areas) it is connected to.
                                                                    This allows 2 CPUs to work in parallel on
                                                                    this module: ARM_APP, xPIC_APP. The inlogic_app
                                                                    IRQ mask enables interrupt requests for
                                                                    ARM_APP. The xpic_app_system IRQ mask enables
                                                                    interrupt requests for xPIC_APP. Since different
                                                                    software tasks might change its bits, the
                                                                    IRQ mask register is not writable directly,
                                                                    but by set and reset masks: Write access
                                                                    with                                                       */
    
    struct {
      __IOM uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IOM uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IOM uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IOM uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IOM uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IOM uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IOM uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IOM uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_irq_mask_rst;       /*!< (@ 0x00000078) GPIO_APP interrupt mask reset: This reset mask
                                                                    serves to disable the interrupt requests
                                                                    for the corresponding interrupt sources.
                                                                    Like irq_msk_set, this address exists for
                                                                    the following address areas: inlogic_app,
                                                                    xpic_app_system. Write access with '1' resets
                                                                    the interrupt mask bit (disables the interrupt
                                                                    request for the corresponding interrupt
                                                                    source). Write access with '0' does not
                                                                    influence this bit. Read access shows the
                                                                    current interrupt mask.                                    */
    
    struct {
      __IOM uint32_t gpio_app0  : 1;            /*!< [0..0] Interrupt bit for GPIO_APP0                                        */
      __IOM uint32_t gpio_app1  : 1;            /*!< [1..1] Interrupt bit for GPIO_APP1                                        */
      __IOM uint32_t gpio_app2  : 1;            /*!< [2..2] Interrupt bit for GPIO_APP2                                        */
      __IOM uint32_t gpio_app3  : 1;            /*!< [3..3] Interrupt bit for GPIO_APP3                                        */
      __IOM uint32_t gpio_app4  : 1;            /*!< [4..4] Interrupt bit for GPIO_APP4                                        */
      __IOM uint32_t gpio_app5  : 1;            /*!< [5..5] Interrupt bit for GPIO_APP5                                        */
      __IOM uint32_t gpio_app6  : 1;            /*!< [6..6] Interrupt bit for GPIO_APP6                                        */
      __IOM uint32_t gpio_app7  : 1;            /*!< [7..7] Interrupt bit for GPIO_APP7                                        */
    } gpio_app_irq_mask_rst_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cnt_irq_raw;        /*!< (@ 0x0000007C) Counter raw IRQ register: Read access shows the
                                                                    status of unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the corresponding
                                                                    IRQ. Write access with '0' does not influence
                                                                    this bit. This register is accessible via
                                                                    address areas inlogic_app and xpic_app_system.             */
    
    struct {
      __IOM uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IOM uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IOM uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t gpio_app_cnt_irq_masked;     /*!< (@ 0x00000080) Counter masked IRQ register: Read access shows
                                                                    the status of masked IRQs (cnt_irq_raw AND
                                                                    cnt_irq_mask). This register exists 2x for
                                                                    the different system busses (address areas)
                                                                    it is connected to. This allows 2 CPUs to
                                                                    work in parallel on this module: ARM_APP,
                                                                    xPIC_APP.                                                  */
    
    struct {
      __IM  uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IM  uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IM  uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cnt_irq_mask_set;   /*!< (@ 0x00000084) Counter interrupt mask set: The interrupt mask
                                                                    register exists 2x for the different system
                                                                    busses (address areas) it is connected to.
                                                                    This allows 2 CPUs to work in parallel on
                                                                    this module: ARM_APP, xPIC_APP. The inlogic_app
                                                                    IRQ mask enables interrupt requests for
                                                                    ARM_APP. The xpic_app_system IRQ mask enables
                                                                    interrupt requests for xPIC_APP. Since different
                                                                    software tasks might change its bits, the
                                                                    IRQ mask register is not writable directly,
                                                                    but by set and reset masks: Write access
                                                                    with '                                                     */
    
    struct {
      __IOM uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IOM uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IOM uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_mask_set_b;
  } ;
  
  union {
    __IOM uint32_t gpio_app_cnt_irq_mask_rst;   /*!< (@ 0x00000088) Counter interrupt mask reset: This reset mask
                                                                    serves to disable the interrupt requests
                                                                    for the corresponding interrupt sources.
                                                                    Like cnt_irq_msk_set, this address exists
                                                                    for the following address areas: inlogic_app,
                                                                    xpic_app_system. Write access with '1' resets
                                                                    the interrupt mask bit (disables the interrupt
                                                                    request for the corresponding interrupt
                                                                    source). Write access with '0' does not
                                                                    influence this bit. Read access shows the
                                                                    current interrupt mask.                                    */
    
    struct {
      __IOM uint32_t cnt0       : 1;            /*!< [0..0] Interrupt bit for counter0                                         */
      __IOM uint32_t cnt1       : 1;            /*!< [1..1] Interrupt bit for counter1                                         */
      __IOM uint32_t cnt2       : 1;            /*!< [2..2] Interrupt bit for counter2                                         */
    } gpio_app_cnt_irq_mask_rst_b;
  } ;
} gpio_xpic_app_Type;                           /*!< Size = 140 (0x8c)                                                         */



/* =========================================================================================================================== */
/* ================                                       uart_xpic_app                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief uart_xpic_app (uart_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF900300) uart_xpic_app Structure                                    */
  
  union {
    __IOM uint32_t uartdr;                      /*!< (@ 0x00000000) data read or written from the interface                    */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] data read or written from the interface                            */
      __IOM uint32_t FE         : 1;            /*!< [8..8] Framing Error, read only, mirrored from uartrsr, to handle
                                                     in DMA-read-out data                                                      */
      __IOM uint32_t PE         : 1;            /*!< [9..9] Parity Error, read only, mirrored from uartrsr, to handle
                                                     in DMA-read-out data                                                      */
      __IOM uint32_t BE         : 1;            /*!< [10..10] Break Error, read only, mirrored from uartrsr, to handle
                                                     in DMA-read-out data                                                      */
    } uartdr_b;
  } ;
  
  union {
    __IOM uint32_t uartrsr;                     /*!< (@ 0x00000004) receive status register (read) / Error Clear
                                                                    Register (write)                                           */
    
    struct {
      __IOM uint32_t FE         : 1;            /*!< [0..0] Framing Error                                                      */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Parity Error                                                       */
      __IOM uint32_t BE         : 1;            /*!< [2..2] Break Error                                                        */
      __IOM uint32_t OE         : 1;            /*!< [3..3] Overrun Error                                                      */
    } uartrsr_b;
  } ;
  
  union {
    __IOM uint32_t uartlcr_h;                   /*!< (@ 0x00000008) Line control Register, high byte                           */
    
    struct {
      __IOM uint32_t BRK        : 1;            /*!< [0..0] Send Break                                                         */
      __IOM uint32_t PEN        : 1;            /*!< [1..1] Parity Enalble                                                     */
      __IOM uint32_t EPS        : 1;            /*!< [2..2] Even Parity Select                                                 */
      __IOM uint32_t STP2       : 1;            /*!< [3..3] 2 Stop Bits Select                                                 */
      __IOM uint32_t FEN        : 1;            /*!< [4..4] FIFO Enable                                                        */
      __IOM uint32_t WLEN       : 2;            /*!< [6..5] Word Length '00' 5 bits '01' 6 bits '10' 7 bits '11'
                                                     8 bits                                                                    */
    } uartlcr_h_b;
  } ;
  
  union {
    __IOM uint32_t uartlcr_m;                   /*!< (@ 0x0000000C) Line control Register, middle byte                         */
    
    struct {
      __IOM uint32_t BAUDDIVMS  : 8;            /*!< [7..0] bauddiv : Baud Divisor Most Significant Byte use higher
                                                     byte of bauddiv = (system clk / (16 * baud rate)) - 1 if
                                                     not alternative settings by register uartcr_2 are done                    */
    } uartlcr_m_b;
  } ;
  
  union {
    __IOM uint32_t uartlcr_l;                   /*!< (@ 0x00000010) Line control Register, low byte                            */
    
    struct {
      __IOM uint32_t BAUDDIVLS  : 8;            /*!< [7..0] Baud Divisor Least Significant Byte use lower byte of
                                                     bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative
                                                     settings by register uartcr_2 are done                                    */
    } uartlcr_l_b;
  } ;
  
  union {
    __IOM uint32_t uartcr;                      /*!< (@ 0x00000014) uart control Register                                      */
    
    struct {
      __IOM uint32_t uartEN     : 1;            /*!< [0..0] uart Enable                                                        */
      __IOM uint32_t SIREN      : 1;            /*!< [1..1] SIR Enable                                                         */
      __IOM uint32_t SIRLP      : 1;            /*!< [2..2] IrDA SIR Low Power Mode                                            */
      __IOM uint32_t MSIE       : 1;            /*!< [3..3] Modem Status Interrupt Enable                                      */
      __IOM uint32_t RIE        : 1;            /*!< [4..4] Receive Interrupt Enable                                           */
      __IOM uint32_t TIE        : 1;            /*!< [5..5] Transmit Interrupt Enable                                          */
      __IOM uint32_t RTIE       : 1;            /*!< [6..6] Receive Timeout Interrupt Enable                                   */
      __IOM uint32_t LBE        : 1;            /*!< [7..7] Loop Back Enable for IrDA mode                                     */
      __IOM uint32_t TX_RX_LOOP : 1;            /*!< [8..8] internal loop (TX -&gt; RX) (test purpose only)                    */
    } uartcr_b;
  } ;
  
  union {
    __IM  uint32_t uartfr;                      /*!< (@ 0x00000018) uart Flag Register                                         */
    
    struct {
      __IM  uint32_t CTS        : 1;            /*!< [0..0] Clear To Send                                                      */
      __IM  uint32_t DSR        : 1;            /*!< [1..1] Data Set Ready                                                     */
      __IM  uint32_t DCD        : 1;            /*!< [2..2] Data Carrier Detect                                                */
      __IM  uint32_t BUSY       : 1;            /*!< [3..3] uart BUSY                                                          */
      __IM  uint32_t RXFE       : 1;            /*!< [4..4] Receive FIFO Empty                                                 */
      __IM  uint32_t TXFF       : 1;            /*!< [5..5] Transmit FIFO Full                                                 */
      __IM  uint32_t RXFF       : 1;            /*!< [6..6] Receive FIFO Full                                                  */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO Empty                                                */
    } uartfr_b;
  } ;
  
  union {
    __IOM uint32_t uartiir;                     /*!< (@ 0x0000001C) Interrupt Identification (read) / interrupt clear
                                                                    (write)                                                    */
    
    struct {
      __IOM uint32_t MIS        : 1;            /*!< [0..0] Modem Interrupt Status                                             */
      __IOM uint32_t RIS        : 1;            /*!< [1..1] Receive Interrupt Status                                           */
      __IOM uint32_t TIS        : 1;            /*!< [2..2] Transmit Interrupt Status                                          */
      __IOM uint32_t RTIS       : 1;            /*!< [3..3] Receive Timeout Interrupt Status                                   */
    } uartiir_b;
  } ;
  
  union {
    __IOM uint32_t uartilpr;                    /*!< (@ 0x00000020) IrDA Low Power Counter Register                            */
    
    struct {
      __IOM uint32_t ILPDVSR    : 8;            /*!< [7..0] IrDA Low Power Divisor                                             */
    } uartilpr_b;
  } ;
  
  union {
    __IOM uint32_t uartrts;                     /*!< (@ 0x00000024) RTS Control Register                                       */
    
    struct {
      __IOM uint32_t AUTO       : 1;            /*!< [0..0] automatic or controlled by the next bit (RTS)                      */
      __IOM uint32_t RTS        : 1;            /*!< [1..1] if AUTO=0: controlled by this bit                                  */
      __IOM uint32_t COUNT      : 1;            /*!< [2..2] count base: 1=system clocks, 0=time in bauds                       */
      __IOM uint32_t MOD2       : 1;            /*!< [3..3] mode1/mode2                                                        */
      __IOM uint32_t RTS_pol    : 1;            /*!< [4..4] RTS polarity: 1=active high                                        */
      __IOM uint32_t CTS_ctr    : 1;            /*!< [5..5] nUARTCTS control                                                   */
      __IOM uint32_t CTS_pol    : 1;            /*!< [6..6] nUARTCTS polarity: 1=active high                                   */
      __IOM uint32_t STICK      : 1;            /*!< [7..7] stick parity                                                       */
    } uartrts_b;
  } ;
  
  union {
    __IOM uint32_t uartforerun;                 /*!< (@ 0x00000028) RTS forerun cycles                                         */
    
    struct {
      __IOM uint32_t FORERUN    : 8;            /*!< [7..0] number of forerun cycles in system clocks or bauds                 */
    } uartforerun_b;
  } ;
  
  union {
    __IOM uint32_t uarttrail;                   /*!< (@ 0x0000002C) RTS trail cycles                                           */
    
    struct {
      __IOM uint32_t TRAIL      : 8;            /*!< [7..0] number of trail cycles in system clocks or bauds                   */
    } uarttrail_b;
  } ;
  
  union {
    __IOM uint32_t uartdrvout;                  /*!< (@ 0x00000030) Drive Output                                               */
    
    struct {
      __IOM uint32_t DRVTX      : 1;            /*!< [0..0] enable driver for TX                                               */
      __IOM uint32_t DRVRTS     : 1;            /*!< [1..1] enable driver for RTS                                              */
    } uartdrvout_b;
  } ;
  
  union {
    __IOM uint32_t uartcr_2;                    /*!< (@ 0x00000034) Control Register 2                                         */
    
    struct {
      __IOM uint32_t Baud_Rate_Mode : 1;        /*!< [0..0] If this bit is set the baud rate is generated more exactly
                                                     by the following formula: value = ( (Baud Rate * 16) /
                                                     System Frequency ) * 2^16 . You have to write this 16-bit
                                                     value in register uartlcr_l and uartlcr_m.                                */
    } uartcr_2_b;
  } ;
  
  union {
    __IOM uint32_t uartrxiflsel;                /*!< (@ 0x00000038) RX FIFO trigger level and RX-DMA enable                    */
    
    struct {
      __IOM uint32_t RXIFLSEL   : 5;            /*!< [4..0] Choose a number between 1 and 16. It defines the IRQ
                                                     trigger level of the receive fifo. The IRQ (UARTRXINTR)
                                                     will be set if the number of received bytes in the receive
                                                     fifo are greater than or equal RXIFLSEL.                                  */
      __IOM uint32_t RXDMA      : 1;            /*!< [5..5] Enable DMA-requests for RX-fifo-data. A request will
                                                     be generated if RX-FIFO is not empty and uartcr.uartEN
                                                     (module enable) is set. Burst request to DMA-Ctrl will
                                                     be done if the RX-FIFO contains at least 4 words (set DMA-burst-size
                                                     to 4) If this bit is reset or the module is disabled, DMA-request
                                                     will also be reset. single transfer request: RX-FIFO contains
                                                     1 byte or more, burst request: 4 bytes or more note: set
                                                     adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the
                                                     DMA module                                                                */
    } uartrxiflsel_b;
  } ;
  
  union {
    __IOM uint32_t uarttxiflsel;                /*!< (@ 0x0000003C) TX FIFO trigger level and TX-DMA enable                    */
    
    struct {
      __IOM uint32_t TXIFLSEL   : 5;            /*!< [4..0] Choose a number between 1 and 16. It defines the IRQ
                                                     trigger level of the transmit fifo. The IRQ (UARTTXINTR)
                                                     will be set if the number of transmitted bytes in the transmit
                                                     fifo are less than TXIFLSEL.                                              */
      __IOM uint32_t TXDMA      : 1;            /*!< [5..5] Enable DMA-requests for TX-fifo-data. A request will
                                                     be generated if TX-FIFO is not full and uartcr.uartEN (module
                                                     enable) is set. Burst request to DMA-Ctrl will be done
                                                     if at least 4 words are writable to the TX-FIFO (set DMA-burst-size
                                                     to 4) If this bit is reset or the module is disabled, DMA-request
                                                     will also be reset. note: set adr_dmac_chctrl.DBSize =
                                                     1 (i.e. burst size: 4) in the DMA module                                  */
    } uarttxiflsel_b;
  } ;
} uart_xpic_app_Type;                           /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                       i2c_xpic_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief i2c_xpic_app (i2c_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF900340) i2c_xpic_app Structure                                     */
  
  union {
    __IOM uint32_t i2c_mcr;                     /*!< (@ 0x00000000) I2C master control register:                               */
    
    struct {
      __IOM uint32_t en_i2c     : 1;            /*!< [0..0] Global I2C controller enable 1: Enable I2C controller
                                                     0: Disable I2C controller Disabling the I2C module during
                                                     a transfer will immediately disconnect the I2C module from
                                                     the bus without generating a STOP. The internal I2C state
                                                     machine will be set back to initial/idle state. The I2C
                                                     bus-state-detection for the bits i2c_sr.bus_master and
                                                     i2c_sr.started are performed even if the module is disabled.
                                                     For details, see these bits.                                              */
      __IOM uint32_t mode       : 3;            /*!< [3..1] I2C-speed-mode: If this device is used as a slave only,
                                                     the mode should be set to the data rate generated by the
                                                     fastest master on the I2C-bus for appropriate input filtering
                                                     and spike suppression. 000: Fast/Standard mode, 50 kbit/s
                                                     001: Fast/Standard mode, 100 kbit/s 010: Fast/Standard
                                                     mode, 200 kbit/s 011: Fast/Standard mode, 400 kbit/s 100:
                                                     High-speed mode, 800 kbit/s 101: High-speed mode, 1.2 Mbit/s
                                                     110: High-speed mode, 1.7 Mbit/s 111: High-speed mode,
                                                     3.4 Mbit/s)                                                               */
      __IOM uint32_t sadr       : 7;            /*!< [10..4] 7-bit slave address sent after (r)START: For 10-bit
                                                     addressing, the first byte (10-bit start '11110', address
                                                     bits[9:8] must be programmed here. The second start byte
                                                     (lower slave address bits) must be on top of the master
                                                     FIFO (i2c_mdr). This register must be rewritten (even if
                                                     the value does not change) to address another slave in
                                                     the 10-bit mode (run 2-byte start sequence). The register
                                                     must not be rewritten before a repeated START on the same
                                                     10-bit addressed slave (run 1-byte start sequence e.g.
                                                     write                                                                     */
      __IOM uint32_t reserved0  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t pio_mode   : 1;            /*!< [16..16] If this bit is set, SCL and SDA can be controlled directly
                                                     by register i2c_pio (e.g. to access devices being incompatible
                                                     with I2C). In PIO mode, the I2C controller state machine
                                                     is disabled: FIFOs are not used, no IRQs will be set, and
                                                     no DMA controlling is possible.                                           */
      __IOM uint32_t rst_i2c    : 1;            /*!< [17..17] Reset the I2C bus-state-detection logic. To avoid conflicts
                                                     with other masters, some I2C bus states, which are important
                                                     when there are multiple masters on the I2C bus, are always
                                                     monitored, even if the I2C module is disabled. For details,
                                                     see bits i2c_sr.started and i2c.bus_master. However, it
                                                     may happen that bus states are detected which lock up the
                                                     I2C module. E.g. hazards during power-up or IO configuration
                                                     or sequences, which are not I2C compliant, can cause a
                                                     lock-up. This bit can be used to escap                                    */
      __IOM uint32_t en_timeout : 1;            /*!< [18..18] Enable I2C command timeout detection. Enabling the
                                                     timeout detection is recommended to prevent the module
                                                     from stalling if another device holds the I2C signals permanently
                                                     low. For details, see the description of bit i2s_sr.timeout.              */
      __IOM uint32_t reserved1  : 13;           /*!< [31..19] reserved                                                         */
    } i2c_mcr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_scr;                     /*!< (@ 0x00000004) I2C slave control register:                                */
    
    struct {
      __IOM uint32_t sid        : 10;           /*!< [9..0] Slave device ID/address: External masters can address
                                                     this device (this I2C module in slave mode) by the ID/address
                                                     programmed here. If sid10 is not set, bits 9 to 7 will
                                                     be ignored.                                                               */
      __IOM uint32_t sid10      : 1;            /*!< [10..10] 10-bit slave device ID/address: 0: Wait for 7-bit slave
                                                     address after (r)START 1: Wait for 10-bit slave address
                                                     after (r)START                                                            */
      __IOM uint32_t reserved0  : 5;            /*!< [15..11] reserved                                                         */
      __IOM uint32_t ac_srx     : 1;            /*!< [16..16] Enable slave-receive-data acknowledge: 0: Do not acknowledge
                                                     receive bytes 1: Acknowledge receive bytes If the slave
                                                     FIFO is full, receive data will not be acknowledged.                      */
      __IOM uint32_t ac_start   : 1;            /*!< [17..17] Enable start sequence acknowledge: If the received
                                                     address matches the sid-bits, the start-byte (2 bytes if
                                                     sid10 is set) will be acknowledged. If the master requests
                                                     a read transfer, a slave FIFO read access will be carried
                                                     out immediately after the acknowledge, i.e. valid data
                                                     must be present in the slave FIFO before enabling the acknowledge.
                                                     If autoreset_ac_start is enabled, the controller will automatically
                                                     reset this bit. If it is not enabled, the software should
                                                     reset this bit after the start sequenc                                    */
      __IOM uint32_t ac_gcall   : 1;            /*!< [18..18] General call acknowledge: 0: Do not generate an acknowledge
                                                     after a general call 1: Generate an acknowledge after a
                                                     general call                                                              */
      __IOM uint32_t reserved1  : 1;            /*!< [19..19] reserved                                                         */
      __IOM uint32_t autoreset_ac_start : 1;    /*!< [20..20] Auto reset ac_start (ac_start must be set again after
                                                     any (r)START): 0: ac_start will not be reset automatically
                                                     (netX 50-compatible, but not recommended) 1: Reset ac_start
                                                     after this slave acknowledged a start sequence (recommended)              */
      __IOM uint32_t reserved2  : 11;           /*!< [31..21] reserved                                                         */
    } i2c_scr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_cmd;                     /*!< (@ 0x00000008) I2C master command register:                               */
    
    struct {
      __IOM uint32_t nwr        : 1;            /*!< [0..0] Transfer direction (not-write/read): 0: cmd will be executed
                                                     as write 1: cmd will be executed as read Master FIFO-requests
                                                     (IRQ and DMA) are generated depending on this direction
                                                     flag.                                                                     */
      __IOM uint32_t cmd        : 3;            /*!< [3..1] I2C sequence command: All commands will generate IRQ
                                                     cmd_ok or IRQ cmd_err. A successful command termination
                                                     will always generate IRQ cmd_ok. In case of an unsuccessful
                                                     command termination, IRQ cmd_err will be set. { | | 000
                                                     START Generate (r)START-condition 001 S_AC Acknowledge-polling:
                                                     generate up to acpollmax+1 START-sequences (until acknowledged
                                                     by slave) 010 S_AC_T Run S_AC, then transfer tsize+1 bytes
                                                     from/to master FIFO. Not to be continued 011 S_AC_TC Run
                                                     S_AC, then tr                                                             */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t tsize      : 10;           /*!< [17..8] Transfer tsize+1 bytes (1...1024): If no acknowledge
                                                     is generated by the slave (receiver), write transfers will
                                                     be terminated and IRQ cmd_err will be generated. For 10-bit-addressing,
                                                     the second start-byte (lower address bits) must be on top
                                                     of the master FIFO. For subsequent transfers, the value
                                                     programmed here has to ignore this byte. This value will
                                                     count down during transfers after each byte. This bit is
                                                     writable, but can also be changed by hardware.                            */
      __IOM uint32_t reserved1  : 2;            /*!< [19..18] reserved                                                         */
      __IOM uint32_t acpollmax  : 8;            /*!< [27..20] Number of tries (acpollmax+1, i.e. 1 to 256) for start
                                                     sequence acknowledge polling: For 7-bit addressing, acknowledge
                                                     polling START and the first byte containing the slave address
                                                     (i2c_mcr.sadr) will be repeated up to acpollmax+1 times
                                                     until a slave generates an acknowledge. If no acknowledge
                                                     is received within acpollmax+1 tries, IRQ cmd_err will
                                                     be generated. For 10-bit-addressing, the 2-byte start sequence
                                                     is performed. The second address byte (lower address bits)
                                                     must be on top of the master FIFO (i2c_                                   */
      __IOM uint32_t reserved2  : 4;            /*!< [31..28] reserved                                                         */
    } i2c_cmd_b;
  } ;
  
  union {
    __IOM uint32_t i2c_mdr;                     /*!< (@ 0x0000000C) I2C master data register (master FIFO): There
                                                                    is only one FIFO for both receive and transmit
                                                                    master data with a depth of 16 bytes. For
                                                                    master write access, data sent by the master
                                                                    is delivered from the FIFO. For master read
                                                                    access, data received by the master is stored
                                                                    in the FIFO. In case of imminent data transfer
                                                                    failure (read transfer and FIFO is full
                                                                    or write transfer and FIFO is empty), the
                                                                    transfer will be interrupted. To continue
                                                                    the transfer, the FIFO must be handled first
                                                                    (filled fo                                                 */
    
    struct {
      __IOM uint32_t mdata      : 8;            /*!< [7..0] I2C master transmit or receive data: Write data will
                                                     be removed from the FIFO after the receiving slave has
                                                     generated the corresponding acknowledge. Write data that
                                                     has not been acknowledged will not be removed from the
                                                     FIFO.                                                                     */
    } i2c_mdr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_sdr;                     /*!< (@ 0x00000010) I2C slave data register (slave FIFO): There is
                                                                    only one FIFO for both receive and transmit
                                                                    slave data with a depth of 16 bytes. For
                                                                    master read access, data sent by the slave
                                                                    is delivered from the FIFO. For master write
                                                                    access, data received by the slave is stored
                                                                    in the FIFO. A transfer is initiated after
                                                                    the detection of I2C-start-sequence to the
                                                                    device address (i2c_scr.sid, sreq IRQ) which
                                                                    is acknowledged by this device (i2c_scr.ac_start).
                                                                    For read transfers, sent data is read from
                                                                    the FI                                                     */
    
    struct {
      __IOM uint32_t sdata      : 8;            /*!< [7..0] I2C slave transmit or receive data: The software must
                                                     handle i2c_scr.ac_start correctly to avoid FIFO errors
                                                     after (r)START.                                                           */
    } i2c_sdr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_mfifo_cr;                /*!< (@ 0x00000014) I2C master FIFO control register:                          */
    
    struct {
      __IOM uint32_t mfifo_wm   : 4;            /*!< [3..0] Master FIFO watermark for the generation of IRQ mfifo_req:
                                                     If the master is the transmitter (enabled and i2c_cmd.nwr
                                                     is 0), IRQ mfifo_req is generated if mfifo_level&lt;mfifo_wm.
                                                     If the master is the receiver (enabled and i2c_cmd.nwr
                                                     is 1), IRQ mfifo_req is generated if mfifo_level&gt;mfifo_wm.
                                                     Note: Set the watermark to 0 at transfer end to avoid further
                                                     IRQ generation.                                                           */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t mfifo_clr  : 1;            /*!< [8..8] Clear master data FIFO, write only bit. This bit is writable,
                                                     but can also be changed by hardware.                                      */
      __IOM uint32_t reserved1  : 23;           /*!< [31..9] reserved                                                          */
    } i2c_mfifo_cr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_sfifo_cr;                /*!< (@ 0x00000018) I2C slave FIFO control register:                           */
    
    struct {
      __IOM uint32_t sfifo_wm   : 4;            /*!< [3..0] Slave FIFO watermark for the generation of IRQ sfifo_req:
                                                     If the slave is the transmitter (start sequence with set
                                                     read bit was acknowledged by this slave), IRQ sfifo_req
                                                     is generated if sfifo_level&lt;sfifo_wm. If the slave is
                                                     not the transmitter (is receiver or not selected), IRQ
                                                     sfifo_req is generated if sfifo_level&gt;sfifo_wm.                        */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t sfifo_clr  : 1;            /*!< [8..8] Clear slave data FIFO, write only bit. This bit is writable,
                                                     but can also be changed by hardware.                                      */
      __IOM uint32_t reserved1  : 23;           /*!< [31..9] reserved                                                          */
    } i2c_sfifo_cr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_sr;                      /*!< (@ 0x0000001C) I2C status register:                                       */
    
    struct {
      __IOM uint32_t mfifo_level : 5;           /*!< [4..0] Master FIFO level (0..16) This is a read-only status
                                                     bit field.                                                                */
      __IOM uint32_t reserved0  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t mfifo_empty : 1;           /*!< [6..6] Master FIFO is empty (1 if empty) This is a read-only
                                                     status bit.                                                               */
      __IOM uint32_t mfifo_full : 1;            /*!< [7..7] Master FIFO is full (1 if full) This is a read-only status
                                                     bit.                                                                      */
      __IOM uint32_t mfifo_err_ovfl : 1;        /*!< [8..8] Master FIFO overflow error occurred. Data is lost and
                                                     the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr.
                                                     Clearing the master FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t mfifo_err_undr : 1;        /*!< [9..9] Master FIFO underrun error occurred. Data is lost and
                                                     the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr.
                                                     Clearing the master FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_level : 5;           /*!< [14..10] Slave FIFO level (0..16) This is a read-only status
                                                     bit field.                                                                */
      __IOM uint32_t reserved1  : 1;            /*!< [15..15] reserved                                                         */
      __IOM uint32_t sfifo_empty : 1;           /*!< [16..16] Slave FIFO is empty (1 if empty) This is a read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_full : 1;            /*!< [17..17] Slave FIFO is full (1 if full) This is a read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_err_ovfl : 1;        /*!< [18..18] Slave FIFO overflow error occurred. Data is lost and
                                                     the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr.
                                                     Clearing the slave FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t sfifo_err_undr : 1;        /*!< [19..19] Slave FIFO underrun error occurred. Data is lost and
                                                     the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr.
                                                     Clearing the slave FIFO will also clear this read-only
                                                     status bit.                                                               */
      __IOM uint32_t bus_master : 1;            /*!< [20..20] Bus arbitration state. 0: Master lost I2C bus arbitration,
                                                     bus is busy by another master. 1: Master gains I2C bus
                                                     arbitration or bus is idle. This read-only status bit is
                                                     set when the monitored bus state does not match the bus
                                                     state expected by the I2C module. The bit is reset, when
                                                     a STOP is detected. This detection will also take place
                                                     while the module is disabled. This is important if there
                                                     are multiple I2C masters on the bus: If another master
                                                     occupies the bus while the I2C module is disabled, the
                                                     I2C                                                                       */
      __IOM uint32_t nwr        : 1;            /*!< [21..21] Transfer direction detected after last (r)START. 0:
                                                     The last start-byte defined a write transfer. 1: The last
                                                     start-byte defined a read transfer. This read-only status
                                                     bit is always reset to 0 during (r)START. This bit is forced
                                                     to '0' when bit i2c_mcr.rst_i2c performs a reset of the
                                                     bus-state-detection logic. Note: This bit does not depend
                                                     on whether the start-byte has been acknowledged or not.                   */
      __IOM uint32_t started    : 1;            /*!< [22..22] START condition detection: 0: The bus is idle (STOP
                                                     was detected, not started). 1: (r)START was detected on
                                                     the bus. The bus is occupied. This detection will also
                                                     take place while the module is disabled. This is important
                                                     if there are multiple I2C masters on the bus: If another
                                                     master occupies the bus while the I2C module is disabled,
                                                     the I2C module must not start a transfer, before the other
                                                     master has released the bus. Use bit i2c_mcr.rst_i2c to
                                                     force this read-only status bit to '0', e.g. in order to
                                                     es                                                                        */
      __IOM uint32_t slave_access : 1;          /*!< [23..23] Slave access state. 0: No slave access to this device.
                                                     1: A master addressed this slave device. This read-only
                                                     status bit is set if a start-byte (2 bytes for 10-bit address)
                                                     containing the address programmed in register i2c_scr.sid
                                                     has been received. This bit is always reset to 0 during
                                                     START or STOP. This bit is forced to '0' when bit i2c_mcr.rst_i2c
                                                     performs a reset of the bus-state-detection logic. Note:
                                                     This bit does not depend on whether the start-byte has
                                                     been acknowledged or not.                                                 */
      __IOM uint32_t last_ac    : 1;            /*!< [24..24] Last acknowledge detected on bus. 0: SDA was high at
                                                     the last acknowledge, i.e. no acknowledge. 1: SDA was low
                                                     at the last acknowledge, i.e. acknowledge. This read-only
                                                     status bit is forced to '0' when bit i2c_mcr.rst_i2c performs
                                                     a reset of the bus-state-detection logic.                                 */
      __IOM uint32_t nwr_aced   : 1;            /*!< [25..25] Transfer direction (nwr-bit) of the last acknowledged
                                                     start-byte (or 2-byte start sequence for 10-bit addressing).
                                                     0: The last acknowledged start-byte defined a write transfer.
                                                     1: The last acknowledged start-byte defined a read transfer.
                                                     Slave FIFO requests generating IRQ and DMA requests depend
                                                     on this direction flag. This read-only status bit is forced
                                                     to '0' when bit i2c_mcr.rst_i2c performs a reset of the
                                                     bus-state-detection logic.                                                */
      __IOM uint32_t gcall_aced : 1;            /*!< [26..26] General call acknowledge state. 0: No general call
                                                     start-byte, or general call start-byte was not acknowledged.
                                                     1: The slave side of the i2c module received and acknowledged
                                                     a general call. Bit i2c_scr.ac_gcall controls the acknowledging
                                                     of a general call. This read-only status bit will be cleared
                                                     automatically if the last start-byte is not a general call
                                                     or if it is a general call but bit i2c_scr.ac_gcall is
                                                     not set. This bit is forced to '0' when the bit i2c_mcr.rst_i2c
                                                     performs a reset of the bus-stat                                          */
      __IOM uint32_t sid10_aced : 1;            /*!< [27..27] 10-bit slave address acknowledge state. { | 0: There
                                                     was no 10-bit slave address or it was not acknowledged.
                                                     1: A 10-bit slave address was broadcasted and a slave acknowledged
                                                     this broadcast. I.e. for the master side: A 10-bit slave
                                                     was addressed and the slave acknowledged. I.e. for the
                                                     slave side: A master broadcasted a start with the address
                                                     programmed in register i2c_scr.sid and the i2c module acknowledged
                                                     this broadcast as bit i2c_scr.ac_start is set.} This read-only
                                                     status bit is cleared automaticall                                        */
      __IOM uint32_t timeout    : 1;            /*!< [28..28] I2C command timeout detection (for I2C master). I2C
                                                     slaves can stretch low SCL phases by holding the SCL line
                                                     low. The master must detect this and wait until the SCL
                                                     line is released before the current transfer can continue.
                                                     In error cases, the I2C bus can be blocked permanently
                                                     by a low signal state of SCL. The reason for the blocking
                                                     can be e.g. a crashed I2C slave or a false I/O configuration.
                                                     To escape from such a situation, a timeout watchdog is
                                                     implemented: A timeout will be detected if the SCL line
                                                                                                                               */
      __IOM uint32_t reserved2  : 1;            /*!< [29..29] reserved                                                         */
      __IOM uint32_t scl_state  : 1;            /*!< [30..30] SCL signal state sampled and filtered from bus (e.g.
                                                     to detect bus blockings) This is a read-only status bit.                  */
      __IOM uint32_t sda_state  : 1;            /*!< [31..31] SDA signal state sampled and filtered from bus (e.g.
                                                     to detect bus blockings) This is a read-only status bit.                  */
    } i2c_sr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_irqmsk;                  /*!< (@ 0x00000020) I2C interrupt mask set or clear register: These
                                                                    bits have AND-mask character. The corresponding
                                                                    IRQ will generate the module IRQ only if
                                                                    the mask bit is set. Changing a mask bit
                                                                    from '0' to '1' will clear the corresponding
                                                                    raw IRQ state. For a detailed IRQ description,
                                                                    see i2c_irqraw.                                            */
    
    struct {
      __IOM uint32_t cmd_ok     : 1;            /*!< [0..0] Command OK interrupt mask                                          */
      __IOM uint32_t cmd_err    : 1;            /*!< [1..1] Command error interrupt mask                                       */
      __IOM uint32_t fifo_err   : 1;            /*!< [2..2] FIFO error interrupt mask                                          */
      __IOM uint32_t bus_busy   : 1;            /*!< [3..3] External I2C-bus is busy interrupt mask                            */
      __IOM uint32_t mfifo_req  : 1;            /*!< [4..4] Master FIFO action request interrupt mask                          */
      __IOM uint32_t sfifo_req  : 1;            /*!< [5..5] Slave FIFO action request interrupt mask                           */
      __IOM uint32_t sreq       : 1;            /*!< [6..6] Slave request interrupt mask                                       */
    } i2c_irqmsk_b;
  } ;
  
  union {
    __IOM uint32_t i2c_irqsr;                   /*!< (@ 0x00000024) I2C interrupt state register (raw interrupt before
                                                                    masking): Writing '1' will clear the corresponding
                                                                    IRQ.                                                       */
    
    struct {
      __IOM uint32_t cmd_ok     : 1;            /*!< [0..0] Unmasked command OK interrupt state: Purpose: Check last
                                                     command termination 1: Last command finished successfully
                                                     0: Command not finished, no command or command finished
                                                     erroneously                                                               */
      __IOM uint32_t cmd_err    : 1;            /*!< [1..1] Unmasked command error interrupt state: Purpose: Check
                                                     last command termination 1: Last command finished erroneously
                                                     0: Command not finished, no command or command finished
                                                     successfully                                                              */
      __IOM uint32_t fifo_err   : 1;            /*!< [2..2] Unmasked FIFO error interrupt state: Purpose: Detect
                                                     FIFO errors/transfer failures 1: FIFO error occurred, check
                                                     register i2c_sr 0: FIFOs ok                                               */
      __IOM uint32_t bus_busy   : 1;            /*!< [3..3] Unmasked external I2C-bus is busy interrupt state: Purpose:
                                                     Detect I2C-bus arbitration loss 1: Master did not gain
                                                     the requested bus access because another master accessed
                                                     the bus 0: Bus is idle or no transfer is requested by this
                                                     master                                                                    */
      __IOM uint32_t mfifo_req  : 1;            /*!< [4..4] Unmasked master FIFO action request interrupt state:
                                                     Purpose: Master FIFO should be updated 1: Master FIFO request:
                                                     i2c_sr.mfifo_level is above or below i2c_mfifo_cr.mfifo_wm
                                                     (see description i2c_mfifo_cr) 0: Master FIFO state not
                                                     critical                                                                  */
      __IOM uint32_t sfifo_req  : 1;            /*!< [5..5] Unmasked slave FIFO action request interrupt state: Purpose:
                                                     Slave FIFO should be updated 1: Slave FIFO request: i2c_sr.sfifo_level
                                                     is above or below i2c_sfifo_cr.sfifo_wm (see description
                                                     i2c_sfifo_cr) 0: Slave FIFO state not critical                            */
      __IOM uint32_t sreq       : 1;            /*!< [6..6] Unmasked slave request interrupt state: Purpose: Set
                                                     up slave FIFO 1: External master was running START-sequence
                                                     and requested this slave 0: Slave is not requested                        */
    } i2c_irqsr_b;
  } ;
  
  union {
    __IM  uint32_t i2c_irqmsked;                /*!< (@ 0x00000028) I2C masked interrupt state register: If one of
                                                                    these bits is set, the I2C IRQ will be set
                                                                    to the interrupt controller. For a detailed
                                                                    IRQ description, see i2c_irqraw.                           */
    
    struct {
      __IM  uint32_t cmd_ok     : 1;            /*!< [0..0] Masked command OK interrupt state                                  */
      __IM  uint32_t cmd_err    : 1;            /*!< [1..1] Masked command error interrupt state                               */
      __IM  uint32_t fifo_err   : 1;            /*!< [2..2] Masked FIFO error interrupt state                                  */
      __IM  uint32_t bus_busy   : 1;            /*!< [3..3] Masked external I2C-bus is busy interrupt state                    */
      __IM  uint32_t mfifo_req  : 1;            /*!< [4..4] Masked master FIFO action request interrupt state                  */
      __IM  uint32_t sfifo_req  : 1;            /*!< [5..5] Masked slave FIFO action request interrupt state                   */
      __IM  uint32_t sreq       : 1;            /*!< [6..6] Masked slave request interrupt state                               */
    } i2c_irqmsked_b;
  } ;
  
  union {
    __IOM uint32_t i2c_dmacr;                   /*!< (@ 0x0000002C) I2C DMA control register: Required settings for
                                                                    the DMA controller: - DMA transfer size
                                                                    to/from I2C module: Byte - DMA burst length
                                                                    to/from I2C module: 4 DMA burst requests
                                                                    will be generated if the corresponding FIFO
                                                                    contains more than 4 bytes (receive case)
                                                                    or if more than 4 bytes are writable to
                                                                    the corresponding FIFO (transmit case).
                                                                    DMA single transfer requests will be generated
                                                                    if the corresponding FIFO contains more
                                                                    than 1 byte (receive case) or if more than
                                                                    1 byte is writable to the c                                */
    
    struct {
      __IOM uint32_t mdmas_en   : 1;            /*!< [0..0] Enable DMA single requests for I2C master data. The I2C
                                                     module is the flow controller (i.e. peripheral-controlled
                                                     flow control). Both, single and burst requests must be
                                                     enabled. This bit is writable, but can also be changed
                                                     by hardware.                                                              */
      __IOM uint32_t mdmab_en   : 1;            /*!< [1..1] Enable DMA burst requests for I2C master data. The I2C
                                                     module is the flow controller (i.e. peripheral-controlled
                                                     flow control). Both, single and burst requests must be
                                                     enabled. This bit is writable, but can also be changed
                                                     by hardware.                                                              */
      __IOM uint32_t sdmas_en   : 1;            /*!< [2..2] Enable DMA single requests for I2C slave data. The DMA
                                                     controller must be the flow controller. This bit is writable,
                                                     but can also be changed by hardware.                                      */
      __IOM uint32_t sdmab_en   : 1;            /*!< [3..3] Enable DMA burst requests for I2C slave data. The DMA
                                                     controller must be the flow controller. This bit is writable,
                                                     but can also be changed by hardware.                                      */
    } i2c_dmacr_b;
  } ;
  
  union {
    __IOM uint32_t i2c_pio;                     /*!< (@ 0x00000030) PIO mode register: This register can directly
                                                                    control the I2C signals SCL and SDA if pio_mode
                                                                    is enabled in register i2c_mcr. In PIO mode,
                                                                    the I2C controller state machine is disabled,
                                                                    thus, no FIFO action takes place, no IRQs
                                                                    will be set, and no DMA-controlling is possible.
                                                                    Note: To avoid external driving conflicts,
                                                                    the I2C signals SCL and SDA are never driven
                                                                    active-high according to the I2C bus specification.
                                                                    The high level of these signals is realized
                                                                    by a pull-up (of the pad or external                       */
    
    struct {
      __IOM uint32_t scl_out    : 1;            /*!< [0..0] Driving level of SCL (1: high, 0: low) if output is enabled
                                                     (scl_oe is set)                                                           */
      __IOM uint32_t scl_oe     : 1;            /*!< [1..1] SCL output enable 0: Do not drive SCL, switch pad to
                                                     high-z. 1: Drive SCL, switch pad to programmed scl_out-state              */
      __IOM uint32_t scl_in_ro  : 1;            /*!< [2..2] SCL input state (read-only)                                        */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t sda_out    : 1;            /*!< [4..4] Driving level of SDA (1: high, 0: low) if output is enabled
                                                     (sda_oe is set)                                                           */
      __IOM uint32_t sda_oe     : 1;            /*!< [5..5] SDA output enable 0: Do not drive SDA, switch pad to
                                                     high-z. 1: Drive SDA, switch pad to programmed sda_out-state              */
      __IOM uint32_t sda_in_ro  : 1;            /*!< [6..6] SDA input state (read-only)                                        */
      __IOM uint32_t reserved1  : 25;           /*!< [31..7] reserved                                                          */
    } i2c_pio_b;
  } ;
} i2c_xpic_app_Type;                            /*!< Size = 52 (0x34)                                                          */



/* =========================================================================================================================== */
/* ================                                       spi_xpic_app                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief spi_xpic_app (spi_xpic_app)
  */

typedef struct {                                /*!< (@ 0xFF900380) spi_xpic_app Structure                                     */
  
  union {
    __IOM uint32_t spi_cr0;                     /*!< (@ 0x00000000) SPI control register 0 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t datasize   : 4;            /*!< [3..0] DSS: data size select (transfer size = datasize + 1 bits):
                                                     { | 0000...0010: reserved 0011: 4 bit 0100: 5 bit ... 0111:
                                                     8 bit ... 1111: 16 bit } Note: 16 bit TX-data-loss bug
                                                     of netX50/netX5 is fixed since netX10.                                    */
      __IOM uint32_t reserved0  : 2;            /*!< [5..4] reserved                                                           */
      __IOM uint32_t SPO        : 1;            /*!< [6..6] Serial clock polarity (netx500: CR_cpol): 0: idle: clock
                                                     is low, first edge is rising 1: idle: clock is high, first
                                                     edge is falling                                                           */
      __IOM uint32_t SPH        : 1;            /*!< [7..7] Serial clock phase (netx500: CR_ncpha): 1: sample data
                                                     at second clock edge, data is generated half a clock phase
                                                     before sampling 0: sample data at first clock edge, data
                                                     is generated half a clock phase before sampling                           */
      __IOM uint32_t sck_muladd : 12;           /*!< [19..8] Serial clock rate multiply add value for master SCK
                                                     generation. The SPI clock frequency is: f_spi_sck = (sck_muladd
                                                     * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI
                                                     clock rate. All serial clock rates are derived from 100MHz
                                                     netX system clock. Hence, all serial clock phases are multiples
                                                     of 10ns. This leads to non-constant serial clock phases
                                                     when a clock rate is programmed which cannot be generated
                                                     by 100MHz/(2*n) without remainder. E.g. programming 0x4CC
                                                     here will lead to a mean clock-rate of 30MHz                              */
      __IOM uint32_t reserved1  : 4;            /*!< [23..20] reserved                                                         */
      __IOM uint32_t format     : 2;            /*!< [25..24] Frame format: 00: Motorola SPI frame format 01..11:
                                                     reserved                                                                  */
      __IOM uint32_t reserved2  : 1;            /*!< [26..26] reserved                                                         */
      __IOM uint32_t filter_in  : 1;            /*!< [27..27] Receive data is sampled every 10ns (100MHz system clock).
                                                     If this bit is set, the stored receive value will be the
                                                     result of a majority decision of the three sampling points
                                                     around a SPI-clock edge (if two or more '1s! were sampled
                                                     a '1' will be stored, else a '0' will be stored. In slave
                                                     mode chip-select and SCK edges will also be detected by
                                                     oversampling if this bit is set: An edge will be detected
                                                     if the majority-result of 3 subsequent sampled values toggles.
                                                     Input filtering should be used for sck_mulad                              */
      __IOM uint32_t slave_sig_early : 1;       /*!< [28..28] Generate MISO in slave mode 1 SCK clock edge earlier
                                                     than defined in the SPI specification. This is to compensate
                                                     pad or sampling delays on fast data rates. However, hold
                                                     timing problems could come up as MISO is generated very
                                                     fast after the sampling SPI clock edge. If filter_in is
                                                     enabled, it takes at least 3 system clocks to generate
                                                     MISO after SCK. If filter_in is disabled, it takes at least
                                                     2 system clocks to generate MISO after SCK.                               */
      __IOM uint32_t reserved3  : 2;            /*!< [30..29] reserved                                                         */
      __IOM uint32_t netx100_comp : 1;          /*!< [31..31] Use netx100/500-compatible SPI mode: 0: start transfer
                                                     after writing data 1: start transfer after setting CR_write
                                                     or CR_read                                                                */
    } spi_cr0_b;
  } ;
  
  union {
    __IOM uint32_t spi_cr1;                     /*!< (@ 0x00000004) SPI control register 1 Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.          */
    
    struct {
      __IOM uint32_t LBM        : 1;            /*!< [0..0] Loop back mode: 0: Internal loop back disabled 1: Internal
                                                     loop back enabled, spi_cr0.filter_in must be set for loopback
                                                     function                                                                  */
      __IOM uint32_t SSE        : 1;            /*!< [1..1] SPI enable: 0: Module disabled 1: Module enabled                   */
      __IOM uint32_t MS         : 1;            /*!< [2..2] Mode select: 0: Module is configured as master 1: Module
                                                     is configured as slave                                                    */
      __IOM uint32_t SOD        : 1;            /*!< [3..3] Slave mode output disable (to connect multiple slaves
                                                     to one master): 0: MISO can be driven in slave mode 1:
                                                     MISO is not driven in slave mode                                          */
      __IOM uint32_t reserved0  : 4;            /*!< [7..4] reserved                                                           */
      __IOM uint32_t fss        : 3;            /*!< [10..8] Frame or slave select. There are up to 3 external SPI
                                                     chip-select signals. In master mode, the fss bits define
                                                     the states of the chip-select signals. The inversion for
                                                     low-active chip-selects (e.g. for Motorola SPI frame format)
                                                     is done automatically depending on the value programmed
                                                     to the 'format' bits. Example: To use the netX IO CS1 as
                                                     chip-select, program '010' here, regardless whether the
                                                     external chip-select is low or high active. In slave mode,
                                                     the fss bits are a mask to select which netX input sho                    */
      __IOM uint32_t fss_static : 1;            /*!< [11..11] SPI static chip-select: { | 0: SPI chip-select will
                                                     be toggled automatically before and after each transferred
                                                     word according to fss and datasize. 1: SPI chip-select
                                                     will be set statically according to the fss bits. }                       */
      __IOM uint32_t reserved1  : 4;            /*!< [15..12] reserved                                                         */
      __IOM uint32_t tx_fifo_wm : 4;            /*!< [19..16] Transmit FIFO watermark for IRQ generation                       */
      __IOM uint32_t tx_fifo_clr : 1;           /*!< [20..20] Writing '1' to this bit will clear the transmit FIFOs.
                                                     Note: There must be at least 1 system clock idle after
                                                     clear before writing new data to the FIFO. This is guaranteed
                                                     by the netX internal bus structure and needs not being
                                                     considered by software.                                                   */
      __IOM uint32_t reserved2  : 3;            /*!< [23..21] reserved                                                         */
      __IOM uint32_t rx_fifo_wm : 4;            /*!< [27..24] Receive FIFO watermark for IRQ generation                        */
      __IOM uint32_t rx_fifo_clr : 1;           /*!< [28..28] Writing '1' to this bit will clear the receive FIFOs.            */
      __IOM uint32_t reserved3  : 3;            /*!< [31..29] reserved                                                         */
    } spi_cr1_b;
  } ;
  
  union {
    __IOM uint32_t spi_dr;                      /*!< (@ 0x00000008) SPI data register Registers 0x30..0x3C can be
                                                                    used instead of registers 0x00...0x24 to
                                                                    keep netx50 software compliant to netx100/500.
                                                                    The SPI module has 2 FIFOs: One for transmit
                                                                    data and one for receive data. Read access:
                                                                    Received data byte is delivered from receive
                                                                    FIFO. Write access: Transmit data byte is
                                                                    written to send FIFO. Both FIFOs (receive
                                                                    and transmit) have a depth of 16. SPI master
                                                                    mode: MISO input data will be stored in
                                                                    the receive FIFO; transmit FIFO generates
                                                                    MOSI output data.                                          */
    
    struct {
      __IOM uint32_t data       : 17;           /*!< [16..0] Transmit data: Only lowest bits according to spi_cr0.datasize
                                                     will be sent. Receive data will be delivered on the lowest
                                                     bits, unused bits (above spi_cr0.datasize) will be '0'.
                                                     In slave mode transmit data is requested from the FIFO
                                                     when the last bit of the currently transferred word is
                                                     set to the MISO signal. If no next transmit data can be
                                                     read from the FIFO until the current word's last bit was
                                                     transferred, a FIFO underrun will occur in case chip-select
                                                     does not go inactive at the next detected SCK edge.                       */
    } spi_dr_b;
  } ;
  
  union {
    __IM  uint32_t spi_sr;                      /*!< (@ 0x0000000C) SPI status register Registers 0x30..0x3C can
                                                                    be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t TFE        : 1;            /*!< [0..0] Transmit FIFO is empty (1 if empty)                                */
      __IM  uint32_t TNF        : 1;            /*!< [1..1] Transmit FIFO is not full (0 if full)                              */
      __IM  uint32_t RNE        : 1;            /*!< [2..2] Receive FIFO is not empty (0 if empty)                             */
      __IM  uint32_t RFF        : 1;            /*!< [3..3] Receive FIFO is full (1 if full)                                   */
      __IM  uint32_t BSY        : 1;            /*!< [4..4] Device busy (1 if data is currently transmitted/received
                                                     or the transmit FIFO is not empty)                                        */
      __IM  uint32_t reserved0  : 11;           /*!< [15..5] reserved                                                          */
      __IM  uint32_t tx_fifo_level : 5;         /*!< [20..16] Transmit FIFO level (number of words to transmit are
                                                     left in FIFO)                                                             */
      __IM  uint32_t reserved1  : 1;            /*!< [21..21] reserved                                                         */
      __IM  uint32_t tx_fifo_err_ovfl : 1;      /*!< [22..22] Transmit FIFO overflow error occurred, data is lost              */
      __IM  uint32_t tx_fifo_err_undr : 1;      /*!< [23..23] Transmit FIFO underrun error occurred, data is lost              */
      __IM  uint32_t rx_fifo_level : 5;         /*!< [28..24] Receive FIFO level (number of received words to read
                                                     out are left in FIFO)                                                     */
      __IM  uint32_t reserved2  : 1;            /*!< [29..29] reserved                                                         */
      __IM  uint32_t rx_fifo_err_ovfl : 1;      /*!< [30..30] Receive FIFO overflow error occurred, data is lost               */
      __IM  uint32_t rx_fifo_err_undr : 1;      /*!< [31..31] Receive FIFO underrun error occurred, data is lost               */
    } spi_sr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t spi_imsc;                    /*!< (@ 0x00000014) SPI Interrupt Mask Set and Clear register: Registers
                                                                    0x30..0x3C can be used instead of registers
                                                                    0x00...0x24 to keep netx50 software compliant
                                                                    to netx100/500. IRQ mask is an AND-mask:
                                                                    only raw interrupts with mask bit set can
                                                                    generate a module IRQ. When writing this
                                                                    register, the corresponding interrupt is
                                                                    cleared similar to writing the register
                                                                    spi_icr. Note: The functionality of this
                                                                    register is similar to the corresponding
                                                                    SQI register sqi_irq_mask. However, in contrast
                                                                    to this register,                                          */
    
    struct {
      __IOM uint32_t RORIM      : 1;            /*!< [0..0] Receive FIFO overrun interrupt mask                                */
      __IOM uint32_t RTIM       : 1;            /*!< [1..1] Receive timeout interrupt mask                                     */
      __IOM uint32_t RXIM       : 1;            /*!< [2..2] Receive FIFO interrupt mask                                        */
      __IOM uint32_t TXIM       : 1;            /*!< [3..3] Transmit FIFO interrupt mask                                       */
      __IOM uint32_t rxneim     : 1;            /*!< [4..4] Receive FIFO not empty interrupt mask (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfim      : 1;            /*!< [5..5] Receive FIFO full interrupt mask (for netx100/500 compliance)      */
      __IOM uint32_t txeim      : 1;            /*!< [6..6] Transmit FIFO empty interrupt mask (for netx100/500 compliance)    */
    } spi_imsc_b;
  } ;
  
  union {
    __IM  uint32_t spi_ris;                     /*!< (@ 0x00000018) SPI interrupt state before masking register (raw
                                                                    interrupt) Registers 0x30..0x3C can be used
                                                                    instead of registers 0x00...0x24 to keep
                                                                    netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORRIS     : 1;            /*!< [0..0] Unmasked receive FIFO overrun interrupt state 1: receive
                                                     FIFO overrun error occurred 0: no receive FIFO overrun
                                                     error occurred                                                            */
      __IM  uint32_t RTRIS      : 1;            /*!< [1..1] Unmasked receive timeout interrupt state Timeout period
                                                     are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd
                                                     1: receive FIFO is not empty and not read out in the passed
                                                     timeout period 0: receive FIFO is empty or read during
                                                     the last timeout period                                                   */
      __IM  uint32_t RXRIS      : 1;            /*!< [2..2] Unmasked receive FIFO interrupt state 1: receive FIFO
                                                     is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals
                                                     or is below spi_cr1.rx_fifo_wm                                            */
      __IM  uint32_t TXRIS      : 1;            /*!< [3..3] Unmasked transmit FIFO interrupt state 1: transmit FIFO
                                                     level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals
                                                     or is higher than spi_cr1.tx_fifo_wm                                      */
      __IM  uint32_t rxneris    : 1;            /*!< [4..4] Unmasked receive FIFO not empty interrupt state (for
                                                     netx100/500 compliance) 1: receive FIFO is not empty 0:
                                                     receive FIFO is empty                                                     */
      __IM  uint32_t rxfris     : 1;            /*!< [5..5] Unmasked receive FIFO full interrupt state (for netx100/500
                                                     compliance) 1: receive FIFO is full 0: receive FIFO is
                                                     not full                                                                  */
      __IM  uint32_t txeris     : 1;            /*!< [6..6] Unmasked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance) 1: transmit FIFO is empty 0: transmit FIFO
                                                     is not empty                                                              */
    } spi_ris_b;
  } ;
  
  union {
    __IM  uint32_t spi_mis;                     /*!< (@ 0x0000001C) SPI interrupt status register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    Note: Both FIFOs (receive and transmit)
                                                                    have a depth of 16.                                        */
    
    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< [0..0] Masked receive FIFO overrun interrupt state                        */
      __IM  uint32_t RTMIS      : 1;            /*!< [1..1] Masked receive timeout interrupt state                             */
      __IM  uint32_t RXMIS      : 1;            /*!< [2..2] Masked receive FIFO interrupt state                                */
      __IM  uint32_t TXMIS      : 1;            /*!< [3..3] Masked transmit FIFO interrupt state                               */
      __IM  uint32_t rxnemis    : 1;            /*!< [4..4] Masked receive FIFO not empty interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t rxfmis     : 1;            /*!< [5..5] Masked receive FIFO full interrupt state (for netx100/500
                                                     compliance)                                                               */
      __IM  uint32_t txemis     : 1;            /*!< [6..6] Masked transmit FIFO empty interrupt state (for netx100/500
                                                     compliance)                                                               */
    } spi_mis_b;
  } ;
  
  union {
    __IOM uint32_t spi_icr;                     /*!< (@ 0x00000020) SPI interrupt clear register Registers 0x30..0x3C
                                                                    can be used instead of registers 0x00...0x24
                                                                    to keep netx50 software compliant to netx100/500.
                                                                    An interrupt is cleared by writing '1' to
                                                                    the according bit. Note: Both FIFOs (receive
                                                                    and transmit) have a depth of 16.                          */
    
    struct {
      __IOM uint32_t RORIC      : 1;            /*!< [0..0] Clear receive FIFO overrun interrupt Writing '1' here
                                                     will clear the receive FIFO                                               */
      __IOM uint32_t RTIC       : 1;            /*!< [1..1] Clear receive FIFO overrun interrupt                               */
      __IOM uint32_t RXIC       : 1;            /*!< [2..2] PL022 extension: clear receive FIFO interrupt                      */
      __IOM uint32_t TXIC       : 1;            /*!< [3..3] PL022 extension: clear transmit FIFO interrupt                     */
      __IOM uint32_t rxneic     : 1;            /*!< [4..4] Clear receive FIFO not empty interrupt (for netx100/500
                                                     compliance)                                                               */
      __IOM uint32_t rxfic      : 1;            /*!< [5..5] Clear receive FIFO full interrupt (for netx100/500 compliance)     */
      __IOM uint32_t txeic      : 1;            /*!< [6..6] Clear transmit FIFO empty interrupt (for netx100/500
                                                     compliance)                                                               */
    } spi_icr_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t spi_dmacr;                   /*!< (@ 0x00000028) SPI DMA control register                                   */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Enable DMA for SPI receive data. A single request will
                                                     be generated if the receive FIFO is not empty and spi_cr1.SSE
                                                     (module enable) is set. Burst request to the DMA controller
                                                     will be generated if the receive FIFO contains at least
                                                     4 words (set DMA burst size to 4). If this bit is reset
                                                     or the module is disabled, the DMA request signals will
                                                     also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst
                                                     size: 4) in the DMA controller.                                           */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Enable DMA for SPI transmit data. A single request will
                                                     be generated if the transmit FIFO is not full and spi_cr1.SSE
                                                     (module enable) is set. Burst requests to the DMA controller
                                                     will be generated if at least 4 words are writable to the
                                                     transmit FIFO (set DMA burst size to 4). If this bit is
                                                     reset or the module is disabled, the DMA request signals
                                                     will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e.
                                                     burst size: 4) in the DMA controller.                                     */
    } spi_dmacr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t spi_data_register;           /*!< (@ 0x00000030) netx100/500 compliant SPI data register (DR)
                                                                    Registers 0x30..0x3C can be used instead
                                                                    of registers 0x00...0x24 to keep netx50
                                                                    software compliant to netx100/500. 2 data
                                                                    bytes with valid bits. During a write access
                                                                    data_byte_1 and dr_valid1 must not be used.
                                                                    dr_valid0 must be set. In netx50 and later
                                                                    versions both FIFOs (receive and transmit)
                                                                    have a depth of 16, fill values are fixed
                                                                    to 4. To keep software compatible, not more
                                                                    than 8 bytes should be in netx100/500 FIFOs.               */
    
    struct {
      __IOM uint32_t data_byte_0 : 8;           /*!< [7..0] Data byte 0                                                        */
      __IOM uint32_t data_byte_1 : 8;           /*!< [15..8] Obsolete, don't use                                               */
      __IOM uint32_t dr_valid0  : 1;            /*!< [16..16] Valid bit for data_byte_0 This bit shows if data_byte_0
                                                     is valid and must be set during a FIFO write access.                      */
      __IOM uint32_t dr_valid1  : 1;            /*!< [17..17] Obsolete, always 0                                               */
    } spi_data_register_b;
  } ;
  
  union {
    __IM  uint32_t spi_status_register;         /*!< (@ 0x00000034) netx100/500 compliant SPI status register (SR):
                                                                    Shows the actual status of the SPI interface.
                                                                    Bits 24..18 show occurred interrupts; writing
                                                                    ones into these bits clears the interrupts.
                                                                    Writing into other bits has no effect. In
                                                                    netx50 and later versions both FIFOs (receive
                                                                    and transmit) have a depth of 16, fill values
                                                                    are fixed to 4. To keep software compatible,
                                                                    not more than 8 bytes should be in netx100/500
                                                                    FIFOs.                                                     */
    
    struct {
      __IM  uint32_t SR_in_fuel_val : 9;        /*!< [8..0] Input FIFO fill value (number of bytes)                            */
      __IM  uint32_t SR_out_fuel_val : 9;       /*!< [17..9] Output FIFO fill value (number of bytes)                          */
      __IM  uint32_t SR_in_fuel : 1;            /*!< [18..18] Adjustable fill value of input FIFO reached (equals
                                                     spi_ris.RXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_in_recdata : 1;         /*!< [19..19] Valid data bytes in input FIFO (equals spi_ris.rxneris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_in_full : 1;            /*!< [20..20] Input FIFO is full (equals spi_ris.rxfris in netx50
                                                     and later versions)                                                       */
      __IM  uint32_t SR_out_fuel : 1;           /*!< [21..21] Adjustable fill value of output FIFO reached (equals
                                                     spi_ris.TXRIS in netx50 and later versions)                               */
      __IM  uint32_t SR_out_fw  : 1;            /*!< [22..22] netX is writing data too fast into output FIFO. Available
                                                     as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl
                                                     in netx50 and later versions).                                            */
      __IM  uint32_t SR_out_empty : 1;          /*!< [23..23] Output FIFO is empty in slave mode (equals spi_ris.txeris
                                                     in netx50 and later versions)                                             */
      __IM  uint32_t SR_out_full : 1;           /*!< [24..24] Output FIFO is full. This is only with netx100/500
                                                     an IRQ.                                                                   */
      __IM  uint32_t SR_selected : 1;           /*!< [25..25] External master has access to SPI interface                      */
    } spi_status_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_control_register;        /*!< (@ 0x00000038) netx100/500 compliant SPI control register (CR)            */
    
    struct {
      __IOM uint32_t CR_softreset : 1;          /*!< [0..0] write only: no function in netx100/netx500; later versions:
                                                     clears IRQs and FIFOs                                                     */
      __IOM uint32_t CR_speed   : 4;            /*!< [4..1] Clock divider for SPI clock (2 - 2^16) If SPI clock rate
                                                     is changed using spi_cr0.sck_muladd, this value will not
                                                     be updated and may be incorrect There are 16 different
                                                     SPI clocks frequencies to choose: 0000: 0.025 MHz (Note:
                                                     Not compatible to netx100/500. '0000' freezes SCK in netx100/500.)
                                                     0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz
                                                     0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001:
                                                     3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101:
                                                     16.6666 MHz 1110: 25 MHz 1111: 50 MHz                                     */
      __IOM uint32_t reserved0  : 1;            /*!< [5..5] reserved                                                           */
      __IOM uint32_t CR_read    : 1;            /*!< [6..6] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface read data                                            */
      __IOM uint32_t CR_write   : 1;            /*!< [7..7] netx100/netx500 only, in later versions always '1': 1:
                                                     enable SPI interface write data                                           */
      __IOM uint32_t CR_ss      : 3;            /*!< [10..8] External slave select                                             */
      __IOM uint32_t CS_mode    : 1;            /*!< [11..11] 1: chip select is generated automatically by the internal
                                                     state machine 0: chip select is directly controlled by
                                                     software (see bits CR_ss).                                                */
      __IOM uint32_t reserved1  : 8;            /*!< [19..12] reserved                                                         */
      __IOM uint32_t CR_clr_infifo : 1;         /*!< [20..20] Clear input FIFO                                                 */
      __IOM uint32_t CR_clr_outfifo : 1;        /*!< [21..21] Clear output FIFO                                                */
      __IOM uint32_t CR_burstdelay : 3;         /*!< [24..22] netx100/netx500 only, obsolete in later versions: delay
                                                     between transmission of 2 data bytes (0 to 7 SCK cycles)                  */
      __IOM uint32_t CR_burst   : 3;            /*!< [27..25] netx100/netx500 only, obsolete in later versions: burst
                                                     length = 2^CR_burst                                                       */
      __IOM uint32_t CR_ncpha   : 1;            /*!< [28..28] SPI clock phase mode (Note: meaning of this bit is
                                                     inverted to functionality of bit spi_cr0.SPH): { | 0: change
                                                     data on secondary SCK edge data is active on primary SCK
                                                     edge 1: change data on primary SCK edge data is active
                                                     on secondary SCK edge }                                                   */
      __IOM uint32_t CR_cpol    : 1;            /*!< [29..29] 1: falling edge of SCK is primary 0: rising edge of
                                                     SCK is primary                                                            */
      __IOM uint32_t CR_ms      : 1;            /*!< [30..30] 1: master mode 0:slave mode                                      */
      __IOM uint32_t CR_en      : 1;            /*!< [31..31] 1: enable 0: disable SPI interface                               */
    } spi_control_register_b;
  } ;
  
  union {
    __IOM uint32_t spi_interrupt_control_register;/*!< (@ 0x0000003C) netx100/500 compliant SPI interrupt control register
                                                                    (IR) In netx50 and later versions both FIFOs
                                                                    (receive and transmit) have a depth of 16,
                                                                    fill values are fixed to 4. To keep software
                                                                    compatible, not more than 8 bytes should
                                                                    be in netx100/500 FIFOs.                                   */
    
    struct {
      __IOM uint32_t IR_in_fuel : 9;            /*!< [8..0] Adjustable watermark level of input FIFO                           */
      __IOM uint32_t IR_out_fuel : 9;           /*!< [17..9] Adjustable watermark level of output FIFO                         */
      __IOM uint32_t IR_in_fuel_en : 1;         /*!< [18..18] IRQ enable for irq_spi(0) (equals spi_imsc.RXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_recdata_en : 1;      /*!< [19..19] IRQ enable for irq_spi(1) (equals spi_imsc.txneim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_in_full_en : 1;         /*!< [20..20] IRQ enable for irq_spi(2) (equals spi_imsc.txfim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fuel_en : 1;        /*!< [21..21] IRQ enable for irq_spi(3) (equals spi_imsc.TXIM in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_fw_en : 1;          /*!< [22..22] IRQ enable for irq_spi(4), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
      __IOM uint32_t IR_out_empty_en : 1;       /*!< [23..23] IRQ enable for irq_spi(5) (equals spi_imsc.rxeim in
                                                     netx50 and later versions)                                                */
      __IOM uint32_t IR_out_full_en : 1;        /*!< [24..24] IRQ enable for irq_spi(6), netx100/netx500 only, always
                                                     '0' in later versions                                                     */
    } spi_interrupt_control_register_b;
  } ;
} spi_xpic_app_Type;                            /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink0 (xlink0)
  */

typedef struct {                                /*!< (@ 0xFF900400) xlink0 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink0_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink1 (xlink1)
  */

typedef struct {                                /*!< (@ 0xFF900410) xlink1 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink1_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink2                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink2 (xlink2)
  */

typedef struct {                                /*!< (@ 0xFF900420) xlink2 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink2_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink3                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink3 (xlink3)
  */

typedef struct {                                /*!< (@ 0xFF900430) xlink3 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink3_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink4                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink4 (xlink4)
  */

typedef struct {                                /*!< (@ 0xFF900440) xlink4 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink4_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink5                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink5 (xlink5)
  */

typedef struct {                                /*!< (@ 0xFF900450) xlink5 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink5_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink6                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink6 (xlink6)
  */

typedef struct {                                /*!< (@ 0xFF900460) xlink6 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink6_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          xlink7                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief xlink7 (xlink7)
  */

typedef struct {                                /*!< (@ 0xFF900470) xlink7 Structure                                           */
  
  union {
    __IOM uint32_t xlink_cfg;                   /*!< (@ 0x00000000) configuration register                                     */
    
    struct {
      __IOM uint32_t rate_inc   : 16;           /*!< [15..0] bitrate compare value for bit clock counter (bit_cnt)
                                                     BITRATE = 100e6/(rate_inc) typical settings for IOLINK:
                                                     {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE
                                                     4800 | 0x5160 | 208,33 us | 208,3333us 38400 | 0xa2b |
                                                     26,04 us | 26,04167us 230400 | 0x1b1 | 4,34 us | 4,340278us
                                                     ... | | invalid: 0 | 0 | 0 | 0 }                                          */
      __IOM uint32_t xlink_en   : 1;            /*!< [16..16] disable the output enable, and activity                          */
      __IOM uint32_t fb_en      : 1;            /*!< [17..17] test feature, enable internal feedback                           */
      __IOM uint32_t bclk2oe_en : 1;            /*!< [18..18] test feature, do not set this bit!                               */
      __IOM uint32_t cnt_da     : 1;            /*!< [19..19] test feature, do not set this bit!                               */
      __IOM uint32_t bits2rec   : 4;            /*!< [23..20] count of bits to receive note: the reset value expect:
                                                     1stopbit, 8databits, 1paritybit and 1stopbit                              */
      __IOM uint32_t start_spl  : 4;            /*!< [27..24] start sample point for receive data a sample period
                                                     is defined as 1/16 of the bitrate period range: 0x0 - 0xf
                                                     note: settings for start_spl and end_spl should always
                                                     fulfill the condition: (start_spl &lt; end_spl)                           */
      __IOM uint32_t end_spl    : 4;            /*!< [31..28] end sample point for receive data                                */
    } xlink_cfg_b;
  } ;
  
  union {
    __IOM uint32_t xlink_tx;                    /*!< (@ 0x00000004) xlink transmit register                                    */
    
    struct {
      __IOM uint32_t hold       : 16;           /*!< [15..0] hold register format for a valid serial DATA sequence:
                                                     &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA
                                                     --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS
                                                     max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware
                                                     marker to stop the shifting, and will not be transmitted.
                                                     this condition implied, than all other not used bits should
                                                     be zero                                                                   */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] TX buffer ready (valid on ready) 0 TX buffer not ready
                                                     1 TX buffer ready                                                         */
      __IOM uint32_t idle_ro    : 1;            /*!< [17..17] indicates no activity on tx                                      */
    } xlink_tx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_rx;                    /*!< (@ 0x00000008) xlink RX register writing to the register, reset
                                                                    the ready bit, the overflow bit and the
                                                                    sampling error bit                                         */
    
    struct {
      __IOM uint32_t hold_ro    : 16;           /*!< [15..0] RX byte (when valid) hold[15:0] is used to shift in
                                                     RX(LSB first!) the amount of shifted bits is defined by
                                                     bits2rec shift order is bit15 downto bit0                                 */
      __IOM uint32_t rdy_ro     : 1;            /*!< [16..16] RX buffer ready (valid on ready) 0 RX buffer not ready
                                                     1 RX buffer ready                                                         */
      __IOM uint32_t reserved0  : 2;            /*!< [18..17] reserved                                                         */
      __IOM uint32_t rxd_ro     : 1;            /*!< [19..19] current status of rx data                                        */
      __IOM uint32_t ovf_err_ro : 1;            /*!< [20..20] overflow error on received data                                  */
      __IOM uint32_t spl_err_ro : 1;            /*!< [21..21] sampling error detected if the amount of sampled bits
                                                     (HI or LOW) do not fulfill the condition: (end_spl - start_spl)
                                                     &lt; (count of HI/LOW bits)                                               */
      __IOM uint32_t reserved1  : 10;           /*!< [31..22] reserved                                                         */
    } xlink_rx_b;
  } ;
  
  union {
    __IOM uint32_t xlink_stat;                  /*!< (@ 0x0000000C) xlink status register & io control writing to
                                                                    this register set the bit clock counter
                                                                    to zero!                                                   */
    
    struct {
      __IOM uint32_t bit_cnt_ro : 16;           /*!< [15..0] status of bit clock counter                                       */
      __IOM uint32_t bit_clk_ro : 1;            /*!< [16..16] status of bit clock signal                                       */
      __IOM uint32_t txo_ro     : 1;            /*!< [17..17] status of tx output                                              */
      __IOM uint32_t rxo_ro     : 1;            /*!< [18..18] status of rx input                                               */
      __IOM uint32_t txoe_ro    : 1;            /*!< [19..19] status of tx output enable                                       */
      __IOM uint32_t io_mode    : 1;            /*!< [20..20] enable the io mode on tx and wakeup 0 : disable io
                                                     function on tx, txoe, wakeup 1 : enable io function on
                                                     tx, txoe, wakeup                                                          */
      __IOM uint32_t set_tx     : 1;            /*!< [21..21] set the tx port,                                                 */
      __IOM uint32_t set_txoe   : 1;            /*!< [22..22] set the tx output enable                                         */
      __IOM uint32_t set_wakeup : 1;            /*!< [23..23] set the wakeup port                                              */
      __IOM uint32_t filter_en  : 1;            /*!< [24..24] enable 3 majority ruling filter                                  */
    } xlink_stat_b;
  } ;
} xlink7_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                        io_link_irq                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief io_link_irq (io_link_irq)
  */

typedef struct {                                /*!< (@ 0xFF900480) io_link_irq Structure                                      */
  
  union {
    __IOM uint32_t io_link_irq_raw;             /*!< (@ 0x00000000) IO-Link raw interrupts: Read access shows status
                                                                    of unmasked IRQs. IRQs are set automatically
                                                                    and reset by writing to this register: Write
                                                                    access with '1' resets the appropriate IRQ.
                                                                    Write access with '0' does not influence
                                                                    this bit.                                                  */
    
    struct {
      __IOM uint32_t xlink0_tx_next : 1;        /*!< [0..0] tx_next interrupt                                                  */
      __IOM uint32_t xlink0_rx_next : 1;        /*!< [1..1] rx_next interrupt                                                  */
      __IOM uint32_t xlink0_shift_en : 1;       /*!< [2..2] shift_en interrupt                                                 */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t xlink1_tx_next : 1;        /*!< [4..4] tx_next interrupt                                                  */
      __IOM uint32_t xlink1_rx_next : 1;        /*!< [5..5] rx_next interrupt                                                  */
      __IOM uint32_t xlink1_shift_en : 1;       /*!< [6..6] shift_en interrupt                                                 */
      __IOM uint32_t reserved1  : 1;            /*!< [7..7] reserved                                                           */
      __IOM uint32_t xlink2_tx_next : 1;        /*!< [8..8] tx_next interrupt                                                  */
      __IOM uint32_t xlink2_rx_next : 1;        /*!< [9..9] rx_next interrupt                                                  */
      __IOM uint32_t xlink2_shift_en : 1;       /*!< [10..10] shift_en interrupt                                               */
      __IOM uint32_t reserved2  : 1;            /*!< [11..11] reserved                                                         */
      __IOM uint32_t xlink3_tx_next : 1;        /*!< [12..12] tx_next interrupt                                                */
      __IOM uint32_t xlink3_rx_next : 1;        /*!< [13..13] rx_next interrupt                                                */
      __IOM uint32_t xlink3_shift_en : 1;       /*!< [14..14] shift_en interrupt                                               */
      __IOM uint32_t reserved3  : 1;            /*!< [15..15] reserved                                                         */
      __IOM uint32_t xlink4_tx_next : 1;        /*!< [16..16] tx_next interrupt                                                */
      __IOM uint32_t xlink4_rx_next : 1;        /*!< [17..17] rx_next interrupt                                                */
      __IOM uint32_t xlink4_shift_en : 1;       /*!< [18..18] shift_en interrupt                                               */
      __IOM uint32_t reserved4  : 1;            /*!< [19..19] reserved                                                         */
      __IOM uint32_t xlink5_tx_next : 1;        /*!< [20..20] tx_next interrupt                                                */
      __IOM uint32_t xlink5_rx_next : 1;        /*!< [21..21] rx_next interrupt                                                */
      __IOM uint32_t xlink5_shift_en : 1;       /*!< [22..22] shift_en interrupt                                               */
      __IOM uint32_t reserved5  : 1;            /*!< [23..23] reserved                                                         */
      __IOM uint32_t xlink6_tx_next : 1;        /*!< [24..24] tx_next interrupt                                                */
      __IOM uint32_t xlink6_rx_next : 1;        /*!< [25..25] rx_next interrupt                                                */
      __IOM uint32_t xlink6_shift_en : 1;       /*!< [26..26] shift_en interrupt                                               */
      __IOM uint32_t reserved6  : 1;            /*!< [27..27] reserved                                                         */
      __IOM uint32_t xlink7_tx_next : 1;        /*!< [28..28] tx_next interrupt                                                */
      __IOM uint32_t xlink7_rx_next : 1;        /*!< [29..29] rx_next interrupt                                                */
      __IOM uint32_t xlink7_shift_en : 1;       /*!< [30..30] shift_en interrupt                                               */
      __IOM uint32_t reserved7  : 1;            /*!< [31..31] reserved                                                         */
    } io_link_irq_raw_b;
  } ;
  
  union {
    __IM  uint32_t io_link_irq_masked;          /*!< (@ 0x00000004) IO-Link Masked IRQ register Shows status of masked
                                                                    IRQs (as connected to ARM/xPIC)                            */
    
    struct {
      __IM  uint32_t xlink0_tx_next : 1;        /*!< [0..0] tx_next interrupt                                                  */
      __IM  uint32_t xlink0_rx_next : 1;        /*!< [1..1] rx_next interrupt                                                  */
      __IM  uint32_t xlink0_shift_en : 1;       /*!< [2..2] shift_en interrupt                                                 */
      __IM  uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IM  uint32_t xlink1_tx_next : 1;        /*!< [4..4] tx_next interrupt                                                  */
      __IM  uint32_t xlink1_rx_next : 1;        /*!< [5..5] rx_next interrupt                                                  */
      __IM  uint32_t xlink1_shift_en : 1;       /*!< [6..6] shift_en interrupt                                                 */
      __IM  uint32_t reserved1  : 1;            /*!< [7..7] reserved                                                           */
      __IM  uint32_t xlink2_tx_next : 1;        /*!< [8..8] tx_next interrupt                                                  */
      __IM  uint32_t xlink2_rx_next : 1;        /*!< [9..9] rx_next interrupt                                                  */
      __IM  uint32_t xlink2_shift_en : 1;       /*!< [10..10] shift_en interrupt                                               */
      __IM  uint32_t reserved2  : 1;            /*!< [11..11] reserved                                                         */
      __IM  uint32_t xlink3_tx_next : 1;        /*!< [12..12] tx_next interrupt                                                */
      __IM  uint32_t xlink3_rx_next : 1;        /*!< [13..13] rx_next interrupt                                                */
      __IM  uint32_t xlink3_shift_en : 1;       /*!< [14..14] shift_en interrupt                                               */
      __IM  uint32_t reserved3  : 1;            /*!< [15..15] reserved                                                         */
      __IM  uint32_t xlink4_tx_next : 1;        /*!< [16..16] tx_next interrupt                                                */
      __IM  uint32_t xlink4_rx_next : 1;        /*!< [17..17] rx_next interrupt                                                */
      __IM  uint32_t xlink4_shift_en : 1;       /*!< [18..18] shift_en interrupt                                               */
      __IM  uint32_t reserved4  : 1;            /*!< [19..19] reserved                                                         */
      __IM  uint32_t xlink5_tx_next : 1;        /*!< [20..20] tx_next interrupt                                                */
      __IM  uint32_t xlink5_rx_next : 1;        /*!< [21..21] rx_next interrupt                                                */
      __IM  uint32_t xlink5_shift_en : 1;       /*!< [22..22] shift_en interrupt                                               */
      __IM  uint32_t reserved5  : 1;            /*!< [23..23] reserved                                                         */
      __IM  uint32_t xlink6_tx_next : 1;        /*!< [24..24] tx_next interrupt                                                */
      __IM  uint32_t xlink6_rx_next : 1;        /*!< [25..25] rx_next interrupt                                                */
      __IM  uint32_t xlink6_shift_en : 1;       /*!< [26..26] shift_en interrupt                                               */
      __IM  uint32_t reserved6  : 1;            /*!< [27..27] reserved                                                         */
      __IM  uint32_t xlink7_tx_next : 1;        /*!< [28..28] tx_next interrupt                                                */
      __IM  uint32_t xlink7_rx_next : 1;        /*!< [29..29] rx_next interrupt                                                */
      __IM  uint32_t xlink7_shift_en : 1;       /*!< [30..30] shift_en interrupt                                               */
      __IM  uint32_t reserved7  : 1;            /*!< [31..31] reserved                                                         */
    } io_link_irq_masked_b;
  } ;
  
  union {
    __IOM uint32_t io_link_irq_msk_set;         /*!< (@ 0x00000008) IO-Link interrupt mask enable: The IRQ mask enables
                                                                    interrupt requests for corresponding interrupt
                                                                    sources. As its bits might be changed by
                                                                    different software tasks, the IRQ mask register
                                                                    is not writable directly, but by set and
                                                                    reset masks: Write access with '1' sets
                                                                    interrupt mask bit (enables interrupt request
                                                                    for corresponding interrupt source). Write
                                                                    access with '0' does not influence this
                                                                    bit. Read access shows actual interrupt
                                                                    mask. Attention: Before activating interrupt
                                                                    mask, delet                                                */
    
    struct {
      __IOM uint32_t xlink0_tx_next : 1;        /*!< [0..0] tx_next interrupt                                                  */
      __IOM uint32_t xlink0_rx_next : 1;        /*!< [1..1] rx_next interrupt                                                  */
      __IOM uint32_t xlink0_shift_en : 1;       /*!< [2..2] shift_en interrupt                                                 */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t xlink1_tx_next : 1;        /*!< [4..4] tx_next interrupt                                                  */
      __IOM uint32_t xlink1_rx_next : 1;        /*!< [5..5] rx_next interrupt                                                  */
      __IOM uint32_t xlink1_shift_en : 1;       /*!< [6..6] shift_en interrupt                                                 */
      __IOM uint32_t reserved1  : 1;            /*!< [7..7] reserved                                                           */
      __IOM uint32_t xlink2_tx_next : 1;        /*!< [8..8] tx_next interrupt                                                  */
      __IOM uint32_t xlink2_rx_next : 1;        /*!< [9..9] rx_next interrupt                                                  */
      __IOM uint32_t xlink2_shift_en : 1;       /*!< [10..10] shift_en interrupt                                               */
      __IOM uint32_t reserved2  : 1;            /*!< [11..11] reserved                                                         */
      __IOM uint32_t xlink3_tx_next : 1;        /*!< [12..12] tx_next interrupt                                                */
      __IOM uint32_t xlink3_rx_next : 1;        /*!< [13..13] rx_next interrupt                                                */
      __IOM uint32_t xlink3_shift_en : 1;       /*!< [14..14] shift_en interrupt                                               */
      __IOM uint32_t reserved3  : 1;            /*!< [15..15] reserved                                                         */
      __IOM uint32_t xlink4_tx_next : 1;        /*!< [16..16] tx_next interrupt                                                */
      __IOM uint32_t xlink4_rx_next : 1;        /*!< [17..17] rx_next interrupt                                                */
      __IOM uint32_t xlink4_shift_en : 1;       /*!< [18..18] shift_en interrupt                                               */
      __IOM uint32_t reserved4  : 1;            /*!< [19..19] reserved                                                         */
      __IOM uint32_t xlink5_tx_next : 1;        /*!< [20..20] tx_next interrupt                                                */
      __IOM uint32_t xlink5_rx_next : 1;        /*!< [21..21] rx_next interrupt                                                */
      __IOM uint32_t xlink5_shift_en : 1;       /*!< [22..22] shift_en interrupt                                               */
      __IOM uint32_t reserved5  : 1;            /*!< [23..23] reserved                                                         */
      __IOM uint32_t xlink6_tx_next : 1;        /*!< [24..24] tx_next interrupt                                                */
      __IOM uint32_t xlink6_rx_next : 1;        /*!< [25..25] rx_next interrupt                                                */
      __IOM uint32_t xlink6_shift_en : 1;       /*!< [26..26] shift_en interrupt                                               */
      __IOM uint32_t reserved6  : 1;            /*!< [27..27] reserved                                                         */
      __IOM uint32_t xlink7_tx_next : 1;        /*!< [28..28] tx_next interrupt                                                */
      __IOM uint32_t xlink7_rx_next : 1;        /*!< [29..29] rx_next interrupt                                                */
      __IOM uint32_t xlink7_shift_en : 1;       /*!< [30..30] shift_en interrupt                                               */
      __IOM uint32_t reserved7  : 1;            /*!< [31..31] reserved                                                         */
    } io_link_irq_msk_set_b;
  } ;
  
  union {
    __IOM uint32_t io_link_irq_msk_reset;       /*!< (@ 0x0000000C) IO-Link interrupt mask disable: This is the corresponding
                                                                    reset mask to disable interrupt requests
                                                                    for corresponding interrupt sources: Write
                                                                    access with '1' resets interrupt mask bit
                                                                    (disables interrupt request for corresponding
                                                                    interrupt source). Write access with '0'
                                                                    does not influence this bit. Read access
                                                                    shows actual interrupt mask.                               */
    
    struct {
      __IOM uint32_t xlink0_tx_next : 1;        /*!< [0..0] tx_next interrupt                                                  */
      __IOM uint32_t xlink0_rx_next : 1;        /*!< [1..1] rx_next interrupt                                                  */
      __IOM uint32_t xlink0_shift_en : 1;       /*!< [2..2] shift_en interrupt                                                 */
      __IOM uint32_t reserved0  : 1;            /*!< [3..3] reserved                                                           */
      __IOM uint32_t xlink1_tx_next : 1;        /*!< [4..4] tx_next interrupt                                                  */
      __IOM uint32_t xlink1_rx_next : 1;        /*!< [5..5] rx_next interrupt                                                  */
      __IOM uint32_t xlink1_shift_en : 1;       /*!< [6..6] shift_en interrupt                                                 */
      __IOM uint32_t reserved1  : 1;            /*!< [7..7] reserved                                                           */
      __IOM uint32_t xlink2_tx_next : 1;        /*!< [8..8] tx_next interrupt                                                  */
      __IOM uint32_t xlink2_rx_next : 1;        /*!< [9..9] rx_next interrupt                                                  */
      __IOM uint32_t xlink2_shift_en : 1;       /*!< [10..10] shift_en interrupt                                               */
      __IOM uint32_t reserved2  : 1;            /*!< [11..11] reserved                                                         */
      __IOM uint32_t xlink3_tx_next : 1;        /*!< [12..12] tx_next interrupt                                                */
      __IOM uint32_t xlink3_rx_next : 1;        /*!< [13..13] rx_next interrupt                                                */
      __IOM uint32_t xlink3_shift_en : 1;       /*!< [14..14] shift_en interrupt                                               */
      __IOM uint32_t reserved3  : 1;            /*!< [15..15] reserved                                                         */
      __IOM uint32_t xlink4_tx_next : 1;        /*!< [16..16] tx_next interrupt                                                */
      __IOM uint32_t xlink4_rx_next : 1;        /*!< [17..17] rx_next interrupt                                                */
      __IOM uint32_t xlink4_shift_en : 1;       /*!< [18..18] shift_en interrupt                                               */
      __IOM uint32_t reserved4  : 1;            /*!< [19..19] reserved                                                         */
      __IOM uint32_t xlink5_tx_next : 1;        /*!< [20..20] tx_next interrupt                                                */
      __IOM uint32_t xlink5_rx_next : 1;        /*!< [21..21] rx_next interrupt                                                */
      __IOM uint32_t xlink5_shift_en : 1;       /*!< [22..22] shift_en interrupt                                               */
      __IOM uint32_t reserved5  : 1;            /*!< [23..23] reserved                                                         */
      __IOM uint32_t xlink6_tx_next : 1;        /*!< [24..24] tx_next interrupt                                                */
      __IOM uint32_t xlink6_rx_next : 1;        /*!< [25..25] rx_next interrupt                                                */
      __IOM uint32_t xlink6_shift_en : 1;       /*!< [26..26] shift_en interrupt                                               */
      __IOM uint32_t reserved6  : 1;            /*!< [27..27] reserved                                                         */
      __IOM uint32_t xlink7_tx_next : 1;        /*!< [28..28] tx_next interrupt                                                */
      __IOM uint32_t xlink7_rx_next : 1;        /*!< [29..29] rx_next interrupt                                                */
      __IOM uint32_t xlink7_shift_en : 1;       /*!< [30..30] shift_en interrupt                                               */
      __IOM uint32_t reserved7  : 1;            /*!< [31..31] reserved                                                         */
    } io_link_irq_msk_reset_b;
  } ;
} io_link_irq_Type;                             /*!< Size = 16 (0x10)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define cm4_scs_BASE                0xE000E000UL
#define cm4_misc_ctrl_BASE          0xE0043000UL
#define idpm_com_BASE               0xFF001B00UL
#define hash_BASE                   0xFF080000UL
#define aes_BASE                    0xFF080080UL
#define random_BASE                 0xFF0800C0UL
#define mtgy_BASE                   0xFF082000UL
#define nfifo_BASE                  0xFF400000UL
#define pad_ctrl_BASE               0xFF401000UL
#define asic_ctrl_BASE              0xFF401200UL
#define mmio_ctrl_BASE              0xFF401300UL
#define global_buf_man_BASE         0xFF401380UL
#define iflash_cfg2_BASE            0xFF401400UL
#define hif_io_ctrl_BASE            0xFF401480UL
#define hif_asyncmem_ctrl_BASE      0xFF401500UL
#define hif_sdram_ctrl_BASE         0xFF401540UL
#define hifmem_priority_ctrl_BASE   0xFF401580UL
#define abort_BASE                  0xFF401600UL
#define sqi_BASE                    0xFF401640UL
#define sample_at_porn_stat_BASE    0xFF401680UL
#define adc_seq_BASE                0xFF4016C0UL
#define miimu_BASE                  0xFF401700UL
#define eth_BASE                    0xFF480000UL
#define dmac_app_ch_BASE            0xFF800100UL
#define dmac_app_reg_BASE           0xFF800800UL
#define dmac_mux_app_BASE           0xFF801000UL
#define uart_app_BASE               0xFF801040UL
#define i2c_app_BASE                0xFF801080UL
#define mled_ctrl_app_BASE          0xFF801100UL
#define ecc_ctrl_app_BASE           0xFF801200UL
#define gpio_app_BASE               0xFF801400UL
#define systime_lt_app_BASE         0xFF801540UL
#define timer_app_BASE              0xFF801580UL
#define systime_app_BASE            0xFF801600UL
#define mcp_app_BASE                0xFF801620UL
#define wdg_app_BASE                0xFF801640UL
#define trigger_irq_app_BASE        0xFF801660UL
#define endat0_app_BASE             0xFF801700UL
#define endat1_app_BASE             0xFF801740UL
#define endat_ctrl0_app_BASE        0xFF801780UL
#define endat_ctrl1_app_BASE        0xFF801790UL
#define can_ctrl0_app_BASE          0xFF801900UL
#define can_ctrl1_app_BASE          0xFF801980UL
#define spi0_app_BASE               0xFF801A00UL
#define spi1_app_BASE               0xFF801A40UL
#define spi2_app_BASE               0xFF801A80UL
#define pio_app_BASE                0xFF801AC0UL
#define biss0_app_BASE              0xFF801B00UL
#define biss1_app_BASE              0xFF801C00UL
#define biss_ctrl0_app_BASE         0xFF801D00UL
#define biss_ctrl1_app_BASE         0xFF801D20UL
#define xpic_app_regs_BASE          0xFF884000UL
#define xpic_app_debug_BASE         0xFF884080UL
#define vic_xpic_app_BASE           0xFF900000UL
#define timer_xpic_app_BASE         0xFF900100UL
#define wdg_xpic_app_BASE           0xFF900180UL
#define mcp_xpic_app_BASE           0xFF9001A0UL
#define systime_lt_xpic_app_BASE    0xFF9001C0UL
#define gpio_xpic_app_BASE          0xFF900200UL
#define uart_xpic_app_BASE          0xFF900300UL
#define i2c_xpic_app_BASE           0xFF900340UL
#define spi_xpic_app_BASE           0xFF900380UL
#define xlink0_BASE                 0xFF900400UL
#define xlink1_BASE                 0xFF900410UL
#define xlink2_BASE                 0xFF900420UL
#define xlink3_BASE                 0xFF900430UL
#define xlink4_BASE                 0xFF900440UL
#define xlink5_BASE                 0xFF900450UL
#define xlink6_BASE                 0xFF900460UL
#define xlink7_BASE                 0xFF900470UL
#define io_link_irq_BASE            0xFF900480UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define cm4_scs                     ((cm4_scs_Type*)           cm4_scs_BASE)
#define cm4_misc_ctrl               ((cm4_misc_ctrl_Type*)     cm4_misc_ctrl_BASE)
#define idpm_com                    ((idpm_com_Type*)          idpm_com_BASE)
#define hash                        ((hash_Type*)              hash_BASE)
#define aes                         ((aes_Type*)               aes_BASE)
#define random                      ((random_Type*)            random_BASE)
#define mtgy                        ((mtgy_Type*)              mtgy_BASE)
#define nfifo                       ((nfifo_Type*)             nfifo_BASE)
#define pad_ctrl                    ((pad_ctrl_Type*)          pad_ctrl_BASE)
#define asic_ctrl                   ((asic_ctrl_Type*)         asic_ctrl_BASE)
#define mmio_ctrl                   ((mmio_ctrl_Type*)         mmio_ctrl_BASE)
#define global_buf_man              ((global_buf_man_Type*)    global_buf_man_BASE)
#define iflash_cfg2                 ((iflash_cfg2_Type*)       iflash_cfg2_BASE)
#define hif_io_ctrl                 ((hif_io_ctrl_Type*)       hif_io_ctrl_BASE)
#define hif_asyncmem_ctrl           ((hif_asyncmem_ctrl_Type*)  hif_asyncmem_ctrl_BASE)
#define hif_sdram_ctrl              ((hif_sdram_ctrl_Type*)    hif_sdram_ctrl_BASE)
#define hifmem_priority_ctrl        ((hifmem_priority_ctrl_Type*)  hifmem_priority_ctrl_BASE)
#define abort                       ((abort_Type*)             abort_BASE)
#define sqi                         ((sqi_Type*)               sqi_BASE)
#define sample_at_porn_stat         ((sample_at_porn_stat_Type*)  sample_at_porn_stat_BASE)
#define adc_seq                     ((adc_seq_Type*)           adc_seq_BASE)
#define miimu                       ((miimu_Type*)             miimu_BASE)
#define eth                         ((eth_Type*)               eth_BASE)
#define dmac_app_ch                 ((dmac_app_ch_ARRAYType*)  dmac_app_ch_BASE)
#define dmac_app_reg                ((dmac_app_reg_Type*)      dmac_app_reg_BASE)
#define dmac_mux_app                ((dmac_mux_app_Type*)      dmac_mux_app_BASE)
#define uart_app                    ((uart_app_Type*)          uart_app_BASE)
#define i2c_app                     ((i2c_app_Type*)           i2c_app_BASE)
#define mled_ctrl_app               ((mled_ctrl_app_Type*)     mled_ctrl_app_BASE)
#define ecc_ctrl_app                ((ecc_ctrl_app_Type*)      ecc_ctrl_app_BASE)
#define gpio_app                    ((gpio_app_Type*)          gpio_app_BASE)
#define systime_lt_app              ((systime_lt_app_Type*)    systime_lt_app_BASE)
#define timer_app                   ((timer_app_Type*)         timer_app_BASE)
#define systime_app                 ((systime_app_Type*)       systime_app_BASE)
#define mcp_app                     ((mcp_app_Type*)           mcp_app_BASE)
#define wdg_app                     ((wdg_app_Type*)           wdg_app_BASE)
#define trigger_irq_app             ((trigger_irq_app_Type*)   trigger_irq_app_BASE)
#define endat0_app                  ((endat0_app_Type*)        endat0_app_BASE)
#define endat1_app                  ((endat1_app_Type*)        endat1_app_BASE)
#define endat_ctrl0_app             ((endat_ctrl0_app_Type*)   endat_ctrl0_app_BASE)
#define endat_ctrl1_app             ((endat_ctrl1_app_Type*)   endat_ctrl1_app_BASE)
#define can_ctrl0_app               ((can_ctrl0_app_Type*)     can_ctrl0_app_BASE)
#define can_ctrl1_app               ((can_ctrl1_app_Type*)     can_ctrl1_app_BASE)
#define spi0_app                    ((spi0_app_Type*)          spi0_app_BASE)
#define spi1_app                    ((spi1_app_Type*)          spi1_app_BASE)
#define spi2_app                    ((spi2_app_Type*)          spi2_app_BASE)
#define pio_app                     ((pio_app_Type*)           pio_app_BASE)
#define biss0_app                   ((biss0_app_Type*)         biss0_app_BASE)
#define biss1_app                   ((biss1_app_Type*)         biss1_app_BASE)
#define biss_ctrl0_app              ((biss_ctrl0_app_Type*)    biss_ctrl0_app_BASE)
#define biss_ctrl1_app              ((biss_ctrl1_app_Type*)    biss_ctrl1_app_BASE)
#define xpic_app_regs               ((xpic_app_regs_Type*)     xpic_app_regs_BASE)
#define xpic_app_debug              ((xpic_app_debug_Type*)    xpic_app_debug_BASE)
#define vic_xpic_app                ((vic_xpic_app_Type*)      vic_xpic_app_BASE)
#define timer_xpic_app              ((timer_xpic_app_Type*)    timer_xpic_app_BASE)
#define wdg_xpic_app                ((wdg_xpic_app_Type*)      wdg_xpic_app_BASE)
#define mcp_xpic_app                ((mcp_xpic_app_Type*)      mcp_xpic_app_BASE)
#define systime_lt_xpic_app         ((systime_lt_xpic_app_Type*)  systime_lt_xpic_app_BASE)
#define gpio_xpic_app               ((gpio_xpic_app_Type*)     gpio_xpic_app_BASE)
#define uart_xpic_app               ((uart_xpic_app_Type*)     uart_xpic_app_BASE)
#define i2c_xpic_app                ((i2c_xpic_app_Type*)      i2c_xpic_app_BASE)
#define spi_xpic_app                ((spi_xpic_app_Type*)      spi_xpic_app_BASE)
#define xlink0                      ((xlink0_Type*)            xlink0_BASE)
#define xlink1                      ((xlink1_Type*)            xlink1_BASE)
#define xlink2                      ((xlink2_Type*)            xlink2_BASE)
#define xlink3                      ((xlink3_Type*)            xlink3_BASE)
#define xlink4                      ((xlink4_Type*)            xlink4_BASE)
#define xlink5                      ((xlink5_Type*)            xlink5_BASE)
#define xlink6                      ((xlink6_Type*)            xlink6_BASE)
#define xlink7                      ((xlink7_Type*)            xlink7_BASE)
#define io_link_irq                 ((io_link_irq_Type*)       io_link_irq_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


/* =========================================================================================================================== */
/* ================                                Pos/Mask Peripheral Section                                ================ */
/* =========================================================================================================================== */


/** @addtogroup PosMask_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                          cm4_scs                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  cm4_scs_actlr  ===================================================== */
/* =====================================================  cm4_scs_stcsr  ===================================================== */
/* =====================================================  cm4_scs_strvr  ===================================================== */
/* =====================================================  cm4_scs_stcvr  ===================================================== */
/* =====================================================  cm4_scs_stcr  ====================================================== */
/* ==================================================  cm4_scs_nvic_iser0  =================================================== */
#define cm4_scs_cm4_scs_nvic_iser0_setena_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_iser0: setena (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_iser0_setena_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_iser0: setena (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_iser1  =================================================== */
#define cm4_scs_cm4_scs_nvic_iser1_setena_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_iser1: setena (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_iser1_setena_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_iser1: setena (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_iser2  =================================================== */
#define cm4_scs_cm4_scs_nvic_iser2_setena_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_iser2: setena (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_iser2_setena_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_iser2: setena (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_icer0  =================================================== */
#define cm4_scs_cm4_scs_nvic_icer0_clrena_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_icer0: clrena (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_icer0_clrena_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_icer0: clrena (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_icer1  =================================================== */
#define cm4_scs_cm4_scs_nvic_icer1_clrena_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_icer1: clrena (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_icer1_clrena_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_icer1: clrena (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_icer2  =================================================== */
#define cm4_scs_cm4_scs_nvic_icer2_clrena_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_icer2: clrena (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_icer2_clrena_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_icer2: clrena (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_ispr0  =================================================== */
#define cm4_scs_cm4_scs_nvic_ispr0_setpend_Pos (0UL)                /*!< cm4_scs cm4_scs_nvic_ispr0: setpend (Bit 0)           */
#define cm4_scs_cm4_scs_nvic_ispr0_setpend_Msk (0xffffffffUL)       /*!< cm4_scs cm4_scs_nvic_ispr0: setpend (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_ispr1  =================================================== */
#define cm4_scs_cm4_scs_nvic_ispr1_setpend_Pos (0UL)                /*!< cm4_scs cm4_scs_nvic_ispr1: setpend (Bit 0)           */
#define cm4_scs_cm4_scs_nvic_ispr1_setpend_Msk (0xffffffffUL)       /*!< cm4_scs cm4_scs_nvic_ispr1: setpend (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_ispr2  =================================================== */
#define cm4_scs_cm4_scs_nvic_ispr2_setpend_Pos (0UL)                /*!< cm4_scs cm4_scs_nvic_ispr2: setpend (Bit 0)           */
#define cm4_scs_cm4_scs_nvic_ispr2_setpend_Msk (0xffffffffUL)       /*!< cm4_scs cm4_scs_nvic_ispr2: setpend (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_icpr0  =================================================== */
#define cm4_scs_cm4_scs_nvic_icpr0_clrpend_Pos (0UL)                /*!< cm4_scs cm4_scs_nvic_icpr0: clrpend (Bit 0)           */
#define cm4_scs_cm4_scs_nvic_icpr0_clrpend_Msk (0xffffffffUL)       /*!< cm4_scs cm4_scs_nvic_icpr0: clrpend (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_icpr1  =================================================== */
#define cm4_scs_cm4_scs_nvic_icpr1_clrpend_Pos (0UL)                /*!< cm4_scs cm4_scs_nvic_icpr1: clrpend (Bit 0)           */
#define cm4_scs_cm4_scs_nvic_icpr1_clrpend_Msk (0xffffffffUL)       /*!< cm4_scs cm4_scs_nvic_icpr1: clrpend (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_icpr2  =================================================== */
#define cm4_scs_cm4_scs_nvic_icpr2_clrpend_Pos (0UL)                /*!< cm4_scs cm4_scs_nvic_icpr2: clrpend (Bit 0)           */
#define cm4_scs_cm4_scs_nvic_icpr2_clrpend_Msk (0xffffffffUL)       /*!< cm4_scs cm4_scs_nvic_icpr2: clrpend (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_iabr0  =================================================== */
#define cm4_scs_cm4_scs_nvic_iabr0_active_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_iabr0: active (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_iabr0_active_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_iabr0: active (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_iabr1  =================================================== */
#define cm4_scs_cm4_scs_nvic_iabr1_active_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_iabr1: active (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_iabr1_active_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_iabr1: active (Bitfield-Mask: 0xffffffff) */
/* ==================================================  cm4_scs_nvic_iabr2  =================================================== */
#define cm4_scs_cm4_scs_nvic_iabr2_active_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_iabr2: active (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_iabr2_active_Msk (0xffffffffUL)        /*!< cm4_scs cm4_scs_nvic_iabr2: active (Bitfield-Mask: 0xffffffff) */
/* ===================================================  cm4_scs_nvic_ipr0  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr0_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr0: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr1  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr1_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr1: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr2  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr2_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr2: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr3  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr3_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr3: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr4  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr4_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr4: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr5  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr5_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr5: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr6  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr6_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr6: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr7  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr7_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr7: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr8  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr8_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr8: pri_n0 (Bitfield-Mask: 0xff) */
/* ===================================================  cm4_scs_nvic_ipr9  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n3_Pos (24UL)                 /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n3 (Bit 24)            */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n3_Msk (0xff000000UL)         /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n2_Pos (16UL)                 /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n2 (Bit 16)            */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n2_Msk (0xff0000UL)           /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n1_Pos (8UL)                  /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n1 (Bit 8)             */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n1_Msk (0xff00UL)             /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n0_Pos (0UL)                  /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n0 (Bit 0)             */
#define cm4_scs_cm4_scs_nvic_ipr9_pri_n0_Msk (0xffUL)               /*!< cm4_scs cm4_scs_nvic_ipr9: pri_n0 (Bitfield-Mask: 0xff) */
/* ==================================================  cm4_scs_nvic_ipr10  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n3_Pos (24UL)                /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n3 (Bit 24)           */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n3_Msk (0xff000000UL)        /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n2_Pos (16UL)                /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n2 (Bit 16)           */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n2_Msk (0xff0000UL)          /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n1_Pos (8UL)                 /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n1 (Bit 8)            */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n1_Msk (0xff00UL)            /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n0_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n0 (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_ipr10_pri_n0_Msk (0xffUL)              /*!< cm4_scs cm4_scs_nvic_ipr10: pri_n0 (Bitfield-Mask: 0xff) */
/* ==================================================  cm4_scs_nvic_ipr11  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n3_Pos (24UL)                /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n3 (Bit 24)           */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n3_Msk (0xff000000UL)        /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n2_Pos (16UL)                /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n2 (Bit 16)           */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n2_Msk (0xff0000UL)          /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n1_Pos (8UL)                 /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n1 (Bit 8)            */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n1_Msk (0xff00UL)            /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n0_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n0 (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_ipr11_pri_n0_Msk (0xffUL)              /*!< cm4_scs cm4_scs_nvic_ipr11: pri_n0 (Bitfield-Mask: 0xff) */
/* ==================================================  cm4_scs_nvic_ipr12  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n3_Pos (24UL)                /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n3 (Bit 24)           */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n3_Msk (0xff000000UL)        /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n2_Pos (16UL)                /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n2 (Bit 16)           */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n2_Msk (0xff0000UL)          /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n1_Pos (8UL)                 /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n1 (Bit 8)            */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n1_Msk (0xff00UL)            /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n0_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n0 (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_ipr12_pri_n0_Msk (0xffUL)              /*!< cm4_scs cm4_scs_nvic_ipr12: pri_n0 (Bitfield-Mask: 0xff) */
/* ==================================================  cm4_scs_nvic_ipr13  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n3_Pos (24UL)                /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n3 (Bit 24)           */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n3_Msk (0xff000000UL)        /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n2_Pos (16UL)                /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n2 (Bit 16)           */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n2_Msk (0xff0000UL)          /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n1_Pos (8UL)                 /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n1 (Bit 8)            */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n1_Msk (0xff00UL)            /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n0_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n0 (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_ipr13_pri_n0_Msk (0xffUL)              /*!< cm4_scs cm4_scs_nvic_ipr13: pri_n0 (Bitfield-Mask: 0xff) */
/* ==================================================  cm4_scs_nvic_ipr14  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n3_Pos (24UL)                /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n3 (Bit 24)           */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n3_Msk (0xff000000UL)        /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n2_Pos (16UL)                /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n2 (Bit 16)           */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n2_Msk (0xff0000UL)          /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n1_Pos (8UL)                 /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n1 (Bit 8)            */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n1_Msk (0xff00UL)            /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n0_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n0 (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_ipr14_pri_n0_Msk (0xffUL)              /*!< cm4_scs cm4_scs_nvic_ipr14: pri_n0 (Bitfield-Mask: 0xff) */
/* ==================================================  cm4_scs_nvic_ipr15  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n3_Pos (24UL)                /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n3 (Bit 24)           */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n3_Msk (0xff000000UL)        /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n2_Pos (16UL)                /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n2 (Bit 16)           */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n2_Msk (0xff0000UL)          /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n1_Pos (8UL)                 /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n1 (Bit 8)            */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n1_Msk (0xff00UL)            /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n0_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n0 (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_ipr15_pri_n0_Msk (0xffUL)              /*!< cm4_scs cm4_scs_nvic_ipr15: pri_n0 (Bitfield-Mask: 0xff) */
/* ==================================================  cm4_scs_nvic_ipr16  =================================================== */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n3_Pos (24UL)                /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n3 (Bit 24)           */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n3_Msk (0xff000000UL)        /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n3 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n2_Pos (16UL)                /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n2 (Bit 16)           */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n2_Msk (0xff0000UL)          /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n2 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n1_Pos (8UL)                 /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n1 (Bit 8)            */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n1_Msk (0xff00UL)            /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n1 (Bitfield-Mask: 0xff) */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n0_Pos (0UL)                 /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n0 (Bit 0)            */
#define cm4_scs_cm4_scs_nvic_ipr16_pri_n0_Msk (0xffUL)              /*!< cm4_scs cm4_scs_nvic_ipr16: pri_n0 (Bitfield-Mask: 0xff) */
/* =====================================================  cm4_scs_cpuid  ===================================================== */
/* =====================================================  cm4_scs_icsr  ====================================================== */
/* =====================================================  cm4_scs_vtor  ====================================================== */
#define cm4_scs_cm4_scs_vtor_tbloff_Pos   (7UL)                     /*!< cm4_scs cm4_scs_vtor: tbloff (Bit 7)                  */
#define cm4_scs_cm4_scs_vtor_tbloff_Msk   (0xffffff80UL)            /*!< cm4_scs cm4_scs_vtor: tbloff (Bitfield-Mask: 0x1ffffff) */
#define cm4_scs_cm4_scs_vtor_reserved0_Pos (0UL)                    /*!< cm4_scs cm4_scs_vtor: reserved0 (Bit 0)               */
#define cm4_scs_cm4_scs_vtor_reserved0_Msk (0x7fUL)                 /*!< cm4_scs cm4_scs_vtor: reserved0 (Bitfield-Mask: 0x7f) */
/* =====================================================  cm4_scs_aircr  ===================================================== */
#define cm4_scs_cm4_scs_aircr_vectkey_Pos (16UL)                    /*!< cm4_scs cm4_scs_aircr: vectkey (Bit 16)               */
#define cm4_scs_cm4_scs_aircr_vectkey_Msk (0xffff0000UL)            /*!< cm4_scs cm4_scs_aircr: vectkey (Bitfield-Mask: 0xffff) */
#define cm4_scs_cm4_scs_aircr_endianness_Pos (15UL)                 /*!< cm4_scs cm4_scs_aircr: endianness (Bit 15)            */
#define cm4_scs_cm4_scs_aircr_endianness_Msk (0x8000UL)             /*!< cm4_scs cm4_scs_aircr: endianness (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_aircr_reserved1_Pos (11UL)                  /*!< cm4_scs cm4_scs_aircr: reserved1 (Bit 11)             */
#define cm4_scs_cm4_scs_aircr_reserved1_Msk (0x7800UL)              /*!< cm4_scs cm4_scs_aircr: reserved1 (Bitfield-Mask: 0x0f) */
#define cm4_scs_cm4_scs_aircr_prigroup_Pos (8UL)                    /*!< cm4_scs cm4_scs_aircr: prigroup (Bit 8)               */
#define cm4_scs_cm4_scs_aircr_prigroup_Msk (0x700UL)                /*!< cm4_scs cm4_scs_aircr: prigroup (Bitfield-Mask: 0x07) */
#define cm4_scs_cm4_scs_aircr_reserved0_Pos (3UL)                   /*!< cm4_scs cm4_scs_aircr: reserved0 (Bit 3)              */
#define cm4_scs_cm4_scs_aircr_reserved0_Msk (0xf8UL)                /*!< cm4_scs cm4_scs_aircr: reserved0 (Bitfield-Mask: 0x1f) */
#define cm4_scs_cm4_scs_aircr_sysresetreq_Pos (2UL)                 /*!< cm4_scs cm4_scs_aircr: sysresetreq (Bit 2)            */
#define cm4_scs_cm4_scs_aircr_sysresetreq_Msk (0x4UL)               /*!< cm4_scs cm4_scs_aircr: sysresetreq (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_aircr_vectclractive_Pos (1UL)               /*!< cm4_scs cm4_scs_aircr: vectclractive (Bit 1)          */
#define cm4_scs_cm4_scs_aircr_vectclractive_Msk (0x2UL)             /*!< cm4_scs cm4_scs_aircr: vectclractive (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_aircr_vectreset_Pos (0UL)                   /*!< cm4_scs cm4_scs_aircr: vectreset (Bit 0)              */
#define cm4_scs_cm4_scs_aircr_vectreset_Msk (0x1UL)                 /*!< cm4_scs cm4_scs_aircr: vectreset (Bitfield-Mask: 0x01) */
/* ======================================================  cm4_scs_scr  ====================================================== */
/* ======================================================  cm4_scs_ccr  ====================================================== */
/* =====================================================  cm4_scs_shpr1  ===================================================== */
/* =====================================================  cm4_scs_shpr2  ===================================================== */
/* =====================================================  cm4_scs_shpr3  ===================================================== */
/* =====================================================  cm4_scs_shcsr  ===================================================== */
/* =====================================================  cm4_scs_cfsr  ====================================================== */
#define cm4_scs_cm4_scs_cfsr_reserved4_Pos (26UL)                   /*!< cm4_scs cm4_scs_cfsr: reserved4 (Bit 26)              */
#define cm4_scs_cm4_scs_cfsr_reserved4_Msk (0xfc000000UL)           /*!< cm4_scs cm4_scs_cfsr: reserved4 (Bitfield-Mask: 0x3f) */
#define cm4_scs_cm4_scs_cfsr_ufsr_divbyzero_Pos (25UL)              /*!< cm4_scs cm4_scs_cfsr: ufsr_divbyzero (Bit 25)         */
#define cm4_scs_cm4_scs_cfsr_ufsr_divbyzero_Msk (0x2000000UL)       /*!< cm4_scs cm4_scs_cfsr: ufsr_divbyzero (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_ufsr_unaligned_Pos (24UL)              /*!< cm4_scs cm4_scs_cfsr: ufsr_unaligned (Bit 24)         */
#define cm4_scs_cm4_scs_cfsr_ufsr_unaligned_Msk (0x1000000UL)       /*!< cm4_scs cm4_scs_cfsr: ufsr_unaligned (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_reserved3_Pos (20UL)                   /*!< cm4_scs cm4_scs_cfsr: reserved3 (Bit 20)              */
#define cm4_scs_cm4_scs_cfsr_reserved3_Msk (0xf00000UL)             /*!< cm4_scs cm4_scs_cfsr: reserved3 (Bitfield-Mask: 0x0f) */
#define cm4_scs_cm4_scs_cfsr_ufsr_nocp_Pos (19UL)                   /*!< cm4_scs cm4_scs_cfsr: ufsr_nocp (Bit 19)              */
#define cm4_scs_cm4_scs_cfsr_ufsr_nocp_Msk (0x80000UL)              /*!< cm4_scs cm4_scs_cfsr: ufsr_nocp (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_ufsr_invpc_Pos (18UL)                  /*!< cm4_scs cm4_scs_cfsr: ufsr_invpc (Bit 18)             */
#define cm4_scs_cm4_scs_cfsr_ufsr_invpc_Msk (0x40000UL)             /*!< cm4_scs cm4_scs_cfsr: ufsr_invpc (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_ufsr_invstate_Pos (17UL)               /*!< cm4_scs cm4_scs_cfsr: ufsr_invstate (Bit 17)          */
#define cm4_scs_cm4_scs_cfsr_ufsr_invstate_Msk (0x20000UL)          /*!< cm4_scs cm4_scs_cfsr: ufsr_invstate (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_ufsr_undefinstr_Pos (16UL)             /*!< cm4_scs cm4_scs_cfsr: ufsr_undefinstr (Bit 16)        */
#define cm4_scs_cm4_scs_cfsr_ufsr_undefinstr_Msk (0x10000UL)        /*!< cm4_scs cm4_scs_cfsr: ufsr_undefinstr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_bfsr_bfarvalid_Pos (15UL)              /*!< cm4_scs cm4_scs_cfsr: bfsr_bfarvalid (Bit 15)         */
#define cm4_scs_cm4_scs_cfsr_bfsr_bfarvalid_Msk (0x8000UL)          /*!< cm4_scs cm4_scs_cfsr: bfsr_bfarvalid (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_reserved2_Pos (14UL)                   /*!< cm4_scs cm4_scs_cfsr: reserved2 (Bit 14)              */
#define cm4_scs_cm4_scs_cfsr_reserved2_Msk (0x4000UL)               /*!< cm4_scs cm4_scs_cfsr: reserved2 (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_bfsr_lsperr_Pos (13UL)                 /*!< cm4_scs cm4_scs_cfsr: bfsr_lsperr (Bit 13)            */
#define cm4_scs_cm4_scs_cfsr_bfsr_lsperr_Msk (0x2000UL)             /*!< cm4_scs cm4_scs_cfsr: bfsr_lsperr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_bfsr_stkerr_Pos (12UL)                 /*!< cm4_scs cm4_scs_cfsr: bfsr_stkerr (Bit 12)            */
#define cm4_scs_cm4_scs_cfsr_bfsr_stkerr_Msk (0x1000UL)             /*!< cm4_scs cm4_scs_cfsr: bfsr_stkerr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_bfsr_unstkerr_Pos (11UL)               /*!< cm4_scs cm4_scs_cfsr: bfsr_unstkerr (Bit 11)          */
#define cm4_scs_cm4_scs_cfsr_bfsr_unstkerr_Msk (0x800UL)            /*!< cm4_scs cm4_scs_cfsr: bfsr_unstkerr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_bfsr_impreciserr_Pos (10UL)            /*!< cm4_scs cm4_scs_cfsr: bfsr_impreciserr (Bit 10)       */
#define cm4_scs_cm4_scs_cfsr_bfsr_impreciserr_Msk (0x400UL)         /*!< cm4_scs cm4_scs_cfsr: bfsr_impreciserr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_bfsr_preciserr_Pos (9UL)               /*!< cm4_scs cm4_scs_cfsr: bfsr_preciserr (Bit 9)          */
#define cm4_scs_cm4_scs_cfsr_bfsr_preciserr_Msk (0x200UL)           /*!< cm4_scs cm4_scs_cfsr: bfsr_preciserr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_bfsr_ibuserr_Pos (8UL)                 /*!< cm4_scs cm4_scs_cfsr: bfsr_ibuserr (Bit 8)            */
#define cm4_scs_cm4_scs_cfsr_bfsr_ibuserr_Msk (0x100UL)             /*!< cm4_scs cm4_scs_cfsr: bfsr_ibuserr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_mmfsr_mmarvalid_Pos (7UL)              /*!< cm4_scs cm4_scs_cfsr: mmfsr_mmarvalid (Bit 7)         */
#define cm4_scs_cm4_scs_cfsr_mmfsr_mmarvalid_Msk (0x80UL)           /*!< cm4_scs cm4_scs_cfsr: mmfsr_mmarvalid (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_reserved1_Pos (6UL)                    /*!< cm4_scs cm4_scs_cfsr: reserved1 (Bit 6)               */
#define cm4_scs_cm4_scs_cfsr_reserved1_Msk (0x40UL)                 /*!< cm4_scs cm4_scs_cfsr: reserved1 (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_mmfsr_lsperr_Pos (5UL)                 /*!< cm4_scs cm4_scs_cfsr: mmfsr_lsperr (Bit 5)            */
#define cm4_scs_cm4_scs_cfsr_mmfsr_lsperr_Msk (0x20UL)              /*!< cm4_scs cm4_scs_cfsr: mmfsr_lsperr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_mmfsr_mstkerr_Pos (4UL)                /*!< cm4_scs cm4_scs_cfsr: mmfsr_mstkerr (Bit 4)           */
#define cm4_scs_cm4_scs_cfsr_mmfsr_mstkerr_Msk (0x10UL)             /*!< cm4_scs cm4_scs_cfsr: mmfsr_mstkerr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_mmfsr_munstkerr_Pos (3UL)              /*!< cm4_scs cm4_scs_cfsr: mmfsr_munstkerr (Bit 3)         */
#define cm4_scs_cm4_scs_cfsr_mmfsr_munstkerr_Msk (0x8UL)            /*!< cm4_scs cm4_scs_cfsr: mmfsr_munstkerr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_reserved0_Pos (2UL)                    /*!< cm4_scs cm4_scs_cfsr: reserved0 (Bit 2)               */
#define cm4_scs_cm4_scs_cfsr_reserved0_Msk (0x4UL)                  /*!< cm4_scs cm4_scs_cfsr: reserved0 (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_mmfsr_daccviol_Pos (1UL)               /*!< cm4_scs cm4_scs_cfsr: mmfsr_daccviol (Bit 1)          */
#define cm4_scs_cm4_scs_cfsr_mmfsr_daccviol_Msk (0x2UL)             /*!< cm4_scs cm4_scs_cfsr: mmfsr_daccviol (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_cfsr_mmfsr_iaccviol_Pos (0UL)               /*!< cm4_scs cm4_scs_cfsr: mmfsr_iaccviol (Bit 0)          */
#define cm4_scs_cm4_scs_cfsr_mmfsr_iaccviol_Msk (0x1UL)             /*!< cm4_scs cm4_scs_cfsr: mmfsr_iaccviol (Bitfield-Mask: 0x01) */
/* =====================================================  cm4_scs_hfsr  ====================================================== */
/* =====================================================  cm4_scs_dfsr  ====================================================== */
#define cm4_scs_cm4_scs_dfsr_external_Pos (4UL)                     /*!< cm4_scs cm4_scs_dfsr: external (Bit 4)                */
#define cm4_scs_cm4_scs_dfsr_external_Msk (0x10UL)                  /*!< cm4_scs cm4_scs_dfsr: external (Bitfield-Mask: 0x01)  */
#define cm4_scs_cm4_scs_dfsr_vcatch_Pos   (3UL)                     /*!< cm4_scs cm4_scs_dfsr: vcatch (Bit 3)                  */
#define cm4_scs_cm4_scs_dfsr_vcatch_Msk   (0x8UL)                   /*!< cm4_scs cm4_scs_dfsr: vcatch (Bitfield-Mask: 0x01)    */
#define cm4_scs_cm4_scs_dfsr_dwttrap_Pos  (2UL)                     /*!< cm4_scs cm4_scs_dfsr: dwttrap (Bit 2)                 */
#define cm4_scs_cm4_scs_dfsr_dwttrap_Msk  (0x4UL)                   /*!< cm4_scs cm4_scs_dfsr: dwttrap (Bitfield-Mask: 0x01)   */
#define cm4_scs_cm4_scs_dfsr_bkpt_Pos     (1UL)                     /*!< cm4_scs cm4_scs_dfsr: bkpt (Bit 1)                    */
#define cm4_scs_cm4_scs_dfsr_bkpt_Msk     (0x2UL)                   /*!< cm4_scs cm4_scs_dfsr: bkpt (Bitfield-Mask: 0x01)      */
#define cm4_scs_cm4_scs_dfsr_halted_Pos   (0UL)                     /*!< cm4_scs cm4_scs_dfsr: halted (Bit 0)                  */
#define cm4_scs_cm4_scs_dfsr_halted_Msk   (0x1UL)                   /*!< cm4_scs cm4_scs_dfsr: halted (Bitfield-Mask: 0x01)    */
/* =====================================================  cm4_scs_mmfar  ===================================================== */
/* =====================================================  cm4_scs_bfar  ====================================================== */
/* =====================================================  cm4_scs_afsr  ====================================================== */
/* =====================================================  cm4_scs_cpacr  ===================================================== */
/* =====================================================  cm4_scs_dhcsr  ===================================================== */
#define cm4_scs_cm4_scs_dhcsr_reserved3_Pos (26UL)                  /*!< cm4_scs cm4_scs_dhcsr: reserved3 (Bit 26)             */
#define cm4_scs_cm4_scs_dhcsr_reserved3_Msk (0xfc000000UL)          /*!< cm4_scs cm4_scs_dhcsr: reserved3 (Bitfield-Mask: 0x3f) */
#define cm4_scs_cm4_scs_dhcsr_s_reset_st_Pos (25UL)                 /*!< cm4_scs cm4_scs_dhcsr: s_reset_st (Bit 25)            */
#define cm4_scs_cm4_scs_dhcsr_s_reset_st_Msk (0x2000000UL)          /*!< cm4_scs cm4_scs_dhcsr: s_reset_st (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_dhcsr_s_retire_st_Pos (24UL)                /*!< cm4_scs cm4_scs_dhcsr: s_retire_st (Bit 24)           */
#define cm4_scs_cm4_scs_dhcsr_s_retire_st_Msk (0x1000000UL)         /*!< cm4_scs cm4_scs_dhcsr: s_retire_st (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_dhcsr_reserved2_Pos (20UL)                  /*!< cm4_scs cm4_scs_dhcsr: reserved2 (Bit 20)             */
#define cm4_scs_cm4_scs_dhcsr_reserved2_Msk (0xf00000UL)            /*!< cm4_scs cm4_scs_dhcsr: reserved2 (Bitfield-Mask: 0x0f) */
#define cm4_scs_cm4_scs_dhcsr_s_lockup_Pos (19UL)                   /*!< cm4_scs cm4_scs_dhcsr: s_lockup (Bit 19)              */
#define cm4_scs_cm4_scs_dhcsr_s_lockup_Msk (0x80000UL)              /*!< cm4_scs cm4_scs_dhcsr: s_lockup (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_dhcsr_s_sleep_Pos (18UL)                    /*!< cm4_scs cm4_scs_dhcsr: s_sleep (Bit 18)               */
#define cm4_scs_cm4_scs_dhcsr_s_sleep_Msk (0x40000UL)               /*!< cm4_scs cm4_scs_dhcsr: s_sleep (Bitfield-Mask: 0x01)  */
#define cm4_scs_cm4_scs_dhcsr_s_halt_Pos  (17UL)                    /*!< cm4_scs cm4_scs_dhcsr: s_halt (Bit 17)                */
#define cm4_scs_cm4_scs_dhcsr_s_halt_Msk  (0x20000UL)               /*!< cm4_scs cm4_scs_dhcsr: s_halt (Bitfield-Mask: 0x01)   */
#define cm4_scs_cm4_scs_dhcsr_s_regrdy_Pos (16UL)                   /*!< cm4_scs cm4_scs_dhcsr: s_regrdy (Bit 16)              */
#define cm4_scs_cm4_scs_dhcsr_s_regrdy_Msk (0x10000UL)              /*!< cm4_scs cm4_scs_dhcsr: s_regrdy (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_dhcsr_reserved1_Pos (6UL)                   /*!< cm4_scs cm4_scs_dhcsr: reserved1 (Bit 6)              */
#define cm4_scs_cm4_scs_dhcsr_reserved1_Msk (0xffc0UL)              /*!< cm4_scs cm4_scs_dhcsr: reserved1 (Bitfield-Mask: 0x3ff) */
#define cm4_scs_cm4_scs_dhcsr_c_snapstall_Pos (5UL)                 /*!< cm4_scs cm4_scs_dhcsr: c_snapstall (Bit 5)            */
#define cm4_scs_cm4_scs_dhcsr_c_snapstall_Msk (0x20UL)              /*!< cm4_scs cm4_scs_dhcsr: c_snapstall (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_dhcsr_reserved0_Pos (4UL)                   /*!< cm4_scs cm4_scs_dhcsr: reserved0 (Bit 4)              */
#define cm4_scs_cm4_scs_dhcsr_reserved0_Msk (0x10UL)                /*!< cm4_scs cm4_scs_dhcsr: reserved0 (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_dhcsr_c_maskints_Pos (3UL)                  /*!< cm4_scs cm4_scs_dhcsr: c_maskints (Bit 3)             */
#define cm4_scs_cm4_scs_dhcsr_c_maskints_Msk (0x8UL)                /*!< cm4_scs cm4_scs_dhcsr: c_maskints (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_dhcsr_c_step_Pos  (2UL)                     /*!< cm4_scs cm4_scs_dhcsr: c_step (Bit 2)                 */
#define cm4_scs_cm4_scs_dhcsr_c_step_Msk  (0x4UL)                   /*!< cm4_scs cm4_scs_dhcsr: c_step (Bitfield-Mask: 0x01)   */
#define cm4_scs_cm4_scs_dhcsr_c_halt_Pos  (1UL)                     /*!< cm4_scs cm4_scs_dhcsr: c_halt (Bit 1)                 */
#define cm4_scs_cm4_scs_dhcsr_c_halt_Msk  (0x2UL)                   /*!< cm4_scs cm4_scs_dhcsr: c_halt (Bitfield-Mask: 0x01)   */
#define cm4_scs_cm4_scs_dhcsr_c_debugen_Pos (0UL)                   /*!< cm4_scs cm4_scs_dhcsr: c_debugen (Bit 0)              */
#define cm4_scs_cm4_scs_dhcsr_c_debugen_Msk (0x1UL)                 /*!< cm4_scs cm4_scs_dhcsr: c_debugen (Bitfield-Mask: 0x01) */
/* =====================================================  cm4_scs_dcrsr  ===================================================== */
#define cm4_scs_cm4_scs_dcrsr_reserved1_Pos (17UL)                  /*!< cm4_scs cm4_scs_dcrsr: reserved1 (Bit 17)             */
#define cm4_scs_cm4_scs_dcrsr_reserved1_Msk (0xfffe0000UL)          /*!< cm4_scs cm4_scs_dcrsr: reserved1 (Bitfield-Mask: 0x7fff) */
#define cm4_scs_cm4_scs_dcrsr_regwnr_Pos  (16UL)                    /*!< cm4_scs cm4_scs_dcrsr: regwnr (Bit 16)                */
#define cm4_scs_cm4_scs_dcrsr_regwnr_Msk  (0x10000UL)               /*!< cm4_scs cm4_scs_dcrsr: regwnr (Bitfield-Mask: 0x01)   */
#define cm4_scs_cm4_scs_dcrsr_reserved0_Pos (7UL)                   /*!< cm4_scs cm4_scs_dcrsr: reserved0 (Bit 7)              */
#define cm4_scs_cm4_scs_dcrsr_reserved0_Msk (0xff80UL)              /*!< cm4_scs cm4_scs_dcrsr: reserved0 (Bitfield-Mask: 0x1ff) */
#define cm4_scs_cm4_scs_dcrsr_regsel_Pos  (0UL)                     /*!< cm4_scs cm4_scs_dcrsr: regsel (Bit 0)                 */
#define cm4_scs_cm4_scs_dcrsr_regsel_Msk  (0x7fUL)                  /*!< cm4_scs cm4_scs_dcrsr: regsel (Bitfield-Mask: 0x7f)   */
/* =====================================================  cm4_scs_dcrdr  ===================================================== */
#define cm4_scs_cm4_scs_dcrdr_dbgtmp_Pos  (0UL)                     /*!< cm4_scs cm4_scs_dcrdr: dbgtmp (Bit 0)                 */
#define cm4_scs_cm4_scs_dcrdr_dbgtmp_Msk  (0xffffffffUL)            /*!< cm4_scs cm4_scs_dcrdr: dbgtmp (Bitfield-Mask: 0xffffffff) */
/* =====================================================  cm4_scs_demcr  ===================================================== */
#define cm4_scs_cm4_scs_demcr_reserved3_Pos (25UL)                  /*!< cm4_scs cm4_scs_demcr: reserved3 (Bit 25)             */
#define cm4_scs_cm4_scs_demcr_reserved3_Msk (0xfe000000UL)          /*!< cm4_scs cm4_scs_demcr: reserved3 (Bitfield-Mask: 0x7f) */
#define cm4_scs_cm4_scs_demcr_trcena_Pos  (24UL)                    /*!< cm4_scs cm4_scs_demcr: trcena (Bit 24)                */
#define cm4_scs_cm4_scs_demcr_trcena_Msk  (0x1000000UL)             /*!< cm4_scs cm4_scs_demcr: trcena (Bitfield-Mask: 0x01)   */
#define cm4_scs_cm4_scs_demcr_reserved2_Pos (20UL)                  /*!< cm4_scs cm4_scs_demcr: reserved2 (Bit 20)             */
#define cm4_scs_cm4_scs_demcr_reserved2_Msk (0xf00000UL)            /*!< cm4_scs cm4_scs_demcr: reserved2 (Bitfield-Mask: 0x0f) */
#define cm4_scs_cm4_scs_demcr_mon_req_Pos (19UL)                    /*!< cm4_scs cm4_scs_demcr: mon_req (Bit 19)               */
#define cm4_scs_cm4_scs_demcr_mon_req_Msk (0x80000UL)               /*!< cm4_scs cm4_scs_demcr: mon_req (Bitfield-Mask: 0x01)  */
#define cm4_scs_cm4_scs_demcr_mon_step_Pos (18UL)                   /*!< cm4_scs cm4_scs_demcr: mon_step (Bit 18)              */
#define cm4_scs_cm4_scs_demcr_mon_step_Msk (0x40000UL)              /*!< cm4_scs cm4_scs_demcr: mon_step (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_mon_pend_Pos (17UL)                   /*!< cm4_scs cm4_scs_demcr: mon_pend (Bit 17)              */
#define cm4_scs_cm4_scs_demcr_mon_pend_Msk (0x20000UL)              /*!< cm4_scs cm4_scs_demcr: mon_pend (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_mon_en_Pos  (16UL)                    /*!< cm4_scs cm4_scs_demcr: mon_en (Bit 16)                */
#define cm4_scs_cm4_scs_demcr_mon_en_Msk  (0x10000UL)               /*!< cm4_scs cm4_scs_demcr: mon_en (Bitfield-Mask: 0x01)   */
#define cm4_scs_cm4_scs_demcr_reserved1_Pos (11UL)                  /*!< cm4_scs cm4_scs_demcr: reserved1 (Bit 11)             */
#define cm4_scs_cm4_scs_demcr_reserved1_Msk (0xf800UL)              /*!< cm4_scs cm4_scs_demcr: reserved1 (Bitfield-Mask: 0x1f) */
#define cm4_scs_cm4_scs_demcr_vc_harderr_Pos (10UL)                 /*!< cm4_scs cm4_scs_demcr: vc_harderr (Bit 10)            */
#define cm4_scs_cm4_scs_demcr_vc_harderr_Msk (0x400UL)              /*!< cm4_scs cm4_scs_demcr: vc_harderr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_vc_interr_Pos (9UL)                   /*!< cm4_scs cm4_scs_demcr: vc_interr (Bit 9)              */
#define cm4_scs_cm4_scs_demcr_vc_interr_Msk (0x200UL)               /*!< cm4_scs cm4_scs_demcr: vc_interr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_vc_buserr_Pos (8UL)                   /*!< cm4_scs cm4_scs_demcr: vc_buserr (Bit 8)              */
#define cm4_scs_cm4_scs_demcr_vc_buserr_Msk (0x100UL)               /*!< cm4_scs cm4_scs_demcr: vc_buserr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_vc_staterr_Pos (7UL)                  /*!< cm4_scs cm4_scs_demcr: vc_staterr (Bit 7)             */
#define cm4_scs_cm4_scs_demcr_vc_staterr_Msk (0x80UL)               /*!< cm4_scs cm4_scs_demcr: vc_staterr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_vc_chkerr_Pos (6UL)                   /*!< cm4_scs cm4_scs_demcr: vc_chkerr (Bit 6)              */
#define cm4_scs_cm4_scs_demcr_vc_chkerr_Msk (0x40UL)                /*!< cm4_scs cm4_scs_demcr: vc_chkerr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_vc_nocperr_Pos (5UL)                  /*!< cm4_scs cm4_scs_demcr: vc_nocperr (Bit 5)             */
#define cm4_scs_cm4_scs_demcr_vc_nocperr_Msk (0x20UL)               /*!< cm4_scs cm4_scs_demcr: vc_nocperr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_vc_mmerr_Pos (4UL)                    /*!< cm4_scs cm4_scs_demcr: vc_mmerr (Bit 4)               */
#define cm4_scs_cm4_scs_demcr_vc_mmerr_Msk (0x10UL)                 /*!< cm4_scs cm4_scs_demcr: vc_mmerr (Bitfield-Mask: 0x01) */
#define cm4_scs_cm4_scs_demcr_reserved0_Pos (1UL)                   /*!< cm4_scs cm4_scs_demcr: reserved0 (Bit 1)              */
#define cm4_scs_cm4_scs_demcr_reserved0_Msk (0xeUL)                 /*!< cm4_scs cm4_scs_demcr: reserved0 (Bitfield-Mask: 0x07) */
#define cm4_scs_cm4_scs_demcr_vc_corereset_Pos (0UL)                /*!< cm4_scs cm4_scs_demcr: vc_corereset (Bit 0)           */
#define cm4_scs_cm4_scs_demcr_vc_corereset_Msk (0x1UL)              /*!< cm4_scs cm4_scs_demcr: vc_corereset (Bitfield-Mask: 0x01) */
/* =====================================================  cm4_scs_pidr4  ===================================================== */
/* =====================================================  cm4_scs_pidr0  ===================================================== */
/* =====================================================  cm4_scs_pidr1  ===================================================== */
/* =====================================================  cm4_scs_pidr2  ===================================================== */
/* =====================================================  cm4_scs_pidr3  ===================================================== */
/* =====================================================  cm4_scs_cidr0  ===================================================== */
#define cm4_scs_cm4_scs_cidr0_prmbl_0_Pos (0UL)                     /*!< cm4_scs cm4_scs_cidr0: prmbl_0 (Bit 0)                */
#define cm4_scs_cm4_scs_cidr0_prmbl_0_Msk (0xffUL)                  /*!< cm4_scs cm4_scs_cidr0: prmbl_0 (Bitfield-Mask: 0xff)  */
/* =====================================================  cm4_scs_cidr1  ===================================================== */
#define cm4_scs_cm4_scs_cidr1_cclass_Pos  (4UL)                     /*!< cm4_scs cm4_scs_cidr1: cclass (Bit 4)                 */
#define cm4_scs_cm4_scs_cidr1_cclass_Msk  (0xf0UL)                  /*!< cm4_scs cm4_scs_cidr1: cclass (Bitfield-Mask: 0x0f)   */
#define cm4_scs_cm4_scs_cidr1_prmbl_1_Pos (0UL)                     /*!< cm4_scs cm4_scs_cidr1: prmbl_1 (Bit 0)                */
#define cm4_scs_cm4_scs_cidr1_prmbl_1_Msk (0xfUL)                   /*!< cm4_scs cm4_scs_cidr1: prmbl_1 (Bitfield-Mask: 0x0f)  */
/* =====================================================  cm4_scs_cidr2  ===================================================== */
#define cm4_scs_cm4_scs_cidr2_prmbl_2_Pos (0UL)                     /*!< cm4_scs cm4_scs_cidr2: prmbl_2 (Bit 0)                */
#define cm4_scs_cm4_scs_cidr2_prmbl_2_Msk (0xffUL)                  /*!< cm4_scs cm4_scs_cidr2: prmbl_2 (Bitfield-Mask: 0xff)  */
/* =====================================================  cm4_scs_cidr3  ===================================================== */
#define cm4_scs_cm4_scs_cidr3_prmbl_3_Pos (0UL)                     /*!< cm4_scs cm4_scs_cidr3: prmbl_3 (Bit 0)                */
#define cm4_scs_cm4_scs_cidr3_prmbl_3_Msk (0xffUL)                  /*!< cm4_scs cm4_scs_cidr3: prmbl_3 (Bitfield-Mask: 0xff)  */


/* =========================================================================================================================== */
/* ================                                       cm4_misc_ctrl                                       ================ */
/* =========================================================================================================================== */

/* ================================================  cm4_misc_ctrl_cpu_info  ================================================= */
#define cm4_misc_ctrl_cm4_misc_ctrl_cpu_info_fpu_Pos (1UL)          /*!< cm4_misc_ctrl cm4_misc_ctrl_cpu_info: fpu (Bit 1)     */
#define cm4_misc_ctrl_cm4_misc_ctrl_cpu_info_fpu_Msk (0x2UL)        /*!< cm4_misc_ctrl cm4_misc_ctrl_cpu_info: fpu (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_cpu_info_id_Pos (0UL)           /*!< cm4_misc_ctrl cm4_misc_ctrl_cpu_info: id (Bit 0)      */
#define cm4_misc_ctrl_cm4_misc_ctrl_cpu_info_id_Msk (0x1UL)         /*!< cm4_misc_ctrl cm4_misc_ctrl_cpu_info: id (Bitfield-Mask: 0x01) */
/* ===============================================  cm4_misc_ctrl_fpu_irq_raw  =============================================== */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_idc_Pos (5UL)       /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: idc (Bit 5)  */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_idc_Msk (0x20UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: idc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ioc_Pos (4UL)       /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ioc (Bit 4)  */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ioc_Msk (0x10UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ioc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_dzc_Pos (3UL)       /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: dzc (Bit 3)  */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_dzc_Msk (0x8UL)     /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: dzc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ofc_Pos (2UL)       /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ofc (Bit 2)  */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ofc_Msk (0x4UL)     /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ofc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ufc_Pos (1UL)       /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ufc (Bit 1)  */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ufc_Msk (0x2UL)     /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ufc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ixc_Pos (0UL)       /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ixc (Bit 0)  */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw_ixc_Msk (0x1UL)     /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_raw: ixc (Bitfield-Mask: 0x01) */
/* =============================================  cm4_misc_ctrl_fpu_irq_masked  ============================================== */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_idc_Pos (5UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: idc (Bit 5) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_idc_Msk (0x20UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: idc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ioc_Pos (4UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ioc (Bit 4) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ioc_Msk (0x10UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ioc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_dzc_Pos (3UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: dzc (Bit 3) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_dzc_Msk (0x8UL)  /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: dzc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ofc_Pos (2UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ofc (Bit 2) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ofc_Msk (0x4UL)  /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ofc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ufc_Pos (1UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ufc (Bit 1) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ufc_Msk (0x2UL)  /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ufc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ixc_Pos (0UL)    /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ixc (Bit 0) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked_ixc_Msk (0x1UL)  /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_masked: ixc (Bitfield-Mask: 0x01) */
/* =============================================  cm4_misc_ctrl_fpu_irq_msk_set  ============================================= */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_idc_Pos (5UL)   /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: idc (Bit 5) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_idc_Msk (0x20UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: idc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ioc_Pos (4UL)   /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ioc (Bit 4) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ioc_Msk (0x10UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ioc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_dzc_Pos (3UL)   /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: dzc (Bit 3) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_dzc_Msk (0x8UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: dzc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ofc_Pos (2UL)   /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ofc (Bit 2) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ofc_Msk (0x4UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ofc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ufc_Pos (1UL)   /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ufc (Bit 1) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ufc_Msk (0x2UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ufc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ixc_Pos (0UL)   /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ixc (Bit 0) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set_ixc_Msk (0x1UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_set: ixc (Bitfield-Mask: 0x01) */
/* ============================================  cm4_misc_ctrl_fpu_irq_msk_reset  ============================================ */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_idc_Pos (5UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: idc (Bit 5) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_idc_Msk (0x20UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: idc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ioc_Pos (4UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ioc (Bit 4) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ioc_Msk (0x10UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ioc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_dzc_Pos (3UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: dzc (Bit 3) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_dzc_Msk (0x8UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: dzc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ofc_Pos (2UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ofc (Bit 2) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ofc_Msk (0x4UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ofc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ufc_Pos (1UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ufc (Bit 1) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ufc_Msk (0x2UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ufc (Bitfield-Mask: 0x01) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ixc_Pos (0UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ixc (Bit 0) */
#define cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset_ixc_Msk (0x1UL) /*!< cm4_misc_ctrl cm4_misc_ctrl_fpu_irq_msk_reset: ixc (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         idpm_com                                          ================ */
/* =========================================================================================================================== */

/* ======================================================  idpm_cfg0x0  ====================================================== */
#define idpm_com_idpm_cfg0x0_reserved1_Pos (6UL)                    /*!< idpm_com idpm_cfg0x0: reserved1 (Bit 6)               */
#define idpm_com_idpm_cfg0x0_reserved1_Msk (0xffffffc0UL)           /*!< idpm_com idpm_cfg0x0: reserved1 (Bitfield-Mask: 0x3ffffff) */
#define idpm_com_idpm_cfg0x0_endian_Pos   (4UL)                     /*!< idpm_com idpm_cfg0x0: endian (Bit 4)                  */
#define idpm_com_idpm_cfg0x0_endian_Msk   (0x30UL)                  /*!< idpm_com idpm_cfg0x0: endian (Bitfield-Mask: 0x03)    */
#define idpm_com_idpm_cfg0x0_reserved0_Pos (1UL)                    /*!< idpm_com idpm_cfg0x0: reserved0 (Bit 1)               */
#define idpm_com_idpm_cfg0x0_reserved0_Msk (0xeUL)                  /*!< idpm_com idpm_cfg0x0: reserved0 (Bitfield-Mask: 0x07) */
#define idpm_com_idpm_cfg0x0_enable_Pos   (0UL)                     /*!< idpm_com idpm_cfg0x0: enable (Bit 0)                  */
#define idpm_com_idpm_cfg0x0_enable_Msk   (0x1UL)                   /*!< idpm_com idpm_cfg0x0: enable (Bitfield-Mask: 0x01)    */
/* =====================================================  idpm_addr_cfg  ===================================================== */
#define idpm_com_idpm_addr_cfg_reserved1_Pos (6UL)                  /*!< idpm_com idpm_addr_cfg: reserved1 (Bit 6)             */
#define idpm_com_idpm_addr_cfg_reserved1_Msk (0xffffffc0UL)         /*!< idpm_com idpm_addr_cfg: reserved1 (Bitfield-Mask: 0x3ffffff) */
#define idpm_com_idpm_addr_cfg_cfg_win_addr_cfg_Pos (4UL)           /*!< idpm_com idpm_addr_cfg: cfg_win_addr_cfg (Bit 4)      */
#define idpm_com_idpm_addr_cfg_cfg_win_addr_cfg_Msk (0x30UL)        /*!< idpm_com idpm_addr_cfg: cfg_win_addr_cfg (Bitfield-Mask: 0x03) */
#define idpm_com_idpm_addr_cfg_reserved0_Pos (0UL)                  /*!< idpm_com idpm_addr_cfg: reserved0 (Bit 0)             */
#define idpm_com_idpm_addr_cfg_reserved0_Msk (0xfUL)                /*!< idpm_com idpm_addr_cfg: reserved0 (Bitfield-Mask: 0x0f) */
/* ======================================================  idpm_status  ====================================================== */
#define idpm_com_idpm_status_unlocked_Pos (0UL)                     /*!< idpm_com idpm_status: unlocked (Bit 0)                */
#define idpm_com_idpm_status_unlocked_Msk (0x1UL)                   /*!< idpm_com idpm_status: unlocked (Bitfield-Mask: 0x01)  */
/* ====================================================  idpm_tunnel_cfg  ==================================================== */
#define idpm_com_idpm_tunnel_cfg_wp_cfg_win_Pos (31UL)              /*!< idpm_com idpm_tunnel_cfg: wp_cfg_win (Bit 31)         */
#define idpm_com_idpm_tunnel_cfg_wp_cfg_win_Msk (0x80000000UL)      /*!< idpm_com idpm_tunnel_cfg: wp_cfg_win (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_tunnel_cfg_reserved1_Pos (15UL)               /*!< idpm_com idpm_tunnel_cfg: reserved1 (Bit 15)          */
#define idpm_com_idpm_tunnel_cfg_reserved1_Msk (0x7fff8000UL)       /*!< idpm_com idpm_tunnel_cfg: reserved1 (Bitfield-Mask: 0xffff) */
#define idpm_com_idpm_tunnel_cfg_base_Pos (6UL)                     /*!< idpm_com idpm_tunnel_cfg: base (Bit 6)                */
#define idpm_com_idpm_tunnel_cfg_base_Msk (0x7fc0UL)                /*!< idpm_com idpm_tunnel_cfg: base (Bitfield-Mask: 0x1ff) */
#define idpm_com_idpm_tunnel_cfg_reserved0_Pos (4UL)                /*!< idpm_com idpm_tunnel_cfg: reserved0 (Bit 4)           */
#define idpm_com_idpm_tunnel_cfg_reserved0_Msk (0x30UL)             /*!< idpm_com idpm_tunnel_cfg: reserved0 (Bitfield-Mask: 0x03) */
#define idpm_com_idpm_tunnel_cfg_tunnel_all_Pos (3UL)               /*!< idpm_com idpm_tunnel_cfg: tunnel_all (Bit 3)          */
#define idpm_com_idpm_tunnel_cfg_tunnel_all_Msk (0x8UL)             /*!< idpm_com idpm_tunnel_cfg: tunnel_all (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_tunnel_cfg_enable_Pos (2UL)                   /*!< idpm_com idpm_tunnel_cfg: enable (Bit 2)              */
#define idpm_com_idpm_tunnel_cfg_enable_Msk (0x4UL)                 /*!< idpm_com idpm_tunnel_cfg: enable (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_tunnel_cfg_wp_itbaddr_Pos (1UL)               /*!< idpm_com idpm_tunnel_cfg: wp_itbaddr (Bit 1)          */
#define idpm_com_idpm_tunnel_cfg_wp_itbaddr_Msk (0x2UL)             /*!< idpm_com idpm_tunnel_cfg: wp_itbaddr (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_tunnel_cfg_wp_data_Pos (0UL)                  /*!< idpm_com idpm_tunnel_cfg: wp_data (Bit 0)             */
#define idpm_com_idpm_tunnel_cfg_wp_data_Msk (0x1UL)                /*!< idpm_com idpm_tunnel_cfg: wp_data (Bitfield-Mask: 0x01) */
/* =====================================================  idpm_itbaddr  ====================================================== */
#define idpm_com_idpm_itbaddr_base_Pos    (6UL)                     /*!< idpm_com idpm_itbaddr: base (Bit 6)                   */
#define idpm_com_idpm_itbaddr_base_Msk    (0xffffffc0UL)            /*!< idpm_com idpm_itbaddr: base (Bitfield-Mask: 0x3ffffff) */
#define idpm_com_idpm_itbaddr_map_Pos     (2UL)                     /*!< idpm_com idpm_itbaddr: map (Bit 2)                    */
#define idpm_com_idpm_itbaddr_map_Msk     (0x3cUL)                  /*!< idpm_com idpm_itbaddr: map (Bitfield-Mask: 0x0f)      */
#define idpm_com_idpm_itbaddr_wp_itbaddr_ro_Pos (1UL)               /*!< idpm_com idpm_itbaddr: wp_itbaddr_ro (Bit 1)          */
#define idpm_com_idpm_itbaddr_wp_itbaddr_ro_Msk (0x2UL)             /*!< idpm_com idpm_itbaddr: wp_itbaddr_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_itbaddr_wp_data_ro_Pos (0UL)                  /*!< idpm_com idpm_itbaddr: wp_data_ro (Bit 0)             */
#define idpm_com_idpm_itbaddr_wp_data_ro_Msk (0x1UL)                /*!< idpm_com idpm_itbaddr: wp_data_ro (Bitfield-Mask: 0x01) */
/* =====================================================  idpm_win1_end  ===================================================== */
#define idpm_com_idpm_win1_end_reserved1_Pos (16UL)                 /*!< idpm_com idpm_win1_end: reserved1 (Bit 16)            */
#define idpm_com_idpm_win1_end_reserved1_Msk (0xffff0000UL)         /*!< idpm_com idpm_win1_end: reserved1 (Bitfield-Mask: 0xffff) */
#define idpm_com_idpm_win1_end_win_end_Pos (7UL)                    /*!< idpm_com idpm_win1_end: win_end (Bit 7)               */
#define idpm_com_idpm_win1_end_win_end_Msk (0xff80UL)               /*!< idpm_com idpm_win1_end: win_end (Bitfield-Mask: 0x1ff) */
#define idpm_com_idpm_win1_end_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win1_end: reserved0 (Bit 0)             */
#define idpm_com_idpm_win1_end_reserved0_Msk (0x7fUL)               /*!< idpm_com idpm_win1_end: reserved0 (Bitfield-Mask: 0x7f) */
/* =====================================================  idpm_win1_map  ===================================================== */
#define idpm_com_idpm_win1_map_reserved3_Pos (15UL)                 /*!< idpm_com idpm_win1_map: reserved3 (Bit 15)            */
#define idpm_com_idpm_win1_map_reserved3_Msk (0xffff8000UL)         /*!< idpm_com idpm_win1_map: reserved3 (Bitfield-Mask: 0x1ffff) */
#define idpm_com_idpm_win1_map_win_map_Pos (7UL)                    /*!< idpm_com idpm_win1_map: win_map (Bit 7)               */
#define idpm_com_idpm_win1_map_win_map_Msk (0x7f80UL)               /*!< idpm_com idpm_win1_map: win_map (Bitfield-Mask: 0xff) */
#define idpm_com_idpm_win1_map_reserved2_Pos (6UL)                  /*!< idpm_com idpm_win1_map: reserved2 (Bit 6)             */
#define idpm_com_idpm_win1_map_reserved2_Msk (0x40UL)               /*!< idpm_com idpm_win1_map: reserved2 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_win1_map_wp_cfg_win_Pos (5UL)                 /*!< idpm_com idpm_win1_map: wp_cfg_win (Bit 5)            */
#define idpm_com_idpm_win1_map_wp_cfg_win_Msk (0x20UL)              /*!< idpm_com idpm_win1_map: wp_cfg_win (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_win1_map_reserved1_Pos (4UL)                  /*!< idpm_com idpm_win1_map: reserved1 (Bit 4)             */
#define idpm_com_idpm_win1_map_reserved1_Msk (0x10UL)               /*!< idpm_com idpm_win1_map: reserved1 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_win1_map_win_map_alt_Pos (2UL)                /*!< idpm_com idpm_win1_map: win_map_alt (Bit 2)           */
#define idpm_com_idpm_win1_map_win_map_alt_Msk (0xcUL)              /*!< idpm_com idpm_win1_map: win_map_alt (Bitfield-Mask: 0x03) */
#define idpm_com_idpm_win1_map_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win1_map: reserved0 (Bit 0)             */
#define idpm_com_idpm_win1_map_reserved0_Msk (0x3UL)                /*!< idpm_com idpm_win1_map: reserved0 (Bitfield-Mask: 0x03) */
/* =====================================================  idpm_win2_end  ===================================================== */
#define idpm_com_idpm_win2_end_reserved1_Pos (16UL)                 /*!< idpm_com idpm_win2_end: reserved1 (Bit 16)            */
#define idpm_com_idpm_win2_end_reserved1_Msk (0xffff0000UL)         /*!< idpm_com idpm_win2_end: reserved1 (Bitfield-Mask: 0xffff) */
#define idpm_com_idpm_win2_end_win_end_Pos (7UL)                    /*!< idpm_com idpm_win2_end: win_end (Bit 7)               */
#define idpm_com_idpm_win2_end_win_end_Msk (0xff80UL)               /*!< idpm_com idpm_win2_end: win_end (Bitfield-Mask: 0x1ff) */
#define idpm_com_idpm_win2_end_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win2_end: reserved0 (Bit 0)             */
#define idpm_com_idpm_win2_end_reserved0_Msk (0x7fUL)               /*!< idpm_com idpm_win2_end: reserved0 (Bitfield-Mask: 0x7f) */
/* =====================================================  idpm_win2_map  ===================================================== */
#define idpm_com_idpm_win2_map_reserved2_Pos (15UL)                 /*!< idpm_com idpm_win2_map: reserved2 (Bit 15)            */
#define idpm_com_idpm_win2_map_reserved2_Msk (0xffff8000UL)         /*!< idpm_com idpm_win2_map: reserved2 (Bitfield-Mask: 0x1ffff) */
#define idpm_com_idpm_win2_map_win_map_Pos (7UL)                    /*!< idpm_com idpm_win2_map: win_map (Bit 7)               */
#define idpm_com_idpm_win2_map_win_map_Msk (0x7f80UL)               /*!< idpm_com idpm_win2_map: win_map (Bitfield-Mask: 0xff) */
#define idpm_com_idpm_win2_map_reserved1_Pos (4UL)                  /*!< idpm_com idpm_win2_map: reserved1 (Bit 4)             */
#define idpm_com_idpm_win2_map_reserved1_Msk (0x70UL)               /*!< idpm_com idpm_win2_map: reserved1 (Bitfield-Mask: 0x07) */
#define idpm_com_idpm_win2_map_win_map_alt_Pos (2UL)                /*!< idpm_com idpm_win2_map: win_map_alt (Bit 2)           */
#define idpm_com_idpm_win2_map_win_map_alt_Msk (0xcUL)              /*!< idpm_com idpm_win2_map: win_map_alt (Bitfield-Mask: 0x03) */
#define idpm_com_idpm_win2_map_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win2_map: reserved0 (Bit 0)             */
#define idpm_com_idpm_win2_map_reserved0_Msk (0x3UL)                /*!< idpm_com idpm_win2_map: reserved0 (Bitfield-Mask: 0x03) */
/* =====================================================  idpm_win3_end  ===================================================== */
#define idpm_com_idpm_win3_end_reserved1_Pos (16UL)                 /*!< idpm_com idpm_win3_end: reserved1 (Bit 16)            */
#define idpm_com_idpm_win3_end_reserved1_Msk (0xffff0000UL)         /*!< idpm_com idpm_win3_end: reserved1 (Bitfield-Mask: 0xffff) */
#define idpm_com_idpm_win3_end_win_end_Pos (7UL)                    /*!< idpm_com idpm_win3_end: win_end (Bit 7)               */
#define idpm_com_idpm_win3_end_win_end_Msk (0xff80UL)               /*!< idpm_com idpm_win3_end: win_end (Bitfield-Mask: 0x1ff) */
#define idpm_com_idpm_win3_end_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win3_end: reserved0 (Bit 0)             */
#define idpm_com_idpm_win3_end_reserved0_Msk (0x7fUL)               /*!< idpm_com idpm_win3_end: reserved0 (Bitfield-Mask: 0x7f) */
/* =====================================================  idpm_win3_map  ===================================================== */
#define idpm_com_idpm_win3_map_reserved2_Pos (15UL)                 /*!< idpm_com idpm_win3_map: reserved2 (Bit 15)            */
#define idpm_com_idpm_win3_map_reserved2_Msk (0xffff8000UL)         /*!< idpm_com idpm_win3_map: reserved2 (Bitfield-Mask: 0x1ffff) */
#define idpm_com_idpm_win3_map_win_map_Pos (7UL)                    /*!< idpm_com idpm_win3_map: win_map (Bit 7)               */
#define idpm_com_idpm_win3_map_win_map_Msk (0x7f80UL)               /*!< idpm_com idpm_win3_map: win_map (Bitfield-Mask: 0xff) */
#define idpm_com_idpm_win3_map_reserved1_Pos (4UL)                  /*!< idpm_com idpm_win3_map: reserved1 (Bit 4)             */
#define idpm_com_idpm_win3_map_reserved1_Msk (0x70UL)               /*!< idpm_com idpm_win3_map: reserved1 (Bitfield-Mask: 0x07) */
#define idpm_com_idpm_win3_map_win_map_alt_Pos (2UL)                /*!< idpm_com idpm_win3_map: win_map_alt (Bit 2)           */
#define idpm_com_idpm_win3_map_win_map_alt_Msk (0xcUL)              /*!< idpm_com idpm_win3_map: win_map_alt (Bitfield-Mask: 0x03) */
#define idpm_com_idpm_win3_map_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win3_map: reserved0 (Bit 0)             */
#define idpm_com_idpm_win3_map_reserved0_Msk (0x3UL)                /*!< idpm_com idpm_win3_map: reserved0 (Bitfield-Mask: 0x03) */
/* =====================================================  idpm_win4_end  ===================================================== */
#define idpm_com_idpm_win4_end_reserved1_Pos (16UL)                 /*!< idpm_com idpm_win4_end: reserved1 (Bit 16)            */
#define idpm_com_idpm_win4_end_reserved1_Msk (0xffff0000UL)         /*!< idpm_com idpm_win4_end: reserved1 (Bitfield-Mask: 0xffff) */
#define idpm_com_idpm_win4_end_win_end_Pos (7UL)                    /*!< idpm_com idpm_win4_end: win_end (Bit 7)               */
#define idpm_com_idpm_win4_end_win_end_Msk (0xff80UL)               /*!< idpm_com idpm_win4_end: win_end (Bitfield-Mask: 0x1ff) */
#define idpm_com_idpm_win4_end_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win4_end: reserved0 (Bit 0)             */
#define idpm_com_idpm_win4_end_reserved0_Msk (0x7fUL)               /*!< idpm_com idpm_win4_end: reserved0 (Bitfield-Mask: 0x7f) */
/* =====================================================  idpm_win4_map  ===================================================== */
#define idpm_com_idpm_win4_map_reserved2_Pos (15UL)                 /*!< idpm_com idpm_win4_map: reserved2 (Bit 15)            */
#define idpm_com_idpm_win4_map_reserved2_Msk (0xffff8000UL)         /*!< idpm_com idpm_win4_map: reserved2 (Bitfield-Mask: 0x1ffff) */
#define idpm_com_idpm_win4_map_win_map_Pos (7UL)                    /*!< idpm_com idpm_win4_map: win_map (Bit 7)               */
#define idpm_com_idpm_win4_map_win_map_Msk (0x7f80UL)               /*!< idpm_com idpm_win4_map: win_map (Bitfield-Mask: 0xff) */
#define idpm_com_idpm_win4_map_reserved1_Pos (4UL)                  /*!< idpm_com idpm_win4_map: reserved1 (Bit 4)             */
#define idpm_com_idpm_win4_map_reserved1_Msk (0x70UL)               /*!< idpm_com idpm_win4_map: reserved1 (Bitfield-Mask: 0x07) */
#define idpm_com_idpm_win4_map_win_map_alt_Pos (2UL)                /*!< idpm_com idpm_win4_map: win_map_alt (Bit 2)           */
#define idpm_com_idpm_win4_map_win_map_alt_Msk (0xcUL)              /*!< idpm_com idpm_win4_map: win_map_alt (Bitfield-Mask: 0x03) */
#define idpm_com_idpm_win4_map_reserved0_Pos (0UL)                  /*!< idpm_com idpm_win4_map: reserved0 (Bit 0)             */
#define idpm_com_idpm_win4_map_reserved0_Msk (0x3UL)                /*!< idpm_com idpm_win4_map: reserved0 (Bitfield-Mask: 0x03) */
/* =====================================================  idpm_irq_raw  ====================================================== */
#define idpm_com_idpm_irq_raw_reserved1_Pos (3UL)                   /*!< idpm_com idpm_irq_raw: reserved1 (Bit 3)              */
#define idpm_com_idpm_irq_raw_reserved1_Msk (0xfffffff8UL)          /*!< idpm_com idpm_irq_raw: reserved1 (Bitfield-Mask: 0x1fffffff) */
#define idpm_com_idpm_irq_raw_firmware_Pos (2UL)                    /*!< idpm_com idpm_irq_raw: firmware (Bit 2)               */
#define idpm_com_idpm_irq_raw_firmware_Msk (0x4UL)                  /*!< idpm_com idpm_irq_raw: firmware (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_raw_reserved0_Pos (1UL)                   /*!< idpm_com idpm_irq_raw: reserved0 (Bit 1)              */
#define idpm_com_idpm_irq_raw_reserved0_Msk (0x2UL)                 /*!< idpm_com idpm_irq_raw: reserved0 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_raw_dpm_sw_Pos  (0UL)                     /*!< idpm_com idpm_irq_raw: dpm_sw (Bit 0)                 */
#define idpm_com_idpm_irq_raw_dpm_sw_Msk  (0x1UL)                   /*!< idpm_com idpm_irq_raw: dpm_sw (Bitfield-Mask: 0x01)   */
/* ================================================  idpm_irq_host_mask_set  ================================================= */
#define idpm_com_idpm_irq_host_mask_set_reserved1_Pos (3UL)         /*!< idpm_com idpm_irq_host_mask_set: reserved1 (Bit 3)    */
#define idpm_com_idpm_irq_host_mask_set_reserved1_Msk (0xfffffff8UL) /*!< idpm_com idpm_irq_host_mask_set: reserved1 (Bitfield-Mask: 0x1fffffff) */
#define idpm_com_idpm_irq_host_mask_set_firmware_Pos (2UL)          /*!< idpm_com idpm_irq_host_mask_set: firmware (Bit 2)     */
#define idpm_com_idpm_irq_host_mask_set_firmware_Msk (0x4UL)        /*!< idpm_com idpm_irq_host_mask_set: firmware (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_host_mask_set_reserved0_Pos (1UL)         /*!< idpm_com idpm_irq_host_mask_set: reserved0 (Bit 1)    */
#define idpm_com_idpm_irq_host_mask_set_reserved0_Msk (0x2UL)       /*!< idpm_com idpm_irq_host_mask_set: reserved0 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_host_mask_set_dpm_sw_Pos (0UL)            /*!< idpm_com idpm_irq_host_mask_set: dpm_sw (Bit 0)       */
#define idpm_com_idpm_irq_host_mask_set_dpm_sw_Msk (0x1UL)          /*!< idpm_com idpm_irq_host_mask_set: dpm_sw (Bitfield-Mask: 0x01) */
/* ===============================================  idpm_irq_host_mask_reset  ================================================ */
#define idpm_com_idpm_irq_host_mask_reset_reserved1_Pos (3UL)       /*!< idpm_com idpm_irq_host_mask_reset: reserved1 (Bit 3)  */
#define idpm_com_idpm_irq_host_mask_reset_reserved1_Msk (0xfffffff8UL) /*!< idpm_com idpm_irq_host_mask_reset: reserved1 (Bitfield-Mask: 0x1fffffff) */
#define idpm_com_idpm_irq_host_mask_reset_firmware_Pos (2UL)        /*!< idpm_com idpm_irq_host_mask_reset: firmware (Bit 2)   */
#define idpm_com_idpm_irq_host_mask_reset_firmware_Msk (0x4UL)      /*!< idpm_com idpm_irq_host_mask_reset: firmware (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_host_mask_reset_reserved0_Pos (1UL)       /*!< idpm_com idpm_irq_host_mask_reset: reserved0 (Bit 1)  */
#define idpm_com_idpm_irq_host_mask_reset_reserved0_Msk (0x2UL)     /*!< idpm_com idpm_irq_host_mask_reset: reserved0 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_host_mask_reset_dpm_sw_Pos (0UL)          /*!< idpm_com idpm_irq_host_mask_reset: dpm_sw (Bit 0)     */
#define idpm_com_idpm_irq_host_mask_reset_dpm_sw_Msk (0x1UL)        /*!< idpm_com idpm_irq_host_mask_reset: dpm_sw (Bitfield-Mask: 0x01) */
/* =================================================  idpm_irq_host_masked  ================================================== */
#define idpm_com_idpm_irq_host_masked_reserved1_Pos (3UL)           /*!< idpm_com idpm_irq_host_masked: reserved1 (Bit 3)      */
#define idpm_com_idpm_irq_host_masked_reserved1_Msk (0xfffffff8UL)  /*!< idpm_com idpm_irq_host_masked: reserved1 (Bitfield-Mask: 0x1fffffff) */
#define idpm_com_idpm_irq_host_masked_firmware_Pos (2UL)            /*!< idpm_com idpm_irq_host_masked: firmware (Bit 2)       */
#define idpm_com_idpm_irq_host_masked_firmware_Msk (0x4UL)          /*!< idpm_com idpm_irq_host_masked: firmware (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_host_masked_reserved0_Pos (1UL)           /*!< idpm_com idpm_irq_host_masked: reserved0 (Bit 1)      */
#define idpm_com_idpm_irq_host_masked_reserved0_Msk (0x2UL)         /*!< idpm_com idpm_irq_host_masked: reserved0 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_irq_host_masked_dpm_sw_Pos (0UL)              /*!< idpm_com idpm_irq_host_masked: dpm_sw (Bit 0)         */
#define idpm_com_idpm_irq_host_masked_dpm_sw_Msk (0x1UL)            /*!< idpm_com idpm_irq_host_masked: dpm_sw (Bitfield-Mask: 0x01) */
/* ======================================================  idpm_sw_irq  ====================================================== */
#define idpm_com_idpm_sw_irq_reserved1_Pos (9UL)                    /*!< idpm_com idpm_sw_irq: reserved1 (Bit 9)               */
#define idpm_com_idpm_sw_irq_reserved1_Msk (0xfffffe00UL)           /*!< idpm_com idpm_sw_irq: reserved1 (Bitfield-Mask: 0x7fffff) */
#define idpm_com_idpm_sw_irq_reset_host_Pos (8UL)                   /*!< idpm_com idpm_sw_irq: reset_host (Bit 8)              */
#define idpm_com_idpm_sw_irq_reset_host_Msk (0x100UL)               /*!< idpm_com idpm_sw_irq: reset_host (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_sw_irq_reserved0_Pos (1UL)                    /*!< idpm_com idpm_sw_irq: reserved0 (Bit 1)               */
#define idpm_com_idpm_sw_irq_reserved0_Msk (0xfeUL)                 /*!< idpm_com idpm_sw_irq: reserved0 (Bitfield-Mask: 0x7f) */
#define idpm_com_idpm_sw_irq_set_host_Pos (0UL)                     /*!< idpm_com idpm_sw_irq: set_host (Bit 0)                */
#define idpm_com_idpm_sw_irq_set_host_Msk (0x1UL)                   /*!< idpm_com idpm_sw_irq: set_host (Bitfield-Mask: 0x01)  */
/* =====================================================  idpm_sys_sta  ====================================================== */
#define idpm_com_idpm_sys_sta_NETX_STA_CODE_ro_Pos (8UL)            /*!< idpm_com idpm_sys_sta: NETX_STA_CODE_ro (Bit 8)       */
#define idpm_com_idpm_sys_sta_NETX_STA_CODE_ro_Msk (0xff00UL)       /*!< idpm_com idpm_sys_sta: NETX_STA_CODE_ro (Bitfield-Mask: 0xff) */
#define idpm_com_idpm_sys_sta_HOST_STATE_Pos (4UL)                  /*!< idpm_com idpm_sys_sta: HOST_STATE (Bit 4)             */
#define idpm_com_idpm_sys_sta_HOST_STATE_Msk (0xf0UL)               /*!< idpm_com idpm_sys_sta: HOST_STATE (Bitfield-Mask: 0x0f) */
#define idpm_com_idpm_sys_sta_NETX_STATE_ro_Pos (2UL)               /*!< idpm_com idpm_sys_sta: NETX_STATE_ro (Bit 2)          */
#define idpm_com_idpm_sys_sta_NETX_STATE_ro_Msk (0xcUL)             /*!< idpm_com idpm_sys_sta: NETX_STATE_ro (Bitfield-Mask: 0x03) */
#define idpm_com_idpm_sys_sta_RUN_ro_Pos  (1UL)                     /*!< idpm_com idpm_sys_sta: RUN_ro (Bit 1)                 */
#define idpm_com_idpm_sys_sta_RUN_ro_Msk  (0x2UL)                   /*!< idpm_com idpm_sys_sta: RUN_ro (Bitfield-Mask: 0x01)   */
#define idpm_com_idpm_sys_sta_RDY_ro_Pos  (0UL)                     /*!< idpm_com idpm_sys_sta: RDY_ro (Bit 0)                 */
#define idpm_com_idpm_sys_sta_RDY_ro_Msk  (0x1UL)                   /*!< idpm_com idpm_sys_sta: RDY_ro (Bitfield-Mask: 0x01)   */
/* ==================================================  idpm_reset_request  =================================================== */
#define idpm_com_idpm_reset_request_reset_key_Pos (0UL)             /*!< idpm_com idpm_reset_request: reset_key (Bit 0)        */
#define idpm_com_idpm_reset_request_reset_key_Msk (0xffUL)          /*!< idpm_com idpm_reset_request: reset_key (Bitfield-Mask: 0xff) */
/* =================================================  idpm_firmware_irq_raw  ================================================= */
#define idpm_com_idpm_firmware_irq_raw_INT_REQ_Pos (31UL)           /*!< idpm_com idpm_firmware_irq_raw: INT_REQ (Bit 31)      */
#define idpm_com_idpm_firmware_irq_raw_INT_REQ_Msk (0x80000000UL)   /*!< idpm_com idpm_firmware_irq_raw: INT_REQ (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_res_MEM_LCK_ro_Pos (30UL)    /*!< idpm_com idpm_firmware_irq_raw: res_MEM_LCK_ro (Bit 30) */
#define idpm_com_idpm_firmware_irq_raw_res_MEM_LCK_ro_Msk (0x40000000UL) /*!< idpm_com idpm_firmware_irq_raw: res_MEM_LCK_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_res_WDG_NETX_ro_Pos (29UL)   /*!< idpm_com idpm_firmware_irq_raw: res_WDG_NETX_ro (Bit 29) */
#define idpm_com_idpm_firmware_irq_raw_res_WDG_NETX_ro_Msk (0x20000000UL) /*!< idpm_com idpm_firmware_irq_raw: res_WDG_NETX_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro_Pos (28UL) /*!< idpm_com idpm_firmware_irq_raw: res_RDY_TIMEOUT_ro (Bit 28) */
#define idpm_com_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro_Msk (0x10000000UL) /*!< idpm_com idpm_firmware_irq_raw: res_RDY_TIMEOUT_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_reserved1_Pos (27UL)         /*!< idpm_com idpm_firmware_irq_raw: reserved1 (Bit 27)    */
#define idpm_com_idpm_firmware_irq_raw_reserved1_Msk (0x8000000UL)  /*!< idpm_com idpm_firmware_irq_raw: reserved1 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_SYS_STA_Pos (26UL)           /*!< idpm_com idpm_firmware_irq_raw: SYS_STA (Bit 26)      */
#define idpm_com_idpm_firmware_irq_raw_SYS_STA_Msk (0x4000000UL)    /*!< idpm_com idpm_firmware_irq_raw: SYS_STA (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_res_TMR_ro_Pos (25UL)        /*!< idpm_com idpm_firmware_irq_raw: res_TMR_ro (Bit 25)   */
#define idpm_com_idpm_firmware_irq_raw_res_TMR_ro_Msk (0x2000000UL) /*!< idpm_com idpm_firmware_irq_raw: res_TMR_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_reserved0_Pos (24UL)         /*!< idpm_com idpm_firmware_irq_raw: reserved0 (Bit 24)    */
#define idpm_com_idpm_firmware_irq_raw_reserved0_Msk (0x1000000UL)  /*!< idpm_com idpm_firmware_irq_raw: reserved0 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_IRQ_VECTOR_Pos (16UL)        /*!< idpm_com idpm_firmware_irq_raw: IRQ_VECTOR (Bit 16)   */
#define idpm_com_idpm_firmware_irq_raw_IRQ_VECTOR_Msk (0xff0000UL)  /*!< idpm_com idpm_firmware_irq_raw: IRQ_VECTOR (Bitfield-Mask: 0xff) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT15_Pos (15UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT15 (Bit 15)   */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT15_Msk (0x8000UL)    /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT15 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT14_Pos (14UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT14 (Bit 14)   */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT14_Msk (0x4000UL)    /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT14 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT13_Pos (13UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT13 (Bit 13)   */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT13_Msk (0x2000UL)    /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT13 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT12_Pos (12UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT12 (Bit 12)   */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT12_Msk (0x1000UL)    /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT12 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT11_Pos (11UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT11 (Bit 11)   */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT11_Msk (0x800UL)     /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT11 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT10_Pos (10UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT10 (Bit 10)   */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT10_Msk (0x400UL)     /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT10 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT9_Pos (9UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT9 (Bit 9)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT9_Msk (0x200UL)      /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT9 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT8_Pos (8UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT8 (Bit 8)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT8_Msk (0x100UL)      /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT8 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT7_Pos (7UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT7 (Bit 7)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT7_Msk (0x80UL)       /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT7 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT6_Pos (6UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT6 (Bit 6)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT6_Msk (0x40UL)       /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT6 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT5_Pos (5UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT5 (Bit 5)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT5_Msk (0x20UL)       /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT5 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT4_Pos (4UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT4 (Bit 4)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT4_Msk (0x10UL)       /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT4 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT3_Pos (3UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT3 (Bit 3)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT3_Msk (0x8UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT3 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT2_Pos (2UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT2 (Bit 2)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT2_Msk (0x4UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT2 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT1_Pos (1UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT1 (Bit 1)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT1_Msk (0x2UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT1 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT0_Pos (0UL)          /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT0 (Bit 0)     */
#define idpm_com_idpm_firmware_irq_raw_HS_EVENT0_Msk (0x1UL)        /*!< idpm_com idpm_firmware_irq_raw: HS_EVENT0 (Bitfield-Mask: 0x01) */
/* ================================================  idpm_firmware_irq_mask  ================================================= */
#define idpm_com_idpm_firmware_irq_mask_INT_EN_Pos (31UL)           /*!< idpm_com idpm_firmware_irq_mask: INT_EN (Bit 31)      */
#define idpm_com_idpm_firmware_irq_mask_INT_EN_Msk (0x80000000UL)   /*!< idpm_com idpm_firmware_irq_mask: INT_EN (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_res_MEM_LCK_ro_Pos (30UL)   /*!< idpm_com idpm_firmware_irq_mask: res_MEM_LCK_ro (Bit 30) */
#define idpm_com_idpm_firmware_irq_mask_res_MEM_LCK_ro_Msk (0x40000000UL) /*!< idpm_com idpm_firmware_irq_mask: res_MEM_LCK_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_res_WDG_NETX_ro_Pos (29UL)  /*!< idpm_com idpm_firmware_irq_mask: res_WDG_NETX_ro (Bit 29) */
#define idpm_com_idpm_firmware_irq_mask_res_WDG_NETX_ro_Msk (0x20000000UL) /*!< idpm_com idpm_firmware_irq_mask: res_WDG_NETX_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro_Pos (28UL) /*!< idpm_com idpm_firmware_irq_mask: res_RDY_TIMEOUT_ro (Bit 28) */
#define idpm_com_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro_Msk (0x10000000UL) /*!< idpm_com idpm_firmware_irq_mask: res_RDY_TIMEOUT_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_reserved1_Pos (27UL)        /*!< idpm_com idpm_firmware_irq_mask: reserved1 (Bit 27)   */
#define idpm_com_idpm_firmware_irq_mask_reserved1_Msk (0x8000000UL) /*!< idpm_com idpm_firmware_irq_mask: reserved1 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_SYS_STA_Pos (26UL)          /*!< idpm_com idpm_firmware_irq_mask: SYS_STA (Bit 26)     */
#define idpm_com_idpm_firmware_irq_mask_SYS_STA_Msk (0x4000000UL)   /*!< idpm_com idpm_firmware_irq_mask: SYS_STA (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_res_TMR_ro_Pos (25UL)       /*!< idpm_com idpm_firmware_irq_mask: res_TMR_ro (Bit 25)  */
#define idpm_com_idpm_firmware_irq_mask_res_TMR_ro_Msk (0x2000000UL) /*!< idpm_com idpm_firmware_irq_mask: res_TMR_ro (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_reserved0_Pos (16UL)        /*!< idpm_com idpm_firmware_irq_mask: reserved0 (Bit 16)   */
#define idpm_com_idpm_firmware_irq_mask_reserved0_Msk (0x1ff0000UL) /*!< idpm_com idpm_firmware_irq_mask: reserved0 (Bitfield-Mask: 0x1ff) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT15_Pos (15UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT15 (Bit 15)  */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT15_Msk (0x8000UL)   /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT15 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT14_Pos (14UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT14 (Bit 14)  */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT14_Msk (0x4000UL)   /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT14 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT13_Pos (13UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT13 (Bit 13)  */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT13_Msk (0x2000UL)   /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT13 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT12_Pos (12UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT12 (Bit 12)  */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT12_Msk (0x1000UL)   /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT12 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT11_Pos (11UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT11 (Bit 11)  */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT11_Msk (0x800UL)    /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT11 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT10_Pos (10UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT10 (Bit 10)  */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT10_Msk (0x400UL)    /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT10 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT9_Pos (9UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT9 (Bit 9)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT9_Msk (0x200UL)     /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT9 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT8_Pos (8UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT8 (Bit 8)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT8_Msk (0x100UL)     /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT8 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT7_Pos (7UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT7 (Bit 7)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT7_Msk (0x80UL)      /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT7 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT6_Pos (6UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT6 (Bit 6)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT6_Msk (0x40UL)      /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT6 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT5_Pos (5UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT5 (Bit 5)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT5_Msk (0x20UL)      /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT5 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT4_Pos (4UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT4 (Bit 4)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT4_Msk (0x10UL)      /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT4 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT3_Pos (3UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT3 (Bit 3)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT3_Msk (0x8UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT3 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT2_Pos (2UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT2 (Bit 2)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT2_Msk (0x4UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT2 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT1_Pos (1UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT1 (Bit 1)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT1_Msk (0x2UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT1 (Bitfield-Mask: 0x01) */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT0_Pos (0UL)         /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT0 (Bit 0)    */
#define idpm_com_idpm_firmware_irq_mask_HS_EVENT0_Msk (0x1UL)       /*!< idpm_com idpm_firmware_irq_mask: HS_EVENT0 (Bitfield-Mask: 0x01) */
/* ===================================================  idpm_netx_version  =================================================== */
#define idpm_com_idpm_netx_version_netx_version_Pos (0UL)           /*!< idpm_com idpm_netx_version: netx_version (Bit 0)      */
#define idpm_com_idpm_netx_version_netx_version_Msk (0xffffffffUL)  /*!< idpm_com idpm_netx_version: netx_version (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                           hash                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  hash_din  ======================================================== */
#define hash_hash_din_val_Pos             (0UL)                     /*!< hash hash_din: val (Bit 0)                            */
#define hash_hash_din_val_Msk             (0xffffffffUL)            /*!< hash hash_din: val (Bitfield-Mask: 0xffffffff)        */
/* =======================================================  hash_cfg  ======================================================== */
#define hash_hash_cfg_dma_burst_only_Pos  (5UL)                     /*!< hash hash_cfg: dma_burst_only (Bit 5)                 */
#define hash_hash_cfg_dma_burst_only_Msk  (0x20UL)                  /*!< hash hash_cfg: dma_burst_only (Bitfield-Mask: 0x01)   */
#define hash_hash_cfg_dma_en_Pos          (4UL)                     /*!< hash hash_cfg: dma_en (Bit 4)                         */
#define hash_hash_cfg_dma_en_Msk          (0x10UL)                  /*!< hash hash_cfg: dma_en (Bitfield-Mask: 0x01)           */
#define hash_hash_cfg_reset_Pos           (3UL)                     /*!< hash hash_cfg: reset (Bit 3)                          */
#define hash_hash_cfg_reset_Msk           (0x8UL)                   /*!< hash hash_cfg: reset (Bitfield-Mask: 0x01)            */
#define hash_hash_cfg_mode_Pos            (0UL)                     /*!< hash hash_cfg: mode (Bit 0)                           */
#define hash_hash_cfg_mode_Msk            (0x7UL)                   /*!< hash hash_cfg: mode (Bitfield-Mask: 0x07)             */
/* =======================================================  hash_stat  ======================================================= */
#define hash_hash_stat_fifo_fill_Pos      (0UL)                     /*!< hash hash_stat: fifo_fill (Bit 0)                     */
#define hash_hash_stat_fifo_fill_Msk      (0x1ffUL)                 /*!< hash hash_stat: fifo_fill (Bitfield-Mask: 0x1ff)      */
/* ====================================================  hash_debug_info  ==================================================== */
#define hash_hash_debug_info_sha_round_Pos (0UL)                    /*!< hash hash_debug_info: sha_round (Bit 0)               */
#define hash_hash_debug_info_sha_round_Msk (0x7fUL)                 /*!< hash hash_debug_info: sha_round (Bitfield-Mask: 0x7f) */
/* =====================================================  hash_irq_raw  ====================================================== */
#define hash_hash_irq_raw_fifo_overflow_Pos (2UL)                   /*!< hash hash_irq_raw: fifo_overflow (Bit 2)              */
#define hash_hash_irq_raw_fifo_overflow_Msk (0x4UL)                 /*!< hash hash_irq_raw: fifo_overflow (Bitfield-Mask: 0x01) */
#define hash_hash_irq_raw_fifo_underrun_Pos (1UL)                   /*!< hash hash_irq_raw: fifo_underrun (Bit 1)              */
#define hash_hash_irq_raw_fifo_underrun_Msk (0x2UL)                 /*!< hash hash_irq_raw: fifo_underrun (Bitfield-Mask: 0x01) */
#define hash_hash_irq_raw_hash_ready_Pos  (0UL)                     /*!< hash hash_irq_raw: hash_ready (Bit 0)                 */
#define hash_hash_irq_raw_hash_ready_Msk  (0x1UL)                   /*!< hash hash_irq_raw: hash_ready (Bitfield-Mask: 0x01)   */
/* ====================================================  hash_irq_masked  ==================================================== */
#define hash_hash_irq_masked_fifo_overflow_Pos (2UL)                /*!< hash hash_irq_masked: fifo_overflow (Bit 2)           */
#define hash_hash_irq_masked_fifo_overflow_Msk (0x4UL)              /*!< hash hash_irq_masked: fifo_overflow (Bitfield-Mask: 0x01) */
#define hash_hash_irq_masked_fifo_underrun_Pos (1UL)                /*!< hash hash_irq_masked: fifo_underrun (Bit 1)           */
#define hash_hash_irq_masked_fifo_underrun_Msk (0x2UL)              /*!< hash hash_irq_masked: fifo_underrun (Bitfield-Mask: 0x01) */
#define hash_hash_irq_masked_hash_ready_Pos (0UL)                   /*!< hash hash_irq_masked: hash_ready (Bit 0)              */
#define hash_hash_irq_masked_hash_ready_Msk (0x1UL)                 /*!< hash hash_irq_masked: hash_ready (Bitfield-Mask: 0x01) */
/* ===================================================  hash_irq_msk_set  ==================================================== */
#define hash_hash_irq_msk_set_fifo_overflow_Pos (2UL)               /*!< hash hash_irq_msk_set: fifo_overflow (Bit 2)          */
#define hash_hash_irq_msk_set_fifo_overflow_Msk (0x4UL)             /*!< hash hash_irq_msk_set: fifo_overflow (Bitfield-Mask: 0x01) */
#define hash_hash_irq_msk_set_fifo_underrun_Pos (1UL)               /*!< hash hash_irq_msk_set: fifo_underrun (Bit 1)          */
#define hash_hash_irq_msk_set_fifo_underrun_Msk (0x2UL)             /*!< hash hash_irq_msk_set: fifo_underrun (Bitfield-Mask: 0x01) */
#define hash_hash_irq_msk_set_hash_ready_Pos (0UL)                  /*!< hash hash_irq_msk_set: hash_ready (Bit 0)             */
#define hash_hash_irq_msk_set_hash_ready_Msk (0x1UL)                /*!< hash hash_irq_msk_set: hash_ready (Bitfield-Mask: 0x01) */
/* ==================================================  hash_irq_msk_reset  =================================================== */
#define hash_hash_irq_msk_reset_fifo_overflow_Pos (2UL)             /*!< hash hash_irq_msk_reset: fifo_overflow (Bit 2)        */
#define hash_hash_irq_msk_reset_fifo_overflow_Msk (0x4UL)           /*!< hash hash_irq_msk_reset: fifo_overflow (Bitfield-Mask: 0x01) */
#define hash_hash_irq_msk_reset_fifo_underrun_Pos (1UL)             /*!< hash hash_irq_msk_reset: fifo_underrun (Bit 1)        */
#define hash_hash_irq_msk_reset_fifo_underrun_Msk (0x2UL)           /*!< hash hash_irq_msk_reset: fifo_underrun (Bitfield-Mask: 0x01) */
#define hash_hash_irq_msk_reset_hash_ready_Pos (0UL)                /*!< hash hash_irq_msk_reset: hash_ready (Bit 0)           */
#define hash_hash_irq_msk_reset_hash_ready_Msk (0x1UL)              /*!< hash hash_irq_msk_reset: hash_ready (Bitfield-Mask: 0x01) */
/* ======================================================  hash_dout0  ======================================================= */
#define hash_hash_dout0_val_Pos           (0UL)                     /*!< hash hash_dout0: val (Bit 0)                          */
#define hash_hash_dout0_val_Msk           (0xffffffffUL)            /*!< hash hash_dout0: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout1  ======================================================= */
#define hash_hash_dout1_val_Pos           (0UL)                     /*!< hash hash_dout1: val (Bit 0)                          */
#define hash_hash_dout1_val_Msk           (0xffffffffUL)            /*!< hash hash_dout1: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout2  ======================================================= */
#define hash_hash_dout2_val_Pos           (0UL)                     /*!< hash hash_dout2: val (Bit 0)                          */
#define hash_hash_dout2_val_Msk           (0xffffffffUL)            /*!< hash hash_dout2: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout3  ======================================================= */
#define hash_hash_dout3_val_Pos           (0UL)                     /*!< hash hash_dout3: val (Bit 0)                          */
#define hash_hash_dout3_val_Msk           (0xffffffffUL)            /*!< hash hash_dout3: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout4  ======================================================= */
#define hash_hash_dout4_val_Pos           (0UL)                     /*!< hash hash_dout4: val (Bit 0)                          */
#define hash_hash_dout4_val_Msk           (0xffffffffUL)            /*!< hash hash_dout4: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout5  ======================================================= */
#define hash_hash_dout5_val_Pos           (0UL)                     /*!< hash hash_dout5: val (Bit 0)                          */
#define hash_hash_dout5_val_Msk           (0xffffffffUL)            /*!< hash hash_dout5: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout6  ======================================================= */
#define hash_hash_dout6_val_Pos           (0UL)                     /*!< hash hash_dout6: val (Bit 0)                          */
#define hash_hash_dout6_val_Msk           (0xffffffffUL)            /*!< hash hash_dout6: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout7  ======================================================= */
#define hash_hash_dout7_val_Pos           (0UL)                     /*!< hash hash_dout7: val (Bit 0)                          */
#define hash_hash_dout7_val_Msk           (0xffffffffUL)            /*!< hash hash_dout7: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout8  ======================================================= */
#define hash_hash_dout8_val_Pos           (0UL)                     /*!< hash hash_dout8: val (Bit 0)                          */
#define hash_hash_dout8_val_Msk           (0xffffffffUL)            /*!< hash hash_dout8: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout9  ======================================================= */
#define hash_hash_dout9_val_Pos           (0UL)                     /*!< hash hash_dout9: val (Bit 0)                          */
#define hash_hash_dout9_val_Msk           (0xffffffffUL)            /*!< hash hash_dout9: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  hash_dout10  ====================================================== */
#define hash_hash_dout10_val_Pos          (0UL)                     /*!< hash hash_dout10: val (Bit 0)                         */
#define hash_hash_dout10_val_Msk          (0xffffffffUL)            /*!< hash hash_dout10: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  hash_dout11  ====================================================== */
#define hash_hash_dout11_val_Pos          (0UL)                     /*!< hash hash_dout11: val (Bit 0)                         */
#define hash_hash_dout11_val_Msk          (0xffffffffUL)            /*!< hash hash_dout11: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  hash_dout12  ====================================================== */
#define hash_hash_dout12_val_Pos          (0UL)                     /*!< hash hash_dout12: val (Bit 0)                         */
#define hash_hash_dout12_val_Msk          (0xffffffffUL)            /*!< hash hash_dout12: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  hash_dout13  ====================================================== */
#define hash_hash_dout13_val_Pos          (0UL)                     /*!< hash hash_dout13: val (Bit 0)                         */
#define hash_hash_dout13_val_Msk          (0xffffffffUL)            /*!< hash hash_dout13: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  hash_dout14  ====================================================== */
#define hash_hash_dout14_val_Pos          (0UL)                     /*!< hash hash_dout14: val (Bit 0)                         */
#define hash_hash_dout14_val_Msk          (0xffffffffUL)            /*!< hash hash_dout14: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  hash_dout15  ====================================================== */
#define hash_hash_dout15_val_Pos          (0UL)                     /*!< hash hash_dout15: val (Bit 0)                         */
#define hash_hash_dout15_val_Msk          (0xffffffffUL)            /*!< hash hash_dout15: val (Bitfield-Mask: 0xffffffff)     */


/* =========================================================================================================================== */
/* ================                                            aes                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  aes_cfg  ======================================================== */
#define aes_aes_cfg_out_fifo_dma_burst_only_Pos (20UL)              /*!< aes aes_cfg: out_fifo_dma_burst_only (Bit 20)         */
#define aes_aes_cfg_out_fifo_dma_burst_only_Msk (0x100000UL)        /*!< aes aes_cfg: out_fifo_dma_burst_only (Bitfield-Mask: 0x01) */
#define aes_aes_cfg_out_fifo_dma_en_Pos   (19UL)                    /*!< aes aes_cfg: out_fifo_dma_en (Bit 19)                 */
#define aes_aes_cfg_out_fifo_dma_en_Msk   (0x80000UL)               /*!< aes aes_cfg: out_fifo_dma_en (Bitfield-Mask: 0x01)    */
#define aes_aes_cfg_in_fifo_dma_burst_only_Pos (18UL)               /*!< aes aes_cfg: in_fifo_dma_burst_only (Bit 18)          */
#define aes_aes_cfg_in_fifo_dma_burst_only_Msk (0x40000UL)          /*!< aes aes_cfg: in_fifo_dma_burst_only (Bitfield-Mask: 0x01) */
#define aes_aes_cfg_in_fifo_dma_en_Pos    (17UL)                    /*!< aes aes_cfg: in_fifo_dma_en (Bit 17)                  */
#define aes_aes_cfg_in_fifo_dma_en_Msk    (0x20000UL)               /*!< aes aes_cfg: in_fifo_dma_en (Bitfield-Mask: 0x01)     */
#define aes_aes_cfg_out_fifo_wm_Pos       (11UL)                    /*!< aes aes_cfg: out_fifo_wm (Bit 11)                     */
#define aes_aes_cfg_out_fifo_wm_Msk       (0x1f800UL)               /*!< aes aes_cfg: out_fifo_wm (Bitfield-Mask: 0x3f)        */
#define aes_aes_cfg_in_fifo_wm_Pos        (5UL)                     /*!< aes aes_cfg: in_fifo_wm (Bit 5)                       */
#define aes_aes_cfg_in_fifo_wm_Msk        (0x7e0UL)                 /*!< aes aes_cfg: in_fifo_wm (Bitfield-Mask: 0x3f)         */
#define aes_aes_cfg_key_exp_start_Pos     (4UL)                     /*!< aes aes_cfg: key_exp_start (Bit 4)                    */
#define aes_aes_cfg_key_exp_start_Msk     (0x10UL)                  /*!< aes aes_cfg: key_exp_start (Bitfield-Mask: 0x01)      */
#define aes_aes_cfg_key_len_Pos           (2UL)                     /*!< aes aes_cfg: key_len (Bit 2)                          */
#define aes_aes_cfg_key_len_Msk           (0xcUL)                   /*!< aes aes_cfg: key_len (Bitfield-Mask: 0x03)            */
#define aes_aes_cfg_mode_Pos              (1UL)                     /*!< aes aes_cfg: mode (Bit 1)                             */
#define aes_aes_cfg_mode_Msk              (0x2UL)                   /*!< aes aes_cfg: mode (Bitfield-Mask: 0x01)               */
#define aes_aes_cfg_enable_Pos            (0UL)                     /*!< aes aes_cfg: enable (Bit 0)                           */
#define aes_aes_cfg_enable_Msk            (0x1UL)                   /*!< aes aes_cfg: enable (Bitfield-Mask: 0x01)             */
/* =======================================================  aes_stat  ======================================================== */
#define aes_aes_stat_out_fifo_overflow_Pos (27UL)                   /*!< aes aes_stat: out_fifo_overflow (Bit 27)              */
#define aes_aes_stat_out_fifo_overflow_Msk (0x8000000UL)            /*!< aes aes_stat: out_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_stat_out_fifo_underrun_Pos (26UL)                   /*!< aes aes_stat: out_fifo_underrun (Bit 26)              */
#define aes_aes_stat_out_fifo_underrun_Msk (0x4000000UL)            /*!< aes aes_stat: out_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_stat_out_fifo_not_full_Pos (25UL)                   /*!< aes aes_stat: out_fifo_not_full (Bit 25)              */
#define aes_aes_stat_out_fifo_not_full_Msk (0x2000000UL)            /*!< aes aes_stat: out_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_stat_out_fifo_full_Pos    (24UL)                    /*!< aes aes_stat: out_fifo_full (Bit 24)                  */
#define aes_aes_stat_out_fifo_full_Msk    (0x1000000UL)             /*!< aes aes_stat: out_fifo_full (Bitfield-Mask: 0x01)     */
#define aes_aes_stat_out_fifo_not_empty_Pos (23UL)                  /*!< aes aes_stat: out_fifo_not_empty (Bit 23)             */
#define aes_aes_stat_out_fifo_not_empty_Msk (0x800000UL)            /*!< aes aes_stat: out_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_stat_out_fifo_empty_Pos   (22UL)                    /*!< aes aes_stat: out_fifo_empty (Bit 22)                 */
#define aes_aes_stat_out_fifo_empty_Msk   (0x400000UL)              /*!< aes aes_stat: out_fifo_empty (Bitfield-Mask: 0x01)    */
#define aes_aes_stat_out_fifo_fill_Pos    (15UL)                    /*!< aes aes_stat: out_fifo_fill (Bit 15)                  */
#define aes_aes_stat_out_fifo_fill_Msk    (0x3f8000UL)              /*!< aes aes_stat: out_fifo_fill (Bitfield-Mask: 0x7f)     */
#define aes_aes_stat_in_fifo_overflow_Pos (14UL)                    /*!< aes aes_stat: in_fifo_overflow (Bit 14)               */
#define aes_aes_stat_in_fifo_overflow_Msk (0x4000UL)                /*!< aes aes_stat: in_fifo_overflow (Bitfield-Mask: 0x01)  */
#define aes_aes_stat_in_fifo_underrun_Pos (13UL)                    /*!< aes aes_stat: in_fifo_underrun (Bit 13)               */
#define aes_aes_stat_in_fifo_underrun_Msk (0x2000UL)                /*!< aes aes_stat: in_fifo_underrun (Bitfield-Mask: 0x01)  */
#define aes_aes_stat_in_fifo_not_full_Pos (12UL)                    /*!< aes aes_stat: in_fifo_not_full (Bit 12)               */
#define aes_aes_stat_in_fifo_not_full_Msk (0x1000UL)                /*!< aes aes_stat: in_fifo_not_full (Bitfield-Mask: 0x01)  */
#define aes_aes_stat_in_fifo_full_Pos     (11UL)                    /*!< aes aes_stat: in_fifo_full (Bit 11)                   */
#define aes_aes_stat_in_fifo_full_Msk     (0x800UL)                 /*!< aes aes_stat: in_fifo_full (Bitfield-Mask: 0x01)      */
#define aes_aes_stat_in_fifo_not_empty_Pos (10UL)                   /*!< aes aes_stat: in_fifo_not_empty (Bit 10)              */
#define aes_aes_stat_in_fifo_not_empty_Msk (0x400UL)                /*!< aes aes_stat: in_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_stat_in_fifo_empty_Pos    (9UL)                     /*!< aes aes_stat: in_fifo_empty (Bit 9)                   */
#define aes_aes_stat_in_fifo_empty_Msk    (0x200UL)                 /*!< aes aes_stat: in_fifo_empty (Bitfield-Mask: 0x01)     */
#define aes_aes_stat_in_fifo_fill_Pos     (2UL)                     /*!< aes aes_stat: in_fifo_fill (Bit 2)                    */
#define aes_aes_stat_in_fifo_fill_Msk     (0x1fcUL)                 /*!< aes aes_stat: in_fifo_fill (Bitfield-Mask: 0x7f)      */
#define aes_aes_stat_op_ready_Pos         (1UL)                     /*!< aes aes_stat: op_ready (Bit 1)                        */
#define aes_aes_stat_op_ready_Msk         (0x2UL)                   /*!< aes aes_stat: op_ready (Bitfield-Mask: 0x01)          */
#define aes_aes_stat_key_exp_ready_Pos    (0UL)                     /*!< aes aes_stat: key_exp_ready (Bit 0)                   */
#define aes_aes_stat_key_exp_ready_Msk    (0x1UL)                   /*!< aes aes_stat: key_exp_ready (Bitfield-Mask: 0x01)     */
/* ======================================================  aes_irq_raw  ====================================================== */
#define aes_aes_irq_raw_out_fifo_overflow_Pos (15UL)                /*!< aes aes_irq_raw: out_fifo_overflow (Bit 15)           */
#define aes_aes_irq_raw_out_fifo_overflow_Msk (0x8000UL)            /*!< aes aes_irq_raw: out_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_out_fifo_underrun_Pos (14UL)                /*!< aes aes_irq_raw: out_fifo_underrun (Bit 14)           */
#define aes_aes_irq_raw_out_fifo_underrun_Msk (0x4000UL)            /*!< aes aes_irq_raw: out_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_out_fifo_not_full_Pos (13UL)                /*!< aes aes_irq_raw: out_fifo_not_full (Bit 13)           */
#define aes_aes_irq_raw_out_fifo_not_full_Msk (0x2000UL)            /*!< aes aes_irq_raw: out_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_out_fifo_full_Pos (12UL)                    /*!< aes aes_irq_raw: out_fifo_full (Bit 12)               */
#define aes_aes_irq_raw_out_fifo_full_Msk (0x1000UL)                /*!< aes aes_irq_raw: out_fifo_full (Bitfield-Mask: 0x01)  */
#define aes_aes_irq_raw_out_fifo_not_empty_Pos (11UL)               /*!< aes aes_irq_raw: out_fifo_not_empty (Bit 11)          */
#define aes_aes_irq_raw_out_fifo_not_empty_Msk (0x800UL)            /*!< aes aes_irq_raw: out_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_out_fifo_empty_Pos (10UL)                   /*!< aes aes_irq_raw: out_fifo_empty (Bit 10)              */
#define aes_aes_irq_raw_out_fifo_empty_Msk (0x400UL)                /*!< aes aes_irq_raw: out_fifo_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_out_fifo_wm_Pos   (9UL)                     /*!< aes aes_irq_raw: out_fifo_wm (Bit 9)                  */
#define aes_aes_irq_raw_out_fifo_wm_Msk   (0x200UL)                 /*!< aes aes_irq_raw: out_fifo_wm (Bitfield-Mask: 0x01)    */
#define aes_aes_irq_raw_in_fifo_overflow_Pos (8UL)                  /*!< aes aes_irq_raw: in_fifo_overflow (Bit 8)             */
#define aes_aes_irq_raw_in_fifo_overflow_Msk (0x100UL)              /*!< aes aes_irq_raw: in_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_in_fifo_underrun_Pos (7UL)                  /*!< aes aes_irq_raw: in_fifo_underrun (Bit 7)             */
#define aes_aes_irq_raw_in_fifo_underrun_Msk (0x80UL)               /*!< aes aes_irq_raw: in_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_in_fifo_not_full_Pos (6UL)                  /*!< aes aes_irq_raw: in_fifo_not_full (Bit 6)             */
#define aes_aes_irq_raw_in_fifo_not_full_Msk (0x40UL)               /*!< aes aes_irq_raw: in_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_in_fifo_full_Pos  (5UL)                     /*!< aes aes_irq_raw: in_fifo_full (Bit 5)                 */
#define aes_aes_irq_raw_in_fifo_full_Msk  (0x20UL)                  /*!< aes aes_irq_raw: in_fifo_full (Bitfield-Mask: 0x01)   */
#define aes_aes_irq_raw_in_fifo_not_empty_Pos (4UL)                 /*!< aes aes_irq_raw: in_fifo_not_empty (Bit 4)            */
#define aes_aes_irq_raw_in_fifo_not_empty_Msk (0x10UL)              /*!< aes aes_irq_raw: in_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_raw_in_fifo_empty_Pos (3UL)                     /*!< aes aes_irq_raw: in_fifo_empty (Bit 3)                */
#define aes_aes_irq_raw_in_fifo_empty_Msk (0x8UL)                   /*!< aes aes_irq_raw: in_fifo_empty (Bitfield-Mask: 0x01)  */
#define aes_aes_irq_raw_in_fifo_wm_Pos    (2UL)                     /*!< aes aes_irq_raw: in_fifo_wm (Bit 2)                   */
#define aes_aes_irq_raw_in_fifo_wm_Msk    (0x4UL)                   /*!< aes aes_irq_raw: in_fifo_wm (Bitfield-Mask: 0x01)     */
#define aes_aes_irq_raw_op_ready_Pos      (1UL)                     /*!< aes aes_irq_raw: op_ready (Bit 1)                     */
#define aes_aes_irq_raw_op_ready_Msk      (0x2UL)                   /*!< aes aes_irq_raw: op_ready (Bitfield-Mask: 0x01)       */
#define aes_aes_irq_raw_key_exp_ready_Pos (0UL)                     /*!< aes aes_irq_raw: key_exp_ready (Bit 0)                */
#define aes_aes_irq_raw_key_exp_ready_Msk (0x1UL)                   /*!< aes aes_irq_raw: key_exp_ready (Bitfield-Mask: 0x01)  */
/* ====================================================  aes_irq_masked  ===================================================== */
#define aes_aes_irq_masked_out_fifo_overflow_Pos (15UL)             /*!< aes aes_irq_masked: out_fifo_overflow (Bit 15)        */
#define aes_aes_irq_masked_out_fifo_overflow_Msk (0x8000UL)         /*!< aes aes_irq_masked: out_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_out_fifo_underrun_Pos (14UL)             /*!< aes aes_irq_masked: out_fifo_underrun (Bit 14)        */
#define aes_aes_irq_masked_out_fifo_underrun_Msk (0x4000UL)         /*!< aes aes_irq_masked: out_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_out_fifo_not_full_Pos (13UL)             /*!< aes aes_irq_masked: out_fifo_not_full (Bit 13)        */
#define aes_aes_irq_masked_out_fifo_not_full_Msk (0x2000UL)         /*!< aes aes_irq_masked: out_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_out_fifo_full_Pos (12UL)                 /*!< aes aes_irq_masked: out_fifo_full (Bit 12)            */
#define aes_aes_irq_masked_out_fifo_full_Msk (0x1000UL)             /*!< aes aes_irq_masked: out_fifo_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_out_fifo_not_empty_Pos (11UL)            /*!< aes aes_irq_masked: out_fifo_not_empty (Bit 11)       */
#define aes_aes_irq_masked_out_fifo_not_empty_Msk (0x800UL)         /*!< aes aes_irq_masked: out_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_out_fifo_empty_Pos (10UL)                /*!< aes aes_irq_masked: out_fifo_empty (Bit 10)           */
#define aes_aes_irq_masked_out_fifo_empty_Msk (0x400UL)             /*!< aes aes_irq_masked: out_fifo_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_out_fifo_wm_Pos (9UL)                    /*!< aes aes_irq_masked: out_fifo_wm (Bit 9)               */
#define aes_aes_irq_masked_out_fifo_wm_Msk (0x200UL)                /*!< aes aes_irq_masked: out_fifo_wm (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_in_fifo_overflow_Pos (8UL)               /*!< aes aes_irq_masked: in_fifo_overflow (Bit 8)          */
#define aes_aes_irq_masked_in_fifo_overflow_Msk (0x100UL)           /*!< aes aes_irq_masked: in_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_in_fifo_underrun_Pos (7UL)               /*!< aes aes_irq_masked: in_fifo_underrun (Bit 7)          */
#define aes_aes_irq_masked_in_fifo_underrun_Msk (0x80UL)            /*!< aes aes_irq_masked: in_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_in_fifo_not_full_Pos (6UL)               /*!< aes aes_irq_masked: in_fifo_not_full (Bit 6)          */
#define aes_aes_irq_masked_in_fifo_not_full_Msk (0x40UL)            /*!< aes aes_irq_masked: in_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_in_fifo_full_Pos (5UL)                   /*!< aes aes_irq_masked: in_fifo_full (Bit 5)              */
#define aes_aes_irq_masked_in_fifo_full_Msk (0x20UL)                /*!< aes aes_irq_masked: in_fifo_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_in_fifo_not_empty_Pos (4UL)              /*!< aes aes_irq_masked: in_fifo_not_empty (Bit 4)         */
#define aes_aes_irq_masked_in_fifo_not_empty_Msk (0x10UL)           /*!< aes aes_irq_masked: in_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_in_fifo_empty_Pos (3UL)                  /*!< aes aes_irq_masked: in_fifo_empty (Bit 3)             */
#define aes_aes_irq_masked_in_fifo_empty_Msk (0x8UL)                /*!< aes aes_irq_masked: in_fifo_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_masked_in_fifo_wm_Pos (2UL)                     /*!< aes aes_irq_masked: in_fifo_wm (Bit 2)                */
#define aes_aes_irq_masked_in_fifo_wm_Msk (0x4UL)                   /*!< aes aes_irq_masked: in_fifo_wm (Bitfield-Mask: 0x01)  */
#define aes_aes_irq_masked_op_ready_Pos   (1UL)                     /*!< aes aes_irq_masked: op_ready (Bit 1)                  */
#define aes_aes_irq_masked_op_ready_Msk   (0x2UL)                   /*!< aes aes_irq_masked: op_ready (Bitfield-Mask: 0x01)    */
#define aes_aes_irq_masked_key_exp_ready_Pos (0UL)                  /*!< aes aes_irq_masked: key_exp_ready (Bit 0)             */
#define aes_aes_irq_masked_key_exp_ready_Msk (0x1UL)                /*!< aes aes_irq_masked: key_exp_ready (Bitfield-Mask: 0x01) */
/* ====================================================  aes_irq_msk_set  ==================================================== */
#define aes_aes_irq_msk_set_out_fifo_overflow_Pos (15UL)            /*!< aes aes_irq_msk_set: out_fifo_overflow (Bit 15)       */
#define aes_aes_irq_msk_set_out_fifo_overflow_Msk (0x8000UL)        /*!< aes aes_irq_msk_set: out_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_out_fifo_underrun_Pos (14UL)            /*!< aes aes_irq_msk_set: out_fifo_underrun (Bit 14)       */
#define aes_aes_irq_msk_set_out_fifo_underrun_Msk (0x4000UL)        /*!< aes aes_irq_msk_set: out_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_out_fifo_not_full_Pos (13UL)            /*!< aes aes_irq_msk_set: out_fifo_not_full (Bit 13)       */
#define aes_aes_irq_msk_set_out_fifo_not_full_Msk (0x2000UL)        /*!< aes aes_irq_msk_set: out_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_out_fifo_full_Pos (12UL)                /*!< aes aes_irq_msk_set: out_fifo_full (Bit 12)           */
#define aes_aes_irq_msk_set_out_fifo_full_Msk (0x1000UL)            /*!< aes aes_irq_msk_set: out_fifo_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_out_fifo_not_empty_Pos (11UL)           /*!< aes aes_irq_msk_set: out_fifo_not_empty (Bit 11)      */
#define aes_aes_irq_msk_set_out_fifo_not_empty_Msk (0x800UL)        /*!< aes aes_irq_msk_set: out_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_out_fifo_empty_Pos (10UL)               /*!< aes aes_irq_msk_set: out_fifo_empty (Bit 10)          */
#define aes_aes_irq_msk_set_out_fifo_empty_Msk (0x400UL)            /*!< aes aes_irq_msk_set: out_fifo_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_out_fifo_wm_Pos (9UL)                   /*!< aes aes_irq_msk_set: out_fifo_wm (Bit 9)              */
#define aes_aes_irq_msk_set_out_fifo_wm_Msk (0x200UL)               /*!< aes aes_irq_msk_set: out_fifo_wm (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_in_fifo_overflow_Pos (8UL)              /*!< aes aes_irq_msk_set: in_fifo_overflow (Bit 8)         */
#define aes_aes_irq_msk_set_in_fifo_overflow_Msk (0x100UL)          /*!< aes aes_irq_msk_set: in_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_in_fifo_underrun_Pos (7UL)              /*!< aes aes_irq_msk_set: in_fifo_underrun (Bit 7)         */
#define aes_aes_irq_msk_set_in_fifo_underrun_Msk (0x80UL)           /*!< aes aes_irq_msk_set: in_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_in_fifo_not_full_Pos (6UL)              /*!< aes aes_irq_msk_set: in_fifo_not_full (Bit 6)         */
#define aes_aes_irq_msk_set_in_fifo_not_full_Msk (0x40UL)           /*!< aes aes_irq_msk_set: in_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_in_fifo_full_Pos (5UL)                  /*!< aes aes_irq_msk_set: in_fifo_full (Bit 5)             */
#define aes_aes_irq_msk_set_in_fifo_full_Msk (0x20UL)               /*!< aes aes_irq_msk_set: in_fifo_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_in_fifo_not_empty_Pos (4UL)             /*!< aes aes_irq_msk_set: in_fifo_not_empty (Bit 4)        */
#define aes_aes_irq_msk_set_in_fifo_not_empty_Msk (0x10UL)          /*!< aes aes_irq_msk_set: in_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_in_fifo_empty_Pos (3UL)                 /*!< aes aes_irq_msk_set: in_fifo_empty (Bit 3)            */
#define aes_aes_irq_msk_set_in_fifo_empty_Msk (0x8UL)               /*!< aes aes_irq_msk_set: in_fifo_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_in_fifo_wm_Pos (2UL)                    /*!< aes aes_irq_msk_set: in_fifo_wm (Bit 2)               */
#define aes_aes_irq_msk_set_in_fifo_wm_Msk (0x4UL)                  /*!< aes aes_irq_msk_set: in_fifo_wm (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_set_op_ready_Pos  (1UL)                     /*!< aes aes_irq_msk_set: op_ready (Bit 1)                 */
#define aes_aes_irq_msk_set_op_ready_Msk  (0x2UL)                   /*!< aes aes_irq_msk_set: op_ready (Bitfield-Mask: 0x01)   */
#define aes_aes_irq_msk_set_key_exp_ready_Pos (0UL)                 /*!< aes aes_irq_msk_set: key_exp_ready (Bit 0)            */
#define aes_aes_irq_msk_set_key_exp_ready_Msk (0x1UL)               /*!< aes aes_irq_msk_set: key_exp_ready (Bitfield-Mask: 0x01) */
/* ===================================================  aes_irq_msk_reset  =================================================== */
#define aes_aes_irq_msk_reset_out_fifo_overflow_Pos (15UL)          /*!< aes aes_irq_msk_reset: out_fifo_overflow (Bit 15)     */
#define aes_aes_irq_msk_reset_out_fifo_overflow_Msk (0x8000UL)      /*!< aes aes_irq_msk_reset: out_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_out_fifo_underrun_Pos (14UL)          /*!< aes aes_irq_msk_reset: out_fifo_underrun (Bit 14)     */
#define aes_aes_irq_msk_reset_out_fifo_underrun_Msk (0x4000UL)      /*!< aes aes_irq_msk_reset: out_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_out_fifo_not_full_Pos (13UL)          /*!< aes aes_irq_msk_reset: out_fifo_not_full (Bit 13)     */
#define aes_aes_irq_msk_reset_out_fifo_not_full_Msk (0x2000UL)      /*!< aes aes_irq_msk_reset: out_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_out_fifo_full_Pos (12UL)              /*!< aes aes_irq_msk_reset: out_fifo_full (Bit 12)         */
#define aes_aes_irq_msk_reset_out_fifo_full_Msk (0x1000UL)          /*!< aes aes_irq_msk_reset: out_fifo_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_out_fifo_not_empty_Pos (11UL)         /*!< aes aes_irq_msk_reset: out_fifo_not_empty (Bit 11)    */
#define aes_aes_irq_msk_reset_out_fifo_not_empty_Msk (0x800UL)      /*!< aes aes_irq_msk_reset: out_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_out_fifo_empty_Pos (10UL)             /*!< aes aes_irq_msk_reset: out_fifo_empty (Bit 10)        */
#define aes_aes_irq_msk_reset_out_fifo_empty_Msk (0x400UL)          /*!< aes aes_irq_msk_reset: out_fifo_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_out_fifo_wm_Pos (9UL)                 /*!< aes aes_irq_msk_reset: out_fifo_wm (Bit 9)            */
#define aes_aes_irq_msk_reset_out_fifo_wm_Msk (0x200UL)             /*!< aes aes_irq_msk_reset: out_fifo_wm (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_in_fifo_overflow_Pos (8UL)            /*!< aes aes_irq_msk_reset: in_fifo_overflow (Bit 8)       */
#define aes_aes_irq_msk_reset_in_fifo_overflow_Msk (0x100UL)        /*!< aes aes_irq_msk_reset: in_fifo_overflow (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_in_fifo_underrun_Pos (7UL)            /*!< aes aes_irq_msk_reset: in_fifo_underrun (Bit 7)       */
#define aes_aes_irq_msk_reset_in_fifo_underrun_Msk (0x80UL)         /*!< aes aes_irq_msk_reset: in_fifo_underrun (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_in_fifo_not_full_Pos (6UL)            /*!< aes aes_irq_msk_reset: in_fifo_not_full (Bit 6)       */
#define aes_aes_irq_msk_reset_in_fifo_not_full_Msk (0x40UL)         /*!< aes aes_irq_msk_reset: in_fifo_not_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_in_fifo_full_Pos (5UL)                /*!< aes aes_irq_msk_reset: in_fifo_full (Bit 5)           */
#define aes_aes_irq_msk_reset_in_fifo_full_Msk (0x20UL)             /*!< aes aes_irq_msk_reset: in_fifo_full (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_in_fifo_not_empty_Pos (4UL)           /*!< aes aes_irq_msk_reset: in_fifo_not_empty (Bit 4)      */
#define aes_aes_irq_msk_reset_in_fifo_not_empty_Msk (0x10UL)        /*!< aes aes_irq_msk_reset: in_fifo_not_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_in_fifo_empty_Pos (3UL)               /*!< aes aes_irq_msk_reset: in_fifo_empty (Bit 3)          */
#define aes_aes_irq_msk_reset_in_fifo_empty_Msk (0x8UL)             /*!< aes aes_irq_msk_reset: in_fifo_empty (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_in_fifo_wm_Pos (2UL)                  /*!< aes aes_irq_msk_reset: in_fifo_wm (Bit 2)             */
#define aes_aes_irq_msk_reset_in_fifo_wm_Msk (0x4UL)                /*!< aes aes_irq_msk_reset: in_fifo_wm (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_op_ready_Pos (1UL)                    /*!< aes aes_irq_msk_reset: op_ready (Bit 1)               */
#define aes_aes_irq_msk_reset_op_ready_Msk (0x2UL)                  /*!< aes aes_irq_msk_reset: op_ready (Bitfield-Mask: 0x01) */
#define aes_aes_irq_msk_reset_key_exp_ready_Pos (0UL)               /*!< aes aes_irq_msk_reset: key_exp_ready (Bit 0)          */
#define aes_aes_irq_msk_reset_key_exp_ready_Msk (0x1UL)             /*!< aes aes_irq_msk_reset: key_exp_ready (Bitfield-Mask: 0x01) */
/* =======================================================  aes_key0  ======================================================== */
#define aes_aes_key0_val_Pos              (0UL)                     /*!< aes aes_key0: val (Bit 0)                             */
#define aes_aes_key0_val_Msk              (0xffffffffUL)            /*!< aes aes_key0: val (Bitfield-Mask: 0xffffffff)         */
/* =======================================================  aes_key1  ======================================================== */
#define aes_aes_key1_val_Pos              (0UL)                     /*!< aes aes_key1: val (Bit 0)                             */
#define aes_aes_key1_val_Msk              (0xffffffffUL)            /*!< aes aes_key1: val (Bitfield-Mask: 0xffffffff)         */
/* =======================================================  aes_key2  ======================================================== */
#define aes_aes_key2_val_Pos              (0UL)                     /*!< aes aes_key2: val (Bit 0)                             */
#define aes_aes_key2_val_Msk              (0xffffffffUL)            /*!< aes aes_key2: val (Bitfield-Mask: 0xffffffff)         */
/* =======================================================  aes_key3  ======================================================== */
#define aes_aes_key3_val_Pos              (0UL)                     /*!< aes aes_key3: val (Bit 0)                             */
#define aes_aes_key3_val_Msk              (0xffffffffUL)            /*!< aes aes_key3: val (Bitfield-Mask: 0xffffffff)         */
/* =======================================================  aes_key4  ======================================================== */
#define aes_aes_key4_val_Pos              (0UL)                     /*!< aes aes_key4: val (Bit 0)                             */
#define aes_aes_key4_val_Msk              (0xffffffffUL)            /*!< aes aes_key4: val (Bitfield-Mask: 0xffffffff)         */
/* =======================================================  aes_key5  ======================================================== */
#define aes_aes_key5_val_Pos              (0UL)                     /*!< aes aes_key5: val (Bit 0)                             */
#define aes_aes_key5_val_Msk              (0xffffffffUL)            /*!< aes aes_key5: val (Bitfield-Mask: 0xffffffff)         */
/* =======================================================  aes_key6  ======================================================== */
#define aes_aes_key6_val_Pos              (0UL)                     /*!< aes aes_key6: val (Bit 0)                             */
#define aes_aes_key6_val_Msk              (0xffffffffUL)            /*!< aes aes_key6: val (Bitfield-Mask: 0xffffffff)         */
/* =======================================================  aes_key7  ======================================================== */
#define aes_aes_key7_val_Pos              (0UL)                     /*!< aes aes_key7: val (Bit 0)                             */
#define aes_aes_key7_val_Msk              (0xffffffffUL)            /*!< aes aes_key7: val (Bitfield-Mask: 0xffffffff)         */
/* ========================================================  aes_din  ======================================================== */
#define aes_aes_din_val_Pos               (0UL)                     /*!< aes aes_din: val (Bit 0)                              */
#define aes_aes_din_val_Msk               (0xffffffffUL)            /*!< aes aes_din: val (Bitfield-Mask: 0xffffffff)          */
/* =======================================================  aes_dout  ======================================================== */
#define aes_aes_dout_val_Pos              (0UL)                     /*!< aes aes_dout: val (Bit 0)                             */
#define aes_aes_dout_val_Msk              (0xffffffffUL)            /*!< aes aes_dout: val (Bitfield-Mask: 0xffffffff)         */


/* =========================================================================================================================== */
/* ================                                          random                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  random_init  ====================================================== */
#define random_random_init_val_Pos        (0UL)                     /*!< random random_init: val (Bit 0)                       */
#define random_random_init_val_Msk        (0xffffffffUL)            /*!< random random_init: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  random_random  ===================================================== */
#define random_random_random_val_Pos      (0UL)                     /*!< random random_random: val (Bit 0)                     */
#define random_random_random_val_Msk      (0xffffffffUL)            /*!< random random_random: val (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                           mtgy                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  mtgy_cmd  ======================================================== */
#define mtgy_mtgy_cmd_src_addr_x_Pos      (27UL)                    /*!< mtgy mtgy_cmd: src_addr_x (Bit 27)                    */
#define mtgy_mtgy_cmd_src_addr_x_Msk      (0xf8000000UL)            /*!< mtgy mtgy_cmd: src_addr_x (Bitfield-Mask: 0x1f)       */
#define mtgy_mtgy_cmd_src_addr_e_Pos      (22UL)                    /*!< mtgy mtgy_cmd: src_addr_e (Bit 22)                    */
#define mtgy_mtgy_cmd_src_addr_e_Msk      (0x7c00000UL)             /*!< mtgy mtgy_cmd: src_addr_e (Bitfield-Mask: 0x1f)       */
#define mtgy_mtgy_cmd_dest_addr_Pos       (17UL)                    /*!< mtgy mtgy_cmd: dest_addr (Bit 17)                     */
#define mtgy_mtgy_cmd_dest_addr_Msk       (0x3e0000UL)              /*!< mtgy mtgy_cmd: dest_addr (Bitfield-Mask: 0x1f)        */
#define mtgy_mtgy_cmd_src_addr_Pos        (12UL)                    /*!< mtgy mtgy_cmd: src_addr (Bit 12)                      */
#define mtgy_mtgy_cmd_src_addr_Msk        (0x1f000UL)               /*!< mtgy mtgy_cmd: src_addr (Bitfield-Mask: 0x1f)         */
#define mtgy_mtgy_cmd_op_Pos              (8UL)                     /*!< mtgy mtgy_cmd: op (Bit 8)                             */
#define mtgy_mtgy_cmd_op_Msk              (0xf00UL)                 /*!< mtgy mtgy_cmd: op (Bitfield-Mask: 0x0f)               */
#define mtgy_mtgy_cmd_precision_Pos       (4UL)                     /*!< mtgy mtgy_cmd: precision (Bit 4)                      */
#define mtgy_mtgy_cmd_precision_Msk       (0xf0UL)                  /*!< mtgy mtgy_cmd: precision (Bitfield-Mask: 0x0f)        */
#define mtgy_mtgy_cmd_reserved0_Pos       (3UL)                     /*!< mtgy mtgy_cmd: reserved0 (Bit 3)                      */
#define mtgy_mtgy_cmd_reserved0_Msk       (0x8UL)                   /*!< mtgy mtgy_cmd: reserved0 (Bitfield-Mask: 0x01)        */
#define mtgy_mtgy_cmd_f_sel_Pos           (2UL)                     /*!< mtgy mtgy_cmd: f_sel (Bit 2)                          */
#define mtgy_mtgy_cmd_f_sel_Msk           (0x4UL)                   /*!< mtgy mtgy_cmd: f_sel (Bitfield-Mask: 0x01)            */
#define mtgy_mtgy_cmd_abort_Pos           (1UL)                     /*!< mtgy mtgy_cmd: abort (Bit 1)                          */
#define mtgy_mtgy_cmd_abort_Msk           (0x2UL)                   /*!< mtgy mtgy_cmd: abort (Bitfield-Mask: 0x01)            */
#define mtgy_mtgy_cmd_start_Pos           (0UL)                     /*!< mtgy mtgy_cmd: start (Bit 0)                          */
#define mtgy_mtgy_cmd_start_Msk           (0x1UL)                   /*!< mtgy mtgy_cmd: start (Bitfield-Mask: 0x01)            */
/* =======================================================  mtgy_stat  ======================================================= */
#define mtgy_mtgy_stat_done_Pos           (0UL)                     /*!< mtgy mtgy_stat: done (Bit 0)                          */
#define mtgy_mtgy_stat_done_Msk           (0x1UL)                   /*!< mtgy mtgy_stat: done (Bitfield-Mask: 0x01)            */
/* =====================================================  mtgy_irq_raw  ====================================================== */
#define mtgy_mtgy_irq_raw_done_Pos        (0UL)                     /*!< mtgy mtgy_irq_raw: done (Bit 0)                       */
#define mtgy_mtgy_irq_raw_done_Msk        (0x1UL)                   /*!< mtgy mtgy_irq_raw: done (Bitfield-Mask: 0x01)         */
/* ====================================================  mtgy_irq_masked  ==================================================== */
#define mtgy_mtgy_irq_masked_done_Pos     (0UL)                     /*!< mtgy mtgy_irq_masked: done (Bit 0)                    */
#define mtgy_mtgy_irq_masked_done_Msk     (0x1UL)                   /*!< mtgy mtgy_irq_masked: done (Bitfield-Mask: 0x01)      */
/* ===================================================  mtgy_irq_msk_set  ==================================================== */
#define mtgy_mtgy_irq_msk_set_done_Pos    (0UL)                     /*!< mtgy mtgy_irq_msk_set: done (Bit 0)                   */
#define mtgy_mtgy_irq_msk_set_done_Msk    (0x1UL)                   /*!< mtgy mtgy_irq_msk_set: done (Bitfield-Mask: 0x01)     */
/* ==================================================  mtgy_irq_msk_reset  =================================================== */
#define mtgy_mtgy_irq_msk_reset_done_Pos  (0UL)                     /*!< mtgy mtgy_irq_msk_reset: done (Bit 0)                 */
#define mtgy_mtgy_irq_msk_reset_done_Msk  (0x1UL)                   /*!< mtgy mtgy_irq_msk_reset: done (Bitfield-Mask: 0x01)   */
/* ======================================================  mtgy_op_tc0  ====================================================== */
#define mtgy_mtgy_op_tc0_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc0: val (Bit 0)                         */
#define mtgy_mtgy_op_tc0_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc0: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc1  ====================================================== */
#define mtgy_mtgy_op_tc1_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc1: val (Bit 0)                         */
#define mtgy_mtgy_op_tc1_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc1: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc2  ====================================================== */
#define mtgy_mtgy_op_tc2_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc2: val (Bit 0)                         */
#define mtgy_mtgy_op_tc2_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc2: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc3  ====================================================== */
#define mtgy_mtgy_op_tc3_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc3: val (Bit 0)                         */
#define mtgy_mtgy_op_tc3_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc3: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc4  ====================================================== */
#define mtgy_mtgy_op_tc4_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc4: val (Bit 0)                         */
#define mtgy_mtgy_op_tc4_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc4: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc5  ====================================================== */
#define mtgy_mtgy_op_tc5_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc5: val (Bit 0)                         */
#define mtgy_mtgy_op_tc5_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc5: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc6  ====================================================== */
#define mtgy_mtgy_op_tc6_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc6: val (Bit 0)                         */
#define mtgy_mtgy_op_tc6_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc6: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc7  ====================================================== */
#define mtgy_mtgy_op_tc7_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc7: val (Bit 0)                         */
#define mtgy_mtgy_op_tc7_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc7: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc8  ====================================================== */
#define mtgy_mtgy_op_tc8_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc8: val (Bit 0)                         */
#define mtgy_mtgy_op_tc8_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc8: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_tc9  ====================================================== */
#define mtgy_mtgy_op_tc9_val_Pos          (0UL)                     /*!< mtgy mtgy_op_tc9: val (Bit 0)                         */
#define mtgy_mtgy_op_tc9_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_tc9: val (Bitfield-Mask: 0xffffffff)     */
/* =====================================================  mtgy_op_tc10  ====================================================== */
#define mtgy_mtgy_op_tc10_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc10: val (Bit 0)                        */
#define mtgy_mtgy_op_tc10_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc10: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc11  ====================================================== */
#define mtgy_mtgy_op_tc11_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc11: val (Bit 0)                        */
#define mtgy_mtgy_op_tc11_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc11: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc12  ====================================================== */
#define mtgy_mtgy_op_tc12_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc12: val (Bit 0)                        */
#define mtgy_mtgy_op_tc12_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc12: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc13  ====================================================== */
#define mtgy_mtgy_op_tc13_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc13: val (Bit 0)                        */
#define mtgy_mtgy_op_tc13_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc13: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc14  ====================================================== */
#define mtgy_mtgy_op_tc14_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc14: val (Bit 0)                        */
#define mtgy_mtgy_op_tc14_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc14: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc15  ====================================================== */
#define mtgy_mtgy_op_tc15_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc15: val (Bit 0)                        */
#define mtgy_mtgy_op_tc15_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc15: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc16  ====================================================== */
#define mtgy_mtgy_op_tc16_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc16: val (Bit 0)                        */
#define mtgy_mtgy_op_tc16_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc16: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc17  ====================================================== */
#define mtgy_mtgy_op_tc17_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc17: val (Bit 0)                        */
#define mtgy_mtgy_op_tc17_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc17: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc18  ====================================================== */
#define mtgy_mtgy_op_tc18_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc18: val (Bit 0)                        */
#define mtgy_mtgy_op_tc18_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc18: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc19  ====================================================== */
#define mtgy_mtgy_op_tc19_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc19: val (Bit 0)                        */
#define mtgy_mtgy_op_tc19_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc19: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc20  ====================================================== */
#define mtgy_mtgy_op_tc20_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc20: val (Bit 0)                        */
#define mtgy_mtgy_op_tc20_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc20: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc21  ====================================================== */
#define mtgy_mtgy_op_tc21_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc21: val (Bit 0)                        */
#define mtgy_mtgy_op_tc21_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc21: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc22  ====================================================== */
#define mtgy_mtgy_op_tc22_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc22: val (Bit 0)                        */
#define mtgy_mtgy_op_tc22_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc22: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc23  ====================================================== */
#define mtgy_mtgy_op_tc23_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc23: val (Bit 0)                        */
#define mtgy_mtgy_op_tc23_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc23: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc24  ====================================================== */
#define mtgy_mtgy_op_tc24_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc24: val (Bit 0)                        */
#define mtgy_mtgy_op_tc24_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc24: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc25  ====================================================== */
#define mtgy_mtgy_op_tc25_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc25: val (Bit 0)                        */
#define mtgy_mtgy_op_tc25_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc25: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc26  ====================================================== */
#define mtgy_mtgy_op_tc26_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc26: val (Bit 0)                        */
#define mtgy_mtgy_op_tc26_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc26: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc27  ====================================================== */
#define mtgy_mtgy_op_tc27_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc27: val (Bit 0)                        */
#define mtgy_mtgy_op_tc27_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc27: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc28  ====================================================== */
#define mtgy_mtgy_op_tc28_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc28: val (Bit 0)                        */
#define mtgy_mtgy_op_tc28_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc28: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc29  ====================================================== */
#define mtgy_mtgy_op_tc29_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc29: val (Bit 0)                        */
#define mtgy_mtgy_op_tc29_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc29: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc30  ====================================================== */
#define mtgy_mtgy_op_tc30_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc30: val (Bit 0)                        */
#define mtgy_mtgy_op_tc30_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc30: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc31  ====================================================== */
#define mtgy_mtgy_op_tc31_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc31: val (Bit 0)                        */
#define mtgy_mtgy_op_tc31_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc31: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc32  ====================================================== */
#define mtgy_mtgy_op_tc32_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc32: val (Bit 0)                        */
#define mtgy_mtgy_op_tc32_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc32: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc33  ====================================================== */
#define mtgy_mtgy_op_tc33_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc33: val (Bit 0)                        */
#define mtgy_mtgy_op_tc33_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc33: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc34  ====================================================== */
#define mtgy_mtgy_op_tc34_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc34: val (Bit 0)                        */
#define mtgy_mtgy_op_tc34_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc34: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc35  ====================================================== */
#define mtgy_mtgy_op_tc35_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc35: val (Bit 0)                        */
#define mtgy_mtgy_op_tc35_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc35: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc36  ====================================================== */
#define mtgy_mtgy_op_tc36_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc36: val (Bit 0)                        */
#define mtgy_mtgy_op_tc36_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc36: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc37  ====================================================== */
#define mtgy_mtgy_op_tc37_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc37: val (Bit 0)                        */
#define mtgy_mtgy_op_tc37_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc37: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc38  ====================================================== */
#define mtgy_mtgy_op_tc38_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc38: val (Bit 0)                        */
#define mtgy_mtgy_op_tc38_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc38: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc39  ====================================================== */
#define mtgy_mtgy_op_tc39_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc39: val (Bit 0)                        */
#define mtgy_mtgy_op_tc39_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc39: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc40  ====================================================== */
#define mtgy_mtgy_op_tc40_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc40: val (Bit 0)                        */
#define mtgy_mtgy_op_tc40_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc40: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc41  ====================================================== */
#define mtgy_mtgy_op_tc41_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc41: val (Bit 0)                        */
#define mtgy_mtgy_op_tc41_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc41: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc42  ====================================================== */
#define mtgy_mtgy_op_tc42_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc42: val (Bit 0)                        */
#define mtgy_mtgy_op_tc42_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc42: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc43  ====================================================== */
#define mtgy_mtgy_op_tc43_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc43: val (Bit 0)                        */
#define mtgy_mtgy_op_tc43_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc43: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc44  ====================================================== */
#define mtgy_mtgy_op_tc44_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc44: val (Bit 0)                        */
#define mtgy_mtgy_op_tc44_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc44: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc45  ====================================================== */
#define mtgy_mtgy_op_tc45_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc45: val (Bit 0)                        */
#define mtgy_mtgy_op_tc45_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc45: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc46  ====================================================== */
#define mtgy_mtgy_op_tc46_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc46: val (Bit 0)                        */
#define mtgy_mtgy_op_tc46_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc46: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc47  ====================================================== */
#define mtgy_mtgy_op_tc47_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc47: val (Bit 0)                        */
#define mtgy_mtgy_op_tc47_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc47: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc48  ====================================================== */
#define mtgy_mtgy_op_tc48_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc48: val (Bit 0)                        */
#define mtgy_mtgy_op_tc48_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc48: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc49  ====================================================== */
#define mtgy_mtgy_op_tc49_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc49: val (Bit 0)                        */
#define mtgy_mtgy_op_tc49_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc49: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc50  ====================================================== */
#define mtgy_mtgy_op_tc50_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc50: val (Bit 0)                        */
#define mtgy_mtgy_op_tc50_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc50: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc51  ====================================================== */
#define mtgy_mtgy_op_tc51_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc51: val (Bit 0)                        */
#define mtgy_mtgy_op_tc51_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc51: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc52  ====================================================== */
#define mtgy_mtgy_op_tc52_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc52: val (Bit 0)                        */
#define mtgy_mtgy_op_tc52_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc52: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc53  ====================================================== */
#define mtgy_mtgy_op_tc53_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc53: val (Bit 0)                        */
#define mtgy_mtgy_op_tc53_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc53: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc54  ====================================================== */
#define mtgy_mtgy_op_tc54_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc54: val (Bit 0)                        */
#define mtgy_mtgy_op_tc54_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc54: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc55  ====================================================== */
#define mtgy_mtgy_op_tc55_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc55: val (Bit 0)                        */
#define mtgy_mtgy_op_tc55_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc55: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc56  ====================================================== */
#define mtgy_mtgy_op_tc56_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc56: val (Bit 0)                        */
#define mtgy_mtgy_op_tc56_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc56: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc57  ====================================================== */
#define mtgy_mtgy_op_tc57_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc57: val (Bit 0)                        */
#define mtgy_mtgy_op_tc57_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc57: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc58  ====================================================== */
#define mtgy_mtgy_op_tc58_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc58: val (Bit 0)                        */
#define mtgy_mtgy_op_tc58_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc58: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc59  ====================================================== */
#define mtgy_mtgy_op_tc59_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc59: val (Bit 0)                        */
#define mtgy_mtgy_op_tc59_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc59: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc60  ====================================================== */
#define mtgy_mtgy_op_tc60_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc60: val (Bit 0)                        */
#define mtgy_mtgy_op_tc60_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc60: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc61  ====================================================== */
#define mtgy_mtgy_op_tc61_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc61: val (Bit 0)                        */
#define mtgy_mtgy_op_tc61_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc61: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc62  ====================================================== */
#define mtgy_mtgy_op_tc62_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc62: val (Bit 0)                        */
#define mtgy_mtgy_op_tc62_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc62: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc63  ====================================================== */
#define mtgy_mtgy_op_tc63_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc63: val (Bit 0)                        */
#define mtgy_mtgy_op_tc63_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc63: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc64  ====================================================== */
#define mtgy_mtgy_op_tc64_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc64: val (Bit 0)                        */
#define mtgy_mtgy_op_tc64_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc64: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc65  ====================================================== */
#define mtgy_mtgy_op_tc65_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc65: val (Bit 0)                        */
#define mtgy_mtgy_op_tc65_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc65: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc66  ====================================================== */
#define mtgy_mtgy_op_tc66_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc66: val (Bit 0)                        */
#define mtgy_mtgy_op_tc66_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc66: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc67  ====================================================== */
#define mtgy_mtgy_op_tc67_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc67: val (Bit 0)                        */
#define mtgy_mtgy_op_tc67_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc67: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc68  ====================================================== */
#define mtgy_mtgy_op_tc68_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc68: val (Bit 0)                        */
#define mtgy_mtgy_op_tc68_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc68: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc69  ====================================================== */
#define mtgy_mtgy_op_tc69_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc69: val (Bit 0)                        */
#define mtgy_mtgy_op_tc69_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc69: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc70  ====================================================== */
#define mtgy_mtgy_op_tc70_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc70: val (Bit 0)                        */
#define mtgy_mtgy_op_tc70_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc70: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc71  ====================================================== */
#define mtgy_mtgy_op_tc71_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc71: val (Bit 0)                        */
#define mtgy_mtgy_op_tc71_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc71: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc72  ====================================================== */
#define mtgy_mtgy_op_tc72_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc72: val (Bit 0)                        */
#define mtgy_mtgy_op_tc72_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc72: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc73  ====================================================== */
#define mtgy_mtgy_op_tc73_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc73: val (Bit 0)                        */
#define mtgy_mtgy_op_tc73_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc73: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc74  ====================================================== */
#define mtgy_mtgy_op_tc74_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc74: val (Bit 0)                        */
#define mtgy_mtgy_op_tc74_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc74: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc75  ====================================================== */
#define mtgy_mtgy_op_tc75_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc75: val (Bit 0)                        */
#define mtgy_mtgy_op_tc75_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc75: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc76  ====================================================== */
#define mtgy_mtgy_op_tc76_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc76: val (Bit 0)                        */
#define mtgy_mtgy_op_tc76_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc76: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc77  ====================================================== */
#define mtgy_mtgy_op_tc77_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc77: val (Bit 0)                        */
#define mtgy_mtgy_op_tc77_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc77: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc78  ====================================================== */
#define mtgy_mtgy_op_tc78_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc78: val (Bit 0)                        */
#define mtgy_mtgy_op_tc78_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc78: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc79  ====================================================== */
#define mtgy_mtgy_op_tc79_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc79: val (Bit 0)                        */
#define mtgy_mtgy_op_tc79_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc79: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc80  ====================================================== */
#define mtgy_mtgy_op_tc80_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc80: val (Bit 0)                        */
#define mtgy_mtgy_op_tc80_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc80: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc81  ====================================================== */
#define mtgy_mtgy_op_tc81_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc81: val (Bit 0)                        */
#define mtgy_mtgy_op_tc81_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc81: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc82  ====================================================== */
#define mtgy_mtgy_op_tc82_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc82: val (Bit 0)                        */
#define mtgy_mtgy_op_tc82_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc82: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc83  ====================================================== */
#define mtgy_mtgy_op_tc83_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc83: val (Bit 0)                        */
#define mtgy_mtgy_op_tc83_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc83: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc84  ====================================================== */
#define mtgy_mtgy_op_tc84_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc84: val (Bit 0)                        */
#define mtgy_mtgy_op_tc84_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc84: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc85  ====================================================== */
#define mtgy_mtgy_op_tc85_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc85: val (Bit 0)                        */
#define mtgy_mtgy_op_tc85_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc85: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc86  ====================================================== */
#define mtgy_mtgy_op_tc86_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc86: val (Bit 0)                        */
#define mtgy_mtgy_op_tc86_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc86: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc87  ====================================================== */
#define mtgy_mtgy_op_tc87_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc87: val (Bit 0)                        */
#define mtgy_mtgy_op_tc87_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc87: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc88  ====================================================== */
#define mtgy_mtgy_op_tc88_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc88: val (Bit 0)                        */
#define mtgy_mtgy_op_tc88_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc88: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc89  ====================================================== */
#define mtgy_mtgy_op_tc89_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc89: val (Bit 0)                        */
#define mtgy_mtgy_op_tc89_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc89: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc90  ====================================================== */
#define mtgy_mtgy_op_tc90_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc90: val (Bit 0)                        */
#define mtgy_mtgy_op_tc90_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc90: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc91  ====================================================== */
#define mtgy_mtgy_op_tc91_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc91: val (Bit 0)                        */
#define mtgy_mtgy_op_tc91_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc91: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc92  ====================================================== */
#define mtgy_mtgy_op_tc92_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc92: val (Bit 0)                        */
#define mtgy_mtgy_op_tc92_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc92: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc93  ====================================================== */
#define mtgy_mtgy_op_tc93_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc93: val (Bit 0)                        */
#define mtgy_mtgy_op_tc93_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc93: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc94  ====================================================== */
#define mtgy_mtgy_op_tc94_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc94: val (Bit 0)                        */
#define mtgy_mtgy_op_tc94_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc94: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc95  ====================================================== */
#define mtgy_mtgy_op_tc95_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc95: val (Bit 0)                        */
#define mtgy_mtgy_op_tc95_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc95: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc96  ====================================================== */
#define mtgy_mtgy_op_tc96_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc96: val (Bit 0)                        */
#define mtgy_mtgy_op_tc96_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc96: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc97  ====================================================== */
#define mtgy_mtgy_op_tc97_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc97: val (Bit 0)                        */
#define mtgy_mtgy_op_tc97_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc97: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc98  ====================================================== */
#define mtgy_mtgy_op_tc98_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc98: val (Bit 0)                        */
#define mtgy_mtgy_op_tc98_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc98: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc99  ====================================================== */
#define mtgy_mtgy_op_tc99_val_Pos         (0UL)                     /*!< mtgy mtgy_op_tc99: val (Bit 0)                        */
#define mtgy_mtgy_op_tc99_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_tc99: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_tc100  ===================================================== */
#define mtgy_mtgy_op_tc100_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc100: val (Bit 0)                       */
#define mtgy_mtgy_op_tc100_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc100: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc101  ===================================================== */
#define mtgy_mtgy_op_tc101_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc101: val (Bit 0)                       */
#define mtgy_mtgy_op_tc101_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc101: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc102  ===================================================== */
#define mtgy_mtgy_op_tc102_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc102: val (Bit 0)                       */
#define mtgy_mtgy_op_tc102_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc102: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc103  ===================================================== */
#define mtgy_mtgy_op_tc103_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc103: val (Bit 0)                       */
#define mtgy_mtgy_op_tc103_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc103: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc104  ===================================================== */
#define mtgy_mtgy_op_tc104_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc104: val (Bit 0)                       */
#define mtgy_mtgy_op_tc104_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc104: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc105  ===================================================== */
#define mtgy_mtgy_op_tc105_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc105: val (Bit 0)                       */
#define mtgy_mtgy_op_tc105_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc105: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc106  ===================================================== */
#define mtgy_mtgy_op_tc106_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc106: val (Bit 0)                       */
#define mtgy_mtgy_op_tc106_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc106: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc107  ===================================================== */
#define mtgy_mtgy_op_tc107_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc107: val (Bit 0)                       */
#define mtgy_mtgy_op_tc107_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc107: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc108  ===================================================== */
#define mtgy_mtgy_op_tc108_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc108: val (Bit 0)                       */
#define mtgy_mtgy_op_tc108_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc108: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc109  ===================================================== */
#define mtgy_mtgy_op_tc109_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc109: val (Bit 0)                       */
#define mtgy_mtgy_op_tc109_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc109: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc110  ===================================================== */
#define mtgy_mtgy_op_tc110_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc110: val (Bit 0)                       */
#define mtgy_mtgy_op_tc110_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc110: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc111  ===================================================== */
#define mtgy_mtgy_op_tc111_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc111: val (Bit 0)                       */
#define mtgy_mtgy_op_tc111_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc111: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc112  ===================================================== */
#define mtgy_mtgy_op_tc112_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc112: val (Bit 0)                       */
#define mtgy_mtgy_op_tc112_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc112: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc113  ===================================================== */
#define mtgy_mtgy_op_tc113_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc113: val (Bit 0)                       */
#define mtgy_mtgy_op_tc113_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc113: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc114  ===================================================== */
#define mtgy_mtgy_op_tc114_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc114: val (Bit 0)                       */
#define mtgy_mtgy_op_tc114_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc114: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc115  ===================================================== */
#define mtgy_mtgy_op_tc115_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc115: val (Bit 0)                       */
#define mtgy_mtgy_op_tc115_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc115: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc116  ===================================================== */
#define mtgy_mtgy_op_tc116_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc116: val (Bit 0)                       */
#define mtgy_mtgy_op_tc116_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc116: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc117  ===================================================== */
#define mtgy_mtgy_op_tc117_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc117: val (Bit 0)                       */
#define mtgy_mtgy_op_tc117_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc117: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc118  ===================================================== */
#define mtgy_mtgy_op_tc118_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc118: val (Bit 0)                       */
#define mtgy_mtgy_op_tc118_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc118: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc119  ===================================================== */
#define mtgy_mtgy_op_tc119_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc119: val (Bit 0)                       */
#define mtgy_mtgy_op_tc119_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc119: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc120  ===================================================== */
#define mtgy_mtgy_op_tc120_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc120: val (Bit 0)                       */
#define mtgy_mtgy_op_tc120_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc120: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc121  ===================================================== */
#define mtgy_mtgy_op_tc121_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc121: val (Bit 0)                       */
#define mtgy_mtgy_op_tc121_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc121: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc122  ===================================================== */
#define mtgy_mtgy_op_tc122_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc122: val (Bit 0)                       */
#define mtgy_mtgy_op_tc122_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc122: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc123  ===================================================== */
#define mtgy_mtgy_op_tc123_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc123: val (Bit 0)                       */
#define mtgy_mtgy_op_tc123_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc123: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc124  ===================================================== */
#define mtgy_mtgy_op_tc124_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc124: val (Bit 0)                       */
#define mtgy_mtgy_op_tc124_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc124: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc125  ===================================================== */
#define mtgy_mtgy_op_tc125_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc125: val (Bit 0)                       */
#define mtgy_mtgy_op_tc125_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc125: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc126  ===================================================== */
#define mtgy_mtgy_op_tc126_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc126: val (Bit 0)                       */
#define mtgy_mtgy_op_tc126_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc126: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_tc127  ===================================================== */
#define mtgy_mtgy_op_tc127_val_Pos        (0UL)                     /*!< mtgy mtgy_op_tc127: val (Bit 0)                       */
#define mtgy_mtgy_op_tc127_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_tc127: val (Bitfield-Mask: 0xffffffff)   */
/* ======================================================  mtgy_op_ts0  ====================================================== */
#define mtgy_mtgy_op_ts0_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts0: val (Bit 0)                         */
#define mtgy_mtgy_op_ts0_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts0: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts1  ====================================================== */
#define mtgy_mtgy_op_ts1_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts1: val (Bit 0)                         */
#define mtgy_mtgy_op_ts1_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts1: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts2  ====================================================== */
#define mtgy_mtgy_op_ts2_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts2: val (Bit 0)                         */
#define mtgy_mtgy_op_ts2_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts2: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts3  ====================================================== */
#define mtgy_mtgy_op_ts3_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts3: val (Bit 0)                         */
#define mtgy_mtgy_op_ts3_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts3: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts4  ====================================================== */
#define mtgy_mtgy_op_ts4_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts4: val (Bit 0)                         */
#define mtgy_mtgy_op_ts4_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts4: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts5  ====================================================== */
#define mtgy_mtgy_op_ts5_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts5: val (Bit 0)                         */
#define mtgy_mtgy_op_ts5_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts5: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts6  ====================================================== */
#define mtgy_mtgy_op_ts6_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts6: val (Bit 0)                         */
#define mtgy_mtgy_op_ts6_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts6: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts7  ====================================================== */
#define mtgy_mtgy_op_ts7_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts7: val (Bit 0)                         */
#define mtgy_mtgy_op_ts7_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts7: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts8  ====================================================== */
#define mtgy_mtgy_op_ts8_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts8: val (Bit 0)                         */
#define mtgy_mtgy_op_ts8_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts8: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_ts9  ====================================================== */
#define mtgy_mtgy_op_ts9_val_Pos          (0UL)                     /*!< mtgy mtgy_op_ts9: val (Bit 0)                         */
#define mtgy_mtgy_op_ts9_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_ts9: val (Bitfield-Mask: 0xffffffff)     */
/* =====================================================  mtgy_op_ts10  ====================================================== */
#define mtgy_mtgy_op_ts10_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts10: val (Bit 0)                        */
#define mtgy_mtgy_op_ts10_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts10: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts11  ====================================================== */
#define mtgy_mtgy_op_ts11_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts11: val (Bit 0)                        */
#define mtgy_mtgy_op_ts11_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts11: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts12  ====================================================== */
#define mtgy_mtgy_op_ts12_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts12: val (Bit 0)                        */
#define mtgy_mtgy_op_ts12_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts12: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts13  ====================================================== */
#define mtgy_mtgy_op_ts13_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts13: val (Bit 0)                        */
#define mtgy_mtgy_op_ts13_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts13: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts14  ====================================================== */
#define mtgy_mtgy_op_ts14_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts14: val (Bit 0)                        */
#define mtgy_mtgy_op_ts14_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts14: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts15  ====================================================== */
#define mtgy_mtgy_op_ts15_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts15: val (Bit 0)                        */
#define mtgy_mtgy_op_ts15_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts15: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts16  ====================================================== */
#define mtgy_mtgy_op_ts16_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts16: val (Bit 0)                        */
#define mtgy_mtgy_op_ts16_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts16: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts17  ====================================================== */
#define mtgy_mtgy_op_ts17_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts17: val (Bit 0)                        */
#define mtgy_mtgy_op_ts17_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts17: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts18  ====================================================== */
#define mtgy_mtgy_op_ts18_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts18: val (Bit 0)                        */
#define mtgy_mtgy_op_ts18_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts18: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts19  ====================================================== */
#define mtgy_mtgy_op_ts19_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts19: val (Bit 0)                        */
#define mtgy_mtgy_op_ts19_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts19: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts20  ====================================================== */
#define mtgy_mtgy_op_ts20_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts20: val (Bit 0)                        */
#define mtgy_mtgy_op_ts20_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts20: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts21  ====================================================== */
#define mtgy_mtgy_op_ts21_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts21: val (Bit 0)                        */
#define mtgy_mtgy_op_ts21_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts21: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts22  ====================================================== */
#define mtgy_mtgy_op_ts22_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts22: val (Bit 0)                        */
#define mtgy_mtgy_op_ts22_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts22: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts23  ====================================================== */
#define mtgy_mtgy_op_ts23_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts23: val (Bit 0)                        */
#define mtgy_mtgy_op_ts23_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts23: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts24  ====================================================== */
#define mtgy_mtgy_op_ts24_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts24: val (Bit 0)                        */
#define mtgy_mtgy_op_ts24_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts24: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts25  ====================================================== */
#define mtgy_mtgy_op_ts25_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts25: val (Bit 0)                        */
#define mtgy_mtgy_op_ts25_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts25: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts26  ====================================================== */
#define mtgy_mtgy_op_ts26_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts26: val (Bit 0)                        */
#define mtgy_mtgy_op_ts26_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts26: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts27  ====================================================== */
#define mtgy_mtgy_op_ts27_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts27: val (Bit 0)                        */
#define mtgy_mtgy_op_ts27_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts27: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts28  ====================================================== */
#define mtgy_mtgy_op_ts28_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts28: val (Bit 0)                        */
#define mtgy_mtgy_op_ts28_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts28: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts29  ====================================================== */
#define mtgy_mtgy_op_ts29_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts29: val (Bit 0)                        */
#define mtgy_mtgy_op_ts29_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts29: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts30  ====================================================== */
#define mtgy_mtgy_op_ts30_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts30: val (Bit 0)                        */
#define mtgy_mtgy_op_ts30_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts30: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts31  ====================================================== */
#define mtgy_mtgy_op_ts31_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts31: val (Bit 0)                        */
#define mtgy_mtgy_op_ts31_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts31: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts32  ====================================================== */
#define mtgy_mtgy_op_ts32_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts32: val (Bit 0)                        */
#define mtgy_mtgy_op_ts32_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts32: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts33  ====================================================== */
#define mtgy_mtgy_op_ts33_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts33: val (Bit 0)                        */
#define mtgy_mtgy_op_ts33_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts33: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts34  ====================================================== */
#define mtgy_mtgy_op_ts34_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts34: val (Bit 0)                        */
#define mtgy_mtgy_op_ts34_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts34: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts35  ====================================================== */
#define mtgy_mtgy_op_ts35_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts35: val (Bit 0)                        */
#define mtgy_mtgy_op_ts35_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts35: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts36  ====================================================== */
#define mtgy_mtgy_op_ts36_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts36: val (Bit 0)                        */
#define mtgy_mtgy_op_ts36_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts36: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts37  ====================================================== */
#define mtgy_mtgy_op_ts37_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts37: val (Bit 0)                        */
#define mtgy_mtgy_op_ts37_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts37: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts38  ====================================================== */
#define mtgy_mtgy_op_ts38_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts38: val (Bit 0)                        */
#define mtgy_mtgy_op_ts38_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts38: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts39  ====================================================== */
#define mtgy_mtgy_op_ts39_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts39: val (Bit 0)                        */
#define mtgy_mtgy_op_ts39_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts39: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts40  ====================================================== */
#define mtgy_mtgy_op_ts40_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts40: val (Bit 0)                        */
#define mtgy_mtgy_op_ts40_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts40: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts41  ====================================================== */
#define mtgy_mtgy_op_ts41_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts41: val (Bit 0)                        */
#define mtgy_mtgy_op_ts41_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts41: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts42  ====================================================== */
#define mtgy_mtgy_op_ts42_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts42: val (Bit 0)                        */
#define mtgy_mtgy_op_ts42_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts42: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts43  ====================================================== */
#define mtgy_mtgy_op_ts43_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts43: val (Bit 0)                        */
#define mtgy_mtgy_op_ts43_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts43: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts44  ====================================================== */
#define mtgy_mtgy_op_ts44_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts44: val (Bit 0)                        */
#define mtgy_mtgy_op_ts44_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts44: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts45  ====================================================== */
#define mtgy_mtgy_op_ts45_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts45: val (Bit 0)                        */
#define mtgy_mtgy_op_ts45_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts45: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts46  ====================================================== */
#define mtgy_mtgy_op_ts46_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts46: val (Bit 0)                        */
#define mtgy_mtgy_op_ts46_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts46: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts47  ====================================================== */
#define mtgy_mtgy_op_ts47_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts47: val (Bit 0)                        */
#define mtgy_mtgy_op_ts47_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts47: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts48  ====================================================== */
#define mtgy_mtgy_op_ts48_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts48: val (Bit 0)                        */
#define mtgy_mtgy_op_ts48_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts48: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts49  ====================================================== */
#define mtgy_mtgy_op_ts49_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts49: val (Bit 0)                        */
#define mtgy_mtgy_op_ts49_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts49: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts50  ====================================================== */
#define mtgy_mtgy_op_ts50_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts50: val (Bit 0)                        */
#define mtgy_mtgy_op_ts50_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts50: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts51  ====================================================== */
#define mtgy_mtgy_op_ts51_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts51: val (Bit 0)                        */
#define mtgy_mtgy_op_ts51_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts51: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts52  ====================================================== */
#define mtgy_mtgy_op_ts52_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts52: val (Bit 0)                        */
#define mtgy_mtgy_op_ts52_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts52: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts53  ====================================================== */
#define mtgy_mtgy_op_ts53_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts53: val (Bit 0)                        */
#define mtgy_mtgy_op_ts53_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts53: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts54  ====================================================== */
#define mtgy_mtgy_op_ts54_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts54: val (Bit 0)                        */
#define mtgy_mtgy_op_ts54_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts54: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts55  ====================================================== */
#define mtgy_mtgy_op_ts55_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts55: val (Bit 0)                        */
#define mtgy_mtgy_op_ts55_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts55: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts56  ====================================================== */
#define mtgy_mtgy_op_ts56_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts56: val (Bit 0)                        */
#define mtgy_mtgy_op_ts56_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts56: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts57  ====================================================== */
#define mtgy_mtgy_op_ts57_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts57: val (Bit 0)                        */
#define mtgy_mtgy_op_ts57_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts57: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts58  ====================================================== */
#define mtgy_mtgy_op_ts58_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts58: val (Bit 0)                        */
#define mtgy_mtgy_op_ts58_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts58: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts59  ====================================================== */
#define mtgy_mtgy_op_ts59_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts59: val (Bit 0)                        */
#define mtgy_mtgy_op_ts59_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts59: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts60  ====================================================== */
#define mtgy_mtgy_op_ts60_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts60: val (Bit 0)                        */
#define mtgy_mtgy_op_ts60_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts60: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts61  ====================================================== */
#define mtgy_mtgy_op_ts61_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts61: val (Bit 0)                        */
#define mtgy_mtgy_op_ts61_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts61: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts62  ====================================================== */
#define mtgy_mtgy_op_ts62_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts62: val (Bit 0)                        */
#define mtgy_mtgy_op_ts62_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts62: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts63  ====================================================== */
#define mtgy_mtgy_op_ts63_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts63: val (Bit 0)                        */
#define mtgy_mtgy_op_ts63_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts63: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts64  ====================================================== */
#define mtgy_mtgy_op_ts64_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts64: val (Bit 0)                        */
#define mtgy_mtgy_op_ts64_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts64: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts65  ====================================================== */
#define mtgy_mtgy_op_ts65_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts65: val (Bit 0)                        */
#define mtgy_mtgy_op_ts65_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts65: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts66  ====================================================== */
#define mtgy_mtgy_op_ts66_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts66: val (Bit 0)                        */
#define mtgy_mtgy_op_ts66_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts66: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts67  ====================================================== */
#define mtgy_mtgy_op_ts67_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts67: val (Bit 0)                        */
#define mtgy_mtgy_op_ts67_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts67: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts68  ====================================================== */
#define mtgy_mtgy_op_ts68_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts68: val (Bit 0)                        */
#define mtgy_mtgy_op_ts68_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts68: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts69  ====================================================== */
#define mtgy_mtgy_op_ts69_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts69: val (Bit 0)                        */
#define mtgy_mtgy_op_ts69_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts69: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts70  ====================================================== */
#define mtgy_mtgy_op_ts70_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts70: val (Bit 0)                        */
#define mtgy_mtgy_op_ts70_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts70: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts71  ====================================================== */
#define mtgy_mtgy_op_ts71_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts71: val (Bit 0)                        */
#define mtgy_mtgy_op_ts71_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts71: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts72  ====================================================== */
#define mtgy_mtgy_op_ts72_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts72: val (Bit 0)                        */
#define mtgy_mtgy_op_ts72_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts72: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts73  ====================================================== */
#define mtgy_mtgy_op_ts73_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts73: val (Bit 0)                        */
#define mtgy_mtgy_op_ts73_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts73: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts74  ====================================================== */
#define mtgy_mtgy_op_ts74_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts74: val (Bit 0)                        */
#define mtgy_mtgy_op_ts74_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts74: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts75  ====================================================== */
#define mtgy_mtgy_op_ts75_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts75: val (Bit 0)                        */
#define mtgy_mtgy_op_ts75_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts75: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts76  ====================================================== */
#define mtgy_mtgy_op_ts76_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts76: val (Bit 0)                        */
#define mtgy_mtgy_op_ts76_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts76: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts77  ====================================================== */
#define mtgy_mtgy_op_ts77_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts77: val (Bit 0)                        */
#define mtgy_mtgy_op_ts77_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts77: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts78  ====================================================== */
#define mtgy_mtgy_op_ts78_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts78: val (Bit 0)                        */
#define mtgy_mtgy_op_ts78_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts78: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts79  ====================================================== */
#define mtgy_mtgy_op_ts79_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts79: val (Bit 0)                        */
#define mtgy_mtgy_op_ts79_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts79: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts80  ====================================================== */
#define mtgy_mtgy_op_ts80_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts80: val (Bit 0)                        */
#define mtgy_mtgy_op_ts80_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts80: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts81  ====================================================== */
#define mtgy_mtgy_op_ts81_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts81: val (Bit 0)                        */
#define mtgy_mtgy_op_ts81_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts81: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts82  ====================================================== */
#define mtgy_mtgy_op_ts82_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts82: val (Bit 0)                        */
#define mtgy_mtgy_op_ts82_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts82: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts83  ====================================================== */
#define mtgy_mtgy_op_ts83_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts83: val (Bit 0)                        */
#define mtgy_mtgy_op_ts83_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts83: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts84  ====================================================== */
#define mtgy_mtgy_op_ts84_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts84: val (Bit 0)                        */
#define mtgy_mtgy_op_ts84_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts84: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts85  ====================================================== */
#define mtgy_mtgy_op_ts85_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts85: val (Bit 0)                        */
#define mtgy_mtgy_op_ts85_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts85: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts86  ====================================================== */
#define mtgy_mtgy_op_ts86_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts86: val (Bit 0)                        */
#define mtgy_mtgy_op_ts86_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts86: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts87  ====================================================== */
#define mtgy_mtgy_op_ts87_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts87: val (Bit 0)                        */
#define mtgy_mtgy_op_ts87_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts87: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts88  ====================================================== */
#define mtgy_mtgy_op_ts88_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts88: val (Bit 0)                        */
#define mtgy_mtgy_op_ts88_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts88: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts89  ====================================================== */
#define mtgy_mtgy_op_ts89_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts89: val (Bit 0)                        */
#define mtgy_mtgy_op_ts89_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts89: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts90  ====================================================== */
#define mtgy_mtgy_op_ts90_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts90: val (Bit 0)                        */
#define mtgy_mtgy_op_ts90_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts90: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts91  ====================================================== */
#define mtgy_mtgy_op_ts91_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts91: val (Bit 0)                        */
#define mtgy_mtgy_op_ts91_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts91: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts92  ====================================================== */
#define mtgy_mtgy_op_ts92_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts92: val (Bit 0)                        */
#define mtgy_mtgy_op_ts92_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts92: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts93  ====================================================== */
#define mtgy_mtgy_op_ts93_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts93: val (Bit 0)                        */
#define mtgy_mtgy_op_ts93_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts93: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts94  ====================================================== */
#define mtgy_mtgy_op_ts94_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts94: val (Bit 0)                        */
#define mtgy_mtgy_op_ts94_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts94: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts95  ====================================================== */
#define mtgy_mtgy_op_ts95_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts95: val (Bit 0)                        */
#define mtgy_mtgy_op_ts95_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts95: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts96  ====================================================== */
#define mtgy_mtgy_op_ts96_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts96: val (Bit 0)                        */
#define mtgy_mtgy_op_ts96_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts96: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts97  ====================================================== */
#define mtgy_mtgy_op_ts97_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts97: val (Bit 0)                        */
#define mtgy_mtgy_op_ts97_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts97: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts98  ====================================================== */
#define mtgy_mtgy_op_ts98_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts98: val (Bit 0)                        */
#define mtgy_mtgy_op_ts98_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts98: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts99  ====================================================== */
#define mtgy_mtgy_op_ts99_val_Pos         (0UL)                     /*!< mtgy mtgy_op_ts99: val (Bit 0)                        */
#define mtgy_mtgy_op_ts99_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_ts99: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_ts100  ===================================================== */
#define mtgy_mtgy_op_ts100_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts100: val (Bit 0)                       */
#define mtgy_mtgy_op_ts100_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts100: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts101  ===================================================== */
#define mtgy_mtgy_op_ts101_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts101: val (Bit 0)                       */
#define mtgy_mtgy_op_ts101_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts101: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts102  ===================================================== */
#define mtgy_mtgy_op_ts102_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts102: val (Bit 0)                       */
#define mtgy_mtgy_op_ts102_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts102: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts103  ===================================================== */
#define mtgy_mtgy_op_ts103_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts103: val (Bit 0)                       */
#define mtgy_mtgy_op_ts103_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts103: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts104  ===================================================== */
#define mtgy_mtgy_op_ts104_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts104: val (Bit 0)                       */
#define mtgy_mtgy_op_ts104_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts104: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts105  ===================================================== */
#define mtgy_mtgy_op_ts105_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts105: val (Bit 0)                       */
#define mtgy_mtgy_op_ts105_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts105: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts106  ===================================================== */
#define mtgy_mtgy_op_ts106_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts106: val (Bit 0)                       */
#define mtgy_mtgy_op_ts106_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts106: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts107  ===================================================== */
#define mtgy_mtgy_op_ts107_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts107: val (Bit 0)                       */
#define mtgy_mtgy_op_ts107_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts107: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts108  ===================================================== */
#define mtgy_mtgy_op_ts108_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts108: val (Bit 0)                       */
#define mtgy_mtgy_op_ts108_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts108: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts109  ===================================================== */
#define mtgy_mtgy_op_ts109_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts109: val (Bit 0)                       */
#define mtgy_mtgy_op_ts109_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts109: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts110  ===================================================== */
#define mtgy_mtgy_op_ts110_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts110: val (Bit 0)                       */
#define mtgy_mtgy_op_ts110_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts110: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts111  ===================================================== */
#define mtgy_mtgy_op_ts111_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts111: val (Bit 0)                       */
#define mtgy_mtgy_op_ts111_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts111: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts112  ===================================================== */
#define mtgy_mtgy_op_ts112_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts112: val (Bit 0)                       */
#define mtgy_mtgy_op_ts112_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts112: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts113  ===================================================== */
#define mtgy_mtgy_op_ts113_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts113: val (Bit 0)                       */
#define mtgy_mtgy_op_ts113_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts113: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts114  ===================================================== */
#define mtgy_mtgy_op_ts114_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts114: val (Bit 0)                       */
#define mtgy_mtgy_op_ts114_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts114: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts115  ===================================================== */
#define mtgy_mtgy_op_ts115_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts115: val (Bit 0)                       */
#define mtgy_mtgy_op_ts115_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts115: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts116  ===================================================== */
#define mtgy_mtgy_op_ts116_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts116: val (Bit 0)                       */
#define mtgy_mtgy_op_ts116_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts116: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts117  ===================================================== */
#define mtgy_mtgy_op_ts117_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts117: val (Bit 0)                       */
#define mtgy_mtgy_op_ts117_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts117: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts118  ===================================================== */
#define mtgy_mtgy_op_ts118_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts118: val (Bit 0)                       */
#define mtgy_mtgy_op_ts118_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts118: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts119  ===================================================== */
#define mtgy_mtgy_op_ts119_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts119: val (Bit 0)                       */
#define mtgy_mtgy_op_ts119_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts119: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts120  ===================================================== */
#define mtgy_mtgy_op_ts120_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts120: val (Bit 0)                       */
#define mtgy_mtgy_op_ts120_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts120: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts121  ===================================================== */
#define mtgy_mtgy_op_ts121_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts121: val (Bit 0)                       */
#define mtgy_mtgy_op_ts121_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts121: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts122  ===================================================== */
#define mtgy_mtgy_op_ts122_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts122: val (Bit 0)                       */
#define mtgy_mtgy_op_ts122_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts122: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts123  ===================================================== */
#define mtgy_mtgy_op_ts123_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts123: val (Bit 0)                       */
#define mtgy_mtgy_op_ts123_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts123: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts124  ===================================================== */
#define mtgy_mtgy_op_ts124_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts124: val (Bit 0)                       */
#define mtgy_mtgy_op_ts124_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts124: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts125  ===================================================== */
#define mtgy_mtgy_op_ts125_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts125: val (Bit 0)                       */
#define mtgy_mtgy_op_ts125_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts125: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts126  ===================================================== */
#define mtgy_mtgy_op_ts126_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts126: val (Bit 0)                       */
#define mtgy_mtgy_op_ts126_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts126: val (Bitfield-Mask: 0xffffffff)   */
/* =====================================================  mtgy_op_ts127  ===================================================== */
#define mtgy_mtgy_op_ts127_val_Pos        (0UL)                     /*!< mtgy mtgy_op_ts127: val (Bit 0)                       */
#define mtgy_mtgy_op_ts127_val_Msk        (0xffffffffUL)            /*!< mtgy mtgy_op_ts127: val (Bitfield-Mask: 0xffffffff)   */
/* ======================================================  mtgy_op_p0  ======================================================= */
#define mtgy_mtgy_op_p0_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p0: val (Bit 0)                          */
#define mtgy_mtgy_op_p0_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p0: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p1  ======================================================= */
#define mtgy_mtgy_op_p1_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p1: val (Bit 0)                          */
#define mtgy_mtgy_op_p1_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p1: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p2  ======================================================= */
#define mtgy_mtgy_op_p2_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p2: val (Bit 0)                          */
#define mtgy_mtgy_op_p2_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p2: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p3  ======================================================= */
#define mtgy_mtgy_op_p3_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p3: val (Bit 0)                          */
#define mtgy_mtgy_op_p3_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p3: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p4  ======================================================= */
#define mtgy_mtgy_op_p4_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p4: val (Bit 0)                          */
#define mtgy_mtgy_op_p4_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p4: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p5  ======================================================= */
#define mtgy_mtgy_op_p5_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p5: val (Bit 0)                          */
#define mtgy_mtgy_op_p5_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p5: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p6  ======================================================= */
#define mtgy_mtgy_op_p6_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p6: val (Bit 0)                          */
#define mtgy_mtgy_op_p6_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p6: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p7  ======================================================= */
#define mtgy_mtgy_op_p7_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p7: val (Bit 0)                          */
#define mtgy_mtgy_op_p7_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p7: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p8  ======================================================= */
#define mtgy_mtgy_op_p8_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p8: val (Bit 0)                          */
#define mtgy_mtgy_op_p8_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p8: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p9  ======================================================= */
#define mtgy_mtgy_op_p9_val_Pos           (0UL)                     /*!< mtgy mtgy_op_p9: val (Bit 0)                          */
#define mtgy_mtgy_op_p9_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_p9: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_p10  ====================================================== */
#define mtgy_mtgy_op_p10_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p10: val (Bit 0)                         */
#define mtgy_mtgy_op_p10_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p10: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p11  ====================================================== */
#define mtgy_mtgy_op_p11_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p11: val (Bit 0)                         */
#define mtgy_mtgy_op_p11_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p11: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p12  ====================================================== */
#define mtgy_mtgy_op_p12_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p12: val (Bit 0)                         */
#define mtgy_mtgy_op_p12_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p12: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p13  ====================================================== */
#define mtgy_mtgy_op_p13_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p13: val (Bit 0)                         */
#define mtgy_mtgy_op_p13_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p13: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p14  ====================================================== */
#define mtgy_mtgy_op_p14_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p14: val (Bit 0)                         */
#define mtgy_mtgy_op_p14_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p14: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p15  ====================================================== */
#define mtgy_mtgy_op_p15_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p15: val (Bit 0)                         */
#define mtgy_mtgy_op_p15_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p15: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p16  ====================================================== */
#define mtgy_mtgy_op_p16_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p16: val (Bit 0)                         */
#define mtgy_mtgy_op_p16_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p16: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p17  ====================================================== */
#define mtgy_mtgy_op_p17_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p17: val (Bit 0)                         */
#define mtgy_mtgy_op_p17_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p17: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p18  ====================================================== */
#define mtgy_mtgy_op_p18_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p18: val (Bit 0)                         */
#define mtgy_mtgy_op_p18_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p18: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p19  ====================================================== */
#define mtgy_mtgy_op_p19_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p19: val (Bit 0)                         */
#define mtgy_mtgy_op_p19_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p19: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p20  ====================================================== */
#define mtgy_mtgy_op_p20_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p20: val (Bit 0)                         */
#define mtgy_mtgy_op_p20_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p20: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p21  ====================================================== */
#define mtgy_mtgy_op_p21_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p21: val (Bit 0)                         */
#define mtgy_mtgy_op_p21_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p21: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p22  ====================================================== */
#define mtgy_mtgy_op_p22_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p22: val (Bit 0)                         */
#define mtgy_mtgy_op_p22_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p22: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p23  ====================================================== */
#define mtgy_mtgy_op_p23_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p23: val (Bit 0)                         */
#define mtgy_mtgy_op_p23_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p23: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p24  ====================================================== */
#define mtgy_mtgy_op_p24_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p24: val (Bit 0)                         */
#define mtgy_mtgy_op_p24_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p24: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p25  ====================================================== */
#define mtgy_mtgy_op_p25_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p25: val (Bit 0)                         */
#define mtgy_mtgy_op_p25_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p25: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p26  ====================================================== */
#define mtgy_mtgy_op_p26_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p26: val (Bit 0)                         */
#define mtgy_mtgy_op_p26_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p26: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p27  ====================================================== */
#define mtgy_mtgy_op_p27_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p27: val (Bit 0)                         */
#define mtgy_mtgy_op_p27_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p27: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p28  ====================================================== */
#define mtgy_mtgy_op_p28_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p28: val (Bit 0)                         */
#define mtgy_mtgy_op_p28_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p28: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p29  ====================================================== */
#define mtgy_mtgy_op_p29_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p29: val (Bit 0)                         */
#define mtgy_mtgy_op_p29_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p29: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p30  ====================================================== */
#define mtgy_mtgy_op_p30_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p30: val (Bit 0)                         */
#define mtgy_mtgy_op_p30_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p30: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p31  ====================================================== */
#define mtgy_mtgy_op_p31_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p31: val (Bit 0)                         */
#define mtgy_mtgy_op_p31_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p31: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p32  ====================================================== */
#define mtgy_mtgy_op_p32_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p32: val (Bit 0)                         */
#define mtgy_mtgy_op_p32_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p32: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p33  ====================================================== */
#define mtgy_mtgy_op_p33_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p33: val (Bit 0)                         */
#define mtgy_mtgy_op_p33_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p33: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p34  ====================================================== */
#define mtgy_mtgy_op_p34_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p34: val (Bit 0)                         */
#define mtgy_mtgy_op_p34_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p34: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p35  ====================================================== */
#define mtgy_mtgy_op_p35_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p35: val (Bit 0)                         */
#define mtgy_mtgy_op_p35_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p35: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p36  ====================================================== */
#define mtgy_mtgy_op_p36_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p36: val (Bit 0)                         */
#define mtgy_mtgy_op_p36_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p36: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p37  ====================================================== */
#define mtgy_mtgy_op_p37_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p37: val (Bit 0)                         */
#define mtgy_mtgy_op_p37_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p37: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p38  ====================================================== */
#define mtgy_mtgy_op_p38_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p38: val (Bit 0)                         */
#define mtgy_mtgy_op_p38_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p38: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p39  ====================================================== */
#define mtgy_mtgy_op_p39_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p39: val (Bit 0)                         */
#define mtgy_mtgy_op_p39_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p39: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p40  ====================================================== */
#define mtgy_mtgy_op_p40_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p40: val (Bit 0)                         */
#define mtgy_mtgy_op_p40_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p40: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p41  ====================================================== */
#define mtgy_mtgy_op_p41_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p41: val (Bit 0)                         */
#define mtgy_mtgy_op_p41_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p41: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p42  ====================================================== */
#define mtgy_mtgy_op_p42_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p42: val (Bit 0)                         */
#define mtgy_mtgy_op_p42_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p42: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p43  ====================================================== */
#define mtgy_mtgy_op_p43_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p43: val (Bit 0)                         */
#define mtgy_mtgy_op_p43_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p43: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p44  ====================================================== */
#define mtgy_mtgy_op_p44_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p44: val (Bit 0)                         */
#define mtgy_mtgy_op_p44_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p44: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p45  ====================================================== */
#define mtgy_mtgy_op_p45_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p45: val (Bit 0)                         */
#define mtgy_mtgy_op_p45_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p45: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p46  ====================================================== */
#define mtgy_mtgy_op_p46_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p46: val (Bit 0)                         */
#define mtgy_mtgy_op_p46_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p46: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p47  ====================================================== */
#define mtgy_mtgy_op_p47_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p47: val (Bit 0)                         */
#define mtgy_mtgy_op_p47_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p47: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p48  ====================================================== */
#define mtgy_mtgy_op_p48_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p48: val (Bit 0)                         */
#define mtgy_mtgy_op_p48_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p48: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p49  ====================================================== */
#define mtgy_mtgy_op_p49_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p49: val (Bit 0)                         */
#define mtgy_mtgy_op_p49_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p49: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p50  ====================================================== */
#define mtgy_mtgy_op_p50_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p50: val (Bit 0)                         */
#define mtgy_mtgy_op_p50_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p50: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p51  ====================================================== */
#define mtgy_mtgy_op_p51_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p51: val (Bit 0)                         */
#define mtgy_mtgy_op_p51_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p51: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p52  ====================================================== */
#define mtgy_mtgy_op_p52_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p52: val (Bit 0)                         */
#define mtgy_mtgy_op_p52_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p52: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p53  ====================================================== */
#define mtgy_mtgy_op_p53_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p53: val (Bit 0)                         */
#define mtgy_mtgy_op_p53_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p53: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p54  ====================================================== */
#define mtgy_mtgy_op_p54_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p54: val (Bit 0)                         */
#define mtgy_mtgy_op_p54_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p54: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p55  ====================================================== */
#define mtgy_mtgy_op_p55_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p55: val (Bit 0)                         */
#define mtgy_mtgy_op_p55_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p55: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p56  ====================================================== */
#define mtgy_mtgy_op_p56_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p56: val (Bit 0)                         */
#define mtgy_mtgy_op_p56_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p56: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p57  ====================================================== */
#define mtgy_mtgy_op_p57_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p57: val (Bit 0)                         */
#define mtgy_mtgy_op_p57_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p57: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p58  ====================================================== */
#define mtgy_mtgy_op_p58_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p58: val (Bit 0)                         */
#define mtgy_mtgy_op_p58_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p58: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p59  ====================================================== */
#define mtgy_mtgy_op_p59_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p59: val (Bit 0)                         */
#define mtgy_mtgy_op_p59_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p59: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p60  ====================================================== */
#define mtgy_mtgy_op_p60_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p60: val (Bit 0)                         */
#define mtgy_mtgy_op_p60_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p60: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p61  ====================================================== */
#define mtgy_mtgy_op_p61_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p61: val (Bit 0)                         */
#define mtgy_mtgy_op_p61_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p61: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p62  ====================================================== */
#define mtgy_mtgy_op_p62_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p62: val (Bit 0)                         */
#define mtgy_mtgy_op_p62_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p62: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p63  ====================================================== */
#define mtgy_mtgy_op_p63_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p63: val (Bit 0)                         */
#define mtgy_mtgy_op_p63_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p63: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p64  ====================================================== */
#define mtgy_mtgy_op_p64_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p64: val (Bit 0)                         */
#define mtgy_mtgy_op_p64_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p64: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p65  ====================================================== */
#define mtgy_mtgy_op_p65_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p65: val (Bit 0)                         */
#define mtgy_mtgy_op_p65_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p65: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p66  ====================================================== */
#define mtgy_mtgy_op_p66_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p66: val (Bit 0)                         */
#define mtgy_mtgy_op_p66_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p66: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p67  ====================================================== */
#define mtgy_mtgy_op_p67_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p67: val (Bit 0)                         */
#define mtgy_mtgy_op_p67_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p67: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p68  ====================================================== */
#define mtgy_mtgy_op_p68_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p68: val (Bit 0)                         */
#define mtgy_mtgy_op_p68_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p68: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p69  ====================================================== */
#define mtgy_mtgy_op_p69_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p69: val (Bit 0)                         */
#define mtgy_mtgy_op_p69_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p69: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p70  ====================================================== */
#define mtgy_mtgy_op_p70_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p70: val (Bit 0)                         */
#define mtgy_mtgy_op_p70_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p70: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p71  ====================================================== */
#define mtgy_mtgy_op_p71_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p71: val (Bit 0)                         */
#define mtgy_mtgy_op_p71_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p71: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p72  ====================================================== */
#define mtgy_mtgy_op_p72_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p72: val (Bit 0)                         */
#define mtgy_mtgy_op_p72_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p72: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p73  ====================================================== */
#define mtgy_mtgy_op_p73_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p73: val (Bit 0)                         */
#define mtgy_mtgy_op_p73_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p73: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p74  ====================================================== */
#define mtgy_mtgy_op_p74_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p74: val (Bit 0)                         */
#define mtgy_mtgy_op_p74_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p74: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p75  ====================================================== */
#define mtgy_mtgy_op_p75_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p75: val (Bit 0)                         */
#define mtgy_mtgy_op_p75_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p75: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p76  ====================================================== */
#define mtgy_mtgy_op_p76_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p76: val (Bit 0)                         */
#define mtgy_mtgy_op_p76_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p76: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p77  ====================================================== */
#define mtgy_mtgy_op_p77_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p77: val (Bit 0)                         */
#define mtgy_mtgy_op_p77_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p77: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p78  ====================================================== */
#define mtgy_mtgy_op_p78_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p78: val (Bit 0)                         */
#define mtgy_mtgy_op_p78_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p78: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p79  ====================================================== */
#define mtgy_mtgy_op_p79_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p79: val (Bit 0)                         */
#define mtgy_mtgy_op_p79_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p79: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p80  ====================================================== */
#define mtgy_mtgy_op_p80_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p80: val (Bit 0)                         */
#define mtgy_mtgy_op_p80_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p80: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p81  ====================================================== */
#define mtgy_mtgy_op_p81_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p81: val (Bit 0)                         */
#define mtgy_mtgy_op_p81_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p81: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p82  ====================================================== */
#define mtgy_mtgy_op_p82_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p82: val (Bit 0)                         */
#define mtgy_mtgy_op_p82_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p82: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p83  ====================================================== */
#define mtgy_mtgy_op_p83_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p83: val (Bit 0)                         */
#define mtgy_mtgy_op_p83_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p83: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p84  ====================================================== */
#define mtgy_mtgy_op_p84_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p84: val (Bit 0)                         */
#define mtgy_mtgy_op_p84_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p84: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p85  ====================================================== */
#define mtgy_mtgy_op_p85_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p85: val (Bit 0)                         */
#define mtgy_mtgy_op_p85_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p85: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p86  ====================================================== */
#define mtgy_mtgy_op_p86_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p86: val (Bit 0)                         */
#define mtgy_mtgy_op_p86_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p86: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p87  ====================================================== */
#define mtgy_mtgy_op_p87_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p87: val (Bit 0)                         */
#define mtgy_mtgy_op_p87_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p87: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p88  ====================================================== */
#define mtgy_mtgy_op_p88_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p88: val (Bit 0)                         */
#define mtgy_mtgy_op_p88_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p88: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p89  ====================================================== */
#define mtgy_mtgy_op_p89_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p89: val (Bit 0)                         */
#define mtgy_mtgy_op_p89_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p89: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p90  ====================================================== */
#define mtgy_mtgy_op_p90_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p90: val (Bit 0)                         */
#define mtgy_mtgy_op_p90_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p90: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p91  ====================================================== */
#define mtgy_mtgy_op_p91_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p91: val (Bit 0)                         */
#define mtgy_mtgy_op_p91_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p91: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p92  ====================================================== */
#define mtgy_mtgy_op_p92_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p92: val (Bit 0)                         */
#define mtgy_mtgy_op_p92_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p92: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p93  ====================================================== */
#define mtgy_mtgy_op_p93_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p93: val (Bit 0)                         */
#define mtgy_mtgy_op_p93_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p93: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p94  ====================================================== */
#define mtgy_mtgy_op_p94_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p94: val (Bit 0)                         */
#define mtgy_mtgy_op_p94_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p94: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p95  ====================================================== */
#define mtgy_mtgy_op_p95_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p95: val (Bit 0)                         */
#define mtgy_mtgy_op_p95_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p95: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p96  ====================================================== */
#define mtgy_mtgy_op_p96_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p96: val (Bit 0)                         */
#define mtgy_mtgy_op_p96_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p96: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p97  ====================================================== */
#define mtgy_mtgy_op_p97_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p97: val (Bit 0)                         */
#define mtgy_mtgy_op_p97_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p97: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p98  ====================================================== */
#define mtgy_mtgy_op_p98_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p98: val (Bit 0)                         */
#define mtgy_mtgy_op_p98_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p98: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_p99  ====================================================== */
#define mtgy_mtgy_op_p99_val_Pos          (0UL)                     /*!< mtgy mtgy_op_p99: val (Bit 0)                         */
#define mtgy_mtgy_op_p99_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_p99: val (Bitfield-Mask: 0xffffffff)     */
/* =====================================================  mtgy_op_p100  ====================================================== */
#define mtgy_mtgy_op_p100_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p100: val (Bit 0)                        */
#define mtgy_mtgy_op_p100_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p100: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p101  ====================================================== */
#define mtgy_mtgy_op_p101_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p101: val (Bit 0)                        */
#define mtgy_mtgy_op_p101_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p101: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p102  ====================================================== */
#define mtgy_mtgy_op_p102_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p102: val (Bit 0)                        */
#define mtgy_mtgy_op_p102_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p102: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p103  ====================================================== */
#define mtgy_mtgy_op_p103_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p103: val (Bit 0)                        */
#define mtgy_mtgy_op_p103_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p103: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p104  ====================================================== */
#define mtgy_mtgy_op_p104_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p104: val (Bit 0)                        */
#define mtgy_mtgy_op_p104_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p104: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p105  ====================================================== */
#define mtgy_mtgy_op_p105_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p105: val (Bit 0)                        */
#define mtgy_mtgy_op_p105_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p105: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p106  ====================================================== */
#define mtgy_mtgy_op_p106_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p106: val (Bit 0)                        */
#define mtgy_mtgy_op_p106_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p106: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p107  ====================================================== */
#define mtgy_mtgy_op_p107_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p107: val (Bit 0)                        */
#define mtgy_mtgy_op_p107_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p107: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p108  ====================================================== */
#define mtgy_mtgy_op_p108_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p108: val (Bit 0)                        */
#define mtgy_mtgy_op_p108_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p108: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p109  ====================================================== */
#define mtgy_mtgy_op_p109_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p109: val (Bit 0)                        */
#define mtgy_mtgy_op_p109_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p109: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p110  ====================================================== */
#define mtgy_mtgy_op_p110_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p110: val (Bit 0)                        */
#define mtgy_mtgy_op_p110_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p110: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p111  ====================================================== */
#define mtgy_mtgy_op_p111_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p111: val (Bit 0)                        */
#define mtgy_mtgy_op_p111_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p111: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p112  ====================================================== */
#define mtgy_mtgy_op_p112_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p112: val (Bit 0)                        */
#define mtgy_mtgy_op_p112_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p112: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p113  ====================================================== */
#define mtgy_mtgy_op_p113_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p113: val (Bit 0)                        */
#define mtgy_mtgy_op_p113_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p113: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p114  ====================================================== */
#define mtgy_mtgy_op_p114_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p114: val (Bit 0)                        */
#define mtgy_mtgy_op_p114_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p114: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p115  ====================================================== */
#define mtgy_mtgy_op_p115_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p115: val (Bit 0)                        */
#define mtgy_mtgy_op_p115_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p115: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p116  ====================================================== */
#define mtgy_mtgy_op_p116_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p116: val (Bit 0)                        */
#define mtgy_mtgy_op_p116_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p116: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p117  ====================================================== */
#define mtgy_mtgy_op_p117_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p117: val (Bit 0)                        */
#define mtgy_mtgy_op_p117_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p117: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p118  ====================================================== */
#define mtgy_mtgy_op_p118_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p118: val (Bit 0)                        */
#define mtgy_mtgy_op_p118_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p118: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p119  ====================================================== */
#define mtgy_mtgy_op_p119_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p119: val (Bit 0)                        */
#define mtgy_mtgy_op_p119_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p119: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p120  ====================================================== */
#define mtgy_mtgy_op_p120_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p120: val (Bit 0)                        */
#define mtgy_mtgy_op_p120_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p120: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p121  ====================================================== */
#define mtgy_mtgy_op_p121_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p121: val (Bit 0)                        */
#define mtgy_mtgy_op_p121_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p121: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p122  ====================================================== */
#define mtgy_mtgy_op_p122_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p122: val (Bit 0)                        */
#define mtgy_mtgy_op_p122_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p122: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p123  ====================================================== */
#define mtgy_mtgy_op_p123_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p123: val (Bit 0)                        */
#define mtgy_mtgy_op_p123_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p123: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p124  ====================================================== */
#define mtgy_mtgy_op_p124_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p124: val (Bit 0)                        */
#define mtgy_mtgy_op_p124_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p124: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p125  ====================================================== */
#define mtgy_mtgy_op_p125_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p125: val (Bit 0)                        */
#define mtgy_mtgy_op_p125_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p125: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p126  ====================================================== */
#define mtgy_mtgy_op_p126_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p126: val (Bit 0)                        */
#define mtgy_mtgy_op_p126_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p126: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_p127  ====================================================== */
#define mtgy_mtgy_op_p127_val_Pos         (0UL)                     /*!< mtgy mtgy_op_p127: val (Bit 0)                        */
#define mtgy_mtgy_op_p127_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_p127: val (Bitfield-Mask: 0xffffffff)    */
/* ======================================================  mtgy_op_b0  ======================================================= */
#define mtgy_mtgy_op_b0_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b0: val (Bit 0)                          */
#define mtgy_mtgy_op_b0_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b0: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b1  ======================================================= */
#define mtgy_mtgy_op_b1_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b1: val (Bit 0)                          */
#define mtgy_mtgy_op_b1_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b1: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b2  ======================================================= */
#define mtgy_mtgy_op_b2_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b2: val (Bit 0)                          */
#define mtgy_mtgy_op_b2_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b2: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b3  ======================================================= */
#define mtgy_mtgy_op_b3_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b3: val (Bit 0)                          */
#define mtgy_mtgy_op_b3_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b3: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b4  ======================================================= */
#define mtgy_mtgy_op_b4_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b4: val (Bit 0)                          */
#define mtgy_mtgy_op_b4_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b4: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b5  ======================================================= */
#define mtgy_mtgy_op_b5_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b5: val (Bit 0)                          */
#define mtgy_mtgy_op_b5_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b5: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b6  ======================================================= */
#define mtgy_mtgy_op_b6_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b6: val (Bit 0)                          */
#define mtgy_mtgy_op_b6_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b6: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b7  ======================================================= */
#define mtgy_mtgy_op_b7_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b7: val (Bit 0)                          */
#define mtgy_mtgy_op_b7_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b7: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b8  ======================================================= */
#define mtgy_mtgy_op_b8_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b8: val (Bit 0)                          */
#define mtgy_mtgy_op_b8_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b8: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b9  ======================================================= */
#define mtgy_mtgy_op_b9_val_Pos           (0UL)                     /*!< mtgy mtgy_op_b9: val (Bit 0)                          */
#define mtgy_mtgy_op_b9_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_b9: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_b10  ====================================================== */
#define mtgy_mtgy_op_b10_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b10: val (Bit 0)                         */
#define mtgy_mtgy_op_b10_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b10: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b11  ====================================================== */
#define mtgy_mtgy_op_b11_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b11: val (Bit 0)                         */
#define mtgy_mtgy_op_b11_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b11: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b12  ====================================================== */
#define mtgy_mtgy_op_b12_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b12: val (Bit 0)                         */
#define mtgy_mtgy_op_b12_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b12: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b13  ====================================================== */
#define mtgy_mtgy_op_b13_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b13: val (Bit 0)                         */
#define mtgy_mtgy_op_b13_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b13: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b14  ====================================================== */
#define mtgy_mtgy_op_b14_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b14: val (Bit 0)                         */
#define mtgy_mtgy_op_b14_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b14: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b15  ====================================================== */
#define mtgy_mtgy_op_b15_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b15: val (Bit 0)                         */
#define mtgy_mtgy_op_b15_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b15: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b16  ====================================================== */
#define mtgy_mtgy_op_b16_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b16: val (Bit 0)                         */
#define mtgy_mtgy_op_b16_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b16: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b17  ====================================================== */
#define mtgy_mtgy_op_b17_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b17: val (Bit 0)                         */
#define mtgy_mtgy_op_b17_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b17: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b18  ====================================================== */
#define mtgy_mtgy_op_b18_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b18: val (Bit 0)                         */
#define mtgy_mtgy_op_b18_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b18: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b19  ====================================================== */
#define mtgy_mtgy_op_b19_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b19: val (Bit 0)                         */
#define mtgy_mtgy_op_b19_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b19: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b20  ====================================================== */
#define mtgy_mtgy_op_b20_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b20: val (Bit 0)                         */
#define mtgy_mtgy_op_b20_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b20: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b21  ====================================================== */
#define mtgy_mtgy_op_b21_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b21: val (Bit 0)                         */
#define mtgy_mtgy_op_b21_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b21: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b22  ====================================================== */
#define mtgy_mtgy_op_b22_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b22: val (Bit 0)                         */
#define mtgy_mtgy_op_b22_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b22: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b23  ====================================================== */
#define mtgy_mtgy_op_b23_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b23: val (Bit 0)                         */
#define mtgy_mtgy_op_b23_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b23: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b24  ====================================================== */
#define mtgy_mtgy_op_b24_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b24: val (Bit 0)                         */
#define mtgy_mtgy_op_b24_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b24: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b25  ====================================================== */
#define mtgy_mtgy_op_b25_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b25: val (Bit 0)                         */
#define mtgy_mtgy_op_b25_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b25: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b26  ====================================================== */
#define mtgy_mtgy_op_b26_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b26: val (Bit 0)                         */
#define mtgy_mtgy_op_b26_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b26: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b27  ====================================================== */
#define mtgy_mtgy_op_b27_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b27: val (Bit 0)                         */
#define mtgy_mtgy_op_b27_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b27: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b28  ====================================================== */
#define mtgy_mtgy_op_b28_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b28: val (Bit 0)                         */
#define mtgy_mtgy_op_b28_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b28: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b29  ====================================================== */
#define mtgy_mtgy_op_b29_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b29: val (Bit 0)                         */
#define mtgy_mtgy_op_b29_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b29: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b30  ====================================================== */
#define mtgy_mtgy_op_b30_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b30: val (Bit 0)                         */
#define mtgy_mtgy_op_b30_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b30: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b31  ====================================================== */
#define mtgy_mtgy_op_b31_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b31: val (Bit 0)                         */
#define mtgy_mtgy_op_b31_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b31: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b32  ====================================================== */
#define mtgy_mtgy_op_b32_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b32: val (Bit 0)                         */
#define mtgy_mtgy_op_b32_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b32: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b33  ====================================================== */
#define mtgy_mtgy_op_b33_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b33: val (Bit 0)                         */
#define mtgy_mtgy_op_b33_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b33: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b34  ====================================================== */
#define mtgy_mtgy_op_b34_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b34: val (Bit 0)                         */
#define mtgy_mtgy_op_b34_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b34: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b35  ====================================================== */
#define mtgy_mtgy_op_b35_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b35: val (Bit 0)                         */
#define mtgy_mtgy_op_b35_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b35: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b36  ====================================================== */
#define mtgy_mtgy_op_b36_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b36: val (Bit 0)                         */
#define mtgy_mtgy_op_b36_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b36: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b37  ====================================================== */
#define mtgy_mtgy_op_b37_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b37: val (Bit 0)                         */
#define mtgy_mtgy_op_b37_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b37: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b38  ====================================================== */
#define mtgy_mtgy_op_b38_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b38: val (Bit 0)                         */
#define mtgy_mtgy_op_b38_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b38: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b39  ====================================================== */
#define mtgy_mtgy_op_b39_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b39: val (Bit 0)                         */
#define mtgy_mtgy_op_b39_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b39: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b40  ====================================================== */
#define mtgy_mtgy_op_b40_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b40: val (Bit 0)                         */
#define mtgy_mtgy_op_b40_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b40: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b41  ====================================================== */
#define mtgy_mtgy_op_b41_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b41: val (Bit 0)                         */
#define mtgy_mtgy_op_b41_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b41: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b42  ====================================================== */
#define mtgy_mtgy_op_b42_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b42: val (Bit 0)                         */
#define mtgy_mtgy_op_b42_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b42: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b43  ====================================================== */
#define mtgy_mtgy_op_b43_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b43: val (Bit 0)                         */
#define mtgy_mtgy_op_b43_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b43: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b44  ====================================================== */
#define mtgy_mtgy_op_b44_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b44: val (Bit 0)                         */
#define mtgy_mtgy_op_b44_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b44: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b45  ====================================================== */
#define mtgy_mtgy_op_b45_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b45: val (Bit 0)                         */
#define mtgy_mtgy_op_b45_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b45: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b46  ====================================================== */
#define mtgy_mtgy_op_b46_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b46: val (Bit 0)                         */
#define mtgy_mtgy_op_b46_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b46: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b47  ====================================================== */
#define mtgy_mtgy_op_b47_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b47: val (Bit 0)                         */
#define mtgy_mtgy_op_b47_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b47: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b48  ====================================================== */
#define mtgy_mtgy_op_b48_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b48: val (Bit 0)                         */
#define mtgy_mtgy_op_b48_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b48: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b49  ====================================================== */
#define mtgy_mtgy_op_b49_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b49: val (Bit 0)                         */
#define mtgy_mtgy_op_b49_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b49: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b50  ====================================================== */
#define mtgy_mtgy_op_b50_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b50: val (Bit 0)                         */
#define mtgy_mtgy_op_b50_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b50: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b51  ====================================================== */
#define mtgy_mtgy_op_b51_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b51: val (Bit 0)                         */
#define mtgy_mtgy_op_b51_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b51: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b52  ====================================================== */
#define mtgy_mtgy_op_b52_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b52: val (Bit 0)                         */
#define mtgy_mtgy_op_b52_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b52: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b53  ====================================================== */
#define mtgy_mtgy_op_b53_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b53: val (Bit 0)                         */
#define mtgy_mtgy_op_b53_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b53: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b54  ====================================================== */
#define mtgy_mtgy_op_b54_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b54: val (Bit 0)                         */
#define mtgy_mtgy_op_b54_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b54: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b55  ====================================================== */
#define mtgy_mtgy_op_b55_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b55: val (Bit 0)                         */
#define mtgy_mtgy_op_b55_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b55: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b56  ====================================================== */
#define mtgy_mtgy_op_b56_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b56: val (Bit 0)                         */
#define mtgy_mtgy_op_b56_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b56: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b57  ====================================================== */
#define mtgy_mtgy_op_b57_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b57: val (Bit 0)                         */
#define mtgy_mtgy_op_b57_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b57: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b58  ====================================================== */
#define mtgy_mtgy_op_b58_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b58: val (Bit 0)                         */
#define mtgy_mtgy_op_b58_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b58: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b59  ====================================================== */
#define mtgy_mtgy_op_b59_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b59: val (Bit 0)                         */
#define mtgy_mtgy_op_b59_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b59: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b60  ====================================================== */
#define mtgy_mtgy_op_b60_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b60: val (Bit 0)                         */
#define mtgy_mtgy_op_b60_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b60: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b61  ====================================================== */
#define mtgy_mtgy_op_b61_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b61: val (Bit 0)                         */
#define mtgy_mtgy_op_b61_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b61: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b62  ====================================================== */
#define mtgy_mtgy_op_b62_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b62: val (Bit 0)                         */
#define mtgy_mtgy_op_b62_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b62: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b63  ====================================================== */
#define mtgy_mtgy_op_b63_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b63: val (Bit 0)                         */
#define mtgy_mtgy_op_b63_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b63: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b64  ====================================================== */
#define mtgy_mtgy_op_b64_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b64: val (Bit 0)                         */
#define mtgy_mtgy_op_b64_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b64: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b65  ====================================================== */
#define mtgy_mtgy_op_b65_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b65: val (Bit 0)                         */
#define mtgy_mtgy_op_b65_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b65: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b66  ====================================================== */
#define mtgy_mtgy_op_b66_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b66: val (Bit 0)                         */
#define mtgy_mtgy_op_b66_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b66: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b67  ====================================================== */
#define mtgy_mtgy_op_b67_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b67: val (Bit 0)                         */
#define mtgy_mtgy_op_b67_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b67: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b68  ====================================================== */
#define mtgy_mtgy_op_b68_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b68: val (Bit 0)                         */
#define mtgy_mtgy_op_b68_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b68: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b69  ====================================================== */
#define mtgy_mtgy_op_b69_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b69: val (Bit 0)                         */
#define mtgy_mtgy_op_b69_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b69: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b70  ====================================================== */
#define mtgy_mtgy_op_b70_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b70: val (Bit 0)                         */
#define mtgy_mtgy_op_b70_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b70: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b71  ====================================================== */
#define mtgy_mtgy_op_b71_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b71: val (Bit 0)                         */
#define mtgy_mtgy_op_b71_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b71: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b72  ====================================================== */
#define mtgy_mtgy_op_b72_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b72: val (Bit 0)                         */
#define mtgy_mtgy_op_b72_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b72: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b73  ====================================================== */
#define mtgy_mtgy_op_b73_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b73: val (Bit 0)                         */
#define mtgy_mtgy_op_b73_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b73: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b74  ====================================================== */
#define mtgy_mtgy_op_b74_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b74: val (Bit 0)                         */
#define mtgy_mtgy_op_b74_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b74: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b75  ====================================================== */
#define mtgy_mtgy_op_b75_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b75: val (Bit 0)                         */
#define mtgy_mtgy_op_b75_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b75: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b76  ====================================================== */
#define mtgy_mtgy_op_b76_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b76: val (Bit 0)                         */
#define mtgy_mtgy_op_b76_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b76: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b77  ====================================================== */
#define mtgy_mtgy_op_b77_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b77: val (Bit 0)                         */
#define mtgy_mtgy_op_b77_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b77: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b78  ====================================================== */
#define mtgy_mtgy_op_b78_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b78: val (Bit 0)                         */
#define mtgy_mtgy_op_b78_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b78: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b79  ====================================================== */
#define mtgy_mtgy_op_b79_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b79: val (Bit 0)                         */
#define mtgy_mtgy_op_b79_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b79: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b80  ====================================================== */
#define mtgy_mtgy_op_b80_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b80: val (Bit 0)                         */
#define mtgy_mtgy_op_b80_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b80: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b81  ====================================================== */
#define mtgy_mtgy_op_b81_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b81: val (Bit 0)                         */
#define mtgy_mtgy_op_b81_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b81: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b82  ====================================================== */
#define mtgy_mtgy_op_b82_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b82: val (Bit 0)                         */
#define mtgy_mtgy_op_b82_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b82: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b83  ====================================================== */
#define mtgy_mtgy_op_b83_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b83: val (Bit 0)                         */
#define mtgy_mtgy_op_b83_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b83: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b84  ====================================================== */
#define mtgy_mtgy_op_b84_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b84: val (Bit 0)                         */
#define mtgy_mtgy_op_b84_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b84: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b85  ====================================================== */
#define mtgy_mtgy_op_b85_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b85: val (Bit 0)                         */
#define mtgy_mtgy_op_b85_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b85: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b86  ====================================================== */
#define mtgy_mtgy_op_b86_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b86: val (Bit 0)                         */
#define mtgy_mtgy_op_b86_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b86: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b87  ====================================================== */
#define mtgy_mtgy_op_b87_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b87: val (Bit 0)                         */
#define mtgy_mtgy_op_b87_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b87: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b88  ====================================================== */
#define mtgy_mtgy_op_b88_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b88: val (Bit 0)                         */
#define mtgy_mtgy_op_b88_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b88: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b89  ====================================================== */
#define mtgy_mtgy_op_b89_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b89: val (Bit 0)                         */
#define mtgy_mtgy_op_b89_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b89: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b90  ====================================================== */
#define mtgy_mtgy_op_b90_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b90: val (Bit 0)                         */
#define mtgy_mtgy_op_b90_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b90: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b91  ====================================================== */
#define mtgy_mtgy_op_b91_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b91: val (Bit 0)                         */
#define mtgy_mtgy_op_b91_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b91: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b92  ====================================================== */
#define mtgy_mtgy_op_b92_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b92: val (Bit 0)                         */
#define mtgy_mtgy_op_b92_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b92: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b93  ====================================================== */
#define mtgy_mtgy_op_b93_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b93: val (Bit 0)                         */
#define mtgy_mtgy_op_b93_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b93: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b94  ====================================================== */
#define mtgy_mtgy_op_b94_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b94: val (Bit 0)                         */
#define mtgy_mtgy_op_b94_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b94: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b95  ====================================================== */
#define mtgy_mtgy_op_b95_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b95: val (Bit 0)                         */
#define mtgy_mtgy_op_b95_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b95: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b96  ====================================================== */
#define mtgy_mtgy_op_b96_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b96: val (Bit 0)                         */
#define mtgy_mtgy_op_b96_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b96: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b97  ====================================================== */
#define mtgy_mtgy_op_b97_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b97: val (Bit 0)                         */
#define mtgy_mtgy_op_b97_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b97: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b98  ====================================================== */
#define mtgy_mtgy_op_b98_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b98: val (Bit 0)                         */
#define mtgy_mtgy_op_b98_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b98: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_b99  ====================================================== */
#define mtgy_mtgy_op_b99_val_Pos          (0UL)                     /*!< mtgy mtgy_op_b99: val (Bit 0)                         */
#define mtgy_mtgy_op_b99_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_b99: val (Bitfield-Mask: 0xffffffff)     */
/* =====================================================  mtgy_op_b100  ====================================================== */
#define mtgy_mtgy_op_b100_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b100: val (Bit 0)                        */
#define mtgy_mtgy_op_b100_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b100: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b101  ====================================================== */
#define mtgy_mtgy_op_b101_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b101: val (Bit 0)                        */
#define mtgy_mtgy_op_b101_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b101: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b102  ====================================================== */
#define mtgy_mtgy_op_b102_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b102: val (Bit 0)                        */
#define mtgy_mtgy_op_b102_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b102: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b103  ====================================================== */
#define mtgy_mtgy_op_b103_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b103: val (Bit 0)                        */
#define mtgy_mtgy_op_b103_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b103: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b104  ====================================================== */
#define mtgy_mtgy_op_b104_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b104: val (Bit 0)                        */
#define mtgy_mtgy_op_b104_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b104: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b105  ====================================================== */
#define mtgy_mtgy_op_b105_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b105: val (Bit 0)                        */
#define mtgy_mtgy_op_b105_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b105: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b106  ====================================================== */
#define mtgy_mtgy_op_b106_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b106: val (Bit 0)                        */
#define mtgy_mtgy_op_b106_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b106: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b107  ====================================================== */
#define mtgy_mtgy_op_b107_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b107: val (Bit 0)                        */
#define mtgy_mtgy_op_b107_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b107: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b108  ====================================================== */
#define mtgy_mtgy_op_b108_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b108: val (Bit 0)                        */
#define mtgy_mtgy_op_b108_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b108: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b109  ====================================================== */
#define mtgy_mtgy_op_b109_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b109: val (Bit 0)                        */
#define mtgy_mtgy_op_b109_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b109: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b110  ====================================================== */
#define mtgy_mtgy_op_b110_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b110: val (Bit 0)                        */
#define mtgy_mtgy_op_b110_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b110: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b111  ====================================================== */
#define mtgy_mtgy_op_b111_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b111: val (Bit 0)                        */
#define mtgy_mtgy_op_b111_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b111: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b112  ====================================================== */
#define mtgy_mtgy_op_b112_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b112: val (Bit 0)                        */
#define mtgy_mtgy_op_b112_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b112: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b113  ====================================================== */
#define mtgy_mtgy_op_b113_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b113: val (Bit 0)                        */
#define mtgy_mtgy_op_b113_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b113: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b114  ====================================================== */
#define mtgy_mtgy_op_b114_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b114: val (Bit 0)                        */
#define mtgy_mtgy_op_b114_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b114: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b115  ====================================================== */
#define mtgy_mtgy_op_b115_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b115: val (Bit 0)                        */
#define mtgy_mtgy_op_b115_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b115: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b116  ====================================================== */
#define mtgy_mtgy_op_b116_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b116: val (Bit 0)                        */
#define mtgy_mtgy_op_b116_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b116: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b117  ====================================================== */
#define mtgy_mtgy_op_b117_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b117: val (Bit 0)                        */
#define mtgy_mtgy_op_b117_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b117: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b118  ====================================================== */
#define mtgy_mtgy_op_b118_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b118: val (Bit 0)                        */
#define mtgy_mtgy_op_b118_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b118: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b119  ====================================================== */
#define mtgy_mtgy_op_b119_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b119: val (Bit 0)                        */
#define mtgy_mtgy_op_b119_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b119: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b120  ====================================================== */
#define mtgy_mtgy_op_b120_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b120: val (Bit 0)                        */
#define mtgy_mtgy_op_b120_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b120: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b121  ====================================================== */
#define mtgy_mtgy_op_b121_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b121: val (Bit 0)                        */
#define mtgy_mtgy_op_b121_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b121: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b122  ====================================================== */
#define mtgy_mtgy_op_b122_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b122: val (Bit 0)                        */
#define mtgy_mtgy_op_b122_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b122: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b123  ====================================================== */
#define mtgy_mtgy_op_b123_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b123: val (Bit 0)                        */
#define mtgy_mtgy_op_b123_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b123: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b124  ====================================================== */
#define mtgy_mtgy_op_b124_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b124: val (Bit 0)                        */
#define mtgy_mtgy_op_b124_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b124: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b125  ====================================================== */
#define mtgy_mtgy_op_b125_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b125: val (Bit 0)                        */
#define mtgy_mtgy_op_b125_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b125: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b126  ====================================================== */
#define mtgy_mtgy_op_b126_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b126: val (Bit 0)                        */
#define mtgy_mtgy_op_b126_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b126: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_b127  ====================================================== */
#define mtgy_mtgy_op_b127_val_Pos         (0UL)                     /*!< mtgy mtgy_op_b127: val (Bit 0)                        */
#define mtgy_mtgy_op_b127_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_b127: val (Bitfield-Mask: 0xffffffff)    */
/* ======================================================  mtgy_op_a0  ======================================================= */
#define mtgy_mtgy_op_a0_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a0: val (Bit 0)                          */
#define mtgy_mtgy_op_a0_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a0: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a1  ======================================================= */
#define mtgy_mtgy_op_a1_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a1: val (Bit 0)                          */
#define mtgy_mtgy_op_a1_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a1: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a2  ======================================================= */
#define mtgy_mtgy_op_a2_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a2: val (Bit 0)                          */
#define mtgy_mtgy_op_a2_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a2: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a3  ======================================================= */
#define mtgy_mtgy_op_a3_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a3: val (Bit 0)                          */
#define mtgy_mtgy_op_a3_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a3: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a4  ======================================================= */
#define mtgy_mtgy_op_a4_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a4: val (Bit 0)                          */
#define mtgy_mtgy_op_a4_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a4: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a5  ======================================================= */
#define mtgy_mtgy_op_a5_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a5: val (Bit 0)                          */
#define mtgy_mtgy_op_a5_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a5: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a6  ======================================================= */
#define mtgy_mtgy_op_a6_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a6: val (Bit 0)                          */
#define mtgy_mtgy_op_a6_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a6: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a7  ======================================================= */
#define mtgy_mtgy_op_a7_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a7: val (Bit 0)                          */
#define mtgy_mtgy_op_a7_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a7: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a8  ======================================================= */
#define mtgy_mtgy_op_a8_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a8: val (Bit 0)                          */
#define mtgy_mtgy_op_a8_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a8: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a9  ======================================================= */
#define mtgy_mtgy_op_a9_val_Pos           (0UL)                     /*!< mtgy mtgy_op_a9: val (Bit 0)                          */
#define mtgy_mtgy_op_a9_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_a9: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_a10  ====================================================== */
#define mtgy_mtgy_op_a10_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a10: val (Bit 0)                         */
#define mtgy_mtgy_op_a10_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a10: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a11  ====================================================== */
#define mtgy_mtgy_op_a11_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a11: val (Bit 0)                         */
#define mtgy_mtgy_op_a11_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a11: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a12  ====================================================== */
#define mtgy_mtgy_op_a12_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a12: val (Bit 0)                         */
#define mtgy_mtgy_op_a12_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a12: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a13  ====================================================== */
#define mtgy_mtgy_op_a13_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a13: val (Bit 0)                         */
#define mtgy_mtgy_op_a13_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a13: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a14  ====================================================== */
#define mtgy_mtgy_op_a14_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a14: val (Bit 0)                         */
#define mtgy_mtgy_op_a14_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a14: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a15  ====================================================== */
#define mtgy_mtgy_op_a15_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a15: val (Bit 0)                         */
#define mtgy_mtgy_op_a15_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a15: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a16  ====================================================== */
#define mtgy_mtgy_op_a16_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a16: val (Bit 0)                         */
#define mtgy_mtgy_op_a16_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a16: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a17  ====================================================== */
#define mtgy_mtgy_op_a17_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a17: val (Bit 0)                         */
#define mtgy_mtgy_op_a17_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a17: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a18  ====================================================== */
#define mtgy_mtgy_op_a18_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a18: val (Bit 0)                         */
#define mtgy_mtgy_op_a18_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a18: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a19  ====================================================== */
#define mtgy_mtgy_op_a19_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a19: val (Bit 0)                         */
#define mtgy_mtgy_op_a19_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a19: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a20  ====================================================== */
#define mtgy_mtgy_op_a20_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a20: val (Bit 0)                         */
#define mtgy_mtgy_op_a20_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a20: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a21  ====================================================== */
#define mtgy_mtgy_op_a21_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a21: val (Bit 0)                         */
#define mtgy_mtgy_op_a21_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a21: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a22  ====================================================== */
#define mtgy_mtgy_op_a22_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a22: val (Bit 0)                         */
#define mtgy_mtgy_op_a22_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a22: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a23  ====================================================== */
#define mtgy_mtgy_op_a23_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a23: val (Bit 0)                         */
#define mtgy_mtgy_op_a23_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a23: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a24  ====================================================== */
#define mtgy_mtgy_op_a24_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a24: val (Bit 0)                         */
#define mtgy_mtgy_op_a24_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a24: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a25  ====================================================== */
#define mtgy_mtgy_op_a25_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a25: val (Bit 0)                         */
#define mtgy_mtgy_op_a25_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a25: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a26  ====================================================== */
#define mtgy_mtgy_op_a26_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a26: val (Bit 0)                         */
#define mtgy_mtgy_op_a26_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a26: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a27  ====================================================== */
#define mtgy_mtgy_op_a27_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a27: val (Bit 0)                         */
#define mtgy_mtgy_op_a27_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a27: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a28  ====================================================== */
#define mtgy_mtgy_op_a28_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a28: val (Bit 0)                         */
#define mtgy_mtgy_op_a28_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a28: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a29  ====================================================== */
#define mtgy_mtgy_op_a29_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a29: val (Bit 0)                         */
#define mtgy_mtgy_op_a29_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a29: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a30  ====================================================== */
#define mtgy_mtgy_op_a30_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a30: val (Bit 0)                         */
#define mtgy_mtgy_op_a30_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a30: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a31  ====================================================== */
#define mtgy_mtgy_op_a31_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a31: val (Bit 0)                         */
#define mtgy_mtgy_op_a31_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a31: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a32  ====================================================== */
#define mtgy_mtgy_op_a32_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a32: val (Bit 0)                         */
#define mtgy_mtgy_op_a32_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a32: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a33  ====================================================== */
#define mtgy_mtgy_op_a33_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a33: val (Bit 0)                         */
#define mtgy_mtgy_op_a33_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a33: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a34  ====================================================== */
#define mtgy_mtgy_op_a34_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a34: val (Bit 0)                         */
#define mtgy_mtgy_op_a34_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a34: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a35  ====================================================== */
#define mtgy_mtgy_op_a35_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a35: val (Bit 0)                         */
#define mtgy_mtgy_op_a35_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a35: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a36  ====================================================== */
#define mtgy_mtgy_op_a36_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a36: val (Bit 0)                         */
#define mtgy_mtgy_op_a36_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a36: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a37  ====================================================== */
#define mtgy_mtgy_op_a37_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a37: val (Bit 0)                         */
#define mtgy_mtgy_op_a37_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a37: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a38  ====================================================== */
#define mtgy_mtgy_op_a38_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a38: val (Bit 0)                         */
#define mtgy_mtgy_op_a38_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a38: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a39  ====================================================== */
#define mtgy_mtgy_op_a39_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a39: val (Bit 0)                         */
#define mtgy_mtgy_op_a39_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a39: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a40  ====================================================== */
#define mtgy_mtgy_op_a40_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a40: val (Bit 0)                         */
#define mtgy_mtgy_op_a40_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a40: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a41  ====================================================== */
#define mtgy_mtgy_op_a41_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a41: val (Bit 0)                         */
#define mtgy_mtgy_op_a41_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a41: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a42  ====================================================== */
#define mtgy_mtgy_op_a42_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a42: val (Bit 0)                         */
#define mtgy_mtgy_op_a42_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a42: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a43  ====================================================== */
#define mtgy_mtgy_op_a43_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a43: val (Bit 0)                         */
#define mtgy_mtgy_op_a43_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a43: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a44  ====================================================== */
#define mtgy_mtgy_op_a44_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a44: val (Bit 0)                         */
#define mtgy_mtgy_op_a44_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a44: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a45  ====================================================== */
#define mtgy_mtgy_op_a45_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a45: val (Bit 0)                         */
#define mtgy_mtgy_op_a45_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a45: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a46  ====================================================== */
#define mtgy_mtgy_op_a46_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a46: val (Bit 0)                         */
#define mtgy_mtgy_op_a46_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a46: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a47  ====================================================== */
#define mtgy_mtgy_op_a47_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a47: val (Bit 0)                         */
#define mtgy_mtgy_op_a47_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a47: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a48  ====================================================== */
#define mtgy_mtgy_op_a48_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a48: val (Bit 0)                         */
#define mtgy_mtgy_op_a48_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a48: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a49  ====================================================== */
#define mtgy_mtgy_op_a49_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a49: val (Bit 0)                         */
#define mtgy_mtgy_op_a49_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a49: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a50  ====================================================== */
#define mtgy_mtgy_op_a50_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a50: val (Bit 0)                         */
#define mtgy_mtgy_op_a50_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a50: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a51  ====================================================== */
#define mtgy_mtgy_op_a51_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a51: val (Bit 0)                         */
#define mtgy_mtgy_op_a51_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a51: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a52  ====================================================== */
#define mtgy_mtgy_op_a52_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a52: val (Bit 0)                         */
#define mtgy_mtgy_op_a52_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a52: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a53  ====================================================== */
#define mtgy_mtgy_op_a53_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a53: val (Bit 0)                         */
#define mtgy_mtgy_op_a53_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a53: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a54  ====================================================== */
#define mtgy_mtgy_op_a54_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a54: val (Bit 0)                         */
#define mtgy_mtgy_op_a54_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a54: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a55  ====================================================== */
#define mtgy_mtgy_op_a55_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a55: val (Bit 0)                         */
#define mtgy_mtgy_op_a55_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a55: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a56  ====================================================== */
#define mtgy_mtgy_op_a56_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a56: val (Bit 0)                         */
#define mtgy_mtgy_op_a56_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a56: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a57  ====================================================== */
#define mtgy_mtgy_op_a57_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a57: val (Bit 0)                         */
#define mtgy_mtgy_op_a57_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a57: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a58  ====================================================== */
#define mtgy_mtgy_op_a58_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a58: val (Bit 0)                         */
#define mtgy_mtgy_op_a58_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a58: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a59  ====================================================== */
#define mtgy_mtgy_op_a59_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a59: val (Bit 0)                         */
#define mtgy_mtgy_op_a59_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a59: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a60  ====================================================== */
#define mtgy_mtgy_op_a60_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a60: val (Bit 0)                         */
#define mtgy_mtgy_op_a60_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a60: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a61  ====================================================== */
#define mtgy_mtgy_op_a61_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a61: val (Bit 0)                         */
#define mtgy_mtgy_op_a61_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a61: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a62  ====================================================== */
#define mtgy_mtgy_op_a62_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a62: val (Bit 0)                         */
#define mtgy_mtgy_op_a62_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a62: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a63  ====================================================== */
#define mtgy_mtgy_op_a63_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a63: val (Bit 0)                         */
#define mtgy_mtgy_op_a63_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a63: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a64  ====================================================== */
#define mtgy_mtgy_op_a64_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a64: val (Bit 0)                         */
#define mtgy_mtgy_op_a64_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a64: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a65  ====================================================== */
#define mtgy_mtgy_op_a65_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a65: val (Bit 0)                         */
#define mtgy_mtgy_op_a65_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a65: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a66  ====================================================== */
#define mtgy_mtgy_op_a66_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a66: val (Bit 0)                         */
#define mtgy_mtgy_op_a66_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a66: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a67  ====================================================== */
#define mtgy_mtgy_op_a67_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a67: val (Bit 0)                         */
#define mtgy_mtgy_op_a67_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a67: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a68  ====================================================== */
#define mtgy_mtgy_op_a68_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a68: val (Bit 0)                         */
#define mtgy_mtgy_op_a68_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a68: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a69  ====================================================== */
#define mtgy_mtgy_op_a69_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a69: val (Bit 0)                         */
#define mtgy_mtgy_op_a69_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a69: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a70  ====================================================== */
#define mtgy_mtgy_op_a70_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a70: val (Bit 0)                         */
#define mtgy_mtgy_op_a70_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a70: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a71  ====================================================== */
#define mtgy_mtgy_op_a71_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a71: val (Bit 0)                         */
#define mtgy_mtgy_op_a71_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a71: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a72  ====================================================== */
#define mtgy_mtgy_op_a72_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a72: val (Bit 0)                         */
#define mtgy_mtgy_op_a72_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a72: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a73  ====================================================== */
#define mtgy_mtgy_op_a73_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a73: val (Bit 0)                         */
#define mtgy_mtgy_op_a73_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a73: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a74  ====================================================== */
#define mtgy_mtgy_op_a74_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a74: val (Bit 0)                         */
#define mtgy_mtgy_op_a74_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a74: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a75  ====================================================== */
#define mtgy_mtgy_op_a75_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a75: val (Bit 0)                         */
#define mtgy_mtgy_op_a75_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a75: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a76  ====================================================== */
#define mtgy_mtgy_op_a76_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a76: val (Bit 0)                         */
#define mtgy_mtgy_op_a76_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a76: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a77  ====================================================== */
#define mtgy_mtgy_op_a77_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a77: val (Bit 0)                         */
#define mtgy_mtgy_op_a77_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a77: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a78  ====================================================== */
#define mtgy_mtgy_op_a78_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a78: val (Bit 0)                         */
#define mtgy_mtgy_op_a78_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a78: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a79  ====================================================== */
#define mtgy_mtgy_op_a79_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a79: val (Bit 0)                         */
#define mtgy_mtgy_op_a79_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a79: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a80  ====================================================== */
#define mtgy_mtgy_op_a80_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a80: val (Bit 0)                         */
#define mtgy_mtgy_op_a80_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a80: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a81  ====================================================== */
#define mtgy_mtgy_op_a81_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a81: val (Bit 0)                         */
#define mtgy_mtgy_op_a81_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a81: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a82  ====================================================== */
#define mtgy_mtgy_op_a82_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a82: val (Bit 0)                         */
#define mtgy_mtgy_op_a82_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a82: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a83  ====================================================== */
#define mtgy_mtgy_op_a83_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a83: val (Bit 0)                         */
#define mtgy_mtgy_op_a83_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a83: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a84  ====================================================== */
#define mtgy_mtgy_op_a84_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a84: val (Bit 0)                         */
#define mtgy_mtgy_op_a84_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a84: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a85  ====================================================== */
#define mtgy_mtgy_op_a85_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a85: val (Bit 0)                         */
#define mtgy_mtgy_op_a85_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a85: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a86  ====================================================== */
#define mtgy_mtgy_op_a86_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a86: val (Bit 0)                         */
#define mtgy_mtgy_op_a86_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a86: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a87  ====================================================== */
#define mtgy_mtgy_op_a87_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a87: val (Bit 0)                         */
#define mtgy_mtgy_op_a87_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a87: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a88  ====================================================== */
#define mtgy_mtgy_op_a88_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a88: val (Bit 0)                         */
#define mtgy_mtgy_op_a88_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a88: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a89  ====================================================== */
#define mtgy_mtgy_op_a89_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a89: val (Bit 0)                         */
#define mtgy_mtgy_op_a89_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a89: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a90  ====================================================== */
#define mtgy_mtgy_op_a90_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a90: val (Bit 0)                         */
#define mtgy_mtgy_op_a90_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a90: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a91  ====================================================== */
#define mtgy_mtgy_op_a91_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a91: val (Bit 0)                         */
#define mtgy_mtgy_op_a91_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a91: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a92  ====================================================== */
#define mtgy_mtgy_op_a92_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a92: val (Bit 0)                         */
#define mtgy_mtgy_op_a92_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a92: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a93  ====================================================== */
#define mtgy_mtgy_op_a93_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a93: val (Bit 0)                         */
#define mtgy_mtgy_op_a93_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a93: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a94  ====================================================== */
#define mtgy_mtgy_op_a94_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a94: val (Bit 0)                         */
#define mtgy_mtgy_op_a94_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a94: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a95  ====================================================== */
#define mtgy_mtgy_op_a95_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a95: val (Bit 0)                         */
#define mtgy_mtgy_op_a95_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a95: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a96  ====================================================== */
#define mtgy_mtgy_op_a96_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a96: val (Bit 0)                         */
#define mtgy_mtgy_op_a96_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a96: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a97  ====================================================== */
#define mtgy_mtgy_op_a97_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a97: val (Bit 0)                         */
#define mtgy_mtgy_op_a97_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a97: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a98  ====================================================== */
#define mtgy_mtgy_op_a98_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a98: val (Bit 0)                         */
#define mtgy_mtgy_op_a98_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a98: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_a99  ====================================================== */
#define mtgy_mtgy_op_a99_val_Pos          (0UL)                     /*!< mtgy mtgy_op_a99: val (Bit 0)                         */
#define mtgy_mtgy_op_a99_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_a99: val (Bitfield-Mask: 0xffffffff)     */
/* =====================================================  mtgy_op_a100  ====================================================== */
#define mtgy_mtgy_op_a100_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a100: val (Bit 0)                        */
#define mtgy_mtgy_op_a100_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a100: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a101  ====================================================== */
#define mtgy_mtgy_op_a101_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a101: val (Bit 0)                        */
#define mtgy_mtgy_op_a101_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a101: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a102  ====================================================== */
#define mtgy_mtgy_op_a102_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a102: val (Bit 0)                        */
#define mtgy_mtgy_op_a102_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a102: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a103  ====================================================== */
#define mtgy_mtgy_op_a103_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a103: val (Bit 0)                        */
#define mtgy_mtgy_op_a103_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a103: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a104  ====================================================== */
#define mtgy_mtgy_op_a104_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a104: val (Bit 0)                        */
#define mtgy_mtgy_op_a104_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a104: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a105  ====================================================== */
#define mtgy_mtgy_op_a105_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a105: val (Bit 0)                        */
#define mtgy_mtgy_op_a105_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a105: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a106  ====================================================== */
#define mtgy_mtgy_op_a106_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a106: val (Bit 0)                        */
#define mtgy_mtgy_op_a106_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a106: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a107  ====================================================== */
#define mtgy_mtgy_op_a107_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a107: val (Bit 0)                        */
#define mtgy_mtgy_op_a107_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a107: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a108  ====================================================== */
#define mtgy_mtgy_op_a108_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a108: val (Bit 0)                        */
#define mtgy_mtgy_op_a108_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a108: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a109  ====================================================== */
#define mtgy_mtgy_op_a109_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a109: val (Bit 0)                        */
#define mtgy_mtgy_op_a109_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a109: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a110  ====================================================== */
#define mtgy_mtgy_op_a110_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a110: val (Bit 0)                        */
#define mtgy_mtgy_op_a110_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a110: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a111  ====================================================== */
#define mtgy_mtgy_op_a111_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a111: val (Bit 0)                        */
#define mtgy_mtgy_op_a111_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a111: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a112  ====================================================== */
#define mtgy_mtgy_op_a112_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a112: val (Bit 0)                        */
#define mtgy_mtgy_op_a112_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a112: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a113  ====================================================== */
#define mtgy_mtgy_op_a113_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a113: val (Bit 0)                        */
#define mtgy_mtgy_op_a113_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a113: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a114  ====================================================== */
#define mtgy_mtgy_op_a114_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a114: val (Bit 0)                        */
#define mtgy_mtgy_op_a114_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a114: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a115  ====================================================== */
#define mtgy_mtgy_op_a115_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a115: val (Bit 0)                        */
#define mtgy_mtgy_op_a115_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a115: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a116  ====================================================== */
#define mtgy_mtgy_op_a116_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a116: val (Bit 0)                        */
#define mtgy_mtgy_op_a116_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a116: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a117  ====================================================== */
#define mtgy_mtgy_op_a117_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a117: val (Bit 0)                        */
#define mtgy_mtgy_op_a117_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a117: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a118  ====================================================== */
#define mtgy_mtgy_op_a118_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a118: val (Bit 0)                        */
#define mtgy_mtgy_op_a118_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a118: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a119  ====================================================== */
#define mtgy_mtgy_op_a119_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a119: val (Bit 0)                        */
#define mtgy_mtgy_op_a119_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a119: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a120  ====================================================== */
#define mtgy_mtgy_op_a120_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a120: val (Bit 0)                        */
#define mtgy_mtgy_op_a120_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a120: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a121  ====================================================== */
#define mtgy_mtgy_op_a121_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a121: val (Bit 0)                        */
#define mtgy_mtgy_op_a121_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a121: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a122  ====================================================== */
#define mtgy_mtgy_op_a122_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a122: val (Bit 0)                        */
#define mtgy_mtgy_op_a122_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a122: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a123  ====================================================== */
#define mtgy_mtgy_op_a123_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a123: val (Bit 0)                        */
#define mtgy_mtgy_op_a123_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a123: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a124  ====================================================== */
#define mtgy_mtgy_op_a124_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a124: val (Bit 0)                        */
#define mtgy_mtgy_op_a124_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a124: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a125  ====================================================== */
#define mtgy_mtgy_op_a125_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a125: val (Bit 0)                        */
#define mtgy_mtgy_op_a125_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a125: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a126  ====================================================== */
#define mtgy_mtgy_op_a126_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a126: val (Bit 0)                        */
#define mtgy_mtgy_op_a126_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a126: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_a127  ====================================================== */
#define mtgy_mtgy_op_a127_val_Pos         (0UL)                     /*!< mtgy mtgy_op_a127: val (Bit 0)                        */
#define mtgy_mtgy_op_a127_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_a127: val (Bitfield-Mask: 0xffffffff)    */
/* ======================================================  mtgy_op_e0  ======================================================= */
#define mtgy_mtgy_op_e0_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e0: val (Bit 0)                          */
#define mtgy_mtgy_op_e0_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e0: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e1  ======================================================= */
#define mtgy_mtgy_op_e1_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e1: val (Bit 0)                          */
#define mtgy_mtgy_op_e1_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e1: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e2  ======================================================= */
#define mtgy_mtgy_op_e2_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e2: val (Bit 0)                          */
#define mtgy_mtgy_op_e2_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e2: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e3  ======================================================= */
#define mtgy_mtgy_op_e3_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e3: val (Bit 0)                          */
#define mtgy_mtgy_op_e3_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e3: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e4  ======================================================= */
#define mtgy_mtgy_op_e4_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e4: val (Bit 0)                          */
#define mtgy_mtgy_op_e4_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e4: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e5  ======================================================= */
#define mtgy_mtgy_op_e5_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e5: val (Bit 0)                          */
#define mtgy_mtgy_op_e5_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e5: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e6  ======================================================= */
#define mtgy_mtgy_op_e6_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e6: val (Bit 0)                          */
#define mtgy_mtgy_op_e6_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e6: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e7  ======================================================= */
#define mtgy_mtgy_op_e7_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e7: val (Bit 0)                          */
#define mtgy_mtgy_op_e7_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e7: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e8  ======================================================= */
#define mtgy_mtgy_op_e8_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e8: val (Bit 0)                          */
#define mtgy_mtgy_op_e8_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e8: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e9  ======================================================= */
#define mtgy_mtgy_op_e9_val_Pos           (0UL)                     /*!< mtgy mtgy_op_e9: val (Bit 0)                          */
#define mtgy_mtgy_op_e9_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_e9: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_e10  ====================================================== */
#define mtgy_mtgy_op_e10_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e10: val (Bit 0)                         */
#define mtgy_mtgy_op_e10_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e10: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e11  ====================================================== */
#define mtgy_mtgy_op_e11_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e11: val (Bit 0)                         */
#define mtgy_mtgy_op_e11_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e11: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e12  ====================================================== */
#define mtgy_mtgy_op_e12_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e12: val (Bit 0)                         */
#define mtgy_mtgy_op_e12_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e12: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e13  ====================================================== */
#define mtgy_mtgy_op_e13_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e13: val (Bit 0)                         */
#define mtgy_mtgy_op_e13_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e13: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e14  ====================================================== */
#define mtgy_mtgy_op_e14_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e14: val (Bit 0)                         */
#define mtgy_mtgy_op_e14_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e14: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e15  ====================================================== */
#define mtgy_mtgy_op_e15_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e15: val (Bit 0)                         */
#define mtgy_mtgy_op_e15_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e15: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e16  ====================================================== */
#define mtgy_mtgy_op_e16_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e16: val (Bit 0)                         */
#define mtgy_mtgy_op_e16_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e16: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e17  ====================================================== */
#define mtgy_mtgy_op_e17_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e17: val (Bit 0)                         */
#define mtgy_mtgy_op_e17_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e17: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e18  ====================================================== */
#define mtgy_mtgy_op_e18_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e18: val (Bit 0)                         */
#define mtgy_mtgy_op_e18_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e18: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e19  ====================================================== */
#define mtgy_mtgy_op_e19_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e19: val (Bit 0)                         */
#define mtgy_mtgy_op_e19_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e19: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e20  ====================================================== */
#define mtgy_mtgy_op_e20_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e20: val (Bit 0)                         */
#define mtgy_mtgy_op_e20_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e20: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e21  ====================================================== */
#define mtgy_mtgy_op_e21_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e21: val (Bit 0)                         */
#define mtgy_mtgy_op_e21_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e21: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e22  ====================================================== */
#define mtgy_mtgy_op_e22_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e22: val (Bit 0)                         */
#define mtgy_mtgy_op_e22_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e22: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e23  ====================================================== */
#define mtgy_mtgy_op_e23_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e23: val (Bit 0)                         */
#define mtgy_mtgy_op_e23_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e23: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e24  ====================================================== */
#define mtgy_mtgy_op_e24_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e24: val (Bit 0)                         */
#define mtgy_mtgy_op_e24_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e24: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e25  ====================================================== */
#define mtgy_mtgy_op_e25_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e25: val (Bit 0)                         */
#define mtgy_mtgy_op_e25_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e25: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e26  ====================================================== */
#define mtgy_mtgy_op_e26_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e26: val (Bit 0)                         */
#define mtgy_mtgy_op_e26_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e26: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e27  ====================================================== */
#define mtgy_mtgy_op_e27_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e27: val (Bit 0)                         */
#define mtgy_mtgy_op_e27_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e27: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e28  ====================================================== */
#define mtgy_mtgy_op_e28_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e28: val (Bit 0)                         */
#define mtgy_mtgy_op_e28_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e28: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e29  ====================================================== */
#define mtgy_mtgy_op_e29_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e29: val (Bit 0)                         */
#define mtgy_mtgy_op_e29_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e29: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e30  ====================================================== */
#define mtgy_mtgy_op_e30_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e30: val (Bit 0)                         */
#define mtgy_mtgy_op_e30_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e30: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e31  ====================================================== */
#define mtgy_mtgy_op_e31_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e31: val (Bit 0)                         */
#define mtgy_mtgy_op_e31_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e31: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e32  ====================================================== */
#define mtgy_mtgy_op_e32_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e32: val (Bit 0)                         */
#define mtgy_mtgy_op_e32_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e32: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e33  ====================================================== */
#define mtgy_mtgy_op_e33_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e33: val (Bit 0)                         */
#define mtgy_mtgy_op_e33_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e33: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e34  ====================================================== */
#define mtgy_mtgy_op_e34_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e34: val (Bit 0)                         */
#define mtgy_mtgy_op_e34_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e34: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e35  ====================================================== */
#define mtgy_mtgy_op_e35_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e35: val (Bit 0)                         */
#define mtgy_mtgy_op_e35_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e35: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e36  ====================================================== */
#define mtgy_mtgy_op_e36_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e36: val (Bit 0)                         */
#define mtgy_mtgy_op_e36_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e36: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e37  ====================================================== */
#define mtgy_mtgy_op_e37_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e37: val (Bit 0)                         */
#define mtgy_mtgy_op_e37_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e37: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e38  ====================================================== */
#define mtgy_mtgy_op_e38_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e38: val (Bit 0)                         */
#define mtgy_mtgy_op_e38_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e38: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e39  ====================================================== */
#define mtgy_mtgy_op_e39_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e39: val (Bit 0)                         */
#define mtgy_mtgy_op_e39_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e39: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e40  ====================================================== */
#define mtgy_mtgy_op_e40_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e40: val (Bit 0)                         */
#define mtgy_mtgy_op_e40_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e40: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e41  ====================================================== */
#define mtgy_mtgy_op_e41_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e41: val (Bit 0)                         */
#define mtgy_mtgy_op_e41_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e41: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e42  ====================================================== */
#define mtgy_mtgy_op_e42_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e42: val (Bit 0)                         */
#define mtgy_mtgy_op_e42_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e42: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e43  ====================================================== */
#define mtgy_mtgy_op_e43_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e43: val (Bit 0)                         */
#define mtgy_mtgy_op_e43_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e43: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e44  ====================================================== */
#define mtgy_mtgy_op_e44_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e44: val (Bit 0)                         */
#define mtgy_mtgy_op_e44_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e44: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e45  ====================================================== */
#define mtgy_mtgy_op_e45_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e45: val (Bit 0)                         */
#define mtgy_mtgy_op_e45_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e45: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e46  ====================================================== */
#define mtgy_mtgy_op_e46_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e46: val (Bit 0)                         */
#define mtgy_mtgy_op_e46_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e46: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e47  ====================================================== */
#define mtgy_mtgy_op_e47_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e47: val (Bit 0)                         */
#define mtgy_mtgy_op_e47_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e47: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e48  ====================================================== */
#define mtgy_mtgy_op_e48_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e48: val (Bit 0)                         */
#define mtgy_mtgy_op_e48_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e48: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e49  ====================================================== */
#define mtgy_mtgy_op_e49_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e49: val (Bit 0)                         */
#define mtgy_mtgy_op_e49_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e49: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e50  ====================================================== */
#define mtgy_mtgy_op_e50_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e50: val (Bit 0)                         */
#define mtgy_mtgy_op_e50_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e50: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e51  ====================================================== */
#define mtgy_mtgy_op_e51_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e51: val (Bit 0)                         */
#define mtgy_mtgy_op_e51_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e51: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e52  ====================================================== */
#define mtgy_mtgy_op_e52_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e52: val (Bit 0)                         */
#define mtgy_mtgy_op_e52_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e52: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e53  ====================================================== */
#define mtgy_mtgy_op_e53_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e53: val (Bit 0)                         */
#define mtgy_mtgy_op_e53_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e53: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e54  ====================================================== */
#define mtgy_mtgy_op_e54_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e54: val (Bit 0)                         */
#define mtgy_mtgy_op_e54_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e54: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e55  ====================================================== */
#define mtgy_mtgy_op_e55_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e55: val (Bit 0)                         */
#define mtgy_mtgy_op_e55_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e55: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e56  ====================================================== */
#define mtgy_mtgy_op_e56_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e56: val (Bit 0)                         */
#define mtgy_mtgy_op_e56_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e56: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e57  ====================================================== */
#define mtgy_mtgy_op_e57_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e57: val (Bit 0)                         */
#define mtgy_mtgy_op_e57_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e57: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e58  ====================================================== */
#define mtgy_mtgy_op_e58_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e58: val (Bit 0)                         */
#define mtgy_mtgy_op_e58_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e58: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e59  ====================================================== */
#define mtgy_mtgy_op_e59_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e59: val (Bit 0)                         */
#define mtgy_mtgy_op_e59_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e59: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e60  ====================================================== */
#define mtgy_mtgy_op_e60_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e60: val (Bit 0)                         */
#define mtgy_mtgy_op_e60_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e60: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e61  ====================================================== */
#define mtgy_mtgy_op_e61_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e61: val (Bit 0)                         */
#define mtgy_mtgy_op_e61_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e61: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e62  ====================================================== */
#define mtgy_mtgy_op_e62_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e62: val (Bit 0)                         */
#define mtgy_mtgy_op_e62_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e62: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e63  ====================================================== */
#define mtgy_mtgy_op_e63_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e63: val (Bit 0)                         */
#define mtgy_mtgy_op_e63_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e63: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e64  ====================================================== */
#define mtgy_mtgy_op_e64_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e64: val (Bit 0)                         */
#define mtgy_mtgy_op_e64_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e64: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e65  ====================================================== */
#define mtgy_mtgy_op_e65_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e65: val (Bit 0)                         */
#define mtgy_mtgy_op_e65_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e65: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e66  ====================================================== */
#define mtgy_mtgy_op_e66_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e66: val (Bit 0)                         */
#define mtgy_mtgy_op_e66_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e66: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e67  ====================================================== */
#define mtgy_mtgy_op_e67_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e67: val (Bit 0)                         */
#define mtgy_mtgy_op_e67_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e67: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e68  ====================================================== */
#define mtgy_mtgy_op_e68_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e68: val (Bit 0)                         */
#define mtgy_mtgy_op_e68_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e68: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e69  ====================================================== */
#define mtgy_mtgy_op_e69_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e69: val (Bit 0)                         */
#define mtgy_mtgy_op_e69_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e69: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e70  ====================================================== */
#define mtgy_mtgy_op_e70_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e70: val (Bit 0)                         */
#define mtgy_mtgy_op_e70_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e70: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e71  ====================================================== */
#define mtgy_mtgy_op_e71_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e71: val (Bit 0)                         */
#define mtgy_mtgy_op_e71_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e71: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e72  ====================================================== */
#define mtgy_mtgy_op_e72_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e72: val (Bit 0)                         */
#define mtgy_mtgy_op_e72_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e72: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e73  ====================================================== */
#define mtgy_mtgy_op_e73_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e73: val (Bit 0)                         */
#define mtgy_mtgy_op_e73_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e73: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e74  ====================================================== */
#define mtgy_mtgy_op_e74_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e74: val (Bit 0)                         */
#define mtgy_mtgy_op_e74_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e74: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e75  ====================================================== */
#define mtgy_mtgy_op_e75_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e75: val (Bit 0)                         */
#define mtgy_mtgy_op_e75_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e75: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e76  ====================================================== */
#define mtgy_mtgy_op_e76_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e76: val (Bit 0)                         */
#define mtgy_mtgy_op_e76_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e76: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e77  ====================================================== */
#define mtgy_mtgy_op_e77_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e77: val (Bit 0)                         */
#define mtgy_mtgy_op_e77_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e77: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e78  ====================================================== */
#define mtgy_mtgy_op_e78_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e78: val (Bit 0)                         */
#define mtgy_mtgy_op_e78_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e78: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e79  ====================================================== */
#define mtgy_mtgy_op_e79_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e79: val (Bit 0)                         */
#define mtgy_mtgy_op_e79_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e79: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e80  ====================================================== */
#define mtgy_mtgy_op_e80_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e80: val (Bit 0)                         */
#define mtgy_mtgy_op_e80_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e80: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e81  ====================================================== */
#define mtgy_mtgy_op_e81_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e81: val (Bit 0)                         */
#define mtgy_mtgy_op_e81_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e81: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e82  ====================================================== */
#define mtgy_mtgy_op_e82_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e82: val (Bit 0)                         */
#define mtgy_mtgy_op_e82_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e82: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e83  ====================================================== */
#define mtgy_mtgy_op_e83_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e83: val (Bit 0)                         */
#define mtgy_mtgy_op_e83_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e83: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e84  ====================================================== */
#define mtgy_mtgy_op_e84_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e84: val (Bit 0)                         */
#define mtgy_mtgy_op_e84_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e84: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e85  ====================================================== */
#define mtgy_mtgy_op_e85_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e85: val (Bit 0)                         */
#define mtgy_mtgy_op_e85_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e85: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e86  ====================================================== */
#define mtgy_mtgy_op_e86_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e86: val (Bit 0)                         */
#define mtgy_mtgy_op_e86_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e86: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e87  ====================================================== */
#define mtgy_mtgy_op_e87_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e87: val (Bit 0)                         */
#define mtgy_mtgy_op_e87_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e87: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e88  ====================================================== */
#define mtgy_mtgy_op_e88_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e88: val (Bit 0)                         */
#define mtgy_mtgy_op_e88_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e88: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e89  ====================================================== */
#define mtgy_mtgy_op_e89_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e89: val (Bit 0)                         */
#define mtgy_mtgy_op_e89_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e89: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e90  ====================================================== */
#define mtgy_mtgy_op_e90_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e90: val (Bit 0)                         */
#define mtgy_mtgy_op_e90_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e90: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e91  ====================================================== */
#define mtgy_mtgy_op_e91_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e91: val (Bit 0)                         */
#define mtgy_mtgy_op_e91_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e91: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e92  ====================================================== */
#define mtgy_mtgy_op_e92_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e92: val (Bit 0)                         */
#define mtgy_mtgy_op_e92_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e92: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e93  ====================================================== */
#define mtgy_mtgy_op_e93_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e93: val (Bit 0)                         */
#define mtgy_mtgy_op_e93_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e93: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e94  ====================================================== */
#define mtgy_mtgy_op_e94_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e94: val (Bit 0)                         */
#define mtgy_mtgy_op_e94_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e94: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e95  ====================================================== */
#define mtgy_mtgy_op_e95_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e95: val (Bit 0)                         */
#define mtgy_mtgy_op_e95_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e95: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e96  ====================================================== */
#define mtgy_mtgy_op_e96_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e96: val (Bit 0)                         */
#define mtgy_mtgy_op_e96_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e96: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e97  ====================================================== */
#define mtgy_mtgy_op_e97_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e97: val (Bit 0)                         */
#define mtgy_mtgy_op_e97_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e97: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e98  ====================================================== */
#define mtgy_mtgy_op_e98_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e98: val (Bit 0)                         */
#define mtgy_mtgy_op_e98_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e98: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_e99  ====================================================== */
#define mtgy_mtgy_op_e99_val_Pos          (0UL)                     /*!< mtgy mtgy_op_e99: val (Bit 0)                         */
#define mtgy_mtgy_op_e99_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_e99: val (Bitfield-Mask: 0xffffffff)     */
/* =====================================================  mtgy_op_e100  ====================================================== */
#define mtgy_mtgy_op_e100_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e100: val (Bit 0)                        */
#define mtgy_mtgy_op_e100_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e100: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e101  ====================================================== */
#define mtgy_mtgy_op_e101_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e101: val (Bit 0)                        */
#define mtgy_mtgy_op_e101_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e101: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e102  ====================================================== */
#define mtgy_mtgy_op_e102_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e102: val (Bit 0)                        */
#define mtgy_mtgy_op_e102_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e102: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e103  ====================================================== */
#define mtgy_mtgy_op_e103_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e103: val (Bit 0)                        */
#define mtgy_mtgy_op_e103_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e103: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e104  ====================================================== */
#define mtgy_mtgy_op_e104_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e104: val (Bit 0)                        */
#define mtgy_mtgy_op_e104_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e104: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e105  ====================================================== */
#define mtgy_mtgy_op_e105_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e105: val (Bit 0)                        */
#define mtgy_mtgy_op_e105_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e105: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e106  ====================================================== */
#define mtgy_mtgy_op_e106_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e106: val (Bit 0)                        */
#define mtgy_mtgy_op_e106_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e106: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e107  ====================================================== */
#define mtgy_mtgy_op_e107_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e107: val (Bit 0)                        */
#define mtgy_mtgy_op_e107_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e107: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e108  ====================================================== */
#define mtgy_mtgy_op_e108_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e108: val (Bit 0)                        */
#define mtgy_mtgy_op_e108_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e108: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e109  ====================================================== */
#define mtgy_mtgy_op_e109_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e109: val (Bit 0)                        */
#define mtgy_mtgy_op_e109_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e109: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e110  ====================================================== */
#define mtgy_mtgy_op_e110_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e110: val (Bit 0)                        */
#define mtgy_mtgy_op_e110_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e110: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e111  ====================================================== */
#define mtgy_mtgy_op_e111_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e111: val (Bit 0)                        */
#define mtgy_mtgy_op_e111_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e111: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e112  ====================================================== */
#define mtgy_mtgy_op_e112_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e112: val (Bit 0)                        */
#define mtgy_mtgy_op_e112_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e112: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e113  ====================================================== */
#define mtgy_mtgy_op_e113_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e113: val (Bit 0)                        */
#define mtgy_mtgy_op_e113_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e113: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e114  ====================================================== */
#define mtgy_mtgy_op_e114_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e114: val (Bit 0)                        */
#define mtgy_mtgy_op_e114_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e114: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e115  ====================================================== */
#define mtgy_mtgy_op_e115_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e115: val (Bit 0)                        */
#define mtgy_mtgy_op_e115_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e115: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e116  ====================================================== */
#define mtgy_mtgy_op_e116_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e116: val (Bit 0)                        */
#define mtgy_mtgy_op_e116_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e116: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e117  ====================================================== */
#define mtgy_mtgy_op_e117_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e117: val (Bit 0)                        */
#define mtgy_mtgy_op_e117_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e117: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e118  ====================================================== */
#define mtgy_mtgy_op_e118_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e118: val (Bit 0)                        */
#define mtgy_mtgy_op_e118_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e118: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e119  ====================================================== */
#define mtgy_mtgy_op_e119_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e119: val (Bit 0)                        */
#define mtgy_mtgy_op_e119_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e119: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e120  ====================================================== */
#define mtgy_mtgy_op_e120_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e120: val (Bit 0)                        */
#define mtgy_mtgy_op_e120_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e120: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e121  ====================================================== */
#define mtgy_mtgy_op_e121_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e121: val (Bit 0)                        */
#define mtgy_mtgy_op_e121_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e121: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e122  ====================================================== */
#define mtgy_mtgy_op_e122_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e122: val (Bit 0)                        */
#define mtgy_mtgy_op_e122_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e122: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e123  ====================================================== */
#define mtgy_mtgy_op_e123_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e123: val (Bit 0)                        */
#define mtgy_mtgy_op_e123_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e123: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e124  ====================================================== */
#define mtgy_mtgy_op_e124_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e124: val (Bit 0)                        */
#define mtgy_mtgy_op_e124_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e124: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e125  ====================================================== */
#define mtgy_mtgy_op_e125_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e125: val (Bit 0)                        */
#define mtgy_mtgy_op_e125_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e125: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e126  ====================================================== */
#define mtgy_mtgy_op_e126_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e126: val (Bit 0)                        */
#define mtgy_mtgy_op_e126_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e126: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_e127  ====================================================== */
#define mtgy_mtgy_op_e127_val_Pos         (0UL)                     /*!< mtgy mtgy_op_e127: val (Bit 0)                        */
#define mtgy_mtgy_op_e127_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_e127: val (Bitfield-Mask: 0xffffffff)    */
/* ======================================================  mtgy_op_x0  ======================================================= */
#define mtgy_mtgy_op_x0_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x0: val (Bit 0)                          */
#define mtgy_mtgy_op_x0_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x0: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x1  ======================================================= */
#define mtgy_mtgy_op_x1_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x1: val (Bit 0)                          */
#define mtgy_mtgy_op_x1_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x1: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x2  ======================================================= */
#define mtgy_mtgy_op_x2_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x2: val (Bit 0)                          */
#define mtgy_mtgy_op_x2_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x2: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x3  ======================================================= */
#define mtgy_mtgy_op_x3_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x3: val (Bit 0)                          */
#define mtgy_mtgy_op_x3_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x3: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x4  ======================================================= */
#define mtgy_mtgy_op_x4_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x4: val (Bit 0)                          */
#define mtgy_mtgy_op_x4_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x4: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x5  ======================================================= */
#define mtgy_mtgy_op_x5_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x5: val (Bit 0)                          */
#define mtgy_mtgy_op_x5_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x5: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x6  ======================================================= */
#define mtgy_mtgy_op_x6_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x6: val (Bit 0)                          */
#define mtgy_mtgy_op_x6_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x6: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x7  ======================================================= */
#define mtgy_mtgy_op_x7_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x7: val (Bit 0)                          */
#define mtgy_mtgy_op_x7_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x7: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x8  ======================================================= */
#define mtgy_mtgy_op_x8_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x8: val (Bit 0)                          */
#define mtgy_mtgy_op_x8_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x8: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x9  ======================================================= */
#define mtgy_mtgy_op_x9_val_Pos           (0UL)                     /*!< mtgy mtgy_op_x9: val (Bit 0)                          */
#define mtgy_mtgy_op_x9_val_Msk           (0xffffffffUL)            /*!< mtgy mtgy_op_x9: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  mtgy_op_x10  ====================================================== */
#define mtgy_mtgy_op_x10_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x10: val (Bit 0)                         */
#define mtgy_mtgy_op_x10_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x10: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x11  ====================================================== */
#define mtgy_mtgy_op_x11_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x11: val (Bit 0)                         */
#define mtgy_mtgy_op_x11_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x11: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x12  ====================================================== */
#define mtgy_mtgy_op_x12_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x12: val (Bit 0)                         */
#define mtgy_mtgy_op_x12_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x12: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x13  ====================================================== */
#define mtgy_mtgy_op_x13_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x13: val (Bit 0)                         */
#define mtgy_mtgy_op_x13_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x13: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x14  ====================================================== */
#define mtgy_mtgy_op_x14_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x14: val (Bit 0)                         */
#define mtgy_mtgy_op_x14_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x14: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x15  ====================================================== */
#define mtgy_mtgy_op_x15_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x15: val (Bit 0)                         */
#define mtgy_mtgy_op_x15_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x15: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x16  ====================================================== */
#define mtgy_mtgy_op_x16_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x16: val (Bit 0)                         */
#define mtgy_mtgy_op_x16_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x16: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x17  ====================================================== */
#define mtgy_mtgy_op_x17_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x17: val (Bit 0)                         */
#define mtgy_mtgy_op_x17_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x17: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x18  ====================================================== */
#define mtgy_mtgy_op_x18_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x18: val (Bit 0)                         */
#define mtgy_mtgy_op_x18_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x18: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x19  ====================================================== */
#define mtgy_mtgy_op_x19_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x19: val (Bit 0)                         */
#define mtgy_mtgy_op_x19_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x19: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x20  ====================================================== */
#define mtgy_mtgy_op_x20_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x20: val (Bit 0)                         */
#define mtgy_mtgy_op_x20_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x20: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x21  ====================================================== */
#define mtgy_mtgy_op_x21_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x21: val (Bit 0)                         */
#define mtgy_mtgy_op_x21_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x21: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x22  ====================================================== */
#define mtgy_mtgy_op_x22_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x22: val (Bit 0)                         */
#define mtgy_mtgy_op_x22_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x22: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x23  ====================================================== */
#define mtgy_mtgy_op_x23_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x23: val (Bit 0)                         */
#define mtgy_mtgy_op_x23_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x23: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x24  ====================================================== */
#define mtgy_mtgy_op_x24_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x24: val (Bit 0)                         */
#define mtgy_mtgy_op_x24_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x24: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x25  ====================================================== */
#define mtgy_mtgy_op_x25_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x25: val (Bit 0)                         */
#define mtgy_mtgy_op_x25_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x25: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x26  ====================================================== */
#define mtgy_mtgy_op_x26_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x26: val (Bit 0)                         */
#define mtgy_mtgy_op_x26_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x26: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x27  ====================================================== */
#define mtgy_mtgy_op_x27_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x27: val (Bit 0)                         */
#define mtgy_mtgy_op_x27_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x27: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x28  ====================================================== */
#define mtgy_mtgy_op_x28_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x28: val (Bit 0)                         */
#define mtgy_mtgy_op_x28_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x28: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x29  ====================================================== */
#define mtgy_mtgy_op_x29_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x29: val (Bit 0)                         */
#define mtgy_mtgy_op_x29_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x29: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x30  ====================================================== */
#define mtgy_mtgy_op_x30_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x30: val (Bit 0)                         */
#define mtgy_mtgy_op_x30_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x30: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x31  ====================================================== */
#define mtgy_mtgy_op_x31_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x31: val (Bit 0)                         */
#define mtgy_mtgy_op_x31_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x31: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x32  ====================================================== */
#define mtgy_mtgy_op_x32_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x32: val (Bit 0)                         */
#define mtgy_mtgy_op_x32_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x32: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x33  ====================================================== */
#define mtgy_mtgy_op_x33_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x33: val (Bit 0)                         */
#define mtgy_mtgy_op_x33_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x33: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x34  ====================================================== */
#define mtgy_mtgy_op_x34_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x34: val (Bit 0)                         */
#define mtgy_mtgy_op_x34_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x34: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x35  ====================================================== */
#define mtgy_mtgy_op_x35_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x35: val (Bit 0)                         */
#define mtgy_mtgy_op_x35_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x35: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x36  ====================================================== */
#define mtgy_mtgy_op_x36_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x36: val (Bit 0)                         */
#define mtgy_mtgy_op_x36_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x36: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x37  ====================================================== */
#define mtgy_mtgy_op_x37_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x37: val (Bit 0)                         */
#define mtgy_mtgy_op_x37_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x37: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x38  ====================================================== */
#define mtgy_mtgy_op_x38_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x38: val (Bit 0)                         */
#define mtgy_mtgy_op_x38_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x38: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x39  ====================================================== */
#define mtgy_mtgy_op_x39_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x39: val (Bit 0)                         */
#define mtgy_mtgy_op_x39_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x39: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x40  ====================================================== */
#define mtgy_mtgy_op_x40_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x40: val (Bit 0)                         */
#define mtgy_mtgy_op_x40_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x40: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x41  ====================================================== */
#define mtgy_mtgy_op_x41_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x41: val (Bit 0)                         */
#define mtgy_mtgy_op_x41_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x41: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x42  ====================================================== */
#define mtgy_mtgy_op_x42_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x42: val (Bit 0)                         */
#define mtgy_mtgy_op_x42_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x42: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x43  ====================================================== */
#define mtgy_mtgy_op_x43_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x43: val (Bit 0)                         */
#define mtgy_mtgy_op_x43_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x43: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x44  ====================================================== */
#define mtgy_mtgy_op_x44_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x44: val (Bit 0)                         */
#define mtgy_mtgy_op_x44_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x44: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x45  ====================================================== */
#define mtgy_mtgy_op_x45_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x45: val (Bit 0)                         */
#define mtgy_mtgy_op_x45_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x45: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x46  ====================================================== */
#define mtgy_mtgy_op_x46_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x46: val (Bit 0)                         */
#define mtgy_mtgy_op_x46_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x46: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x47  ====================================================== */
#define mtgy_mtgy_op_x47_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x47: val (Bit 0)                         */
#define mtgy_mtgy_op_x47_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x47: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x48  ====================================================== */
#define mtgy_mtgy_op_x48_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x48: val (Bit 0)                         */
#define mtgy_mtgy_op_x48_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x48: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x49  ====================================================== */
#define mtgy_mtgy_op_x49_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x49: val (Bit 0)                         */
#define mtgy_mtgy_op_x49_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x49: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x50  ====================================================== */
#define mtgy_mtgy_op_x50_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x50: val (Bit 0)                         */
#define mtgy_mtgy_op_x50_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x50: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x51  ====================================================== */
#define mtgy_mtgy_op_x51_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x51: val (Bit 0)                         */
#define mtgy_mtgy_op_x51_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x51: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x52  ====================================================== */
#define mtgy_mtgy_op_x52_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x52: val (Bit 0)                         */
#define mtgy_mtgy_op_x52_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x52: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x53  ====================================================== */
#define mtgy_mtgy_op_x53_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x53: val (Bit 0)                         */
#define mtgy_mtgy_op_x53_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x53: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x54  ====================================================== */
#define mtgy_mtgy_op_x54_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x54: val (Bit 0)                         */
#define mtgy_mtgy_op_x54_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x54: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x55  ====================================================== */
#define mtgy_mtgy_op_x55_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x55: val (Bit 0)                         */
#define mtgy_mtgy_op_x55_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x55: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x56  ====================================================== */
#define mtgy_mtgy_op_x56_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x56: val (Bit 0)                         */
#define mtgy_mtgy_op_x56_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x56: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x57  ====================================================== */
#define mtgy_mtgy_op_x57_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x57: val (Bit 0)                         */
#define mtgy_mtgy_op_x57_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x57: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x58  ====================================================== */
#define mtgy_mtgy_op_x58_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x58: val (Bit 0)                         */
#define mtgy_mtgy_op_x58_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x58: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x59  ====================================================== */
#define mtgy_mtgy_op_x59_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x59: val (Bit 0)                         */
#define mtgy_mtgy_op_x59_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x59: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x60  ====================================================== */
#define mtgy_mtgy_op_x60_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x60: val (Bit 0)                         */
#define mtgy_mtgy_op_x60_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x60: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x61  ====================================================== */
#define mtgy_mtgy_op_x61_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x61: val (Bit 0)                         */
#define mtgy_mtgy_op_x61_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x61: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x62  ====================================================== */
#define mtgy_mtgy_op_x62_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x62: val (Bit 0)                         */
#define mtgy_mtgy_op_x62_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x62: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x63  ====================================================== */
#define mtgy_mtgy_op_x63_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x63: val (Bit 0)                         */
#define mtgy_mtgy_op_x63_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x63: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x64  ====================================================== */
#define mtgy_mtgy_op_x64_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x64: val (Bit 0)                         */
#define mtgy_mtgy_op_x64_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x64: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x65  ====================================================== */
#define mtgy_mtgy_op_x65_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x65: val (Bit 0)                         */
#define mtgy_mtgy_op_x65_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x65: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x66  ====================================================== */
#define mtgy_mtgy_op_x66_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x66: val (Bit 0)                         */
#define mtgy_mtgy_op_x66_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x66: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x67  ====================================================== */
#define mtgy_mtgy_op_x67_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x67: val (Bit 0)                         */
#define mtgy_mtgy_op_x67_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x67: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x68  ====================================================== */
#define mtgy_mtgy_op_x68_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x68: val (Bit 0)                         */
#define mtgy_mtgy_op_x68_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x68: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x69  ====================================================== */
#define mtgy_mtgy_op_x69_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x69: val (Bit 0)                         */
#define mtgy_mtgy_op_x69_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x69: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x70  ====================================================== */
#define mtgy_mtgy_op_x70_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x70: val (Bit 0)                         */
#define mtgy_mtgy_op_x70_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x70: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x71  ====================================================== */
#define mtgy_mtgy_op_x71_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x71: val (Bit 0)                         */
#define mtgy_mtgy_op_x71_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x71: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x72  ====================================================== */
#define mtgy_mtgy_op_x72_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x72: val (Bit 0)                         */
#define mtgy_mtgy_op_x72_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x72: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x73  ====================================================== */
#define mtgy_mtgy_op_x73_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x73: val (Bit 0)                         */
#define mtgy_mtgy_op_x73_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x73: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x74  ====================================================== */
#define mtgy_mtgy_op_x74_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x74: val (Bit 0)                         */
#define mtgy_mtgy_op_x74_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x74: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x75  ====================================================== */
#define mtgy_mtgy_op_x75_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x75: val (Bit 0)                         */
#define mtgy_mtgy_op_x75_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x75: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x76  ====================================================== */
#define mtgy_mtgy_op_x76_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x76: val (Bit 0)                         */
#define mtgy_mtgy_op_x76_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x76: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x77  ====================================================== */
#define mtgy_mtgy_op_x77_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x77: val (Bit 0)                         */
#define mtgy_mtgy_op_x77_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x77: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x78  ====================================================== */
#define mtgy_mtgy_op_x78_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x78: val (Bit 0)                         */
#define mtgy_mtgy_op_x78_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x78: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x79  ====================================================== */
#define mtgy_mtgy_op_x79_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x79: val (Bit 0)                         */
#define mtgy_mtgy_op_x79_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x79: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x80  ====================================================== */
#define mtgy_mtgy_op_x80_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x80: val (Bit 0)                         */
#define mtgy_mtgy_op_x80_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x80: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x81  ====================================================== */
#define mtgy_mtgy_op_x81_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x81: val (Bit 0)                         */
#define mtgy_mtgy_op_x81_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x81: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x82  ====================================================== */
#define mtgy_mtgy_op_x82_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x82: val (Bit 0)                         */
#define mtgy_mtgy_op_x82_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x82: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x83  ====================================================== */
#define mtgy_mtgy_op_x83_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x83: val (Bit 0)                         */
#define mtgy_mtgy_op_x83_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x83: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x84  ====================================================== */
#define mtgy_mtgy_op_x84_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x84: val (Bit 0)                         */
#define mtgy_mtgy_op_x84_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x84: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x85  ====================================================== */
#define mtgy_mtgy_op_x85_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x85: val (Bit 0)                         */
#define mtgy_mtgy_op_x85_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x85: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x86  ====================================================== */
#define mtgy_mtgy_op_x86_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x86: val (Bit 0)                         */
#define mtgy_mtgy_op_x86_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x86: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x87  ====================================================== */
#define mtgy_mtgy_op_x87_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x87: val (Bit 0)                         */
#define mtgy_mtgy_op_x87_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x87: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x88  ====================================================== */
#define mtgy_mtgy_op_x88_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x88: val (Bit 0)                         */
#define mtgy_mtgy_op_x88_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x88: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x89  ====================================================== */
#define mtgy_mtgy_op_x89_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x89: val (Bit 0)                         */
#define mtgy_mtgy_op_x89_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x89: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x90  ====================================================== */
#define mtgy_mtgy_op_x90_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x90: val (Bit 0)                         */
#define mtgy_mtgy_op_x90_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x90: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x91  ====================================================== */
#define mtgy_mtgy_op_x91_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x91: val (Bit 0)                         */
#define mtgy_mtgy_op_x91_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x91: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x92  ====================================================== */
#define mtgy_mtgy_op_x92_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x92: val (Bit 0)                         */
#define mtgy_mtgy_op_x92_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x92: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x93  ====================================================== */
#define mtgy_mtgy_op_x93_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x93: val (Bit 0)                         */
#define mtgy_mtgy_op_x93_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x93: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x94  ====================================================== */
#define mtgy_mtgy_op_x94_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x94: val (Bit 0)                         */
#define mtgy_mtgy_op_x94_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x94: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x95  ====================================================== */
#define mtgy_mtgy_op_x95_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x95: val (Bit 0)                         */
#define mtgy_mtgy_op_x95_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x95: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x96  ====================================================== */
#define mtgy_mtgy_op_x96_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x96: val (Bit 0)                         */
#define mtgy_mtgy_op_x96_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x96: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x97  ====================================================== */
#define mtgy_mtgy_op_x97_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x97: val (Bit 0)                         */
#define mtgy_mtgy_op_x97_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x97: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x98  ====================================================== */
#define mtgy_mtgy_op_x98_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x98: val (Bit 0)                         */
#define mtgy_mtgy_op_x98_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x98: val (Bitfield-Mask: 0xffffffff)     */
/* ======================================================  mtgy_op_x99  ====================================================== */
#define mtgy_mtgy_op_x99_val_Pos          (0UL)                     /*!< mtgy mtgy_op_x99: val (Bit 0)                         */
#define mtgy_mtgy_op_x99_val_Msk          (0xffffffffUL)            /*!< mtgy mtgy_op_x99: val (Bitfield-Mask: 0xffffffff)     */
/* =====================================================  mtgy_op_x100  ====================================================== */
#define mtgy_mtgy_op_x100_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x100: val (Bit 0)                        */
#define mtgy_mtgy_op_x100_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x100: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x101  ====================================================== */
#define mtgy_mtgy_op_x101_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x101: val (Bit 0)                        */
#define mtgy_mtgy_op_x101_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x101: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x102  ====================================================== */
#define mtgy_mtgy_op_x102_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x102: val (Bit 0)                        */
#define mtgy_mtgy_op_x102_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x102: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x103  ====================================================== */
#define mtgy_mtgy_op_x103_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x103: val (Bit 0)                        */
#define mtgy_mtgy_op_x103_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x103: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x104  ====================================================== */
#define mtgy_mtgy_op_x104_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x104: val (Bit 0)                        */
#define mtgy_mtgy_op_x104_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x104: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x105  ====================================================== */
#define mtgy_mtgy_op_x105_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x105: val (Bit 0)                        */
#define mtgy_mtgy_op_x105_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x105: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x106  ====================================================== */
#define mtgy_mtgy_op_x106_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x106: val (Bit 0)                        */
#define mtgy_mtgy_op_x106_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x106: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x107  ====================================================== */
#define mtgy_mtgy_op_x107_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x107: val (Bit 0)                        */
#define mtgy_mtgy_op_x107_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x107: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x108  ====================================================== */
#define mtgy_mtgy_op_x108_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x108: val (Bit 0)                        */
#define mtgy_mtgy_op_x108_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x108: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x109  ====================================================== */
#define mtgy_mtgy_op_x109_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x109: val (Bit 0)                        */
#define mtgy_mtgy_op_x109_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x109: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x110  ====================================================== */
#define mtgy_mtgy_op_x110_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x110: val (Bit 0)                        */
#define mtgy_mtgy_op_x110_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x110: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x111  ====================================================== */
#define mtgy_mtgy_op_x111_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x111: val (Bit 0)                        */
#define mtgy_mtgy_op_x111_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x111: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x112  ====================================================== */
#define mtgy_mtgy_op_x112_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x112: val (Bit 0)                        */
#define mtgy_mtgy_op_x112_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x112: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x113  ====================================================== */
#define mtgy_mtgy_op_x113_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x113: val (Bit 0)                        */
#define mtgy_mtgy_op_x113_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x113: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x114  ====================================================== */
#define mtgy_mtgy_op_x114_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x114: val (Bit 0)                        */
#define mtgy_mtgy_op_x114_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x114: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x115  ====================================================== */
#define mtgy_mtgy_op_x115_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x115: val (Bit 0)                        */
#define mtgy_mtgy_op_x115_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x115: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x116  ====================================================== */
#define mtgy_mtgy_op_x116_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x116: val (Bit 0)                        */
#define mtgy_mtgy_op_x116_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x116: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x117  ====================================================== */
#define mtgy_mtgy_op_x117_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x117: val (Bit 0)                        */
#define mtgy_mtgy_op_x117_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x117: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x118  ====================================================== */
#define mtgy_mtgy_op_x118_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x118: val (Bit 0)                        */
#define mtgy_mtgy_op_x118_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x118: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x119  ====================================================== */
#define mtgy_mtgy_op_x119_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x119: val (Bit 0)                        */
#define mtgy_mtgy_op_x119_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x119: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x120  ====================================================== */
#define mtgy_mtgy_op_x120_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x120: val (Bit 0)                        */
#define mtgy_mtgy_op_x120_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x120: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x121  ====================================================== */
#define mtgy_mtgy_op_x121_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x121: val (Bit 0)                        */
#define mtgy_mtgy_op_x121_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x121: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x122  ====================================================== */
#define mtgy_mtgy_op_x122_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x122: val (Bit 0)                        */
#define mtgy_mtgy_op_x122_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x122: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x123  ====================================================== */
#define mtgy_mtgy_op_x123_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x123: val (Bit 0)                        */
#define mtgy_mtgy_op_x123_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x123: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x124  ====================================================== */
#define mtgy_mtgy_op_x124_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x124: val (Bit 0)                        */
#define mtgy_mtgy_op_x124_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x124: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x125  ====================================================== */
#define mtgy_mtgy_op_x125_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x125: val (Bit 0)                        */
#define mtgy_mtgy_op_x125_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x125: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x126  ====================================================== */
#define mtgy_mtgy_op_x126_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x126: val (Bit 0)                        */
#define mtgy_mtgy_op_x126_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x126: val (Bitfield-Mask: 0xffffffff)    */
/* =====================================================  mtgy_op_x127  ====================================================== */
#define mtgy_mtgy_op_x127_val_Pos         (0UL)                     /*!< mtgy mtgy_op_x127: val (Bit 0)                        */
#define mtgy_mtgy_op_x127_val_Msk         (0xffffffffUL)            /*!< mtgy mtgy_op_x127: val (Bitfield-Mask: 0xffffffff)    */


/* =========================================================================================================================== */
/* ================                                           nfifo                                           ================ */
/* =========================================================================================================================== */

/* =====================================================  nfifo_config  ====================================================== */
#define nfifo_nfifo_config_base_config_Pos (2UL)                    /*!< nfifo nfifo_config: base_config (Bit 2)               */
#define nfifo_nfifo_config_base_config_Msk (0xfffffffcUL)           /*!< nfifo nfifo_config: base_config (Bitfield-Mask: 0x3fffffff) */
#define nfifo_nfifo_config_reserved0_Pos  (0UL)                     /*!< nfifo nfifo_config: reserved0 (Bit 0)                 */
#define nfifo_nfifo_config_reserved0_Msk  (0x3UL)                   /*!< nfifo nfifo_config: reserved0 (Bitfield-Mask: 0x03)   */
/* =====================================================  nfifo_irq_raw  ===================================================== */
#define nfifo_nfifo_irq_raw_observe9_Pos  (13UL)                    /*!< nfifo nfifo_irq_raw: observe9 (Bit 13)                */
#define nfifo_nfifo_irq_raw_observe9_Msk  (0x2000UL)                /*!< nfifo nfifo_irq_raw: observe9 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe8_Pos  (12UL)                    /*!< nfifo nfifo_irq_raw: observe8 (Bit 12)                */
#define nfifo_nfifo_irq_raw_observe8_Msk  (0x1000UL)                /*!< nfifo nfifo_irq_raw: observe8 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe7_Pos  (11UL)                    /*!< nfifo nfifo_irq_raw: observe7 (Bit 11)                */
#define nfifo_nfifo_irq_raw_observe7_Msk  (0x800UL)                 /*!< nfifo nfifo_irq_raw: observe7 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe6_Pos  (10UL)                    /*!< nfifo nfifo_irq_raw: observe6 (Bit 10)                */
#define nfifo_nfifo_irq_raw_observe6_Msk  (0x400UL)                 /*!< nfifo nfifo_irq_raw: observe6 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe5_Pos  (9UL)                     /*!< nfifo nfifo_irq_raw: observe5 (Bit 9)                 */
#define nfifo_nfifo_irq_raw_observe5_Msk  (0x200UL)                 /*!< nfifo nfifo_irq_raw: observe5 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe4_Pos  (8UL)                     /*!< nfifo nfifo_irq_raw: observe4 (Bit 8)                 */
#define nfifo_nfifo_irq_raw_observe4_Msk  (0x100UL)                 /*!< nfifo nfifo_irq_raw: observe4 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe3_Pos  (7UL)                     /*!< nfifo nfifo_irq_raw: observe3 (Bit 7)                 */
#define nfifo_nfifo_irq_raw_observe3_Msk  (0x80UL)                  /*!< nfifo nfifo_irq_raw: observe3 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe2_Pos  (6UL)                     /*!< nfifo nfifo_irq_raw: observe2 (Bit 6)                 */
#define nfifo_nfifo_irq_raw_observe2_Msk  (0x40UL)                  /*!< nfifo nfifo_irq_raw: observe2 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe1_Pos  (5UL)                     /*!< nfifo nfifo_irq_raw: observe1 (Bit 5)                 */
#define nfifo_nfifo_irq_raw_observe1_Msk  (0x20UL)                  /*!< nfifo nfifo_irq_raw: observe1 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_observe0_Pos  (4UL)                     /*!< nfifo nfifo_irq_raw: observe0 (Bit 4)                 */
#define nfifo_nfifo_irq_raw_observe0_Msk  (0x10UL)                  /*!< nfifo nfifo_irq_raw: observe0 (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_raw_fifo_active_Pos (3UL)                   /*!< nfifo nfifo_irq_raw: fifo_active (Bit 3)              */
#define nfifo_nfifo_irq_raw_fifo_active_Msk (0x8UL)                 /*!< nfifo nfifo_irq_raw: fifo_active (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_raw_write_Pos     (2UL)                     /*!< nfifo nfifo_irq_raw: write (Bit 2)                    */
#define nfifo_nfifo_irq_raw_write_Msk     (0x4UL)                   /*!< nfifo nfifo_irq_raw: write (Bitfield-Mask: 0x01)      */
#define nfifo_nfifo_irq_raw_read_Pos      (1UL)                     /*!< nfifo nfifo_irq_raw: read (Bit 1)                     */
#define nfifo_nfifo_irq_raw_read_Msk      (0x2UL)                   /*!< nfifo nfifo_irq_raw: read (Bitfield-Mask: 0x01)       */
#define nfifo_nfifo_irq_raw_ahbl_error_Pos (0UL)                    /*!< nfifo nfifo_irq_raw: ahbl_error (Bit 0)               */
#define nfifo_nfifo_irq_raw_ahbl_error_Msk (0x1UL)                  /*!< nfifo nfifo_irq_raw: ahbl_error (Bitfield-Mask: 0x01) */
/* ===============================================  nfifo_irq_arm_app_masked  ================================================ */
#define nfifo_nfifo_irq_arm_app_masked_observe9_Pos (13UL)          /*!< nfifo nfifo_irq_arm_app_masked: observe9 (Bit 13)     */
#define nfifo_nfifo_irq_arm_app_masked_observe9_Msk (0x2000UL)      /*!< nfifo nfifo_irq_arm_app_masked: observe9 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe8_Pos (12UL)          /*!< nfifo nfifo_irq_arm_app_masked: observe8 (Bit 12)     */
#define nfifo_nfifo_irq_arm_app_masked_observe8_Msk (0x1000UL)      /*!< nfifo nfifo_irq_arm_app_masked: observe8 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe7_Pos (11UL)          /*!< nfifo nfifo_irq_arm_app_masked: observe7 (Bit 11)     */
#define nfifo_nfifo_irq_arm_app_masked_observe7_Msk (0x800UL)       /*!< nfifo nfifo_irq_arm_app_masked: observe7 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe6_Pos (10UL)          /*!< nfifo nfifo_irq_arm_app_masked: observe6 (Bit 10)     */
#define nfifo_nfifo_irq_arm_app_masked_observe6_Msk (0x400UL)       /*!< nfifo nfifo_irq_arm_app_masked: observe6 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe5_Pos (9UL)           /*!< nfifo nfifo_irq_arm_app_masked: observe5 (Bit 9)      */
#define nfifo_nfifo_irq_arm_app_masked_observe5_Msk (0x200UL)       /*!< nfifo nfifo_irq_arm_app_masked: observe5 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe4_Pos (8UL)           /*!< nfifo nfifo_irq_arm_app_masked: observe4 (Bit 8)      */
#define nfifo_nfifo_irq_arm_app_masked_observe4_Msk (0x100UL)       /*!< nfifo nfifo_irq_arm_app_masked: observe4 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe3_Pos (7UL)           /*!< nfifo nfifo_irq_arm_app_masked: observe3 (Bit 7)      */
#define nfifo_nfifo_irq_arm_app_masked_observe3_Msk (0x80UL)        /*!< nfifo nfifo_irq_arm_app_masked: observe3 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe2_Pos (6UL)           /*!< nfifo nfifo_irq_arm_app_masked: observe2 (Bit 6)      */
#define nfifo_nfifo_irq_arm_app_masked_observe2_Msk (0x40UL)        /*!< nfifo nfifo_irq_arm_app_masked: observe2 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe1_Pos (5UL)           /*!< nfifo nfifo_irq_arm_app_masked: observe1 (Bit 5)      */
#define nfifo_nfifo_irq_arm_app_masked_observe1_Msk (0x20UL)        /*!< nfifo nfifo_irq_arm_app_masked: observe1 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_observe0_Pos (4UL)           /*!< nfifo nfifo_irq_arm_app_masked: observe0 (Bit 4)      */
#define nfifo_nfifo_irq_arm_app_masked_observe0_Msk (0x10UL)        /*!< nfifo nfifo_irq_arm_app_masked: observe0 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_fifo_active_Pos (3UL)        /*!< nfifo nfifo_irq_arm_app_masked: fifo_active (Bit 3)   */
#define nfifo_nfifo_irq_arm_app_masked_fifo_active_Msk (0x8UL)      /*!< nfifo nfifo_irq_arm_app_masked: fifo_active (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_write_Pos (2UL)              /*!< nfifo nfifo_irq_arm_app_masked: write (Bit 2)         */
#define nfifo_nfifo_irq_arm_app_masked_write_Msk (0x4UL)            /*!< nfifo nfifo_irq_arm_app_masked: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_read_Pos (1UL)               /*!< nfifo nfifo_irq_arm_app_masked: read (Bit 1)          */
#define nfifo_nfifo_irq_arm_app_masked_read_Msk (0x2UL)             /*!< nfifo nfifo_irq_arm_app_masked: read (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_masked_ahbl_error_Pos (0UL)         /*!< nfifo nfifo_irq_arm_app_masked: ahbl_error (Bit 0)    */
#define nfifo_nfifo_irq_arm_app_masked_ahbl_error_Msk (0x1UL)       /*!< nfifo nfifo_irq_arm_app_masked: ahbl_error (Bitfield-Mask: 0x01) */
/* ===============================================  nfifo_irq_arm_app_msk_set  =============================================== */
#define nfifo_nfifo_irq_arm_app_msk_set_observe9_Pos (13UL)         /*!< nfifo nfifo_irq_arm_app_msk_set: observe9 (Bit 13)    */
#define nfifo_nfifo_irq_arm_app_msk_set_observe9_Msk (0x2000UL)     /*!< nfifo nfifo_irq_arm_app_msk_set: observe9 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe8_Pos (12UL)         /*!< nfifo nfifo_irq_arm_app_msk_set: observe8 (Bit 12)    */
#define nfifo_nfifo_irq_arm_app_msk_set_observe8_Msk (0x1000UL)     /*!< nfifo nfifo_irq_arm_app_msk_set: observe8 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe7_Pos (11UL)         /*!< nfifo nfifo_irq_arm_app_msk_set: observe7 (Bit 11)    */
#define nfifo_nfifo_irq_arm_app_msk_set_observe7_Msk (0x800UL)      /*!< nfifo nfifo_irq_arm_app_msk_set: observe7 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe6_Pos (10UL)         /*!< nfifo nfifo_irq_arm_app_msk_set: observe6 (Bit 10)    */
#define nfifo_nfifo_irq_arm_app_msk_set_observe6_Msk (0x400UL)      /*!< nfifo nfifo_irq_arm_app_msk_set: observe6 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe5_Pos (9UL)          /*!< nfifo nfifo_irq_arm_app_msk_set: observe5 (Bit 9)     */
#define nfifo_nfifo_irq_arm_app_msk_set_observe5_Msk (0x200UL)      /*!< nfifo nfifo_irq_arm_app_msk_set: observe5 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe4_Pos (8UL)          /*!< nfifo nfifo_irq_arm_app_msk_set: observe4 (Bit 8)     */
#define nfifo_nfifo_irq_arm_app_msk_set_observe4_Msk (0x100UL)      /*!< nfifo nfifo_irq_arm_app_msk_set: observe4 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe3_Pos (7UL)          /*!< nfifo nfifo_irq_arm_app_msk_set: observe3 (Bit 7)     */
#define nfifo_nfifo_irq_arm_app_msk_set_observe3_Msk (0x80UL)       /*!< nfifo nfifo_irq_arm_app_msk_set: observe3 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe2_Pos (6UL)          /*!< nfifo nfifo_irq_arm_app_msk_set: observe2 (Bit 6)     */
#define nfifo_nfifo_irq_arm_app_msk_set_observe2_Msk (0x40UL)       /*!< nfifo nfifo_irq_arm_app_msk_set: observe2 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe1_Pos (5UL)          /*!< nfifo nfifo_irq_arm_app_msk_set: observe1 (Bit 5)     */
#define nfifo_nfifo_irq_arm_app_msk_set_observe1_Msk (0x20UL)       /*!< nfifo nfifo_irq_arm_app_msk_set: observe1 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_observe0_Pos (4UL)          /*!< nfifo nfifo_irq_arm_app_msk_set: observe0 (Bit 4)     */
#define nfifo_nfifo_irq_arm_app_msk_set_observe0_Msk (0x10UL)       /*!< nfifo nfifo_irq_arm_app_msk_set: observe0 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_fifo_active_Pos (3UL)       /*!< nfifo nfifo_irq_arm_app_msk_set: fifo_active (Bit 3)  */
#define nfifo_nfifo_irq_arm_app_msk_set_fifo_active_Msk (0x8UL)     /*!< nfifo nfifo_irq_arm_app_msk_set: fifo_active (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_write_Pos (2UL)             /*!< nfifo nfifo_irq_arm_app_msk_set: write (Bit 2)        */
#define nfifo_nfifo_irq_arm_app_msk_set_write_Msk (0x4UL)           /*!< nfifo nfifo_irq_arm_app_msk_set: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_read_Pos (1UL)              /*!< nfifo nfifo_irq_arm_app_msk_set: read (Bit 1)         */
#define nfifo_nfifo_irq_arm_app_msk_set_read_Msk (0x2UL)            /*!< nfifo nfifo_irq_arm_app_msk_set: read (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_set_ahbl_error_Pos (0UL)        /*!< nfifo nfifo_irq_arm_app_msk_set: ahbl_error (Bit 0)   */
#define nfifo_nfifo_irq_arm_app_msk_set_ahbl_error_Msk (0x1UL)      /*!< nfifo nfifo_irq_arm_app_msk_set: ahbl_error (Bitfield-Mask: 0x01) */
/* ==============================================  nfifo_irq_arm_app_msk_reset  ============================================== */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe9_Pos (13UL)       /*!< nfifo nfifo_irq_arm_app_msk_reset: observe9 (Bit 13)  */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe9_Msk (0x2000UL)   /*!< nfifo nfifo_irq_arm_app_msk_reset: observe9 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe8_Pos (12UL)       /*!< nfifo nfifo_irq_arm_app_msk_reset: observe8 (Bit 12)  */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe8_Msk (0x1000UL)   /*!< nfifo nfifo_irq_arm_app_msk_reset: observe8 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe7_Pos (11UL)       /*!< nfifo nfifo_irq_arm_app_msk_reset: observe7 (Bit 11)  */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe7_Msk (0x800UL)    /*!< nfifo nfifo_irq_arm_app_msk_reset: observe7 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe6_Pos (10UL)       /*!< nfifo nfifo_irq_arm_app_msk_reset: observe6 (Bit 10)  */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe6_Msk (0x400UL)    /*!< nfifo nfifo_irq_arm_app_msk_reset: observe6 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe5_Pos (9UL)        /*!< nfifo nfifo_irq_arm_app_msk_reset: observe5 (Bit 9)   */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe5_Msk (0x200UL)    /*!< nfifo nfifo_irq_arm_app_msk_reset: observe5 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe4_Pos (8UL)        /*!< nfifo nfifo_irq_arm_app_msk_reset: observe4 (Bit 8)   */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe4_Msk (0x100UL)    /*!< nfifo nfifo_irq_arm_app_msk_reset: observe4 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe3_Pos (7UL)        /*!< nfifo nfifo_irq_arm_app_msk_reset: observe3 (Bit 7)   */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe3_Msk (0x80UL)     /*!< nfifo nfifo_irq_arm_app_msk_reset: observe3 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe2_Pos (6UL)        /*!< nfifo nfifo_irq_arm_app_msk_reset: observe2 (Bit 6)   */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe2_Msk (0x40UL)     /*!< nfifo nfifo_irq_arm_app_msk_reset: observe2 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe1_Pos (5UL)        /*!< nfifo nfifo_irq_arm_app_msk_reset: observe1 (Bit 5)   */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe1_Msk (0x20UL)     /*!< nfifo nfifo_irq_arm_app_msk_reset: observe1 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe0_Pos (4UL)        /*!< nfifo nfifo_irq_arm_app_msk_reset: observe0 (Bit 4)   */
#define nfifo_nfifo_irq_arm_app_msk_reset_observe0_Msk (0x10UL)     /*!< nfifo nfifo_irq_arm_app_msk_reset: observe0 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_fifo_active_Pos (3UL)     /*!< nfifo nfifo_irq_arm_app_msk_reset: fifo_active (Bit 3) */
#define nfifo_nfifo_irq_arm_app_msk_reset_fifo_active_Msk (0x8UL)   /*!< nfifo nfifo_irq_arm_app_msk_reset: fifo_active (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_write_Pos (2UL)           /*!< nfifo nfifo_irq_arm_app_msk_reset: write (Bit 2)      */
#define nfifo_nfifo_irq_arm_app_msk_reset_write_Msk (0x4UL)         /*!< nfifo nfifo_irq_arm_app_msk_reset: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_read_Pos (1UL)            /*!< nfifo nfifo_irq_arm_app_msk_reset: read (Bit 1)       */
#define nfifo_nfifo_irq_arm_app_msk_reset_read_Msk (0x2UL)          /*!< nfifo nfifo_irq_arm_app_msk_reset: read (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_arm_app_msk_reset_ahbl_error_Pos (0UL)      /*!< nfifo nfifo_irq_arm_app_msk_reset: ahbl_error (Bit 0) */
#define nfifo_nfifo_irq_arm_app_msk_reset_ahbl_error_Msk (0x1UL)    /*!< nfifo nfifo_irq_arm_app_msk_reset: ahbl_error (Bitfield-Mask: 0x01) */
/* ===============================================  nfifo_irq_xpic_app_masked  =============================================== */
#define nfifo_nfifo_irq_xpic_app_masked_observe9_Pos (13UL)         /*!< nfifo nfifo_irq_xpic_app_masked: observe9 (Bit 13)    */
#define nfifo_nfifo_irq_xpic_app_masked_observe9_Msk (0x2000UL)     /*!< nfifo nfifo_irq_xpic_app_masked: observe9 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe8_Pos (12UL)         /*!< nfifo nfifo_irq_xpic_app_masked: observe8 (Bit 12)    */
#define nfifo_nfifo_irq_xpic_app_masked_observe8_Msk (0x1000UL)     /*!< nfifo nfifo_irq_xpic_app_masked: observe8 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe7_Pos (11UL)         /*!< nfifo nfifo_irq_xpic_app_masked: observe7 (Bit 11)    */
#define nfifo_nfifo_irq_xpic_app_masked_observe7_Msk (0x800UL)      /*!< nfifo nfifo_irq_xpic_app_masked: observe7 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe6_Pos (10UL)         /*!< nfifo nfifo_irq_xpic_app_masked: observe6 (Bit 10)    */
#define nfifo_nfifo_irq_xpic_app_masked_observe6_Msk (0x400UL)      /*!< nfifo nfifo_irq_xpic_app_masked: observe6 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe5_Pos (9UL)          /*!< nfifo nfifo_irq_xpic_app_masked: observe5 (Bit 9)     */
#define nfifo_nfifo_irq_xpic_app_masked_observe5_Msk (0x200UL)      /*!< nfifo nfifo_irq_xpic_app_masked: observe5 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe4_Pos (8UL)          /*!< nfifo nfifo_irq_xpic_app_masked: observe4 (Bit 8)     */
#define nfifo_nfifo_irq_xpic_app_masked_observe4_Msk (0x100UL)      /*!< nfifo nfifo_irq_xpic_app_masked: observe4 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe3_Pos (7UL)          /*!< nfifo nfifo_irq_xpic_app_masked: observe3 (Bit 7)     */
#define nfifo_nfifo_irq_xpic_app_masked_observe3_Msk (0x80UL)       /*!< nfifo nfifo_irq_xpic_app_masked: observe3 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe2_Pos (6UL)          /*!< nfifo nfifo_irq_xpic_app_masked: observe2 (Bit 6)     */
#define nfifo_nfifo_irq_xpic_app_masked_observe2_Msk (0x40UL)       /*!< nfifo nfifo_irq_xpic_app_masked: observe2 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe1_Pos (5UL)          /*!< nfifo nfifo_irq_xpic_app_masked: observe1 (Bit 5)     */
#define nfifo_nfifo_irq_xpic_app_masked_observe1_Msk (0x20UL)       /*!< nfifo nfifo_irq_xpic_app_masked: observe1 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_observe0_Pos (4UL)          /*!< nfifo nfifo_irq_xpic_app_masked: observe0 (Bit 4)     */
#define nfifo_nfifo_irq_xpic_app_masked_observe0_Msk (0x10UL)       /*!< nfifo nfifo_irq_xpic_app_masked: observe0 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_fifo_active_Pos (3UL)       /*!< nfifo nfifo_irq_xpic_app_masked: fifo_active (Bit 3)  */
#define nfifo_nfifo_irq_xpic_app_masked_fifo_active_Msk (0x8UL)     /*!< nfifo nfifo_irq_xpic_app_masked: fifo_active (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_write_Pos (2UL)             /*!< nfifo nfifo_irq_xpic_app_masked: write (Bit 2)        */
#define nfifo_nfifo_irq_xpic_app_masked_write_Msk (0x4UL)           /*!< nfifo nfifo_irq_xpic_app_masked: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_read_Pos (1UL)              /*!< nfifo nfifo_irq_xpic_app_masked: read (Bit 1)         */
#define nfifo_nfifo_irq_xpic_app_masked_read_Msk (0x2UL)            /*!< nfifo nfifo_irq_xpic_app_masked: read (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_masked_ahbl_error_Pos (0UL)        /*!< nfifo nfifo_irq_xpic_app_masked: ahbl_error (Bit 0)   */
#define nfifo_nfifo_irq_xpic_app_masked_ahbl_error_Msk (0x1UL)      /*!< nfifo nfifo_irq_xpic_app_masked: ahbl_error (Bitfield-Mask: 0x01) */
/* ==============================================  nfifo_irq_xpic_app_msk_set  =============================================== */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe9_Pos (13UL)        /*!< nfifo nfifo_irq_xpic_app_msk_set: observe9 (Bit 13)   */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe9_Msk (0x2000UL)    /*!< nfifo nfifo_irq_xpic_app_msk_set: observe9 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe8_Pos (12UL)        /*!< nfifo nfifo_irq_xpic_app_msk_set: observe8 (Bit 12)   */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe8_Msk (0x1000UL)    /*!< nfifo nfifo_irq_xpic_app_msk_set: observe8 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe7_Pos (11UL)        /*!< nfifo nfifo_irq_xpic_app_msk_set: observe7 (Bit 11)   */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe7_Msk (0x800UL)     /*!< nfifo nfifo_irq_xpic_app_msk_set: observe7 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe6_Pos (10UL)        /*!< nfifo nfifo_irq_xpic_app_msk_set: observe6 (Bit 10)   */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe6_Msk (0x400UL)     /*!< nfifo nfifo_irq_xpic_app_msk_set: observe6 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe5_Pos (9UL)         /*!< nfifo nfifo_irq_xpic_app_msk_set: observe5 (Bit 9)    */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe5_Msk (0x200UL)     /*!< nfifo nfifo_irq_xpic_app_msk_set: observe5 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe4_Pos (8UL)         /*!< nfifo nfifo_irq_xpic_app_msk_set: observe4 (Bit 8)    */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe4_Msk (0x100UL)     /*!< nfifo nfifo_irq_xpic_app_msk_set: observe4 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe3_Pos (7UL)         /*!< nfifo nfifo_irq_xpic_app_msk_set: observe3 (Bit 7)    */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe3_Msk (0x80UL)      /*!< nfifo nfifo_irq_xpic_app_msk_set: observe3 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe2_Pos (6UL)         /*!< nfifo nfifo_irq_xpic_app_msk_set: observe2 (Bit 6)    */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe2_Msk (0x40UL)      /*!< nfifo nfifo_irq_xpic_app_msk_set: observe2 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe1_Pos (5UL)         /*!< nfifo nfifo_irq_xpic_app_msk_set: observe1 (Bit 5)    */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe1_Msk (0x20UL)      /*!< nfifo nfifo_irq_xpic_app_msk_set: observe1 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe0_Pos (4UL)         /*!< nfifo nfifo_irq_xpic_app_msk_set: observe0 (Bit 4)    */
#define nfifo_nfifo_irq_xpic_app_msk_set_observe0_Msk (0x10UL)      /*!< nfifo nfifo_irq_xpic_app_msk_set: observe0 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_fifo_active_Pos (3UL)      /*!< nfifo nfifo_irq_xpic_app_msk_set: fifo_active (Bit 3) */
#define nfifo_nfifo_irq_xpic_app_msk_set_fifo_active_Msk (0x8UL)    /*!< nfifo nfifo_irq_xpic_app_msk_set: fifo_active (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_write_Pos (2UL)            /*!< nfifo nfifo_irq_xpic_app_msk_set: write (Bit 2)       */
#define nfifo_nfifo_irq_xpic_app_msk_set_write_Msk (0x4UL)          /*!< nfifo nfifo_irq_xpic_app_msk_set: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_read_Pos (1UL)             /*!< nfifo nfifo_irq_xpic_app_msk_set: read (Bit 1)        */
#define nfifo_nfifo_irq_xpic_app_msk_set_read_Msk (0x2UL)           /*!< nfifo nfifo_irq_xpic_app_msk_set: read (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_set_ahbl_error_Pos (0UL)       /*!< nfifo nfifo_irq_xpic_app_msk_set: ahbl_error (Bit 0)  */
#define nfifo_nfifo_irq_xpic_app_msk_set_ahbl_error_Msk (0x1UL)     /*!< nfifo nfifo_irq_xpic_app_msk_set: ahbl_error (Bitfield-Mask: 0x01) */
/* =============================================  nfifo_irq_xpic_app_msk_reset  ============================================== */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe9_Pos (13UL)      /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe9 (Bit 13) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe9_Msk (0x2000UL)  /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe9 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe8_Pos (12UL)      /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe8 (Bit 12) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe8_Msk (0x1000UL)  /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe8 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe7_Pos (11UL)      /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe7 (Bit 11) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe7_Msk (0x800UL)   /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe7 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe6_Pos (10UL)      /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe6 (Bit 10) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe6_Msk (0x400UL)   /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe6 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe5_Pos (9UL)       /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe5 (Bit 9)  */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe5_Msk (0x200UL)   /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe5 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe4_Pos (8UL)       /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe4 (Bit 8)  */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe4_Msk (0x100UL)   /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe4 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe3_Pos (7UL)       /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe3 (Bit 7)  */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe3_Msk (0x80UL)    /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe3 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe2_Pos (6UL)       /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe2 (Bit 6)  */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe2_Msk (0x40UL)    /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe2 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe1_Pos (5UL)       /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe1 (Bit 5)  */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe1_Msk (0x20UL)    /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe1 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe0_Pos (4UL)       /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe0 (Bit 4)  */
#define nfifo_nfifo_irq_xpic_app_msk_reset_observe0_Msk (0x10UL)    /*!< nfifo nfifo_irq_xpic_app_msk_reset: observe0 (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_fifo_active_Pos (3UL)    /*!< nfifo nfifo_irq_xpic_app_msk_reset: fifo_active (Bit 3) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_fifo_active_Msk (0x8UL)  /*!< nfifo nfifo_irq_xpic_app_msk_reset: fifo_active (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_write_Pos (2UL)          /*!< nfifo nfifo_irq_xpic_app_msk_reset: write (Bit 2)     */
#define nfifo_nfifo_irq_xpic_app_msk_reset_write_Msk (0x4UL)        /*!< nfifo nfifo_irq_xpic_app_msk_reset: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_read_Pos (1UL)           /*!< nfifo nfifo_irq_xpic_app_msk_reset: read (Bit 1)      */
#define nfifo_nfifo_irq_xpic_app_msk_reset_read_Msk (0x2UL)         /*!< nfifo nfifo_irq_xpic_app_msk_reset: read (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_ahbl_error_Pos (0UL)     /*!< nfifo nfifo_irq_xpic_app_msk_reset: ahbl_error (Bit 0) */
#define nfifo_nfifo_irq_xpic_app_msk_reset_ahbl_error_Msk (0x1UL)   /*!< nfifo nfifo_irq_xpic_app_msk_reset: ahbl_error (Bitfield-Mask: 0x01) */
/* ==================================================  nfifo_irq_observe0  =================================================== */
#define nfifo_nfifo_irq_observe0_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe0: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe0_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe0: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe0_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe0: full (Bit 22)               */
#define nfifo_nfifo_irq_observe0_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe0: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe0_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe0: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe0_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe0: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe0_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe0: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe0_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe0: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe0_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe0: write (Bit 19)              */
#define nfifo_nfifo_irq_observe0_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe0: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe0_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe0: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe0_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe0: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe0_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe0: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe0_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe0: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe0_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe0: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe0_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe0: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe0_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe0: read (Bit 15)               */
#define nfifo_nfifo_irq_observe0_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe0: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe0_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe0: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe0_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe0: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe0_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe0: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe0_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe0: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe1  =================================================== */
#define nfifo_nfifo_irq_observe1_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe1: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe1_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe1: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe1_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe1: full (Bit 22)               */
#define nfifo_nfifo_irq_observe1_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe1: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe1_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe1: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe1_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe1: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe1_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe1: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe1_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe1: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe1_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe1: write (Bit 19)              */
#define nfifo_nfifo_irq_observe1_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe1: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe1_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe1: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe1_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe1: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe1_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe1: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe1_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe1: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe1_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe1: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe1_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe1: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe1_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe1: read (Bit 15)               */
#define nfifo_nfifo_irq_observe1_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe1: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe1_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe1: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe1_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe1: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe1_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe1: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe1_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe1: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe2  =================================================== */
#define nfifo_nfifo_irq_observe2_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe2: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe2_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe2: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe2_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe2: full (Bit 22)               */
#define nfifo_nfifo_irq_observe2_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe2: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe2_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe2: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe2_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe2: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe2_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe2: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe2_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe2: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe2_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe2: write (Bit 19)              */
#define nfifo_nfifo_irq_observe2_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe2: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe2_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe2: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe2_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe2: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe2_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe2: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe2_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe2: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe2_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe2: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe2_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe2: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe2_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe2: read (Bit 15)               */
#define nfifo_nfifo_irq_observe2_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe2: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe2_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe2: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe2_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe2: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe2_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe2: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe2_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe2: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe3  =================================================== */
#define nfifo_nfifo_irq_observe3_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe3: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe3_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe3: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe3_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe3: full (Bit 22)               */
#define nfifo_nfifo_irq_observe3_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe3: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe3_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe3: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe3_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe3: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe3_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe3: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe3_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe3: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe3_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe3: write (Bit 19)              */
#define nfifo_nfifo_irq_observe3_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe3: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe3_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe3: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe3_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe3: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe3_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe3: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe3_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe3: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe3_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe3: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe3_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe3: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe3_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe3: read (Bit 15)               */
#define nfifo_nfifo_irq_observe3_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe3: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe3_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe3: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe3_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe3: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe3_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe3: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe3_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe3: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe4  =================================================== */
#define nfifo_nfifo_irq_observe4_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe4: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe4_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe4: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe4_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe4: full (Bit 22)               */
#define nfifo_nfifo_irq_observe4_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe4: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe4_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe4: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe4_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe4: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe4_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe4: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe4_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe4: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe4_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe4: write (Bit 19)              */
#define nfifo_nfifo_irq_observe4_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe4: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe4_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe4: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe4_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe4: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe4_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe4: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe4_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe4: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe4_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe4: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe4_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe4: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe4_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe4: read (Bit 15)               */
#define nfifo_nfifo_irq_observe4_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe4: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe4_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe4: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe4_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe4: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe4_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe4: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe4_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe4: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe5  =================================================== */
#define nfifo_nfifo_irq_observe5_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe5: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe5_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe5: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe5_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe5: full (Bit 22)               */
#define nfifo_nfifo_irq_observe5_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe5: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe5_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe5: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe5_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe5: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe5_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe5: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe5_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe5: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe5_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe5: write (Bit 19)              */
#define nfifo_nfifo_irq_observe5_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe5: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe5_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe5: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe5_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe5: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe5_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe5: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe5_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe5: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe5_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe5: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe5_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe5: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe5_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe5: read (Bit 15)               */
#define nfifo_nfifo_irq_observe5_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe5: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe5_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe5: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe5_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe5: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe5_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe5: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe5_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe5: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe6  =================================================== */
#define nfifo_nfifo_irq_observe6_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe6: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe6_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe6: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe6_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe6: full (Bit 22)               */
#define nfifo_nfifo_irq_observe6_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe6: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe6_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe6: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe6_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe6: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe6_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe6: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe6_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe6: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe6_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe6: write (Bit 19)              */
#define nfifo_nfifo_irq_observe6_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe6: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe6_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe6: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe6_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe6: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe6_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe6: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe6_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe6: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe6_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe6: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe6_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe6: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe6_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe6: read (Bit 15)               */
#define nfifo_nfifo_irq_observe6_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe6: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe6_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe6: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe6_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe6: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe6_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe6: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe6_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe6: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe7  =================================================== */
#define nfifo_nfifo_irq_observe7_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe7: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe7_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe7: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe7_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe7: full (Bit 22)               */
#define nfifo_nfifo_irq_observe7_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe7: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe7_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe7: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe7_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe7: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe7_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe7: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe7_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe7: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe7_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe7: write (Bit 19)              */
#define nfifo_nfifo_irq_observe7_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe7: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe7_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe7: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe7_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe7: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe7_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe7: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe7_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe7: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe7_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe7: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe7_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe7: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe7_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe7: read (Bit 15)               */
#define nfifo_nfifo_irq_observe7_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe7: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe7_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe7: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe7_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe7: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe7_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe7: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe7_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe7: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe8  =================================================== */
#define nfifo_nfifo_irq_observe8_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe8: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe8_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe8: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe8_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe8: full (Bit 22)               */
#define nfifo_nfifo_irq_observe8_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe8: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe8_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe8: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe8_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe8: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe8_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe8: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe8_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe8: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe8_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe8: write (Bit 19)              */
#define nfifo_nfifo_irq_observe8_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe8: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe8_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe8: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe8_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe8: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe8_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe8: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe8_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe8: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe8_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe8: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe8_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe8: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe8_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe8: read (Bit 15)               */
#define nfifo_nfifo_irq_observe8_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe8: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe8_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe8: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe8_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe8: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe8_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe8: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe8_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe8: fifonr (Bitfield-Mask: 0x3ff) */
/* ==================================================  nfifo_irq_observe9  =================================================== */
#define nfifo_nfifo_irq_observe9_reserved1_Pos (23UL)               /*!< nfifo nfifo_irq_observe9: reserved1 (Bit 23)          */
#define nfifo_nfifo_irq_observe9_reserved1_Msk (0xff800000UL)       /*!< nfifo nfifo_irq_observe9: reserved1 (Bitfield-Mask: 0x1ff) */
#define nfifo_nfifo_irq_observe9_full_Pos (22UL)                    /*!< nfifo nfifo_irq_observe9: full (Bit 22)               */
#define nfifo_nfifo_irq_observe9_full_Msk (0x400000UL)              /*!< nfifo nfifo_irq_observe9: full (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe9_fmw_Pos  (21UL)                    /*!< nfifo nfifo_irq_observe9: fmw (Bit 21)                */
#define nfifo_nfifo_irq_observe9_fmw_Msk  (0x200000UL)              /*!< nfifo nfifo_irq_observe9: fmw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe9_ovfl_Pos (20UL)                    /*!< nfifo nfifo_irq_observe9: ovfl (Bit 20)               */
#define nfifo_nfifo_irq_observe9_ovfl_Msk (0x100000UL)              /*!< nfifo nfifo_irq_observe9: ovfl (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe9_write_Pos (19UL)                   /*!< nfifo nfifo_irq_observe9: write (Bit 19)              */
#define nfifo_nfifo_irq_observe9_write_Msk (0x80000UL)              /*!< nfifo nfifo_irq_observe9: write (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe9_empty_Pos (18UL)                   /*!< nfifo nfifo_irq_observe9: empty (Bit 18)              */
#define nfifo_nfifo_irq_observe9_empty_Msk (0x40000UL)              /*!< nfifo nfifo_irq_observe9: empty (Bitfield-Mask: 0x01) */
#define nfifo_nfifo_irq_observe9_emw_Pos  (17UL)                    /*!< nfifo nfifo_irq_observe9: emw (Bit 17)                */
#define nfifo_nfifo_irq_observe9_emw_Msk  (0x20000UL)               /*!< nfifo nfifo_irq_observe9: emw (Bitfield-Mask: 0x01)   */
#define nfifo_nfifo_irq_observe9_undr_Pos (16UL)                    /*!< nfifo nfifo_irq_observe9: undr (Bit 16)               */
#define nfifo_nfifo_irq_observe9_undr_Msk (0x10000UL)               /*!< nfifo nfifo_irq_observe9: undr (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe9_read_Pos (15UL)                    /*!< nfifo nfifo_irq_observe9: read (Bit 15)               */
#define nfifo_nfifo_irq_observe9_read_Msk (0x8000UL)                /*!< nfifo nfifo_irq_observe9: read (Bitfield-Mask: 0x01)  */
#define nfifo_nfifo_irq_observe9_reserved0_Pos (10UL)               /*!< nfifo nfifo_irq_observe9: reserved0 (Bit 10)          */
#define nfifo_nfifo_irq_observe9_reserved0_Msk (0x7c00UL)           /*!< nfifo nfifo_irq_observe9: reserved0 (Bitfield-Mask: 0x1f) */
#define nfifo_nfifo_irq_observe9_fifonr_Pos (0UL)                   /*!< nfifo nfifo_irq_observe9: fifonr (Bit 0)              */
#define nfifo_nfifo_irq_observe9_fifonr_Msk (0x3ffUL)               /*!< nfifo nfifo_irq_observe9: fifonr (Bitfield-Mask: 0x3ff) */
/* ===================================================  nfifo_fifo_start  ==================================================== */
/* ====================================================  nfifo_fifo_end  ===================================================== */


/* =========================================================================================================================== */
/* ================                                         pad_ctrl                                          ================ */
/* =========================================================================================================================== */

/* ====================================================  pad_ctrl_rdy_n  ===================================================== */
#define pad_ctrl_pad_ctrl_rdy_n_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_rdy_n: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_rdy_n_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_rdy_n: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_rdy_n_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_rdy_n: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_rdy_n_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_rdy_n: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_rdy_n_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_rdy_n: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_rdy_n_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_rdy_n: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_rdy_n_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_rdy_n: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_rdy_n_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_rdy_n: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_rdy_n_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_rdy_n: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_rdy_n_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_rdy_n: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_rdy_n_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_rdy_n: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_rdy_n_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_rdy_n: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_run_n  ===================================================== */
#define pad_ctrl_pad_ctrl_run_n_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_run_n: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_run_n_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_run_n: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_run_n_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_run_n: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_run_n_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_run_n: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_run_n_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_run_n: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_run_n_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_run_n: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_run_n_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_run_n: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_run_n_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_run_n: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_run_n_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_run_n: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_run_n_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_run_n: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_run_n_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_run_n: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_run_n_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_run_n: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mled0  ===================================================== */
#define pad_ctrl_pad_ctrl_mled0_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mled0: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mled0_reserved1_Msk (0xffffffe0UL)        /*!< pad_ctrl pad_ctrl_mled0: reserved1 (Bitfield-Mask: 0x7ffffff) */
#define pad_ctrl_pad_ctrl_mled0_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mled0: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mled0_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mled0: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mled0_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mled0: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mled0_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mled0: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mled0_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mled0: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mled0_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mled0: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mled1  ===================================================== */
#define pad_ctrl_pad_ctrl_mled1_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mled1: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mled1_reserved1_Msk (0xffffffe0UL)        /*!< pad_ctrl pad_ctrl_mled1: reserved1 (Bitfield-Mask: 0x7ffffff) */
#define pad_ctrl_pad_ctrl_mled1_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mled1: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mled1_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mled1: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mled1_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mled1: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mled1_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mled1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mled1_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mled1: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mled1_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mled1: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mled2  ===================================================== */
#define pad_ctrl_pad_ctrl_mled2_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mled2: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mled2_reserved1_Msk (0xffffffe0UL)        /*!< pad_ctrl pad_ctrl_mled2: reserved1 (Bitfield-Mask: 0x7ffffff) */
#define pad_ctrl_pad_ctrl_mled2_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mled2: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mled2_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mled2: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mled2_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mled2: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mled2_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mled2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mled2_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mled2: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mled2_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mled2: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mled3  ===================================================== */
#define pad_ctrl_pad_ctrl_mled3_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mled3: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mled3_reserved1_Msk (0xffffffe0UL)        /*!< pad_ctrl pad_ctrl_mled3: reserved1 (Bitfield-Mask: 0x7ffffff) */
#define pad_ctrl_pad_ctrl_mled3_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mled3: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mled3_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mled3: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mled3_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mled3: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mled3_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mled3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mled3_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mled3: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mled3_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mled3: ds (Bitfield-Mask: 0x01)     */
/* ===================================================  pad_ctrl_com_io0  ==================================================== */
#define pad_ctrl_pad_ctrl_com_io0_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_com_io0: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_com_io0_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_com_io0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_com_io0_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_com_io0: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_com_io0_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_com_io0: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io0_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_com_io0: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_com_io0_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_com_io0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_com_io0_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_com_io0: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_com_io0_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_com_io0: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io0_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_com_io0: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_com_io0_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_com_io0: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_com_io0_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_com_io0: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_com_io0_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_com_io0: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_com_io1  ==================================================== */
#define pad_ctrl_pad_ctrl_com_io1_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_com_io1: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_com_io1_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_com_io1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_com_io1_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_com_io1: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_com_io1_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_com_io1: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io1_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_com_io1: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_com_io1_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_com_io1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_com_io1_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_com_io1: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_com_io1_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_com_io1: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io1_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_com_io1: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_com_io1_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_com_io1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_com_io1_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_com_io1: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_com_io1_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_com_io1: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_com_io2  ==================================================== */
#define pad_ctrl_pad_ctrl_com_io2_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_com_io2: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_com_io2_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_com_io2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_com_io2_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_com_io2: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_com_io2_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_com_io2: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io2_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_com_io2: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_com_io2_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_com_io2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_com_io2_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_com_io2: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_com_io2_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_com_io2: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io2_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_com_io2: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_com_io2_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_com_io2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_com_io2_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_com_io2: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_com_io2_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_com_io2: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_com_io3  ==================================================== */
#define pad_ctrl_pad_ctrl_com_io3_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_com_io3: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_com_io3_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_com_io3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_com_io3_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_com_io3: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_com_io3_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_com_io3: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io3_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_com_io3: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_com_io3_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_com_io3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_com_io3_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_com_io3: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_com_io3_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_com_io3: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_com_io3_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_com_io3: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_com_io3_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_com_io3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_com_io3_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_com_io3: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_com_io3_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_com_io3: ds (Bitfield-Mask: 0x01)   */
/* ==================================================  pad_ctrl_mii0_rxclk  ================================================== */
#define pad_ctrl_pad_ctrl_mii0_rxclk_reserved2_Pos (7UL)            /*!< pad_ctrl pad_ctrl_mii0_rxclk: reserved2 (Bit 7)       */
#define pad_ctrl_pad_ctrl_mii0_rxclk_reserved2_Msk (0xffffff80UL)   /*!< pad_ctrl pad_ctrl_mii0_rxclk: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_rxclk_ie_Pos (6UL)                   /*!< pad_ctrl pad_ctrl_mii0_rxclk: ie (Bit 6)              */
#define pad_ctrl_pad_ctrl_mii0_rxclk_ie_Msk (0x40UL)                /*!< pad_ctrl pad_ctrl_mii0_rxclk: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxclk_reserved1_Pos (5UL)            /*!< pad_ctrl pad_ctrl_mii0_rxclk: reserved1 (Bit 5)       */
#define pad_ctrl_pad_ctrl_mii0_rxclk_reserved1_Msk (0x20UL)         /*!< pad_ctrl pad_ctrl_mii0_rxclk: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxclk_pe_Pos (4UL)                   /*!< pad_ctrl pad_ctrl_mii0_rxclk: pe (Bit 4)              */
#define pad_ctrl_pad_ctrl_mii0_rxclk_pe_Msk (0x10UL)                /*!< pad_ctrl pad_ctrl_mii0_rxclk: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxclk_reserved0_Pos (1UL)            /*!< pad_ctrl pad_ctrl_mii0_rxclk: reserved0 (Bit 1)       */
#define pad_ctrl_pad_ctrl_mii0_rxclk_reserved0_Msk (0xeUL)          /*!< pad_ctrl pad_ctrl_mii0_rxclk: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_rxclk_ds_Pos (0UL)                   /*!< pad_ctrl pad_ctrl_mii0_rxclk: ds (Bit 0)              */
#define pad_ctrl_pad_ctrl_mii0_rxclk_ds_Msk (0x1UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxclk: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_rxd0  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_rxd0_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd0: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_rxd0_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_rxd0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_rxd0_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd0: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_rxd0_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd0: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd0_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd0: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_rxd0_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_rxd0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd0_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd0: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_rxd0_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd0: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd0_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd0: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii0_rxd0_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii0_rxd0: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii0_rxd1  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_rxd1_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd1: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_rxd1_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_rxd1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_rxd1_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd1: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_rxd1_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd1: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd1_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd1: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_rxd1_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_rxd1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd1_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd1: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_rxd1_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd1: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd1_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd1: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii0_rxd1_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii0_rxd1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_rxd1_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd1: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii0_rxd1_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii0_rxd1: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_rxd2  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_rxd2_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd2: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_rxd2_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_rxd2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_rxd2_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd2: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_rxd2_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd2: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd2_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd2: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_rxd2_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_rxd2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd2_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd2: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_rxd2_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd2: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd2_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd2: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii0_rxd2_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii0_rxd2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_rxd2_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd2: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii0_rxd2_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii0_rxd2: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_rxd3  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_rxd3_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd3: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_rxd3_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_rxd3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_rxd3_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd3: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_rxd3_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd3: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd3_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd3: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_rxd3_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_rxd3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd3_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxd3: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_rxd3_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxd3: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxd3_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii0_rxd3: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii0_rxd3_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii0_rxd3: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii0_rxdv  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_rxdv_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_rxdv: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_rxdv_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_rxdv: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_rxdv_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxdv: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_rxdv_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxdv: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxdv_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_rxdv: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_rxdv_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_rxdv: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxdv_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxdv: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_rxdv_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxdv: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxdv_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii0_rxdv: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii0_rxdv_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii0_rxdv: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii0_rxer  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_rxer_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_rxer: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_rxer_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_rxer: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_rxer_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxer: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_rxer_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxer: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxer_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_rxer: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_rxer_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_rxer: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxer_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_rxer: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_rxer_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_rxer: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_rxer_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii0_rxer: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii0_rxer_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii0_rxer: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii0_txclk  ================================================== */
#define pad_ctrl_pad_ctrl_mii0_txclk_reserved2_Pos (7UL)            /*!< pad_ctrl pad_ctrl_mii0_txclk: reserved2 (Bit 7)       */
#define pad_ctrl_pad_ctrl_mii0_txclk_reserved2_Msk (0xffffff80UL)   /*!< pad_ctrl pad_ctrl_mii0_txclk: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_txclk_ie_Pos (6UL)                   /*!< pad_ctrl pad_ctrl_mii0_txclk: ie (Bit 6)              */
#define pad_ctrl_pad_ctrl_mii0_txclk_ie_Msk (0x40UL)                /*!< pad_ctrl pad_ctrl_mii0_txclk: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txclk_reserved1_Pos (5UL)            /*!< pad_ctrl pad_ctrl_mii0_txclk: reserved1 (Bit 5)       */
#define pad_ctrl_pad_ctrl_mii0_txclk_reserved1_Msk (0x20UL)         /*!< pad_ctrl pad_ctrl_mii0_txclk: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txclk_pe_Pos (4UL)                   /*!< pad_ctrl pad_ctrl_mii0_txclk: pe (Bit 4)              */
#define pad_ctrl_pad_ctrl_mii0_txclk_pe_Msk (0x10UL)                /*!< pad_ctrl pad_ctrl_mii0_txclk: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txclk_reserved0_Pos (1UL)            /*!< pad_ctrl pad_ctrl_mii0_txclk: reserved0 (Bit 1)       */
#define pad_ctrl_pad_ctrl_mii0_txclk_reserved0_Msk (0xeUL)          /*!< pad_ctrl pad_ctrl_mii0_txclk: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_txclk_ds_Pos (0UL)                   /*!< pad_ctrl pad_ctrl_mii0_txclk: ds (Bit 0)              */
#define pad_ctrl_pad_ctrl_mii0_txclk_ds_Msk (0x1UL)                 /*!< pad_ctrl pad_ctrl_mii0_txclk: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_txd0  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_txd0_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_txd0: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_txd0_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_txd0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_txd0_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd0: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_txd0_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd0: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd0_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_txd0: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_txd0_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_txd0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd0_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd0: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_txd0_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd0: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd0_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii0_txd0: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii0_txd0_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii0_txd0: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_txd0_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd0: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii0_txd0_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii0_txd0: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_txd1  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_txd1_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_txd1: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_txd1_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_txd1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_txd1_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd1: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_txd1_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd1: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd1_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_txd1: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_txd1_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_txd1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd1_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd1: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_txd1_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd1: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd1_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii0_txd1: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii0_txd1_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii0_txd1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_txd1_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd1: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii0_txd1_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii0_txd1: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_txd2  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_txd2_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_txd2: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_txd2_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_txd2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_txd2_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd2: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_txd2_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd2: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd2_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_txd2: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_txd2_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_txd2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd2_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd2: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_txd2_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd2: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd2_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii0_txd2: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii0_txd2_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii0_txd2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_txd2_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd2: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii0_txd2_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii0_txd2: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_txd3  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_txd3_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_txd3: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_txd3_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_txd3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_txd3_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd3: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_txd3_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd3: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd3_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_txd3: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_txd3_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_txd3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd3_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd3: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_txd3_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_txd3: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txd3_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii0_txd3: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii0_txd3_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii0_txd3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_txd3_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii0_txd3: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii0_txd3_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii0_txd3: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii0_txen  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_txen_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii0_txen: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii0_txen_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii0_txen: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_txen_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii0_txen: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii0_txen_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii0_txen: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txen_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii0_txen: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii0_txen_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii0_txen: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txen_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii0_txen: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii0_txen_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii0_txen: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_txen_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii0_txen: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii0_txen_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii0_txen: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_txen_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii0_txen: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii0_txen_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii0_txen: ds (Bitfield-Mask: 0x01) */
/* ===================================================  pad_ctrl_mii0_col  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_col_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_mii0_col: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_mii0_col_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_mii0_col: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_col_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_mii0_col: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_mii0_col_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_mii0_col: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii0_col_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_mii0_col: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_mii0_col_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_mii0_col: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_col_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_mii0_col: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_mii0_col_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_mii0_col: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii0_col_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_mii0_col: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_mii0_col_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_mii0_col: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_col_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_mii0_col: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_mii0_col_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_mii0_col: ds (Bitfield-Mask: 0x01)  */
/* ===================================================  pad_ctrl_mii0_crs  =================================================== */
#define pad_ctrl_pad_ctrl_mii0_crs_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_mii0_crs: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_mii0_crs_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_mii0_crs: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii0_crs_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_mii0_crs: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_mii0_crs_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_mii0_crs: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii0_crs_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_mii0_crs: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_mii0_crs_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_mii0_crs: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii0_crs_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_mii0_crs: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_mii0_crs_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_mii0_crs: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii0_crs_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_mii0_crs: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_mii0_crs_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_mii0_crs: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii0_crs_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_mii0_crs: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_mii0_crs_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_mii0_crs: ds (Bitfield-Mask: 0x01)  */
/* ===============================================  pad_ctrl_phy0_led_link_in  =============================================== */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_reserved2_Pos (7UL)      /*!< pad_ctrl pad_ctrl_phy0_led_link_in: reserved2 (Bit 7) */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_reserved2_Msk (0xffffff80UL) /*!< pad_ctrl pad_ctrl_phy0_led_link_in: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_ie_Pos (6UL)             /*!< pad_ctrl pad_ctrl_phy0_led_link_in: ie (Bit 6)        */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_ie_Msk (0x40UL)          /*!< pad_ctrl pad_ctrl_phy0_led_link_in: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_reserved1_Pos (5UL)      /*!< pad_ctrl pad_ctrl_phy0_led_link_in: reserved1 (Bit 5) */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_reserved1_Msk (0x20UL)   /*!< pad_ctrl pad_ctrl_phy0_led_link_in: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_pe_Pos (4UL)             /*!< pad_ctrl pad_ctrl_phy0_led_link_in: pe (Bit 4)        */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_pe_Msk (0x10UL)          /*!< pad_ctrl pad_ctrl_phy0_led_link_in: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_reserved0_Pos (0UL)      /*!< pad_ctrl pad_ctrl_phy0_led_link_in: reserved0 (Bit 0) */
#define pad_ctrl_pad_ctrl_phy0_led_link_in_reserved0_Msk (0xfUL)    /*!< pad_ctrl pad_ctrl_phy0_led_link_in: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii1_rxclk  ================================================== */
#define pad_ctrl_pad_ctrl_mii1_rxclk_reserved2_Pos (7UL)            /*!< pad_ctrl pad_ctrl_mii1_rxclk: reserved2 (Bit 7)       */
#define pad_ctrl_pad_ctrl_mii1_rxclk_reserved2_Msk (0xffffff80UL)   /*!< pad_ctrl pad_ctrl_mii1_rxclk: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_rxclk_ie_Pos (6UL)                   /*!< pad_ctrl pad_ctrl_mii1_rxclk: ie (Bit 6)              */
#define pad_ctrl_pad_ctrl_mii1_rxclk_ie_Msk (0x40UL)                /*!< pad_ctrl pad_ctrl_mii1_rxclk: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxclk_reserved1_Pos (5UL)            /*!< pad_ctrl pad_ctrl_mii1_rxclk: reserved1 (Bit 5)       */
#define pad_ctrl_pad_ctrl_mii1_rxclk_reserved1_Msk (0x20UL)         /*!< pad_ctrl pad_ctrl_mii1_rxclk: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxclk_pe_Pos (4UL)                   /*!< pad_ctrl pad_ctrl_mii1_rxclk: pe (Bit 4)              */
#define pad_ctrl_pad_ctrl_mii1_rxclk_pe_Msk (0x10UL)                /*!< pad_ctrl pad_ctrl_mii1_rxclk: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxclk_reserved0_Pos (1UL)            /*!< pad_ctrl pad_ctrl_mii1_rxclk: reserved0 (Bit 1)       */
#define pad_ctrl_pad_ctrl_mii1_rxclk_reserved0_Msk (0xeUL)          /*!< pad_ctrl pad_ctrl_mii1_rxclk: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_rxclk_ds_Pos (0UL)                   /*!< pad_ctrl pad_ctrl_mii1_rxclk: ds (Bit 0)              */
#define pad_ctrl_pad_ctrl_mii1_rxclk_ds_Msk (0x1UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxclk: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_rxd0  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_rxd0_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd0: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_rxd0_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_rxd0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_rxd0_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd0: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_rxd0_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd0: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd0_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd0: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_rxd0_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_rxd0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd0_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd0: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_rxd0_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd0: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd0_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd0: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii1_rxd0_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii1_rxd0: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii1_rxd1  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_rxd1_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd1: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_rxd1_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_rxd1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_rxd1_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd1: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_rxd1_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd1: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd1_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd1: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_rxd1_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_rxd1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd1_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd1: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_rxd1_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd1: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd1_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd1: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii1_rxd1_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii1_rxd1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_rxd1_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd1: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii1_rxd1_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii1_rxd1: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_rxd2  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_rxd2_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd2: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_rxd2_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_rxd2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_rxd2_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd2: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_rxd2_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd2: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd2_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd2: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_rxd2_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_rxd2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd2_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd2: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_rxd2_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd2: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd2_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd2: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii1_rxd2_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii1_rxd2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_rxd2_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd2: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii1_rxd2_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii1_rxd2: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_rxd3  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_rxd3_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd3: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_rxd3_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_rxd3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_rxd3_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd3: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_rxd3_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd3: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd3_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd3: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_rxd3_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_rxd3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd3_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxd3: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_rxd3_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxd3: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxd3_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii1_rxd3: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii1_rxd3_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii1_rxd3: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii1_rxdv  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_rxdv_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_rxdv: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_rxdv_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_rxdv: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_rxdv_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxdv: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_rxdv_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxdv: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxdv_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_rxdv: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_rxdv_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_rxdv: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxdv_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxdv: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_rxdv_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxdv: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxdv_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii1_rxdv: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii1_rxdv_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii1_rxdv: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii1_rxer  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_rxer_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_rxer: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_rxer_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_rxer: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_rxer_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxer: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_rxer_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxer: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxer_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_rxer: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_rxer_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_rxer: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxer_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_rxer: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_rxer_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_rxer: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_rxer_reserved0_Pos (0UL)             /*!< pad_ctrl pad_ctrl_mii1_rxer: reserved0 (Bit 0)        */
#define pad_ctrl_pad_ctrl_mii1_rxer_reserved0_Msk (0xfUL)           /*!< pad_ctrl pad_ctrl_mii1_rxer: reserved0 (Bitfield-Mask: 0x0f) */
/* ==================================================  pad_ctrl_mii1_txclk  ================================================== */
#define pad_ctrl_pad_ctrl_mii1_txclk_reserved2_Pos (7UL)            /*!< pad_ctrl pad_ctrl_mii1_txclk: reserved2 (Bit 7)       */
#define pad_ctrl_pad_ctrl_mii1_txclk_reserved2_Msk (0xffffff80UL)   /*!< pad_ctrl pad_ctrl_mii1_txclk: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_txclk_ie_Pos (6UL)                   /*!< pad_ctrl pad_ctrl_mii1_txclk: ie (Bit 6)              */
#define pad_ctrl_pad_ctrl_mii1_txclk_ie_Msk (0x40UL)                /*!< pad_ctrl pad_ctrl_mii1_txclk: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txclk_reserved1_Pos (5UL)            /*!< pad_ctrl pad_ctrl_mii1_txclk: reserved1 (Bit 5)       */
#define pad_ctrl_pad_ctrl_mii1_txclk_reserved1_Msk (0x20UL)         /*!< pad_ctrl pad_ctrl_mii1_txclk: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txclk_pe_Pos (4UL)                   /*!< pad_ctrl pad_ctrl_mii1_txclk: pe (Bit 4)              */
#define pad_ctrl_pad_ctrl_mii1_txclk_pe_Msk (0x10UL)                /*!< pad_ctrl pad_ctrl_mii1_txclk: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txclk_reserved0_Pos (1UL)            /*!< pad_ctrl pad_ctrl_mii1_txclk: reserved0 (Bit 1)       */
#define pad_ctrl_pad_ctrl_mii1_txclk_reserved0_Msk (0xeUL)          /*!< pad_ctrl pad_ctrl_mii1_txclk: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_txclk_ds_Pos (0UL)                   /*!< pad_ctrl pad_ctrl_mii1_txclk: ds (Bit 0)              */
#define pad_ctrl_pad_ctrl_mii1_txclk_ds_Msk (0x1UL)                 /*!< pad_ctrl pad_ctrl_mii1_txclk: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_txd0  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_txd0_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_txd0: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_txd0_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_txd0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_txd0_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd0: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_txd0_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd0: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd0_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_txd0: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_txd0_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_txd0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd0_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd0: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_txd0_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd0: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd0_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii1_txd0: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii1_txd0_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii1_txd0: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_txd0_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd0: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii1_txd0_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii1_txd0: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_txd1  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_txd1_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_txd1: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_txd1_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_txd1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_txd1_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd1: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_txd1_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd1: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd1_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_txd1: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_txd1_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_txd1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd1_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd1: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_txd1_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd1: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd1_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii1_txd1: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii1_txd1_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii1_txd1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_txd1_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd1: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii1_txd1_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii1_txd1: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_txd2  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_txd2_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_txd2: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_txd2_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_txd2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_txd2_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd2: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_txd2_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd2: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd2_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_txd2: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_txd2_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_txd2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd2_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd2: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_txd2_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd2: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd2_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii1_txd2: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii1_txd2_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii1_txd2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_txd2_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd2: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii1_txd2_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii1_txd2: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_txd3  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_txd3_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_txd3: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_txd3_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_txd3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_txd3_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd3: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_txd3_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd3: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd3_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_txd3: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_txd3_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_txd3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd3_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd3: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_txd3_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_txd3: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txd3_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii1_txd3: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii1_txd3_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii1_txd3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_txd3_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii1_txd3: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii1_txd3_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii1_txd3: ds (Bitfield-Mask: 0x01) */
/* ==================================================  pad_ctrl_mii1_txen  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_txen_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_mii1_txen: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_mii1_txen_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_mii1_txen: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_txen_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_mii1_txen: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_mii1_txen_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_mii1_txen: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txen_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_mii1_txen: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_mii1_txen_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_mii1_txen: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txen_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_mii1_txen: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_mii1_txen_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_mii1_txen: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_txen_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_mii1_txen: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_mii1_txen_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_mii1_txen: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_txen_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_mii1_txen: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_mii1_txen_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_mii1_txen: ds (Bitfield-Mask: 0x01) */
/* ===================================================  pad_ctrl_mii1_col  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_col_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_mii1_col: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_mii1_col_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_mii1_col: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_col_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_mii1_col: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_mii1_col_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_mii1_col: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii1_col_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_mii1_col: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_mii1_col_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_mii1_col: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_col_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_mii1_col: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_mii1_col_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_mii1_col: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii1_col_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_mii1_col: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_mii1_col_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_mii1_col: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_col_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_mii1_col: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_mii1_col_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_mii1_col: ds (Bitfield-Mask: 0x01)  */
/* ===================================================  pad_ctrl_mii1_crs  =================================================== */
#define pad_ctrl_pad_ctrl_mii1_crs_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_mii1_crs: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_mii1_crs_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_mii1_crs: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii1_crs_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_mii1_crs: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_mii1_crs_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_mii1_crs: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii1_crs_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_mii1_crs: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_mii1_crs_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_mii1_crs: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii1_crs_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_mii1_crs: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_mii1_crs_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_mii1_crs: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii1_crs_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_mii1_crs: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_mii1_crs_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_mii1_crs: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii1_crs_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_mii1_crs: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_mii1_crs_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_mii1_crs: ds (Bitfield-Mask: 0x01)  */
/* ===============================================  pad_ctrl_phy1_led_link_in  =============================================== */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_reserved2_Pos (7UL)      /*!< pad_ctrl pad_ctrl_phy1_led_link_in: reserved2 (Bit 7) */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_reserved2_Msk (0xffffff80UL) /*!< pad_ctrl pad_ctrl_phy1_led_link_in: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_ie_Pos (6UL)             /*!< pad_ctrl pad_ctrl_phy1_led_link_in: ie (Bit 6)        */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_ie_Msk (0x40UL)          /*!< pad_ctrl pad_ctrl_phy1_led_link_in: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_reserved1_Pos (5UL)      /*!< pad_ctrl pad_ctrl_phy1_led_link_in: reserved1 (Bit 5) */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_reserved1_Msk (0x20UL)   /*!< pad_ctrl pad_ctrl_phy1_led_link_in: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_pe_Pos (4UL)             /*!< pad_ctrl pad_ctrl_phy1_led_link_in: pe (Bit 4)        */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_pe_Msk (0x10UL)          /*!< pad_ctrl pad_ctrl_phy1_led_link_in: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_reserved0_Pos (0UL)      /*!< pad_ctrl pad_ctrl_phy1_led_link_in: reserved0 (Bit 0) */
#define pad_ctrl_pad_ctrl_phy1_led_link_in_reserved0_Msk (0xfUL)    /*!< pad_ctrl pad_ctrl_phy1_led_link_in: reserved0 (Bitfield-Mask: 0x0f) */
/* ===================================================  pad_ctrl_mii_mdc  ==================================================== */
#define pad_ctrl_pad_ctrl_mii_mdc_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_mii_mdc: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_mii_mdc_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_mii_mdc: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii_mdc_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_mii_mdc: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_mii_mdc_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_mii_mdc: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_mii_mdc_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_mii_mdc: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_mii_mdc_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_mii_mdc: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii_mdc_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_mii_mdc: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_mii_mdc_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_mii_mdc: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_mii_mdc_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_mii_mdc: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_mii_mdc_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_mii_mdc: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii_mdc_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_mii_mdc: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_mii_mdc_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_mii_mdc: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_mii_mdio  =================================================== */
#define pad_ctrl_pad_ctrl_mii_mdio_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_mii_mdio: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_mii_mdio_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_mii_mdio: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mii_mdio_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_mii_mdio: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_mii_mdio_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_mii_mdio: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii_mdio_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_mii_mdio: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_mii_mdio_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_mii_mdio: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mii_mdio_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_mii_mdio: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_mii_mdio_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_mii_mdio: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_mii_mdio_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_mii_mdio: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_mii_mdio_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_mii_mdio: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mii_mdio_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_mii_mdio: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_mii_mdio_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_mii_mdio: ds (Bitfield-Mask: 0x01)  */
/* ==================================================  pad_ctrl_rst_out_n  =================================================== */
#define pad_ctrl_pad_ctrl_rst_out_n_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_rst_out_n: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_rst_out_n_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_rst_out_n: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_rst_out_n_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_rst_out_n: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_rst_out_n_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_rst_out_n: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_rst_out_n_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_rst_out_n: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_rst_out_n_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_rst_out_n: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_rst_out_n_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_rst_out_n: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_rst_out_n_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_rst_out_n: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_rst_out_n_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_rst_out_n: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_rst_out_n_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_rst_out_n: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_rst_out_n_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_rst_out_n: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_rst_out_n_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_rst_out_n: ds (Bitfield-Mask: 0x01) */
/* ===================================================  pad_ctrl_clk25out  =================================================== */
#define pad_ctrl_pad_ctrl_clk25out_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_clk25out: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_clk25out_reserved1_Msk (0xffffffe0UL)     /*!< pad_ctrl pad_ctrl_clk25out: reserved1 (Bitfield-Mask: 0x7ffffff) */
#define pad_ctrl_pad_ctrl_clk25out_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_clk25out: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_clk25out_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_clk25out: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_clk25out_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_clk25out: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_clk25out_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_clk25out: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_clk25out_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_clk25out: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_clk25out_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_clk25out: ds (Bitfield-Mask: 0x01)  */
/* ====================================================  pad_ctrl_mmio0  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio0_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio0: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio0_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio0_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio0: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio0_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio0: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio0_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio0: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio0_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio0_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio0: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio0_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio0: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio0_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio0: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio0_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio0: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio0_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio0: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio0_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio0: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mmio1  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio1_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio1: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio1_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio1_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio1: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio1_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio1: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio1_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio1: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio1_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio1_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio1: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio1_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio1: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio1_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio1: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio1_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio1_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio1: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio1_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio1: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mmio2  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio2_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio2: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio2_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio2_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio2: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio2_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio2: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio2_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio2: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio2_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio2_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio2: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio2_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio2: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio2_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio2: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio2_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio2_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio2: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio2_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio2: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mmio3  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio3_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio3: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio3_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio3_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio3: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio3_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio3: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio3_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio3: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio3_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio3_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio3: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio3_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio3: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio3_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio3: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio3_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio3_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio3: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio3_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio3: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mmio4  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio4_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio4: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio4_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio4: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio4_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio4: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio4_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio4: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio4_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio4: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio4_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio4: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio4_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio4: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio4_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio4: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio4_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio4: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio4_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio4: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio4_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio4: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio4_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio4: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mmio5  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio5_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio5: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio5_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio5: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio5_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio5: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio5_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio5: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio5_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio5: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio5_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio5: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio5_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio5: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio5_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio5: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio5_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio5: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio5_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio5: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio5_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio5: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio5_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio5: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mmio6  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio6_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio6: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio6_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio6: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio6_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio6: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio6_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio6: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio6_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio6: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio6_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio6: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio6_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio6: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio6_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio6: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio6_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio6: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio6_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio6: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio6_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio6: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio6_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio6: ds (Bitfield-Mask: 0x01)     */
/* ====================================================  pad_ctrl_mmio7  ===================================================== */
#define pad_ctrl_pad_ctrl_mmio7_reserved2_Pos (7UL)                 /*!< pad_ctrl pad_ctrl_mmio7: reserved2 (Bit 7)            */
#define pad_ctrl_pad_ctrl_mmio7_reserved2_Msk (0xffffff80UL)        /*!< pad_ctrl pad_ctrl_mmio7: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_mmio7_ie_Pos    (6UL)                     /*!< pad_ctrl pad_ctrl_mmio7: ie (Bit 6)                   */
#define pad_ctrl_pad_ctrl_mmio7_ie_Msk    (0x40UL)                  /*!< pad_ctrl pad_ctrl_mmio7: ie (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio7_reserved1_Pos (5UL)                 /*!< pad_ctrl pad_ctrl_mmio7: reserved1 (Bit 5)            */
#define pad_ctrl_pad_ctrl_mmio7_reserved1_Msk (0x20UL)              /*!< pad_ctrl pad_ctrl_mmio7: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_mmio7_pe_Pos    (4UL)                     /*!< pad_ctrl pad_ctrl_mmio7: pe (Bit 4)                   */
#define pad_ctrl_pad_ctrl_mmio7_pe_Msk    (0x10UL)                  /*!< pad_ctrl pad_ctrl_mmio7: pe (Bitfield-Mask: 0x01)     */
#define pad_ctrl_pad_ctrl_mmio7_reserved0_Pos (1UL)                 /*!< pad_ctrl pad_ctrl_mmio7: reserved0 (Bit 1)            */
#define pad_ctrl_pad_ctrl_mmio7_reserved0_Msk (0xeUL)               /*!< pad_ctrl pad_ctrl_mmio7: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_mmio7_ds_Pos    (0UL)                     /*!< pad_ctrl pad_ctrl_mmio7: ds (Bit 0)                   */
#define pad_ctrl_pad_ctrl_mmio7_ds_Msk    (0x1UL)                   /*!< pad_ctrl pad_ctrl_mmio7: ds (Bitfield-Mask: 0x01)     */
/* ===================================================  pad_ctrl_sqi_clk  ==================================================== */
#define pad_ctrl_pad_ctrl_sqi_clk_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_sqi_clk: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_sqi_clk_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_sqi_clk: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_sqi_clk_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_sqi_clk: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_sqi_clk_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_sqi_clk: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_sqi_clk_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_sqi_clk: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_sqi_clk_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_sqi_clk: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_sqi_clk_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_sqi_clk: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_sqi_clk_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_sqi_clk: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_sqi_clk_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_sqi_clk: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_sqi_clk_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_sqi_clk: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_sqi_clk_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_sqi_clk: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_sqi_clk_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_sqi_clk: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_sqi_cs0n  =================================================== */
#define pad_ctrl_pad_ctrl_sqi_cs0n_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_sqi_cs0n: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_sqi_cs0n_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_sqi_cs0n: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_sqi_cs0n_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_sqi_cs0n: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_sqi_cs0n_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_sqi_cs0n: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_cs0n_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_sqi_cs0n: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_sqi_cs0n_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_sqi_cs0n: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_sqi_cs0n_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_sqi_cs0n: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_sqi_cs0n_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_sqi_cs0n: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_cs0n_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_sqi_cs0n: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_sqi_cs0n_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_sqi_cs0n: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_sqi_cs0n_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_sqi_cs0n: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_sqi_cs0n_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_sqi_cs0n: ds (Bitfield-Mask: 0x01)  */
/* ===================================================  pad_ctrl_sqi_mosi  =================================================== */
#define pad_ctrl_pad_ctrl_sqi_mosi_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_sqi_mosi: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_sqi_mosi_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_sqi_mosi: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_sqi_mosi_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_sqi_mosi: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_sqi_mosi_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_sqi_mosi: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_mosi_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_sqi_mosi: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_sqi_mosi_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_sqi_mosi: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_sqi_mosi_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_sqi_mosi: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_sqi_mosi_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_sqi_mosi: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_mosi_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_sqi_mosi: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_sqi_mosi_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_sqi_mosi: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_sqi_mosi_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_sqi_mosi: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_sqi_mosi_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_sqi_mosi: ds (Bitfield-Mask: 0x01)  */
/* ===================================================  pad_ctrl_sqi_miso  =================================================== */
#define pad_ctrl_pad_ctrl_sqi_miso_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_sqi_miso: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_sqi_miso_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_sqi_miso: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_sqi_miso_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_sqi_miso: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_sqi_miso_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_sqi_miso: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_miso_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_sqi_miso: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_sqi_miso_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_sqi_miso: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_sqi_miso_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_sqi_miso: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_sqi_miso_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_sqi_miso: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_miso_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_sqi_miso: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_sqi_miso_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_sqi_miso: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_sqi_miso_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_sqi_miso: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_sqi_miso_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_sqi_miso: ds (Bitfield-Mask: 0x01)  */
/* ===================================================  pad_ctrl_sqi_sio2  =================================================== */
#define pad_ctrl_pad_ctrl_sqi_sio2_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_sqi_sio2: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_sqi_sio2_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_sqi_sio2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_sqi_sio2_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_sqi_sio2: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_sqi_sio2_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_sqi_sio2: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_sio2_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_sqi_sio2: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_sqi_sio2_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_sqi_sio2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_sqi_sio2_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_sqi_sio2: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_sqi_sio2_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_sqi_sio2: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_sio2_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_sqi_sio2: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_sqi_sio2_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_sqi_sio2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_sqi_sio2_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_sqi_sio2: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_sqi_sio2_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_sqi_sio2: ds (Bitfield-Mask: 0x01)  */
/* ===================================================  pad_ctrl_sqi_sio3  =================================================== */
#define pad_ctrl_pad_ctrl_sqi_sio3_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_sqi_sio3: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_sqi_sio3_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_sqi_sio3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_sqi_sio3_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_sqi_sio3: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_sqi_sio3_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_sqi_sio3: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_sio3_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_sqi_sio3: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_sqi_sio3_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_sqi_sio3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_sqi_sio3_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_sqi_sio3: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_sqi_sio3_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_sqi_sio3: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_sqi_sio3_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_sqi_sio3: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_sqi_sio3_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_sqi_sio3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_sqi_sio3_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_sqi_sio3: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_sqi_sio3_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_sqi_sio3: ds (Bitfield-Mask: 0x01)  */
/* ====================================================  pad_ctrl_hif_a0  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a0_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a0: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a0_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a0_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a0: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a0_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a0: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a0_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a0: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a0_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a0_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a0: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a0_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a0: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a0_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a0: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a0_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a0: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a0_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a0: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a0_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a0: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a1  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a1_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a1: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a1_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a1_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a1: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a1_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a1: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a1_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a1: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a1_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a1_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a1: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a1_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a1: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a1_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a1: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a1_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a1_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a1: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a1_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a1: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a2  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a2_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a2: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a2_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a2_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a2: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a2_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a2: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a2_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a2: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a2_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a2_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a2: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a2_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a2: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a2_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a2: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a2_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a2_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a2: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a2_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a2: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a3  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a3_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a3: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a3_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a3_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a3: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a3_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a3: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a3_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a3: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a3_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a3_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a3: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a3_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a3: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a3_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a3: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a3_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a3_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a3: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a3_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a3: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a4  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a4_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a4: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a4_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a4: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a4_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a4: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a4_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a4: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a4_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a4: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a4_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a4: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a4_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a4: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a4_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a4: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a4_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a4: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a4_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a4: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a4_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a4: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a4_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a4: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a5  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a5_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a5: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a5_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a5: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a5_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a5: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a5_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a5: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a5_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a5: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a5_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a5: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a5_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a5: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a5_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a5: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a5_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a5: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a5_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a5: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a5_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a5: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a5_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a5: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a6  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a6_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a6: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a6_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a6: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a6_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a6: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a6_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a6: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a6_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a6: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a6_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a6: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a6_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a6: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a6_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a6: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a6_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a6: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a6_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a6: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a6_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a6: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a6_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a6: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a7  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a7_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a7: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a7_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a7: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a7_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a7: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a7_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a7: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a7_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a7: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a7_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a7: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a7_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a7: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a7_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a7: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a7_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a7: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a7_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a7: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a7_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a7: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a7_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a7: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a8  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a8_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a8: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a8_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a8: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a8_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a8: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a8_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a8: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a8_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a8: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a8_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a8: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a8_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a8: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a8_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a8: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a8_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a8: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a8_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a8: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a8_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a8: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a8_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a8: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_a9  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a9_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_a9: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_a9_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_a9: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a9_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a9: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_a9_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a9: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a9_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_a9: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_a9_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_a9: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a9_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a9: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_a9_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a9: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_a9_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_a9: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_a9_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_a9: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a9_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a9: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_a9_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a9: ds (Bitfield-Mask: 0x01)    */
/* ===================================================  pad_ctrl_hif_a10  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a10_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a10: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a10_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a10: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a10_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a10: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a10_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a10: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a10_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a10: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a10_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a10: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a10_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a10: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a10_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a10: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a10_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a10: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a10_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a10: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a10_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a10: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a10_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a10: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_a11  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a11_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a11: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a11_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a11: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a11_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a11: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a11_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a11: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a11_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a11: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a11_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a11: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a11_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a11: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a11_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a11: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a11_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a11: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a11_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a11: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a11_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a11: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a11_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a11: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_a12  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a12_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a12: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a12_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a12: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a12_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a12: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a12_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a12: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a12_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a12: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a12_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a12: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a12_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a12: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a12_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a12: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a12_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a12: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a12_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a12: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a12_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a12: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a12_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a12: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_a13  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a13_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a13: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a13_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a13: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a13_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a13: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a13_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a13: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a13_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a13: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a13_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a13: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a13_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a13: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a13_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a13: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a13_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a13: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a13_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a13: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a13_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a13: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a13_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a13: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_a14  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a14_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a14: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a14_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a14: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a14_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a14: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a14_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a14: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a14_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a14: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a14_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a14: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a14_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a14: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a14_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a14: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a14_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a14: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a14_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a14: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a14_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a14: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a14_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a14: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_a15  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a15_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a15: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a15_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a15: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a15_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a15: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a15_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a15: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a15_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a15: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a15_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a15: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a15_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a15: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a15_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a15: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a15_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a15: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a15_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a15: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a15_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a15: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a15_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a15: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_a16  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a16_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a16: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a16_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a16: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a16_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a16: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a16_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a16: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a16_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a16: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a16_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a16: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a16_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a16: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a16_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a16: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a16_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a16: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a16_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a16: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a16_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a16: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a16_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a16: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_a17  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_a17_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_a17: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_a17_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_a17: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_a17_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_a17: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_a17_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_a17: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a17_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_a17: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_a17_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_a17: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_a17_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_a17: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_a17_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_a17: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_a17_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_a17: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_a17_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_a17: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_a17_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_a17: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_a17_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_a17: ds (Bitfield-Mask: 0x01)   */
/* ====================================================  pad_ctrl_hif_d0  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d0_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d0: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d0_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d0: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d0_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d0: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d0_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d0: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d0_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d0: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d0_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d0: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d0_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d0: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d0_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d0: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d0_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d0: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d0_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d0: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d0_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d0: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d0_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d0: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d1  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d1_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d1: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d1_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d1: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d1_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d1: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d1_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d1: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d1_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d1: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d1_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d1: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d1_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d1: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d1_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d1: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d1_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d1: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d1_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d1: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d1_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d1: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d1_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d1: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d2  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d2_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d2: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d2_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d2: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d2_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d2: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d2_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d2: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d2_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d2: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d2_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d2: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d2_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d2: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d2_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d2: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d2_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d2: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d2_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d2: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d2_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d2: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d2_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d2: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d3  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d3_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d3: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d3_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d3: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d3_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d3: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d3_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d3: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d3_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d3: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d3_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d3: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d3_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d3: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d3_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d3: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d3_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d3: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d3_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d3: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d3_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d3: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d3_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d3: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d4  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d4_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d4: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d4_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d4: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d4_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d4: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d4_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d4: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d4_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d4: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d4_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d4: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d4_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d4: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d4_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d4: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d4_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d4: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d4_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d4: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d4_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d4: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d4_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d4: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d5  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d5_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d5: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d5_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d5: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d5_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d5: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d5_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d5: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d5_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d5: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d5_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d5: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d5_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d5: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d5_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d5: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d5_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d5: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d5_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d5: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d5_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d5: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d5_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d5: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d6  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d6_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d6: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d6_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d6: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d6_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d6: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d6_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d6: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d6_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d6: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d6_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d6: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d6_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d6: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d6_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d6: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d6_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d6: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d6_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d6: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d6_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d6: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d6_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d6: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d7  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d7_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d7: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d7_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d7: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d7_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d7: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d7_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d7: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d7_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d7: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d7_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d7: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d7_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d7: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d7_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d7: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d7_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d7: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d7_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d7: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d7_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d7: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d7_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d7: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d8  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d8_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d8: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d8_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d8: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d8_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d8: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d8_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d8: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d8_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d8: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d8_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d8: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d8_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d8: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d8_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d8: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d8_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d8: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d8_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d8: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d8_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d8: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d8_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d8: ds (Bitfield-Mask: 0x01)    */
/* ====================================================  pad_ctrl_hif_d9  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d9_reserved2_Pos (7UL)                /*!< pad_ctrl pad_ctrl_hif_d9: reserved2 (Bit 7)           */
#define pad_ctrl_pad_ctrl_hif_d9_reserved2_Msk (0xffffff80UL)       /*!< pad_ctrl pad_ctrl_hif_d9: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d9_ie_Pos   (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d9: ie (Bit 6)                  */
#define pad_ctrl_pad_ctrl_hif_d9_ie_Msk   (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d9: ie (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d9_reserved1_Pos (5UL)                /*!< pad_ctrl pad_ctrl_hif_d9: reserved1 (Bit 5)           */
#define pad_ctrl_pad_ctrl_hif_d9_reserved1_Msk (0x20UL)             /*!< pad_ctrl pad_ctrl_hif_d9: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d9_pe_Pos   (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d9: pe (Bit 4)                  */
#define pad_ctrl_pad_ctrl_hif_d9_pe_Msk   (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d9: pe (Bitfield-Mask: 0x01)    */
#define pad_ctrl_pad_ctrl_hif_d9_reserved0_Pos (1UL)                /*!< pad_ctrl pad_ctrl_hif_d9: reserved0 (Bit 1)           */
#define pad_ctrl_pad_ctrl_hif_d9_reserved0_Msk (0xeUL)              /*!< pad_ctrl pad_ctrl_hif_d9: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d9_ds_Pos   (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d9: ds (Bit 0)                  */
#define pad_ctrl_pad_ctrl_hif_d9_ds_Msk   (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d9: ds (Bitfield-Mask: 0x01)    */
/* ===================================================  pad_ctrl_hif_d10  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d10_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_d10: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_d10_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_d10: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d10_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d10: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_d10_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d10: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d10_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_d10: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_d10_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_d10: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d10_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d10: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_d10_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d10: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d10_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_d10: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_d10_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_d10: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d10_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d10: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_d10_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d10: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_d11  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d11_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_d11: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_d11_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_d11: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d11_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d11: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_d11_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d11: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d11_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_d11: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_d11_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_d11: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d11_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d11: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_d11_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d11: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d11_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_d11: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_d11_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_d11: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d11_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d11: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_d11_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d11: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_d12  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d12_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_d12: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_d12_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_d12: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d12_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d12: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_d12_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d12: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d12_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_d12: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_d12_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_d12: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d12_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d12: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_d12_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d12: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d12_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_d12: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_d12_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_d12: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d12_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d12: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_d12_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d12: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_d13  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d13_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_d13: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_d13_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_d13: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d13_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d13: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_d13_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d13: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d13_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_d13: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_d13_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_d13: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d13_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d13: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_d13_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d13: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d13_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_d13: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_d13_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_d13: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d13_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d13: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_d13_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d13: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_d14  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d14_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_d14: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_d14_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_d14: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d14_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d14: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_d14_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d14: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d14_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_d14: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_d14_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_d14: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d14_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d14: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_d14_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d14: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d14_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_d14: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_d14_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_d14: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d14_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d14: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_d14_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d14: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_d15  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_d15_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_d15: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_d15_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_d15: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_d15_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_d15: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_d15_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_d15: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d15_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_d15: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_d15_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_d15: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_d15_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_d15: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_d15_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_d15: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_d15_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_d15: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_d15_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_d15: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_d15_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_d15: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_d15_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_d15: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_bhen  =================================================== */
#define pad_ctrl_pad_ctrl_hif_bhen_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_hif_bhen: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_hif_bhen_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_hif_bhen: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_bhen_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_hif_bhen: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_hif_bhen_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_bhen: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_hif_bhen_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_hif_bhen: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_hif_bhen_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_hif_bhen: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_bhen_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_hif_bhen: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_hif_bhen_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_bhen: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_hif_bhen_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_hif_bhen: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_hif_bhen_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_hif_bhen: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_bhen_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_hif_bhen: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_hif_bhen_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_bhen: ds (Bitfield-Mask: 0x01)  */
/* ===================================================  pad_ctrl_hif_csn  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_csn_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_csn: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_csn_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_csn: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_csn_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_csn: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_csn_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_csn: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_csn_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_csn: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_csn_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_csn: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_csn_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_csn: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_csn_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_csn: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_csn_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_csn: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_csn_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_csn: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_csn_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_csn: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_csn_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_csn: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_rdn  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_rdn_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_rdn: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_rdn_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_rdn: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_rdn_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_rdn: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_rdn_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_rdn: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_rdn_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_rdn: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_rdn_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_rdn: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_rdn_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_rdn: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_rdn_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_rdn: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_rdn_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_rdn: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_rdn_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_rdn: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_rdn_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_rdn: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_rdn_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_rdn: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_wrn  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_wrn_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_wrn: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_wrn_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_wrn: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_wrn_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_wrn: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_wrn_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_wrn: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_wrn_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_wrn: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_wrn_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_wrn: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_wrn_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_wrn: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_wrn_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_wrn: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_wrn_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_wrn: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_wrn_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_wrn: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_wrn_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_wrn: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_wrn_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_wrn: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_rdy  ==================================================== */
#define pad_ctrl_pad_ctrl_hif_rdy_reserved2_Pos (7UL)               /*!< pad_ctrl pad_ctrl_hif_rdy: reserved2 (Bit 7)          */
#define pad_ctrl_pad_ctrl_hif_rdy_reserved2_Msk (0xffffff80UL)      /*!< pad_ctrl pad_ctrl_hif_rdy: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_rdy_ie_Pos  (6UL)                     /*!< pad_ctrl pad_ctrl_hif_rdy: ie (Bit 6)                 */
#define pad_ctrl_pad_ctrl_hif_rdy_ie_Msk  (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_rdy: ie (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_rdy_reserved1_Pos (5UL)               /*!< pad_ctrl pad_ctrl_hif_rdy: reserved1 (Bit 5)          */
#define pad_ctrl_pad_ctrl_hif_rdy_reserved1_Msk (0x20UL)            /*!< pad_ctrl pad_ctrl_hif_rdy: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_rdy_pe_Pos  (4UL)                     /*!< pad_ctrl pad_ctrl_hif_rdy: pe (Bit 4)                 */
#define pad_ctrl_pad_ctrl_hif_rdy_pe_Msk  (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_rdy: pe (Bitfield-Mask: 0x01)   */
#define pad_ctrl_pad_ctrl_hif_rdy_reserved0_Pos (1UL)               /*!< pad_ctrl pad_ctrl_hif_rdy: reserved0 (Bit 1)          */
#define pad_ctrl_pad_ctrl_hif_rdy_reserved0_Msk (0xeUL)             /*!< pad_ctrl pad_ctrl_hif_rdy: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_rdy_ds_Pos  (0UL)                     /*!< pad_ctrl pad_ctrl_hif_rdy: ds (Bit 0)                 */
#define pad_ctrl_pad_ctrl_hif_rdy_ds_Msk  (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_rdy: ds (Bitfield-Mask: 0x01)   */
/* ===================================================  pad_ctrl_hif_dirq  =================================================== */
#define pad_ctrl_pad_ctrl_hif_dirq_reserved2_Pos (7UL)              /*!< pad_ctrl pad_ctrl_hif_dirq: reserved2 (Bit 7)         */
#define pad_ctrl_pad_ctrl_hif_dirq_reserved2_Msk (0xffffff80UL)     /*!< pad_ctrl pad_ctrl_hif_dirq: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_dirq_ie_Pos (6UL)                     /*!< pad_ctrl pad_ctrl_hif_dirq: ie (Bit 6)                */
#define pad_ctrl_pad_ctrl_hif_dirq_ie_Msk (0x40UL)                  /*!< pad_ctrl pad_ctrl_hif_dirq: ie (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_hif_dirq_reserved1_Pos (5UL)              /*!< pad_ctrl pad_ctrl_hif_dirq: reserved1 (Bit 5)         */
#define pad_ctrl_pad_ctrl_hif_dirq_reserved1_Msk (0x20UL)           /*!< pad_ctrl pad_ctrl_hif_dirq: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_dirq_pe_Pos (4UL)                     /*!< pad_ctrl pad_ctrl_hif_dirq: pe (Bit 4)                */
#define pad_ctrl_pad_ctrl_hif_dirq_pe_Msk (0x10UL)                  /*!< pad_ctrl pad_ctrl_hif_dirq: pe (Bitfield-Mask: 0x01)  */
#define pad_ctrl_pad_ctrl_hif_dirq_reserved0_Pos (1UL)              /*!< pad_ctrl pad_ctrl_hif_dirq: reserved0 (Bit 1)         */
#define pad_ctrl_pad_ctrl_hif_dirq_reserved0_Msk (0xeUL)            /*!< pad_ctrl pad_ctrl_hif_dirq: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_dirq_ds_Pos (0UL)                     /*!< pad_ctrl pad_ctrl_hif_dirq: ds (Bit 0)                */
#define pad_ctrl_pad_ctrl_hif_dirq_ds_Msk (0x1UL)                   /*!< pad_ctrl pad_ctrl_hif_dirq: ds (Bitfield-Mask: 0x01)  */
/* ==================================================  pad_ctrl_hif_sdclk  =================================================== */
#define pad_ctrl_pad_ctrl_hif_sdclk_reserved2_Pos (7UL)             /*!< pad_ctrl pad_ctrl_hif_sdclk: reserved2 (Bit 7)        */
#define pad_ctrl_pad_ctrl_hif_sdclk_reserved2_Msk (0xffffff80UL)    /*!< pad_ctrl pad_ctrl_hif_sdclk: reserved2 (Bitfield-Mask: 0x1ffffff) */
#define pad_ctrl_pad_ctrl_hif_sdclk_ie_Pos (6UL)                    /*!< pad_ctrl pad_ctrl_hif_sdclk: ie (Bit 6)               */
#define pad_ctrl_pad_ctrl_hif_sdclk_ie_Msk (0x40UL)                 /*!< pad_ctrl pad_ctrl_hif_sdclk: ie (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_sdclk_reserved1_Pos (5UL)             /*!< pad_ctrl pad_ctrl_hif_sdclk: reserved1 (Bit 5)        */
#define pad_ctrl_pad_ctrl_hif_sdclk_reserved1_Msk (0x20UL)          /*!< pad_ctrl pad_ctrl_hif_sdclk: reserved1 (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_sdclk_pe_Pos (4UL)                    /*!< pad_ctrl pad_ctrl_hif_sdclk: pe (Bit 4)               */
#define pad_ctrl_pad_ctrl_hif_sdclk_pe_Msk (0x10UL)                 /*!< pad_ctrl pad_ctrl_hif_sdclk: pe (Bitfield-Mask: 0x01) */
#define pad_ctrl_pad_ctrl_hif_sdclk_reserved0_Pos (1UL)             /*!< pad_ctrl pad_ctrl_hif_sdclk: reserved0 (Bit 1)        */
#define pad_ctrl_pad_ctrl_hif_sdclk_reserved0_Msk (0xeUL)           /*!< pad_ctrl pad_ctrl_hif_sdclk: reserved0 (Bitfield-Mask: 0x07) */
#define pad_ctrl_pad_ctrl_hif_sdclk_ds_Pos (0UL)                    /*!< pad_ctrl pad_ctrl_hif_sdclk: ds (Bit 0)               */
#define pad_ctrl_pad_ctrl_hif_sdclk_ds_Msk (0x1UL)                  /*!< pad_ctrl pad_ctrl_hif_sdclk: ds (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         asic_ctrl                                         ================ */
/* =========================================================================================================================== */

/* ======================================================  io_config0  ======================================================= */
#define asic_ctrl_io_config0_val_Pos      (0UL)                     /*!< asic_ctrl io_config0: val (Bit 0)                     */
#define asic_ctrl_io_config0_val_Msk      (0xffffffffUL)            /*!< asic_ctrl io_config0: val (Bitfield-Mask: 0xffffffff) */
/* ====================================================  io_config0_mask  ==================================================== */
#define asic_ctrl_io_config0_mask_val_Pos (0UL)                     /*!< asic_ctrl io_config0_mask: val (Bit 0)                */
#define asic_ctrl_io_config0_mask_val_Msk (0xffffffffUL)            /*!< asic_ctrl io_config0_mask: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  io_config1  ======================================================= */
#define asic_ctrl_io_config1_val_Pos      (0UL)                     /*!< asic_ctrl io_config1: val (Bit 0)                     */
#define asic_ctrl_io_config1_val_Msk      (0xffffffffUL)            /*!< asic_ctrl io_config1: val (Bitfield-Mask: 0xffffffff) */
/* ====================================================  io_config1_mask  ==================================================== */
#define asic_ctrl_io_config1_mask_val_Pos (0UL)                     /*!< asic_ctrl io_config1_mask: val (Bit 0)                */
#define asic_ctrl_io_config1_mask_val_Msk (0xffffffffUL)            /*!< asic_ctrl io_config1_mask: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  io_config2  ======================================================= */
#define asic_ctrl_io_config2_val_Pos      (0UL)                     /*!< asic_ctrl io_config2: val (Bit 0)                     */
#define asic_ctrl_io_config2_val_Msk      (0xffffffffUL)            /*!< asic_ctrl io_config2: val (Bitfield-Mask: 0xffffffff) */
/* ====================================================  io_config2_mask  ==================================================== */
#define asic_ctrl_io_config2_mask_val_Pos (0UL)                     /*!< asic_ctrl io_config2_mask: val (Bit 0)                */
#define asic_ctrl_io_config2_mask_val_Msk (0xffffffffUL)            /*!< asic_ctrl io_config2_mask: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  io_config3  ======================================================= */
#define asic_ctrl_io_config3_sel_biss1_mo_Pos (15UL)                /*!< asic_ctrl io_config3: sel_biss1_mo (Bit 15)           */
#define asic_ctrl_io_config3_sel_biss1_mo_Msk (0x8000UL)            /*!< asic_ctrl io_config3: sel_biss1_mo (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_biss1_Pos (14UL)                   /*!< asic_ctrl io_config3: sel_biss1 (Bit 14)              */
#define asic_ctrl_io_config3_sel_biss1_Msk (0x4000UL)               /*!< asic_ctrl io_config3: sel_biss1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_biss0_mo_Pos (13UL)                /*!< asic_ctrl io_config3: sel_biss0_mo (Bit 13)           */
#define asic_ctrl_io_config3_sel_biss0_mo_Msk (0x2000UL)            /*!< asic_ctrl io_config3: sel_biss0_mo (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_biss0_Pos (12UL)                   /*!< asic_ctrl io_config3: sel_biss0 (Bit 12)              */
#define asic_ctrl_io_config3_sel_biss0_Msk (0x1000UL)               /*!< asic_ctrl io_config3: sel_biss0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_endat1_devel_Pos (11UL)            /*!< asic_ctrl io_config3: sel_endat1_devel (Bit 11)       */
#define asic_ctrl_io_config3_sel_endat1_devel_Msk (0x800UL)         /*!< asic_ctrl io_config3: sel_endat1_devel (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_endat1_Pos (10UL)                  /*!< asic_ctrl io_config3: sel_endat1 (Bit 10)             */
#define asic_ctrl_io_config3_sel_endat1_Msk (0x400UL)               /*!< asic_ctrl io_config3: sel_endat1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_endat0_devel_Pos (9UL)             /*!< asic_ctrl io_config3: sel_endat0_devel (Bit 9)        */
#define asic_ctrl_io_config3_sel_endat0_devel_Msk (0x200UL)         /*!< asic_ctrl io_config3: sel_endat0_devel (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_endat0_Pos (8UL)                   /*!< asic_ctrl io_config3: sel_endat0 (Bit 8)              */
#define asic_ctrl_io_config3_sel_endat0_Msk (0x100UL)               /*!< asic_ctrl io_config3: sel_endat0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio7_Pos (7UL)                    /*!< asic_ctrl io_config3: sel_gpio7 (Bit 7)               */
#define asic_ctrl_io_config3_sel_gpio7_Msk (0x80UL)                 /*!< asic_ctrl io_config3: sel_gpio7 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio6_Pos (6UL)                    /*!< asic_ctrl io_config3: sel_gpio6 (Bit 6)               */
#define asic_ctrl_io_config3_sel_gpio6_Msk (0x40UL)                 /*!< asic_ctrl io_config3: sel_gpio6 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio5_Pos (5UL)                    /*!< asic_ctrl io_config3: sel_gpio5 (Bit 5)               */
#define asic_ctrl_io_config3_sel_gpio5_Msk (0x20UL)                 /*!< asic_ctrl io_config3: sel_gpio5 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio4_Pos (4UL)                    /*!< asic_ctrl io_config3: sel_gpio4 (Bit 4)               */
#define asic_ctrl_io_config3_sel_gpio4_Msk (0x10UL)                 /*!< asic_ctrl io_config3: sel_gpio4 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio3_Pos (3UL)                    /*!< asic_ctrl io_config3: sel_gpio3 (Bit 3)               */
#define asic_ctrl_io_config3_sel_gpio3_Msk (0x8UL)                  /*!< asic_ctrl io_config3: sel_gpio3 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio2_Pos (2UL)                    /*!< asic_ctrl io_config3: sel_gpio2 (Bit 2)               */
#define asic_ctrl_io_config3_sel_gpio2_Msk (0x4UL)                  /*!< asic_ctrl io_config3: sel_gpio2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio1_Pos (1UL)                    /*!< asic_ctrl io_config3: sel_gpio1 (Bit 1)               */
#define asic_ctrl_io_config3_sel_gpio1_Msk (0x2UL)                  /*!< asic_ctrl io_config3: sel_gpio1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_sel_gpio0_Pos (0UL)                    /*!< asic_ctrl io_config3: sel_gpio0 (Bit 0)               */
#define asic_ctrl_io_config3_sel_gpio0_Msk (0x1UL)                  /*!< asic_ctrl io_config3: sel_gpio0 (Bitfield-Mask: 0x01) */
/* ====================================================  io_config3_mask  ==================================================== */
#define asic_ctrl_io_config3_mask_sel_biss1_mo_Pos (15UL)           /*!< asic_ctrl io_config3_mask: sel_biss1_mo (Bit 15)      */
#define asic_ctrl_io_config3_mask_sel_biss1_mo_Msk (0x8000UL)       /*!< asic_ctrl io_config3_mask: sel_biss1_mo (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_biss1_Pos (14UL)              /*!< asic_ctrl io_config3_mask: sel_biss1 (Bit 14)         */
#define asic_ctrl_io_config3_mask_sel_biss1_Msk (0x4000UL)          /*!< asic_ctrl io_config3_mask: sel_biss1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_biss0_mo_Pos (13UL)           /*!< asic_ctrl io_config3_mask: sel_biss0_mo (Bit 13)      */
#define asic_ctrl_io_config3_mask_sel_biss0_mo_Msk (0x2000UL)       /*!< asic_ctrl io_config3_mask: sel_biss0_mo (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_biss0_Pos (12UL)              /*!< asic_ctrl io_config3_mask: sel_biss0 (Bit 12)         */
#define asic_ctrl_io_config3_mask_sel_biss0_Msk (0x1000UL)          /*!< asic_ctrl io_config3_mask: sel_biss0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_endat1_devel_Pos (11UL)       /*!< asic_ctrl io_config3_mask: sel_endat1_devel (Bit 11)  */
#define asic_ctrl_io_config3_mask_sel_endat1_devel_Msk (0x800UL)    /*!< asic_ctrl io_config3_mask: sel_endat1_devel (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_endat1_Pos (10UL)             /*!< asic_ctrl io_config3_mask: sel_endat1 (Bit 10)        */
#define asic_ctrl_io_config3_mask_sel_endat1_Msk (0x400UL)          /*!< asic_ctrl io_config3_mask: sel_endat1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_endat0_devel_Pos (9UL)        /*!< asic_ctrl io_config3_mask: sel_endat0_devel (Bit 9)   */
#define asic_ctrl_io_config3_mask_sel_endat0_devel_Msk (0x200UL)    /*!< asic_ctrl io_config3_mask: sel_endat0_devel (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_endat0_Pos (8UL)              /*!< asic_ctrl io_config3_mask: sel_endat0 (Bit 8)         */
#define asic_ctrl_io_config3_mask_sel_endat0_Msk (0x100UL)          /*!< asic_ctrl io_config3_mask: sel_endat0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio7_Pos (7UL)               /*!< asic_ctrl io_config3_mask: sel_gpio7 (Bit 7)          */
#define asic_ctrl_io_config3_mask_sel_gpio7_Msk (0x80UL)            /*!< asic_ctrl io_config3_mask: sel_gpio7 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio6_Pos (6UL)               /*!< asic_ctrl io_config3_mask: sel_gpio6 (Bit 6)          */
#define asic_ctrl_io_config3_mask_sel_gpio6_Msk (0x40UL)            /*!< asic_ctrl io_config3_mask: sel_gpio6 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio5_Pos (5UL)               /*!< asic_ctrl io_config3_mask: sel_gpio5 (Bit 5)          */
#define asic_ctrl_io_config3_mask_sel_gpio5_Msk (0x20UL)            /*!< asic_ctrl io_config3_mask: sel_gpio5 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio4_Pos (4UL)               /*!< asic_ctrl io_config3_mask: sel_gpio4 (Bit 4)          */
#define asic_ctrl_io_config3_mask_sel_gpio4_Msk (0x10UL)            /*!< asic_ctrl io_config3_mask: sel_gpio4 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio3_Pos (3UL)               /*!< asic_ctrl io_config3_mask: sel_gpio3 (Bit 3)          */
#define asic_ctrl_io_config3_mask_sel_gpio3_Msk (0x8UL)             /*!< asic_ctrl io_config3_mask: sel_gpio3 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio2_Pos (2UL)               /*!< asic_ctrl io_config3_mask: sel_gpio2 (Bit 2)          */
#define asic_ctrl_io_config3_mask_sel_gpio2_Msk (0x4UL)             /*!< asic_ctrl io_config3_mask: sel_gpio2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio1_Pos (1UL)               /*!< asic_ctrl io_config3_mask: sel_gpio1 (Bit 1)          */
#define asic_ctrl_io_config3_mask_sel_gpio1_Msk (0x2UL)             /*!< asic_ctrl io_config3_mask: sel_gpio1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config3_mask_sel_gpio0_Pos (0UL)               /*!< asic_ctrl io_config3_mask: sel_gpio0 (Bit 0)          */
#define asic_ctrl_io_config3_mask_sel_gpio0_Msk (0x1UL)             /*!< asic_ctrl io_config3_mask: sel_gpio0 (Bitfield-Mask: 0x01) */
/* ======================================================  io_config4  ======================================================= */
#define asic_ctrl_io_config4_sel_can1_app_Pos (11UL)                /*!< asic_ctrl io_config4: sel_can1_app (Bit 11)           */
#define asic_ctrl_io_config4_sel_can1_app_Msk (0x800UL)             /*!< asic_ctrl io_config4: sel_can1_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_can0_app_Pos (10UL)                /*!< asic_ctrl io_config4: sel_can0_app (Bit 10)           */
#define asic_ctrl_io_config4_sel_can0_app_Msk (0x400UL)             /*!< asic_ctrl io_config4: sel_can0_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_spi2_app_cs2_Pos (9UL)             /*!< asic_ctrl io_config4: sel_spi2_app_cs2 (Bit 9)        */
#define asic_ctrl_io_config4_sel_spi2_app_cs2_Msk (0x200UL)         /*!< asic_ctrl io_config4: sel_spi2_app_cs2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_spi2_app_cs1_Pos (8UL)             /*!< asic_ctrl io_config4: sel_spi2_app_cs1 (Bit 8)        */
#define asic_ctrl_io_config4_sel_spi2_app_cs1_Msk (0x100UL)         /*!< asic_ctrl io_config4: sel_spi2_app_cs1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_spi2_app_Pos (7UL)                 /*!< asic_ctrl io_config4: sel_spi2_app (Bit 7)            */
#define asic_ctrl_io_config4_sel_spi2_app_Msk (0x80UL)              /*!< asic_ctrl io_config4: sel_spi2_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_spi0_app_cs1_Pos (6UL)             /*!< asic_ctrl io_config4: sel_spi0_app_cs1 (Bit 6)        */
#define asic_ctrl_io_config4_sel_spi0_app_cs1_Msk (0x40UL)          /*!< asic_ctrl io_config4: sel_spi0_app_cs1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_spi0_app_Pos (5UL)                 /*!< asic_ctrl io_config4: sel_spi0_app (Bit 5)            */
#define asic_ctrl_io_config4_sel_spi0_app_Msk (0x20UL)              /*!< asic_ctrl io_config4: sel_spi0_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_uart_xpic_app_rctsn_Pos (4UL)      /*!< asic_ctrl io_config4: sel_uart_xpic_app_rctsn (Bit 4) */
#define asic_ctrl_io_config4_sel_uart_xpic_app_rctsn_Msk (0x10UL)   /*!< asic_ctrl io_config4: sel_uart_xpic_app_rctsn (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_uart_xpic_app_Pos (3UL)            /*!< asic_ctrl io_config4: sel_uart_xpic_app (Bit 3)       */
#define asic_ctrl_io_config4_sel_uart_xpic_app_Msk (0x8UL)          /*!< asic_ctrl io_config4: sel_uart_xpic_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_uart_app_rctsn_Pos (2UL)           /*!< asic_ctrl io_config4: sel_uart_app_rctsn (Bit 2)      */
#define asic_ctrl_io_config4_sel_uart_app_rctsn_Msk (0x4UL)         /*!< asic_ctrl io_config4: sel_uart_app_rctsn (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_uart_app_Pos (1UL)                 /*!< asic_ctrl io_config4: sel_uart_app (Bit 1)            */
#define asic_ctrl_io_config4_sel_uart_app_Msk (0x2UL)               /*!< asic_ctrl io_config4: sel_uart_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_sel_i2c_app_Pos (0UL)                  /*!< asic_ctrl io_config4: sel_i2c_app (Bit 0)             */
#define asic_ctrl_io_config4_sel_i2c_app_Msk (0x1UL)                /*!< asic_ctrl io_config4: sel_i2c_app (Bitfield-Mask: 0x01) */
/* ====================================================  io_config4_mask  ==================================================== */
#define asic_ctrl_io_config4_mask_sel_can1_app_Pos (11UL)           /*!< asic_ctrl io_config4_mask: sel_can1_app (Bit 11)      */
#define asic_ctrl_io_config4_mask_sel_can1_app_Msk (0x800UL)        /*!< asic_ctrl io_config4_mask: sel_can1_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_can0_app_Pos (10UL)           /*!< asic_ctrl io_config4_mask: sel_can0_app (Bit 10)      */
#define asic_ctrl_io_config4_mask_sel_can0_app_Msk (0x400UL)        /*!< asic_ctrl io_config4_mask: sel_can0_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_spi2_app_cs2_Pos (9UL)        /*!< asic_ctrl io_config4_mask: sel_spi2_app_cs2 (Bit 9)   */
#define asic_ctrl_io_config4_mask_sel_spi2_app_cs2_Msk (0x200UL)    /*!< asic_ctrl io_config4_mask: sel_spi2_app_cs2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_spi2_app_cs1_Pos (8UL)        /*!< asic_ctrl io_config4_mask: sel_spi2_app_cs1 (Bit 8)   */
#define asic_ctrl_io_config4_mask_sel_spi2_app_cs1_Msk (0x100UL)    /*!< asic_ctrl io_config4_mask: sel_spi2_app_cs1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_spi2_app_Pos (7UL)            /*!< asic_ctrl io_config4_mask: sel_spi2_app (Bit 7)       */
#define asic_ctrl_io_config4_mask_sel_spi2_app_Msk (0x80UL)         /*!< asic_ctrl io_config4_mask: sel_spi2_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_spi0_app_cs1_Pos (6UL)        /*!< asic_ctrl io_config4_mask: sel_spi0_app_cs1 (Bit 6)   */
#define asic_ctrl_io_config4_mask_sel_spi0_app_cs1_Msk (0x40UL)     /*!< asic_ctrl io_config4_mask: sel_spi0_app_cs1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_spi0_app_Pos (5UL)            /*!< asic_ctrl io_config4_mask: sel_spi0_app (Bit 5)       */
#define asic_ctrl_io_config4_mask_sel_spi0_app_Msk (0x20UL)         /*!< asic_ctrl io_config4_mask: sel_spi0_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_uart_xpic_app_rctsn_Pos (4UL) /*!< asic_ctrl io_config4_mask: sel_uart_xpic_app_rctsn (Bit 4) */
#define asic_ctrl_io_config4_mask_sel_uart_xpic_app_rctsn_Msk (0x10UL) /*!< asic_ctrl io_config4_mask: sel_uart_xpic_app_rctsn (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_uart_xpic_app_Pos (3UL)       /*!< asic_ctrl io_config4_mask: sel_uart_xpic_app (Bit 3)  */
#define asic_ctrl_io_config4_mask_sel_uart_xpic_app_Msk (0x8UL)     /*!< asic_ctrl io_config4_mask: sel_uart_xpic_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_uart_app_rctsn_Pos (2UL)      /*!< asic_ctrl io_config4_mask: sel_uart_app_rctsn (Bit 2) */
#define asic_ctrl_io_config4_mask_sel_uart_app_rctsn_Msk (0x4UL)    /*!< asic_ctrl io_config4_mask: sel_uart_app_rctsn (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_uart_app_Pos (1UL)            /*!< asic_ctrl io_config4_mask: sel_uart_app (Bit 1)       */
#define asic_ctrl_io_config4_mask_sel_uart_app_Msk (0x2UL)          /*!< asic_ctrl io_config4_mask: sel_uart_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config4_mask_sel_i2c_app_Pos (0UL)             /*!< asic_ctrl io_config4_mask: sel_i2c_app (Bit 0)        */
#define asic_ctrl_io_config4_mask_sel_i2c_app_Msk (0x1UL)           /*!< asic_ctrl io_config4_mask: sel_i2c_app (Bitfield-Mask: 0x01) */
/* ======================================================  io_config5  ======================================================= */
#define asic_ctrl_io_config5_sel_mled11_Pos (15UL)                  /*!< asic_ctrl io_config5: sel_mled11 (Bit 15)             */
#define asic_ctrl_io_config5_sel_mled11_Msk (0x8000UL)              /*!< asic_ctrl io_config5: sel_mled11 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_mled10_Pos (14UL)                  /*!< asic_ctrl io_config5: sel_mled10 (Bit 14)             */
#define asic_ctrl_io_config5_sel_mled10_Msk (0x4000UL)              /*!< asic_ctrl io_config5: sel_mled10 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_mled9_Pos (13UL)                   /*!< asic_ctrl io_config5: sel_mled9 (Bit 13)              */
#define asic_ctrl_io_config5_sel_mled9_Msk (0x2000UL)               /*!< asic_ctrl io_config5: sel_mled9 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_mled8_Pos (12UL)                   /*!< asic_ctrl io_config5: sel_mled8 (Bit 12)              */
#define asic_ctrl_io_config5_sel_mled8_Msk (0x1000UL)               /*!< asic_ctrl io_config5: sel_mled8 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_mled7_Pos (11UL)                   /*!< asic_ctrl io_config5: sel_mled7 (Bit 11)              */
#define asic_ctrl_io_config5_sel_mled7_Msk (0x800UL)                /*!< asic_ctrl io_config5: sel_mled7 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_mled6_Pos (10UL)                   /*!< asic_ctrl io_config5: sel_mled6 (Bit 10)              */
#define asic_ctrl_io_config5_sel_mled6_Msk (0x400UL)                /*!< asic_ctrl io_config5: sel_mled6 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_mled5_Pos (9UL)                    /*!< asic_ctrl io_config5: sel_mled5 (Bit 9)               */
#define asic_ctrl_io_config5_sel_mled5_Msk (0x200UL)                /*!< asic_ctrl io_config5: sel_mled5 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_mled4_Pos (8UL)                    /*!< asic_ctrl io_config5: sel_mled4 (Bit 8)               */
#define asic_ctrl_io_config5_sel_mled4_Msk (0x100UL)                /*!< asic_ctrl io_config5: sel_mled4 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_sel_pio_app_Pos (0UL)                  /*!< asic_ctrl io_config5: sel_pio_app (Bit 0)             */
#define asic_ctrl_io_config5_sel_pio_app_Msk (0xffUL)               /*!< asic_ctrl io_config5: sel_pio_app (Bitfield-Mask: 0xff) */
/* ====================================================  io_config5_mask  ==================================================== */
#define asic_ctrl_io_config5_mask_sel_mled11_Pos (15UL)             /*!< asic_ctrl io_config5_mask: sel_mled11 (Bit 15)        */
#define asic_ctrl_io_config5_mask_sel_mled11_Msk (0x8000UL)         /*!< asic_ctrl io_config5_mask: sel_mled11 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_mled10_Pos (14UL)             /*!< asic_ctrl io_config5_mask: sel_mled10 (Bit 14)        */
#define asic_ctrl_io_config5_mask_sel_mled10_Msk (0x4000UL)         /*!< asic_ctrl io_config5_mask: sel_mled10 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_mled9_Pos (13UL)              /*!< asic_ctrl io_config5_mask: sel_mled9 (Bit 13)         */
#define asic_ctrl_io_config5_mask_sel_mled9_Msk (0x2000UL)          /*!< asic_ctrl io_config5_mask: sel_mled9 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_mled8_Pos (12UL)              /*!< asic_ctrl io_config5_mask: sel_mled8 (Bit 12)         */
#define asic_ctrl_io_config5_mask_sel_mled8_Msk (0x1000UL)          /*!< asic_ctrl io_config5_mask: sel_mled8 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_mled7_Pos (11UL)              /*!< asic_ctrl io_config5_mask: sel_mled7 (Bit 11)         */
#define asic_ctrl_io_config5_mask_sel_mled7_Msk (0x800UL)           /*!< asic_ctrl io_config5_mask: sel_mled7 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_mled6_Pos (10UL)              /*!< asic_ctrl io_config5_mask: sel_mled6 (Bit 10)         */
#define asic_ctrl_io_config5_mask_sel_mled6_Msk (0x400UL)           /*!< asic_ctrl io_config5_mask: sel_mled6 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_mled5_Pos (9UL)               /*!< asic_ctrl io_config5_mask: sel_mled5 (Bit 9)          */
#define asic_ctrl_io_config5_mask_sel_mled5_Msk (0x200UL)           /*!< asic_ctrl io_config5_mask: sel_mled5 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_mled4_Pos (8UL)               /*!< asic_ctrl io_config5_mask: sel_mled4 (Bit 8)          */
#define asic_ctrl_io_config5_mask_sel_mled4_Msk (0x100UL)           /*!< asic_ctrl io_config5_mask: sel_mled4 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config5_mask_sel_pio_app_Pos (0UL)             /*!< asic_ctrl io_config5_mask: sel_pio_app (Bit 0)        */
#define asic_ctrl_io_config5_mask_sel_pio_app_Msk (0xffUL)          /*!< asic_ctrl io_config5_mask: sel_pio_app (Bitfield-Mask: 0xff) */
/* ======================================================  io_config6  ======================================================= */
#define asic_ctrl_io_config6_sel_io_link7_Pos (9UL)                 /*!< asic_ctrl io_config6: sel_io_link7 (Bit 9)            */
#define asic_ctrl_io_config6_sel_io_link7_Msk (0x200UL)             /*!< asic_ctrl io_config6: sel_io_link7 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link6_Pos (8UL)                 /*!< asic_ctrl io_config6: sel_io_link6 (Bit 8)            */
#define asic_ctrl_io_config6_sel_io_link6_Msk (0x100UL)             /*!< asic_ctrl io_config6: sel_io_link6 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link5_Pos (7UL)                 /*!< asic_ctrl io_config6: sel_io_link5 (Bit 7)            */
#define asic_ctrl_io_config6_sel_io_link5_Msk (0x80UL)              /*!< asic_ctrl io_config6: sel_io_link5 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link4_Pos (6UL)                 /*!< asic_ctrl io_config6: sel_io_link4 (Bit 6)            */
#define asic_ctrl_io_config6_sel_io_link4_Msk (0x40UL)              /*!< asic_ctrl io_config6: sel_io_link4 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link3_Pos (5UL)                 /*!< asic_ctrl io_config6: sel_io_link3 (Bit 5)            */
#define asic_ctrl_io_config6_sel_io_link3_Msk (0x20UL)              /*!< asic_ctrl io_config6: sel_io_link3 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link2_Pos (4UL)                 /*!< asic_ctrl io_config6: sel_io_link2 (Bit 4)            */
#define asic_ctrl_io_config6_sel_io_link2_Msk (0x10UL)              /*!< asic_ctrl io_config6: sel_io_link2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link1b_Pos (3UL)                /*!< asic_ctrl io_config6: sel_io_link1b (Bit 3)           */
#define asic_ctrl_io_config6_sel_io_link1b_Msk (0x8UL)              /*!< asic_ctrl io_config6: sel_io_link1b (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link1_Pos (2UL)                 /*!< asic_ctrl io_config6: sel_io_link1 (Bit 2)            */
#define asic_ctrl_io_config6_sel_io_link1_Msk (0x4UL)               /*!< asic_ctrl io_config6: sel_io_link1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link0b_Pos (1UL)                /*!< asic_ctrl io_config6: sel_io_link0b (Bit 1)           */
#define asic_ctrl_io_config6_sel_io_link0b_Msk (0x2UL)              /*!< asic_ctrl io_config6: sel_io_link0b (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_sel_io_link0_Pos (0UL)                 /*!< asic_ctrl io_config6: sel_io_link0 (Bit 0)            */
#define asic_ctrl_io_config6_sel_io_link0_Msk (0x1UL)               /*!< asic_ctrl io_config6: sel_io_link0 (Bitfield-Mask: 0x01) */
/* ====================================================  io_config6_mask  ==================================================== */
#define asic_ctrl_io_config6_mask_sel_io_link7_Pos (9UL)            /*!< asic_ctrl io_config6_mask: sel_io_link7 (Bit 9)       */
#define asic_ctrl_io_config6_mask_sel_io_link7_Msk (0x200UL)        /*!< asic_ctrl io_config6_mask: sel_io_link7 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link6_Pos (8UL)            /*!< asic_ctrl io_config6_mask: sel_io_link6 (Bit 8)       */
#define asic_ctrl_io_config6_mask_sel_io_link6_Msk (0x100UL)        /*!< asic_ctrl io_config6_mask: sel_io_link6 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link5_Pos (7UL)            /*!< asic_ctrl io_config6_mask: sel_io_link5 (Bit 7)       */
#define asic_ctrl_io_config6_mask_sel_io_link5_Msk (0x80UL)         /*!< asic_ctrl io_config6_mask: sel_io_link5 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link4_Pos (6UL)            /*!< asic_ctrl io_config6_mask: sel_io_link4 (Bit 6)       */
#define asic_ctrl_io_config6_mask_sel_io_link4_Msk (0x40UL)         /*!< asic_ctrl io_config6_mask: sel_io_link4 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link3_Pos (5UL)            /*!< asic_ctrl io_config6_mask: sel_io_link3 (Bit 5)       */
#define asic_ctrl_io_config6_mask_sel_io_link3_Msk (0x20UL)         /*!< asic_ctrl io_config6_mask: sel_io_link3 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link2_Pos (4UL)            /*!< asic_ctrl io_config6_mask: sel_io_link2 (Bit 4)       */
#define asic_ctrl_io_config6_mask_sel_io_link2_Msk (0x10UL)         /*!< asic_ctrl io_config6_mask: sel_io_link2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link1b_Pos (3UL)           /*!< asic_ctrl io_config6_mask: sel_io_link1b (Bit 3)      */
#define asic_ctrl_io_config6_mask_sel_io_link1b_Msk (0x8UL)         /*!< asic_ctrl io_config6_mask: sel_io_link1b (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link1_Pos (2UL)            /*!< asic_ctrl io_config6_mask: sel_io_link1 (Bit 2)       */
#define asic_ctrl_io_config6_mask_sel_io_link1_Msk (0x4UL)          /*!< asic_ctrl io_config6_mask: sel_io_link1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link0b_Pos (1UL)           /*!< asic_ctrl io_config6_mask: sel_io_link0b (Bit 1)      */
#define asic_ctrl_io_config6_mask_sel_io_link0b_Msk (0x2UL)         /*!< asic_ctrl io_config6_mask: sel_io_link0b (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config6_mask_sel_io_link0_Pos (0UL)            /*!< asic_ctrl io_config6_mask: sel_io_link0 (Bit 0)       */
#define asic_ctrl_io_config6_mask_sel_io_link0_Msk (0x1UL)          /*!< asic_ctrl io_config6_mask: sel_io_link0 (Bitfield-Mask: 0x01) */
/* ======================================================  io_config7  ======================================================= */
#define asic_ctrl_io_config7_sel_sqi_cs2_Pos (8UL)                  /*!< asic_ctrl io_config7: sel_sqi_cs2 (Bit 8)             */
#define asic_ctrl_io_config7_sel_sqi_cs2_Msk (0x100UL)              /*!< asic_ctrl io_config7: sel_sqi_cs2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config7_sel_sqi_cs1_Pos (7UL)                  /*!< asic_ctrl io_config7: sel_sqi_cs1 (Bit 7)             */
#define asic_ctrl_io_config7_sel_sqi_cs1_Msk (0x80UL)               /*!< asic_ctrl io_config7: sel_sqi_cs1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config7_sel_eth_mdio_Pos (5UL)                 /*!< asic_ctrl io_config7: sel_eth_mdio (Bit 5)            */
#define asic_ctrl_io_config7_sel_eth_mdio_Msk (0x60UL)              /*!< asic_ctrl io_config7: sel_eth_mdio (Bitfield-Mask: 0x03) */
#define asic_ctrl_io_config7_sel_eth_cfg_Pos (0UL)                  /*!< asic_ctrl io_config7: sel_eth_cfg (Bit 0)             */
#define asic_ctrl_io_config7_sel_eth_cfg_Msk (0x1fUL)               /*!< asic_ctrl io_config7: sel_eth_cfg (Bitfield-Mask: 0x1f) */
/* ====================================================  io_config7_mask  ==================================================== */
#define asic_ctrl_io_config7_mask_sel_sqi_cs2_Pos (8UL)             /*!< asic_ctrl io_config7_mask: sel_sqi_cs2 (Bit 8)        */
#define asic_ctrl_io_config7_mask_sel_sqi_cs2_Msk (0x100UL)         /*!< asic_ctrl io_config7_mask: sel_sqi_cs2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config7_mask_sel_sqi_cs1_Pos (7UL)             /*!< asic_ctrl io_config7_mask: sel_sqi_cs1 (Bit 7)        */
#define asic_ctrl_io_config7_mask_sel_sqi_cs1_Msk (0x80UL)          /*!< asic_ctrl io_config7_mask: sel_sqi_cs1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_io_config7_mask_sel_eth_mdio_Pos (5UL)            /*!< asic_ctrl io_config7_mask: sel_eth_mdio (Bit 5)       */
#define asic_ctrl_io_config7_mask_sel_eth_mdio_Msk (0x60UL)         /*!< asic_ctrl io_config7_mask: sel_eth_mdio (Bitfield-Mask: 0x03) */
#define asic_ctrl_io_config7_mask_sel_eth_cfg_Pos (0UL)             /*!< asic_ctrl io_config7_mask: sel_eth_cfg (Bit 0)        */
#define asic_ctrl_io_config7_mask_sel_eth_cfg_Msk (0x1fUL)          /*!< asic_ctrl io_config7_mask: sel_eth_cfg (Bitfield-Mask: 0x1f) */
/* ======================================================  io_config8  ======================================================= */
#define asic_ctrl_io_config8_sel_arm_trace_cfg_Pos (0UL)            /*!< asic_ctrl io_config8: sel_arm_trace_cfg (Bit 0)       */
#define asic_ctrl_io_config8_sel_arm_trace_cfg_Msk (0x3UL)          /*!< asic_ctrl io_config8: sel_arm_trace_cfg (Bitfield-Mask: 0x03) */
/* ====================================================  io_config8_mask  ==================================================== */
#define asic_ctrl_io_config8_mask_sel_arm_trace_cfg_Pos (0UL)       /*!< asic_ctrl io_config8_mask: sel_arm_trace_cfg (Bit 0)  */
#define asic_ctrl_io_config8_mask_sel_arm_trace_cfg_Msk (0x3UL)     /*!< asic_ctrl io_config8_mask: sel_arm_trace_cfg (Bitfield-Mask: 0x03) */
/* =====================================================  clock_enable0  ===================================================== */
#define asic_ctrl_clock_enable0_dpm_Pos   (13UL)                    /*!< asic_ctrl clock_enable0: dpm (Bit 13)                 */
#define asic_ctrl_clock_enable0_dpm_Msk   (0x2000UL)                /*!< asic_ctrl clock_enable0: dpm (Bitfield-Mask: 0x01)    */
#define asic_ctrl_clock_enable0_debug_Pos (12UL)                    /*!< asic_ctrl clock_enable0: debug (Bit 12)               */
#define asic_ctrl_clock_enable0_debug_Msk (0x1000UL)                /*!< asic_ctrl clock_enable0: debug (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable0_arm_app_Pos (11UL)                  /*!< asic_ctrl clock_enable0: arm_app (Bit 11)             */
#define asic_ctrl_clock_enable0_arm_app_Msk (0x800UL)               /*!< asic_ctrl clock_enable0: arm_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_dma_com_Pos (10UL)                  /*!< asic_ctrl clock_enable0: dma_com (Bit 10)             */
#define asic_ctrl_clock_enable0_dma_com_Msk (0x400UL)               /*!< asic_ctrl clock_enable0: dma_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_xpic0_Pos (9UL)                     /*!< asic_ctrl clock_enable0: xpic0 (Bit 9)                */
#define asic_ctrl_clock_enable0_xpic0_Msk (0x200UL)                 /*!< asic_ctrl clock_enable0: xpic0 (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable0_xc_misc_Pos (8UL)                   /*!< asic_ctrl clock_enable0: xc_misc (Bit 8)              */
#define asic_ctrl_clock_enable0_xc_misc_Msk (0x100UL)               /*!< asic_ctrl clock_enable0: xc_misc (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_fb1_Pos   (7UL)                     /*!< asic_ctrl clock_enable0: fb1 (Bit 7)                  */
#define asic_ctrl_clock_enable0_fb1_Msk   (0x80UL)                  /*!< asic_ctrl clock_enable0: fb1 (Bitfield-Mask: 0x01)    */
#define asic_ctrl_clock_enable0_fb0_Pos   (6UL)                     /*!< asic_ctrl clock_enable0: fb0 (Bit 6)                  */
#define asic_ctrl_clock_enable0_fb0_Msk   (0x40UL)                  /*!< asic_ctrl clock_enable0: fb0 (Bitfield-Mask: 0x01)    */
#define asic_ctrl_clock_enable0_xmac1_Pos (5UL)                     /*!< asic_ctrl clock_enable0: xmac1 (Bit 5)                */
#define asic_ctrl_clock_enable0_xmac1_Msk (0x20UL)                  /*!< asic_ctrl clock_enable0: xmac1 (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable0_xmac0_Pos (4UL)                     /*!< asic_ctrl clock_enable0: xmac0 (Bit 4)                */
#define asic_ctrl_clock_enable0_xmac0_Msk (0x10UL)                  /*!< asic_ctrl clock_enable0: xmac0 (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable0_tpec1_Pos (3UL)                     /*!< asic_ctrl clock_enable0: tpec1 (Bit 3)                */
#define asic_ctrl_clock_enable0_tpec1_Msk (0x8UL)                   /*!< asic_ctrl clock_enable0: tpec1 (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable0_tpec0_Pos (2UL)                     /*!< asic_ctrl clock_enable0: tpec0 (Bit 2)                */
#define asic_ctrl_clock_enable0_tpec0_Msk (0x4UL)                   /*!< asic_ctrl clock_enable0: tpec0 (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable0_rpec1_Pos (1UL)                     /*!< asic_ctrl clock_enable0: rpec1 (Bit 1)                */
#define asic_ctrl_clock_enable0_rpec1_Msk (0x2UL)                   /*!< asic_ctrl clock_enable0: rpec1 (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable0_rpec0_Pos (0UL)                     /*!< asic_ctrl clock_enable0: rpec0 (Bit 0)                */
#define asic_ctrl_clock_enable0_rpec0_Msk (0x1UL)                   /*!< asic_ctrl clock_enable0: rpec0 (Bitfield-Mask: 0x01)  */
/* ==================================================  clock_enable0_mask  =================================================== */
#define asic_ctrl_clock_enable0_mask_dpm_Pos (13UL)                 /*!< asic_ctrl clock_enable0_mask: dpm (Bit 13)            */
#define asic_ctrl_clock_enable0_mask_dpm_Msk (0x2000UL)             /*!< asic_ctrl clock_enable0_mask: dpm (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_debug_Pos (12UL)               /*!< asic_ctrl clock_enable0_mask: debug (Bit 12)          */
#define asic_ctrl_clock_enable0_mask_debug_Msk (0x1000UL)           /*!< asic_ctrl clock_enable0_mask: debug (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_arm_app_Pos (11UL)             /*!< asic_ctrl clock_enable0_mask: arm_app (Bit 11)        */
#define asic_ctrl_clock_enable0_mask_arm_app_Msk (0x800UL)          /*!< asic_ctrl clock_enable0_mask: arm_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_dma_com_Pos (10UL)             /*!< asic_ctrl clock_enable0_mask: dma_com (Bit 10)        */
#define asic_ctrl_clock_enable0_mask_dma_com_Msk (0x400UL)          /*!< asic_ctrl clock_enable0_mask: dma_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_xpic0_Pos (9UL)                /*!< asic_ctrl clock_enable0_mask: xpic0 (Bit 9)           */
#define asic_ctrl_clock_enable0_mask_xpic0_Msk (0x200UL)            /*!< asic_ctrl clock_enable0_mask: xpic0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_xc_misc_Pos (8UL)              /*!< asic_ctrl clock_enable0_mask: xc_misc (Bit 8)         */
#define asic_ctrl_clock_enable0_mask_xc_misc_Msk (0x100UL)          /*!< asic_ctrl clock_enable0_mask: xc_misc (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_fb1_Pos (7UL)                  /*!< asic_ctrl clock_enable0_mask: fb1 (Bit 7)             */
#define asic_ctrl_clock_enable0_mask_fb1_Msk (0x80UL)               /*!< asic_ctrl clock_enable0_mask: fb1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_fb0_Pos (6UL)                  /*!< asic_ctrl clock_enable0_mask: fb0 (Bit 6)             */
#define asic_ctrl_clock_enable0_mask_fb0_Msk (0x40UL)               /*!< asic_ctrl clock_enable0_mask: fb0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_xmac1_Pos (5UL)                /*!< asic_ctrl clock_enable0_mask: xmac1 (Bit 5)           */
#define asic_ctrl_clock_enable0_mask_xmac1_Msk (0x20UL)             /*!< asic_ctrl clock_enable0_mask: xmac1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_xmac0_Pos (4UL)                /*!< asic_ctrl clock_enable0_mask: xmac0 (Bit 4)           */
#define asic_ctrl_clock_enable0_mask_xmac0_Msk (0x10UL)             /*!< asic_ctrl clock_enable0_mask: xmac0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_tpec1_Pos (3UL)                /*!< asic_ctrl clock_enable0_mask: tpec1 (Bit 3)           */
#define asic_ctrl_clock_enable0_mask_tpec1_Msk (0x8UL)              /*!< asic_ctrl clock_enable0_mask: tpec1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_tpec0_Pos (2UL)                /*!< asic_ctrl clock_enable0_mask: tpec0 (Bit 2)           */
#define asic_ctrl_clock_enable0_mask_tpec0_Msk (0x4UL)              /*!< asic_ctrl clock_enable0_mask: tpec0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_rpec1_Pos (1UL)                /*!< asic_ctrl clock_enable0_mask: rpec1 (Bit 1)           */
#define asic_ctrl_clock_enable0_mask_rpec1_Msk (0x2UL)              /*!< asic_ctrl clock_enable0_mask: rpec1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable0_mask_rpec0_Pos (0UL)                /*!< asic_ctrl clock_enable0_mask: rpec0 (Bit 0)           */
#define asic_ctrl_clock_enable0_mask_rpec0_Msk (0x1UL)              /*!< asic_ctrl clock_enable0_mask: rpec0 (Bitfield-Mask: 0x01) */
/* =====================================================  clock_enable1  ===================================================== */
#define asic_ctrl_clock_enable1_crypt_Pos (2UL)                     /*!< asic_ctrl clock_enable1: crypt (Bit 2)                */
#define asic_ctrl_clock_enable1_crypt_Msk (0x4UL)                   /*!< asic_ctrl clock_enable1: crypt (Bitfield-Mask: 0x01)  */
#define asic_ctrl_clock_enable1_dma_app_Pos (1UL)                   /*!< asic_ctrl clock_enable1: dma_app (Bit 1)              */
#define asic_ctrl_clock_enable1_dma_app_Msk (0x2UL)                 /*!< asic_ctrl clock_enable1: dma_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable1_xpic1_Pos (0UL)                     /*!< asic_ctrl clock_enable1: xpic1 (Bit 0)                */
#define asic_ctrl_clock_enable1_xpic1_Msk (0x1UL)                   /*!< asic_ctrl clock_enable1: xpic1 (Bitfield-Mask: 0x01)  */
/* ==================================================  clock_enable1_mask  =================================================== */
#define asic_ctrl_clock_enable1_mask_crypt_Pos (2UL)                /*!< asic_ctrl clock_enable1_mask: crypt (Bit 2)           */
#define asic_ctrl_clock_enable1_mask_crypt_Msk (0x4UL)              /*!< asic_ctrl clock_enable1_mask: crypt (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable1_mask_dma_app_Pos (1UL)              /*!< asic_ctrl clock_enable1_mask: dma_app (Bit 1)         */
#define asic_ctrl_clock_enable1_mask_dma_app_Msk (0x2UL)            /*!< asic_ctrl clock_enable1_mask: dma_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_clock_enable1_mask_xpic1_Pos (0UL)                /*!< asic_ctrl clock_enable1_mask: xpic1 (Bit 0)           */
#define asic_ctrl_clock_enable1_mask_xpic1_Msk (0x1UL)              /*!< asic_ctrl clock_enable1_mask: xpic1 (Bitfield-Mask: 0x01) */
/* ======================================================  reset_ctrl  ======================================================= */
#define asic_ctrl_reset_ctrl_reserved1_Pos (28UL)                   /*!< asic_ctrl reset_ctrl: reserved1 (Bit 28)              */
#define asic_ctrl_reset_ctrl_reserved1_Msk (0xf0000000UL)           /*!< asic_ctrl reset_ctrl: reserved1 (Bitfield-Mask: 0x0f) */
#define asic_ctrl_reset_ctrl_rst_out_n_in_ro_Pos (27UL)             /*!< asic_ctrl reset_ctrl: rst_out_n_in_ro (Bit 27)        */
#define asic_ctrl_reset_ctrl_rst_out_n_in_ro_Msk (0x8000000UL)      /*!< asic_ctrl reset_ctrl: rst_out_n_in_ro (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_EN_RES_REQ_OUT_Pos (26UL)              /*!< asic_ctrl reset_ctrl: EN_RES_REQ_OUT (Bit 26)         */
#define asic_ctrl_reset_ctrl_EN_RES_REQ_OUT_Msk (0x4000000UL)       /*!< asic_ctrl reset_ctrl: EN_RES_REQ_OUT (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_RES_REQ_OUT_Pos (25UL)                 /*!< asic_ctrl reset_ctrl: RES_REQ_OUT (Bit 25)            */
#define asic_ctrl_reset_ctrl_RES_REQ_OUT_Msk (0x2000000UL)          /*!< asic_ctrl reset_ctrl: RES_REQ_OUT (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_RES_REQ_FIRMWARE_Pos (24UL)            /*!< asic_ctrl reset_ctrl: RES_REQ_FIRMWARE (Bit 24)       */
#define asic_ctrl_reset_ctrl_RES_REQ_FIRMWARE_Msk (0x1000000UL)     /*!< asic_ctrl reset_ctrl: RES_REQ_FIRMWARE (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS3_Pos (23UL)            /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS3 (Bit 23)       */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS3_Msk (0x800000UL)      /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS3 (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS2_Pos (22UL)            /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS2 (Bit 22)       */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS2_Msk (0x400000UL)      /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS2 (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS1_Pos (21UL)            /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS1 (Bit 21)       */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS1_Msk (0x200000UL)      /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS1 (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS0_Pos (20UL)            /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS0 (Bit 20)       */
#define asic_ctrl_reset_ctrl_FIRMWARE_STATUS0_Msk (0x100000UL)      /*!< asic_ctrl reset_ctrl: FIRMWARE_STATUS0 (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_reserved0_Pos (6UL)                    /*!< asic_ctrl reset_ctrl: reserved0 (Bit 6)               */
#define asic_ctrl_reset_ctrl_reserved0_Msk (0xfffc0UL)              /*!< asic_ctrl reset_ctrl: reserved0 (Bitfield-Mask: 0x3fff) */
#define asic_ctrl_reset_ctrl_RES_ARM_APP_Pos (5UL)                  /*!< asic_ctrl reset_ctrl: RES_ARM_APP (Bit 5)             */
#define asic_ctrl_reset_ctrl_RES_ARM_APP_Msk (0x20UL)               /*!< asic_ctrl reset_ctrl: RES_ARM_APP (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_RES_ARM_COM_Pos (4UL)                  /*!< asic_ctrl reset_ctrl: RES_ARM_COM (Bit 4)             */
#define asic_ctrl_reset_ctrl_RES_ARM_COM_Msk (0x10UL)               /*!< asic_ctrl reset_ctrl: RES_ARM_COM (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_RES_FIRMWARE_Pos (3UL)                 /*!< asic_ctrl reset_ctrl: RES_FIRMWARE (Bit 3)            */
#define asic_ctrl_reset_ctrl_RES_FIRMWARE_Msk (0x8UL)               /*!< asic_ctrl reset_ctrl: RES_FIRMWARE (Bitfield-Mask: 0x01) */
#define asic_ctrl_reset_ctrl_RES_HOST_Pos (2UL)                     /*!< asic_ctrl reset_ctrl: RES_HOST (Bit 2)                */
#define asic_ctrl_reset_ctrl_RES_HOST_Msk (0x4UL)                   /*!< asic_ctrl reset_ctrl: RES_HOST (Bitfield-Mask: 0x01)  */
#define asic_ctrl_reset_ctrl_RES_WDOG_Pos (1UL)                     /*!< asic_ctrl reset_ctrl: RES_WDOG (Bit 1)                */
#define asic_ctrl_reset_ctrl_RES_WDOG_Msk (0x2UL)                   /*!< asic_ctrl reset_ctrl: RES_WDOG (Bitfield-Mask: 0x01)  */
#define asic_ctrl_reset_ctrl_RES_IN_Pos   (0UL)                     /*!< asic_ctrl reset_ctrl: RES_IN (Bit 0)                  */
#define asic_ctrl_reset_ctrl_RES_IN_Msk   (0x1UL)                   /*!< asic_ctrl reset_ctrl: RES_IN (Bitfield-Mask: 0x01)    */
/* ===================================================  ahbl_master_ready  =================================================== */
#define asic_ctrl_ahbl_master_ready_val_Pos (0UL)                   /*!< asic_ctrl ahbl_master_ready: val (Bit 0)              */
#define asic_ctrl_ahbl_master_ready_val_Msk (0x7ffffUL)             /*!< asic_ctrl ahbl_master_ready: val (Bitfield-Mask: 0x7ffff) */
/* =====================================================  system_status  ===================================================== */
#define asic_ctrl_system_status_reserved2_Pos (17UL)                /*!< asic_ctrl system_status: reserved2 (Bit 17)           */
#define asic_ctrl_system_status_reserved2_Msk (0xfffe0000UL)        /*!< asic_ctrl system_status: reserved2 (Bitfield-Mask: 0x7fff) */
#define asic_ctrl_system_status_lic_err_abort_status_Pos (16UL)     /*!< asic_ctrl system_status: lic_err_abort_status (Bit 16) */
#define asic_ctrl_system_status_lic_err_abort_status_Msk (0x10000UL) /*!< asic_ctrl system_status: lic_err_abort_status (Bitfield-Mask: 0x01) */
#define asic_ctrl_system_status_reserved1_Pos (12UL)                /*!< asic_ctrl system_status: reserved1 (Bit 12)           */
#define asic_ctrl_system_status_reserved1_Msk (0xf000UL)            /*!< asic_ctrl system_status: reserved1 (Bitfield-Mask: 0x0f) */
#define asic_ctrl_system_status_quick_count_Pos (11UL)              /*!< asic_ctrl system_status: quick_count (Bit 11)         */
#define asic_ctrl_system_status_quick_count_Msk (0x800UL)           /*!< asic_ctrl system_status: quick_count (Bitfield-Mask: 0x01) */
#define asic_ctrl_system_status_pll_bypass_Pos (10UL)               /*!< asic_ctrl system_status: pll_bypass (Bit 10)          */
#define asic_ctrl_system_status_pll_bypass_Msk (0x400UL)            /*!< asic_ctrl system_status: pll_bypass (Bitfield-Mask: 0x01) */
#define asic_ctrl_system_status_pw_bod_ok_Pos (9UL)                 /*!< asic_ctrl system_status: pw_bod_ok (Bit 9)            */
#define asic_ctrl_system_status_pw_bod_ok_Msk (0x200UL)             /*!< asic_ctrl system_status: pw_bod_ok (Bitfield-Mask: 0x01) */
#define asic_ctrl_system_status_testmode_Pos (8UL)                  /*!< asic_ctrl system_status: testmode (Bit 8)             */
#define asic_ctrl_system_status_testmode_Msk (0x100UL)              /*!< asic_ctrl system_status: testmode (Bitfield-Mask: 0x01) */
#define asic_ctrl_system_status_reserved0_Pos (2UL)                 /*!< asic_ctrl system_status: reserved0 (Bit 2)            */
#define asic_ctrl_system_status_reserved0_Msk (0xfcUL)              /*!< asic_ctrl system_status: reserved0 (Bitfield-Mask: 0x3f) */
#define asic_ctrl_system_status_extbus_to_irq_status_Pos (1UL)      /*!< asic_ctrl system_status: extbus_to_irq_status (Bit 1) */
#define asic_ctrl_system_status_extbus_to_irq_status_Msk (0x2UL)    /*!< asic_ctrl system_status: extbus_to_irq_status (Bitfield-Mask: 0x01) */
#define asic_ctrl_system_status_lic_err_irq_status_Pos (0UL)        /*!< asic_ctrl system_status: lic_err_irq_status (Bit 0)   */
#define asic_ctrl_system_status_lic_err_irq_status_Msk (0x1UL)      /*!< asic_ctrl system_status: lic_err_irq_status (Bitfield-Mask: 0x01) */
/* ===================================================  systime_feth_ctrl  =================================================== */
#define asic_ctrl_systime_feth_ctrl_feth_Pos (0UL)                  /*!< asic_ctrl systime_feth_ctrl: feth (Bit 0)             */
#define asic_ctrl_systime_feth_ctrl_feth_Msk (0x3UL)                /*!< asic_ctrl systime_feth_ctrl: feth (Bitfield-Mask: 0x03) */
/* =================================================  systime_gpio_app_ctrl  ================================================= */
#define asic_ctrl_systime_gpio_app_ctrl_gpio_app_Pos (0UL)          /*!< asic_ctrl systime_gpio_app_ctrl: gpio_app (Bit 0)     */
#define asic_ctrl_systime_gpio_app_ctrl_gpio_app_Msk (0x3UL)        /*!< asic_ctrl systime_gpio_app_ctrl: gpio_app (Bitfield-Mask: 0x03) */
/* =======================================================  only_porn  ======================================================= */
#define asic_ctrl_only_porn_only_porn_Pos (0UL)                     /*!< asic_ctrl only_porn: only_porn (Bit 0)                */
#define asic_ctrl_only_porn_only_porn_Msk (0xffffffffUL)            /*!< asic_ctrl only_porn: only_porn (Bitfield-Mask: 0xffffffff) */
/* =====================================================  only_porn_rom  ===================================================== */
#define asic_ctrl_only_porn_rom_val_Pos   (0UL)                     /*!< asic_ctrl only_porn_rom: val (Bit 0)                  */
#define asic_ctrl_only_porn_rom_val_Msk   (0xffffffffUL)            /*!< asic_ctrl only_porn_rom: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  netx_version  ====================================================== */
#define asic_ctrl_netx_version_netx_version_Pos (0UL)               /*!< asic_ctrl netx_version: netx_version (Bit 0)          */
#define asic_ctrl_netx_version_netx_version_Msk (0xffffffffUL)      /*!< asic_ctrl netx_version: netx_version (Bitfield-Mask: 0xffffffff) */
/* ======================================================  netx_status  ====================================================== */
#define asic_ctrl_netx_status_reserved1_Pos (26UL)                  /*!< asic_ctrl netx_status: reserved1 (Bit 26)             */
#define asic_ctrl_netx_status_reserved1_Msk (0xfc000000UL)          /*!< asic_ctrl netx_status: reserved1 (Bitfield-Mask: 0x3f) */
#define asic_ctrl_netx_status_RUN_DRV_Pos (25UL)                    /*!< asic_ctrl netx_status: RUN_DRV (Bit 25)               */
#define asic_ctrl_netx_status_RUN_DRV_Msk (0x2000000UL)             /*!< asic_ctrl netx_status: RUN_DRV (Bitfield-Mask: 0x01)  */
#define asic_ctrl_netx_status_RDY_DRV_Pos (24UL)                    /*!< asic_ctrl netx_status: RDY_DRV (Bit 24)               */
#define asic_ctrl_netx_status_RDY_DRV_Msk (0x1000000UL)             /*!< asic_ctrl netx_status: RDY_DRV (Bitfield-Mask: 0x01)  */
#define asic_ctrl_netx_status_reserved0_Pos (20UL)                  /*!< asic_ctrl netx_status: reserved0 (Bit 20)             */
#define asic_ctrl_netx_status_reserved0_Msk (0xf00000UL)            /*!< asic_ctrl netx_status: reserved0 (Bitfield-Mask: 0x0f) */
#define asic_ctrl_netx_status_RUN_POL_Pos (19UL)                    /*!< asic_ctrl netx_status: RUN_POL (Bit 19)               */
#define asic_ctrl_netx_status_RUN_POL_Msk (0x80000UL)               /*!< asic_ctrl netx_status: RUN_POL (Bitfield-Mask: 0x01)  */
#define asic_ctrl_netx_status_RDY_POL_Pos (18UL)                    /*!< asic_ctrl netx_status: RDY_POL (Bit 18)               */
#define asic_ctrl_netx_status_RDY_POL_Msk (0x40000UL)               /*!< asic_ctrl netx_status: RDY_POL (Bitfield-Mask: 0x01)  */
#define asic_ctrl_netx_status_RUN_IN_Pos  (17UL)                    /*!< asic_ctrl netx_status: RUN_IN (Bit 17)                */
#define asic_ctrl_netx_status_RUN_IN_Msk  (0x20000UL)               /*!< asic_ctrl netx_status: RUN_IN (Bitfield-Mask: 0x01)   */
#define asic_ctrl_netx_status_RDY_IN_Pos  (16UL)                    /*!< asic_ctrl netx_status: RDY_IN (Bit 16)                */
#define asic_ctrl_netx_status_RDY_IN_Msk  (0x10000UL)               /*!< asic_ctrl netx_status: RDY_IN (Bitfield-Mask: 0x01)   */
#define asic_ctrl_netx_status_NETX_STA_CODE_Pos (8UL)               /*!< asic_ctrl netx_status: NETX_STA_CODE (Bit 8)          */
#define asic_ctrl_netx_status_NETX_STA_CODE_Msk (0xff00UL)          /*!< asic_ctrl netx_status: NETX_STA_CODE (Bitfield-Mask: 0xff) */
#define asic_ctrl_netx_status_HOST_STATE_ro_Pos (4UL)               /*!< asic_ctrl netx_status: HOST_STATE_ro (Bit 4)          */
#define asic_ctrl_netx_status_HOST_STATE_ro_Msk (0xf0UL)            /*!< asic_ctrl netx_status: HOST_STATE_ro (Bitfield-Mask: 0x0f) */
#define asic_ctrl_netx_status_NETX_STATE_Pos (2UL)                  /*!< asic_ctrl netx_status: NETX_STATE (Bit 2)             */
#define asic_ctrl_netx_status_NETX_STATE_Msk (0xcUL)                /*!< asic_ctrl netx_status: NETX_STATE (Bitfield-Mask: 0x03) */
#define asic_ctrl_netx_status_RUN_Pos     (1UL)                     /*!< asic_ctrl netx_status: RUN (Bit 1)                    */
#define asic_ctrl_netx_status_RUN_Msk     (0x2UL)                   /*!< asic_ctrl netx_status: RUN (Bitfield-Mask: 0x01)      */
#define asic_ctrl_netx_status_RDY_Pos     (0UL)                     /*!< asic_ctrl netx_status: RDY (Bit 0)                    */
#define asic_ctrl_netx_status_RDY_Msk     (0x1UL)                   /*!< asic_ctrl netx_status: RDY (Bitfield-Mask: 0x01)      */
/* ======================================================  rdy_run_cfg  ====================================================== */
#define asic_ctrl_rdy_run_cfg_reserved2_Pos (26UL)                  /*!< asic_ctrl rdy_run_cfg: reserved2 (Bit 26)             */
#define asic_ctrl_rdy_run_cfg_reserved2_Msk (0xfc000000UL)          /*!< asic_ctrl rdy_run_cfg: reserved2 (Bitfield-Mask: 0x3f) */
#define asic_ctrl_rdy_run_cfg_RUN_DRV_Pos (25UL)                    /*!< asic_ctrl rdy_run_cfg: RUN_DRV (Bit 25)               */
#define asic_ctrl_rdy_run_cfg_RUN_DRV_Msk (0x2000000UL)             /*!< asic_ctrl rdy_run_cfg: RUN_DRV (Bitfield-Mask: 0x01)  */
#define asic_ctrl_rdy_run_cfg_RDY_DRV_Pos (24UL)                    /*!< asic_ctrl rdy_run_cfg: RDY_DRV (Bit 24)               */
#define asic_ctrl_rdy_run_cfg_RDY_DRV_Msk (0x1000000UL)             /*!< asic_ctrl rdy_run_cfg: RDY_DRV (Bitfield-Mask: 0x01)  */
#define asic_ctrl_rdy_run_cfg_reserved1_Pos (20UL)                  /*!< asic_ctrl rdy_run_cfg: reserved1 (Bit 20)             */
#define asic_ctrl_rdy_run_cfg_reserved1_Msk (0xf00000UL)            /*!< asic_ctrl rdy_run_cfg: reserved1 (Bitfield-Mask: 0x0f) */
#define asic_ctrl_rdy_run_cfg_RUN_POL_Pos (19UL)                    /*!< asic_ctrl rdy_run_cfg: RUN_POL (Bit 19)               */
#define asic_ctrl_rdy_run_cfg_RUN_POL_Msk (0x80000UL)               /*!< asic_ctrl rdy_run_cfg: RUN_POL (Bitfield-Mask: 0x01)  */
#define asic_ctrl_rdy_run_cfg_RDY_POL_Pos (18UL)                    /*!< asic_ctrl rdy_run_cfg: RDY_POL (Bit 18)               */
#define asic_ctrl_rdy_run_cfg_RDY_POL_Msk (0x40000UL)               /*!< asic_ctrl rdy_run_cfg: RDY_POL (Bitfield-Mask: 0x01)  */
#define asic_ctrl_rdy_run_cfg_RUN_IN_Pos  (17UL)                    /*!< asic_ctrl rdy_run_cfg: RUN_IN (Bit 17)                */
#define asic_ctrl_rdy_run_cfg_RUN_IN_Msk  (0x20000UL)               /*!< asic_ctrl rdy_run_cfg: RUN_IN (Bitfield-Mask: 0x01)   */
#define asic_ctrl_rdy_run_cfg_RDY_IN_Pos  (16UL)                    /*!< asic_ctrl rdy_run_cfg: RDY_IN (Bit 16)                */
#define asic_ctrl_rdy_run_cfg_RDY_IN_Msk  (0x10000UL)               /*!< asic_ctrl rdy_run_cfg: RDY_IN (Bitfield-Mask: 0x01)   */
#define asic_ctrl_rdy_run_cfg_reserved0_Pos (2UL)                   /*!< asic_ctrl rdy_run_cfg: reserved0 (Bit 2)              */
#define asic_ctrl_rdy_run_cfg_reserved0_Msk (0xfffcUL)              /*!< asic_ctrl rdy_run_cfg: reserved0 (Bitfield-Mask: 0x3fff) */
#define asic_ctrl_rdy_run_cfg_RUN_Pos     (1UL)                     /*!< asic_ctrl rdy_run_cfg: RUN (Bit 1)                    */
#define asic_ctrl_rdy_run_cfg_RUN_Msk     (0x2UL)                   /*!< asic_ctrl rdy_run_cfg: RUN (Bitfield-Mask: 0x01)      */
#define asic_ctrl_rdy_run_cfg_RDY_Pos     (0UL)                     /*!< asic_ctrl rdy_run_cfg: RDY (Bit 0)                    */
#define asic_ctrl_rdy_run_cfg_RDY_Msk     (0x1UL)                   /*!< asic_ctrl rdy_run_cfg: RDY (Bitfield-Mask: 0x01)      */
/* ===============================================  firewall_cfg_hifmem_sdram  =============================================== */
#define asic_ctrl_firewall_cfg_hifmem_sdram_reserved2_Pos (10UL)    /*!< asic_ctrl firewall_cfg_hifmem_sdram: reserved2 (Bit 10) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_reserved2_Msk (0xfffffc00UL) /*!< asic_ctrl firewall_cfg_hifmem_sdram: reserved2 (Bitfield-Mask: 0x3fffff) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_abort_en_app_Pos (9UL)  /*!< asic_ctrl firewall_cfg_hifmem_sdram: abort_en_app (Bit 9) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_abort_en_app_Msk (0x200UL) /*!< asic_ctrl firewall_cfg_hifmem_sdram: abort_en_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_abort_en_com_Pos (8UL)  /*!< asic_ctrl firewall_cfg_hifmem_sdram: abort_en_com (Bit 8) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_abort_en_com_Msk (0x100UL) /*!< asic_ctrl firewall_cfg_hifmem_sdram: abort_en_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_reserved1_Pos (6UL)     /*!< asic_ctrl firewall_cfg_hifmem_sdram: reserved1 (Bit 6) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_reserved1_Msk (0xc0UL)  /*!< asic_ctrl firewall_cfg_hifmem_sdram: reserved1 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_rp_app_Pos (5UL)        /*!< asic_ctrl firewall_cfg_hifmem_sdram: rp_app (Bit 5)   */
#define asic_ctrl_firewall_cfg_hifmem_sdram_rp_app_Msk (0x20UL)     /*!< asic_ctrl firewall_cfg_hifmem_sdram: rp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_rp_com_Pos (4UL)        /*!< asic_ctrl firewall_cfg_hifmem_sdram: rp_com (Bit 4)   */
#define asic_ctrl_firewall_cfg_hifmem_sdram_rp_com_Msk (0x10UL)     /*!< asic_ctrl firewall_cfg_hifmem_sdram: rp_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_reserved0_Pos (2UL)     /*!< asic_ctrl firewall_cfg_hifmem_sdram: reserved0 (Bit 2) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_reserved0_Msk (0xcUL)   /*!< asic_ctrl firewall_cfg_hifmem_sdram: reserved0 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_wp_app_Pos (1UL)        /*!< asic_ctrl firewall_cfg_hifmem_sdram: wp_app (Bit 1)   */
#define asic_ctrl_firewall_cfg_hifmem_sdram_wp_app_Msk (0x2UL)      /*!< asic_ctrl firewall_cfg_hifmem_sdram: wp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_sdram_wp_com_Pos (0UL)        /*!< asic_ctrl firewall_cfg_hifmem_sdram: wp_com (Bit 0)   */
#define asic_ctrl_firewall_cfg_hifmem_sdram_wp_com_Msk (0x1UL)      /*!< asic_ctrl firewall_cfg_hifmem_sdram: wp_com (Bitfield-Mask: 0x01) */
/* ===============================================  firewall_cfg_hifmem_amem  ================================================ */
#define asic_ctrl_firewall_cfg_hifmem_amem_reserved2_Pos (10UL)     /*!< asic_ctrl firewall_cfg_hifmem_amem: reserved2 (Bit 10) */
#define asic_ctrl_firewall_cfg_hifmem_amem_reserved2_Msk (0xfffffc00UL) /*!< asic_ctrl firewall_cfg_hifmem_amem: reserved2 (Bitfield-Mask: 0x3fffff) */
#define asic_ctrl_firewall_cfg_hifmem_amem_abort_en_app_Pos (9UL)   /*!< asic_ctrl firewall_cfg_hifmem_amem: abort_en_app (Bit 9) */
#define asic_ctrl_firewall_cfg_hifmem_amem_abort_en_app_Msk (0x200UL) /*!< asic_ctrl firewall_cfg_hifmem_amem: abort_en_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_amem_abort_en_com_Pos (8UL)   /*!< asic_ctrl firewall_cfg_hifmem_amem: abort_en_com (Bit 8) */
#define asic_ctrl_firewall_cfg_hifmem_amem_abort_en_com_Msk (0x100UL) /*!< asic_ctrl firewall_cfg_hifmem_amem: abort_en_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_amem_reserved1_Pos (6UL)      /*!< asic_ctrl firewall_cfg_hifmem_amem: reserved1 (Bit 6) */
#define asic_ctrl_firewall_cfg_hifmem_amem_reserved1_Msk (0xc0UL)   /*!< asic_ctrl firewall_cfg_hifmem_amem: reserved1 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_hifmem_amem_rp_app_Pos (5UL)         /*!< asic_ctrl firewall_cfg_hifmem_amem: rp_app (Bit 5)    */
#define asic_ctrl_firewall_cfg_hifmem_amem_rp_app_Msk (0x20UL)      /*!< asic_ctrl firewall_cfg_hifmem_amem: rp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_amem_rp_com_Pos (4UL)         /*!< asic_ctrl firewall_cfg_hifmem_amem: rp_com (Bit 4)    */
#define asic_ctrl_firewall_cfg_hifmem_amem_rp_com_Msk (0x10UL)      /*!< asic_ctrl firewall_cfg_hifmem_amem: rp_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_amem_reserved0_Pos (2UL)      /*!< asic_ctrl firewall_cfg_hifmem_amem: reserved0 (Bit 2) */
#define asic_ctrl_firewall_cfg_hifmem_amem_reserved0_Msk (0xcUL)    /*!< asic_ctrl firewall_cfg_hifmem_amem: reserved0 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_hifmem_amem_wp_app_Pos (1UL)         /*!< asic_ctrl firewall_cfg_hifmem_amem: wp_app (Bit 1)    */
#define asic_ctrl_firewall_cfg_hifmem_amem_wp_app_Msk (0x2UL)       /*!< asic_ctrl firewall_cfg_hifmem_amem: wp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_hifmem_amem_wp_com_Pos (0UL)         /*!< asic_ctrl firewall_cfg_hifmem_amem: wp_com (Bit 0)    */
#define asic_ctrl_firewall_cfg_hifmem_amem_wp_com_Msk (0x1UL)       /*!< asic_ctrl firewall_cfg_hifmem_amem: wp_com (Bitfield-Mask: 0x01) */
/* ==================================================  firewall_cfg_sqirom  ================================================== */
#define asic_ctrl_firewall_cfg_sqirom_reserved2_Pos (10UL)          /*!< asic_ctrl firewall_cfg_sqirom: reserved2 (Bit 10)     */
#define asic_ctrl_firewall_cfg_sqirom_reserved2_Msk (0xfffffc00UL)  /*!< asic_ctrl firewall_cfg_sqirom: reserved2 (Bitfield-Mask: 0x3fffff) */
#define asic_ctrl_firewall_cfg_sqirom_abort_en_app_Pos (9UL)        /*!< asic_ctrl firewall_cfg_sqirom: abort_en_app (Bit 9)   */
#define asic_ctrl_firewall_cfg_sqirom_abort_en_app_Msk (0x200UL)    /*!< asic_ctrl firewall_cfg_sqirom: abort_en_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_sqirom_abort_en_com_Pos (8UL)        /*!< asic_ctrl firewall_cfg_sqirom: abort_en_com (Bit 8)   */
#define asic_ctrl_firewall_cfg_sqirom_abort_en_com_Msk (0x100UL)    /*!< asic_ctrl firewall_cfg_sqirom: abort_en_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_sqirom_reserved1_Pos (6UL)           /*!< asic_ctrl firewall_cfg_sqirom: reserved1 (Bit 6)      */
#define asic_ctrl_firewall_cfg_sqirom_reserved1_Msk (0xc0UL)        /*!< asic_ctrl firewall_cfg_sqirom: reserved1 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_sqirom_rp_app_Pos (5UL)              /*!< asic_ctrl firewall_cfg_sqirom: rp_app (Bit 5)         */
#define asic_ctrl_firewall_cfg_sqirom_rp_app_Msk (0x20UL)           /*!< asic_ctrl firewall_cfg_sqirom: rp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_sqirom_rp_com_Pos (4UL)              /*!< asic_ctrl firewall_cfg_sqirom: rp_com (Bit 4)         */
#define asic_ctrl_firewall_cfg_sqirom_rp_com_Msk (0x10UL)           /*!< asic_ctrl firewall_cfg_sqirom: rp_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_sqirom_reserved0_Pos (2UL)           /*!< asic_ctrl firewall_cfg_sqirom: reserved0 (Bit 2)      */
#define asic_ctrl_firewall_cfg_sqirom_reserved0_Msk (0xcUL)         /*!< asic_ctrl firewall_cfg_sqirom: reserved0 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_sqirom_wp_app_Pos (1UL)              /*!< asic_ctrl firewall_cfg_sqirom: wp_app (Bit 1)         */
#define asic_ctrl_firewall_cfg_sqirom_wp_app_Msk (0x2UL)            /*!< asic_ctrl firewall_cfg_sqirom: wp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_sqirom_wp_com_Pos (0UL)              /*!< asic_ctrl firewall_cfg_sqirom: wp_com (Bit 0)         */
#define asic_ctrl_firewall_cfg_sqirom_wp_com_Msk (0x1UL)            /*!< asic_ctrl firewall_cfg_sqirom: wp_com (Bitfield-Mask: 0x01) */
/* ==================================================  firewall_cfg_crypt  =================================================== */
#define asic_ctrl_firewall_cfg_crypt_reserved2_Pos (10UL)           /*!< asic_ctrl firewall_cfg_crypt: reserved2 (Bit 10)      */
#define asic_ctrl_firewall_cfg_crypt_reserved2_Msk (0xfffffc00UL)   /*!< asic_ctrl firewall_cfg_crypt: reserved2 (Bitfield-Mask: 0x3fffff) */
#define asic_ctrl_firewall_cfg_crypt_abort_en_app_Pos (9UL)         /*!< asic_ctrl firewall_cfg_crypt: abort_en_app (Bit 9)    */
#define asic_ctrl_firewall_cfg_crypt_abort_en_app_Msk (0x200UL)     /*!< asic_ctrl firewall_cfg_crypt: abort_en_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_crypt_abort_en_com_Pos (8UL)         /*!< asic_ctrl firewall_cfg_crypt: abort_en_com (Bit 8)    */
#define asic_ctrl_firewall_cfg_crypt_abort_en_com_Msk (0x100UL)     /*!< asic_ctrl firewall_cfg_crypt: abort_en_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_crypt_reserved1_Pos (6UL)            /*!< asic_ctrl firewall_cfg_crypt: reserved1 (Bit 6)       */
#define asic_ctrl_firewall_cfg_crypt_reserved1_Msk (0xc0UL)         /*!< asic_ctrl firewall_cfg_crypt: reserved1 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_crypt_rp_app_Pos (5UL)               /*!< asic_ctrl firewall_cfg_crypt: rp_app (Bit 5)          */
#define asic_ctrl_firewall_cfg_crypt_rp_app_Msk (0x20UL)            /*!< asic_ctrl firewall_cfg_crypt: rp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_crypt_rp_com_Pos (4UL)               /*!< asic_ctrl firewall_cfg_crypt: rp_com (Bit 4)          */
#define asic_ctrl_firewall_cfg_crypt_rp_com_Msk (0x10UL)            /*!< asic_ctrl firewall_cfg_crypt: rp_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_crypt_reserved0_Pos (2UL)            /*!< asic_ctrl firewall_cfg_crypt: reserved0 (Bit 2)       */
#define asic_ctrl_firewall_cfg_crypt_reserved0_Msk (0xcUL)          /*!< asic_ctrl firewall_cfg_crypt: reserved0 (Bitfield-Mask: 0x03) */
#define asic_ctrl_firewall_cfg_crypt_wp_app_Pos (1UL)               /*!< asic_ctrl firewall_cfg_crypt: wp_app (Bit 1)          */
#define asic_ctrl_firewall_cfg_crypt_wp_app_Msk (0x2UL)             /*!< asic_ctrl firewall_cfg_crypt: wp_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_firewall_cfg_crypt_wp_com_Pos (0UL)               /*!< asic_ctrl firewall_cfg_crypt: wp_com (Bit 0)          */
#define asic_ctrl_firewall_cfg_crypt_wp_com_Msk (0x1UL)             /*!< asic_ctrl firewall_cfg_crypt: wp_com (Bitfield-Mask: 0x01) */
/* ====================================================  misc_asic_ctrl  ===================================================== */
#define asic_ctrl_misc_asic_ctrl_lic_err_delay_en_Pos (3UL)         /*!< asic_ctrl misc_asic_ctrl: lic_err_delay_en (Bit 3)    */
#define asic_ctrl_misc_asic_ctrl_lic_err_delay_en_Msk (0x8UL)       /*!< asic_ctrl misc_asic_ctrl: lic_err_delay_en (Bitfield-Mask: 0x01) */
#define asic_ctrl_misc_asic_ctrl_lic_err_irq_en_Pos (2UL)           /*!< asic_ctrl misc_asic_ctrl: lic_err_irq_en (Bit 2)      */
#define asic_ctrl_misc_asic_ctrl_lic_err_irq_en_Msk (0x4UL)         /*!< asic_ctrl misc_asic_ctrl: lic_err_irq_en (Bitfield-Mask: 0x01) */
#define asic_ctrl_misc_asic_ctrl_lic_err_abort_en_Pos (1UL)         /*!< asic_ctrl misc_asic_ctrl: lic_err_abort_en (Bit 1)    */
#define asic_ctrl_misc_asic_ctrl_lic_err_abort_en_Msk (0x2UL)       /*!< asic_ctrl misc_asic_ctrl: lic_err_abort_en (Bitfield-Mask: 0x01) */
#define asic_ctrl_misc_asic_ctrl_lic_err_taint_en_Pos (0UL)         /*!< asic_ctrl misc_asic_ctrl: lic_err_taint_en (Bit 0)    */
#define asic_ctrl_misc_asic_ctrl_lic_err_taint_en_Msk (0x1UL)       /*!< asic_ctrl misc_asic_ctrl: lic_err_taint_en (Bitfield-Mask: 0x01) */
/* =================================================  asic_ctrl_access_key  ================================================== */
#define asic_ctrl_asic_ctrl_access_key_access_key_Pos (0UL)         /*!< asic_ctrl asic_ctrl_access_key: access_key (Bit 0)    */
#define asic_ctrl_asic_ctrl_access_key_access_key_Msk (0xffffUL)    /*!< asic_ctrl asic_ctrl_access_key: access_key (Bitfield-Mask: 0xffff) */
/* ===================================================  asic_ctrl_irq_raw  =================================================== */
#define asic_ctrl_asic_ctrl_irq_raw_bod_fail_Pos (8UL)              /*!< asic_ctrl asic_ctrl_irq_raw: bod_fail (Bit 8)         */
#define asic_ctrl_asic_ctrl_irq_raw_bod_fail_Msk (0x100UL)          /*!< asic_ctrl asic_ctrl_irq_raw: bod_fail (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_crypt_app_Pos (7UL)    /*!< asic_ctrl asic_ctrl_irq_raw: firewall_crypt_app (Bit 7) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_crypt_app_Msk (0x80UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_crypt_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_crypt_com_Pos (6UL)    /*!< asic_ctrl asic_ctrl_irq_raw: firewall_crypt_com (Bit 6) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_crypt_com_Msk (0x40UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_crypt_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_sqirom_app_Pos (5UL)   /*!< asic_ctrl asic_ctrl_irq_raw: firewall_sqirom_app (Bit 5) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_sqirom_app_Msk (0x20UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_sqirom_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_sqirom_com_Pos (4UL)   /*!< asic_ctrl asic_ctrl_irq_raw: firewall_sqirom_com (Bit 4) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_sqirom_com_Msk (0x10UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_sqirom_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_amem_app_Pos (3UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_amem_app (Bit 3) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_amem_app_Msk (0x8UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_amem_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_amem_com_Pos (2UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_amem_com (Bit 2) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_amem_com_Msk (0x4UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_amem_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_sdram_app_Pos (1UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_sdram_app (Bit 1) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_sdram_app_Msk (0x2UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_sdram_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_sdram_com_Pos (0UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_sdram_com (Bit 0) */
#define asic_ctrl_asic_ctrl_irq_raw_firewall_hifmem_sdram_com_Msk (0x1UL) /*!< asic_ctrl asic_ctrl_irq_raw: firewall_hifmem_sdram_com (Bitfield-Mask: 0x01) */
/* =================================================  asic_ctrl_irq_masked  ================================================== */
#define asic_ctrl_asic_ctrl_irq_masked_bod_fail_Pos (8UL)           /*!< asic_ctrl asic_ctrl_irq_masked: bod_fail (Bit 8)      */
#define asic_ctrl_asic_ctrl_irq_masked_bod_fail_Msk (0x100UL)       /*!< asic_ctrl asic_ctrl_irq_masked: bod_fail (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_crypt_app_Pos (7UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_crypt_app (Bit 7) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_crypt_app_Msk (0x80UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_crypt_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_crypt_com_Pos (6UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_crypt_com (Bit 6) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_crypt_com_Msk (0x40UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_crypt_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_sqirom_app_Pos (5UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_sqirom_app (Bit 5) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_sqirom_app_Msk (0x20UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_sqirom_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_sqirom_com_Pos (4UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_sqirom_com (Bit 4) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_sqirom_com_Msk (0x10UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_sqirom_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_amem_app_Pos (3UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_amem_app (Bit 3) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_amem_app_Msk (0x8UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_amem_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_amem_com_Pos (2UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_amem_com (Bit 2) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_amem_com_Msk (0x4UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_amem_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_sdram_app_Pos (1UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_sdram_app (Bit 1) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_sdram_app_Msk (0x2UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_sdram_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_sdram_com_Pos (0UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_sdram_com (Bit 0) */
#define asic_ctrl_asic_ctrl_irq_masked_firewall_hifmem_sdram_com_Msk (0x1UL) /*!< asic_ctrl asic_ctrl_irq_masked: firewall_hifmem_sdram_com (Bitfield-Mask: 0x01) */
/* ================================================  asic_ctrl_irq_mask_set  ================================================= */
#define asic_ctrl_asic_ctrl_irq_mask_set_bod_fail_Pos (8UL)         /*!< asic_ctrl asic_ctrl_irq_mask_set: bod_fail (Bit 8)    */
#define asic_ctrl_asic_ctrl_irq_mask_set_bod_fail_Msk (0x100UL)     /*!< asic_ctrl asic_ctrl_irq_mask_set: bod_fail (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_crypt_app_Pos (7UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_crypt_app (Bit 7) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_crypt_app_Msk (0x80UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_crypt_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_crypt_com_Pos (6UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_crypt_com (Bit 6) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_crypt_com_Msk (0x40UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_crypt_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_sqirom_app_Pos (5UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_sqirom_app (Bit 5) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_sqirom_app_Msk (0x20UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_sqirom_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_sqirom_com_Pos (4UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_sqirom_com (Bit 4) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_sqirom_com_Msk (0x10UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_sqirom_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app_Pos (3UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_amem_app (Bit 3) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app_Msk (0x8UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_amem_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com_Pos (2UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_amem_com (Bit 2) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com_Msk (0x4UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_amem_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app_Pos (1UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_sdram_app (Bit 1) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app_Msk (0x2UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_sdram_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com_Pos (0UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_sdram_com (Bit 0) */
#define asic_ctrl_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com_Msk (0x1UL) /*!< asic_ctrl asic_ctrl_irq_mask_set: firewall_hifmem_sdram_com (Bitfield-Mask: 0x01) */
/* ===============================================  asic_ctrl_irq_mask_reset  ================================================ */
#define asic_ctrl_asic_ctrl_irq_mask_reset_bod_fail_Pos (8UL)       /*!< asic_ctrl asic_ctrl_irq_mask_reset: bod_fail (Bit 8)  */
#define asic_ctrl_asic_ctrl_irq_mask_reset_bod_fail_Msk (0x100UL)   /*!< asic_ctrl asic_ctrl_irq_mask_reset: bod_fail (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_crypt_app_Pos (7UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_crypt_app (Bit 7) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_crypt_app_Msk (0x80UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_crypt_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_crypt_com_Pos (6UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_crypt_com (Bit 6) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_crypt_com_Msk (0x40UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_crypt_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_sqirom_app_Pos (5UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_sqirom_app (Bit 5) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_sqirom_app_Msk (0x20UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_sqirom_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_sqirom_com_Pos (4UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_sqirom_com (Bit 4) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_sqirom_com_Msk (0x10UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_sqirom_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app_Pos (3UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_amem_app (Bit 3) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app_Msk (0x8UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_amem_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com_Pos (2UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_amem_com (Bit 2) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com_Msk (0x4UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_amem_com (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app_Pos (1UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_sdram_app (Bit 1) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app_Msk (0x2UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_sdram_app (Bitfield-Mask: 0x01) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com_Pos (0UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_sdram_com (Bit 0) */
#define asic_ctrl_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com_Msk (0x1UL) /*!< asic_ctrl asic_ctrl_irq_mask_reset: firewall_hifmem_sdram_com (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         mmio_ctrl                                         ================ */
/* =========================================================================================================================== */

/* =======================================================  mmio0_cfg  ======================================================= */
#define mmio_ctrl_mmio0_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio0_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio0_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio0_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio0_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio0_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio0_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio0_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio0_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio0_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio0_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio0_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio0_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio0_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio0_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio0_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio0_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio0_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio0_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio0_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio0_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio0_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio0_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio0_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio0_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio0_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio0_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio0_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio0_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio0_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio0_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio0_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio0_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio0_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio0_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio0_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio1_cfg  ======================================================= */
#define mmio_ctrl_mmio1_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio1_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio1_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio1_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio1_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio1_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio1_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio1_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio1_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio1_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio1_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio1_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio1_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio1_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio1_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio1_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio1_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio1_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio1_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio1_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio1_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio1_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio1_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio1_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio1_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio1_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio1_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio1_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio1_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio1_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio1_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio1_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio1_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio1_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio1_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio1_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio2_cfg  ======================================================= */
#define mmio_ctrl_mmio2_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio2_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio2_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio2_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio2_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio2_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio2_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio2_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio2_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio2_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio2_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio2_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio2_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio2_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio2_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio2_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio2_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio2_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio2_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio2_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio2_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio2_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio2_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio2_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio2_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio2_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio2_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio2_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio2_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio2_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio2_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio2_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio2_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio2_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio2_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio2_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio3_cfg  ======================================================= */
#define mmio_ctrl_mmio3_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio3_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio3_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio3_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio3_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio3_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio3_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio3_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio3_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio3_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio3_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio3_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio3_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio3_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio3_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio3_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio3_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio3_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio3_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio3_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio3_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio3_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio3_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio3_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio3_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio3_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio3_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio3_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio3_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio3_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio3_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio3_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio3_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio3_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio3_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio3_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio4_cfg  ======================================================= */
#define mmio_ctrl_mmio4_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio4_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio4_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio4_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio4_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio4_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio4_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio4_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio4_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio4_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio4_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio4_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio4_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio4_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio4_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio4_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio4_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio4_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio4_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio4_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio4_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio4_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio4_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio4_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio4_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio4_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio4_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio4_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio4_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio4_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio4_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio4_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio4_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio4_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio4_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio4_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio5_cfg  ======================================================= */
#define mmio_ctrl_mmio5_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio5_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio5_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio5_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio5_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio5_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio5_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio5_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio5_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio5_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio5_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio5_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio5_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio5_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio5_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio5_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio5_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio5_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio5_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio5_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio5_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio5_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio5_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio5_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio5_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio5_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio5_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio5_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio5_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio5_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio5_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio5_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio5_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio5_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio5_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio5_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio6_cfg  ======================================================= */
#define mmio_ctrl_mmio6_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio6_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio6_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio6_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio6_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio6_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio6_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio6_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio6_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio6_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio6_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio6_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio6_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio6_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio6_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio6_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio6_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio6_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio6_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio6_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio6_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio6_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio6_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio6_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio6_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio6_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio6_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio6_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio6_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio6_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio6_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio6_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio6_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio6_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio6_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio6_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio7_cfg  ======================================================= */
#define mmio_ctrl_mmio7_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio7_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio7_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio7_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio7_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio7_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio7_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio7_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio7_cfg_pio_out_Pos   (17UL)                    /*!< mmio_ctrl mmio7_cfg: pio_out (Bit 17)                 */
#define mmio_ctrl_mmio7_cfg_pio_out_Msk   (0x20000UL)               /*!< mmio_ctrl mmio7_cfg: pio_out (Bitfield-Mask: 0x01)    */
#define mmio_ctrl_mmio7_cfg_pio_oe_Pos    (16UL)                    /*!< mmio_ctrl mmio7_cfg: pio_oe (Bit 16)                  */
#define mmio_ctrl_mmio7_cfg_pio_oe_Msk    (0x10000UL)               /*!< mmio_ctrl mmio7_cfg: pio_oe (Bitfield-Mask: 0x01)     */
#define mmio_ctrl_mmio7_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio7_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio7_cfg_reserved1_Msk (0xf800UL)                /*!< mmio_ctrl mmio7_cfg: reserved1 (Bitfield-Mask: 0x1f)  */
#define mmio_ctrl_mmio7_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio7_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio7_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio7_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio7_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio7_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio7_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio7_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio7_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio7_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio7_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio7_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio7_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio7_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio7_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio7_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio8_cfg  ======================================================= */
#define mmio_ctrl_mmio8_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio8_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio8_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio8_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio8_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio8_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio8_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio8_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio8_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio8_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio8_cfg_reserved1_Msk (0x3f800UL)               /*!< mmio_ctrl mmio8_cfg: reserved1 (Bitfield-Mask: 0x7f)  */
#define mmio_ctrl_mmio8_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio8_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio8_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio8_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio8_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio8_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio8_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio8_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio8_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio8_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio8_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio8_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio8_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio8_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio8_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio8_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* =======================================================  mmio9_cfg  ======================================================= */
#define mmio_ctrl_mmio9_cfg_reserved2_Pos (19UL)                    /*!< mmio_ctrl mmio9_cfg: reserved2 (Bit 19)               */
#define mmio_ctrl_mmio9_cfg_reserved2_Msk (0xfff80000UL)            /*!< mmio_ctrl mmio9_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio9_cfg_status_in_ro_Pos (18UL)                 /*!< mmio_ctrl mmio9_cfg: status_in_ro (Bit 18)            */
#define mmio_ctrl_mmio9_cfg_status_in_ro_Msk (0x40000UL)            /*!< mmio_ctrl mmio9_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio9_cfg_reserved1_Pos (11UL)                    /*!< mmio_ctrl mmio9_cfg: reserved1 (Bit 11)               */
#define mmio_ctrl_mmio9_cfg_reserved1_Msk (0x3f800UL)               /*!< mmio_ctrl mmio9_cfg: reserved1 (Bitfield-Mask: 0x7f)  */
#define mmio_ctrl_mmio9_cfg_mmio_in_inv_Pos (10UL)                  /*!< mmio_ctrl mmio9_cfg: mmio_in_inv (Bit 10)             */
#define mmio_ctrl_mmio9_cfg_mmio_in_inv_Msk (0x400UL)               /*!< mmio_ctrl mmio9_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio9_cfg_mmio_out_inv_Pos (9UL)                  /*!< mmio_ctrl mmio9_cfg: mmio_out_inv (Bit 9)             */
#define mmio_ctrl_mmio9_cfg_mmio_out_inv_Msk (0x200UL)              /*!< mmio_ctrl mmio9_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio9_cfg_reserved0_Pos (6UL)                     /*!< mmio_ctrl mmio9_cfg: reserved0 (Bit 6)                */
#define mmio_ctrl_mmio9_cfg_reserved0_Msk (0x1c0UL)                 /*!< mmio_ctrl mmio9_cfg: reserved0 (Bitfield-Mask: 0x07)  */
#define mmio_ctrl_mmio9_cfg_mmio_sel_Pos  (0UL)                     /*!< mmio_ctrl mmio9_cfg: mmio_sel (Bit 0)                 */
#define mmio_ctrl_mmio9_cfg_mmio_sel_Msk  (0x3fUL)                  /*!< mmio_ctrl mmio9_cfg: mmio_sel (Bitfield-Mask: 0x3f)   */
/* ======================================================  mmio10_cfg  ======================================================= */
#define mmio_ctrl_mmio10_cfg_reserved2_Pos (19UL)                   /*!< mmio_ctrl mmio10_cfg: reserved2 (Bit 19)              */
#define mmio_ctrl_mmio10_cfg_reserved2_Msk (0xfff80000UL)           /*!< mmio_ctrl mmio10_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio10_cfg_status_in_ro_Pos (18UL)                /*!< mmio_ctrl mmio10_cfg: status_in_ro (Bit 18)           */
#define mmio_ctrl_mmio10_cfg_status_in_ro_Msk (0x40000UL)           /*!< mmio_ctrl mmio10_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio10_cfg_reserved1_Pos (11UL)                   /*!< mmio_ctrl mmio10_cfg: reserved1 (Bit 11)              */
#define mmio_ctrl_mmio10_cfg_reserved1_Msk (0x3f800UL)              /*!< mmio_ctrl mmio10_cfg: reserved1 (Bitfield-Mask: 0x7f) */
#define mmio_ctrl_mmio10_cfg_mmio_in_inv_Pos (10UL)                 /*!< mmio_ctrl mmio10_cfg: mmio_in_inv (Bit 10)            */
#define mmio_ctrl_mmio10_cfg_mmio_in_inv_Msk (0x400UL)              /*!< mmio_ctrl mmio10_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio10_cfg_mmio_out_inv_Pos (9UL)                 /*!< mmio_ctrl mmio10_cfg: mmio_out_inv (Bit 9)            */
#define mmio_ctrl_mmio10_cfg_mmio_out_inv_Msk (0x200UL)             /*!< mmio_ctrl mmio10_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio10_cfg_reserved0_Pos (6UL)                    /*!< mmio_ctrl mmio10_cfg: reserved0 (Bit 6)               */
#define mmio_ctrl_mmio10_cfg_reserved0_Msk (0x1c0UL)                /*!< mmio_ctrl mmio10_cfg: reserved0 (Bitfield-Mask: 0x07) */
#define mmio_ctrl_mmio10_cfg_mmio_sel_Pos (0UL)                     /*!< mmio_ctrl mmio10_cfg: mmio_sel (Bit 0)                */
#define mmio_ctrl_mmio10_cfg_mmio_sel_Msk (0x3fUL)                  /*!< mmio_ctrl mmio10_cfg: mmio_sel (Bitfield-Mask: 0x3f)  */
/* ======================================================  mmio11_cfg  ======================================================= */
#define mmio_ctrl_mmio11_cfg_reserved2_Pos (19UL)                   /*!< mmio_ctrl mmio11_cfg: reserved2 (Bit 19)              */
#define mmio_ctrl_mmio11_cfg_reserved2_Msk (0xfff80000UL)           /*!< mmio_ctrl mmio11_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio11_cfg_status_in_ro_Pos (18UL)                /*!< mmio_ctrl mmio11_cfg: status_in_ro (Bit 18)           */
#define mmio_ctrl_mmio11_cfg_status_in_ro_Msk (0x40000UL)           /*!< mmio_ctrl mmio11_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio11_cfg_reserved1_Pos (11UL)                   /*!< mmio_ctrl mmio11_cfg: reserved1 (Bit 11)              */
#define mmio_ctrl_mmio11_cfg_reserved1_Msk (0x3f800UL)              /*!< mmio_ctrl mmio11_cfg: reserved1 (Bitfield-Mask: 0x7f) */
#define mmio_ctrl_mmio11_cfg_mmio_in_inv_Pos (10UL)                 /*!< mmio_ctrl mmio11_cfg: mmio_in_inv (Bit 10)            */
#define mmio_ctrl_mmio11_cfg_mmio_in_inv_Msk (0x400UL)              /*!< mmio_ctrl mmio11_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio11_cfg_mmio_out_inv_Pos (9UL)                 /*!< mmio_ctrl mmio11_cfg: mmio_out_inv (Bit 9)            */
#define mmio_ctrl_mmio11_cfg_mmio_out_inv_Msk (0x200UL)             /*!< mmio_ctrl mmio11_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio11_cfg_reserved0_Pos (6UL)                    /*!< mmio_ctrl mmio11_cfg: reserved0 (Bit 6)               */
#define mmio_ctrl_mmio11_cfg_reserved0_Msk (0x1c0UL)                /*!< mmio_ctrl mmio11_cfg: reserved0 (Bitfield-Mask: 0x07) */
#define mmio_ctrl_mmio11_cfg_mmio_sel_Pos (0UL)                     /*!< mmio_ctrl mmio11_cfg: mmio_sel (Bit 0)                */
#define mmio_ctrl_mmio11_cfg_mmio_sel_Msk (0x3fUL)                  /*!< mmio_ctrl mmio11_cfg: mmio_sel (Bitfield-Mask: 0x3f)  */
/* ======================================================  mmio12_cfg  ======================================================= */
#define mmio_ctrl_mmio12_cfg_reserved2_Pos (19UL)                   /*!< mmio_ctrl mmio12_cfg: reserved2 (Bit 19)              */
#define mmio_ctrl_mmio12_cfg_reserved2_Msk (0xfff80000UL)           /*!< mmio_ctrl mmio12_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio12_cfg_status_in_ro_Pos (18UL)                /*!< mmio_ctrl mmio12_cfg: status_in_ro (Bit 18)           */
#define mmio_ctrl_mmio12_cfg_status_in_ro_Msk (0x40000UL)           /*!< mmio_ctrl mmio12_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio12_cfg_reserved1_Pos (11UL)                   /*!< mmio_ctrl mmio12_cfg: reserved1 (Bit 11)              */
#define mmio_ctrl_mmio12_cfg_reserved1_Msk (0x3f800UL)              /*!< mmio_ctrl mmio12_cfg: reserved1 (Bitfield-Mask: 0x7f) */
#define mmio_ctrl_mmio12_cfg_mmio_in_inv_Pos (10UL)                 /*!< mmio_ctrl mmio12_cfg: mmio_in_inv (Bit 10)            */
#define mmio_ctrl_mmio12_cfg_mmio_in_inv_Msk (0x400UL)              /*!< mmio_ctrl mmio12_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio12_cfg_mmio_out_inv_Pos (9UL)                 /*!< mmio_ctrl mmio12_cfg: mmio_out_inv (Bit 9)            */
#define mmio_ctrl_mmio12_cfg_mmio_out_inv_Msk (0x200UL)             /*!< mmio_ctrl mmio12_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio12_cfg_reserved0_Pos (6UL)                    /*!< mmio_ctrl mmio12_cfg: reserved0 (Bit 6)               */
#define mmio_ctrl_mmio12_cfg_reserved0_Msk (0x1c0UL)                /*!< mmio_ctrl mmio12_cfg: reserved0 (Bitfield-Mask: 0x07) */
#define mmio_ctrl_mmio12_cfg_mmio_sel_Pos (0UL)                     /*!< mmio_ctrl mmio12_cfg: mmio_sel (Bit 0)                */
#define mmio_ctrl_mmio12_cfg_mmio_sel_Msk (0x3fUL)                  /*!< mmio_ctrl mmio12_cfg: mmio_sel (Bitfield-Mask: 0x3f)  */
/* ======================================================  mmio13_cfg  ======================================================= */
#define mmio_ctrl_mmio13_cfg_reserved2_Pos (19UL)                   /*!< mmio_ctrl mmio13_cfg: reserved2 (Bit 19)              */
#define mmio_ctrl_mmio13_cfg_reserved2_Msk (0xfff80000UL)           /*!< mmio_ctrl mmio13_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio13_cfg_status_in_ro_Pos (18UL)                /*!< mmio_ctrl mmio13_cfg: status_in_ro (Bit 18)           */
#define mmio_ctrl_mmio13_cfg_status_in_ro_Msk (0x40000UL)           /*!< mmio_ctrl mmio13_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio13_cfg_reserved1_Pos (11UL)                   /*!< mmio_ctrl mmio13_cfg: reserved1 (Bit 11)              */
#define mmio_ctrl_mmio13_cfg_reserved1_Msk (0x3f800UL)              /*!< mmio_ctrl mmio13_cfg: reserved1 (Bitfield-Mask: 0x7f) */
#define mmio_ctrl_mmio13_cfg_mmio_in_inv_Pos (10UL)                 /*!< mmio_ctrl mmio13_cfg: mmio_in_inv (Bit 10)            */
#define mmio_ctrl_mmio13_cfg_mmio_in_inv_Msk (0x400UL)              /*!< mmio_ctrl mmio13_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio13_cfg_mmio_out_inv_Pos (9UL)                 /*!< mmio_ctrl mmio13_cfg: mmio_out_inv (Bit 9)            */
#define mmio_ctrl_mmio13_cfg_mmio_out_inv_Msk (0x200UL)             /*!< mmio_ctrl mmio13_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio13_cfg_reserved0_Pos (6UL)                    /*!< mmio_ctrl mmio13_cfg: reserved0 (Bit 6)               */
#define mmio_ctrl_mmio13_cfg_reserved0_Msk (0x1c0UL)                /*!< mmio_ctrl mmio13_cfg: reserved0 (Bitfield-Mask: 0x07) */
#define mmio_ctrl_mmio13_cfg_mmio_sel_Pos (0UL)                     /*!< mmio_ctrl mmio13_cfg: mmio_sel (Bit 0)                */
#define mmio_ctrl_mmio13_cfg_mmio_sel_Msk (0x3fUL)                  /*!< mmio_ctrl mmio13_cfg: mmio_sel (Bitfield-Mask: 0x3f)  */
/* ======================================================  mmio14_cfg  ======================================================= */
#define mmio_ctrl_mmio14_cfg_reserved2_Pos (19UL)                   /*!< mmio_ctrl mmio14_cfg: reserved2 (Bit 19)              */
#define mmio_ctrl_mmio14_cfg_reserved2_Msk (0xfff80000UL)           /*!< mmio_ctrl mmio14_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio14_cfg_status_in_ro_Pos (18UL)                /*!< mmio_ctrl mmio14_cfg: status_in_ro (Bit 18)           */
#define mmio_ctrl_mmio14_cfg_status_in_ro_Msk (0x40000UL)           /*!< mmio_ctrl mmio14_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio14_cfg_reserved1_Pos (11UL)                   /*!< mmio_ctrl mmio14_cfg: reserved1 (Bit 11)              */
#define mmio_ctrl_mmio14_cfg_reserved1_Msk (0x3f800UL)              /*!< mmio_ctrl mmio14_cfg: reserved1 (Bitfield-Mask: 0x7f) */
#define mmio_ctrl_mmio14_cfg_mmio_in_inv_Pos (10UL)                 /*!< mmio_ctrl mmio14_cfg: mmio_in_inv (Bit 10)            */
#define mmio_ctrl_mmio14_cfg_mmio_in_inv_Msk (0x400UL)              /*!< mmio_ctrl mmio14_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio14_cfg_mmio_out_inv_Pos (9UL)                 /*!< mmio_ctrl mmio14_cfg: mmio_out_inv (Bit 9)            */
#define mmio_ctrl_mmio14_cfg_mmio_out_inv_Msk (0x200UL)             /*!< mmio_ctrl mmio14_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio14_cfg_reserved0_Pos (6UL)                    /*!< mmio_ctrl mmio14_cfg: reserved0 (Bit 6)               */
#define mmio_ctrl_mmio14_cfg_reserved0_Msk (0x1c0UL)                /*!< mmio_ctrl mmio14_cfg: reserved0 (Bitfield-Mask: 0x07) */
#define mmio_ctrl_mmio14_cfg_mmio_sel_Pos (0UL)                     /*!< mmio_ctrl mmio14_cfg: mmio_sel (Bit 0)                */
#define mmio_ctrl_mmio14_cfg_mmio_sel_Msk (0x3fUL)                  /*!< mmio_ctrl mmio14_cfg: mmio_sel (Bitfield-Mask: 0x3f)  */
/* ======================================================  mmio15_cfg  ======================================================= */
#define mmio_ctrl_mmio15_cfg_reserved2_Pos (19UL)                   /*!< mmio_ctrl mmio15_cfg: reserved2 (Bit 19)              */
#define mmio_ctrl_mmio15_cfg_reserved2_Msk (0xfff80000UL)           /*!< mmio_ctrl mmio15_cfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define mmio_ctrl_mmio15_cfg_status_in_ro_Pos (18UL)                /*!< mmio_ctrl mmio15_cfg: status_in_ro (Bit 18)           */
#define mmio_ctrl_mmio15_cfg_status_in_ro_Msk (0x40000UL)           /*!< mmio_ctrl mmio15_cfg: status_in_ro (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio15_cfg_reserved1_Pos (11UL)                   /*!< mmio_ctrl mmio15_cfg: reserved1 (Bit 11)              */
#define mmio_ctrl_mmio15_cfg_reserved1_Msk (0x3f800UL)              /*!< mmio_ctrl mmio15_cfg: reserved1 (Bitfield-Mask: 0x7f) */
#define mmio_ctrl_mmio15_cfg_mmio_in_inv_Pos (10UL)                 /*!< mmio_ctrl mmio15_cfg: mmio_in_inv (Bit 10)            */
#define mmio_ctrl_mmio15_cfg_mmio_in_inv_Msk (0x400UL)              /*!< mmio_ctrl mmio15_cfg: mmio_in_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio15_cfg_mmio_out_inv_Pos (9UL)                 /*!< mmio_ctrl mmio15_cfg: mmio_out_inv (Bit 9)            */
#define mmio_ctrl_mmio15_cfg_mmio_out_inv_Msk (0x200UL)             /*!< mmio_ctrl mmio15_cfg: mmio_out_inv (Bitfield-Mask: 0x01) */
#define mmio_ctrl_mmio15_cfg_reserved0_Pos (6UL)                    /*!< mmio_ctrl mmio15_cfg: reserved0 (Bit 6)               */
#define mmio_ctrl_mmio15_cfg_reserved0_Msk (0x1c0UL)                /*!< mmio_ctrl mmio15_cfg: reserved0 (Bitfield-Mask: 0x07) */
#define mmio_ctrl_mmio15_cfg_mmio_sel_Pos (0UL)                     /*!< mmio_ctrl mmio15_cfg: mmio_sel (Bit 0)                */
#define mmio_ctrl_mmio15_cfg_mmio_sel_Msk (0x3fUL)                  /*!< mmio_ctrl mmio15_cfg: mmio_sel (Bitfield-Mask: 0x3f)  */
/* ================================================  mmio_pio_out_line_cfg0  ================================================= */
#define mmio_ctrl_mmio_pio_out_line_cfg0_line_Pos (0UL)             /*!< mmio_ctrl mmio_pio_out_line_cfg0: line (Bit 0)        */
#define mmio_ctrl_mmio_pio_out_line_cfg0_line_Msk (0xffffUL)        /*!< mmio_ctrl mmio_pio_out_line_cfg0: line (Bitfield-Mask: 0xffff) */
/* ==============================================  mmio_pio_out_line_set_cfg0  =============================================== */
#define mmio_ctrl_mmio_pio_out_line_set_cfg0_line_Pos (0UL)         /*!< mmio_ctrl mmio_pio_out_line_set_cfg0: line (Bit 0)    */
#define mmio_ctrl_mmio_pio_out_line_set_cfg0_line_Msk (0xffffUL)    /*!< mmio_ctrl mmio_pio_out_line_set_cfg0: line (Bitfield-Mask: 0xffff) */
/* =============================================  mmio_pio_out_line_reset_cfg0  ============================================== */
#define mmio_ctrl_mmio_pio_out_line_reset_cfg0_line_Pos (0UL)       /*!< mmio_ctrl mmio_pio_out_line_reset_cfg0: line (Bit 0)  */
#define mmio_ctrl_mmio_pio_out_line_reset_cfg0_line_Msk (0xffffUL)  /*!< mmio_ctrl mmio_pio_out_line_reset_cfg0: line (Bitfield-Mask: 0xffff) */
/* =================================================  mmio_pio_oe_line_cfg0  ================================================= */
#define mmio_ctrl_mmio_pio_oe_line_cfg0_line_Pos (0UL)              /*!< mmio_ctrl mmio_pio_oe_line_cfg0: line (Bit 0)         */
#define mmio_ctrl_mmio_pio_oe_line_cfg0_line_Msk (0xffffUL)         /*!< mmio_ctrl mmio_pio_oe_line_cfg0: line (Bitfield-Mask: 0xffff) */
/* ===============================================  mmio_pio_oe_line_set_cfg0  =============================================== */
#define mmio_ctrl_mmio_pio_oe_line_set_cfg0_line_Pos (0UL)          /*!< mmio_ctrl mmio_pio_oe_line_set_cfg0: line (Bit 0)     */
#define mmio_ctrl_mmio_pio_oe_line_set_cfg0_line_Msk (0xffffUL)     /*!< mmio_ctrl mmio_pio_oe_line_set_cfg0: line (Bitfield-Mask: 0xffff) */
/* ==============================================  mmio_pio_oe_line_reset_cfg0  ============================================== */
#define mmio_ctrl_mmio_pio_oe_line_reset_cfg0_line_Pos (0UL)        /*!< mmio_ctrl mmio_pio_oe_line_reset_cfg0: line (Bit 0)   */
#define mmio_ctrl_mmio_pio_oe_line_reset_cfg0_line_Msk (0xffffUL)   /*!< mmio_ctrl mmio_pio_oe_line_reset_cfg0: line (Bitfield-Mask: 0xffff) */
/* =================================================  mmio_in_line_status0  ================================================== */
#define mmio_ctrl_mmio_in_line_status0_line_Pos (0UL)               /*!< mmio_ctrl mmio_in_line_status0: line (Bit 0)          */
#define mmio_ctrl_mmio_in_line_status0_line_Msk (0xffffUL)          /*!< mmio_ctrl mmio_in_line_status0: line (Bitfield-Mask: 0xffff) */
/* ==================================================  mmio_is_pio_status0  ================================================== */
#define mmio_ctrl_mmio_is_pio_status0_line_Pos (0UL)                /*!< mmio_ctrl mmio_is_pio_status0: line (Bit 0)           */
#define mmio_ctrl_mmio_is_pio_status0_line_Msk (0xffffUL)           /*!< mmio_ctrl mmio_is_pio_status0: line (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                      global_buf_man                                       ================ */
/* =========================================================================================================================== */

/* =================================================  global_read_buffer_0  ================================================== */
#define global_buf_man_global_read_buffer_0_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_0: val (Bit 0)      */
#define global_buf_man_global_read_buffer_0_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_0: val (Bitfield-Mask: 0x03) */
/* =================================================  global_read_buffer_1  ================================================== */
#define global_buf_man_global_read_buffer_1_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_1: val (Bit 0)      */
#define global_buf_man_global_read_buffer_1_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_1: val (Bitfield-Mask: 0x03) */
/* =================================================  global_read_buffer_2  ================================================== */
#define global_buf_man_global_read_buffer_2_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_2: val (Bit 0)      */
#define global_buf_man_global_read_buffer_2_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_2: val (Bitfield-Mask: 0x03) */
/* =================================================  global_read_buffer_3  ================================================== */
#define global_buf_man_global_read_buffer_3_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_3: val (Bit 0)      */
#define global_buf_man_global_read_buffer_3_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_3: val (Bitfield-Mask: 0x03) */
/* =================================================  global_read_buffer_4  ================================================== */
#define global_buf_man_global_read_buffer_4_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_4: val (Bit 0)      */
#define global_buf_man_global_read_buffer_4_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_4: val (Bitfield-Mask: 0x03) */
/* =================================================  global_read_buffer_5  ================================================== */
#define global_buf_man_global_read_buffer_5_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_5: val (Bit 0)      */
#define global_buf_man_global_read_buffer_5_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_5: val (Bitfield-Mask: 0x03) */
/* =================================================  global_read_buffer_6  ================================================== */
#define global_buf_man_global_read_buffer_6_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_6: val (Bit 0)      */
#define global_buf_man_global_read_buffer_6_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_6: val (Bitfield-Mask: 0x03) */
/* =================================================  global_read_buffer_7  ================================================== */
#define global_buf_man_global_read_buffer_7_val_Pos (0UL)           /*!< global_buf_man global_read_buffer_7: val (Bit 0)      */
#define global_buf_man_global_read_buffer_7_val_Msk (0x3UL)         /*!< global_buf_man global_read_buffer_7: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_0  ================================================= */
#define global_buf_man_global_write_buffer_0_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_0: val (Bit 0)     */
#define global_buf_man_global_write_buffer_0_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_0: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_1  ================================================= */
#define global_buf_man_global_write_buffer_1_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_1: val (Bit 0)     */
#define global_buf_man_global_write_buffer_1_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_1: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_2  ================================================= */
#define global_buf_man_global_write_buffer_2_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_2: val (Bit 0)     */
#define global_buf_man_global_write_buffer_2_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_2: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_3  ================================================= */
#define global_buf_man_global_write_buffer_3_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_3: val (Bit 0)     */
#define global_buf_man_global_write_buffer_3_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_3: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_4  ================================================= */
#define global_buf_man_global_write_buffer_4_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_4: val (Bit 0)     */
#define global_buf_man_global_write_buffer_4_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_4: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_5  ================================================= */
#define global_buf_man_global_write_buffer_5_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_5: val (Bit 0)     */
#define global_buf_man_global_write_buffer_5_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_5: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_6  ================================================= */
#define global_buf_man_global_write_buffer_6_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_6: val (Bit 0)     */
#define global_buf_man_global_write_buffer_6_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_6: val (Bitfield-Mask: 0x03) */
/* =================================================  global_write_buffer_7  ================================================= */
#define global_buf_man_global_write_buffer_7_val_Pos (0UL)          /*!< global_buf_man global_write_buffer_7: val (Bit 0)     */
#define global_buf_man_global_write_buffer_7_val_Msk (0x3UL)        /*!< global_buf_man global_write_buffer_7: val (Bitfield-Mask: 0x03) */


/* =========================================================================================================================== */
/* ================                                        iflash_cfg2                                        ================ */
/* =========================================================================================================================== */

/* ============================================  buffer_read_ahead_instructions  ============================================= */
#define iflash_cfg2_buffer_read_ahead_instructions_val_Pos (0UL)    /*!< iflash_cfg2 buffer_read_ahead_instructions: val (Bit 0) */
#define iflash_cfg2_buffer_read_ahead_instructions_val_Msk (0xffffffffUL) /*!< iflash_cfg2 buffer_read_ahead_instructions: val (Bitfield-Mask: 0xffffffff) */
/* ================================================  buffer_read_ahead_data  ================================================= */
#define iflash_cfg2_buffer_read_ahead_data_val_Pos (0UL)            /*!< iflash_cfg2 buffer_read_ahead_data: val (Bit 0)       */
#define iflash_cfg2_buffer_read_ahead_data_val_Msk (0xffffffffUL)   /*!< iflash_cfg2 buffer_read_ahead_data: val (Bitfield-Mask: 0xffffffff) */
/* ==================================================  iflash_signals_cfg  =================================================== */
#define iflash_cfg2_iflash_signals_cfg_se_Pos (6UL)                 /*!< iflash_cfg2 iflash_signals_cfg: se (Bit 6)            */
#define iflash_cfg2_iflash_signals_cfg_se_Msk (0x40UL)              /*!< iflash_cfg2 iflash_signals_cfg: se (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_signals_cfg_prog_Pos (5UL)               /*!< iflash_cfg2 iflash_signals_cfg: prog (Bit 5)          */
#define iflash_cfg2_iflash_signals_cfg_prog_Msk (0x20UL)            /*!< iflash_cfg2 iflash_signals_cfg: prog (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_signals_cfg_nvstr_Pos (4UL)              /*!< iflash_cfg2 iflash_signals_cfg: nvstr (Bit 4)         */
#define iflash_cfg2_iflash_signals_cfg_nvstr_Msk (0x10UL)           /*!< iflash_cfg2 iflash_signals_cfg: nvstr (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_signals_cfg_mas1_Pos (3UL)               /*!< iflash_cfg2 iflash_signals_cfg: mas1 (Bit 3)          */
#define iflash_cfg2_iflash_signals_cfg_mas1_Msk (0x8UL)             /*!< iflash_cfg2 iflash_signals_cfg: mas1 (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_signals_cfg_erase_Pos (2UL)              /*!< iflash_cfg2 iflash_signals_cfg: erase (Bit 2)         */
#define iflash_cfg2_iflash_signals_cfg_erase_Msk (0x4UL)            /*!< iflash_cfg2 iflash_signals_cfg: erase (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_signals_cfg_ye_Pos (1UL)                 /*!< iflash_cfg2 iflash_signals_cfg: ye (Bit 1)            */
#define iflash_cfg2_iflash_signals_cfg_ye_Msk (0x2UL)               /*!< iflash_cfg2 iflash_signals_cfg: ye (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_signals_cfg_xe_Pos (0UL)                 /*!< iflash_cfg2 iflash_signals_cfg: xe (Bit 0)            */
#define iflash_cfg2_iflash_signals_cfg_xe_Msk (0x1UL)               /*!< iflash_cfg2 iflash_signals_cfg: xe (Bitfield-Mask: 0x01) */
/* ====================================================  iflash_mode_cfg  ==================================================== */
#define iflash_cfg2_iflash_mode_cfg_iflash_mode_Pos (0UL)           /*!< iflash_cfg2 iflash_mode_cfg: iflash_mode (Bit 0)      */
#define iflash_cfg2_iflash_mode_cfg_iflash_mode_Msk (0x7UL)         /*!< iflash_cfg2 iflash_mode_cfg: iflash_mode (Bitfield-Mask: 0x07) */
/* =====================================================  iflash_access  ===================================================== */
#define iflash_cfg2_iflash_access_run_Pos (0UL)                     /*!< iflash_cfg2 iflash_access: run (Bit 0)                */
#define iflash_cfg2_iflash_access_run_Msk (0x1UL)                   /*!< iflash_cfg2 iflash_access: run (Bitfield-Mask: 0x01)  */
/* ======================================================  iflash_yadr  ====================================================== */
#define iflash_cfg2_iflash_yadr_val_Pos   (0UL)                     /*!< iflash_cfg2 iflash_yadr: val (Bit 0)                  */
#define iflash_cfg2_iflash_yadr_val_Msk   (0x1fUL)                  /*!< iflash_cfg2 iflash_yadr: val (Bitfield-Mask: 0x1f)    */
/* ======================================================  iflash_xadr  ====================================================== */
#define iflash_cfg2_iflash_xadr_val_Pos   (0UL)                     /*!< iflash_cfg2 iflash_xadr: val (Bit 0)                  */
#define iflash_cfg2_iflash_xadr_val_Msk   (0x3ffUL)                 /*!< iflash_cfg2 iflash_xadr: val (Bitfield-Mask: 0x3ff)   */
/* ======================================================  iflash_din0  ====================================================== */
#define iflash_cfg2_iflash_din0_val_Pos   (0UL)                     /*!< iflash_cfg2 iflash_din0: val (Bit 0)                  */
#define iflash_cfg2_iflash_din0_val_Msk   (0xffffffffUL)            /*!< iflash_cfg2 iflash_din0: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  iflash_din1  ====================================================== */
#define iflash_cfg2_iflash_din1_val_Pos   (0UL)                     /*!< iflash_cfg2 iflash_din1: val (Bit 0)                  */
#define iflash_cfg2_iflash_din1_val_Msk   (0xffffffffUL)            /*!< iflash_cfg2 iflash_din1: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  iflash_din2  ====================================================== */
#define iflash_cfg2_iflash_din2_val_Pos   (0UL)                     /*!< iflash_cfg2 iflash_din2: val (Bit 0)                  */
#define iflash_cfg2_iflash_din2_val_Msk   (0xffffffffUL)            /*!< iflash_cfg2 iflash_din2: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  iflash_din3  ====================================================== */
#define iflash_cfg2_iflash_din3_val_Pos   (0UL)                     /*!< iflash_cfg2 iflash_din3: val (Bit 0)                  */
#define iflash_cfg2_iflash_din3_val_Msk   (0xffffffffUL)            /*!< iflash_cfg2 iflash_din3: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  iflash_din4  ====================================================== */
#define iflash_cfg2_iflash_din4_val_Pos   (0UL)                     /*!< iflash_cfg2 iflash_din4: val (Bit 0)                  */
#define iflash_cfg2_iflash_din4_val_Msk   (0xffffUL)                /*!< iflash_cfg2 iflash_din4: val (Bitfield-Mask: 0xffff)  */
/* =====================================================  iflash_reset  ====================================================== */
#define iflash_cfg2_iflash_reset_reset_Pos (0UL)                    /*!< iflash_cfg2 iflash_reset: reset (Bit 0)               */
#define iflash_cfg2_iflash_reset_reset_Msk (0x1UL)                  /*!< iflash_cfg2 iflash_reset: reset (Bitfield-Mask: 0x01) */
/* ====================================================  iflash_red_cfg0  ==================================================== */
#define iflash_cfg2_iflash_red_cfg0_adr0_Pos (1UL)                  /*!< iflash_cfg2 iflash_red_cfg0: adr0 (Bit 1)             */
#define iflash_cfg2_iflash_red_cfg0_adr0_Msk (0xfeUL)               /*!< iflash_cfg2 iflash_red_cfg0: adr0 (Bitfield-Mask: 0x7f) */
#define iflash_cfg2_iflash_red_cfg0_n_enb_Pos (0UL)                 /*!< iflash_cfg2 iflash_red_cfg0: n_enb (Bit 0)            */
#define iflash_cfg2_iflash_red_cfg0_n_enb_Msk (0x1UL)               /*!< iflash_cfg2 iflash_red_cfg0: n_enb (Bitfield-Mask: 0x01) */
/* ====================================================  iflash_red_cfg1  ==================================================== */
#define iflash_cfg2_iflash_red_cfg1_adr1_Pos (1UL)                  /*!< iflash_cfg2 iflash_red_cfg1: adr1 (Bit 1)             */
#define iflash_cfg2_iflash_red_cfg1_adr1_Msk (0xfeUL)               /*!< iflash_cfg2 iflash_red_cfg1: adr1 (Bitfield-Mask: 0x7f) */
#define iflash_cfg2_iflash_red_cfg1_n_enb_Pos (0UL)                 /*!< iflash_cfg2 iflash_red_cfg1: n_enb (Bit 0)            */
#define iflash_cfg2_iflash_red_cfg1_n_enb_Msk (0x1UL)               /*!< iflash_cfg2 iflash_red_cfg1: n_enb (Bitfield-Mask: 0x01) */
/* ===================================================  iflash_ifren_cfg  ==================================================== */
#define iflash_cfg2_iflash_ifren_cfg_ifren1_Pos (1UL)               /*!< iflash_cfg2 iflash_ifren_cfg: ifren1 (Bit 1)          */
#define iflash_cfg2_iflash_ifren_cfg_ifren1_Msk (0x2UL)             /*!< iflash_cfg2 iflash_ifren_cfg: ifren1 (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_ifren_cfg_ifren_Pos (0UL)                /*!< iflash_cfg2 iflash_ifren_cfg: ifren (Bit 0)           */
#define iflash_cfg2_iflash_ifren_cfg_ifren_Msk (0x1UL)              /*!< iflash_cfg2 iflash_ifren_cfg: ifren (Bitfield-Mask: 0x01) */
/* ====================================================  iflash_din4_ecc  ==================================================== */
#define iflash_cfg2_iflash_din4_ecc_val_Pos (0UL)                   /*!< iflash_cfg2 iflash_din4_ecc: val (Bit 0)              */
#define iflash_cfg2_iflash_din4_ecc_val_Msk (0xffffUL)              /*!< iflash_cfg2 iflash_din4_ecc: val (Bitfield-Mask: 0xffff) */
/* ==================================================  iflash_special_cfg  =================================================== */
#define iflash_cfg2_iflash_special_cfg_slm_Pos (1UL)                /*!< iflash_cfg2 iflash_special_cfg: slm (Bit 1)           */
#define iflash_cfg2_iflash_special_cfg_slm_Msk (0x2UL)              /*!< iflash_cfg2 iflash_special_cfg: slm (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_special_cfg_tmr_Pos (0UL)                /*!< iflash_cfg2 iflash_special_cfg: tmr (Bit 0)           */
#define iflash_cfg2_iflash_special_cfg_tmr_Msk (0x1UL)              /*!< iflash_cfg2 iflash_special_cfg: tmr (Bitfield-Mask: 0x01) */
/* ================================================  iflash_protection_info  ================================================= */
#define iflash_cfg2_iflash_protection_info_read_up_Pos (3UL)        /*!< iflash_cfg2 iflash_protection_info: read_up (Bit 3)   */
#define iflash_cfg2_iflash_protection_info_read_up_Msk (0x8UL)      /*!< iflash_cfg2 iflash_protection_info: read_up (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_protection_info_read_dw_Pos (2UL)        /*!< iflash_cfg2 iflash_protection_info: read_dw (Bit 2)   */
#define iflash_cfg2_iflash_protection_info_read_dw_Msk (0x4UL)      /*!< iflash_cfg2 iflash_protection_info: read_dw (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_protection_info_write_up_Pos (1UL)       /*!< iflash_cfg2 iflash_protection_info: write_up (Bit 1)  */
#define iflash_cfg2_iflash_protection_info_write_up_Msk (0x2UL)     /*!< iflash_cfg2 iflash_protection_info: write_up (Bitfield-Mask: 0x01) */
#define iflash_cfg2_iflash_protection_info_write_dw_Pos (0UL)       /*!< iflash_cfg2 iflash_protection_info: write_dw (Bit 0)  */
#define iflash_cfg2_iflash_protection_info_write_dw_Msk (0x1UL)     /*!< iflash_cfg2 iflash_protection_info: write_dw (Bitfield-Mask: 0x01) */
/* =============================================  iflash_write_protection_main  ============================================== */
#define iflash_cfg2_iflash_write_protection_main_val_Pos (0UL)      /*!< iflash_cfg2 iflash_write_protection_main: val (Bit 0) */
#define iflash_cfg2_iflash_write_protection_main_val_Msk (0xffffffffUL) /*!< iflash_cfg2 iflash_write_protection_main: val (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                        hif_io_ctrl                                        ================ */
/* =========================================================================================================================== */

/* ======================================================  hif_io_cfg  ======================================================= */
#define hif_io_ctrl_hif_io_cfg_reserved1_Pos (26UL)                 /*!< hif_io_ctrl hif_io_cfg: reserved1 (Bit 26)            */
#define hif_io_ctrl_hif_io_cfg_reserved1_Msk (0xfc000000UL)         /*!< hif_io_ctrl hif_io_cfg: reserved1 (Bitfield-Mask: 0x3f) */
#define hif_io_ctrl_hif_io_cfg_en_hif_wdg_sys_hif_d19_Pos (25UL)    /*!< hif_io_ctrl hif_io_cfg: en_hif_wdg_sys_hif_d19 (Bit 25) */
#define hif_io_ctrl_hif_io_cfg_en_hif_wdg_sys_hif_d19_Msk (0x2000000UL) /*!< hif_io_ctrl hif_io_cfg: en_hif_wdg_sys_hif_d19 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_io_cfg_en_hif_rdy_pio_mi_Pos (24UL)         /*!< hif_io_ctrl hif_io_cfg: en_hif_rdy_pio_mi (Bit 24)    */
#define hif_io_ctrl_hif_io_cfg_en_hif_rdy_pio_mi_Msk (0x1000000UL)  /*!< hif_io_ctrl hif_io_cfg: en_hif_rdy_pio_mi (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_io_cfg_reserved0_Pos (12UL)                 /*!< hif_io_ctrl hif_io_cfg: reserved0 (Bit 12)            */
#define hif_io_ctrl_hif_io_cfg_reserved0_Msk (0xfff000UL)           /*!< hif_io_ctrl hif_io_cfg: reserved0 (Bitfield-Mask: 0xfff) */
#define hif_io_ctrl_hif_io_cfg_sel_hif_a_width_Pos (8UL)            /*!< hif_io_ctrl hif_io_cfg: sel_hif_a_width (Bit 8)       */
#define hif_io_ctrl_hif_io_cfg_sel_hif_a_width_Msk (0xf00UL)        /*!< hif_io_ctrl hif_io_cfg: sel_hif_a_width (Bitfield-Mask: 0x0f) */
#define hif_io_ctrl_hif_io_cfg_en_hif_sdram_mi_Pos (7UL)            /*!< hif_io_ctrl hif_io_cfg: en_hif_sdram_mi (Bit 7)       */
#define hif_io_ctrl_hif_io_cfg_en_hif_sdram_mi_Msk (0x80UL)         /*!< hif_io_ctrl hif_io_cfg: en_hif_sdram_mi (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_io_cfg_hif_mi_cfg_Pos (5UL)                 /*!< hif_io_ctrl hif_io_cfg: hif_mi_cfg (Bit 5)            */
#define hif_io_ctrl_hif_io_cfg_hif_mi_cfg_Msk (0x60UL)              /*!< hif_io_ctrl hif_io_cfg: hif_mi_cfg (Bitfield-Mask: 0x03) */
#define hif_io_ctrl_hif_io_cfg_en_sdpm1_Pos (4UL)                   /*!< hif_io_ctrl hif_io_cfg: en_sdpm1 (Bit 4)              */
#define hif_io_ctrl_hif_io_cfg_en_sdpm1_Msk (0x10UL)                /*!< hif_io_ctrl hif_io_cfg: en_sdpm1 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_io_cfg_sel_dpm_serial_spo_Pos (3UL)         /*!< hif_io_ctrl hif_io_cfg: sel_dpm_serial_spo (Bit 3)    */
#define hif_io_ctrl_hif_io_cfg_sel_dpm_serial_spo_Msk (0x8UL)       /*!< hif_io_ctrl hif_io_cfg: sel_dpm_serial_spo (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_io_cfg_sel_dpm_serial_sph_Pos (2UL)         /*!< hif_io_ctrl hif_io_cfg: sel_dpm_serial_sph (Bit 2)    */
#define hif_io_ctrl_hif_io_cfg_sel_dpm_serial_sph_Msk (0x4UL)       /*!< hif_io_ctrl hif_io_cfg: sel_dpm_serial_sph (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_io_cfg_sel_dpm_serial_Pos (1UL)             /*!< hif_io_ctrl hif_io_cfg: sel_dpm_serial (Bit 1)        */
#define hif_io_ctrl_hif_io_cfg_sel_dpm_serial_Msk (0x2UL)           /*!< hif_io_ctrl hif_io_cfg: sel_dpm_serial (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_io_cfg_sel_hif_dpm_Pos (0UL)                /*!< hif_io_ctrl hif_io_cfg: sel_hif_dpm (Bit 0)           */
#define hif_io_ctrl_hif_io_cfg_sel_hif_dpm_Msk (0x1UL)              /*!< hif_io_ctrl hif_io_cfg: sel_hif_dpm (Bitfield-Mask: 0x01) */
/* ======================================================  hif_pio_cfg  ====================================================== */
#define hif_io_ctrl_hif_pio_cfg_filter_irqs_Pos (31UL)              /*!< hif_io_ctrl hif_pio_cfg: filter_irqs (Bit 31)         */
#define hif_io_ctrl_hif_pio_cfg_filter_irqs_Msk (0x80000000UL)      /*!< hif_io_ctrl hif_pio_cfg: filter_irqs (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_cfg_reserved3_Pos (28UL)                /*!< hif_io_ctrl hif_pio_cfg: reserved3 (Bit 28)           */
#define hif_io_ctrl_hif_pio_cfg_reserved3_Msk (0x70000000UL)        /*!< hif_io_ctrl hif_pio_cfg: reserved3 (Bitfield-Mask: 0x07) */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_dirq_cfg_Pos (26UL)         /*!< hif_io_ctrl hif_pio_cfg: irq_hif_dirq_cfg (Bit 26)    */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_dirq_cfg_Msk (0xc000000UL)  /*!< hif_io_ctrl hif_pio_cfg: irq_hif_dirq_cfg (Bitfield-Mask: 0x03) */
#define hif_io_ctrl_hif_pio_cfg_reserved2_Pos (22UL)                /*!< hif_io_ctrl hif_pio_cfg: reserved2 (Bit 22)           */
#define hif_io_ctrl_hif_pio_cfg_reserved2_Msk (0x3c00000UL)         /*!< hif_io_ctrl hif_pio_cfg: reserved2 (Bitfield-Mask: 0x0f) */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_a17_cfg_Pos (20UL)          /*!< hif_io_ctrl hif_pio_cfg: irq_hif_a17_cfg (Bit 20)     */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_a17_cfg_Msk (0x300000UL)    /*!< hif_io_ctrl hif_pio_cfg: irq_hif_a17_cfg (Bitfield-Mask: 0x03) */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_a16_cfg_Pos (18UL)          /*!< hif_io_ctrl hif_pio_cfg: irq_hif_a16_cfg (Bit 18)     */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_a16_cfg_Msk (0xc0000UL)     /*!< hif_io_ctrl hif_pio_cfg: irq_hif_a16_cfg (Bitfield-Mask: 0x03) */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_d12_cfg_Pos (16UL)          /*!< hif_io_ctrl hif_pio_cfg: irq_hif_d12_cfg (Bit 16)     */
#define hif_io_ctrl_hif_pio_cfg_irq_hif_d12_cfg_Msk (0x30000UL)     /*!< hif_io_ctrl hif_pio_cfg: irq_hif_d12_cfg (Bitfield-Mask: 0x03) */
#define hif_io_ctrl_hif_pio_cfg_reserved1_Pos (4UL)                 /*!< hif_io_ctrl hif_pio_cfg: reserved1 (Bit 4)            */
#define hif_io_ctrl_hif_pio_cfg_reserved1_Msk (0xfff0UL)            /*!< hif_io_ctrl hif_pio_cfg: reserved1 (Bitfield-Mask: 0xfff) */
#define hif_io_ctrl_hif_pio_cfg_filter_en_in_Pos (3UL)              /*!< hif_io_ctrl hif_pio_cfg: filter_en_in (Bit 3)         */
#define hif_io_ctrl_hif_pio_cfg_filter_en_in_Msk (0x8UL)            /*!< hif_io_ctrl hif_pio_cfg: filter_en_in (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_cfg_reserved0_Pos (2UL)                 /*!< hif_io_ctrl hif_pio_cfg: reserved0 (Bit 2)            */
#define hif_io_ctrl_hif_pio_cfg_reserved0_Msk (0x4UL)               /*!< hif_io_ctrl hif_pio_cfg: reserved0 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_cfg_in_ctrl_Pos (0UL)                   /*!< hif_io_ctrl hif_pio_cfg: in_ctrl (Bit 0)              */
#define hif_io_ctrl_hif_pio_cfg_in_ctrl_Msk (0x3UL)                 /*!< hif_io_ctrl hif_pio_cfg: in_ctrl (Bitfield-Mask: 0x03) */
/* =====================================================  hif_pio_out0  ====================================================== */
#define hif_io_ctrl_hif_pio_out0_hif_d15_Pos (15UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d15 (Bit 15)            */
#define hif_io_ctrl_hif_pio_out0_hif_d15_Msk (0x8000UL)             /*!< hif_io_ctrl hif_pio_out0: hif_d15 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d14_Pos (14UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d14 (Bit 14)            */
#define hif_io_ctrl_hif_pio_out0_hif_d14_Msk (0x4000UL)             /*!< hif_io_ctrl hif_pio_out0: hif_d14 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d13_Pos (13UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d13 (Bit 13)            */
#define hif_io_ctrl_hif_pio_out0_hif_d13_Msk (0x2000UL)             /*!< hif_io_ctrl hif_pio_out0: hif_d13 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d12_Pos (12UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d12 (Bit 12)            */
#define hif_io_ctrl_hif_pio_out0_hif_d12_Msk (0x1000UL)             /*!< hif_io_ctrl hif_pio_out0: hif_d12 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d11_Pos (11UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d11 (Bit 11)            */
#define hif_io_ctrl_hif_pio_out0_hif_d11_Msk (0x800UL)              /*!< hif_io_ctrl hif_pio_out0: hif_d11 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d10_Pos (10UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d10 (Bit 10)            */
#define hif_io_ctrl_hif_pio_out0_hif_d10_Msk (0x400UL)              /*!< hif_io_ctrl hif_pio_out0: hif_d10 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d9_Pos (9UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d9 (Bit 9)              */
#define hif_io_ctrl_hif_pio_out0_hif_d9_Msk (0x200UL)               /*!< hif_io_ctrl hif_pio_out0: hif_d9 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d8_Pos (8UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d8 (Bit 8)              */
#define hif_io_ctrl_hif_pio_out0_hif_d8_Msk (0x100UL)               /*!< hif_io_ctrl hif_pio_out0: hif_d8 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d7_Pos (7UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d7 (Bit 7)              */
#define hif_io_ctrl_hif_pio_out0_hif_d7_Msk (0x80UL)                /*!< hif_io_ctrl hif_pio_out0: hif_d7 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d6_Pos (6UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d6 (Bit 6)              */
#define hif_io_ctrl_hif_pio_out0_hif_d6_Msk (0x40UL)                /*!< hif_io_ctrl hif_pio_out0: hif_d6 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d5_Pos (5UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d5 (Bit 5)              */
#define hif_io_ctrl_hif_pio_out0_hif_d5_Msk (0x20UL)                /*!< hif_io_ctrl hif_pio_out0: hif_d5 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d4_Pos (4UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d4 (Bit 4)              */
#define hif_io_ctrl_hif_pio_out0_hif_d4_Msk (0x10UL)                /*!< hif_io_ctrl hif_pio_out0: hif_d4 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d3_Pos (3UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d3 (Bit 3)              */
#define hif_io_ctrl_hif_pio_out0_hif_d3_Msk (0x8UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d3 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d2_Pos (2UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d2 (Bit 2)              */
#define hif_io_ctrl_hif_pio_out0_hif_d2_Msk (0x4UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d2 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d1_Pos (1UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d1 (Bit 1)              */
#define hif_io_ctrl_hif_pio_out0_hif_d1_Msk (0x2UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d1 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out0_hif_d0_Pos (0UL)                   /*!< hif_io_ctrl hif_pio_out0: hif_d0 (Bit 0)              */
#define hif_io_ctrl_hif_pio_out0_hif_d0_Msk (0x1UL)                 /*!< hif_io_ctrl hif_pio_out0: hif_d0 (Bitfield-Mask: 0x01) */
/* =====================================================  hif_pio_out1  ====================================================== */
#define hif_io_ctrl_hif_pio_out1_hif_sdclk_Pos (31UL)               /*!< hif_io_ctrl hif_pio_out1: hif_sdclk (Bit 31)          */
#define hif_io_ctrl_hif_pio_out1_hif_sdclk_Msk (0x80000000UL)       /*!< hif_io_ctrl hif_pio_out1: hif_sdclk (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_dirq_Pos (30UL)                /*!< hif_io_ctrl hif_pio_out1: hif_dirq (Bit 30)           */
#define hif_io_ctrl_hif_pio_out1_hif_dirq_Msk (0x40000000UL)        /*!< hif_io_ctrl hif_pio_out1: hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_rdy_Pos (29UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_rdy (Bit 29)            */
#define hif_io_ctrl_hif_pio_out1_hif_rdy_Msk (0x20000000UL)         /*!< hif_io_ctrl hif_pio_out1: hif_rdy (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_csn_Pos (28UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_csn (Bit 28)            */
#define hif_io_ctrl_hif_pio_out1_hif_csn_Msk (0x10000000UL)         /*!< hif_io_ctrl hif_pio_out1: hif_csn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_wrn_Pos (27UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_wrn (Bit 27)            */
#define hif_io_ctrl_hif_pio_out1_hif_wrn_Msk (0x8000000UL)          /*!< hif_io_ctrl hif_pio_out1: hif_wrn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_rdn_Pos (26UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_rdn (Bit 26)            */
#define hif_io_ctrl_hif_pio_out1_hif_rdn_Msk (0x4000000UL)          /*!< hif_io_ctrl hif_pio_out1: hif_rdn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_bhen_Pos (25UL)                /*!< hif_io_ctrl hif_pio_out1: hif_bhen (Bit 25)           */
#define hif_io_ctrl_hif_pio_out1_hif_bhen_Msk (0x2000000UL)         /*!< hif_io_ctrl hif_pio_out1: hif_bhen (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_reserved0_Pos (18UL)               /*!< hif_io_ctrl hif_pio_out1: reserved0 (Bit 18)          */
#define hif_io_ctrl_hif_pio_out1_reserved0_Msk (0x1fc0000UL)        /*!< hif_io_ctrl hif_pio_out1: reserved0 (Bitfield-Mask: 0x7f) */
#define hif_io_ctrl_hif_pio_out1_hif_a17_Pos (17UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a17 (Bit 17)            */
#define hif_io_ctrl_hif_pio_out1_hif_a17_Msk (0x20000UL)            /*!< hif_io_ctrl hif_pio_out1: hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a16_Pos (16UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a16 (Bit 16)            */
#define hif_io_ctrl_hif_pio_out1_hif_a16_Msk (0x10000UL)            /*!< hif_io_ctrl hif_pio_out1: hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a15_Pos (15UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a15 (Bit 15)            */
#define hif_io_ctrl_hif_pio_out1_hif_a15_Msk (0x8000UL)             /*!< hif_io_ctrl hif_pio_out1: hif_a15 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a14_Pos (14UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a14 (Bit 14)            */
#define hif_io_ctrl_hif_pio_out1_hif_a14_Msk (0x4000UL)             /*!< hif_io_ctrl hif_pio_out1: hif_a14 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a13_Pos (13UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a13 (Bit 13)            */
#define hif_io_ctrl_hif_pio_out1_hif_a13_Msk (0x2000UL)             /*!< hif_io_ctrl hif_pio_out1: hif_a13 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a12_Pos (12UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a12 (Bit 12)            */
#define hif_io_ctrl_hif_pio_out1_hif_a12_Msk (0x1000UL)             /*!< hif_io_ctrl hif_pio_out1: hif_a12 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a11_Pos (11UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a11 (Bit 11)            */
#define hif_io_ctrl_hif_pio_out1_hif_a11_Msk (0x800UL)              /*!< hif_io_ctrl hif_pio_out1: hif_a11 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a10_Pos (10UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a10 (Bit 10)            */
#define hif_io_ctrl_hif_pio_out1_hif_a10_Msk (0x400UL)              /*!< hif_io_ctrl hif_pio_out1: hif_a10 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a9_Pos (9UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a9 (Bit 9)              */
#define hif_io_ctrl_hif_pio_out1_hif_a9_Msk (0x200UL)               /*!< hif_io_ctrl hif_pio_out1: hif_a9 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a8_Pos (8UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a8 (Bit 8)              */
#define hif_io_ctrl_hif_pio_out1_hif_a8_Msk (0x100UL)               /*!< hif_io_ctrl hif_pio_out1: hif_a8 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a7_Pos (7UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a7 (Bit 7)              */
#define hif_io_ctrl_hif_pio_out1_hif_a7_Msk (0x80UL)                /*!< hif_io_ctrl hif_pio_out1: hif_a7 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a6_Pos (6UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a6 (Bit 6)              */
#define hif_io_ctrl_hif_pio_out1_hif_a6_Msk (0x40UL)                /*!< hif_io_ctrl hif_pio_out1: hif_a6 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a5_Pos (5UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a5 (Bit 5)              */
#define hif_io_ctrl_hif_pio_out1_hif_a5_Msk (0x20UL)                /*!< hif_io_ctrl hif_pio_out1: hif_a5 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a4_Pos (4UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a4 (Bit 4)              */
#define hif_io_ctrl_hif_pio_out1_hif_a4_Msk (0x10UL)                /*!< hif_io_ctrl hif_pio_out1: hif_a4 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a3_Pos (3UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a3 (Bit 3)              */
#define hif_io_ctrl_hif_pio_out1_hif_a3_Msk (0x8UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a3 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a2_Pos (2UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a2 (Bit 2)              */
#define hif_io_ctrl_hif_pio_out1_hif_a2_Msk (0x4UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a2 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a1_Pos (1UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a1 (Bit 1)              */
#define hif_io_ctrl_hif_pio_out1_hif_a1_Msk (0x2UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a1 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_out1_hif_a0_Pos (0UL)                   /*!< hif_io_ctrl hif_pio_out1: hif_a0 (Bit 0)              */
#define hif_io_ctrl_hif_pio_out1_hif_a0_Msk (0x1UL)                 /*!< hif_io_ctrl hif_pio_out1: hif_a0 (Bitfield-Mask: 0x01) */
/* ======================================================  hif_pio_oe0  ====================================================== */
#define hif_io_ctrl_hif_pio_oe0_hif_d15_Pos (15UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d15 (Bit 15)             */
#define hif_io_ctrl_hif_pio_oe0_hif_d15_Msk (0x8000UL)              /*!< hif_io_ctrl hif_pio_oe0: hif_d15 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d14_Pos (14UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d14 (Bit 14)             */
#define hif_io_ctrl_hif_pio_oe0_hif_d14_Msk (0x4000UL)              /*!< hif_io_ctrl hif_pio_oe0: hif_d14 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d13_Pos (13UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d13 (Bit 13)             */
#define hif_io_ctrl_hif_pio_oe0_hif_d13_Msk (0x2000UL)              /*!< hif_io_ctrl hif_pio_oe0: hif_d13 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d12_Pos (12UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d12 (Bit 12)             */
#define hif_io_ctrl_hif_pio_oe0_hif_d12_Msk (0x1000UL)              /*!< hif_io_ctrl hif_pio_oe0: hif_d12 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d11_Pos (11UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d11 (Bit 11)             */
#define hif_io_ctrl_hif_pio_oe0_hif_d11_Msk (0x800UL)               /*!< hif_io_ctrl hif_pio_oe0: hif_d11 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d10_Pos (10UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d10 (Bit 10)             */
#define hif_io_ctrl_hif_pio_oe0_hif_d10_Msk (0x400UL)               /*!< hif_io_ctrl hif_pio_oe0: hif_d10 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d9_Pos (9UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d9 (Bit 9)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d9_Msk (0x200UL)                /*!< hif_io_ctrl hif_pio_oe0: hif_d9 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d8_Pos (8UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d8 (Bit 8)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d8_Msk (0x100UL)                /*!< hif_io_ctrl hif_pio_oe0: hif_d8 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d7_Pos (7UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d7 (Bit 7)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d7_Msk (0x80UL)                 /*!< hif_io_ctrl hif_pio_oe0: hif_d7 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d6_Pos (6UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d6 (Bit 6)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d6_Msk (0x40UL)                 /*!< hif_io_ctrl hif_pio_oe0: hif_d6 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d5_Pos (5UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d5 (Bit 5)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d5_Msk (0x20UL)                 /*!< hif_io_ctrl hif_pio_oe0: hif_d5 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d4_Pos (4UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d4 (Bit 4)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d4_Msk (0x10UL)                 /*!< hif_io_ctrl hif_pio_oe0: hif_d4 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d3_Pos (3UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d3 (Bit 3)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d3_Msk (0x8UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d3 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d2_Pos (2UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d2 (Bit 2)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d2_Msk (0x4UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d2 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d1_Pos (1UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d1 (Bit 1)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d1_Msk (0x2UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d1 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe0_hif_d0_Pos (0UL)                    /*!< hif_io_ctrl hif_pio_oe0: hif_d0 (Bit 0)               */
#define hif_io_ctrl_hif_pio_oe0_hif_d0_Msk (0x1UL)                  /*!< hif_io_ctrl hif_pio_oe0: hif_d0 (Bitfield-Mask: 0x01) */
/* ======================================================  hif_pio_oe1  ====================================================== */
#define hif_io_ctrl_hif_pio_oe1_hif_sdclk_Pos (31UL)                /*!< hif_io_ctrl hif_pio_oe1: hif_sdclk (Bit 31)           */
#define hif_io_ctrl_hif_pio_oe1_hif_sdclk_Msk (0x80000000UL)        /*!< hif_io_ctrl hif_pio_oe1: hif_sdclk (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_dirq_Pos (30UL)                 /*!< hif_io_ctrl hif_pio_oe1: hif_dirq (Bit 30)            */
#define hif_io_ctrl_hif_pio_oe1_hif_dirq_Msk (0x40000000UL)         /*!< hif_io_ctrl hif_pio_oe1: hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_rdy_Pos (29UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_rdy (Bit 29)             */
#define hif_io_ctrl_hif_pio_oe1_hif_rdy_Msk (0x20000000UL)          /*!< hif_io_ctrl hif_pio_oe1: hif_rdy (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_csn_Pos (28UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_csn (Bit 28)             */
#define hif_io_ctrl_hif_pio_oe1_hif_csn_Msk (0x10000000UL)          /*!< hif_io_ctrl hif_pio_oe1: hif_csn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_wrn_Pos (27UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_wrn (Bit 27)             */
#define hif_io_ctrl_hif_pio_oe1_hif_wrn_Msk (0x8000000UL)           /*!< hif_io_ctrl hif_pio_oe1: hif_wrn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_rdn_Pos (26UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_rdn (Bit 26)             */
#define hif_io_ctrl_hif_pio_oe1_hif_rdn_Msk (0x4000000UL)           /*!< hif_io_ctrl hif_pio_oe1: hif_rdn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_bhen_Pos (25UL)                 /*!< hif_io_ctrl hif_pio_oe1: hif_bhen (Bit 25)            */
#define hif_io_ctrl_hif_pio_oe1_hif_bhen_Msk (0x2000000UL)          /*!< hif_io_ctrl hif_pio_oe1: hif_bhen (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_reserved0_Pos (18UL)                /*!< hif_io_ctrl hif_pio_oe1: reserved0 (Bit 18)           */
#define hif_io_ctrl_hif_pio_oe1_reserved0_Msk (0x1fc0000UL)         /*!< hif_io_ctrl hif_pio_oe1: reserved0 (Bitfield-Mask: 0x7f) */
#define hif_io_ctrl_hif_pio_oe1_hif_a17_Pos (17UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a17 (Bit 17)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a17_Msk (0x20000UL)             /*!< hif_io_ctrl hif_pio_oe1: hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a16_Pos (16UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a16 (Bit 16)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a16_Msk (0x10000UL)             /*!< hif_io_ctrl hif_pio_oe1: hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a15_Pos (15UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a15 (Bit 15)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a15_Msk (0x8000UL)              /*!< hif_io_ctrl hif_pio_oe1: hif_a15 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a14_Pos (14UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a14 (Bit 14)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a14_Msk (0x4000UL)              /*!< hif_io_ctrl hif_pio_oe1: hif_a14 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a13_Pos (13UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a13 (Bit 13)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a13_Msk (0x2000UL)              /*!< hif_io_ctrl hif_pio_oe1: hif_a13 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a12_Pos (12UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a12 (Bit 12)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a12_Msk (0x1000UL)              /*!< hif_io_ctrl hif_pio_oe1: hif_a12 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a11_Pos (11UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a11 (Bit 11)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a11_Msk (0x800UL)               /*!< hif_io_ctrl hif_pio_oe1: hif_a11 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a10_Pos (10UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a10 (Bit 10)             */
#define hif_io_ctrl_hif_pio_oe1_hif_a10_Msk (0x400UL)               /*!< hif_io_ctrl hif_pio_oe1: hif_a10 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a9_Pos (9UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a9 (Bit 9)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a9_Msk (0x200UL)                /*!< hif_io_ctrl hif_pio_oe1: hif_a9 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a8_Pos (8UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a8 (Bit 8)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a8_Msk (0x100UL)                /*!< hif_io_ctrl hif_pio_oe1: hif_a8 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a7_Pos (7UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a7 (Bit 7)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a7_Msk (0x80UL)                 /*!< hif_io_ctrl hif_pio_oe1: hif_a7 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a6_Pos (6UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a6 (Bit 6)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a6_Msk (0x40UL)                 /*!< hif_io_ctrl hif_pio_oe1: hif_a6 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a5_Pos (5UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a5 (Bit 5)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a5_Msk (0x20UL)                 /*!< hif_io_ctrl hif_pio_oe1: hif_a5 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a4_Pos (4UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a4 (Bit 4)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a4_Msk (0x10UL)                 /*!< hif_io_ctrl hif_pio_oe1: hif_a4 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a3_Pos (3UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a3 (Bit 3)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a3_Msk (0x8UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a3 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a2_Pos (2UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a2 (Bit 2)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a2_Msk (0x4UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a2 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a1_Pos (1UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a1 (Bit 1)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a1_Msk (0x2UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a1 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_oe1_hif_a0_Pos (0UL)                    /*!< hif_io_ctrl hif_pio_oe1: hif_a0 (Bit 0)               */
#define hif_io_ctrl_hif_pio_oe1_hif_a0_Msk (0x1UL)                  /*!< hif_io_ctrl hif_pio_oe1: hif_a0 (Bitfield-Mask: 0x01) */
/* ======================================================  hif_pio_in0  ====================================================== */
#define hif_io_ctrl_hif_pio_in0_hif_d15_Pos (15UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d15 (Bit 15)             */
#define hif_io_ctrl_hif_pio_in0_hif_d15_Msk (0x8000UL)              /*!< hif_io_ctrl hif_pio_in0: hif_d15 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d14_Pos (14UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d14 (Bit 14)             */
#define hif_io_ctrl_hif_pio_in0_hif_d14_Msk (0x4000UL)              /*!< hif_io_ctrl hif_pio_in0: hif_d14 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d13_Pos (13UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d13 (Bit 13)             */
#define hif_io_ctrl_hif_pio_in0_hif_d13_Msk (0x2000UL)              /*!< hif_io_ctrl hif_pio_in0: hif_d13 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d12_Pos (12UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d12 (Bit 12)             */
#define hif_io_ctrl_hif_pio_in0_hif_d12_Msk (0x1000UL)              /*!< hif_io_ctrl hif_pio_in0: hif_d12 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d11_Pos (11UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d11 (Bit 11)             */
#define hif_io_ctrl_hif_pio_in0_hif_d11_Msk (0x800UL)               /*!< hif_io_ctrl hif_pio_in0: hif_d11 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d10_Pos (10UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d10 (Bit 10)             */
#define hif_io_ctrl_hif_pio_in0_hif_d10_Msk (0x400UL)               /*!< hif_io_ctrl hif_pio_in0: hif_d10 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d9_Pos (9UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d9 (Bit 9)               */
#define hif_io_ctrl_hif_pio_in0_hif_d9_Msk (0x200UL)                /*!< hif_io_ctrl hif_pio_in0: hif_d9 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d8_Pos (8UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d8 (Bit 8)               */
#define hif_io_ctrl_hif_pio_in0_hif_d8_Msk (0x100UL)                /*!< hif_io_ctrl hif_pio_in0: hif_d8 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d7_Pos (7UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d7 (Bit 7)               */
#define hif_io_ctrl_hif_pio_in0_hif_d7_Msk (0x80UL)                 /*!< hif_io_ctrl hif_pio_in0: hif_d7 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d6_Pos (6UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d6 (Bit 6)               */
#define hif_io_ctrl_hif_pio_in0_hif_d6_Msk (0x40UL)                 /*!< hif_io_ctrl hif_pio_in0: hif_d6 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d5_Pos (5UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d5 (Bit 5)               */
#define hif_io_ctrl_hif_pio_in0_hif_d5_Msk (0x20UL)                 /*!< hif_io_ctrl hif_pio_in0: hif_d5 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d4_Pos (4UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d4 (Bit 4)               */
#define hif_io_ctrl_hif_pio_in0_hif_d4_Msk (0x10UL)                 /*!< hif_io_ctrl hif_pio_in0: hif_d4 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d3_Pos (3UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d3 (Bit 3)               */
#define hif_io_ctrl_hif_pio_in0_hif_d3_Msk (0x8UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d3 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d2_Pos (2UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d2 (Bit 2)               */
#define hif_io_ctrl_hif_pio_in0_hif_d2_Msk (0x4UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d2 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d1_Pos (1UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d1 (Bit 1)               */
#define hif_io_ctrl_hif_pio_in0_hif_d1_Msk (0x2UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d1 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in0_hif_d0_Pos (0UL)                    /*!< hif_io_ctrl hif_pio_in0: hif_d0 (Bit 0)               */
#define hif_io_ctrl_hif_pio_in0_hif_d0_Msk (0x1UL)                  /*!< hif_io_ctrl hif_pio_in0: hif_d0 (Bitfield-Mask: 0x01) */
/* ======================================================  hif_pio_in1  ====================================================== */
#define hif_io_ctrl_hif_pio_in1_hif_sdclk_Pos (31UL)                /*!< hif_io_ctrl hif_pio_in1: hif_sdclk (Bit 31)           */
#define hif_io_ctrl_hif_pio_in1_hif_sdclk_Msk (0x80000000UL)        /*!< hif_io_ctrl hif_pio_in1: hif_sdclk (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_dirq_Pos (30UL)                 /*!< hif_io_ctrl hif_pio_in1: hif_dirq (Bit 30)            */
#define hif_io_ctrl_hif_pio_in1_hif_dirq_Msk (0x40000000UL)         /*!< hif_io_ctrl hif_pio_in1: hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_rdy_Pos (29UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_rdy (Bit 29)             */
#define hif_io_ctrl_hif_pio_in1_hif_rdy_Msk (0x20000000UL)          /*!< hif_io_ctrl hif_pio_in1: hif_rdy (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_csn_Pos (28UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_csn (Bit 28)             */
#define hif_io_ctrl_hif_pio_in1_hif_csn_Msk (0x10000000UL)          /*!< hif_io_ctrl hif_pio_in1: hif_csn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_wrn_Pos (27UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_wrn (Bit 27)             */
#define hif_io_ctrl_hif_pio_in1_hif_wrn_Msk (0x8000000UL)           /*!< hif_io_ctrl hif_pio_in1: hif_wrn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_rdn_Pos (26UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_rdn (Bit 26)             */
#define hif_io_ctrl_hif_pio_in1_hif_rdn_Msk (0x4000000UL)           /*!< hif_io_ctrl hif_pio_in1: hif_rdn (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_bhen_Pos (25UL)                 /*!< hif_io_ctrl hif_pio_in1: hif_bhen (Bit 25)            */
#define hif_io_ctrl_hif_pio_in1_hif_bhen_Msk (0x2000000UL)          /*!< hif_io_ctrl hif_pio_in1: hif_bhen (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_reserved0_Pos (18UL)                /*!< hif_io_ctrl hif_pio_in1: reserved0 (Bit 18)           */
#define hif_io_ctrl_hif_pio_in1_reserved0_Msk (0x1fc0000UL)         /*!< hif_io_ctrl hif_pio_in1: reserved0 (Bitfield-Mask: 0x7f) */
#define hif_io_ctrl_hif_pio_in1_hif_a17_Pos (17UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a17 (Bit 17)             */
#define hif_io_ctrl_hif_pio_in1_hif_a17_Msk (0x20000UL)             /*!< hif_io_ctrl hif_pio_in1: hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a16_Pos (16UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a16 (Bit 16)             */
#define hif_io_ctrl_hif_pio_in1_hif_a16_Msk (0x10000UL)             /*!< hif_io_ctrl hif_pio_in1: hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a15_Pos (15UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a15 (Bit 15)             */
#define hif_io_ctrl_hif_pio_in1_hif_a15_Msk (0x8000UL)              /*!< hif_io_ctrl hif_pio_in1: hif_a15 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a14_Pos (14UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a14 (Bit 14)             */
#define hif_io_ctrl_hif_pio_in1_hif_a14_Msk (0x4000UL)              /*!< hif_io_ctrl hif_pio_in1: hif_a14 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a13_Pos (13UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a13 (Bit 13)             */
#define hif_io_ctrl_hif_pio_in1_hif_a13_Msk (0x2000UL)              /*!< hif_io_ctrl hif_pio_in1: hif_a13 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a12_Pos (12UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a12 (Bit 12)             */
#define hif_io_ctrl_hif_pio_in1_hif_a12_Msk (0x1000UL)              /*!< hif_io_ctrl hif_pio_in1: hif_a12 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a11_Pos (11UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a11 (Bit 11)             */
#define hif_io_ctrl_hif_pio_in1_hif_a11_Msk (0x800UL)               /*!< hif_io_ctrl hif_pio_in1: hif_a11 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a10_Pos (10UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a10 (Bit 10)             */
#define hif_io_ctrl_hif_pio_in1_hif_a10_Msk (0x400UL)               /*!< hif_io_ctrl hif_pio_in1: hif_a10 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a9_Pos (9UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a9 (Bit 9)               */
#define hif_io_ctrl_hif_pio_in1_hif_a9_Msk (0x200UL)                /*!< hif_io_ctrl hif_pio_in1: hif_a9 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a8_Pos (8UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a8 (Bit 8)               */
#define hif_io_ctrl_hif_pio_in1_hif_a8_Msk (0x100UL)                /*!< hif_io_ctrl hif_pio_in1: hif_a8 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a7_Pos (7UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a7 (Bit 7)               */
#define hif_io_ctrl_hif_pio_in1_hif_a7_Msk (0x80UL)                 /*!< hif_io_ctrl hif_pio_in1: hif_a7 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a6_Pos (6UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a6 (Bit 6)               */
#define hif_io_ctrl_hif_pio_in1_hif_a6_Msk (0x40UL)                 /*!< hif_io_ctrl hif_pio_in1: hif_a6 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a5_Pos (5UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a5 (Bit 5)               */
#define hif_io_ctrl_hif_pio_in1_hif_a5_Msk (0x20UL)                 /*!< hif_io_ctrl hif_pio_in1: hif_a5 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a4_Pos (4UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a4 (Bit 4)               */
#define hif_io_ctrl_hif_pio_in1_hif_a4_Msk (0x10UL)                 /*!< hif_io_ctrl hif_pio_in1: hif_a4 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a3_Pos (3UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a3 (Bit 3)               */
#define hif_io_ctrl_hif_pio_in1_hif_a3_Msk (0x8UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a3 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a2_Pos (2UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a2 (Bit 2)               */
#define hif_io_ctrl_hif_pio_in1_hif_a2_Msk (0x4UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a2 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a1_Pos (1UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a1 (Bit 1)               */
#define hif_io_ctrl_hif_pio_in1_hif_a1_Msk (0x2UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a1 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_in1_hif_a0_Pos (0UL)                    /*!< hif_io_ctrl hif_pio_in1: hif_a0 (Bit 0)               */
#define hif_io_ctrl_hif_pio_in1_hif_a0_Msk (0x1UL)                  /*!< hif_io_ctrl hif_pio_in1: hif_a0 (Bitfield-Mask: 0x01) */
/* ====================================================  hif_pio_irq_raw  ==================================================== */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_dirq_Pos (3UL)          /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_dirq (Bit 3)     */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_dirq_Msk (0x8UL)        /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_a17_Pos (2UL)           /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_a17 (Bit 2)      */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_a17_Msk (0x4UL)         /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_a16_Pos (1UL)           /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_a16 (Bit 1)      */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_a16_Msk (0x2UL)         /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_d12_Pos (0UL)           /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_d12 (Bit 0)      */
#define hif_io_ctrl_hif_pio_irq_raw_irq_hif_d12_Msk (0x1UL)         /*!< hif_io_ctrl hif_pio_irq_raw: irq_hif_d12 (Bitfield-Mask: 0x01) */
/* ===============================================  hif_pio_irq_arm_mask_set  ================================================ */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_dirq_Pos (3UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_dirq (Bit 3) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_dirq_Msk (0x8UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_a17_Pos (2UL)  /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_a17 (Bit 2) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_a17_Msk (0x4UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_a16_Pos (1UL)  /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_a16 (Bit 1) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_a16_Msk (0x2UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_d12_Pos (0UL)  /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_d12 (Bit 0) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_set_irq_hif_d12_Msk (0x1UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_set: irq_hif_d12 (Bitfield-Mask: 0x01) */
/* ==============================================  hif_pio_irq_arm_mask_reset  =============================================== */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_dirq_Pos (3UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_dirq (Bit 3) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_dirq_Msk (0x8UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_a17_Pos (2UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_a17 (Bit 2) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_a17_Msk (0x4UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_a16_Pos (1UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_a16 (Bit 1) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_a16_Msk (0x2UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_d12_Pos (0UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_d12 (Bit 0) */
#define hif_io_ctrl_hif_pio_irq_arm_mask_reset_irq_hif_d12_Msk (0x1UL) /*!< hif_io_ctrl hif_pio_irq_arm_mask_reset: irq_hif_d12 (Bitfield-Mask: 0x01) */
/* ================================================  hif_pio_irq_arm_masked  ================================================= */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_dirq_Pos (3UL)   /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_dirq (Bit 3) */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_dirq_Msk (0x8UL) /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_a17_Pos (2UL)    /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_a17 (Bit 2) */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_a17_Msk (0x4UL)  /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_a16_Pos (1UL)    /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_a16 (Bit 1) */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_a16_Msk (0x2UL)  /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_d12_Pos (0UL)    /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_d12 (Bit 0) */
#define hif_io_ctrl_hif_pio_irq_arm_masked_irq_hif_d12_Msk (0x1UL)  /*!< hif_io_ctrl hif_pio_irq_arm_masked: irq_hif_d12 (Bitfield-Mask: 0x01) */
/* ===============================================  hif_pio_irq_xpic_mask_set  =============================================== */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_dirq_Pos (3UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_dirq (Bit 3) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_dirq_Msk (0x8UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_a17_Pos (2UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_a17 (Bit 2) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_a17_Msk (0x4UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_a16_Pos (1UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_a16 (Bit 1) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_a16_Msk (0x2UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_d12_Pos (0UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_d12 (Bit 0) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_set_irq_hif_d12_Msk (0x1UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_set: irq_hif_d12 (Bitfield-Mask: 0x01) */
/* ==============================================  hif_pio_irq_xpic_mask_reset  ============================================== */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_dirq_Pos (3UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_dirq (Bit 3) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_dirq_Msk (0x8UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_a17_Pos (2UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_a17 (Bit 2) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_a17_Msk (0x4UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_a16_Pos (1UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_a16 (Bit 1) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_a16_Msk (0x2UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_d12_Pos (0UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_d12 (Bit 0) */
#define hif_io_ctrl_hif_pio_irq_xpic_mask_reset_irq_hif_d12_Msk (0x1UL) /*!< hif_io_ctrl hif_pio_irq_xpic_mask_reset: irq_hif_d12 (Bitfield-Mask: 0x01) */
/* ================================================  hif_pio_irq_xpic_masked  ================================================ */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_dirq_Pos (3UL)  /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_dirq (Bit 3) */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_dirq_Msk (0x8UL) /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_dirq (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_a17_Pos (2UL)   /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_a17 (Bit 2) */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_a17_Msk (0x4UL) /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_a17 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_a16_Pos (1UL)   /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_a16 (Bit 1) */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_a16_Msk (0x2UL) /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_a16 (Bitfield-Mask: 0x01) */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_d12_Pos (0UL)   /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_d12 (Bit 0) */
#define hif_io_ctrl_hif_pio_irq_xpic_masked_irq_hif_d12_Msk (0x1UL) /*!< hif_io_ctrl hif_pio_irq_xpic_masked: irq_hif_d12 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                     hif_asyncmem_ctrl                                     ================ */
/* =========================================================================================================================== */

/* =====================================================  extsram0_ctrl  ===================================================== */
#define hif_asyncmem_ctrl_extsram0_ctrl_ready_en_Pos (31UL)         /*!< hif_asyncmem_ctrl extsram0_ctrl: ready_en (Bit 31)    */
#define hif_asyncmem_ctrl_extsram0_ctrl_ready_en_Msk (0x80000000UL) /*!< hif_asyncmem_ctrl extsram0_ctrl: ready_en (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram0_ctrl_static_cs_Pos (30UL)        /*!< hif_asyncmem_ctrl extsram0_ctrl: static_cs (Bit 30)   */
#define hif_asyncmem_ctrl_extsram0_ctrl_static_cs_Msk (0x40000000UL) /*!< hif_asyncmem_ctrl extsram0_ctrl: static_cs (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram0_ctrl_no_p_post_seq_rd_Pos (29UL) /*!< hif_asyncmem_ctrl extsram0_ctrl: no_p_post_seq_rd (Bit 29) */
#define hif_asyncmem_ctrl_extsram0_ctrl_no_p_post_seq_rd_Msk (0x20000000UL) /*!< hif_asyncmem_ctrl extsram0_ctrl: no_p_post_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram0_ctrl_no_p_pre_seq_rd_Pos (28UL)  /*!< hif_asyncmem_ctrl extsram0_ctrl: no_p_pre_seq_rd (Bit 28) */
#define hif_asyncmem_ctrl_extsram0_ctrl_no_p_pre_seq_rd_Msk (0x10000000UL) /*!< hif_asyncmem_ctrl extsram0_ctrl: no_p_pre_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved3_Pos (26UL)        /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved3 (Bit 26)   */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved3_Msk (0xc000000UL) /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved3 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram0_ctrl_dwidth_Pos (24UL)           /*!< hif_asyncmem_ctrl extsram0_ctrl: dwidth (Bit 24)      */
#define hif_asyncmem_ctrl_extsram0_ctrl_dwidth_Msk (0x3000000UL)    /*!< hif_asyncmem_ctrl extsram0_ctrl: dwidth (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved2_Pos (18UL)        /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved2 (Bit 18)   */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved2_Msk (0xfc0000UL)  /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved2 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram0_ctrl_p_post_Pos (16UL)           /*!< hif_asyncmem_ctrl extsram0_ctrl: p_post (Bit 16)      */
#define hif_asyncmem_ctrl_extsram0_ctrl_p_post_Msk (0x30000UL)      /*!< hif_asyncmem_ctrl extsram0_ctrl: p_post (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved1_Pos (10UL)        /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved1 (Bit 10)   */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved1_Msk (0xfc00UL)    /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved1 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram0_ctrl_p_pre_Pos (8UL)             /*!< hif_asyncmem_ctrl extsram0_ctrl: p_pre (Bit 8)        */
#define hif_asyncmem_ctrl_extsram0_ctrl_p_pre_Msk (0x300UL)         /*!< hif_asyncmem_ctrl extsram0_ctrl: p_pre (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved0_Pos (6UL)         /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved0 (Bit 6)    */
#define hif_asyncmem_ctrl_extsram0_ctrl_reserved0_Msk (0xc0UL)      /*!< hif_asyncmem_ctrl extsram0_ctrl: reserved0 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram0_ctrl_ws_Pos (0UL)                /*!< hif_asyncmem_ctrl extsram0_ctrl: ws (Bit 0)           */
#define hif_asyncmem_ctrl_extsram0_ctrl_ws_Msk (0x3fUL)             /*!< hif_asyncmem_ctrl extsram0_ctrl: ws (Bitfield-Mask: 0x3f) */
/* =====================================================  extsram1_ctrl  ===================================================== */
#define hif_asyncmem_ctrl_extsram1_ctrl_ready_en_Pos (31UL)         /*!< hif_asyncmem_ctrl extsram1_ctrl: ready_en (Bit 31)    */
#define hif_asyncmem_ctrl_extsram1_ctrl_ready_en_Msk (0x80000000UL) /*!< hif_asyncmem_ctrl extsram1_ctrl: ready_en (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram1_ctrl_static_cs_Pos (30UL)        /*!< hif_asyncmem_ctrl extsram1_ctrl: static_cs (Bit 30)   */
#define hif_asyncmem_ctrl_extsram1_ctrl_static_cs_Msk (0x40000000UL) /*!< hif_asyncmem_ctrl extsram1_ctrl: static_cs (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram1_ctrl_no_p_post_seq_rd_Pos (29UL) /*!< hif_asyncmem_ctrl extsram1_ctrl: no_p_post_seq_rd (Bit 29) */
#define hif_asyncmem_ctrl_extsram1_ctrl_no_p_post_seq_rd_Msk (0x20000000UL) /*!< hif_asyncmem_ctrl extsram1_ctrl: no_p_post_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram1_ctrl_no_p_pre_seq_rd_Pos (28UL)  /*!< hif_asyncmem_ctrl extsram1_ctrl: no_p_pre_seq_rd (Bit 28) */
#define hif_asyncmem_ctrl_extsram1_ctrl_no_p_pre_seq_rd_Msk (0x10000000UL) /*!< hif_asyncmem_ctrl extsram1_ctrl: no_p_pre_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved3_Pos (26UL)        /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved3 (Bit 26)   */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved3_Msk (0xc000000UL) /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved3 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram1_ctrl_dwidth_Pos (24UL)           /*!< hif_asyncmem_ctrl extsram1_ctrl: dwidth (Bit 24)      */
#define hif_asyncmem_ctrl_extsram1_ctrl_dwidth_Msk (0x3000000UL)    /*!< hif_asyncmem_ctrl extsram1_ctrl: dwidth (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved2_Pos (18UL)        /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved2 (Bit 18)   */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved2_Msk (0xfc0000UL)  /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved2 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram1_ctrl_p_post_Pos (16UL)           /*!< hif_asyncmem_ctrl extsram1_ctrl: p_post (Bit 16)      */
#define hif_asyncmem_ctrl_extsram1_ctrl_p_post_Msk (0x30000UL)      /*!< hif_asyncmem_ctrl extsram1_ctrl: p_post (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved1_Pos (10UL)        /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved1 (Bit 10)   */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved1_Msk (0xfc00UL)    /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved1 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram1_ctrl_p_pre_Pos (8UL)             /*!< hif_asyncmem_ctrl extsram1_ctrl: p_pre (Bit 8)        */
#define hif_asyncmem_ctrl_extsram1_ctrl_p_pre_Msk (0x300UL)         /*!< hif_asyncmem_ctrl extsram1_ctrl: p_pre (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved0_Pos (6UL)         /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved0 (Bit 6)    */
#define hif_asyncmem_ctrl_extsram1_ctrl_reserved0_Msk (0xc0UL)      /*!< hif_asyncmem_ctrl extsram1_ctrl: reserved0 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram1_ctrl_ws_Pos (0UL)                /*!< hif_asyncmem_ctrl extsram1_ctrl: ws (Bit 0)           */
#define hif_asyncmem_ctrl_extsram1_ctrl_ws_Msk (0x3fUL)             /*!< hif_asyncmem_ctrl extsram1_ctrl: ws (Bitfield-Mask: 0x3f) */
/* =====================================================  extsram2_ctrl  ===================================================== */
#define hif_asyncmem_ctrl_extsram2_ctrl_ready_en_Pos (31UL)         /*!< hif_asyncmem_ctrl extsram2_ctrl: ready_en (Bit 31)    */
#define hif_asyncmem_ctrl_extsram2_ctrl_ready_en_Msk (0x80000000UL) /*!< hif_asyncmem_ctrl extsram2_ctrl: ready_en (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram2_ctrl_static_cs_Pos (30UL)        /*!< hif_asyncmem_ctrl extsram2_ctrl: static_cs (Bit 30)   */
#define hif_asyncmem_ctrl_extsram2_ctrl_static_cs_Msk (0x40000000UL) /*!< hif_asyncmem_ctrl extsram2_ctrl: static_cs (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram2_ctrl_no_p_post_seq_rd_Pos (29UL) /*!< hif_asyncmem_ctrl extsram2_ctrl: no_p_post_seq_rd (Bit 29) */
#define hif_asyncmem_ctrl_extsram2_ctrl_no_p_post_seq_rd_Msk (0x20000000UL) /*!< hif_asyncmem_ctrl extsram2_ctrl: no_p_post_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram2_ctrl_no_p_pre_seq_rd_Pos (28UL)  /*!< hif_asyncmem_ctrl extsram2_ctrl: no_p_pre_seq_rd (Bit 28) */
#define hif_asyncmem_ctrl_extsram2_ctrl_no_p_pre_seq_rd_Msk (0x10000000UL) /*!< hif_asyncmem_ctrl extsram2_ctrl: no_p_pre_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved3_Pos (26UL)        /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved3 (Bit 26)   */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved3_Msk (0xc000000UL) /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved3 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram2_ctrl_dwidth_Pos (24UL)           /*!< hif_asyncmem_ctrl extsram2_ctrl: dwidth (Bit 24)      */
#define hif_asyncmem_ctrl_extsram2_ctrl_dwidth_Msk (0x3000000UL)    /*!< hif_asyncmem_ctrl extsram2_ctrl: dwidth (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved2_Pos (18UL)        /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved2 (Bit 18)   */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved2_Msk (0xfc0000UL)  /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved2 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram2_ctrl_p_post_Pos (16UL)           /*!< hif_asyncmem_ctrl extsram2_ctrl: p_post (Bit 16)      */
#define hif_asyncmem_ctrl_extsram2_ctrl_p_post_Msk (0x30000UL)      /*!< hif_asyncmem_ctrl extsram2_ctrl: p_post (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved1_Pos (10UL)        /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved1 (Bit 10)   */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved1_Msk (0xfc00UL)    /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved1 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram2_ctrl_p_pre_Pos (8UL)             /*!< hif_asyncmem_ctrl extsram2_ctrl: p_pre (Bit 8)        */
#define hif_asyncmem_ctrl_extsram2_ctrl_p_pre_Msk (0x300UL)         /*!< hif_asyncmem_ctrl extsram2_ctrl: p_pre (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved0_Pos (6UL)         /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved0 (Bit 6)    */
#define hif_asyncmem_ctrl_extsram2_ctrl_reserved0_Msk (0xc0UL)      /*!< hif_asyncmem_ctrl extsram2_ctrl: reserved0 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram2_ctrl_ws_Pos (0UL)                /*!< hif_asyncmem_ctrl extsram2_ctrl: ws (Bit 0)           */
#define hif_asyncmem_ctrl_extsram2_ctrl_ws_Msk (0x3fUL)             /*!< hif_asyncmem_ctrl extsram2_ctrl: ws (Bitfield-Mask: 0x3f) */
/* =====================================================  extsram3_ctrl  ===================================================== */
#define hif_asyncmem_ctrl_extsram3_ctrl_ready_en_Pos (31UL)         /*!< hif_asyncmem_ctrl extsram3_ctrl: ready_en (Bit 31)    */
#define hif_asyncmem_ctrl_extsram3_ctrl_ready_en_Msk (0x80000000UL) /*!< hif_asyncmem_ctrl extsram3_ctrl: ready_en (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram3_ctrl_static_cs_Pos (30UL)        /*!< hif_asyncmem_ctrl extsram3_ctrl: static_cs (Bit 30)   */
#define hif_asyncmem_ctrl_extsram3_ctrl_static_cs_Msk (0x40000000UL) /*!< hif_asyncmem_ctrl extsram3_ctrl: static_cs (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram3_ctrl_no_p_post_seq_rd_Pos (29UL) /*!< hif_asyncmem_ctrl extsram3_ctrl: no_p_post_seq_rd (Bit 29) */
#define hif_asyncmem_ctrl_extsram3_ctrl_no_p_post_seq_rd_Msk (0x20000000UL) /*!< hif_asyncmem_ctrl extsram3_ctrl: no_p_post_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram3_ctrl_no_p_pre_seq_rd_Pos (28UL)  /*!< hif_asyncmem_ctrl extsram3_ctrl: no_p_pre_seq_rd (Bit 28) */
#define hif_asyncmem_ctrl_extsram3_ctrl_no_p_pre_seq_rd_Msk (0x10000000UL) /*!< hif_asyncmem_ctrl extsram3_ctrl: no_p_pre_seq_rd (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved3_Pos (26UL)        /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved3 (Bit 26)   */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved3_Msk (0xc000000UL) /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved3 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram3_ctrl_dwidth_Pos (24UL)           /*!< hif_asyncmem_ctrl extsram3_ctrl: dwidth (Bit 24)      */
#define hif_asyncmem_ctrl_extsram3_ctrl_dwidth_Msk (0x3000000UL)    /*!< hif_asyncmem_ctrl extsram3_ctrl: dwidth (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved2_Pos (18UL)        /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved2 (Bit 18)   */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved2_Msk (0xfc0000UL)  /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved2 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram3_ctrl_p_post_Pos (16UL)           /*!< hif_asyncmem_ctrl extsram3_ctrl: p_post (Bit 16)      */
#define hif_asyncmem_ctrl_extsram3_ctrl_p_post_Msk (0x30000UL)      /*!< hif_asyncmem_ctrl extsram3_ctrl: p_post (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved1_Pos (10UL)        /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved1 (Bit 10)   */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved1_Msk (0xfc00UL)    /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved1 (Bitfield-Mask: 0x3f) */
#define hif_asyncmem_ctrl_extsram3_ctrl_p_pre_Pos (8UL)             /*!< hif_asyncmem_ctrl extsram3_ctrl: p_pre (Bit 8)        */
#define hif_asyncmem_ctrl_extsram3_ctrl_p_pre_Msk (0x300UL)         /*!< hif_asyncmem_ctrl extsram3_ctrl: p_pre (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved0_Pos (6UL)         /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved0 (Bit 6)    */
#define hif_asyncmem_ctrl_extsram3_ctrl_reserved0_Msk (0xc0UL)      /*!< hif_asyncmem_ctrl extsram3_ctrl: reserved0 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_extsram3_ctrl_ws_Pos (0UL)                /*!< hif_asyncmem_ctrl extsram3_ctrl: ws (Bit 0)           */
#define hif_asyncmem_ctrl_extsram3_ctrl_ws_Msk (0x3fUL)             /*!< hif_asyncmem_ctrl extsram3_ctrl: ws (Bitfield-Mask: 0x3f) */
/* ===================================================  ext_cs0_apm_ctrl  ==================================================== */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_reserved1_Pos (11UL)     /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: reserved1 (Bit 11) */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_reserved1_Msk (0xfffff800UL) /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: reserved1 (Bitfield-Mask: 0x1fffff) */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_apm_cfg_Pos (8UL)        /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: apm_cfg (Bit 8)   */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_apm_cfg_Msk (0x700UL)    /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: apm_cfg (Bitfield-Mask: 0x07) */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_reserved0_Pos (4UL)      /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: reserved0 (Bit 4) */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_reserved0_Msk (0xf0UL)   /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: reserved0 (Bitfield-Mask: 0x0f) */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_ws_apm_Pos (0UL)         /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: ws_apm (Bit 0)    */
#define hif_asyncmem_ctrl_ext_cs0_apm_ctrl_ws_apm_Msk (0xfUL)       /*!< hif_asyncmem_ctrl ext_cs0_apm_ctrl: ws_apm (Bitfield-Mask: 0x0f) */
/* ======================================================  ext_rdy_cfg  ====================================================== */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved3_Pos (12UL)          /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved3 (Bit 12)     */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved3_Msk (0xfffff000UL)  /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved3 (Bitfield-Mask: 0xfffff) */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_to_dis_Pos (11UL)         /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_to_dis (Bit 11)    */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_to_dis_Msk (0x800UL)      /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_to_dis (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved2_Pos (9UL)           /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved2 (Bit 9)      */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved2_Msk (0x600UL)       /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved2 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_to_irq_en_Pos (8UL)       /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_to_irq_en (Bit 8)  */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_to_irq_en_Msk (0x100UL)   /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_to_irq_en (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved1_Pos (6UL)           /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved1 (Bit 6)      */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved1_Msk (0xc0UL)        /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved1 (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_filter_Pos (4UL)          /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_filter (Bit 4)     */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_filter_Msk (0x30UL)       /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_filter (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved0_Pos (1UL)           /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved0 (Bit 1)      */
#define hif_asyncmem_ctrl_ext_rdy_cfg_reserved0_Msk (0xeUL)         /*!< hif_asyncmem_ctrl ext_rdy_cfg: reserved0 (Bitfield-Mask: 0x07) */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_act_level_Pos (0UL)       /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_act_level (Bit 0)  */
#define hif_asyncmem_ctrl_ext_rdy_cfg_rdy_act_level_Msk (0x1UL)     /*!< hif_asyncmem_ctrl ext_rdy_cfg: rdy_act_level (Bitfield-Mask: 0x01) */
/* ====================================================  ext_rdy_status  ===================================================== */
#define hif_asyncmem_ctrl_ext_rdy_status_rdy_to_err_Pos (31UL)      /*!< hif_asyncmem_ctrl ext_rdy_status: rdy_to_err (Bit 31) */
#define hif_asyncmem_ctrl_ext_rdy_status_rdy_to_err_Msk (0x80000000UL) /*!< hif_asyncmem_ctrl ext_rdy_status: rdy_to_err (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_ext_rdy_status_reserved1_Pos (30UL)       /*!< hif_asyncmem_ctrl ext_rdy_status: reserved1 (Bit 30)  */
#define hif_asyncmem_ctrl_ext_rdy_status_reserved1_Msk (0x40000000UL) /*!< hif_asyncmem_ctrl ext_rdy_status: reserved1 (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_ext_rdy_status_rdy_to_err_cs_Pos (28UL)   /*!< hif_asyncmem_ctrl ext_rdy_status: rdy_to_err_cs (Bit 28) */
#define hif_asyncmem_ctrl_ext_rdy_status_rdy_to_err_cs_Msk (0x30000000UL) /*!< hif_asyncmem_ctrl ext_rdy_status: rdy_to_err_cs (Bitfield-Mask: 0x03) */
#define hif_asyncmem_ctrl_ext_rdy_status_reserved0_Pos (27UL)       /*!< hif_asyncmem_ctrl ext_rdy_status: reserved0 (Bit 27)  */
#define hif_asyncmem_ctrl_ext_rdy_status_reserved0_Msk (0x8000000UL) /*!< hif_asyncmem_ctrl ext_rdy_status: reserved0 (Bitfield-Mask: 0x01) */
#define hif_asyncmem_ctrl_ext_rdy_status_rdy_to_err_adr_Pos (0UL)   /*!< hif_asyncmem_ctrl ext_rdy_status: rdy_to_err_adr (Bit 0) */
#define hif_asyncmem_ctrl_ext_rdy_status_rdy_to_err_adr_Msk (0x7ffffffUL) /*!< hif_asyncmem_ctrl ext_rdy_status: rdy_to_err_adr (Bitfield-Mask: 0x7ffffff) */


/* =========================================================================================================================== */
/* ================                                      hif_sdram_ctrl                                       ================ */
/* =========================================================================================================================== */

/* ==================================================  sdram_general_ctrl  =================================================== */
#define hif_sdram_ctrl_sdram_general_ctrl_refresh_status_Pos (31UL) /*!< hif_sdram_ctrl sdram_general_ctrl: refresh_status (Bit 31) */
#define hif_sdram_ctrl_sdram_general_ctrl_refresh_status_Msk (0x80000000UL) /*!< hif_sdram_ctrl sdram_general_ctrl: refresh_status (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_general_ctrl_sdram_ready_Pos (30UL)    /*!< hif_sdram_ctrl sdram_general_ctrl: sdram_ready (Bit 30) */
#define hif_sdram_ctrl_sdram_general_ctrl_sdram_ready_Msk (0x40000000UL) /*!< hif_sdram_ctrl sdram_general_ctrl: sdram_ready (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved4_Pos (26UL)      /*!< hif_sdram_ctrl sdram_general_ctrl: reserved4 (Bit 26) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved4_Msk (0x3c000000UL) /*!< hif_sdram_ctrl sdram_general_ctrl: reserved4 (Bitfield-Mask: 0x0f) */
#define hif_sdram_ctrl_sdram_general_ctrl_refresh_mode_Pos (24UL)   /*!< hif_sdram_ctrl sdram_general_ctrl: refresh_mode (Bit 24) */
#define hif_sdram_ctrl_sdram_general_ctrl_refresh_mode_Msk (0x3000000UL) /*!< hif_sdram_ctrl sdram_general_ctrl: refresh_mode (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved3_Pos (20UL)      /*!< hif_sdram_ctrl sdram_general_ctrl: reserved3 (Bit 20) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved3_Msk (0xf00000UL) /*!< hif_sdram_ctrl sdram_general_ctrl: reserved3 (Bitfield-Mask: 0x0f) */
#define hif_sdram_ctrl_sdram_general_ctrl_ctrl_en_Pos (19UL)        /*!< hif_sdram_ctrl sdram_general_ctrl: ctrl_en (Bit 19)   */
#define hif_sdram_ctrl_sdram_general_ctrl_ctrl_en_Msk (0x80000UL)   /*!< hif_sdram_ctrl sdram_general_ctrl: ctrl_en (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_general_ctrl_extclk_en_Pos (18UL)      /*!< hif_sdram_ctrl sdram_general_ctrl: extclk_en (Bit 18) */
#define hif_sdram_ctrl_sdram_general_ctrl_extclk_en_Msk (0x40000UL) /*!< hif_sdram_ctrl sdram_general_ctrl: extclk_en (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_general_ctrl_sdram_pwdn_Pos (17UL)     /*!< hif_sdram_ctrl sdram_general_ctrl: sdram_pwdn (Bit 17) */
#define hif_sdram_ctrl_sdram_general_ctrl_sdram_pwdn_Msk (0x20000UL) /*!< hif_sdram_ctrl sdram_general_ctrl: sdram_pwdn (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_general_ctrl_dbus16_Pos (16UL)         /*!< hif_sdram_ctrl sdram_general_ctrl: dbus16 (Bit 16)    */
#define hif_sdram_ctrl_sdram_general_ctrl_dbus16_Msk (0x10000UL)    /*!< hif_sdram_ctrl sdram_general_ctrl: dbus16 (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved2_Pos (11UL)      /*!< hif_sdram_ctrl sdram_general_ctrl: reserved2 (Bit 11) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved2_Msk (0xf800UL)  /*!< hif_sdram_ctrl sdram_general_ctrl: reserved2 (Bitfield-Mask: 0x1f) */
#define hif_sdram_ctrl_sdram_general_ctrl_columns_Pos (8UL)         /*!< hif_sdram_ctrl sdram_general_ctrl: columns (Bit 8)    */
#define hif_sdram_ctrl_sdram_general_ctrl_columns_Msk (0x700UL)     /*!< hif_sdram_ctrl sdram_general_ctrl: columns (Bitfield-Mask: 0x07) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved1_Pos (6UL)       /*!< hif_sdram_ctrl sdram_general_ctrl: reserved1 (Bit 6)  */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved1_Msk (0xc0UL)    /*!< hif_sdram_ctrl sdram_general_ctrl: reserved1 (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_general_ctrl_rows_Pos (4UL)            /*!< hif_sdram_ctrl sdram_general_ctrl: rows (Bit 4)       */
#define hif_sdram_ctrl_sdram_general_ctrl_rows_Msk (0x30UL)         /*!< hif_sdram_ctrl sdram_general_ctrl: rows (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved0_Pos (2UL)       /*!< hif_sdram_ctrl sdram_general_ctrl: reserved0 (Bit 2)  */
#define hif_sdram_ctrl_sdram_general_ctrl_reserved0_Msk (0xcUL)     /*!< hif_sdram_ctrl sdram_general_ctrl: reserved0 (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_general_ctrl_banks_Pos (0UL)           /*!< hif_sdram_ctrl sdram_general_ctrl: banks (Bit 0)      */
#define hif_sdram_ctrl_sdram_general_ctrl_banks_Msk (0x3UL)         /*!< hif_sdram_ctrl sdram_general_ctrl: banks (Bitfield-Mask: 0x03) */
/* ===================================================  sdram_timing_ctrl  =================================================== */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved5_Pos (29UL)       /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved5 (Bit 29)  */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved5_Msk (0xe0000000UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved5 (Bitfield-Mask: 0x07) */
#define hif_sdram_ctrl_sdram_timing_ctrl_bypass_neg_delay_Pos (28UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: bypass_neg_delay (Bit 28) */
#define hif_sdram_ctrl_sdram_timing_ctrl_bypass_neg_delay_Msk (0x10000000UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: bypass_neg_delay (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved4_Pos (27UL)       /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved4 (Bit 27)  */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved4_Msk (0x8000000UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved4 (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_timing_ctrl_data_sample_phase_Pos (24UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: data_sample_phase (Bit 24) */
#define hif_sdram_ctrl_sdram_timing_ctrl_data_sample_phase_Msk (0x7000000UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: data_sample_phase (Bitfield-Mask: 0x07) */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved3_Pos (23UL)       /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved3 (Bit 23)  */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved3_Msk (0x800000UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved3 (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_timing_ctrl_mem_sdclk_phase_Pos (20UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: mem_sdclk_phase (Bit 20) */
#define hif_sdram_ctrl_sdram_timing_ctrl_mem_sdclk_phase_Msk (0x700000UL) /*!< hif_sdram_ctrl sdram_timing_ctrl: mem_sdclk_phase (Bitfield-Mask: 0x07) */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved2_Pos (18UL)       /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved2 (Bit 18)  */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved2_Msk (0xc0000UL)  /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved2 (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_REFI_Pos (16UL)          /*!< hif_sdram_ctrl sdram_timing_ctrl: t_REFI (Bit 16)     */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_REFI_Msk (0x30000UL)     /*!< hif_sdram_ctrl sdram_timing_ctrl: t_REFI (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RFC_Pos (12UL)           /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RFC (Bit 12)      */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RFC_Msk (0xf000UL)       /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RFC (Bitfield-Mask: 0x0f) */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved1_Pos (11UL)       /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved1 (Bit 11)  */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved1_Msk (0x800UL)    /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved1 (Bitfield-Mask: 0x01) */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RAS_Pos (8UL)            /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RAS (Bit 8)       */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RAS_Msk (0x700UL)        /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RAS (Bitfield-Mask: 0x07) */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RP_Pos (6UL)             /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RP (Bit 6)        */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RP_Msk (0xc0UL)          /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RP (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_WR_Pos (4UL)             /*!< hif_sdram_ctrl sdram_timing_ctrl: t_WR (Bit 4)        */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_WR_Msk (0x30UL)          /*!< hif_sdram_ctrl sdram_timing_ctrl: t_WR (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved0_Pos (2UL)        /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved0 (Bit 2)   */
#define hif_sdram_ctrl_sdram_timing_ctrl_reserved0_Msk (0xcUL)      /*!< hif_sdram_ctrl sdram_timing_ctrl: reserved0 (Bitfield-Mask: 0x03) */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RCD_Pos (0UL)            /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RCD (Bit 0)       */
#define hif_sdram_ctrl_sdram_timing_ctrl_t_RCD_Msk (0x3UL)          /*!< hif_sdram_ctrl sdram_timing_ctrl: t_RCD (Bitfield-Mask: 0x03) */
/* =======================================================  sdram_mr  ======================================================== */
#define hif_sdram_ctrl_sdram_mr_MR_Pos    (0UL)                     /*!< hif_sdram_ctrl sdram_mr: MR (Bit 0)                   */
#define hif_sdram_ctrl_sdram_mr_MR_Msk    (0x3fffUL)                /*!< hif_sdram_ctrl sdram_mr: MR (Bitfield-Mask: 0x3fff)   */


/* =========================================================================================================================== */
/* ================                                   hifmem_priority_ctrl                                    ================ */
/* =========================================================================================================================== */

/* ===============================================  extmem_prio_timslot_ctrl  ================================================ */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved4_Pos (19UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved4 (Bit 19) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved4_Msk (0xfff80000UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved4 (Bitfield-Mask: 0x1fff) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_shared_mi_Pos (16UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_shared_mi (Bit 16) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_shared_mi_Msk (0x70000UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_shared_mi (Bitfield-Mask: 0x07) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved3_Pos (15UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved3 (Bit 15) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved3_Msk (0x8000UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved3 (Bitfield-Mask: 0x01) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_app_i_Pos (12UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_app_i (Bit 12) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_app_i_Msk (0x7000UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_app_i (Bitfield-Mask: 0x07) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved2_Pos (11UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved2 (Bit 11) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved2_Msk (0x800UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved2 (Bitfield-Mask: 0x01) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_app_d_Pos (8UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_app_d (Bit 8) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_app_d_Msk (0x700UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_app_d (Bitfield-Mask: 0x07) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved1_Pos (7UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved1 (Bit 7) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved1_Msk (0x80UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved1 (Bitfield-Mask: 0x01) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_com_i_Pos (4UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_com_i (Bit 4) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_com_i_Msk (0x70UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_com_i (Bitfield-Mask: 0x07) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved0_Pos (3UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved0 (Bit 3) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_reserved0_Msk (0x8UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: reserved0 (Bitfield-Mask: 0x01) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_com_d_Pos (0UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_com_d (Bit 0) */
#define hifmem_priority_ctrl_extmem_prio_timslot_ctrl_ts_length_arm_com_d_Msk (0x7UL) /*!< hifmem_priority_ctrl extmem_prio_timslot_ctrl: ts_length_arm_com_d (Bitfield-Mask: 0x07) */
/* ==============================================  extmem_prio_accesstime_ctrl  ============================================== */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi_Pos (24UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_shared_mi (Bit 24) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi_Msk (0x3f000000UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_shared_mi (Bitfield-Mask: 0x3f) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i_Pos (18UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_app_i (Bit 18) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i_Msk (0xfc0000UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_app_i (Bitfield-Mask: 0x3f) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d_Pos (12UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_app_d (Bit 12) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d_Msk (0x3f000UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_app_d (Bitfield-Mask: 0x3f) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i_Pos (6UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_com_i (Bit 6) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i_Msk (0xfc0UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_com_i (Bitfield-Mask: 0x3f) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d_Pos (0UL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_com_d (Bit 0) */
#define hifmem_priority_ctrl_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d_Msk (0x3fUL) /*!< hifmem_priority_ctrl extmem_prio_accesstime_ctrl: ts_accessrate_arm_com_d (Bitfield-Mask: 0x3f) */


/* =========================================================================================================================== */
/* ================                                           abort                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  abort_base  ======================================================= */
/* =======================================================  abort_end  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            sqi                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  sqi_cr0  ======================================================== */
#define sqi_sqi_cr0_reserved3_Pos         (28UL)                    /*!< sqi sqi_cr0: reserved3 (Bit 28)                       */
#define sqi_sqi_cr0_reserved3_Msk         (0xf0000000UL)            /*!< sqi sqi_cr0: reserved3 (Bitfield-Mask: 0x0f)          */
#define sqi_sqi_cr0_filter_in_Pos         (27UL)                    /*!< sqi sqi_cr0: filter_in (Bit 27)                       */
#define sqi_sqi_cr0_filter_in_Msk         (0x8000000UL)             /*!< sqi sqi_cr0: filter_in (Bitfield-Mask: 0x01)          */
#define sqi_sqi_cr0_reserved2_Pos         (24UL)                    /*!< sqi sqi_cr0: reserved2 (Bit 24)                       */
#define sqi_sqi_cr0_reserved2_Msk         (0x7000000UL)             /*!< sqi sqi_cr0: reserved2 (Bitfield-Mask: 0x07)          */
#define sqi_sqi_cr0_sio_cfg_Pos           (22UL)                    /*!< sqi sqi_cr0: sio_cfg (Bit 22)                         */
#define sqi_sqi_cr0_sio_cfg_Msk           (0xc00000UL)              /*!< sqi sqi_cr0: sio_cfg (Bitfield-Mask: 0x03)            */
#define sqi_sqi_cr0_reserved1_Pos         (20UL)                    /*!< sqi sqi_cr0: reserved1 (Bit 20)                       */
#define sqi_sqi_cr0_reserved1_Msk         (0x300000UL)              /*!< sqi sqi_cr0: reserved1 (Bitfield-Mask: 0x03)          */
#define sqi_sqi_cr0_sck_muladd_Pos        (8UL)                     /*!< sqi sqi_cr0: sck_muladd (Bit 8)                       */
#define sqi_sqi_cr0_sck_muladd_Msk        (0xfff00UL)               /*!< sqi sqi_cr0: sck_muladd (Bitfield-Mask: 0xfff)        */
#define sqi_sqi_cr0_sck_phase_Pos         (7UL)                     /*!< sqi sqi_cr0: sck_phase (Bit 7)                        */
#define sqi_sqi_cr0_sck_phase_Msk         (0x80UL)                  /*!< sqi sqi_cr0: sck_phase (Bitfield-Mask: 0x01)          */
#define sqi_sqi_cr0_sck_pol_Pos           (6UL)                     /*!< sqi sqi_cr0: sck_pol (Bit 6)                          */
#define sqi_sqi_cr0_sck_pol_Msk           (0x40UL)                  /*!< sqi sqi_cr0: sck_pol (Bitfield-Mask: 0x01)            */
#define sqi_sqi_cr0_reserved0_Pos         (4UL)                     /*!< sqi sqi_cr0: reserved0 (Bit 4)                        */
#define sqi_sqi_cr0_reserved0_Msk         (0x30UL)                  /*!< sqi sqi_cr0: reserved0 (Bitfield-Mask: 0x03)          */
#define sqi_sqi_cr0_datasize_Pos          (0UL)                     /*!< sqi sqi_cr0: datasize (Bit 0)                         */
#define sqi_sqi_cr0_datasize_Msk          (0xfUL)                   /*!< sqi sqi_cr0: datasize (Bitfield-Mask: 0x0f)           */
/* ========================================================  sqi_cr1  ======================================================== */
#define sqi_sqi_cr1_reserved4_Pos         (29UL)                    /*!< sqi sqi_cr1: reserved4 (Bit 29)                       */
#define sqi_sqi_cr1_reserved4_Msk         (0xe0000000UL)            /*!< sqi sqi_cr1: reserved4 (Bitfield-Mask: 0x07)          */
#define sqi_sqi_cr1_rx_fifo_clr_Pos       (28UL)                    /*!< sqi sqi_cr1: rx_fifo_clr (Bit 28)                     */
#define sqi_sqi_cr1_rx_fifo_clr_Msk       (0x10000000UL)            /*!< sqi sqi_cr1: rx_fifo_clr (Bitfield-Mask: 0x01)        */
#define sqi_sqi_cr1_rx_fifo_wm_Pos        (24UL)                    /*!< sqi sqi_cr1: rx_fifo_wm (Bit 24)                      */
#define sqi_sqi_cr1_rx_fifo_wm_Msk        (0xf000000UL)             /*!< sqi sqi_cr1: rx_fifo_wm (Bitfield-Mask: 0x0f)         */
#define sqi_sqi_cr1_reserved3_Pos         (21UL)                    /*!< sqi sqi_cr1: reserved3 (Bit 21)                       */
#define sqi_sqi_cr1_reserved3_Msk         (0xe00000UL)              /*!< sqi sqi_cr1: reserved3 (Bitfield-Mask: 0x07)          */
#define sqi_sqi_cr1_tx_fifo_clr_Pos       (20UL)                    /*!< sqi sqi_cr1: tx_fifo_clr (Bit 20)                     */
#define sqi_sqi_cr1_tx_fifo_clr_Msk       (0x100000UL)              /*!< sqi sqi_cr1: tx_fifo_clr (Bitfield-Mask: 0x01)        */
#define sqi_sqi_cr1_tx_fifo_wm_Pos        (16UL)                    /*!< sqi sqi_cr1: tx_fifo_wm (Bit 16)                      */
#define sqi_sqi_cr1_tx_fifo_wm_Msk        (0xf0000UL)               /*!< sqi sqi_cr1: tx_fifo_wm (Bitfield-Mask: 0x0f)         */
#define sqi_sqi_cr1_reserved2_Pos         (13UL)                    /*!< sqi sqi_cr1: reserved2 (Bit 13)                       */
#define sqi_sqi_cr1_reserved2_Msk         (0xe000UL)                /*!< sqi sqi_cr1: reserved2 (Bitfield-Mask: 0x07)          */
#define sqi_sqi_cr1_spi_trans_ctrl_Pos    (12UL)                    /*!< sqi sqi_cr1: spi_trans_ctrl (Bit 12)                  */
#define sqi_sqi_cr1_spi_trans_ctrl_Msk    (0x1000UL)                /*!< sqi sqi_cr1: spi_trans_ctrl (Bitfield-Mask: 0x01)     */
#define sqi_sqi_cr1_fss_static_Pos        (11UL)                    /*!< sqi sqi_cr1: fss_static (Bit 11)                      */
#define sqi_sqi_cr1_fss_static_Msk        (0x800UL)                 /*!< sqi sqi_cr1: fss_static (Bitfield-Mask: 0x01)         */
#define sqi_sqi_cr1_fss_Pos               (8UL)                     /*!< sqi sqi_cr1: fss (Bit 8)                              */
#define sqi_sqi_cr1_fss_Msk               (0x700UL)                 /*!< sqi sqi_cr1: fss (Bitfield-Mask: 0x07)                */
#define sqi_sqi_cr1_reserved1_Pos         (2UL)                     /*!< sqi sqi_cr1: reserved1 (Bit 2)                        */
#define sqi_sqi_cr1_reserved1_Msk         (0xfcUL)                  /*!< sqi sqi_cr1: reserved1 (Bitfield-Mask: 0x3f)          */
#define sqi_sqi_cr1_sqi_en_Pos            (1UL)                     /*!< sqi sqi_cr1: sqi_en (Bit 1)                           */
#define sqi_sqi_cr1_sqi_en_Msk            (0x2UL)                   /*!< sqi sqi_cr1: sqi_en (Bitfield-Mask: 0x01)             */
#define sqi_sqi_cr1_reserved0_Pos         (0UL)                     /*!< sqi sqi_cr1: reserved0 (Bit 0)                        */
#define sqi_sqi_cr1_reserved0_Msk         (0x1UL)                   /*!< sqi sqi_cr1: reserved0 (Bitfield-Mask: 0x01)          */
/* ========================================================  sqi_dr  ========================================================= */
#define sqi_sqi_dr_data_Pos               (0UL)                     /*!< sqi sqi_dr: data (Bit 0)                              */
#define sqi_sqi_dr_data_Msk               (0xffffffffUL)            /*!< sqi sqi_dr: data (Bitfield-Mask: 0xffffffff)          */
/* ========================================================  sqi_sr  ========================================================= */
#define sqi_sqi_sr_rx_fifo_err_undr_Pos   (31UL)                    /*!< sqi sqi_sr: rx_fifo_err_undr (Bit 31)                 */
#define sqi_sqi_sr_rx_fifo_err_undr_Msk   (0x80000000UL)            /*!< sqi sqi_sr: rx_fifo_err_undr (Bitfield-Mask: 0x01)    */
#define sqi_sqi_sr_rx_fifo_err_ovfl_Pos   (30UL)                    /*!< sqi sqi_sr: rx_fifo_err_ovfl (Bit 30)                 */
#define sqi_sqi_sr_rx_fifo_err_ovfl_Msk   (0x40000000UL)            /*!< sqi sqi_sr: rx_fifo_err_ovfl (Bitfield-Mask: 0x01)    */
#define sqi_sqi_sr_reserved2_Pos          (29UL)                    /*!< sqi sqi_sr: reserved2 (Bit 29)                        */
#define sqi_sqi_sr_reserved2_Msk          (0x20000000UL)            /*!< sqi sqi_sr: reserved2 (Bitfield-Mask: 0x01)           */
#define sqi_sqi_sr_rx_fifo_level_Pos      (24UL)                    /*!< sqi sqi_sr: rx_fifo_level (Bit 24)                    */
#define sqi_sqi_sr_rx_fifo_level_Msk      (0x1f000000UL)            /*!< sqi sqi_sr: rx_fifo_level (Bitfield-Mask: 0x1f)       */
#define sqi_sqi_sr_tx_fifo_err_undr_Pos   (23UL)                    /*!< sqi sqi_sr: tx_fifo_err_undr (Bit 23)                 */
#define sqi_sqi_sr_tx_fifo_err_undr_Msk   (0x800000UL)              /*!< sqi sqi_sr: tx_fifo_err_undr (Bitfield-Mask: 0x01)    */
#define sqi_sqi_sr_tx_fifo_err_ovfl_Pos   (22UL)                    /*!< sqi sqi_sr: tx_fifo_err_ovfl (Bit 22)                 */
#define sqi_sqi_sr_tx_fifo_err_ovfl_Msk   (0x400000UL)              /*!< sqi sqi_sr: tx_fifo_err_ovfl (Bitfield-Mask: 0x01)    */
#define sqi_sqi_sr_reserved1_Pos          (21UL)                    /*!< sqi sqi_sr: reserved1 (Bit 21)                        */
#define sqi_sqi_sr_reserved1_Msk          (0x200000UL)              /*!< sqi sqi_sr: reserved1 (Bitfield-Mask: 0x01)           */
#define sqi_sqi_sr_tx_fifo_level_Pos      (16UL)                    /*!< sqi sqi_sr: tx_fifo_level (Bit 16)                    */
#define sqi_sqi_sr_tx_fifo_level_Msk      (0x1f0000UL)              /*!< sqi sqi_sr: tx_fifo_level (Bitfield-Mask: 0x1f)       */
#define sqi_sqi_sr_sqirom_disabled_err_Pos (15UL)                   /*!< sqi sqi_sr: sqirom_disabled_err (Bit 15)              */
#define sqi_sqi_sr_sqirom_disabled_err_Msk (0x8000UL)               /*!< sqi sqi_sr: sqirom_disabled_err (Bitfield-Mask: 0x01) */
#define sqi_sqi_sr_sqirom_write_err_Pos   (14UL)                    /*!< sqi sqi_sr: sqirom_write_err (Bit 14)                 */
#define sqi_sqi_sr_sqirom_write_err_Msk   (0x4000UL)                /*!< sqi sqi_sr: sqirom_write_err (Bitfield-Mask: 0x01)    */
#define sqi_sqi_sr_sqirom_timeout_err_Pos (13UL)                    /*!< sqi sqi_sr: sqirom_timeout_err (Bit 13)               */
#define sqi_sqi_sr_sqirom_timeout_err_Msk (0x2000UL)                /*!< sqi sqi_sr: sqirom_timeout_err (Bitfield-Mask: 0x01)  */
#define sqi_sqi_sr_reserved0_Pos          (5UL)                     /*!< sqi sqi_sr: reserved0 (Bit 5)                         */
#define sqi_sqi_sr_reserved0_Msk          (0x1fe0UL)                /*!< sqi sqi_sr: reserved0 (Bitfield-Mask: 0xff)           */
#define sqi_sqi_sr_busy_Pos               (4UL)                     /*!< sqi sqi_sr: busy (Bit 4)                              */
#define sqi_sqi_sr_busy_Msk               (0x10UL)                  /*!< sqi sqi_sr: busy (Bitfield-Mask: 0x01)                */
#define sqi_sqi_sr_rx_fifo_full_Pos       (3UL)                     /*!< sqi sqi_sr: rx_fifo_full (Bit 3)                      */
#define sqi_sqi_sr_rx_fifo_full_Msk       (0x8UL)                   /*!< sqi sqi_sr: rx_fifo_full (Bitfield-Mask: 0x01)        */
#define sqi_sqi_sr_rx_fifo_not_empty_Pos  (2UL)                     /*!< sqi sqi_sr: rx_fifo_not_empty (Bit 2)                 */
#define sqi_sqi_sr_rx_fifo_not_empty_Msk  (0x4UL)                   /*!< sqi sqi_sr: rx_fifo_not_empty (Bitfield-Mask: 0x01)   */
#define sqi_sqi_sr_tx_fifo_not_full_Pos   (1UL)                     /*!< sqi sqi_sr: tx_fifo_not_full (Bit 1)                  */
#define sqi_sqi_sr_tx_fifo_not_full_Msk   (0x2UL)                   /*!< sqi sqi_sr: tx_fifo_not_full (Bitfield-Mask: 0x01)    */
#define sqi_sqi_sr_tx_fifo_empty_Pos      (0UL)                     /*!< sqi sqi_sr: tx_fifo_empty (Bit 0)                     */
#define sqi_sqi_sr_tx_fifo_empty_Msk      (0x1UL)                   /*!< sqi sqi_sr: tx_fifo_empty (Bitfield-Mask: 0x01)       */
/* ========================================================  sqi_tcr  ======================================================== */
#define sqi_sqi_tcr_reserved1_Pos         (30UL)                    /*!< sqi sqi_tcr: reserved1 (Bit 30)                       */
#define sqi_sqi_tcr_reserved1_Msk         (0xc0000000UL)            /*!< sqi sqi_tcr: reserved1 (Bitfield-Mask: 0x03)          */
#define sqi_sqi_tcr_ms_byte_first_Pos     (29UL)                    /*!< sqi sqi_tcr: ms_byte_first (Bit 29)                   */
#define sqi_sqi_tcr_ms_byte_first_Msk     (0x20000000UL)            /*!< sqi sqi_tcr: ms_byte_first (Bitfield-Mask: 0x01)      */
#define sqi_sqi_tcr_ms_bit_first_Pos      (28UL)                    /*!< sqi sqi_tcr: ms_bit_first (Bit 28)                    */
#define sqi_sqi_tcr_ms_bit_first_Msk      (0x10000000UL)            /*!< sqi sqi_tcr: ms_bit_first (Bitfield-Mask: 0x01)       */
#define sqi_sqi_tcr_duplex_Pos            (26UL)                    /*!< sqi sqi_tcr: duplex (Bit 26)                          */
#define sqi_sqi_tcr_duplex_Msk            (0xc000000UL)             /*!< sqi sqi_tcr: duplex (Bitfield-Mask: 0x03)             */
#define sqi_sqi_tcr_mode_Pos              (24UL)                    /*!< sqi sqi_tcr: mode (Bit 24)                            */
#define sqi_sqi_tcr_mode_Msk              (0x3000000UL)             /*!< sqi sqi_tcr: mode (Bitfield-Mask: 0x03)               */
#define sqi_sqi_tcr_start_transfer_Pos    (23UL)                    /*!< sqi sqi_tcr: start_transfer (Bit 23)                  */
#define sqi_sqi_tcr_start_transfer_Msk    (0x800000UL)              /*!< sqi sqi_tcr: start_transfer (Bitfield-Mask: 0x01)     */
#define sqi_sqi_tcr_tx_oe_Pos             (22UL)                    /*!< sqi sqi_tcr: tx_oe (Bit 22)                           */
#define sqi_sqi_tcr_tx_oe_Msk             (0x400000UL)              /*!< sqi sqi_tcr: tx_oe (Bitfield-Mask: 0x01)              */
#define sqi_sqi_tcr_tx_out_Pos            (21UL)                    /*!< sqi sqi_tcr: tx_out (Bit 21)                          */
#define sqi_sqi_tcr_tx_out_Msk            (0x200000UL)              /*!< sqi sqi_tcr: tx_out (Bitfield-Mask: 0x01)             */
#define sqi_sqi_tcr_reserved0_Pos         (19UL)                    /*!< sqi sqi_tcr: reserved0 (Bit 19)                       */
#define sqi_sqi_tcr_reserved0_Msk         (0x180000UL)              /*!< sqi sqi_tcr: reserved0 (Bitfield-Mask: 0x03)          */
#define sqi_sqi_tcr_transfer_size_Pos     (0UL)                     /*!< sqi sqi_tcr: transfer_size (Bit 0)                    */
#define sqi_sqi_tcr_transfer_size_Msk     (0x7ffffUL)               /*!< sqi sqi_tcr: transfer_size (Bitfield-Mask: 0x7ffff)   */
/* =====================================================  sqi_irq_mask  ====================================================== */
#define sqi_sqi_irq_mask_sqirom_error_Pos (8UL)                     /*!< sqi sqi_irq_mask: sqirom_error (Bit 8)                */
#define sqi_sqi_irq_mask_sqirom_error_Msk (0x100UL)                 /*!< sqi sqi_irq_mask: sqirom_error (Bitfield-Mask: 0x01)  */
#define sqi_sqi_irq_mask_trans_end_Pos    (7UL)                     /*!< sqi sqi_irq_mask: trans_end (Bit 7)                   */
#define sqi_sqi_irq_mask_trans_end_Msk    (0x80UL)                  /*!< sqi sqi_irq_mask: trans_end (Bitfield-Mask: 0x01)     */
#define sqi_sqi_irq_mask_txeim_Pos        (6UL)                     /*!< sqi sqi_irq_mask: txeim (Bit 6)                       */
#define sqi_sqi_irq_mask_txeim_Msk        (0x40UL)                  /*!< sqi sqi_irq_mask: txeim (Bitfield-Mask: 0x01)         */
#define sqi_sqi_irq_mask_rxfim_Pos        (5UL)                     /*!< sqi sqi_irq_mask: rxfim (Bit 5)                       */
#define sqi_sqi_irq_mask_rxfim_Msk        (0x20UL)                  /*!< sqi sqi_irq_mask: rxfim (Bitfield-Mask: 0x01)         */
#define sqi_sqi_irq_mask_rxneim_Pos       (4UL)                     /*!< sqi sqi_irq_mask: rxneim (Bit 4)                      */
#define sqi_sqi_irq_mask_rxneim_Msk       (0x10UL)                  /*!< sqi sqi_irq_mask: rxneim (Bitfield-Mask: 0x01)        */
#define sqi_sqi_irq_mask_TXIM_Pos         (3UL)                     /*!< sqi sqi_irq_mask: TXIM (Bit 3)                        */
#define sqi_sqi_irq_mask_TXIM_Msk         (0x8UL)                   /*!< sqi sqi_irq_mask: TXIM (Bitfield-Mask: 0x01)          */
#define sqi_sqi_irq_mask_RXIM_Pos         (2UL)                     /*!< sqi sqi_irq_mask: RXIM (Bit 2)                        */
#define sqi_sqi_irq_mask_RXIM_Msk         (0x4UL)                   /*!< sqi sqi_irq_mask: RXIM (Bitfield-Mask: 0x01)          */
#define sqi_sqi_irq_mask_RTIM_Pos         (1UL)                     /*!< sqi sqi_irq_mask: RTIM (Bit 1)                        */
#define sqi_sqi_irq_mask_RTIM_Msk         (0x2UL)                   /*!< sqi sqi_irq_mask: RTIM (Bitfield-Mask: 0x01)          */
#define sqi_sqi_irq_mask_RORIM_Pos        (0UL)                     /*!< sqi sqi_irq_mask: RORIM (Bit 0)                       */
#define sqi_sqi_irq_mask_RORIM_Msk        (0x1UL)                   /*!< sqi sqi_irq_mask: RORIM (Bitfield-Mask: 0x01)         */
/* ======================================================  sqi_irq_raw  ====================================================== */
#define sqi_sqi_irq_raw_sqirom_error_Pos  (8UL)                     /*!< sqi sqi_irq_raw: sqirom_error (Bit 8)                 */
#define sqi_sqi_irq_raw_sqirom_error_Msk  (0x100UL)                 /*!< sqi sqi_irq_raw: sqirom_error (Bitfield-Mask: 0x01)   */
#define sqi_sqi_irq_raw_trans_end_Pos     (7UL)                     /*!< sqi sqi_irq_raw: trans_end (Bit 7)                    */
#define sqi_sqi_irq_raw_trans_end_Msk     (0x80UL)                  /*!< sqi sqi_irq_raw: trans_end (Bitfield-Mask: 0x01)      */
#define sqi_sqi_irq_raw_txeris_Pos        (6UL)                     /*!< sqi sqi_irq_raw: txeris (Bit 6)                       */
#define sqi_sqi_irq_raw_txeris_Msk        (0x40UL)                  /*!< sqi sqi_irq_raw: txeris (Bitfield-Mask: 0x01)         */
#define sqi_sqi_irq_raw_rxfris_Pos        (5UL)                     /*!< sqi sqi_irq_raw: rxfris (Bit 5)                       */
#define sqi_sqi_irq_raw_rxfris_Msk        (0x20UL)                  /*!< sqi sqi_irq_raw: rxfris (Bitfield-Mask: 0x01)         */
#define sqi_sqi_irq_raw_rxneris_Pos       (4UL)                     /*!< sqi sqi_irq_raw: rxneris (Bit 4)                      */
#define sqi_sqi_irq_raw_rxneris_Msk       (0x10UL)                  /*!< sqi sqi_irq_raw: rxneris (Bitfield-Mask: 0x01)        */
#define sqi_sqi_irq_raw_TXRIS_Pos         (3UL)                     /*!< sqi sqi_irq_raw: TXRIS (Bit 3)                        */
#define sqi_sqi_irq_raw_TXRIS_Msk         (0x8UL)                   /*!< sqi sqi_irq_raw: TXRIS (Bitfield-Mask: 0x01)          */
#define sqi_sqi_irq_raw_RXRIS_Pos         (2UL)                     /*!< sqi sqi_irq_raw: RXRIS (Bit 2)                        */
#define sqi_sqi_irq_raw_RXRIS_Msk         (0x4UL)                   /*!< sqi sqi_irq_raw: RXRIS (Bitfield-Mask: 0x01)          */
#define sqi_sqi_irq_raw_RTRIS_Pos         (1UL)                     /*!< sqi sqi_irq_raw: RTRIS (Bit 1)                        */
#define sqi_sqi_irq_raw_RTRIS_Msk         (0x2UL)                   /*!< sqi sqi_irq_raw: RTRIS (Bitfield-Mask: 0x01)          */
#define sqi_sqi_irq_raw_RORRIS_Pos        (0UL)                     /*!< sqi sqi_irq_raw: RORRIS (Bit 0)                       */
#define sqi_sqi_irq_raw_RORRIS_Msk        (0x1UL)                   /*!< sqi sqi_irq_raw: RORRIS (Bitfield-Mask: 0x01)         */
/* ====================================================  sqi_irq_masked  ===================================================== */
#define sqi_sqi_irq_masked_sqirom_error_Pos (8UL)                   /*!< sqi sqi_irq_masked: sqirom_error (Bit 8)              */
#define sqi_sqi_irq_masked_sqirom_error_Msk (0x100UL)               /*!< sqi sqi_irq_masked: sqirom_error (Bitfield-Mask: 0x01) */
#define sqi_sqi_irq_masked_trans_end_Pos  (7UL)                     /*!< sqi sqi_irq_masked: trans_end (Bit 7)                 */
#define sqi_sqi_irq_masked_trans_end_Msk  (0x80UL)                  /*!< sqi sqi_irq_masked: trans_end (Bitfield-Mask: 0x01)   */
#define sqi_sqi_irq_masked_txemis_Pos     (6UL)                     /*!< sqi sqi_irq_masked: txemis (Bit 6)                    */
#define sqi_sqi_irq_masked_txemis_Msk     (0x40UL)                  /*!< sqi sqi_irq_masked: txemis (Bitfield-Mask: 0x01)      */
#define sqi_sqi_irq_masked_rxfmis_Pos     (5UL)                     /*!< sqi sqi_irq_masked: rxfmis (Bit 5)                    */
#define sqi_sqi_irq_masked_rxfmis_Msk     (0x20UL)                  /*!< sqi sqi_irq_masked: rxfmis (Bitfield-Mask: 0x01)      */
#define sqi_sqi_irq_masked_rxnemis_Pos    (4UL)                     /*!< sqi sqi_irq_masked: rxnemis (Bit 4)                   */
#define sqi_sqi_irq_masked_rxnemis_Msk    (0x10UL)                  /*!< sqi sqi_irq_masked: rxnemis (Bitfield-Mask: 0x01)     */
#define sqi_sqi_irq_masked_TXMIS_Pos      (3UL)                     /*!< sqi sqi_irq_masked: TXMIS (Bit 3)                     */
#define sqi_sqi_irq_masked_TXMIS_Msk      (0x8UL)                   /*!< sqi sqi_irq_masked: TXMIS (Bitfield-Mask: 0x01)       */
#define sqi_sqi_irq_masked_RXMIS_Pos      (2UL)                     /*!< sqi sqi_irq_masked: RXMIS (Bit 2)                     */
#define sqi_sqi_irq_masked_RXMIS_Msk      (0x4UL)                   /*!< sqi sqi_irq_masked: RXMIS (Bitfield-Mask: 0x01)       */
#define sqi_sqi_irq_masked_RTMIS_Pos      (1UL)                     /*!< sqi sqi_irq_masked: RTMIS (Bit 1)                     */
#define sqi_sqi_irq_masked_RTMIS_Msk      (0x2UL)                   /*!< sqi sqi_irq_masked: RTMIS (Bitfield-Mask: 0x01)       */
#define sqi_sqi_irq_masked_RORMIS_Pos     (0UL)                     /*!< sqi sqi_irq_masked: RORMIS (Bit 0)                    */
#define sqi_sqi_irq_masked_RORMIS_Msk     (0x1UL)                   /*!< sqi sqi_irq_masked: RORMIS (Bitfield-Mask: 0x01)      */
/* =====================================================  sqi_irq_clear  ===================================================== */
#define sqi_sqi_irq_clear_sqirom_error_Pos (8UL)                    /*!< sqi sqi_irq_clear: sqirom_error (Bit 8)               */
#define sqi_sqi_irq_clear_sqirom_error_Msk (0x100UL)                /*!< sqi sqi_irq_clear: sqirom_error (Bitfield-Mask: 0x01) */
#define sqi_sqi_irq_clear_trans_end_Pos   (7UL)                     /*!< sqi sqi_irq_clear: trans_end (Bit 7)                  */
#define sqi_sqi_irq_clear_trans_end_Msk   (0x80UL)                  /*!< sqi sqi_irq_clear: trans_end (Bitfield-Mask: 0x01)    */
#define sqi_sqi_irq_clear_txeic_Pos       (6UL)                     /*!< sqi sqi_irq_clear: txeic (Bit 6)                      */
#define sqi_sqi_irq_clear_txeic_Msk       (0x40UL)                  /*!< sqi sqi_irq_clear: txeic (Bitfield-Mask: 0x01)        */
#define sqi_sqi_irq_clear_rxfic_Pos       (5UL)                     /*!< sqi sqi_irq_clear: rxfic (Bit 5)                      */
#define sqi_sqi_irq_clear_rxfic_Msk       (0x20UL)                  /*!< sqi sqi_irq_clear: rxfic (Bitfield-Mask: 0x01)        */
#define sqi_sqi_irq_clear_rxneic_Pos      (4UL)                     /*!< sqi sqi_irq_clear: rxneic (Bit 4)                     */
#define sqi_sqi_irq_clear_rxneic_Msk      (0x10UL)                  /*!< sqi sqi_irq_clear: rxneic (Bitfield-Mask: 0x01)       */
#define sqi_sqi_irq_clear_TXIC_Pos        (3UL)                     /*!< sqi sqi_irq_clear: TXIC (Bit 3)                       */
#define sqi_sqi_irq_clear_TXIC_Msk        (0x8UL)                   /*!< sqi sqi_irq_clear: TXIC (Bitfield-Mask: 0x01)         */
#define sqi_sqi_irq_clear_RXIC_Pos        (2UL)                     /*!< sqi sqi_irq_clear: RXIC (Bit 2)                       */
#define sqi_sqi_irq_clear_RXIC_Msk        (0x4UL)                   /*!< sqi sqi_irq_clear: RXIC (Bitfield-Mask: 0x01)         */
#define sqi_sqi_irq_clear_RTIC_Pos        (1UL)                     /*!< sqi sqi_irq_clear: RTIC (Bit 1)                       */
#define sqi_sqi_irq_clear_RTIC_Msk        (0x2UL)                   /*!< sqi sqi_irq_clear: RTIC (Bitfield-Mask: 0x01)         */
#define sqi_sqi_irq_clear_RORIC_Pos       (0UL)                     /*!< sqi sqi_irq_clear: RORIC (Bit 0)                      */
#define sqi_sqi_irq_clear_RORIC_Msk       (0x1UL)                   /*!< sqi sqi_irq_clear: RORIC (Bitfield-Mask: 0x01)        */
/* =======================================================  sqi_dmacr  ======================================================= */
#define sqi_sqi_dmacr_tx_dma_en_Pos       (1UL)                     /*!< sqi sqi_dmacr: tx_dma_en (Bit 1)                      */
#define sqi_sqi_dmacr_tx_dma_en_Msk       (0x2UL)                   /*!< sqi sqi_dmacr: tx_dma_en (Bitfield-Mask: 0x01)        */
#define sqi_sqi_dmacr_rx_dma_en_Pos       (0UL)                     /*!< sqi sqi_dmacr: rx_dma_en (Bit 0)                      */
#define sqi_sqi_dmacr_rx_dma_en_Msk       (0x1UL)                   /*!< sqi sqi_dmacr: rx_dma_en (Bitfield-Mask: 0x01)        */
/* ======================================================  sqi_pio_out  ====================================================== */
#define sqi_sqi_pio_out_sio3_Pos          (7UL)                     /*!< sqi sqi_pio_out: sio3 (Bit 7)                         */
#define sqi_sqi_pio_out_sio3_Msk          (0x80UL)                  /*!< sqi sqi_pio_out: sio3 (Bitfield-Mask: 0x01)           */
#define sqi_sqi_pio_out_sio2_Pos          (6UL)                     /*!< sqi sqi_pio_out: sio2 (Bit 6)                         */
#define sqi_sqi_pio_out_sio2_Msk          (0x40UL)                  /*!< sqi sqi_pio_out: sio2 (Bitfield-Mask: 0x01)           */
#define sqi_sqi_pio_out_miso_Pos          (5UL)                     /*!< sqi sqi_pio_out: miso (Bit 5)                         */
#define sqi_sqi_pio_out_miso_Msk          (0x20UL)                  /*!< sqi sqi_pio_out: miso (Bitfield-Mask: 0x01)           */
#define sqi_sqi_pio_out_mosi_Pos          (4UL)                     /*!< sqi sqi_pio_out: mosi (Bit 4)                         */
#define sqi_sqi_pio_out_mosi_Msk          (0x10UL)                  /*!< sqi sqi_pio_out: mosi (Bitfield-Mask: 0x01)           */
#define sqi_sqi_pio_out_csn_Pos           (1UL)                     /*!< sqi sqi_pio_out: csn (Bit 1)                          */
#define sqi_sqi_pio_out_csn_Msk           (0xeUL)                   /*!< sqi sqi_pio_out: csn (Bitfield-Mask: 0x07)            */
#define sqi_sqi_pio_out_sclk_Pos          (0UL)                     /*!< sqi sqi_pio_out: sclk (Bit 0)                         */
#define sqi_sqi_pio_out_sclk_Msk          (0x1UL)                   /*!< sqi sqi_pio_out: sclk (Bitfield-Mask: 0x01)           */
/* ======================================================  sqi_pio_oe  ======================================================= */
#define sqi_sqi_pio_oe_sio3_Pos           (7UL)                     /*!< sqi sqi_pio_oe: sio3 (Bit 7)                          */
#define sqi_sqi_pio_oe_sio3_Msk           (0x80UL)                  /*!< sqi sqi_pio_oe: sio3 (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_oe_sio2_Pos           (6UL)                     /*!< sqi sqi_pio_oe: sio2 (Bit 6)                          */
#define sqi_sqi_pio_oe_sio2_Msk           (0x40UL)                  /*!< sqi sqi_pio_oe: sio2 (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_oe_miso_Pos           (5UL)                     /*!< sqi sqi_pio_oe: miso (Bit 5)                          */
#define sqi_sqi_pio_oe_miso_Msk           (0x20UL)                  /*!< sqi sqi_pio_oe: miso (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_oe_mosi_Pos           (4UL)                     /*!< sqi sqi_pio_oe: mosi (Bit 4)                          */
#define sqi_sqi_pio_oe_mosi_Msk           (0x10UL)                  /*!< sqi sqi_pio_oe: mosi (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_oe_csn_Pos            (1UL)                     /*!< sqi sqi_pio_oe: csn (Bit 1)                           */
#define sqi_sqi_pio_oe_csn_Msk            (0xeUL)                   /*!< sqi sqi_pio_oe: csn (Bitfield-Mask: 0x07)             */
#define sqi_sqi_pio_oe_sclk_Pos           (0UL)                     /*!< sqi sqi_pio_oe: sclk (Bit 0)                          */
#define sqi_sqi_pio_oe_sclk_Msk           (0x1UL)                   /*!< sqi sqi_pio_oe: sclk (Bitfield-Mask: 0x01)            */
/* ======================================================  sqi_pio_in  ======================================================= */
#define sqi_sqi_pio_in_sio3_Pos           (7UL)                     /*!< sqi sqi_pio_in: sio3 (Bit 7)                          */
#define sqi_sqi_pio_in_sio3_Msk           (0x80UL)                  /*!< sqi sqi_pio_in: sio3 (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_in_sio2_Pos           (6UL)                     /*!< sqi sqi_pio_in: sio2 (Bit 6)                          */
#define sqi_sqi_pio_in_sio2_Msk           (0x40UL)                  /*!< sqi sqi_pio_in: sio2 (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_in_miso_Pos           (5UL)                     /*!< sqi sqi_pio_in: miso (Bit 5)                          */
#define sqi_sqi_pio_in_miso_Msk           (0x20UL)                  /*!< sqi sqi_pio_in: miso (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_in_mosi_Pos           (4UL)                     /*!< sqi sqi_pio_in: mosi (Bit 4)                          */
#define sqi_sqi_pio_in_mosi_Msk           (0x10UL)                  /*!< sqi sqi_pio_in: mosi (Bitfield-Mask: 0x01)            */
#define sqi_sqi_pio_in_csn_Pos            (1UL)                     /*!< sqi sqi_pio_in: csn (Bit 1)                           */
#define sqi_sqi_pio_in_csn_Msk            (0xeUL)                   /*!< sqi sqi_pio_in: csn (Bitfield-Mask: 0x07)             */
#define sqi_sqi_pio_in_sclk_Pos           (0UL)                     /*!< sqi sqi_pio_in: sclk (Bit 0)                          */
#define sqi_sqi_pio_in_sclk_Msk           (0x1UL)                   /*!< sqi sqi_pio_in: sclk (Bitfield-Mask: 0x01)            */
/* ====================================================  sqi_sqirom_cfg  ===================================================== */
#define sqi_sqi_sqirom_cfg_clk_div_val_Pos (24UL)                   /*!< sqi sqi_sqirom_cfg: clk_div_val (Bit 24)              */
#define sqi_sqi_sqirom_cfg_clk_div_val_Msk (0xff000000UL)           /*!< sqi sqi_sqirom_cfg: clk_div_val (Bitfield-Mask: 0xff) */
#define sqi_sqi_sqirom_cfg_reserved1_Pos  (22UL)                    /*!< sqi sqi_sqirom_cfg: reserved1 (Bit 22)                */
#define sqi_sqi_sqirom_cfg_reserved1_Msk  (0xc00000UL)              /*!< sqi sqi_sqirom_cfg: reserved1 (Bitfield-Mask: 0x03)   */
#define sqi_sqi_sqirom_cfg_t_csh_Pos      (20UL)                    /*!< sqi sqi_sqirom_cfg: t_csh (Bit 20)                    */
#define sqi_sqi_sqirom_cfg_t_csh_Msk      (0x300000UL)              /*!< sqi sqi_sqirom_cfg: t_csh (Bitfield-Mask: 0x03)       */
#define sqi_sqi_sqirom_cfg_dummy_cycles_Pos (16UL)                  /*!< sqi sqi_sqirom_cfg: dummy_cycles (Bit 16)             */
#define sqi_sqi_sqirom_cfg_dummy_cycles_Msk (0xf0000UL)             /*!< sqi sqi_sqirom_cfg: dummy_cycles (Bitfield-Mask: 0x0f) */
#define sqi_sqi_sqirom_cfg_cmd_byte_Pos   (8UL)                     /*!< sqi sqi_sqirom_cfg: cmd_byte (Bit 8)                  */
#define sqi_sqi_sqirom_cfg_cmd_byte_Msk   (0xff00UL)                /*!< sqi sqi_sqirom_cfg: cmd_byte (Bitfield-Mask: 0xff)    */
#define sqi_sqi_sqirom_cfg_reserved0_Pos  (7UL)                     /*!< sqi sqi_sqirom_cfg: reserved0 (Bit 7)                 */
#define sqi_sqi_sqirom_cfg_reserved0_Msk  (0x80UL)                  /*!< sqi sqi_sqirom_cfg: reserved0 (Bitfield-Mask: 0x01)   */
#define sqi_sqi_sqirom_cfg_addr_bits_Pos  (4UL)                     /*!< sqi sqi_sqirom_cfg: addr_bits (Bit 4)                 */
#define sqi_sqi_sqirom_cfg_addr_bits_Msk  (0x70UL)                  /*!< sqi sqi_sqirom_cfg: addr_bits (Bitfield-Mask: 0x07)   */
#define sqi_sqi_sqirom_cfg_addr_nibbles_Pos (2UL)                   /*!< sqi sqi_sqirom_cfg: addr_nibbles (Bit 2)              */
#define sqi_sqi_sqirom_cfg_addr_nibbles_Msk (0xcUL)                 /*!< sqi sqi_sqirom_cfg: addr_nibbles (Bitfield-Mask: 0x03) */
#define sqi_sqi_sqirom_cfg_addr_before_cmd_Pos (1UL)                /*!< sqi sqi_sqirom_cfg: addr_before_cmd (Bit 1)           */
#define sqi_sqi_sqirom_cfg_addr_before_cmd_Msk (0x2UL)              /*!< sqi sqi_sqirom_cfg: addr_before_cmd (Bitfield-Mask: 0x01) */
#define sqi_sqi_sqirom_cfg_enable_Pos     (0UL)                     /*!< sqi sqi_sqirom_cfg: enable (Bit 0)                    */
#define sqi_sqi_sqirom_cfg_enable_Msk     (0x1UL)                   /*!< sqi sqi_sqirom_cfg: enable (Bitfield-Mask: 0x01)      */


/* =========================================================================================================================== */
/* ================                                    sample_at_porn_stat                                    ================ */
/* =========================================================================================================================== */

/* ================================================  sample_at_porn_stat_in0  ================================================ */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a15_Pos (31UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a15 (Bit 31) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a15_Msk (0x80000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a15 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a14_Pos (30UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a14 (Bit 30) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a14_Msk (0x40000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a14 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a13_Pos (29UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a13 (Bit 29) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a13_Msk (0x20000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a13 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a12_Pos (28UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a12 (Bit 28) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a12_Msk (0x10000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a12 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a11_Pos (27UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a11 (Bit 27) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a11_Msk (0x8000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a11 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a10_Pos (26UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a10 (Bit 26) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a10_Msk (0x4000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a10 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a9_Pos (25UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a9 (Bit 25) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a9_Msk (0x2000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a9 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a8_Pos (24UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a8 (Bit 24) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a8_Msk (0x1000000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a8 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a7_Pos (23UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a7 (Bit 23) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a7_Msk (0x800000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a7 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a6_Pos (22UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a6 (Bit 22) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a6_Msk (0x400000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a6 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a5_Pos (21UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a5 (Bit 21) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a5_Msk (0x200000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a5 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a4_Pos (20UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a4 (Bit 20) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a4_Msk (0x100000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a4 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a3_Pos (19UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a3 (Bit 19) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a3_Msk (0x80000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a3 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a2_Pos (18UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a2 (Bit 18) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a2_Msk (0x40000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a2 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a1_Pos (17UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a1 (Bit 17) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a1_Msk (0x20000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a1 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a0_Pos (16UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a0 (Bit 16) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_a0_Msk (0x10000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_a0 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d15_Pos (15UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d15 (Bit 15) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d15_Msk (0x8000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d15 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d14_Pos (14UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d14 (Bit 14) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d14_Msk (0x4000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d14 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d13_Pos (13UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d13 (Bit 13) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d13_Msk (0x2000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d13 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d12_Pos (12UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d12 (Bit 12) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d12_Msk (0x1000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d12 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d11_Pos (11UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d11 (Bit 11) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d11_Msk (0x800UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d11 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d10_Pos (10UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d10 (Bit 10) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d10_Msk (0x400UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d10 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d9_Pos (9UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d9 (Bit 9) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d9_Msk (0x200UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d9 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d8_Pos (8UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d8 (Bit 8) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d8_Msk (0x100UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d8 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d7_Pos (7UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d7 (Bit 7) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d7_Msk (0x80UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d7 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d6_Pos (6UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d6 (Bit 6) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d6_Msk (0x40UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d6 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d5_Pos (5UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d5 (Bit 5) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d5_Msk (0x20UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d5 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d4_Pos (4UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d4 (Bit 4) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d4_Msk (0x10UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d4 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d3_Pos (3UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d3 (Bit 3) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d3_Msk (0x8UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d3 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d2_Pos (2UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d2 (Bit 2) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d2_Msk (0x4UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d2 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d1_Pos (1UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d1 (Bit 1) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d1_Msk (0x2UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d1 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d0_Pos (0UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d0 (Bit 0) */
#define sample_at_porn_stat_sample_at_porn_stat_in0_hif_d0_Msk (0x1UL) /*!< sample_at_porn_stat sample_at_porn_stat_in0: hif_d0 (Bitfield-Mask: 0x01) */
/* ================================================  sample_at_porn_stat_in1  ================================================ */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_sio3_Pos (16UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_sio3 (Bit 16) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_sio3_Msk (0x10000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_sio3 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_sio2_Pos (15UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_sio2 (Bit 15) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_sio2_Msk (0x8000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_sio2 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_miso_Pos (14UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_miso (Bit 14) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_miso_Msk (0x4000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_miso (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_mosi_Pos (13UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_mosi (Bit 13) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_mosi_Msk (0x2000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_mosi (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_cs0n_Pos (12UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_cs0n (Bit 12) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_cs0n_Msk (0x1000UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_cs0n (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_clk_Pos (11UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_clk (Bit 11) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_sqi_clk_Msk (0x800UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: sqi_clk (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_run_n_Pos (10UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: run_n (Bit 10) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_run_n_Msk (0x400UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: run_n (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_rdy_n_Pos (9UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: rdy_n (Bit 9) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_rdy_n_Msk (0x200UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: rdy_n (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_sdclk_Pos (8UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_sdclk (Bit 8) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_sdclk_Msk (0x100UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_sdclk (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_dirq_Pos (7UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_dirq (Bit 7) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_dirq_Msk (0x80UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_dirq (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_rdy_Pos (6UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_rdy (Bit 6) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_rdy_Msk (0x40UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_rdy (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_csn_Pos (5UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_csn (Bit 5) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_csn_Msk (0x20UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_csn (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_wrn_Pos (4UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_wrn (Bit 4) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_wrn_Msk (0x10UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_wrn (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_rdn_Pos (3UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_rdn (Bit 3) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_rdn_Msk (0x8UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_rdn (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_bhen_Pos (2UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_bhen (Bit 2) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_bhen_Msk (0x4UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_bhen (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_a17_Pos (1UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_a17 (Bit 1) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_a17_Msk (0x2UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_a17 (Bitfield-Mask: 0x01) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_a16_Pos (0UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_a16 (Bit 0) */
#define sample_at_porn_stat_sample_at_porn_stat_in1_hif_a16_Msk (0x1UL) /*!< sample_at_porn_stat sample_at_porn_stat_in1: hif_a16 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                          adc_seq                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  adc_seq_start  ===================================================== */
#define adc_seq_adc_seq_start_reserved1_Pos (26UL)                  /*!< adc_seq adc_seq_start: reserved1 (Bit 26)             */
#define adc_seq_adc_seq_start_reserved1_Msk (0xfc000000UL)          /*!< adc_seq adc_seq_start: reserved1 (Bitfield-Mask: 0x3f) */
#define adc_seq_adc_seq_start_tt_add_adc1_Pos (20UL)                /*!< adc_seq adc_seq_start: tt_add_adc1 (Bit 20)           */
#define adc_seq_adc_seq_start_tt_add_adc1_Msk (0x3f00000UL)         /*!< adc_seq adc_seq_start: tt_add_adc1 (Bitfield-Mask: 0x3f) */
#define adc_seq_adc_seq_start_ref_adc1_Pos (19UL)                   /*!< adc_seq adc_seq_start: ref_adc1 (Bit 19)              */
#define adc_seq_adc_seq_start_ref_adc1_Msk (0x80000UL)              /*!< adc_seq adc_seq_start: ref_adc1 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_start_sel_adc1_Pos (17UL)                   /*!< adc_seq adc_seq_start: sel_adc1 (Bit 17)              */
#define adc_seq_adc_seq_start_sel_adc1_Msk (0x60000UL)              /*!< adc_seq adc_seq_start: sel_adc1 (Bitfield-Mask: 0x03) */
#define adc_seq_adc_seq_start_start_adc1_Pos (16UL)                 /*!< adc_seq adc_seq_start: start_adc1 (Bit 16)            */
#define adc_seq_adc_seq_start_start_adc1_Msk (0x10000UL)            /*!< adc_seq adc_seq_start: start_adc1 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_start_reserved0_Pos (10UL)                  /*!< adc_seq adc_seq_start: reserved0 (Bit 10)             */
#define adc_seq_adc_seq_start_reserved0_Msk (0xfc00UL)              /*!< adc_seq adc_seq_start: reserved0 (Bitfield-Mask: 0x3f) */
#define adc_seq_adc_seq_start_tt_add_adc0_Pos (4UL)                 /*!< adc_seq adc_seq_start: tt_add_adc0 (Bit 4)            */
#define adc_seq_adc_seq_start_tt_add_adc0_Msk (0x3f0UL)             /*!< adc_seq adc_seq_start: tt_add_adc0 (Bitfield-Mask: 0x3f) */
#define adc_seq_adc_seq_start_ref_adc0_Pos (3UL)                    /*!< adc_seq adc_seq_start: ref_adc0 (Bit 3)               */
#define adc_seq_adc_seq_start_ref_adc0_Msk (0x8UL)                  /*!< adc_seq adc_seq_start: ref_adc0 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_start_sel_adc0_Pos (1UL)                    /*!< adc_seq adc_seq_start: sel_adc0 (Bit 1)               */
#define adc_seq_adc_seq_start_sel_adc0_Msk (0x6UL)                  /*!< adc_seq adc_seq_start: sel_adc0 (Bitfield-Mask: 0x03) */
#define adc_seq_adc_seq_start_start_adc0_Pos (0UL)                  /*!< adc_seq adc_seq_start: start_adc0 (Bit 0)             */
#define adc_seq_adc_seq_start_start_adc0_Msk (0x1UL)                /*!< adc_seq adc_seq_start: start_adc0 (Bitfield-Mask: 0x01) */
/* ======================================================  adc_seq_cfg  ====================================================== */
#define adc_seq_adc_seq_cfg_sync_sample_start_if_restart_both_Pos (4UL) /*!< adc_seq adc_seq_cfg: sync_sample_start_if_restart_both (Bit 4) */
#define adc_seq_adc_seq_cfg_sync_sample_start_if_restart_both_Msk (0x10UL) /*!< adc_seq adc_seq_cfg: sync_sample_start_if_restart_both (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_cfg_debug_Pos     (3UL)                     /*!< adc_seq adc_seq_cfg: debug (Bit 3)                    */
#define adc_seq_adc_seq_cfg_debug_Msk     (0x8UL)                   /*!< adc_seq adc_seq_cfg: debug (Bitfield-Mask: 0x01)      */
#define adc_seq_adc_seq_cfg_buffer_enable_Pos (2UL)                 /*!< adc_seq adc_seq_cfg: buffer_enable (Bit 2)            */
#define adc_seq_adc_seq_cfg_buffer_enable_Msk (0x4UL)               /*!< adc_seq adc_seq_cfg: buffer_enable (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_cfg_reset_n_Pos   (1UL)                     /*!< adc_seq adc_seq_cfg: reset_n (Bit 1)                  */
#define adc_seq_adc_seq_cfg_reset_n_Msk   (0x2UL)                   /*!< adc_seq adc_seq_cfg: reset_n (Bitfield-Mask: 0x01)    */
#define adc_seq_adc_seq_cfg_enable_Pos    (0UL)                     /*!< adc_seq adc_seq_cfg: enable (Bit 0)                   */
#define adc_seq_adc_seq_cfg_enable_Msk    (0x1UL)                   /*!< adc_seq adc_seq_cfg: enable (Bitfield-Mask: 0x01)     */
/* ===================================================  adc_seq_cfg_clock  =================================================== */
#define adc_seq_adc_seq_cfg_clock_adc1_shift_Pos (3UL)              /*!< adc_seq adc_seq_cfg_clock: adc1_shift (Bit 3)         */
#define adc_seq_adc_seq_cfg_clock_adc1_shift_Msk (0x38UL)           /*!< adc_seq adc_seq_cfg_clock: adc1_shift (Bitfield-Mask: 0x07) */
#define adc_seq_adc_seq_cfg_clock_period_Pos (0UL)                  /*!< adc_seq adc_seq_cfg_clock: period (Bit 0)             */
#define adc_seq_adc_seq_cfg_clock_period_Msk (0x7UL)                /*!< adc_seq adc_seq_cfg_clock: period (Bitfield-Mask: 0x07) */
/* ====================================================  adc_seq_status  ===================================================== */
#define adc_seq_adc_seq_status_adc_clock_running_Pos (6UL)          /*!< adc_seq adc_seq_status: adc_clock_running (Bit 6)     */
#define adc_seq_adc_seq_status_adc_clock_running_Msk (0x40UL)       /*!< adc_seq adc_seq_status: adc_clock_running (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_status_adc1_data_Pos (5UL)                  /*!< adc_seq adc_seq_status: adc1_data (Bit 5)             */
#define adc_seq_adc_seq_status_adc1_data_Msk (0x20UL)               /*!< adc_seq adc_seq_status: adc1_data (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_status_adc0_data_Pos (4UL)                  /*!< adc_seq adc_seq_status: adc0_data (Bit 4)             */
#define adc_seq_adc_seq_status_adc0_data_Msk (0x10UL)               /*!< adc_seq adc_seq_status: adc0_data (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_status_adc1_running_Pos (3UL)               /*!< adc_seq adc_seq_status: adc1_running (Bit 3)          */
#define adc_seq_adc_seq_status_adc1_running_Msk (0x8UL)             /*!< adc_seq adc_seq_status: adc1_running (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_status_adc0_running_Pos (2UL)               /*!< adc_seq adc_seq_status: adc0_running (Bit 2)          */
#define adc_seq_adc_seq_status_adc0_running_Msk (0x4UL)             /*!< adc_seq adc_seq_status: adc0_running (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_status_adc1_sample_Pos (1UL)                /*!< adc_seq adc_seq_status: adc1_sample (Bit 1)           */
#define adc_seq_adc_seq_status_adc1_sample_Msk (0x2UL)              /*!< adc_seq adc_seq_status: adc1_sample (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_status_adc0_sample_Pos (0UL)                /*!< adc_seq adc_seq_status: adc0_sample (Bit 0)           */
#define adc_seq_adc_seq_status_adc0_sample_Msk (0x1UL)              /*!< adc_seq adc_seq_status: adc0_sample (Bitfield-Mask: 0x01) */
/* ===================================================  adc_seq_adc_data0  =================================================== */
#define adc_seq_adc_seq_adc_data0_val_Pos (0UL)                     /*!< adc_seq adc_seq_adc_data0: val (Bit 0)                */
#define adc_seq_adc_seq_adc_data0_val_Msk (0xfffUL)                 /*!< adc_seq adc_seq_adc_data0: val (Bitfield-Mask: 0xfff) */
/* ===================================================  adc_seq_adc_data1  =================================================== */
#define adc_seq_adc_seq_adc_data1_val_Pos (0UL)                     /*!< adc_seq adc_seq_adc_data1: val (Bit 0)                */
#define adc_seq_adc_seq_adc_data1_val_Msk (0xfffUL)                 /*!< adc_seq adc_seq_adc_data1: val (Bitfield-Mask: 0xfff) */
/* =====================================================  adc_seq_debug  ===================================================== */
#define adc_seq_adc_seq_debug_reserved1_Pos (15UL)                  /*!< adc_seq adc_seq_debug: reserved1 (Bit 15)             */
#define adc_seq_adc_seq_debug_reserved1_Msk (0xffff8000UL)          /*!< adc_seq adc_seq_debug: reserved1 (Bitfield-Mask: 0x1ffff) */
#define adc_seq_adc_seq_debug_adc1_set_mux3_Pos (14UL)              /*!< adc_seq adc_seq_debug: adc1_set_mux3 (Bit 14)         */
#define adc_seq_adc_seq_debug_adc1_set_mux3_Msk (0x4000UL)          /*!< adc_seq adc_seq_debug: adc1_set_mux3 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc1_set_mux2_Pos (13UL)              /*!< adc_seq adc_seq_debug: adc1_set_mux2 (Bit 13)         */
#define adc_seq_adc_seq_debug_adc1_set_mux2_Msk (0x2000UL)          /*!< adc_seq adc_seq_debug: adc1_set_mux2 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc1_set_mux1_Pos (12UL)              /*!< adc_seq adc_seq_debug: adc1_set_mux1 (Bit 12)         */
#define adc_seq_adc_seq_debug_adc1_set_mux1_Msk (0x1000UL)          /*!< adc_seq adc_seq_debug: adc1_set_mux1 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc1_set_mux0_Pos (11UL)              /*!< adc_seq adc_seq_debug: adc1_set_mux0 (Bit 11)         */
#define adc_seq_adc_seq_debug_adc1_set_mux0_Msk (0x800UL)           /*!< adc_seq adc_seq_debug: adc1_set_mux0 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc1_use_ref_vdd3_Pos (10UL)          /*!< adc_seq adc_seq_debug: adc1_use_ref_vdd3 (Bit 10)     */
#define adc_seq_adc_seq_debug_adc1_use_ref_vdd3_Msk (0x400UL)       /*!< adc_seq adc_seq_debug: adc1_use_ref_vdd3 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc1_soc_Pos (9UL)                    /*!< adc_seq adc_seq_debug: adc1_soc (Bit 9)               */
#define adc_seq_adc_seq_debug_adc1_soc_Msk (0x200UL)                /*!< adc_seq adc_seq_debug: adc1_soc (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc1_clk_Pos (8UL)                    /*!< adc_seq adc_seq_debug: adc1_clk (Bit 8)               */
#define adc_seq_adc_seq_debug_adc1_clk_Msk (0x100UL)                /*!< adc_seq adc_seq_debug: adc1_clk (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_reserved0_Pos (7UL)                   /*!< adc_seq adc_seq_debug: reserved0 (Bit 7)              */
#define adc_seq_adc_seq_debug_reserved0_Msk (0x80UL)                /*!< adc_seq adc_seq_debug: reserved0 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc0_set_mux3_Pos (6UL)               /*!< adc_seq adc_seq_debug: adc0_set_mux3 (Bit 6)          */
#define adc_seq_adc_seq_debug_adc0_set_mux3_Msk (0x40UL)            /*!< adc_seq adc_seq_debug: adc0_set_mux3 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc0_set_mux2_Pos (5UL)               /*!< adc_seq adc_seq_debug: adc0_set_mux2 (Bit 5)          */
#define adc_seq_adc_seq_debug_adc0_set_mux2_Msk (0x20UL)            /*!< adc_seq adc_seq_debug: adc0_set_mux2 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc0_set_mux1_Pos (4UL)               /*!< adc_seq adc_seq_debug: adc0_set_mux1 (Bit 4)          */
#define adc_seq_adc_seq_debug_adc0_set_mux1_Msk (0x10UL)            /*!< adc_seq adc_seq_debug: adc0_set_mux1 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc0_set_mux0_Pos (3UL)               /*!< adc_seq adc_seq_debug: adc0_set_mux0 (Bit 3)          */
#define adc_seq_adc_seq_debug_adc0_set_mux0_Msk (0x8UL)             /*!< adc_seq adc_seq_debug: adc0_set_mux0 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc0_use_ref_vdd3_Pos (2UL)           /*!< adc_seq adc_seq_debug: adc0_use_ref_vdd3 (Bit 2)      */
#define adc_seq_adc_seq_debug_adc0_use_ref_vdd3_Msk (0x4UL)         /*!< adc_seq adc_seq_debug: adc0_use_ref_vdd3 (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc0_soc_Pos (1UL)                    /*!< adc_seq adc_seq_debug: adc0_soc (Bit 1)               */
#define adc_seq_adc_seq_debug_adc0_soc_Msk (0x2UL)                  /*!< adc_seq adc_seq_debug: adc0_soc (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_debug_adc0_clk_Pos (0UL)                    /*!< adc_seq adc_seq_debug: adc0_clk (Bit 0)               */
#define adc_seq_adc_seq_debug_adc0_clk_Msk (0x1UL)                  /*!< adc_seq adc_seq_debug: adc0_clk (Bitfield-Mask: 0x01) */
/* ====================================================  adc_seq_irq_raw  ==================================================== */
#define adc_seq_adc_seq_irq_raw_adc1_data_finish_Pos (3UL)          /*!< adc_seq adc_seq_irq_raw: adc1_data_finish (Bit 3)     */
#define adc_seq_adc_seq_irq_raw_adc1_data_finish_Msk (0x8UL)        /*!< adc_seq adc_seq_irq_raw: adc1_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_raw_adc0_data_finish_Pos (2UL)          /*!< adc_seq adc_seq_irq_raw: adc0_data_finish (Bit 2)     */
#define adc_seq_adc_seq_irq_raw_adc0_data_finish_Msk (0x4UL)        /*!< adc_seq adc_seq_irq_raw: adc0_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_raw_adc1_sample_finish_Pos (1UL)        /*!< adc_seq adc_seq_irq_raw: adc1_sample_finish (Bit 1)   */
#define adc_seq_adc_seq_irq_raw_adc1_sample_finish_Msk (0x2UL)      /*!< adc_seq adc_seq_irq_raw: adc1_sample_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_raw_adc0_sample_finish_Pos (0UL)        /*!< adc_seq adc_seq_irq_raw: adc0_sample_finish (Bit 0)   */
#define adc_seq_adc_seq_irq_raw_adc0_sample_finish_Msk (0x1UL)      /*!< adc_seq adc_seq_irq_raw: adc0_sample_finish (Bitfield-Mask: 0x01) */
/* ==================================================  adc_seq_irq_masked  =================================================== */
#define adc_seq_adc_seq_irq_masked_adc1_data_finish_Pos (3UL)       /*!< adc_seq adc_seq_irq_masked: adc1_data_finish (Bit 3)  */
#define adc_seq_adc_seq_irq_masked_adc1_data_finish_Msk (0x8UL)     /*!< adc_seq adc_seq_irq_masked: adc1_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_masked_adc0_data_finish_Pos (2UL)       /*!< adc_seq adc_seq_irq_masked: adc0_data_finish (Bit 2)  */
#define adc_seq_adc_seq_irq_masked_adc0_data_finish_Msk (0x4UL)     /*!< adc_seq adc_seq_irq_masked: adc0_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_masked_adc1_sample_finish_Pos (1UL)     /*!< adc_seq adc_seq_irq_masked: adc1_sample_finish (Bit 1) */
#define adc_seq_adc_seq_irq_masked_adc1_sample_finish_Msk (0x2UL)   /*!< adc_seq adc_seq_irq_masked: adc1_sample_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_masked_adc0_sample_finish_Pos (0UL)     /*!< adc_seq adc_seq_irq_masked: adc0_sample_finish (Bit 0) */
#define adc_seq_adc_seq_irq_masked_adc0_sample_finish_Msk (0x1UL)   /*!< adc_seq adc_seq_irq_masked: adc0_sample_finish (Bitfield-Mask: 0x01) */
/* =================================================  adc_seq_irq_mask_set  ================================================== */
#define adc_seq_adc_seq_irq_mask_set_adc1_data_finish_Pos (3UL)     /*!< adc_seq adc_seq_irq_mask_set: adc1_data_finish (Bit 3) */
#define adc_seq_adc_seq_irq_mask_set_adc1_data_finish_Msk (0x8UL)   /*!< adc_seq adc_seq_irq_mask_set: adc1_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_mask_set_adc0_data_finish_Pos (2UL)     /*!< adc_seq adc_seq_irq_mask_set: adc0_data_finish (Bit 2) */
#define adc_seq_adc_seq_irq_mask_set_adc0_data_finish_Msk (0x4UL)   /*!< adc_seq adc_seq_irq_mask_set: adc0_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_mask_set_adc1_sample_finish_Pos (1UL)   /*!< adc_seq adc_seq_irq_mask_set: adc1_sample_finish (Bit 1) */
#define adc_seq_adc_seq_irq_mask_set_adc1_sample_finish_Msk (0x2UL) /*!< adc_seq adc_seq_irq_mask_set: adc1_sample_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_mask_set_adc0_sample_finish_Pos (0UL)   /*!< adc_seq adc_seq_irq_mask_set: adc0_sample_finish (Bit 0) */
#define adc_seq_adc_seq_irq_mask_set_adc0_sample_finish_Msk (0x1UL) /*!< adc_seq adc_seq_irq_mask_set: adc0_sample_finish (Bitfield-Mask: 0x01) */
/* ================================================  adc_seq_irq_mask_reset  ================================================= */
#define adc_seq_adc_seq_irq_mask_reset_adc1_data_finish_Pos (3UL)   /*!< adc_seq adc_seq_irq_mask_reset: adc1_data_finish (Bit 3) */
#define adc_seq_adc_seq_irq_mask_reset_adc1_data_finish_Msk (0x8UL) /*!< adc_seq adc_seq_irq_mask_reset: adc1_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_mask_reset_adc0_data_finish_Pos (2UL)   /*!< adc_seq adc_seq_irq_mask_reset: adc0_data_finish (Bit 2) */
#define adc_seq_adc_seq_irq_mask_reset_adc0_data_finish_Msk (0x4UL) /*!< adc_seq adc_seq_irq_mask_reset: adc0_data_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_mask_reset_adc1_sample_finish_Pos (1UL) /*!< adc_seq adc_seq_irq_mask_reset: adc1_sample_finish (Bit 1) */
#define adc_seq_adc_seq_irq_mask_reset_adc1_sample_finish_Msk (0x2UL) /*!< adc_seq adc_seq_irq_mask_reset: adc1_sample_finish (Bitfield-Mask: 0x01) */
#define adc_seq_adc_seq_irq_mask_reset_adc0_sample_finish_Pos (0UL) /*!< adc_seq adc_seq_irq_mask_reset: adc0_sample_finish (Bit 0) */
#define adc_seq_adc_seq_irq_mask_reset_adc0_sample_finish_Msk (0x1UL) /*!< adc_seq adc_seq_irq_mask_reset: adc0_sample_finish (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                           miimu                                           ================ */
/* =========================================================================================================================== */

/* =========================================================  miimu  ========================================================= */
#define miimu_miimu_data_Pos              (16UL)                    /*!< miimu miimu: data (Bit 16)                            */
#define miimu_miimu_data_Msk              (0xffff0000UL)            /*!< miimu miimu: data (Bitfield-Mask: 0xffff)             */
#define miimu_miimu_phyaddr_Pos           (11UL)                    /*!< miimu miimu: phyaddr (Bit 11)                         */
#define miimu_miimu_phyaddr_Msk           (0xf800UL)                /*!< miimu miimu: phyaddr (Bitfield-Mask: 0x1f)            */
#define miimu_miimu_regaddr_Pos           (6UL)                     /*!< miimu miimu: regaddr (Bit 6)                          */
#define miimu_miimu_regaddr_Msk           (0x7c0UL)                 /*!< miimu miimu: regaddr (Bitfield-Mask: 0x1f)            */
#define miimu_miimu_rta_Pos               (5UL)                     /*!< miimu miimu: rta (Bit 5)                              */
#define miimu_miimu_rta_Msk               (0x20UL)                  /*!< miimu miimu: rta (Bitfield-Mask: 0x01)                */
#define miimu_miimu_reserved0_Pos         (4UL)                     /*!< miimu miimu: reserved0 (Bit 4)                        */
#define miimu_miimu_reserved0_Msk         (0x10UL)                  /*!< miimu miimu: reserved0 (Bitfield-Mask: 0x01)          */
#define miimu_miimu_mdc_period_Pos        (3UL)                     /*!< miimu miimu: mdc_period (Bit 3)                       */
#define miimu_miimu_mdc_period_Msk        (0x8UL)                   /*!< miimu miimu: mdc_period (Bitfield-Mask: 0x01)         */
#define miimu_miimu_opmode_Pos            (2UL)                     /*!< miimu miimu: opmode (Bit 2)                           */
#define miimu_miimu_opmode_Msk            (0x4UL)                   /*!< miimu miimu: opmode (Bitfield-Mask: 0x01)             */
#define miimu_miimu_preamble_Pos          (1UL)                     /*!< miimu miimu: preamble (Bit 1)                         */
#define miimu_miimu_preamble_Msk          (0x2UL)                   /*!< miimu miimu: preamble (Bitfield-Mask: 0x01)           */
#define miimu_miimu_snrdy_Pos             (0UL)                     /*!< miimu miimu: snrdy (Bit 0)                            */
#define miimu_miimu_snrdy_Msk             (0x1UL)                   /*!< miimu miimu: snrdy (Bitfield-Mask: 0x01)              */
/* =======================================================  miimu_sw  ======================================================== */
#define miimu_miimu_sw_reserved1_Pos      (9UL)                     /*!< miimu miimu_sw: reserved1 (Bit 9)                     */
#define miimu_miimu_sw_reserved1_Msk      (0xfffffe00UL)            /*!< miimu miimu_sw: reserved1 (Bitfield-Mask: 0x7fffff)   */
#define miimu_miimu_sw_loopback_Pos       (8UL)                     /*!< miimu miimu_sw: loopback (Bit 8)                      */
#define miimu_miimu_sw_loopback_Msk       (0x100UL)                 /*!< miimu miimu_sw: loopback (Bitfield-Mask: 0x01)        */
#define miimu_miimu_sw_mdi_ro_Pos         (7UL)                     /*!< miimu miimu_sw: mdi_ro (Bit 7)                        */
#define miimu_miimu_sw_mdi_ro_Msk         (0x80UL)                  /*!< miimu miimu_sw: mdi_ro (Bitfield-Mask: 0x01)          */
#define miimu_miimu_sw_mdoe_Pos           (6UL)                     /*!< miimu miimu_sw: mdoe (Bit 6)                          */
#define miimu_miimu_sw_mdoe_Msk           (0x40UL)                  /*!< miimu miimu_sw: mdoe (Bitfield-Mask: 0x01)            */
#define miimu_miimu_sw_mdo_Pos            (5UL)                     /*!< miimu miimu_sw: mdo (Bit 5)                           */
#define miimu_miimu_sw_mdo_Msk            (0x20UL)                  /*!< miimu miimu_sw: mdo (Bitfield-Mask: 0x01)             */
#define miimu_miimu_sw_mdc_Pos            (4UL)                     /*!< miimu miimu_sw: mdc (Bit 4)                           */
#define miimu_miimu_sw_mdc_Msk            (0x10UL)                  /*!< miimu miimu_sw: mdc (Bitfield-Mask: 0x01)             */
#define miimu_miimu_sw_reserved0_Pos      (1UL)                     /*!< miimu miimu_sw: reserved0 (Bit 1)                     */
#define miimu_miimu_sw_reserved0_Msk      (0xeUL)                   /*!< miimu miimu_sw: reserved0 (Bitfield-Mask: 0x07)       */
#define miimu_miimu_sw_enable_Pos         (0UL)                     /*!< miimu miimu_sw: enable (Bit 0)                        */
#define miimu_miimu_sw_enable_Msk         (0x1UL)                   /*!< miimu miimu_sw: enable (Bitfield-Mask: 0x01)          */


/* =========================================================================================================================== */
/* ================                                            eth                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  eth_config  ======================================================= */
#define eth_eth_config_reserved1_Pos      (30UL)                    /*!< eth eth_config: reserved1 (Bit 30)                    */
#define eth_eth_config_reserved1_Msk      (0xc0000000UL)            /*!< eth eth_config: reserved1 (Bitfield-Mask: 0x03)       */
#define eth_eth_config_phy_mode_Pos       (29UL)                    /*!< eth eth_config: phy_mode (Bit 29)                     */
#define eth_eth_config_phy_mode_Msk       (0x20000000UL)            /*!< eth eth_config: phy_mode (Bitfield-Mask: 0x01)        */
#define eth_eth_config_hd_suppress_loopback_Pos (28UL)              /*!< eth eth_config: hd_suppress_loopback (Bit 28)         */
#define eth_eth_config_hd_suppress_loopback_Msk (0x10000000UL)      /*!< eth eth_config: hd_suppress_loopback (Bitfield-Mask: 0x01) */
#define eth_eth_config_frequency_Pos      (27UL)                    /*!< eth eth_config: frequency (Bit 27)                    */
#define eth_eth_config_frequency_Msk      (0x8000000UL)             /*!< eth eth_config: frequency (Bitfield-Mask: 0x01)       */
#define eth_eth_config_reserved0_Pos      (14UL)                    /*!< eth eth_config: reserved0 (Bit 14)                    */
#define eth_eth_config_reserved0_Msk      (0x7ffc000UL)             /*!< eth eth_config: reserved0 (Bitfield-Mask: 0x1fff)     */
#define eth_eth_config_rx_enable_Pos      (13UL)                    /*!< eth eth_config: rx_enable (Bit 13)                    */
#define eth_eth_config_rx_enable_Msk      (0x2000UL)                /*!< eth eth_config: rx_enable (Bitfield-Mask: 0x01)       */
#define eth_eth_config_rx_systime_sfd_Pos (12UL)                    /*!< eth eth_config: rx_systime_sfd (Bit 12)               */
#define eth_eth_config_rx_systime_sfd_Msk (0x1000UL)                /*!< eth eth_config: rx_systime_sfd (Bitfield-Mask: 0x01)  */
#define eth_eth_config_rx_dma_mode_Pos    (11UL)                    /*!< eth eth_config: rx_dma_mode (Bit 11)                  */
#define eth_eth_config_rx_dma_mode_Msk    (0x800UL)                 /*!< eth eth_config: rx_dma_mode (Bitfield-Mask: 0x01)     */
#define eth_eth_config_rx_no_preamble_Pos (10UL)                    /*!< eth eth_config: rx_no_preamble (Bit 10)               */
#define eth_eth_config_rx_no_preamble_Msk (0x400UL)                 /*!< eth eth_config: rx_no_preamble (Bitfield-Mask: 0x01)  */
#define eth_eth_config_rx_exact_preamble_Pos (9UL)                  /*!< eth eth_config: rx_exact_preamble (Bit 9)             */
#define eth_eth_config_rx_exact_preamble_Msk (0x200UL)              /*!< eth eth_config: rx_exact_preamble (Bitfield-Mask: 0x01) */
#define eth_eth_config_rx_allow_jumbo_packets_Pos (8UL)             /*!< eth eth_config: rx_allow_jumbo_packets (Bit 8)        */
#define eth_eth_config_rx_allow_jumbo_packets_Msk (0x100UL)         /*!< eth eth_config: rx_allow_jumbo_packets (Bitfield-Mask: 0x01) */
#define eth_eth_config_rx_delay_inputs_Pos (7UL)                    /*!< eth eth_config: rx_delay_inputs (Bit 7)               */
#define eth_eth_config_rx_delay_inputs_Msk (0x80UL)                 /*!< eth eth_config: rx_delay_inputs (Bitfield-Mask: 0x01) */
#define eth_eth_config_rx_sample_phase_Pos (4UL)                    /*!< eth eth_config: rx_sample_phase (Bit 4)               */
#define eth_eth_config_rx_sample_phase_Msk (0x70UL)                 /*!< eth eth_config: rx_sample_phase (Bitfield-Mask: 0x07) */
#define eth_eth_config_rx_watermark_irq_Pos (0UL)                   /*!< eth eth_config: rx_watermark_irq (Bit 0)              */
#define eth_eth_config_rx_watermark_irq_Msk (0xfUL)                 /*!< eth eth_config: rx_watermark_irq (Bitfield-Mask: 0x0f) */
/* =====================================================  eth_tx_config  ===================================================== */
#define eth_eth_tx_config_half_duplex_Pos (31UL)                    /*!< eth eth_tx_config: half_duplex (Bit 31)               */
#define eth_eth_tx_config_half_duplex_Msk (0x80000000UL)            /*!< eth eth_tx_config: half_duplex (Bitfield-Mask: 0x01)  */
#define eth_eth_tx_config_tx_dma_mode_Pos (30UL)                    /*!< eth eth_tx_config: tx_dma_mode (Bit 30)               */
#define eth_eth_tx_config_tx_dma_mode_Msk (0x40000000UL)            /*!< eth eth_tx_config: tx_dma_mode (Bitfield-Mask: 0x01)  */
#define eth_eth_tx_config_tx_systime_sfd_Pos (29UL)                 /*!< eth eth_tx_config: tx_systime_sfd (Bit 29)            */
#define eth_eth_tx_config_tx_systime_sfd_Msk (0x20000000UL)         /*!< eth eth_tx_config: tx_systime_sfd (Bitfield-Mask: 0x01) */
#define eth_eth_tx_config_tx_abort_frame_Pos (26UL)                 /*!< eth eth_tx_config: tx_abort_frame (Bit 26)            */
#define eth_eth_tx_config_tx_abort_frame_Msk (0x1c000000UL)         /*!< eth eth_tx_config: tx_abort_frame (Bitfield-Mask: 0x07) */
#define eth_eth_tx_config_tx_crs_low_cycles_Pos (21UL)              /*!< eth eth_tx_config: tx_crs_low_cycles (Bit 21)         */
#define eth_eth_tx_config_tx_crs_low_cycles_Msk (0x3e00000UL)       /*!< eth eth_tx_config: tx_crs_low_cycles (Bitfield-Mask: 0x1f) */
#define eth_eth_tx_config_tx_min_ifg_cycles_Pos (16UL)              /*!< eth eth_tx_config: tx_min_ifg_cycles (Bit 16)         */
#define eth_eth_tx_config_tx_min_ifg_cycles_Msk (0x1f0000UL)        /*!< eth eth_tx_config: tx_min_ifg_cycles (Bitfield-Mask: 0x1f) */
#define eth_eth_tx_config_tx_preamble_len_Pos (11UL)                /*!< eth eth_tx_config: tx_preamble_len (Bit 11)           */
#define eth_eth_tx_config_tx_preamble_len_Msk (0xf800UL)            /*!< eth eth_tx_config: tx_preamble_len (Bitfield-Mask: 0x1f) */
#define eth_eth_tx_config_tx_output_phase_Pos (8UL)                 /*!< eth eth_tx_config: tx_output_phase (Bit 8)            */
#define eth_eth_tx_config_tx_output_phase_Msk (0x700UL)             /*!< eth eth_tx_config: tx_output_phase (Bitfield-Mask: 0x07) */
#define eth_eth_tx_config_tx_watermark_start_Pos (4UL)              /*!< eth eth_tx_config: tx_watermark_start (Bit 4)         */
#define eth_eth_tx_config_tx_watermark_start_Msk (0xf0UL)           /*!< eth eth_tx_config: tx_watermark_start (Bitfield-Mask: 0x0f) */
#define eth_eth_tx_config_tx_watermark_irq_Pos (0UL)                /*!< eth eth_tx_config: tx_watermark_irq (Bit 0)           */
#define eth_eth_tx_config_tx_watermark_irq_Msk (0xfUL)              /*!< eth eth_tx_config: tx_watermark_irq (Bitfield-Mask: 0x0f) */
/* ======================================================  eth_status  ======================================================= */
#define eth_eth_status_reserved1_Pos      (12UL)                    /*!< eth eth_status: reserved1 (Bit 12)                    */
#define eth_eth_status_reserved1_Msk      (0xfffff000UL)            /*!< eth eth_status: reserved1 (Bitfield-Mask: 0xfffff)    */
#define eth_eth_status_tx_fill_Pos        (7UL)                     /*!< eth eth_status: tx_fill (Bit 7)                       */
#define eth_eth_status_tx_fill_Msk        (0xf80UL)                 /*!< eth eth_status: tx_fill (Bitfield-Mask: 0x1f)         */
#define eth_eth_status_reserved0_Pos      (5UL)                     /*!< eth eth_status: reserved0 (Bit 5)                     */
#define eth_eth_status_reserved0_Msk      (0x60UL)                  /*!< eth eth_status: reserved0 (Bitfield-Mask: 0x03)       */
#define eth_eth_status_rx_fill_Pos        (0UL)                     /*!< eth eth_status: rx_fill (Bit 0)                       */
#define eth_eth_status_rx_fill_Msk        (0x1fUL)                  /*!< eth eth_status: rx_fill (Bitfield-Mask: 0x1f)         */
/* ======================================================  eth_tx_data  ====================================================== */
#define eth_eth_tx_data_val_Pos           (0UL)                     /*!< eth eth_tx_data: val (Bit 0)                          */
#define eth_eth_tx_data_val_Msk           (0xffffffffUL)            /*!< eth eth_tx_data: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  eth_rx_data  ====================================================== */
#define eth_eth_rx_data_val_Pos           (0UL)                     /*!< eth eth_rx_data: val (Bit 0)                          */
#define eth_eth_rx_data_val_Msk           (0xffffffffUL)            /*!< eth eth_rx_data: val (Bitfield-Mask: 0xffffffff)      */
/* ======================================================  eth_tx_len  ======================================================= */
#define eth_eth_tx_len_val_Pos            (0UL)                     /*!< eth eth_tx_len: val (Bit 0)                           */
#define eth_eth_tx_len_val_Msk            (0x7ffUL)                 /*!< eth eth_tx_len: val (Bitfield-Mask: 0x7ff)            */
/* ====================================================  eth_rx_len_stat  ==================================================== */
#define eth_eth_rx_len_stat_rx_mii_rxerr_Pos (31UL)                 /*!< eth eth_rx_len_stat: rx_mii_rxerr (Bit 31)            */
#define eth_eth_rx_len_stat_rx_mii_rxerr_Msk (0x80000000UL)         /*!< eth eth_rx_len_stat: rx_mii_rxerr (Bitfield-Mask: 0x01) */
#define eth_eth_rx_len_stat_rx_crc_error_Pos (30UL)                 /*!< eth eth_rx_len_stat: rx_crc_error (Bit 30)            */
#define eth_eth_rx_len_stat_rx_crc_error_Msk (0x40000000UL)         /*!< eth eth_rx_len_stat: rx_crc_error (Bitfield-Mask: 0x01) */
#define eth_eth_rx_len_stat_rx_dribble_nibble_Pos (29UL)            /*!< eth eth_rx_len_stat: rx_dribble_nibble (Bit 29)       */
#define eth_eth_rx_len_stat_rx_dribble_nibble_Msk (0x20000000UL)    /*!< eth eth_rx_len_stat: rx_dribble_nibble (Bitfield-Mask: 0x01) */
#define eth_eth_rx_len_stat_rx_jumbo_packet_Pos (28UL)              /*!< eth eth_rx_len_stat: rx_jumbo_packet (Bit 28)         */
#define eth_eth_rx_len_stat_rx_jumbo_packet_Msk (0x10000000UL)      /*!< eth eth_rx_len_stat: rx_jumbo_packet (Bitfield-Mask: 0x01) */
#define eth_eth_rx_len_stat_rx_short_ifg_Pos (27UL)                 /*!< eth eth_rx_len_stat: rx_short_ifg (Bit 27)            */
#define eth_eth_rx_len_stat_rx_short_ifg_Msk (0x8000000UL)          /*!< eth eth_rx_len_stat: rx_short_ifg (Bitfield-Mask: 0x01) */
#define eth_eth_rx_len_stat_reserved0_Pos (11UL)                    /*!< eth eth_rx_len_stat: reserved0 (Bit 11)               */
#define eth_eth_rx_len_stat_reserved0_Msk (0x7fff800UL)             /*!< eth eth_rx_len_stat: reserved0 (Bitfield-Mask: 0xffff) */
#define eth_eth_rx_len_stat_rx_len_Pos    (0UL)                     /*!< eth eth_rx_len_stat: rx_len (Bit 0)                   */
#define eth_eth_rx_len_stat_rx_len_Msk    (0x7ffUL)                 /*!< eth eth_rx_len_stat: rx_len (Bitfield-Mask: 0x7ff)    */
/* ===================================================  eth_rx_systime_ns  =================================================== */
#define eth_eth_rx_systime_ns_val_Pos     (0UL)                     /*!< eth eth_rx_systime_ns: val (Bit 0)                    */
#define eth_eth_rx_systime_ns_val_Msk     (0xffffffffUL)            /*!< eth eth_rx_systime_ns: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  eth_tx_systime_ns  =================================================== */
#define eth_eth_tx_systime_ns_val_Pos     (0UL)                     /*!< eth eth_tx_systime_ns: val (Bit 0)                    */
#define eth_eth_tx_systime_ns_val_Msk     (0xffffffffUL)            /*!< eth eth_tx_systime_ns: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  eth_irq_raw  ====================================================== */
#define eth_eth_irq_raw_tx_late_col_Pos   (12UL)                    /*!< eth eth_irq_raw: tx_late_col (Bit 12)                 */
#define eth_eth_irq_raw_tx_late_col_Msk   (0x1000UL)                /*!< eth eth_irq_raw: tx_late_col (Bitfield-Mask: 0x01)    */
#define eth_eth_irq_raw_tx_col_Pos        (11UL)                    /*!< eth eth_irq_raw: tx_col (Bit 11)                      */
#define eth_eth_irq_raw_tx_col_Msk        (0x800UL)                 /*!< eth eth_irq_raw: tx_col (Bitfield-Mask: 0x01)         */
#define eth_eth_irq_raw_rx_preamble_error_Pos (10UL)                /*!< eth eth_irq_raw: rx_preamble_error (Bit 10)           */
#define eth_eth_irq_raw_rx_preamble_error_Msk (0x400UL)             /*!< eth eth_irq_raw: rx_preamble_error (Bitfield-Mask: 0x01) */
#define eth_eth_irq_raw_rx_short_dv_Pos   (9UL)                     /*!< eth eth_irq_raw: rx_short_dv (Bit 9)                  */
#define eth_eth_irq_raw_rx_short_dv_Msk   (0x200UL)                 /*!< eth eth_irq_raw: rx_short_dv (Bitfield-Mask: 0x01)    */
#define eth_eth_irq_raw_rx_cpu_too_slow_Pos (8UL)                   /*!< eth eth_irq_raw: rx_cpu_too_slow (Bit 8)              */
#define eth_eth_irq_raw_rx_cpu_too_slow_Msk (0x100UL)               /*!< eth eth_irq_raw: rx_cpu_too_slow (Bitfield-Mask: 0x01) */
#define eth_eth_irq_raw_rx_fifo_ovfl_Pos  (7UL)                     /*!< eth eth_irq_raw: rx_fifo_ovfl (Bit 7)                 */
#define eth_eth_irq_raw_rx_fifo_ovfl_Msk  (0x80UL)                  /*!< eth eth_irq_raw: rx_fifo_ovfl (Bitfield-Mask: 0x01)   */
#define eth_eth_irq_raw_rx_fifo_undr_Pos  (6UL)                     /*!< eth eth_irq_raw: rx_fifo_undr (Bit 6)                 */
#define eth_eth_irq_raw_rx_fifo_undr_Msk  (0x40UL)                  /*!< eth eth_irq_raw: rx_fifo_undr (Bitfield-Mask: 0x01)   */
#define eth_eth_irq_raw_tx_fifo_ovfl_Pos  (5UL)                     /*!< eth eth_irq_raw: tx_fifo_ovfl (Bit 5)                 */
#define eth_eth_irq_raw_tx_fifo_ovfl_Msk  (0x20UL)                  /*!< eth eth_irq_raw: tx_fifo_ovfl (Bitfield-Mask: 0x01)   */
#define eth_eth_irq_raw_tx_fifo_undr_Pos  (4UL)                     /*!< eth eth_irq_raw: tx_fifo_undr (Bit 4)                 */
#define eth_eth_irq_raw_tx_fifo_undr_Msk  (0x10UL)                  /*!< eth eth_irq_raw: tx_fifo_undr (Bitfield-Mask: 0x01)   */
#define eth_eth_irq_raw_rx_frame_finished_Pos (3UL)                 /*!< eth eth_irq_raw: rx_frame_finished (Bit 3)            */
#define eth_eth_irq_raw_rx_frame_finished_Msk (0x8UL)               /*!< eth eth_irq_raw: rx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_raw_rx_data_Pos       (2UL)                     /*!< eth eth_irq_raw: rx_data (Bit 2)                      */
#define eth_eth_irq_raw_rx_data_Msk       (0x4UL)                   /*!< eth eth_irq_raw: rx_data (Bitfield-Mask: 0x01)        */
#define eth_eth_irq_raw_tx_frame_finished_Pos (1UL)                 /*!< eth eth_irq_raw: tx_frame_finished (Bit 1)            */
#define eth_eth_irq_raw_tx_frame_finished_Msk (0x2UL)               /*!< eth eth_irq_raw: tx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_raw_tx_fifo_Pos       (0UL)                     /*!< eth eth_irq_raw: tx_fifo (Bit 0)                      */
#define eth_eth_irq_raw_tx_fifo_Msk       (0x1UL)                   /*!< eth eth_irq_raw: tx_fifo (Bitfield-Mask: 0x01)        */
/* ====================================================  eth_irq_masked  ===================================================== */
#define eth_eth_irq_masked_tx_late_col_Pos (12UL)                   /*!< eth eth_irq_masked: tx_late_col (Bit 12)              */
#define eth_eth_irq_masked_tx_late_col_Msk (0x1000UL)               /*!< eth eth_irq_masked: tx_late_col (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_tx_col_Pos     (11UL)                    /*!< eth eth_irq_masked: tx_col (Bit 11)                   */
#define eth_eth_irq_masked_tx_col_Msk     (0x800UL)                 /*!< eth eth_irq_masked: tx_col (Bitfield-Mask: 0x01)      */
#define eth_eth_irq_masked_rx_preamble_error_Pos (10UL)             /*!< eth eth_irq_masked: rx_preamble_error (Bit 10)        */
#define eth_eth_irq_masked_rx_preamble_error_Msk (0x400UL)          /*!< eth eth_irq_masked: rx_preamble_error (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_rx_short_dv_Pos (9UL)                    /*!< eth eth_irq_masked: rx_short_dv (Bit 9)               */
#define eth_eth_irq_masked_rx_short_dv_Msk (0x200UL)                /*!< eth eth_irq_masked: rx_short_dv (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_rx_cpu_too_slow_Pos (8UL)                /*!< eth eth_irq_masked: rx_cpu_too_slow (Bit 8)           */
#define eth_eth_irq_masked_rx_cpu_too_slow_Msk (0x100UL)            /*!< eth eth_irq_masked: rx_cpu_too_slow (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_rx_fifo_ovfl_Pos (7UL)                   /*!< eth eth_irq_masked: rx_fifo_ovfl (Bit 7)              */
#define eth_eth_irq_masked_rx_fifo_ovfl_Msk (0x80UL)                /*!< eth eth_irq_masked: rx_fifo_ovfl (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_rx_fifo_undr_Pos (6UL)                   /*!< eth eth_irq_masked: rx_fifo_undr (Bit 6)              */
#define eth_eth_irq_masked_rx_fifo_undr_Msk (0x40UL)                /*!< eth eth_irq_masked: rx_fifo_undr (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_tx_fifo_ovfl_Pos (5UL)                   /*!< eth eth_irq_masked: tx_fifo_ovfl (Bit 5)              */
#define eth_eth_irq_masked_tx_fifo_ovfl_Msk (0x20UL)                /*!< eth eth_irq_masked: tx_fifo_ovfl (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_tx_fifo_undr_Pos (4UL)                   /*!< eth eth_irq_masked: tx_fifo_undr (Bit 4)              */
#define eth_eth_irq_masked_tx_fifo_undr_Msk (0x10UL)                /*!< eth eth_irq_masked: tx_fifo_undr (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_rx_frame_finished_Pos (3UL)              /*!< eth eth_irq_masked: rx_frame_finished (Bit 3)         */
#define eth_eth_irq_masked_rx_frame_finished_Msk (0x8UL)            /*!< eth eth_irq_masked: rx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_rx_data_Pos    (2UL)                     /*!< eth eth_irq_masked: rx_data (Bit 2)                   */
#define eth_eth_irq_masked_rx_data_Msk    (0x4UL)                   /*!< eth eth_irq_masked: rx_data (Bitfield-Mask: 0x01)     */
#define eth_eth_irq_masked_tx_frame_finished_Pos (1UL)              /*!< eth eth_irq_masked: tx_frame_finished (Bit 1)         */
#define eth_eth_irq_masked_tx_frame_finished_Msk (0x2UL)            /*!< eth eth_irq_masked: tx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_masked_tx_fifo_Pos    (0UL)                     /*!< eth eth_irq_masked: tx_fifo (Bit 0)                   */
#define eth_eth_irq_masked_tx_fifo_Msk    (0x1UL)                   /*!< eth eth_irq_masked: tx_fifo (Bitfield-Mask: 0x01)     */
/* ====================================================  eth_irq_msk_set  ==================================================== */
#define eth_eth_irq_msk_set_tx_late_col_Pos (12UL)                  /*!< eth eth_irq_msk_set: tx_late_col (Bit 12)             */
#define eth_eth_irq_msk_set_tx_late_col_Msk (0x1000UL)              /*!< eth eth_irq_msk_set: tx_late_col (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_tx_col_Pos    (11UL)                    /*!< eth eth_irq_msk_set: tx_col (Bit 11)                  */
#define eth_eth_irq_msk_set_tx_col_Msk    (0x800UL)                 /*!< eth eth_irq_msk_set: tx_col (Bitfield-Mask: 0x01)     */
#define eth_eth_irq_msk_set_rx_preamble_error_Pos (10UL)            /*!< eth eth_irq_msk_set: rx_preamble_error (Bit 10)       */
#define eth_eth_irq_msk_set_rx_preamble_error_Msk (0x400UL)         /*!< eth eth_irq_msk_set: rx_preamble_error (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_rx_short_dv_Pos (9UL)                   /*!< eth eth_irq_msk_set: rx_short_dv (Bit 9)              */
#define eth_eth_irq_msk_set_rx_short_dv_Msk (0x200UL)               /*!< eth eth_irq_msk_set: rx_short_dv (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_rx_cpu_too_slow_Pos (8UL)               /*!< eth eth_irq_msk_set: rx_cpu_too_slow (Bit 8)          */
#define eth_eth_irq_msk_set_rx_cpu_too_slow_Msk (0x100UL)           /*!< eth eth_irq_msk_set: rx_cpu_too_slow (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_rx_fifo_ovfl_Pos (7UL)                  /*!< eth eth_irq_msk_set: rx_fifo_ovfl (Bit 7)             */
#define eth_eth_irq_msk_set_rx_fifo_ovfl_Msk (0x80UL)               /*!< eth eth_irq_msk_set: rx_fifo_ovfl (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_rx_fifo_undr_Pos (6UL)                  /*!< eth eth_irq_msk_set: rx_fifo_undr (Bit 6)             */
#define eth_eth_irq_msk_set_rx_fifo_undr_Msk (0x40UL)               /*!< eth eth_irq_msk_set: rx_fifo_undr (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_tx_fifo_ovfl_Pos (5UL)                  /*!< eth eth_irq_msk_set: tx_fifo_ovfl (Bit 5)             */
#define eth_eth_irq_msk_set_tx_fifo_ovfl_Msk (0x20UL)               /*!< eth eth_irq_msk_set: tx_fifo_ovfl (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_tx_fifo_undr_Pos (4UL)                  /*!< eth eth_irq_msk_set: tx_fifo_undr (Bit 4)             */
#define eth_eth_irq_msk_set_tx_fifo_undr_Msk (0x10UL)               /*!< eth eth_irq_msk_set: tx_fifo_undr (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_rx_frame_finished_Pos (3UL)             /*!< eth eth_irq_msk_set: rx_frame_finished (Bit 3)        */
#define eth_eth_irq_msk_set_rx_frame_finished_Msk (0x8UL)           /*!< eth eth_irq_msk_set: rx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_rx_data_Pos   (2UL)                     /*!< eth eth_irq_msk_set: rx_data (Bit 2)                  */
#define eth_eth_irq_msk_set_rx_data_Msk   (0x4UL)                   /*!< eth eth_irq_msk_set: rx_data (Bitfield-Mask: 0x01)    */
#define eth_eth_irq_msk_set_tx_frame_finished_Pos (1UL)             /*!< eth eth_irq_msk_set: tx_frame_finished (Bit 1)        */
#define eth_eth_irq_msk_set_tx_frame_finished_Msk (0x2UL)           /*!< eth eth_irq_msk_set: tx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_set_tx_fifo_Pos   (0UL)                     /*!< eth eth_irq_msk_set: tx_fifo (Bit 0)                  */
#define eth_eth_irq_msk_set_tx_fifo_Msk   (0x1UL)                   /*!< eth eth_irq_msk_set: tx_fifo (Bitfield-Mask: 0x01)    */
/* ===================================================  eth_irq_msk_reset  =================================================== */
#define eth_eth_irq_msk_reset_tx_late_col_Pos (12UL)                /*!< eth eth_irq_msk_reset: tx_late_col (Bit 12)           */
#define eth_eth_irq_msk_reset_tx_late_col_Msk (0x1000UL)            /*!< eth eth_irq_msk_reset: tx_late_col (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_tx_col_Pos  (11UL)                    /*!< eth eth_irq_msk_reset: tx_col (Bit 11)                */
#define eth_eth_irq_msk_reset_tx_col_Msk  (0x800UL)                 /*!< eth eth_irq_msk_reset: tx_col (Bitfield-Mask: 0x01)   */
#define eth_eth_irq_msk_reset_rx_preamble_error_Pos (10UL)          /*!< eth eth_irq_msk_reset: rx_preamble_error (Bit 10)     */
#define eth_eth_irq_msk_reset_rx_preamble_error_Msk (0x400UL)       /*!< eth eth_irq_msk_reset: rx_preamble_error (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_rx_short_dv_Pos (9UL)                 /*!< eth eth_irq_msk_reset: rx_short_dv (Bit 9)            */
#define eth_eth_irq_msk_reset_rx_short_dv_Msk (0x200UL)             /*!< eth eth_irq_msk_reset: rx_short_dv (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_rx_cpu_too_slow_Pos (8UL)             /*!< eth eth_irq_msk_reset: rx_cpu_too_slow (Bit 8)        */
#define eth_eth_irq_msk_reset_rx_cpu_too_slow_Msk (0x100UL)         /*!< eth eth_irq_msk_reset: rx_cpu_too_slow (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_rx_fifo_ovfl_Pos (7UL)                /*!< eth eth_irq_msk_reset: rx_fifo_ovfl (Bit 7)           */
#define eth_eth_irq_msk_reset_rx_fifo_ovfl_Msk (0x80UL)             /*!< eth eth_irq_msk_reset: rx_fifo_ovfl (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_rx_fifo_undr_Pos (6UL)                /*!< eth eth_irq_msk_reset: rx_fifo_undr (Bit 6)           */
#define eth_eth_irq_msk_reset_rx_fifo_undr_Msk (0x40UL)             /*!< eth eth_irq_msk_reset: rx_fifo_undr (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_tx_fifo_ovfl_Pos (5UL)                /*!< eth eth_irq_msk_reset: tx_fifo_ovfl (Bit 5)           */
#define eth_eth_irq_msk_reset_tx_fifo_ovfl_Msk (0x20UL)             /*!< eth eth_irq_msk_reset: tx_fifo_ovfl (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_tx_fifo_undr_Pos (4UL)                /*!< eth eth_irq_msk_reset: tx_fifo_undr (Bit 4)           */
#define eth_eth_irq_msk_reset_tx_fifo_undr_Msk (0x10UL)             /*!< eth eth_irq_msk_reset: tx_fifo_undr (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_rx_frame_finished_Pos (3UL)           /*!< eth eth_irq_msk_reset: rx_frame_finished (Bit 3)      */
#define eth_eth_irq_msk_reset_rx_frame_finished_Msk (0x8UL)         /*!< eth eth_irq_msk_reset: rx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_rx_data_Pos (2UL)                     /*!< eth eth_irq_msk_reset: rx_data (Bit 2)                */
#define eth_eth_irq_msk_reset_rx_data_Msk (0x4UL)                   /*!< eth eth_irq_msk_reset: rx_data (Bitfield-Mask: 0x01)  */
#define eth_eth_irq_msk_reset_tx_frame_finished_Pos (1UL)           /*!< eth eth_irq_msk_reset: tx_frame_finished (Bit 1)      */
#define eth_eth_irq_msk_reset_tx_frame_finished_Msk (0x2UL)         /*!< eth eth_irq_msk_reset: tx_frame_finished (Bitfield-Mask: 0x01) */
#define eth_eth_irq_msk_reset_tx_fifo_Pos (0UL)                     /*!< eth eth_irq_msk_reset: tx_fifo (Bit 0)                */
#define eth_eth_irq_msk_reset_tx_fifo_Msk (0x1UL)                   /*!< eth eth_irq_msk_reset: tx_fifo (Bitfield-Mask: 0x01)  */


/* =========================================================================================================================== */
/* ================                                        dmac_app_ch                                        ================ */
/* =========================================================================================================================== */

/* =====================================================  dmac_chsrc_ad  ===================================================== */
#define dmac_app_ch_dmac_chsrc_ad_DMACCHSRCADDR_Pos (0UL)           /*!< dmac_app_ch dmac_chsrc_ad: DMACCHSRCADDR (Bit 0)      */
#define dmac_app_ch_dmac_chsrc_ad_DMACCHSRCADDR_Msk (0xffffffffUL)  /*!< dmac_app_ch dmac_chsrc_ad: DMACCHSRCADDR (Bitfield-Mask: 0xffffffff) */
/* ====================================================  dmac_chdest_ad  ===================================================== */
#define dmac_app_ch_dmac_chdest_ad_DMACCHDESTADDR_Pos (0UL)         /*!< dmac_app_ch dmac_chdest_ad: DMACCHDESTADDR (Bit 0)    */
#define dmac_app_ch_dmac_chdest_ad_DMACCHDESTADDR_Msk (0xffffffffUL) /*!< dmac_app_ch dmac_chdest_ad: DMACCHDESTADDR (Bitfield-Mask: 0xffffffff) */
/* ======================================================  dmac_chlink  ====================================================== */
#define dmac_app_ch_dmac_chlink_LLIADDR_Pos (2UL)                   /*!< dmac_app_ch dmac_chlink: LLIADDR (Bit 2)              */
#define dmac_app_ch_dmac_chlink_LLIADDR_Msk (0xfffffffcUL)          /*!< dmac_app_ch dmac_chlink: LLIADDR (Bitfield-Mask: 0x3fffffff) */
#define dmac_app_ch_dmac_chlink_reserved0_Pos (0UL)                 /*!< dmac_app_ch dmac_chlink: reserved0 (Bit 0)            */
#define dmac_app_ch_dmac_chlink_reserved0_Msk (0x3UL)               /*!< dmac_app_ch dmac_chlink: reserved0 (Bitfield-Mask: 0x03) */
/* ======================================================  dmac_chctrl  ====================================================== */
#define dmac_app_ch_dmac_chctrl_I_Pos     (31UL)                    /*!< dmac_app_ch dmac_chctrl: I (Bit 31)                   */
#define dmac_app_ch_dmac_chctrl_I_Msk     (0x80000000UL)            /*!< dmac_app_ch dmac_chctrl: I (Bitfield-Mask: 0x01)      */
#define dmac_app_ch_dmac_chctrl_Prot_Pos  (28UL)                    /*!< dmac_app_ch dmac_chctrl: Prot (Bit 28)                */
#define dmac_app_ch_dmac_chctrl_Prot_Msk  (0x70000000UL)            /*!< dmac_app_ch dmac_chctrl: Prot (Bitfield-Mask: 0x07)   */
#define dmac_app_ch_dmac_chctrl_DI_Pos    (27UL)                    /*!< dmac_app_ch dmac_chctrl: DI (Bit 27)                  */
#define dmac_app_ch_dmac_chctrl_DI_Msk    (0x8000000UL)             /*!< dmac_app_ch dmac_chctrl: DI (Bitfield-Mask: 0x01)     */
#define dmac_app_ch_dmac_chctrl_SI_Pos    (26UL)                    /*!< dmac_app_ch dmac_chctrl: SI (Bit 26)                  */
#define dmac_app_ch_dmac_chctrl_SI_Msk    (0x4000000UL)             /*!< dmac_app_ch dmac_chctrl: SI (Bitfield-Mask: 0x01)     */
#define dmac_app_ch_dmac_chctrl_reserved0_Pos (25UL)                /*!< dmac_app_ch dmac_chctrl: reserved0 (Bit 25)           */
#define dmac_app_ch_dmac_chctrl_reserved0_Msk (0x2000000UL)         /*!< dmac_app_ch dmac_chctrl: reserved0 (Bitfield-Mask: 0x01) */
#define dmac_app_ch_dmac_chctrl_ARM_EQ_Pos (24UL)                   /*!< dmac_app_ch dmac_chctrl: ARM_EQ (Bit 24)              */
#define dmac_app_ch_dmac_chctrl_ARM_EQ_Msk (0x1000000UL)            /*!< dmac_app_ch dmac_chctrl: ARM_EQ (Bitfield-Mask: 0x01) */
#define dmac_app_ch_dmac_chctrl_DWidth_Pos (21UL)                   /*!< dmac_app_ch dmac_chctrl: DWidth (Bit 21)              */
#define dmac_app_ch_dmac_chctrl_DWidth_Msk (0xe00000UL)             /*!< dmac_app_ch dmac_chctrl: DWidth (Bitfield-Mask: 0x07) */
#define dmac_app_ch_dmac_chctrl_SWidth_Pos (18UL)                   /*!< dmac_app_ch dmac_chctrl: SWidth (Bit 18)              */
#define dmac_app_ch_dmac_chctrl_SWidth_Msk (0x1c0000UL)             /*!< dmac_app_ch dmac_chctrl: SWidth (Bitfield-Mask: 0x07) */
#define dmac_app_ch_dmac_chctrl_DBSize_Pos (15UL)                   /*!< dmac_app_ch dmac_chctrl: DBSize (Bit 15)              */
#define dmac_app_ch_dmac_chctrl_DBSize_Msk (0x38000UL)              /*!< dmac_app_ch dmac_chctrl: DBSize (Bitfield-Mask: 0x07) */
#define dmac_app_ch_dmac_chctrl_SBSize_Pos (12UL)                   /*!< dmac_app_ch dmac_chctrl: SBSize (Bit 12)              */
#define dmac_app_ch_dmac_chctrl_SBSize_Msk (0x7000UL)               /*!< dmac_app_ch dmac_chctrl: SBSize (Bitfield-Mask: 0x07) */
#define dmac_app_ch_dmac_chctrl_TransferSize_Pos (0UL)              /*!< dmac_app_ch dmac_chctrl: TransferSize (Bit 0)         */
#define dmac_app_ch_dmac_chctrl_TransferSize_Msk (0xfffUL)          /*!< dmac_app_ch dmac_chctrl: TransferSize (Bitfield-Mask: 0xfff) */
/* ======================================================  dmac_chcfg  ======================================================= */
#define dmac_app_ch_dmac_chcfg_reserved2_Pos (19UL)                 /*!< dmac_app_ch dmac_chcfg: reserved2 (Bit 19)            */
#define dmac_app_ch_dmac_chcfg_reserved2_Msk (0xfff80000UL)         /*!< dmac_app_ch dmac_chcfg: reserved2 (Bitfield-Mask: 0x1fff) */
#define dmac_app_ch_dmac_chcfg_H_Pos      (18UL)                    /*!< dmac_app_ch dmac_chcfg: H (Bit 18)                    */
#define dmac_app_ch_dmac_chcfg_H_Msk      (0x40000UL)               /*!< dmac_app_ch dmac_chcfg: H (Bitfield-Mask: 0x01)       */
#define dmac_app_ch_dmac_chcfg_A_Pos      (17UL)                    /*!< dmac_app_ch dmac_chcfg: A (Bit 17)                    */
#define dmac_app_ch_dmac_chcfg_A_Msk      (0x20000UL)               /*!< dmac_app_ch dmac_chcfg: A (Bitfield-Mask: 0x01)       */
#define dmac_app_ch_dmac_chcfg_L_Pos      (16UL)                    /*!< dmac_app_ch dmac_chcfg: L (Bit 16)                    */
#define dmac_app_ch_dmac_chcfg_L_Msk      (0x10000UL)               /*!< dmac_app_ch dmac_chcfg: L (Bitfield-Mask: 0x01)       */
#define dmac_app_ch_dmac_chcfg_ITC_Pos    (15UL)                    /*!< dmac_app_ch dmac_chcfg: ITC (Bit 15)                  */
#define dmac_app_ch_dmac_chcfg_ITC_Msk    (0x8000UL)                /*!< dmac_app_ch dmac_chcfg: ITC (Bitfield-Mask: 0x01)     */
#define dmac_app_ch_dmac_chcfg_IE_Pos     (14UL)                    /*!< dmac_app_ch dmac_chcfg: IE (Bit 14)                   */
#define dmac_app_ch_dmac_chcfg_IE_Msk     (0x4000UL)                /*!< dmac_app_ch dmac_chcfg: IE (Bitfield-Mask: 0x01)      */
#define dmac_app_ch_dmac_chcfg_FlowCntrl_Pos (11UL)                 /*!< dmac_app_ch dmac_chcfg: FlowCntrl (Bit 11)            */
#define dmac_app_ch_dmac_chcfg_FlowCntrl_Msk (0x3800UL)             /*!< dmac_app_ch dmac_chcfg: FlowCntrl (Bitfield-Mask: 0x07) */
#define dmac_app_ch_dmac_chcfg_reserved1_Pos (10UL)                 /*!< dmac_app_ch dmac_chcfg: reserved1 (Bit 10)            */
#define dmac_app_ch_dmac_chcfg_reserved1_Msk (0x400UL)              /*!< dmac_app_ch dmac_chcfg: reserved1 (Bitfield-Mask: 0x01) */
#define dmac_app_ch_dmac_chcfg_DestPeripheral_Pos (6UL)             /*!< dmac_app_ch dmac_chcfg: DestPeripheral (Bit 6)        */
#define dmac_app_ch_dmac_chcfg_DestPeripheral_Msk (0x3c0UL)         /*!< dmac_app_ch dmac_chcfg: DestPeripheral (Bitfield-Mask: 0x0f) */
#define dmac_app_ch_dmac_chcfg_reserved0_Pos (5UL)                  /*!< dmac_app_ch dmac_chcfg: reserved0 (Bit 5)             */
#define dmac_app_ch_dmac_chcfg_reserved0_Msk (0x20UL)               /*!< dmac_app_ch dmac_chcfg: reserved0 (Bitfield-Mask: 0x01) */
#define dmac_app_ch_dmac_chcfg_SrcPeripheral_Pos (1UL)              /*!< dmac_app_ch dmac_chcfg: SrcPeripheral (Bit 1)         */
#define dmac_app_ch_dmac_chcfg_SrcPeripheral_Msk (0x1eUL)           /*!< dmac_app_ch dmac_chcfg: SrcPeripheral (Bitfield-Mask: 0x0f) */
#define dmac_app_ch_dmac_chcfg_E_Pos      (0UL)                     /*!< dmac_app_ch dmac_chcfg: E (Bit 0)                     */
#define dmac_app_ch_dmac_chcfg_E_Msk      (0x1UL)                   /*!< dmac_app_ch dmac_chcfg: E (Bitfield-Mask: 0x01)       */


/* =========================================================================================================================== */
/* ================                                       dmac_app_reg                                        ================ */
/* =========================================================================================================================== */

/* ====================================================  dmac_int_status  ==================================================== */
#define dmac_app_reg_dmac_int_status_DMACINT_ch2_Pos (2UL)          /*!< dmac_app_reg dmac_int_status: DMACINT_ch2 (Bit 2)     */
#define dmac_app_reg_dmac_int_status_DMACINT_ch2_Msk (0x4UL)        /*!< dmac_app_reg dmac_int_status: DMACINT_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_int_status_DMACINT_ch1_Pos (1UL)          /*!< dmac_app_reg dmac_int_status: DMACINT_ch1 (Bit 1)     */
#define dmac_app_reg_dmac_int_status_DMACINT_ch1_Msk (0x2UL)        /*!< dmac_app_reg dmac_int_status: DMACINT_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_int_status_DMACINT_ch0_Pos (0UL)          /*!< dmac_app_reg dmac_int_status: DMACINT_ch0 (Bit 0)     */
#define dmac_app_reg_dmac_int_status_DMACINT_ch0_Msk (0x1UL)        /*!< dmac_app_reg dmac_int_status: DMACINT_ch0 (Bitfield-Mask: 0x01) */
/* ===================================================  dmac_inttc_status  =================================================== */
#define dmac_app_reg_dmac_inttc_status_DMACINTTC_ch2_Pos (2UL)      /*!< dmac_app_reg dmac_inttc_status: DMACINTTC_ch2 (Bit 2) */
#define dmac_app_reg_dmac_inttc_status_DMACINTTC_ch2_Msk (0x4UL)    /*!< dmac_app_reg dmac_inttc_status: DMACINTTC_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_inttc_status_DMACINTTC_ch1_Pos (1UL)      /*!< dmac_app_reg dmac_inttc_status: DMACINTTC_ch1 (Bit 1) */
#define dmac_app_reg_dmac_inttc_status_DMACINTTC_ch1_Msk (0x2UL)    /*!< dmac_app_reg dmac_inttc_status: DMACINTTC_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_inttc_status_DMACINTTC_ch0_Pos (0UL)      /*!< dmac_app_reg dmac_inttc_status: DMACINTTC_ch0 (Bit 0) */
#define dmac_app_reg_dmac_inttc_status_DMACINTTC_ch0_Msk (0x1UL)    /*!< dmac_app_reg dmac_inttc_status: DMACINTTC_ch0 (Bitfield-Mask: 0x01) */
/* ===================================================  dmac_inttc_clear  ==================================================== */
#define dmac_app_reg_dmac_inttc_clear_DMACINTTCCLR_ch2_Pos (2UL)    /*!< dmac_app_reg dmac_inttc_clear: DMACINTTCCLR_ch2 (Bit 2) */
#define dmac_app_reg_dmac_inttc_clear_DMACINTTCCLR_ch2_Msk (0x4UL)  /*!< dmac_app_reg dmac_inttc_clear: DMACINTTCCLR_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_inttc_clear_DMACINTTCCLR_ch1_Pos (1UL)    /*!< dmac_app_reg dmac_inttc_clear: DMACINTTCCLR_ch1 (Bit 1) */
#define dmac_app_reg_dmac_inttc_clear_DMACINTTCCLR_ch1_Msk (0x2UL)  /*!< dmac_app_reg dmac_inttc_clear: DMACINTTCCLR_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_inttc_clear_DMACINTTCCLR_ch0_Pos (0UL)    /*!< dmac_app_reg dmac_inttc_clear: DMACINTTCCLR_ch0 (Bit 0) */
#define dmac_app_reg_dmac_inttc_clear_DMACINTTCCLR_ch0_Msk (0x1UL)  /*!< dmac_app_reg dmac_inttc_clear: DMACINTTCCLR_ch0 (Bitfield-Mask: 0x01) */
/* ==================================================  dmac_interr_status  =================================================== */
#define dmac_app_reg_dmac_interr_status_DMACINTERR_ch2_Pos (2UL)    /*!< dmac_app_reg dmac_interr_status: DMACINTERR_ch2 (Bit 2) */
#define dmac_app_reg_dmac_interr_status_DMACINTERR_ch2_Msk (0x4UL)  /*!< dmac_app_reg dmac_interr_status: DMACINTERR_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_interr_status_DMACINTERR_ch1_Pos (1UL)    /*!< dmac_app_reg dmac_interr_status: DMACINTERR_ch1 (Bit 1) */
#define dmac_app_reg_dmac_interr_status_DMACINTERR_ch1_Msk (0x2UL)  /*!< dmac_app_reg dmac_interr_status: DMACINTERR_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_interr_status_DMACINTERR_ch0_Pos (0UL)    /*!< dmac_app_reg dmac_interr_status: DMACINTERR_ch0 (Bit 0) */
#define dmac_app_reg_dmac_interr_status_DMACINTERR_ch0_Msk (0x1UL)  /*!< dmac_app_reg dmac_interr_status: DMACINTERR_ch0 (Bitfield-Mask: 0x01) */
/* ===================================================  dmac_interr_clear  =================================================== */
#define dmac_app_reg_dmac_interr_clear_DMACINTERRCLR_ch2_Pos (2UL)  /*!< dmac_app_reg dmac_interr_clear: DMACINTERRCLR_ch2 (Bit 2) */
#define dmac_app_reg_dmac_interr_clear_DMACINTERRCLR_ch2_Msk (0x4UL) /*!< dmac_app_reg dmac_interr_clear: DMACINTERRCLR_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_interr_clear_DMACINTERRCLR_ch1_Pos (1UL)  /*!< dmac_app_reg dmac_interr_clear: DMACINTERRCLR_ch1 (Bit 1) */
#define dmac_app_reg_dmac_interr_clear_DMACINTERRCLR_ch1_Msk (0x2UL) /*!< dmac_app_reg dmac_interr_clear: DMACINTERRCLR_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_interr_clear_DMACINTERRCLR_ch0_Pos (0UL)  /*!< dmac_app_reg dmac_interr_clear: DMACINTERRCLR_ch0 (Bit 0) */
#define dmac_app_reg_dmac_interr_clear_DMACINTERRCLR_ch0_Msk (0x1UL) /*!< dmac_app_reg dmac_interr_clear: DMACINTERRCLR_ch0 (Bitfield-Mask: 0x01) */
/* =================================================  dmac_rawinttc_status  ================================================== */
#define dmac_app_reg_dmac_rawinttc_status_DMACRAWINTTC_ch2_Pos (2UL) /*!< dmac_app_reg dmac_rawinttc_status: DMACRAWINTTC_ch2 (Bit 2) */
#define dmac_app_reg_dmac_rawinttc_status_DMACRAWINTTC_ch2_Msk (0x4UL) /*!< dmac_app_reg dmac_rawinttc_status: DMACRAWINTTC_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_rawinttc_status_DMACRAWINTTC_ch1_Pos (1UL) /*!< dmac_app_reg dmac_rawinttc_status: DMACRAWINTTC_ch1 (Bit 1) */
#define dmac_app_reg_dmac_rawinttc_status_DMACRAWINTTC_ch1_Msk (0x2UL) /*!< dmac_app_reg dmac_rawinttc_status: DMACRAWINTTC_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_rawinttc_status_DMACRAWINTTC_ch0_Pos (0UL) /*!< dmac_app_reg dmac_rawinttc_status: DMACRAWINTTC_ch0 (Bit 0) */
#define dmac_app_reg_dmac_rawinttc_status_DMACRAWINTTC_ch0_Msk (0x1UL) /*!< dmac_app_reg dmac_rawinttc_status: DMACRAWINTTC_ch0 (Bitfield-Mask: 0x01) */
/* =================================================  dmac_rawinterr_status  ================================================= */
#define dmac_app_reg_dmac_rawinterr_status_DMACRAWINTERR_ch2_Pos (2UL) /*!< dmac_app_reg dmac_rawinterr_status: DMACRAWINTERR_ch2 (Bit 2) */
#define dmac_app_reg_dmac_rawinterr_status_DMACRAWINTERR_ch2_Msk (0x4UL) /*!< dmac_app_reg dmac_rawinterr_status: DMACRAWINTERR_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_rawinterr_status_DMACRAWINTERR_ch1_Pos (1UL) /*!< dmac_app_reg dmac_rawinterr_status: DMACRAWINTERR_ch1 (Bit 1) */
#define dmac_app_reg_dmac_rawinterr_status_DMACRAWINTERR_ch1_Msk (0x2UL) /*!< dmac_app_reg dmac_rawinterr_status: DMACRAWINTERR_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_rawinterr_status_DMACRAWINTERR_ch0_Pos (0UL) /*!< dmac_app_reg dmac_rawinterr_status: DMACRAWINTERR_ch0 (Bit 0) */
#define dmac_app_reg_dmac_rawinterr_status_DMACRAWINTERR_ch0_Msk (0x1UL) /*!< dmac_app_reg dmac_rawinterr_status: DMACRAWINTERR_ch0 (Bitfield-Mask: 0x01) */
/* =================================================  dmac_enabled_channel  ================================================== */
#define dmac_app_reg_dmac_enabled_channel_DMACENABLEDCHNS_ch2_Pos (2UL) /*!< dmac_app_reg dmac_enabled_channel: DMACENABLEDCHNS_ch2 (Bit 2) */
#define dmac_app_reg_dmac_enabled_channel_DMACENABLEDCHNS_ch2_Msk (0x4UL) /*!< dmac_app_reg dmac_enabled_channel: DMACENABLEDCHNS_ch2 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_enabled_channel_DMACENABLEDCHNS_ch1_Pos (1UL) /*!< dmac_app_reg dmac_enabled_channel: DMACENABLEDCHNS_ch1 (Bit 1) */
#define dmac_app_reg_dmac_enabled_channel_DMACENABLEDCHNS_ch1_Msk (0x2UL) /*!< dmac_app_reg dmac_enabled_channel: DMACENABLEDCHNS_ch1 (Bitfield-Mask: 0x01) */
#define dmac_app_reg_dmac_enabled_channel_DMACENABLEDCHNS_ch0_Pos (0UL) /*!< dmac_app_reg dmac_enabled_channel: DMACENABLEDCHNS_ch0 (Bit 0) */
#define dmac_app_reg_dmac_enabled_channel_DMACENABLEDCHNS_ch0_Msk (0x1UL) /*!< dmac_app_reg dmac_enabled_channel: DMACENABLEDCHNS_ch0 (Bitfield-Mask: 0x01) */
/* ====================================================  dmac_softb_req  ===================================================== */
#define dmac_app_reg_dmac_softb_req_DMACSoftBReq_Pos (0UL)          /*!< dmac_app_reg dmac_softb_req: DMACSoftBReq (Bit 0)     */
#define dmac_app_reg_dmac_softb_req_DMACSoftBReq_Msk (0xffffUL)     /*!< dmac_app_reg dmac_softb_req: DMACSoftBReq (Bitfield-Mask: 0xffff) */
/* ====================================================  dmac_softs_req  ===================================================== */
#define dmac_app_reg_dmac_softs_req_DMACSoftSReq_Pos (0UL)          /*!< dmac_app_reg dmac_softs_req: DMACSoftSReq (Bit 0)     */
#define dmac_app_reg_dmac_softs_req_DMACSoftSReq_Msk (0xffffUL)     /*!< dmac_app_reg dmac_softs_req: DMACSoftSReq (Bitfield-Mask: 0xffff) */
/* ====================================================  dmac_softlb_req  ==================================================== */
#define dmac_app_reg_dmac_softlb_req_DMACSoftLBReq_Pos (0UL)        /*!< dmac_app_reg dmac_softlb_req: DMACSoftLBReq (Bit 0)   */
#define dmac_app_reg_dmac_softlb_req_DMACSoftLBReq_Msk (0xffffUL)   /*!< dmac_app_reg dmac_softlb_req: DMACSoftLBReq (Bitfield-Mask: 0xffff) */
/* ====================================================  dmac_softls_req  ==================================================== */
#define dmac_app_reg_dmac_softls_req_DMACSoftLSReq_Pos (0UL)        /*!< dmac_app_reg dmac_softls_req: DMACSoftLSReq (Bit 0)   */
#define dmac_app_reg_dmac_softls_req_DMACSoftLSReq_Msk (0xffffUL)   /*!< dmac_app_reg dmac_softls_req: DMACSoftLSReq (Bitfield-Mask: 0xffff) */
/* ======================================================  dmac_config  ====================================================== */
#define dmac_app_reg_dmac_config_DMACENABLE_Pos (0UL)               /*!< dmac_app_reg dmac_config: DMACENABLE (Bit 0)          */
#define dmac_app_reg_dmac_config_DMACENABLE_Msk (0x1UL)             /*!< dmac_app_reg dmac_config: DMACENABLE (Bitfield-Mask: 0x01) */
/* =======================================================  dmac_sync  ======================================================= */
#define dmac_app_reg_dmac_sync_DIS_SYNC_Pos (0UL)                   /*!< dmac_app_reg dmac_sync: DIS_SYNC (Bit 0)              */
#define dmac_app_reg_dmac_sync_DIS_SYNC_Msk (0xffffUL)              /*!< dmac_app_reg dmac_sync: DIS_SYNC (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                       dmac_mux_app                                        ================ */
/* =========================================================================================================================== */

/* ============================================  dmac_mux_peripheral_input_sel0  ============================================= */
#define dmac_mux_app_dmac_mux_peripheral_input_sel0_index_Pos (0UL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel0: index (Bit 0) */
#define dmac_mux_app_dmac_mux_peripheral_input_sel0_index_Msk (0x3fUL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel0: index (Bitfield-Mask: 0x3f) */
/* ============================================  dmac_mux_peripheral_input_sel1  ============================================= */
#define dmac_mux_app_dmac_mux_peripheral_input_sel1_index_Pos (0UL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel1: index (Bit 0) */
#define dmac_mux_app_dmac_mux_peripheral_input_sel1_index_Msk (0x3fUL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel1: index (Bitfield-Mask: 0x3f) */
/* ============================================  dmac_mux_peripheral_input_sel2  ============================================= */
#define dmac_mux_app_dmac_mux_peripheral_input_sel2_index_Pos (0UL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel2: index (Bit 0) */
#define dmac_mux_app_dmac_mux_peripheral_input_sel2_index_Msk (0x3fUL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel2: index (Bitfield-Mask: 0x3f) */
/* ============================================  dmac_mux_peripheral_input_sel3  ============================================= */
#define dmac_mux_app_dmac_mux_peripheral_input_sel3_index_Pos (0UL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel3: index (Bit 0) */
#define dmac_mux_app_dmac_mux_peripheral_input_sel3_index_Msk (0x3fUL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel3: index (Bitfield-Mask: 0x3f) */
/* ============================================  dmac_mux_peripheral_input_sel4  ============================================= */
#define dmac_mux_app_dmac_mux_peripheral_input_sel4_index_Pos (0UL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel4: index (Bit 0) */
#define dmac_mux_app_dmac_mux_peripheral_input_sel4_index_Msk (0x3fUL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel4: index (Bitfield-Mask: 0x3f) */
/* ============================================  dmac_mux_peripheral_input_sel5  ============================================= */
#define dmac_mux_app_dmac_mux_peripheral_input_sel5_index_Pos (0UL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel5: index (Bit 0) */
#define dmac_mux_app_dmac_mux_peripheral_input_sel5_index_Msk (0x3fUL) /*!< dmac_mux_app dmac_mux_peripheral_input_sel5: index (Bitfield-Mask: 0x3f) */


/* =========================================================================================================================== */
/* ================                                         uart_app                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  uartdr  ========================================================= */
#define uart_app_uartdr_BE_Pos            (10UL)                    /*!< uart_app uartdr: BE (Bit 10)                          */
#define uart_app_uartdr_BE_Msk            (0x400UL)                 /*!< uart_app uartdr: BE (Bitfield-Mask: 0x01)             */
#define uart_app_uartdr_PE_Pos            (9UL)                     /*!< uart_app uartdr: PE (Bit 9)                           */
#define uart_app_uartdr_PE_Msk            (0x200UL)                 /*!< uart_app uartdr: PE (Bitfield-Mask: 0x01)             */
#define uart_app_uartdr_FE_Pos            (8UL)                     /*!< uart_app uartdr: FE (Bit 8)                           */
#define uart_app_uartdr_FE_Msk            (0x100UL)                 /*!< uart_app uartdr: FE (Bitfield-Mask: 0x01)             */
#define uart_app_uartdr_DATA_Pos          (0UL)                     /*!< uart_app uartdr: DATA (Bit 0)                         */
#define uart_app_uartdr_DATA_Msk          (0xffUL)                  /*!< uart_app uartdr: DATA (Bitfield-Mask: 0xff)           */
/* ========================================================  uartrsr  ======================================================== */
#define uart_app_uartrsr_OE_Pos           (3UL)                     /*!< uart_app uartrsr: OE (Bit 3)                          */
#define uart_app_uartrsr_OE_Msk           (0x8UL)                   /*!< uart_app uartrsr: OE (Bitfield-Mask: 0x01)            */
#define uart_app_uartrsr_BE_Pos           (2UL)                     /*!< uart_app uartrsr: BE (Bit 2)                          */
#define uart_app_uartrsr_BE_Msk           (0x4UL)                   /*!< uart_app uartrsr: BE (Bitfield-Mask: 0x01)            */
#define uart_app_uartrsr_PE_Pos           (1UL)                     /*!< uart_app uartrsr: PE (Bit 1)                          */
#define uart_app_uartrsr_PE_Msk           (0x2UL)                   /*!< uart_app uartrsr: PE (Bitfield-Mask: 0x01)            */
#define uart_app_uartrsr_FE_Pos           (0UL)                     /*!< uart_app uartrsr: FE (Bit 0)                          */
#define uart_app_uartrsr_FE_Msk           (0x1UL)                   /*!< uart_app uartrsr: FE (Bitfield-Mask: 0x01)            */
/* =======================================================  uartlcr_h  ======================================================= */
#define uart_app_uartlcr_h_WLEN_Pos       (5UL)                     /*!< uart_app uartlcr_h: WLEN (Bit 5)                      */
#define uart_app_uartlcr_h_WLEN_Msk       (0x60UL)                  /*!< uart_app uartlcr_h: WLEN (Bitfield-Mask: 0x03)        */
#define uart_app_uartlcr_h_FEN_Pos        (4UL)                     /*!< uart_app uartlcr_h: FEN (Bit 4)                       */
#define uart_app_uartlcr_h_FEN_Msk        (0x10UL)                  /*!< uart_app uartlcr_h: FEN (Bitfield-Mask: 0x01)         */
#define uart_app_uartlcr_h_STP2_Pos       (3UL)                     /*!< uart_app uartlcr_h: STP2 (Bit 3)                      */
#define uart_app_uartlcr_h_STP2_Msk       (0x8UL)                   /*!< uart_app uartlcr_h: STP2 (Bitfield-Mask: 0x01)        */
#define uart_app_uartlcr_h_EPS_Pos        (2UL)                     /*!< uart_app uartlcr_h: EPS (Bit 2)                       */
#define uart_app_uartlcr_h_EPS_Msk        (0x4UL)                   /*!< uart_app uartlcr_h: EPS (Bitfield-Mask: 0x01)         */
#define uart_app_uartlcr_h_PEN_Pos        (1UL)                     /*!< uart_app uartlcr_h: PEN (Bit 1)                       */
#define uart_app_uartlcr_h_PEN_Msk        (0x2UL)                   /*!< uart_app uartlcr_h: PEN (Bitfield-Mask: 0x01)         */
#define uart_app_uartlcr_h_BRK_Pos        (0UL)                     /*!< uart_app uartlcr_h: BRK (Bit 0)                       */
#define uart_app_uartlcr_h_BRK_Msk        (0x1UL)                   /*!< uart_app uartlcr_h: BRK (Bitfield-Mask: 0x01)         */
/* =======================================================  uartlcr_m  ======================================================= */
#define uart_app_uartlcr_m_BAUDDIVMS_Pos  (0UL)                     /*!< uart_app uartlcr_m: BAUDDIVMS (Bit 0)                 */
#define uart_app_uartlcr_m_BAUDDIVMS_Msk  (0xffUL)                  /*!< uart_app uartlcr_m: BAUDDIVMS (Bitfield-Mask: 0xff)   */
/* =======================================================  uartlcr_l  ======================================================= */
#define uart_app_uartlcr_l_BAUDDIVLS_Pos  (0UL)                     /*!< uart_app uartlcr_l: BAUDDIVLS (Bit 0)                 */
#define uart_app_uartlcr_l_BAUDDIVLS_Msk  (0xffUL)                  /*!< uart_app uartlcr_l: BAUDDIVLS (Bitfield-Mask: 0xff)   */
/* ========================================================  uartcr  ========================================================= */
#define uart_app_uartcr_TX_RX_LOOP_Pos    (8UL)                     /*!< uart_app uartcr: TX_RX_LOOP (Bit 8)                   */
#define uart_app_uartcr_TX_RX_LOOP_Msk    (0x100UL)                 /*!< uart_app uartcr: TX_RX_LOOP (Bitfield-Mask: 0x01)     */
#define uart_app_uartcr_LBE_Pos           (7UL)                     /*!< uart_app uartcr: LBE (Bit 7)                          */
#define uart_app_uartcr_LBE_Msk           (0x80UL)                  /*!< uart_app uartcr: LBE (Bitfield-Mask: 0x01)            */
#define uart_app_uartcr_RTIE_Pos          (6UL)                     /*!< uart_app uartcr: RTIE (Bit 6)                         */
#define uart_app_uartcr_RTIE_Msk          (0x40UL)                  /*!< uart_app uartcr: RTIE (Bitfield-Mask: 0x01)           */
#define uart_app_uartcr_TIE_Pos           (5UL)                     /*!< uart_app uartcr: TIE (Bit 5)                          */
#define uart_app_uartcr_TIE_Msk           (0x20UL)                  /*!< uart_app uartcr: TIE (Bitfield-Mask: 0x01)            */
#define uart_app_uartcr_RIE_Pos           (4UL)                     /*!< uart_app uartcr: RIE (Bit 4)                          */
#define uart_app_uartcr_RIE_Msk           (0x10UL)                  /*!< uart_app uartcr: RIE (Bitfield-Mask: 0x01)            */
#define uart_app_uartcr_MSIE_Pos          (3UL)                     /*!< uart_app uartcr: MSIE (Bit 3)                         */
#define uart_app_uartcr_MSIE_Msk          (0x8UL)                   /*!< uart_app uartcr: MSIE (Bitfield-Mask: 0x01)           */
#define uart_app_uartcr_SIRLP_Pos         (2UL)                     /*!< uart_app uartcr: SIRLP (Bit 2)                        */
#define uart_app_uartcr_SIRLP_Msk         (0x4UL)                   /*!< uart_app uartcr: SIRLP (Bitfield-Mask: 0x01)          */
#define uart_app_uartcr_SIREN_Pos         (1UL)                     /*!< uart_app uartcr: SIREN (Bit 1)                        */
#define uart_app_uartcr_SIREN_Msk         (0x2UL)                   /*!< uart_app uartcr: SIREN (Bitfield-Mask: 0x01)          */
#define uart_app_uartcr_uartEN_Pos        (0UL)                     /*!< uart_app uartcr: uartEN (Bit 0)                       */
#define uart_app_uartcr_uartEN_Msk        (0x1UL)                   /*!< uart_app uartcr: uartEN (Bitfield-Mask: 0x01)         */
/* ========================================================  uartfr  ========================================================= */
#define uart_app_uartfr_TXFE_Pos          (7UL)                     /*!< uart_app uartfr: TXFE (Bit 7)                         */
#define uart_app_uartfr_TXFE_Msk          (0x80UL)                  /*!< uart_app uartfr: TXFE (Bitfield-Mask: 0x01)           */
#define uart_app_uartfr_RXFF_Pos          (6UL)                     /*!< uart_app uartfr: RXFF (Bit 6)                         */
#define uart_app_uartfr_RXFF_Msk          (0x40UL)                  /*!< uart_app uartfr: RXFF (Bitfield-Mask: 0x01)           */
#define uart_app_uartfr_TXFF_Pos          (5UL)                     /*!< uart_app uartfr: TXFF (Bit 5)                         */
#define uart_app_uartfr_TXFF_Msk          (0x20UL)                  /*!< uart_app uartfr: TXFF (Bitfield-Mask: 0x01)           */
#define uart_app_uartfr_RXFE_Pos          (4UL)                     /*!< uart_app uartfr: RXFE (Bit 4)                         */
#define uart_app_uartfr_RXFE_Msk          (0x10UL)                  /*!< uart_app uartfr: RXFE (Bitfield-Mask: 0x01)           */
#define uart_app_uartfr_BUSY_Pos          (3UL)                     /*!< uart_app uartfr: BUSY (Bit 3)                         */
#define uart_app_uartfr_BUSY_Msk          (0x8UL)                   /*!< uart_app uartfr: BUSY (Bitfield-Mask: 0x01)           */
#define uart_app_uartfr_DCD_Pos           (2UL)                     /*!< uart_app uartfr: DCD (Bit 2)                          */
#define uart_app_uartfr_DCD_Msk           (0x4UL)                   /*!< uart_app uartfr: DCD (Bitfield-Mask: 0x01)            */
#define uart_app_uartfr_DSR_Pos           (1UL)                     /*!< uart_app uartfr: DSR (Bit 1)                          */
#define uart_app_uartfr_DSR_Msk           (0x2UL)                   /*!< uart_app uartfr: DSR (Bitfield-Mask: 0x01)            */
#define uart_app_uartfr_CTS_Pos           (0UL)                     /*!< uart_app uartfr: CTS (Bit 0)                          */
#define uart_app_uartfr_CTS_Msk           (0x1UL)                   /*!< uart_app uartfr: CTS (Bitfield-Mask: 0x01)            */
/* ========================================================  uartiir  ======================================================== */
#define uart_app_uartiir_RTIS_Pos         (3UL)                     /*!< uart_app uartiir: RTIS (Bit 3)                        */
#define uart_app_uartiir_RTIS_Msk         (0x8UL)                   /*!< uart_app uartiir: RTIS (Bitfield-Mask: 0x01)          */
#define uart_app_uartiir_TIS_Pos          (2UL)                     /*!< uart_app uartiir: TIS (Bit 2)                         */
#define uart_app_uartiir_TIS_Msk          (0x4UL)                   /*!< uart_app uartiir: TIS (Bitfield-Mask: 0x01)           */
#define uart_app_uartiir_RIS_Pos          (1UL)                     /*!< uart_app uartiir: RIS (Bit 1)                         */
#define uart_app_uartiir_RIS_Msk          (0x2UL)                   /*!< uart_app uartiir: RIS (Bitfield-Mask: 0x01)           */
#define uart_app_uartiir_MIS_Pos          (0UL)                     /*!< uart_app uartiir: MIS (Bit 0)                         */
#define uart_app_uartiir_MIS_Msk          (0x1UL)                   /*!< uart_app uartiir: MIS (Bitfield-Mask: 0x01)           */
/* =======================================================  uartilpr  ======================================================== */
#define uart_app_uartilpr_ILPDVSR_Pos     (0UL)                     /*!< uart_app uartilpr: ILPDVSR (Bit 0)                    */
#define uart_app_uartilpr_ILPDVSR_Msk     (0xffUL)                  /*!< uart_app uartilpr: ILPDVSR (Bitfield-Mask: 0xff)      */
/* ========================================================  uartrts  ======================================================== */
#define uart_app_uartrts_STICK_Pos        (7UL)                     /*!< uart_app uartrts: STICK (Bit 7)                       */
#define uart_app_uartrts_STICK_Msk        (0x80UL)                  /*!< uart_app uartrts: STICK (Bitfield-Mask: 0x01)         */
#define uart_app_uartrts_CTS_pol_Pos      (6UL)                     /*!< uart_app uartrts: CTS_pol (Bit 6)                     */
#define uart_app_uartrts_CTS_pol_Msk      (0x40UL)                  /*!< uart_app uartrts: CTS_pol (Bitfield-Mask: 0x01)       */
#define uart_app_uartrts_CTS_ctr_Pos      (5UL)                     /*!< uart_app uartrts: CTS_ctr (Bit 5)                     */
#define uart_app_uartrts_CTS_ctr_Msk      (0x20UL)                  /*!< uart_app uartrts: CTS_ctr (Bitfield-Mask: 0x01)       */
#define uart_app_uartrts_RTS_pol_Pos      (4UL)                     /*!< uart_app uartrts: RTS_pol (Bit 4)                     */
#define uart_app_uartrts_RTS_pol_Msk      (0x10UL)                  /*!< uart_app uartrts: RTS_pol (Bitfield-Mask: 0x01)       */
#define uart_app_uartrts_MOD2_Pos         (3UL)                     /*!< uart_app uartrts: MOD2 (Bit 3)                        */
#define uart_app_uartrts_MOD2_Msk         (0x8UL)                   /*!< uart_app uartrts: MOD2 (Bitfield-Mask: 0x01)          */
#define uart_app_uartrts_COUNT_Pos        (2UL)                     /*!< uart_app uartrts: COUNT (Bit 2)                       */
#define uart_app_uartrts_COUNT_Msk        (0x4UL)                   /*!< uart_app uartrts: COUNT (Bitfield-Mask: 0x01)         */
#define uart_app_uartrts_RTS_Pos          (1UL)                     /*!< uart_app uartrts: RTS (Bit 1)                         */
#define uart_app_uartrts_RTS_Msk          (0x2UL)                   /*!< uart_app uartrts: RTS (Bitfield-Mask: 0x01)           */
#define uart_app_uartrts_AUTO_Pos         (0UL)                     /*!< uart_app uartrts: AUTO (Bit 0)                        */
#define uart_app_uartrts_AUTO_Msk         (0x1UL)                   /*!< uart_app uartrts: AUTO (Bitfield-Mask: 0x01)          */
/* ======================================================  uartforerun  ====================================================== */
#define uart_app_uartforerun_FORERUN_Pos  (0UL)                     /*!< uart_app uartforerun: FORERUN (Bit 0)                 */
#define uart_app_uartforerun_FORERUN_Msk  (0xffUL)                  /*!< uart_app uartforerun: FORERUN (Bitfield-Mask: 0xff)   */
/* =======================================================  uarttrail  ======================================================= */
#define uart_app_uarttrail_TRAIL_Pos      (0UL)                     /*!< uart_app uarttrail: TRAIL (Bit 0)                     */
#define uart_app_uarttrail_TRAIL_Msk      (0xffUL)                  /*!< uart_app uarttrail: TRAIL (Bitfield-Mask: 0xff)       */
/* ======================================================  uartdrvout  ======================================================= */
#define uart_app_uartdrvout_DRVRTS_Pos    (1UL)                     /*!< uart_app uartdrvout: DRVRTS (Bit 1)                   */
#define uart_app_uartdrvout_DRVRTS_Msk    (0x2UL)                   /*!< uart_app uartdrvout: DRVRTS (Bitfield-Mask: 0x01)     */
#define uart_app_uartdrvout_DRVTX_Pos     (0UL)                     /*!< uart_app uartdrvout: DRVTX (Bit 0)                    */
#define uart_app_uartdrvout_DRVTX_Msk     (0x1UL)                   /*!< uart_app uartdrvout: DRVTX (Bitfield-Mask: 0x01)      */
/* =======================================================  uartcr_2  ======================================================== */
#define uart_app_uartcr_2_Baud_Rate_Mode_Pos (0UL)                  /*!< uart_app uartcr_2: Baud_Rate_Mode (Bit 0)             */
#define uart_app_uartcr_2_Baud_Rate_Mode_Msk (0x1UL)                /*!< uart_app uartcr_2: Baud_Rate_Mode (Bitfield-Mask: 0x01) */
/* =====================================================  uartrxiflsel  ====================================================== */
#define uart_app_uartrxiflsel_RXDMA_Pos   (5UL)                     /*!< uart_app uartrxiflsel: RXDMA (Bit 5)                  */
#define uart_app_uartrxiflsel_RXDMA_Msk   (0x20UL)                  /*!< uart_app uartrxiflsel: RXDMA (Bitfield-Mask: 0x01)    */
#define uart_app_uartrxiflsel_RXIFLSEL_Pos (0UL)                    /*!< uart_app uartrxiflsel: RXIFLSEL (Bit 0)               */
#define uart_app_uartrxiflsel_RXIFLSEL_Msk (0x1fUL)                 /*!< uart_app uartrxiflsel: RXIFLSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  uarttxiflsel  ====================================================== */
#define uart_app_uarttxiflsel_TXDMA_Pos   (5UL)                     /*!< uart_app uarttxiflsel: TXDMA (Bit 5)                  */
#define uart_app_uarttxiflsel_TXDMA_Msk   (0x20UL)                  /*!< uart_app uarttxiflsel: TXDMA (Bitfield-Mask: 0x01)    */
#define uart_app_uarttxiflsel_TXIFLSEL_Pos (0UL)                    /*!< uart_app uarttxiflsel: TXIFLSEL (Bit 0)               */
#define uart_app_uarttxiflsel_TXIFLSEL_Msk (0x1fUL)                 /*!< uart_app uarttxiflsel: TXIFLSEL (Bitfield-Mask: 0x1f) */


/* =========================================================================================================================== */
/* ================                                          i2c_app                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  i2c_mcr  ======================================================== */
#define i2c_app_i2c_mcr_reserved1_Pos     (19UL)                    /*!< i2c_app i2c_mcr: reserved1 (Bit 19)                   */
#define i2c_app_i2c_mcr_reserved1_Msk     (0xfff80000UL)            /*!< i2c_app i2c_mcr: reserved1 (Bitfield-Mask: 0x1fff)    */
#define i2c_app_i2c_mcr_en_timeout_Pos    (18UL)                    /*!< i2c_app i2c_mcr: en_timeout (Bit 18)                  */
#define i2c_app_i2c_mcr_en_timeout_Msk    (0x40000UL)               /*!< i2c_app i2c_mcr: en_timeout (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_mcr_rst_i2c_Pos       (17UL)                    /*!< i2c_app i2c_mcr: rst_i2c (Bit 17)                     */
#define i2c_app_i2c_mcr_rst_i2c_Msk       (0x20000UL)               /*!< i2c_app i2c_mcr: rst_i2c (Bitfield-Mask: 0x01)        */
#define i2c_app_i2c_mcr_pio_mode_Pos      (16UL)                    /*!< i2c_app i2c_mcr: pio_mode (Bit 16)                    */
#define i2c_app_i2c_mcr_pio_mode_Msk      (0x10000UL)               /*!< i2c_app i2c_mcr: pio_mode (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_mcr_reserved0_Pos     (11UL)                    /*!< i2c_app i2c_mcr: reserved0 (Bit 11)                   */
#define i2c_app_i2c_mcr_reserved0_Msk     (0xf800UL)                /*!< i2c_app i2c_mcr: reserved0 (Bitfield-Mask: 0x1f)      */
#define i2c_app_i2c_mcr_sadr_Pos          (4UL)                     /*!< i2c_app i2c_mcr: sadr (Bit 4)                         */
#define i2c_app_i2c_mcr_sadr_Msk          (0x7f0UL)                 /*!< i2c_app i2c_mcr: sadr (Bitfield-Mask: 0x7f)           */
#define i2c_app_i2c_mcr_mode_Pos          (1UL)                     /*!< i2c_app i2c_mcr: mode (Bit 1)                         */
#define i2c_app_i2c_mcr_mode_Msk          (0xeUL)                   /*!< i2c_app i2c_mcr: mode (Bitfield-Mask: 0x07)           */
#define i2c_app_i2c_mcr_en_i2c_Pos        (0UL)                     /*!< i2c_app i2c_mcr: en_i2c (Bit 0)                       */
#define i2c_app_i2c_mcr_en_i2c_Msk        (0x1UL)                   /*!< i2c_app i2c_mcr: en_i2c (Bitfield-Mask: 0x01)         */
/* ========================================================  i2c_scr  ======================================================== */
#define i2c_app_i2c_scr_reserved2_Pos     (21UL)                    /*!< i2c_app i2c_scr: reserved2 (Bit 21)                   */
#define i2c_app_i2c_scr_reserved2_Msk     (0xffe00000UL)            /*!< i2c_app i2c_scr: reserved2 (Bitfield-Mask: 0x7ff)     */
#define i2c_app_i2c_scr_autoreset_ac_start_Pos (20UL)               /*!< i2c_app i2c_scr: autoreset_ac_start (Bit 20)          */
#define i2c_app_i2c_scr_autoreset_ac_start_Msk (0x100000UL)         /*!< i2c_app i2c_scr: autoreset_ac_start (Bitfield-Mask: 0x01) */
#define i2c_app_i2c_scr_reserved1_Pos     (19UL)                    /*!< i2c_app i2c_scr: reserved1 (Bit 19)                   */
#define i2c_app_i2c_scr_reserved1_Msk     (0x80000UL)               /*!< i2c_app i2c_scr: reserved1 (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_scr_ac_gcall_Pos      (18UL)                    /*!< i2c_app i2c_scr: ac_gcall (Bit 18)                    */
#define i2c_app_i2c_scr_ac_gcall_Msk      (0x40000UL)               /*!< i2c_app i2c_scr: ac_gcall (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_scr_ac_start_Pos      (17UL)                    /*!< i2c_app i2c_scr: ac_start (Bit 17)                    */
#define i2c_app_i2c_scr_ac_start_Msk      (0x20000UL)               /*!< i2c_app i2c_scr: ac_start (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_scr_ac_srx_Pos        (16UL)                    /*!< i2c_app i2c_scr: ac_srx (Bit 16)                      */
#define i2c_app_i2c_scr_ac_srx_Msk        (0x10000UL)               /*!< i2c_app i2c_scr: ac_srx (Bitfield-Mask: 0x01)         */
#define i2c_app_i2c_scr_reserved0_Pos     (11UL)                    /*!< i2c_app i2c_scr: reserved0 (Bit 11)                   */
#define i2c_app_i2c_scr_reserved0_Msk     (0xf800UL)                /*!< i2c_app i2c_scr: reserved0 (Bitfield-Mask: 0x1f)      */
#define i2c_app_i2c_scr_sid10_Pos         (10UL)                    /*!< i2c_app i2c_scr: sid10 (Bit 10)                       */
#define i2c_app_i2c_scr_sid10_Msk         (0x400UL)                 /*!< i2c_app i2c_scr: sid10 (Bitfield-Mask: 0x01)          */
#define i2c_app_i2c_scr_sid_Pos           (0UL)                     /*!< i2c_app i2c_scr: sid (Bit 0)                          */
#define i2c_app_i2c_scr_sid_Msk           (0x3ffUL)                 /*!< i2c_app i2c_scr: sid (Bitfield-Mask: 0x3ff)           */
/* ========================================================  i2c_cmd  ======================================================== */
#define i2c_app_i2c_cmd_reserved2_Pos     (28UL)                    /*!< i2c_app i2c_cmd: reserved2 (Bit 28)                   */
#define i2c_app_i2c_cmd_reserved2_Msk     (0xf0000000UL)            /*!< i2c_app i2c_cmd: reserved2 (Bitfield-Mask: 0x0f)      */
#define i2c_app_i2c_cmd_acpollmax_Pos     (20UL)                    /*!< i2c_app i2c_cmd: acpollmax (Bit 20)                   */
#define i2c_app_i2c_cmd_acpollmax_Msk     (0xff00000UL)             /*!< i2c_app i2c_cmd: acpollmax (Bitfield-Mask: 0xff)      */
#define i2c_app_i2c_cmd_reserved1_Pos     (18UL)                    /*!< i2c_app i2c_cmd: reserved1 (Bit 18)                   */
#define i2c_app_i2c_cmd_reserved1_Msk     (0xc0000UL)               /*!< i2c_app i2c_cmd: reserved1 (Bitfield-Mask: 0x03)      */
#define i2c_app_i2c_cmd_tsize_Pos         (8UL)                     /*!< i2c_app i2c_cmd: tsize (Bit 8)                        */
#define i2c_app_i2c_cmd_tsize_Msk         (0x3ff00UL)               /*!< i2c_app i2c_cmd: tsize (Bitfield-Mask: 0x3ff)         */
#define i2c_app_i2c_cmd_reserved0_Pos     (4UL)                     /*!< i2c_app i2c_cmd: reserved0 (Bit 4)                    */
#define i2c_app_i2c_cmd_reserved0_Msk     (0xf0UL)                  /*!< i2c_app i2c_cmd: reserved0 (Bitfield-Mask: 0x0f)      */
#define i2c_app_i2c_cmd_cmd_Pos           (1UL)                     /*!< i2c_app i2c_cmd: cmd (Bit 1)                          */
#define i2c_app_i2c_cmd_cmd_Msk           (0xeUL)                   /*!< i2c_app i2c_cmd: cmd (Bitfield-Mask: 0x07)            */
#define i2c_app_i2c_cmd_nwr_Pos           (0UL)                     /*!< i2c_app i2c_cmd: nwr (Bit 0)                          */
#define i2c_app_i2c_cmd_nwr_Msk           (0x1UL)                   /*!< i2c_app i2c_cmd: nwr (Bitfield-Mask: 0x01)            */
/* ========================================================  i2c_mdr  ======================================================== */
#define i2c_app_i2c_mdr_mdata_Pos         (0UL)                     /*!< i2c_app i2c_mdr: mdata (Bit 0)                        */
#define i2c_app_i2c_mdr_mdata_Msk         (0xffUL)                  /*!< i2c_app i2c_mdr: mdata (Bitfield-Mask: 0xff)          */
/* ========================================================  i2c_sdr  ======================================================== */
#define i2c_app_i2c_sdr_sdata_Pos         (0UL)                     /*!< i2c_app i2c_sdr: sdata (Bit 0)                        */
#define i2c_app_i2c_sdr_sdata_Msk         (0xffUL)                  /*!< i2c_app i2c_sdr: sdata (Bitfield-Mask: 0xff)          */
/* =====================================================  i2c_mfifo_cr  ====================================================== */
#define i2c_app_i2c_mfifo_cr_reserved1_Pos (9UL)                    /*!< i2c_app i2c_mfifo_cr: reserved1 (Bit 9)               */
#define i2c_app_i2c_mfifo_cr_reserved1_Msk (0xfffffe00UL)           /*!< i2c_app i2c_mfifo_cr: reserved1 (Bitfield-Mask: 0x7fffff) */
#define i2c_app_i2c_mfifo_cr_mfifo_clr_Pos (8UL)                    /*!< i2c_app i2c_mfifo_cr: mfifo_clr (Bit 8)               */
#define i2c_app_i2c_mfifo_cr_mfifo_clr_Msk (0x100UL)                /*!< i2c_app i2c_mfifo_cr: mfifo_clr (Bitfield-Mask: 0x01) */
#define i2c_app_i2c_mfifo_cr_reserved0_Pos (4UL)                    /*!< i2c_app i2c_mfifo_cr: reserved0 (Bit 4)               */
#define i2c_app_i2c_mfifo_cr_reserved0_Msk (0xf0UL)                 /*!< i2c_app i2c_mfifo_cr: reserved0 (Bitfield-Mask: 0x0f) */
#define i2c_app_i2c_mfifo_cr_mfifo_wm_Pos (0UL)                     /*!< i2c_app i2c_mfifo_cr: mfifo_wm (Bit 0)                */
#define i2c_app_i2c_mfifo_cr_mfifo_wm_Msk (0xfUL)                   /*!< i2c_app i2c_mfifo_cr: mfifo_wm (Bitfield-Mask: 0x0f)  */
/* =====================================================  i2c_sfifo_cr  ====================================================== */
#define i2c_app_i2c_sfifo_cr_reserved1_Pos (9UL)                    /*!< i2c_app i2c_sfifo_cr: reserved1 (Bit 9)               */
#define i2c_app_i2c_sfifo_cr_reserved1_Msk (0xfffffe00UL)           /*!< i2c_app i2c_sfifo_cr: reserved1 (Bitfield-Mask: 0x7fffff) */
#define i2c_app_i2c_sfifo_cr_sfifo_clr_Pos (8UL)                    /*!< i2c_app i2c_sfifo_cr: sfifo_clr (Bit 8)               */
#define i2c_app_i2c_sfifo_cr_sfifo_clr_Msk (0x100UL)                /*!< i2c_app i2c_sfifo_cr: sfifo_clr (Bitfield-Mask: 0x01) */
#define i2c_app_i2c_sfifo_cr_reserved0_Pos (4UL)                    /*!< i2c_app i2c_sfifo_cr: reserved0 (Bit 4)               */
#define i2c_app_i2c_sfifo_cr_reserved0_Msk (0xf0UL)                 /*!< i2c_app i2c_sfifo_cr: reserved0 (Bitfield-Mask: 0x0f) */
#define i2c_app_i2c_sfifo_cr_sfifo_wm_Pos (0UL)                     /*!< i2c_app i2c_sfifo_cr: sfifo_wm (Bit 0)                */
#define i2c_app_i2c_sfifo_cr_sfifo_wm_Msk (0xfUL)                   /*!< i2c_app i2c_sfifo_cr: sfifo_wm (Bitfield-Mask: 0x0f)  */
/* ========================================================  i2c_sr  ========================================================= */
#define i2c_app_i2c_sr_sda_state_Pos      (31UL)                    /*!< i2c_app i2c_sr: sda_state (Bit 31)                    */
#define i2c_app_i2c_sr_sda_state_Msk      (0x80000000UL)            /*!< i2c_app i2c_sr: sda_state (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_sr_scl_state_Pos      (30UL)                    /*!< i2c_app i2c_sr: scl_state (Bit 30)                    */
#define i2c_app_i2c_sr_scl_state_Msk      (0x40000000UL)            /*!< i2c_app i2c_sr: scl_state (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_sr_reserved2_Pos      (29UL)                    /*!< i2c_app i2c_sr: reserved2 (Bit 29)                    */
#define i2c_app_i2c_sr_reserved2_Msk      (0x20000000UL)            /*!< i2c_app i2c_sr: reserved2 (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_sr_timeout_Pos        (28UL)                    /*!< i2c_app i2c_sr: timeout (Bit 28)                      */
#define i2c_app_i2c_sr_timeout_Msk        (0x10000000UL)            /*!< i2c_app i2c_sr: timeout (Bitfield-Mask: 0x01)         */
#define i2c_app_i2c_sr_sid10_aced_Pos     (27UL)                    /*!< i2c_app i2c_sr: sid10_aced (Bit 27)                   */
#define i2c_app_i2c_sr_sid10_aced_Msk     (0x8000000UL)             /*!< i2c_app i2c_sr: sid10_aced (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_sr_gcall_aced_Pos     (26UL)                    /*!< i2c_app i2c_sr: gcall_aced (Bit 26)                   */
#define i2c_app_i2c_sr_gcall_aced_Msk     (0x4000000UL)             /*!< i2c_app i2c_sr: gcall_aced (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_sr_nwr_aced_Pos       (25UL)                    /*!< i2c_app i2c_sr: nwr_aced (Bit 25)                     */
#define i2c_app_i2c_sr_nwr_aced_Msk       (0x2000000UL)             /*!< i2c_app i2c_sr: nwr_aced (Bitfield-Mask: 0x01)        */
#define i2c_app_i2c_sr_last_ac_Pos        (24UL)                    /*!< i2c_app i2c_sr: last_ac (Bit 24)                      */
#define i2c_app_i2c_sr_last_ac_Msk        (0x1000000UL)             /*!< i2c_app i2c_sr: last_ac (Bitfield-Mask: 0x01)         */
#define i2c_app_i2c_sr_slave_access_Pos   (23UL)                    /*!< i2c_app i2c_sr: slave_access (Bit 23)                 */
#define i2c_app_i2c_sr_slave_access_Msk   (0x800000UL)              /*!< i2c_app i2c_sr: slave_access (Bitfield-Mask: 0x01)    */
#define i2c_app_i2c_sr_started_Pos        (22UL)                    /*!< i2c_app i2c_sr: started (Bit 22)                      */
#define i2c_app_i2c_sr_started_Msk        (0x400000UL)              /*!< i2c_app i2c_sr: started (Bitfield-Mask: 0x01)         */
#define i2c_app_i2c_sr_nwr_Pos            (21UL)                    /*!< i2c_app i2c_sr: nwr (Bit 21)                          */
#define i2c_app_i2c_sr_nwr_Msk            (0x200000UL)              /*!< i2c_app i2c_sr: nwr (Bitfield-Mask: 0x01)             */
#define i2c_app_i2c_sr_bus_master_Pos     (20UL)                    /*!< i2c_app i2c_sr: bus_master (Bit 20)                   */
#define i2c_app_i2c_sr_bus_master_Msk     (0x100000UL)              /*!< i2c_app i2c_sr: bus_master (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_sr_sfifo_err_undr_Pos (19UL)                    /*!< i2c_app i2c_sr: sfifo_err_undr (Bit 19)               */
#define i2c_app_i2c_sr_sfifo_err_undr_Msk (0x80000UL)               /*!< i2c_app i2c_sr: sfifo_err_undr (Bitfield-Mask: 0x01)  */
#define i2c_app_i2c_sr_sfifo_err_ovfl_Pos (18UL)                    /*!< i2c_app i2c_sr: sfifo_err_ovfl (Bit 18)               */
#define i2c_app_i2c_sr_sfifo_err_ovfl_Msk (0x40000UL)               /*!< i2c_app i2c_sr: sfifo_err_ovfl (Bitfield-Mask: 0x01)  */
#define i2c_app_i2c_sr_sfifo_full_Pos     (17UL)                    /*!< i2c_app i2c_sr: sfifo_full (Bit 17)                   */
#define i2c_app_i2c_sr_sfifo_full_Msk     (0x20000UL)               /*!< i2c_app i2c_sr: sfifo_full (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_sr_sfifo_empty_Pos    (16UL)                    /*!< i2c_app i2c_sr: sfifo_empty (Bit 16)                  */
#define i2c_app_i2c_sr_sfifo_empty_Msk    (0x10000UL)               /*!< i2c_app i2c_sr: sfifo_empty (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_sr_reserved1_Pos      (15UL)                    /*!< i2c_app i2c_sr: reserved1 (Bit 15)                    */
#define i2c_app_i2c_sr_reserved1_Msk      (0x8000UL)                /*!< i2c_app i2c_sr: reserved1 (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_sr_sfifo_level_Pos    (10UL)                    /*!< i2c_app i2c_sr: sfifo_level (Bit 10)                  */
#define i2c_app_i2c_sr_sfifo_level_Msk    (0x7c00UL)                /*!< i2c_app i2c_sr: sfifo_level (Bitfield-Mask: 0x1f)     */
#define i2c_app_i2c_sr_mfifo_err_undr_Pos (9UL)                     /*!< i2c_app i2c_sr: mfifo_err_undr (Bit 9)                */
#define i2c_app_i2c_sr_mfifo_err_undr_Msk (0x200UL)                 /*!< i2c_app i2c_sr: mfifo_err_undr (Bitfield-Mask: 0x01)  */
#define i2c_app_i2c_sr_mfifo_err_ovfl_Pos (8UL)                     /*!< i2c_app i2c_sr: mfifo_err_ovfl (Bit 8)                */
#define i2c_app_i2c_sr_mfifo_err_ovfl_Msk (0x100UL)                 /*!< i2c_app i2c_sr: mfifo_err_ovfl (Bitfield-Mask: 0x01)  */
#define i2c_app_i2c_sr_mfifo_full_Pos     (7UL)                     /*!< i2c_app i2c_sr: mfifo_full (Bit 7)                    */
#define i2c_app_i2c_sr_mfifo_full_Msk     (0x80UL)                  /*!< i2c_app i2c_sr: mfifo_full (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_sr_mfifo_empty_Pos    (6UL)                     /*!< i2c_app i2c_sr: mfifo_empty (Bit 6)                   */
#define i2c_app_i2c_sr_mfifo_empty_Msk    (0x40UL)                  /*!< i2c_app i2c_sr: mfifo_empty (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_sr_reserved0_Pos      (5UL)                     /*!< i2c_app i2c_sr: reserved0 (Bit 5)                     */
#define i2c_app_i2c_sr_reserved0_Msk      (0x20UL)                  /*!< i2c_app i2c_sr: reserved0 (Bitfield-Mask: 0x01)       */
#define i2c_app_i2c_sr_mfifo_level_Pos    (0UL)                     /*!< i2c_app i2c_sr: mfifo_level (Bit 0)                   */
#define i2c_app_i2c_sr_mfifo_level_Msk    (0x1fUL)                  /*!< i2c_app i2c_sr: mfifo_level (Bitfield-Mask: 0x1f)     */
/* ======================================================  i2c_irqmsk  ======================================================= */
#define i2c_app_i2c_irqmsk_sreq_Pos       (6UL)                     /*!< i2c_app i2c_irqmsk: sreq (Bit 6)                      */
#define i2c_app_i2c_irqmsk_sreq_Msk       (0x40UL)                  /*!< i2c_app i2c_irqmsk: sreq (Bitfield-Mask: 0x01)        */
#define i2c_app_i2c_irqmsk_sfifo_req_Pos  (5UL)                     /*!< i2c_app i2c_irqmsk: sfifo_req (Bit 5)                 */
#define i2c_app_i2c_irqmsk_sfifo_req_Msk  (0x20UL)                  /*!< i2c_app i2c_irqmsk: sfifo_req (Bitfield-Mask: 0x01)   */
#define i2c_app_i2c_irqmsk_mfifo_req_Pos  (4UL)                     /*!< i2c_app i2c_irqmsk: mfifo_req (Bit 4)                 */
#define i2c_app_i2c_irqmsk_mfifo_req_Msk  (0x10UL)                  /*!< i2c_app i2c_irqmsk: mfifo_req (Bitfield-Mask: 0x01)   */
#define i2c_app_i2c_irqmsk_bus_busy_Pos   (3UL)                     /*!< i2c_app i2c_irqmsk: bus_busy (Bit 3)                  */
#define i2c_app_i2c_irqmsk_bus_busy_Msk   (0x8UL)                   /*!< i2c_app i2c_irqmsk: bus_busy (Bitfield-Mask: 0x01)    */
#define i2c_app_i2c_irqmsk_fifo_err_Pos   (2UL)                     /*!< i2c_app i2c_irqmsk: fifo_err (Bit 2)                  */
#define i2c_app_i2c_irqmsk_fifo_err_Msk   (0x4UL)                   /*!< i2c_app i2c_irqmsk: fifo_err (Bitfield-Mask: 0x01)    */
#define i2c_app_i2c_irqmsk_cmd_err_Pos    (1UL)                     /*!< i2c_app i2c_irqmsk: cmd_err (Bit 1)                   */
#define i2c_app_i2c_irqmsk_cmd_err_Msk    (0x2UL)                   /*!< i2c_app i2c_irqmsk: cmd_err (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_irqmsk_cmd_ok_Pos     (0UL)                     /*!< i2c_app i2c_irqmsk: cmd_ok (Bit 0)                    */
#define i2c_app_i2c_irqmsk_cmd_ok_Msk     (0x1UL)                   /*!< i2c_app i2c_irqmsk: cmd_ok (Bitfield-Mask: 0x01)      */
/* =======================================================  i2c_irqsr  ======================================================= */
#define i2c_app_i2c_irqsr_sreq_Pos        (6UL)                     /*!< i2c_app i2c_irqsr: sreq (Bit 6)                       */
#define i2c_app_i2c_irqsr_sreq_Msk        (0x40UL)                  /*!< i2c_app i2c_irqsr: sreq (Bitfield-Mask: 0x01)         */
#define i2c_app_i2c_irqsr_sfifo_req_Pos   (5UL)                     /*!< i2c_app i2c_irqsr: sfifo_req (Bit 5)                  */
#define i2c_app_i2c_irqsr_sfifo_req_Msk   (0x20UL)                  /*!< i2c_app i2c_irqsr: sfifo_req (Bitfield-Mask: 0x01)    */
#define i2c_app_i2c_irqsr_mfifo_req_Pos   (4UL)                     /*!< i2c_app i2c_irqsr: mfifo_req (Bit 4)                  */
#define i2c_app_i2c_irqsr_mfifo_req_Msk   (0x10UL)                  /*!< i2c_app i2c_irqsr: mfifo_req (Bitfield-Mask: 0x01)    */
#define i2c_app_i2c_irqsr_bus_busy_Pos    (3UL)                     /*!< i2c_app i2c_irqsr: bus_busy (Bit 3)                   */
#define i2c_app_i2c_irqsr_bus_busy_Msk    (0x8UL)                   /*!< i2c_app i2c_irqsr: bus_busy (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_irqsr_fifo_err_Pos    (2UL)                     /*!< i2c_app i2c_irqsr: fifo_err (Bit 2)                   */
#define i2c_app_i2c_irqsr_fifo_err_Msk    (0x4UL)                   /*!< i2c_app i2c_irqsr: fifo_err (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_irqsr_cmd_err_Pos     (1UL)                     /*!< i2c_app i2c_irqsr: cmd_err (Bit 1)                    */
#define i2c_app_i2c_irqsr_cmd_err_Msk     (0x2UL)                   /*!< i2c_app i2c_irqsr: cmd_err (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_irqsr_cmd_ok_Pos      (0UL)                     /*!< i2c_app i2c_irqsr: cmd_ok (Bit 0)                     */
#define i2c_app_i2c_irqsr_cmd_ok_Msk      (0x1UL)                   /*!< i2c_app i2c_irqsr: cmd_ok (Bitfield-Mask: 0x01)       */
/* =====================================================  i2c_irqmsked  ====================================================== */
#define i2c_app_i2c_irqmsked_sreq_Pos     (6UL)                     /*!< i2c_app i2c_irqmsked: sreq (Bit 6)                    */
#define i2c_app_i2c_irqmsked_sreq_Msk     (0x40UL)                  /*!< i2c_app i2c_irqmsked: sreq (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_irqmsked_sfifo_req_Pos (5UL)                    /*!< i2c_app i2c_irqmsked: sfifo_req (Bit 5)               */
#define i2c_app_i2c_irqmsked_sfifo_req_Msk (0x20UL)                 /*!< i2c_app i2c_irqmsked: sfifo_req (Bitfield-Mask: 0x01) */
#define i2c_app_i2c_irqmsked_mfifo_req_Pos (4UL)                    /*!< i2c_app i2c_irqmsked: mfifo_req (Bit 4)               */
#define i2c_app_i2c_irqmsked_mfifo_req_Msk (0x10UL)                 /*!< i2c_app i2c_irqmsked: mfifo_req (Bitfield-Mask: 0x01) */
#define i2c_app_i2c_irqmsked_bus_busy_Pos (3UL)                     /*!< i2c_app i2c_irqmsked: bus_busy (Bit 3)                */
#define i2c_app_i2c_irqmsked_bus_busy_Msk (0x8UL)                   /*!< i2c_app i2c_irqmsked: bus_busy (Bitfield-Mask: 0x01)  */
#define i2c_app_i2c_irqmsked_fifo_err_Pos (2UL)                     /*!< i2c_app i2c_irqmsked: fifo_err (Bit 2)                */
#define i2c_app_i2c_irqmsked_fifo_err_Msk (0x4UL)                   /*!< i2c_app i2c_irqmsked: fifo_err (Bitfield-Mask: 0x01)  */
#define i2c_app_i2c_irqmsked_cmd_err_Pos  (1UL)                     /*!< i2c_app i2c_irqmsked: cmd_err (Bit 1)                 */
#define i2c_app_i2c_irqmsked_cmd_err_Msk  (0x2UL)                   /*!< i2c_app i2c_irqmsked: cmd_err (Bitfield-Mask: 0x01)   */
#define i2c_app_i2c_irqmsked_cmd_ok_Pos   (0UL)                     /*!< i2c_app i2c_irqmsked: cmd_ok (Bit 0)                  */
#define i2c_app_i2c_irqmsked_cmd_ok_Msk   (0x1UL)                   /*!< i2c_app i2c_irqmsked: cmd_ok (Bitfield-Mask: 0x01)    */
/* =======================================================  i2c_dmacr  ======================================================= */
#define i2c_app_i2c_dmacr_sdmab_en_Pos    (3UL)                     /*!< i2c_app i2c_dmacr: sdmab_en (Bit 3)                   */
#define i2c_app_i2c_dmacr_sdmab_en_Msk    (0x8UL)                   /*!< i2c_app i2c_dmacr: sdmab_en (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_dmacr_sdmas_en_Pos    (2UL)                     /*!< i2c_app i2c_dmacr: sdmas_en (Bit 2)                   */
#define i2c_app_i2c_dmacr_sdmas_en_Msk    (0x4UL)                   /*!< i2c_app i2c_dmacr: sdmas_en (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_dmacr_mdmab_en_Pos    (1UL)                     /*!< i2c_app i2c_dmacr: mdmab_en (Bit 1)                   */
#define i2c_app_i2c_dmacr_mdmab_en_Msk    (0x2UL)                   /*!< i2c_app i2c_dmacr: mdmab_en (Bitfield-Mask: 0x01)     */
#define i2c_app_i2c_dmacr_mdmas_en_Pos    (0UL)                     /*!< i2c_app i2c_dmacr: mdmas_en (Bit 0)                   */
#define i2c_app_i2c_dmacr_mdmas_en_Msk    (0x1UL)                   /*!< i2c_app i2c_dmacr: mdmas_en (Bitfield-Mask: 0x01)     */
/* ========================================================  i2c_pio  ======================================================== */
#define i2c_app_i2c_pio_reserved1_Pos     (7UL)                     /*!< i2c_app i2c_pio: reserved1 (Bit 7)                    */
#define i2c_app_i2c_pio_reserved1_Msk     (0xffffff80UL)            /*!< i2c_app i2c_pio: reserved1 (Bitfield-Mask: 0x1ffffff) */
#define i2c_app_i2c_pio_sda_in_ro_Pos     (6UL)                     /*!< i2c_app i2c_pio: sda_in_ro (Bit 6)                    */
#define i2c_app_i2c_pio_sda_in_ro_Msk     (0x40UL)                  /*!< i2c_app i2c_pio: sda_in_ro (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_pio_sda_oe_Pos        (5UL)                     /*!< i2c_app i2c_pio: sda_oe (Bit 5)                       */
#define i2c_app_i2c_pio_sda_oe_Msk        (0x20UL)                  /*!< i2c_app i2c_pio: sda_oe (Bitfield-Mask: 0x01)         */
#define i2c_app_i2c_pio_sda_out_Pos       (4UL)                     /*!< i2c_app i2c_pio: sda_out (Bit 4)                      */
#define i2c_app_i2c_pio_sda_out_Msk       (0x10UL)                  /*!< i2c_app i2c_pio: sda_out (Bitfield-Mask: 0x01)        */
#define i2c_app_i2c_pio_reserved0_Pos     (3UL)                     /*!< i2c_app i2c_pio: reserved0 (Bit 3)                    */
#define i2c_app_i2c_pio_reserved0_Msk     (0x8UL)                   /*!< i2c_app i2c_pio: reserved0 (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_pio_scl_in_ro_Pos     (2UL)                     /*!< i2c_app i2c_pio: scl_in_ro (Bit 2)                    */
#define i2c_app_i2c_pio_scl_in_ro_Msk     (0x4UL)                   /*!< i2c_app i2c_pio: scl_in_ro (Bitfield-Mask: 0x01)      */
#define i2c_app_i2c_pio_scl_oe_Pos        (1UL)                     /*!< i2c_app i2c_pio: scl_oe (Bit 1)                       */
#define i2c_app_i2c_pio_scl_oe_Msk        (0x2UL)                   /*!< i2c_app i2c_pio: scl_oe (Bitfield-Mask: 0x01)         */
#define i2c_app_i2c_pio_scl_out_Pos       (0UL)                     /*!< i2c_app i2c_pio: scl_out (Bit 0)                      */
#define i2c_app_i2c_pio_scl_out_Msk       (0x1UL)                   /*!< i2c_app i2c_pio: scl_out (Bitfield-Mask: 0x01)        */


/* =========================================================================================================================== */
/* ================                                       mled_ctrl_app                                       ================ */
/* =========================================================================================================================== */

/* ===================================================  mled_ctrl_app_cfg  =================================================== */
#define mled_ctrl_app_mled_ctrl_app_cfg_blink_counter_max_Pos (11UL) /*!< mled_ctrl_app mled_ctrl_app_cfg: blink_counter_max (Bit 11) */
#define mled_ctrl_app_mled_ctrl_app_cfg_blink_counter_max_Msk (0xff800UL) /*!< mled_ctrl_app mled_ctrl_app_cfg: blink_counter_max (Bitfield-Mask: 0x1ff) */
#define mled_ctrl_app_mled_ctrl_app_cfg_prescale_counter_max_Pos (1UL) /*!< mled_ctrl_app mled_ctrl_app_cfg: prescale_counter_max (Bit 1) */
#define mled_ctrl_app_mled_ctrl_app_cfg_prescale_counter_max_Msk (0x7feUL) /*!< mled_ctrl_app mled_ctrl_app_cfg: prescale_counter_max (Bitfield-Mask: 0x3ff) */
#define mled_ctrl_app_mled_ctrl_app_cfg_enable_Pos (0UL)            /*!< mled_ctrl_app mled_ctrl_app_cfg: enable (Bit 0)       */
#define mled_ctrl_app_mled_ctrl_app_cfg_enable_Msk (0x1UL)          /*!< mled_ctrl_app mled_ctrl_app_cfg: enable (Bitfield-Mask: 0x01) */
/* ===============================================  mled_ctrl_app_output_sel  ================================================ */
#define mled_ctrl_app_mled_ctrl_app_output_sel_sel_Pos (1UL)        /*!< mled_ctrl_app mled_ctrl_app_output_sel: sel (Bit 1)   */
#define mled_ctrl_app_mled_ctrl_app_output_sel_sel_Msk (0x6UL)      /*!< mled_ctrl_app mled_ctrl_app_output_sel: sel (Bitfield-Mask: 0x03) */
#define mled_ctrl_app_mled_ctrl_app_output_sel_inv_Pos (0UL)        /*!< mled_ctrl_app mled_ctrl_app_output_sel: inv (Bit 0)   */
#define mled_ctrl_app_mled_ctrl_app_output_sel_inv_Msk (0x1UL)      /*!< mled_ctrl_app mled_ctrl_app_output_sel: inv (Bitfield-Mask: 0x01) */
/* =============================================  mled_ctrl_app_output_on_time  ============================================== */
#define mled_ctrl_app_mled_ctrl_app_output_on_time_val_Pos (0UL)    /*!< mled_ctrl_app mled_ctrl_app_output_on_time: val (Bit 0) */
#define mled_ctrl_app_mled_ctrl_app_output_on_time_val_Msk (0xffUL) /*!< mled_ctrl_app mled_ctrl_app_output_on_time: val (Bitfield-Mask: 0xff) */
/* ==================================================  mled_ctrl_app_line  =================================================== */
#define mled_ctrl_app_mled_ctrl_app_line_val_Pos (0UL)              /*!< mled_ctrl_app mled_ctrl_app_line: val (Bit 0)         */
#define mled_ctrl_app_mled_ctrl_app_line_val_Msk (0xffffUL)         /*!< mled_ctrl_app mled_ctrl_app_line: val (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                       ecc_ctrl_app                                        ================ */
/* =========================================================================================================================== */

/* =================================================  ecc_ctrl_intram0_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram0_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram0_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram0_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_intram0_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_intram0_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram0_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram0_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram0_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_intram1_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram1_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram1_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram1_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_intram1_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_intram1_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram1_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram1_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram1_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_intram2_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram2_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram2_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram2_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_intram2_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_intram2_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram2_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram2_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram2_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_intram3_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram3_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram3_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram3_ctrl_syndrome_inv_Msk (0x3eUL) /*!< ecc_ctrl_app ecc_ctrl_intram3_ctrl: syndrome_inv (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_intram3_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram3_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram3_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram3_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_intram4_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram4_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram4_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram4_ctrl_syndrome_inv_Msk (0x3eUL) /*!< ecc_ctrl_app ecc_ctrl_intram4_ctrl: syndrome_inv (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_intram4_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram4_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram4_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram4_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_intram5_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram5_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram5_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram5_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_intram5_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_intram5_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram5_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram5_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram5_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_intram6_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram6_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram6_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram6_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_intram6_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_intram6_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram6_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram6_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram6_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_intram7_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intram7_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_intram7_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intram7_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_intram7_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_intram7_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_intram7_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_intram7_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_intram7_ctrl: enable (Bitfield-Mask: 0x01) */
/* ================================================  ecc_ctrl_intramhs_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_intramhs_ctrl_syndrome_inv_Pos (1UL)  /*!< ecc_ctrl_app ecc_ctrl_intramhs_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_intramhs_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_ctrl_enable_Pos (0UL)        /*!< ecc_ctrl_app ecc_ctrl_intramhs_ctrl: enable (Bit 0)   */
#define ecc_ctrl_app_ecc_ctrl_intramhs_ctrl_enable_Msk (0x1UL)      /*!< ecc_ctrl_app ecc_ctrl_intramhs_ctrl: enable (Bitfield-Mask: 0x01) */
/* =============================================  ecc_ctrl_xc0_rpec0_pram_ctrl  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_ctrl_enable_Pos (0UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_ctrl_enable_Msk (0x1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_ctrl: enable (Bitfield-Mask: 0x01) */
/* =============================================  ecc_ctrl_xc0_rpec1_pram_ctrl  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_ctrl_enable_Pos (0UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_ctrl_enable_Msk (0x1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_ctrl: enable (Bitfield-Mask: 0x01) */
/* =============================================  ecc_ctrl_xc0_tpec0_pram_ctrl  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_ctrl_enable_Pos (0UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_ctrl_enable_Msk (0x1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_ctrl: enable (Bitfield-Mask: 0x01) */
/* =============================================  ecc_ctrl_xc0_tpec1_pram_ctrl  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_ctrl_enable_Pos (0UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_ctrl_enable_Msk (0x1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ===============================================  ecc_ctrl_xc0_dpram0_ctrl  ================================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram0_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv_Msk (0x3eUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram0_ctrl: syndrome_inv (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram0_ctrl_enable_Pos (0UL)      /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram0_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram0_ctrl_enable_Msk (0x1UL)    /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram0_ctrl: enable (Bitfield-Mask: 0x01) */
/* ===============================================  ecc_ctrl_xc0_dpram1_ctrl  ================================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram1_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv_Msk (0x3eUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram1_ctrl: syndrome_inv (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram1_ctrl_enable_Pos (0UL)      /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram1_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_dpram1_ctrl_enable_Msk (0x1UL)    /*!< ecc_ctrl_app ecc_ctrl_xc0_dpram1_ctrl: enable (Bitfield-Mask: 0x01) */
/* ==============================================  ecc_ctrl_xc0_rpu0_ram_ctrl  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv_Msk (0x1feUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_ctrl: syndrome_inv (Bitfield-Mask: 0xff) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_ctrl_enable_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_ctrl_enable_Msk (0x1UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ==============================================  ecc_ctrl_xc0_rpu1_ram_ctrl  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv_Msk (0x1feUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_ctrl: syndrome_inv (Bitfield-Mask: 0xff) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_ctrl_enable_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_ctrl_enable_Msk (0x1UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ==============================================  ecc_ctrl_xc0_tpu0_ram_ctrl  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv_Msk (0x1feUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_ctrl: syndrome_inv (Bitfield-Mask: 0xff) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_ctrl_enable_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_ctrl_enable_Msk (0x1UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ==============================================  ecc_ctrl_xc0_tpu1_ram_ctrl  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv_Msk (0x1feUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_ctrl: syndrome_inv (Bitfield-Mask: 0xff) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_ctrl_enable_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_ctrl_enable_Msk (0x1UL)  /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ================================================  ecc_ctrl_xc0_pfifo_ctrl  ================================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_pfifo_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_pfifo_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_xc0_pfifo_ctrl_enable_Pos (0UL)       /*!< ecc_ctrl_app ecc_ctrl_xc0_pfifo_ctrl: enable (Bit 0)  */
#define ecc_ctrl_app_ecc_ctrl_xc0_pfifo_ctrl_enable_Msk (0x1UL)     /*!< ecc_ctrl_app ecc_ctrl_xc0_pfifo_ctrl: enable (Bitfield-Mask: 0x01) */
/* ===============================================  ecc_ctrl_xpic0_pram_ctrl  ================================================ */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_ctrl_enable_Pos (0UL)      /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_ctrl_enable_Msk (0x1UL)    /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ===============================================  ecc_ctrl_xpic1_pram_ctrl  ================================================ */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv_Msk (0xfeUL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_ctrl: syndrome_inv (Bitfield-Mask: 0x7f) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_ctrl_enable_Pos (0UL)      /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_ctrl_enable_Msk (0x1UL)    /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ===============================================  ecc_ctrl_xpic0_dram_ctrl  ================================================ */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv_Msk (0x3eUL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_ctrl: syndrome_inv (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_ctrl_enable_Pos (0UL)      /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_ctrl_enable_Msk (0x1UL)    /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_ctrl: enable (Bitfield-Mask: 0x01) */
/* ===============================================  ecc_ctrl_xpic1_dram_ctrl  ================================================ */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv_Pos (1UL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv_Msk (0x3eUL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_ctrl: syndrome_inv (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_ctrl_enable_Pos (0UL)      /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_ctrl: enable (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_ctrl_enable_Msk (0x1UL)    /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_iflash0_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_iflash0_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_iflash0_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_iflash0_ctrl_syndrome_inv_Msk (0x1feUL) /*!< ecc_ctrl_app ecc_ctrl_iflash0_ctrl: syndrome_inv (Bitfield-Mask: 0xff) */
#define ecc_ctrl_app_ecc_ctrl_iflash0_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_iflash0_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_iflash0_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_iflash0_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_iflash1_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_iflash1_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_iflash1_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_iflash1_ctrl_syndrome_inv_Msk (0x1feUL) /*!< ecc_ctrl_app ecc_ctrl_iflash1_ctrl: syndrome_inv (Bitfield-Mask: 0xff) */
#define ecc_ctrl_app_ecc_ctrl_iflash1_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_iflash1_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_iflash1_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_iflash1_ctrl: enable (Bitfield-Mask: 0x01) */
/* =================================================  ecc_ctrl_iflash2_ctrl  ================================================= */
#define ecc_ctrl_app_ecc_ctrl_iflash2_ctrl_syndrome_inv_Pos (1UL)   /*!< ecc_ctrl_app ecc_ctrl_iflash2_ctrl: syndrome_inv (Bit 1) */
#define ecc_ctrl_app_ecc_ctrl_iflash2_ctrl_syndrome_inv_Msk (0x1feUL) /*!< ecc_ctrl_app ecc_ctrl_iflash2_ctrl: syndrome_inv (Bitfield-Mask: 0xff) */
#define ecc_ctrl_app_ecc_ctrl_iflash2_ctrl_enable_Pos (0UL)         /*!< ecc_ctrl_app ecc_ctrl_iflash2_ctrl: enable (Bit 0)    */
#define ecc_ctrl_app_ecc_ctrl_iflash2_ctrl_enable_Msk (0x1UL)       /*!< ecc_ctrl_app ecc_ctrl_iflash2_ctrl: enable (Bitfield-Mask: 0x01) */
/* ===============================================  ecc_ctrl_intram0_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_sbe_add_addr_Pos (15UL)  /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_sbe: add_addr (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_sbe_add_addr_Msk (0x1f8000UL) /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_sbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_sbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_sbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_intram1_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_sbe_add_addr_Pos (15UL)  /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_sbe: add_addr (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_sbe_add_addr_Msk (0x1f8000UL) /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_sbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_sbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_sbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_intram2_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_sbe_add_addr_Pos (15UL)  /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_sbe: add_addr (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_sbe_add_addr_Msk (0x1f8000UL) /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_sbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_sbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_sbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_intram3_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_sbe_add_addr_Pos (14UL)  /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_sbe: add_addr (Bit 14) */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_sbe_add_addr_Msk (0x7c000UL) /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_sbe: add_addr (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_sbe_address_Msk (0x3fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_sbe: address (Bitfield-Mask: 0x3fff) */
/* ===============================================  ecc_ctrl_intram4_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_sbe_add_addr_Pos (14UL)  /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_sbe: add_addr (Bit 14) */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_sbe_add_addr_Msk (0x7c000UL) /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_sbe: add_addr (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_sbe_address_Msk (0x3fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_sbe: address (Bitfield-Mask: 0x3fff) */
/* ===============================================  ecc_ctrl_intram5_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_sbe_add_addr_Pos (13UL)  /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_sbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_sbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_sbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_sbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_sbe: address (Bitfield-Mask: 0x1fff) */
/* ===============================================  ecc_ctrl_intram6_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_sbe_add_addr_Pos (13UL)  /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_sbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_sbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_sbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_sbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_sbe: address (Bitfield-Mask: 0x1fff) */
/* ===============================================  ecc_ctrl_intram7_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_sbe_add_addr_Pos (13UL)  /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_sbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_sbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_sbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_sbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_sbe: address (Bitfield-Mask: 0x1fff) */
/* ==============================================  ecc_ctrl_intramhs_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_sbe_add_addr_Pos (13UL) /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_sbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_sbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_sbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_sbe_address_Pos (0UL)   /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_sbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_sbe: address (Bitfield-Mask: 0x1fff) */
/* ===========================================  ecc_ctrl_xc0_rpec0_pram_addr_sbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* ===========================================  ecc_ctrl_xc0_rpec1_pram_addr_sbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* ===========================================  ecc_ctrl_xc0_tpec0_pram_addr_sbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* ===========================================  ecc_ctrl_xc0_tpec1_pram_addr_sbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* ============================================  ecc_ctrl_xc0_rpu0_ram_addr_sbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_addr_sbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_addr_sbe: address (Bitfield-Mask: 0x7f) */
/* ============================================  ecc_ctrl_xc0_rpu1_ram_addr_sbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_addr_sbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_addr_sbe: address (Bitfield-Mask: 0x7f) */
/* ============================================  ecc_ctrl_xc0_tpu0_ram_addr_sbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_addr_sbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_addr_sbe: address (Bitfield-Mask: 0x7f) */
/* ============================================  ecc_ctrl_xc0_tpu1_ram_addr_sbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_addr_sbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_addr_sbe: address (Bitfield-Mask: 0x7f) */
/* =============================================  ecc_ctrl_xpic0_pram_addr_sbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* =============================================  ecc_ctrl_xpic1_pram_addr_sbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* =============================================  ecc_ctrl_xpic0_dram_addr_sbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* =============================================  ecc_ctrl_xpic1_dram_addr_sbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_addr_sbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_addr_sbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_addr_sbe: address (Bitfield-Mask: 0x7ff) */
/* ===============================================  ecc_ctrl_iflash0_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_iflash0_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_iflash0_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_iflash0_addr_sbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_iflash0_addr_sbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_iflash1_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_iflash1_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_iflash1_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_iflash1_addr_sbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_iflash1_addr_sbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_iflash2_addr_sbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_iflash2_addr_sbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_iflash2_addr_sbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_iflash2_addr_sbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_iflash2_addr_sbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_intram0_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_dbe_add_addr_Pos (15UL)  /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_dbe: add_addr (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_dbe_add_addr_Msk (0x1f8000UL) /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_dbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram0_addr_dbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram0_addr_dbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_intram1_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_dbe_add_addr_Pos (15UL)  /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_dbe: add_addr (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_dbe_add_addr_Msk (0x1f8000UL) /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_dbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram1_addr_dbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram1_addr_dbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_intram2_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_dbe_add_addr_Pos (15UL)  /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_dbe: add_addr (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_dbe_add_addr_Msk (0x1f8000UL) /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_dbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram2_addr_dbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram2_addr_dbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_intram3_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_dbe_add_addr_Pos (14UL)  /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_dbe: add_addr (Bit 14) */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_dbe_add_addr_Msk (0x7c000UL) /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_dbe: add_addr (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram3_addr_dbe_address_Msk (0x3fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram3_addr_dbe: address (Bitfield-Mask: 0x3fff) */
/* ===============================================  ecc_ctrl_intram4_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_dbe_add_addr_Pos (14UL)  /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_dbe: add_addr (Bit 14) */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_dbe_add_addr_Msk (0x7c000UL) /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_dbe: add_addr (Bitfield-Mask: 0x1f) */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram4_addr_dbe_address_Msk (0x3fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram4_addr_dbe: address (Bitfield-Mask: 0x3fff) */
/* ===============================================  ecc_ctrl_intram5_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_dbe_add_addr_Pos (13UL)  /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_dbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_dbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_dbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram5_addr_dbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram5_addr_dbe: address (Bitfield-Mask: 0x1fff) */
/* ===============================================  ecc_ctrl_intram6_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_dbe_add_addr_Pos (13UL)  /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_dbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_dbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_dbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram6_addr_dbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram6_addr_dbe: address (Bitfield-Mask: 0x1fff) */
/* ===============================================  ecc_ctrl_intram7_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_dbe_add_addr_Pos (13UL)  /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_dbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_dbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_dbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intram7_addr_dbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intram7_addr_dbe: address (Bitfield-Mask: 0x1fff) */
/* ==============================================  ecc_ctrl_intramhs_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_dbe_add_addr_Pos (13UL) /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_dbe: add_addr (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_dbe_add_addr_Msk (0x7e000UL) /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_dbe: add_addr (Bitfield-Mask: 0x3f) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_dbe_address_Pos (0UL)   /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_intramhs_addr_dbe_address_Msk (0x1fffUL) /*!< ecc_ctrl_app ecc_ctrl_intramhs_addr_dbe: address (Bitfield-Mask: 0x1fff) */
/* ===========================================  ecc_ctrl_xc0_rpec0_pram_addr_dbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec0_pram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* ===========================================  ecc_ctrl_xc0_rpec1_pram_addr_dbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpec1_pram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* ===========================================  ecc_ctrl_xc0_tpec0_pram_addr_dbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec0_pram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* ===========================================  ecc_ctrl_xc0_tpec1_pram_addr_dbe  ============================================ */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpec1_pram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* ============================================  ecc_ctrl_xc0_rpu0_ram_addr_dbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_addr_dbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu0_ram_addr_dbe: address (Bitfield-Mask: 0x7f) */
/* ============================================  ecc_ctrl_xc0_rpu1_ram_addr_dbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_addr_dbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_rpu1_ram_addr_dbe: address (Bitfield-Mask: 0x7f) */
/* ============================================  ecc_ctrl_xc0_tpu0_ram_addr_dbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_addr_dbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu0_ram_addr_dbe: address (Bitfield-Mask: 0x7f) */
/* ============================================  ecc_ctrl_xc0_tpu1_ram_addr_dbe  ============================================= */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_addr_dbe_address_Msk (0x7fUL) /*!< ecc_ctrl_app ecc_ctrl_xc0_tpu1_ram_addr_dbe: address (Bitfield-Mask: 0x7f) */
/* =============================================  ecc_ctrl_xpic0_pram_addr_dbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_pram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_pram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* =============================================  ecc_ctrl_xpic1_pram_addr_dbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_pram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_pram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* =============================================  ecc_ctrl_xpic0_dram_addr_dbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic0_dram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic0_dram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* =============================================  ecc_ctrl_xpic1_dram_addr_dbe  ============================================== */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_addr_dbe_address_Pos (0UL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_xpic1_dram_addr_dbe_address_Msk (0x7ffUL) /*!< ecc_ctrl_app ecc_ctrl_xpic1_dram_addr_dbe: address (Bitfield-Mask: 0x7ff) */
/* ===============================================  ecc_ctrl_iflash0_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_iflash0_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_iflash0_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_iflash0_addr_dbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_iflash0_addr_dbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_iflash1_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_iflash1_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_iflash1_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_iflash1_addr_dbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_iflash1_addr_dbe: address (Bitfield-Mask: 0x7fff) */
/* ===============================================  ecc_ctrl_iflash2_addr_dbe  =============================================== */
#define ecc_ctrl_app_ecc_ctrl_iflash2_addr_dbe_address_Pos (0UL)    /*!< ecc_ctrl_app ecc_ctrl_iflash2_addr_dbe: address (Bit 0) */
#define ecc_ctrl_app_ecc_ctrl_iflash2_addr_dbe_address_Msk (0x7fffUL) /*!< ecc_ctrl_app ecc_ctrl_iflash2_addr_dbe: address (Bitfield-Mask: 0x7fff) */
/* ==================================================  ecc_ctrl_status_sbe  ================================================== */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_iflash2_Pos (26UL)         /*!< ecc_ctrl_app ecc_ctrl_status_sbe: iflash2 (Bit 26)    */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_iflash2_Msk (0x4000000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: iflash2 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_iflash1_Pos (25UL)         /*!< ecc_ctrl_app ecc_ctrl_status_sbe: iflash1 (Bit 25)    */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_iflash1_Msk (0x2000000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: iflash1 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_iflash0_Pos (24UL)         /*!< ecc_ctrl_app ecc_ctrl_status_sbe: iflash0 (Bit 24)    */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_iflash0_Msk (0x1000000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: iflash0 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic1_dram_Pos (23UL)      /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic1_dram (Bit 23) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic1_dram_Msk (0x800000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic1_dram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic0_dram_Pos (22UL)      /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic0_dram (Bit 22) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic0_dram_Msk (0x400000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic0_dram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic1_pram_Pos (21UL)      /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic1_pram (Bit 21) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic1_pram_Msk (0x200000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic1_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic0_pram_Pos (20UL)      /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic0_pram (Bit 20) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xpic0_pram_Msk (0x100000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xpic0_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_pfifo_Pos (19UL)       /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_pfifo (Bit 19)  */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_pfifo_Msk (0x80000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_pfifo (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpu1_ram_Pos (18UL)    /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpu1_ram (Bit 18) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpu1_ram_Msk (0x40000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpu1_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpu0_ram_Pos (17UL)    /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpu0_ram (Bit 17) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpu0_ram_Msk (0x20000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpu0_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpu1_ram_Pos (16UL)    /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpu1_ram (Bit 16) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpu1_ram_Msk (0x10000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpu1_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpu0_ram_Pos (15UL)    /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpu0_ram (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpu0_ram_Msk (0x8000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpu0_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_dpram1_Pos (14UL)      /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_dpram1 (Bit 14) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_dpram1_Msk (0x4000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_dpram1 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_dpram0_Pos (13UL)      /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_dpram0 (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_dpram0_Msk (0x2000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_dpram0 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpec1_pram_Pos (12UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpec1_pram (Bit 12) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpec1_pram_Msk (0x1000UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpec1_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpec0_pram_Pos (11UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpec0_pram (Bit 11) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_tpec0_pram_Msk (0x800UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_tpec0_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpec1_pram_Pos (10UL)  /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpec1_pram (Bit 10) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpec1_pram_Msk (0x400UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpec1_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpec0_pram_Pos (9UL)   /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpec0_pram (Bit 9) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_xc0_rpec0_pram_Msk (0x200UL) /*!< ecc_ctrl_app ecc_ctrl_status_sbe: xc0_rpec0_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intramhs_Pos (8UL)         /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intramhs (Bit 8)    */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intramhs_Msk (0x100UL)     /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intramhs (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram7_Pos (7UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram7 (Bit 7)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram7_Msk (0x80UL)       /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram7 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram6_Pos (6UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram6 (Bit 6)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram6_Msk (0x40UL)       /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram6 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram5_Pos (5UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram5 (Bit 5)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram5_Msk (0x20UL)       /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram5 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram4_Pos (4UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram4 (Bit 4)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram4_Msk (0x10UL)       /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram4 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram3_Pos (3UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram3 (Bit 3)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram3_Msk (0x8UL)        /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram3 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram2_Pos (2UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram2 (Bit 2)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram2_Msk (0x4UL)        /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram2 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram1_Pos (1UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram1 (Bit 1)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram1_Msk (0x2UL)        /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram1 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram0_Pos (0UL)          /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram0 (Bit 0)     */
#define ecc_ctrl_app_ecc_ctrl_status_sbe_intram0_Msk (0x1UL)        /*!< ecc_ctrl_app ecc_ctrl_status_sbe: intram0 (Bitfield-Mask: 0x01) */
/* ==================================================  ecc_ctrl_status_dbe  ================================================== */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_iflash2_Pos (26UL)         /*!< ecc_ctrl_app ecc_ctrl_status_dbe: iflash2 (Bit 26)    */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_iflash2_Msk (0x4000000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: iflash2 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_iflash1_Pos (25UL)         /*!< ecc_ctrl_app ecc_ctrl_status_dbe: iflash1 (Bit 25)    */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_iflash1_Msk (0x2000000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: iflash1 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_iflash0_Pos (24UL)         /*!< ecc_ctrl_app ecc_ctrl_status_dbe: iflash0 (Bit 24)    */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_iflash0_Msk (0x1000000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: iflash0 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic1_dram_Pos (23UL)      /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic1_dram (Bit 23) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic1_dram_Msk (0x800000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic1_dram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic0_dram_Pos (22UL)      /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic0_dram (Bit 22) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic0_dram_Msk (0x400000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic0_dram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic1_pram_Pos (21UL)      /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic1_pram (Bit 21) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic1_pram_Msk (0x200000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic1_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic0_pram_Pos (20UL)      /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic0_pram (Bit 20) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xpic0_pram_Msk (0x100000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xpic0_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_pfifo_Pos (19UL)       /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_pfifo (Bit 19)  */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_pfifo_Msk (0x80000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_pfifo (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpu1_ram_Pos (18UL)    /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpu1_ram (Bit 18) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpu1_ram_Msk (0x40000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpu1_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpu0_ram_Pos (17UL)    /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpu0_ram (Bit 17) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpu0_ram_Msk (0x20000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpu0_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpu1_ram_Pos (16UL)    /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpu1_ram (Bit 16) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpu1_ram_Msk (0x10000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpu1_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpu0_ram_Pos (15UL)    /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpu0_ram (Bit 15) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpu0_ram_Msk (0x8000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpu0_ram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_dpram1_Pos (14UL)      /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_dpram1 (Bit 14) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_dpram1_Msk (0x4000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_dpram1 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_dpram0_Pos (13UL)      /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_dpram0 (Bit 13) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_dpram0_Msk (0x2000UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_dpram0 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpec1_pram_Pos (12UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpec1_pram (Bit 12) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpec1_pram_Msk (0x1000UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpec1_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpec0_pram_Pos (11UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpec0_pram (Bit 11) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_tpec0_pram_Msk (0x800UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_tpec0_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpec1_pram_Pos (10UL)  /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpec1_pram (Bit 10) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpec1_pram_Msk (0x400UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpec1_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpec0_pram_Pos (9UL)   /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpec0_pram (Bit 9) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_xc0_rpec0_pram_Msk (0x200UL) /*!< ecc_ctrl_app ecc_ctrl_status_dbe: xc0_rpec0_pram (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intramhs_Pos (8UL)         /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intramhs (Bit 8)    */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intramhs_Msk (0x100UL)     /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intramhs (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram7_Pos (7UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram7 (Bit 7)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram7_Msk (0x80UL)       /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram7 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram6_Pos (6UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram6 (Bit 6)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram6_Msk (0x40UL)       /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram6 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram5_Pos (5UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram5 (Bit 5)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram5_Msk (0x20UL)       /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram5 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram4_Pos (4UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram4 (Bit 4)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram4_Msk (0x10UL)       /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram4 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram3_Pos (3UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram3 (Bit 3)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram3_Msk (0x8UL)        /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram3 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram2_Pos (2UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram2 (Bit 2)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram2_Msk (0x4UL)        /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram2 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram1_Pos (1UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram1 (Bit 1)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram1_Msk (0x2UL)        /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram1 (Bitfield-Mask: 0x01) */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram0_Pos (0UL)          /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram0 (Bit 0)     */
#define ecc_ctrl_app_ecc_ctrl_status_dbe_intram0_Msk (0x1UL)        /*!< ecc_ctrl_app ecc_ctrl_status_dbe: intram0 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         gpio_app                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  gpio_app_cfg  ====================================================== */
#define gpio_app_gpio_app_cfg_blink_once_Pos (12UL)                 /*!< gpio_app gpio_app_cfg: blink_once (Bit 12)            */
#define gpio_app_gpio_app_cfg_blink_once_Msk (0x1000UL)             /*!< gpio_app gpio_app_cfg: blink_once (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cfg_blink_len_Pos (7UL)                   /*!< gpio_app gpio_app_cfg: blink_len (Bit 7)              */
#define gpio_app_gpio_app_cfg_blink_len_Msk (0xf80UL)               /*!< gpio_app gpio_app_cfg: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_app_gpio_app_cfg_count_ref_Pos (5UL)                   /*!< gpio_app gpio_app_cfg: count_ref (Bit 5)              */
#define gpio_app_gpio_app_cfg_count_ref_Msk (0x60UL)                /*!< gpio_app gpio_app_cfg: count_ref (Bitfield-Mask: 0x03) */
#define gpio_app_gpio_app_cfg_inv_Pos     (4UL)                     /*!< gpio_app gpio_app_cfg: inv (Bit 4)                    */
#define gpio_app_gpio_app_cfg_inv_Msk     (0x10UL)                  /*!< gpio_app gpio_app_cfg: inv (Bitfield-Mask: 0x01)      */
#define gpio_app_gpio_app_cfg_mode_Pos    (0UL)                     /*!< gpio_app gpio_app_cfg: mode (Bit 0)                   */
#define gpio_app_gpio_app_cfg_mode_Msk    (0xfUL)                   /*!< gpio_app gpio_app_cfg: mode (Bitfield-Mask: 0x0f)     */
/* ======================================================  gpio_app_tc  ====================================================== */
#define gpio_app_gpio_app_tc_val_Pos      (0UL)                     /*!< gpio_app gpio_app_tc: val (Bit 0)                     */
#define gpio_app_gpio_app_tc_val_Msk      (0xffffffffUL)            /*!< gpio_app gpio_app_tc: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  gpio_app_counter_ctrl  ================================================= */
#define gpio_app_gpio_app_counter_ctrl_gpio_ref_Pos (7UL)           /*!< gpio_app gpio_app_counter_ctrl: gpio_ref (Bit 7)      */
#define gpio_app_gpio_app_counter_ctrl_gpio_ref_Msk (0x380UL)       /*!< gpio_app gpio_app_counter_ctrl: gpio_ref (Bitfield-Mask: 0x07) */
#define gpio_app_gpio_app_counter_ctrl_event_act_Pos (5UL)          /*!< gpio_app gpio_app_counter_ctrl: event_act (Bit 5)     */
#define gpio_app_gpio_app_counter_ctrl_event_act_Msk (0x60UL)       /*!< gpio_app gpio_app_counter_ctrl: event_act (Bitfield-Mask: 0x03) */
#define gpio_app_gpio_app_counter_ctrl_once_Pos (4UL)               /*!< gpio_app gpio_app_counter_ctrl: once (Bit 4)          */
#define gpio_app_gpio_app_counter_ctrl_once_Msk (0x10UL)            /*!< gpio_app gpio_app_counter_ctrl: once (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_counter_ctrl_sel_event_Pos (3UL)          /*!< gpio_app gpio_app_counter_ctrl: sel_event (Bit 3)     */
#define gpio_app_gpio_app_counter_ctrl_sel_event_Msk (0x8UL)        /*!< gpio_app gpio_app_counter_ctrl: sel_event (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_counter_ctrl_irq_en_Pos (2UL)             /*!< gpio_app gpio_app_counter_ctrl: irq_en (Bit 2)        */
#define gpio_app_gpio_app_counter_ctrl_irq_en_Msk (0x4UL)           /*!< gpio_app gpio_app_counter_ctrl: irq_en (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_counter_ctrl_sym_nasym_Pos (1UL)          /*!< gpio_app gpio_app_counter_ctrl: sym_nasym (Bit 1)     */
#define gpio_app_gpio_app_counter_ctrl_sym_nasym_Msk (0x2UL)        /*!< gpio_app gpio_app_counter_ctrl: sym_nasym (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_counter_ctrl_run_Pos (0UL)                /*!< gpio_app gpio_app_counter_ctrl: run (Bit 0)           */
#define gpio_app_gpio_app_counter_ctrl_run_Msk (0x1UL)              /*!< gpio_app gpio_app_counter_ctrl: run (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_counter_max  ================================================== */
#define gpio_app_gpio_app_counter_max_val_Pos (0UL)                 /*!< gpio_app gpio_app_counter_max: val (Bit 0)            */
#define gpio_app_gpio_app_counter_max_val_Msk (0xffffffffUL)        /*!< gpio_app gpio_app_counter_max: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  gpio_app_counter_cnt  ================================================== */
#define gpio_app_gpio_app_counter_cnt_val_Pos (0UL)                 /*!< gpio_app gpio_app_counter_cnt: val (Bit 0)            */
#define gpio_app_gpio_app_counter_cnt_val_Msk (0xffffffffUL)        /*!< gpio_app gpio_app_counter_cnt: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_line  ===================================================== */
#define gpio_app_gpio_app_line_val_Pos    (0UL)                     /*!< gpio_app gpio_app_line: val (Bit 0)                   */
#define gpio_app_gpio_app_line_val_Msk    (0xffUL)                  /*!< gpio_app gpio_app_line: val (Bitfield-Mask: 0xff)     */
/* ======================================================  gpio_app_in  ====================================================== */
#define gpio_app_gpio_app_in_val_Pos      (0UL)                     /*!< gpio_app gpio_app_in: val (Bit 0)                     */
#define gpio_app_gpio_app_in_val_Msk      (0xffUL)                  /*!< gpio_app gpio_app_in: val (Bitfield-Mask: 0xff)       */
/* ===================================================  gpio_app_irq_raw  ==================================================== */
#define gpio_app_gpio_app_irq_raw_gpio_app7_Pos (7UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app7 (Bit 7)          */
#define gpio_app_gpio_app_irq_raw_gpio_app7_Msk (0x80UL)            /*!< gpio_app gpio_app_irq_raw: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_raw_gpio_app6_Pos (6UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app6 (Bit 6)          */
#define gpio_app_gpio_app_irq_raw_gpio_app6_Msk (0x40UL)            /*!< gpio_app gpio_app_irq_raw: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_raw_gpio_app5_Pos (5UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app5 (Bit 5)          */
#define gpio_app_gpio_app_irq_raw_gpio_app5_Msk (0x20UL)            /*!< gpio_app gpio_app_irq_raw: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_raw_gpio_app4_Pos (4UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app4 (Bit 4)          */
#define gpio_app_gpio_app_irq_raw_gpio_app4_Msk (0x10UL)            /*!< gpio_app gpio_app_irq_raw: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_raw_gpio_app3_Pos (3UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app3 (Bit 3)          */
#define gpio_app_gpio_app_irq_raw_gpio_app3_Msk (0x8UL)             /*!< gpio_app gpio_app_irq_raw: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_raw_gpio_app2_Pos (2UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app2 (Bit 2)          */
#define gpio_app_gpio_app_irq_raw_gpio_app2_Msk (0x4UL)             /*!< gpio_app gpio_app_irq_raw: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_raw_gpio_app1_Pos (1UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app1 (Bit 1)          */
#define gpio_app_gpio_app_irq_raw_gpio_app1_Msk (0x2UL)             /*!< gpio_app gpio_app_irq_raw: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_raw_gpio_app0_Pos (0UL)               /*!< gpio_app gpio_app_irq_raw: gpio_app0 (Bit 0)          */
#define gpio_app_gpio_app_irq_raw_gpio_app0_Msk (0x1UL)             /*!< gpio_app gpio_app_irq_raw: gpio_app0 (Bitfield-Mask: 0x01) */
/* ==================================================  gpio_app_irq_masked  ================================================== */
#define gpio_app_gpio_app_irq_masked_gpio_app7_Pos (7UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app7 (Bit 7)       */
#define gpio_app_gpio_app_irq_masked_gpio_app7_Msk (0x80UL)         /*!< gpio_app gpio_app_irq_masked: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_masked_gpio_app6_Pos (6UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app6 (Bit 6)       */
#define gpio_app_gpio_app_irq_masked_gpio_app6_Msk (0x40UL)         /*!< gpio_app gpio_app_irq_masked: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_masked_gpio_app5_Pos (5UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app5 (Bit 5)       */
#define gpio_app_gpio_app_irq_masked_gpio_app5_Msk (0x20UL)         /*!< gpio_app gpio_app_irq_masked: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_masked_gpio_app4_Pos (4UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app4 (Bit 4)       */
#define gpio_app_gpio_app_irq_masked_gpio_app4_Msk (0x10UL)         /*!< gpio_app gpio_app_irq_masked: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_masked_gpio_app3_Pos (3UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app3 (Bit 3)       */
#define gpio_app_gpio_app_irq_masked_gpio_app3_Msk (0x8UL)          /*!< gpio_app gpio_app_irq_masked: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_masked_gpio_app2_Pos (2UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app2 (Bit 2)       */
#define gpio_app_gpio_app_irq_masked_gpio_app2_Msk (0x4UL)          /*!< gpio_app gpio_app_irq_masked: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_masked_gpio_app1_Pos (1UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app1 (Bit 1)       */
#define gpio_app_gpio_app_irq_masked_gpio_app1_Msk (0x2UL)          /*!< gpio_app gpio_app_irq_masked: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_masked_gpio_app0_Pos (0UL)            /*!< gpio_app gpio_app_irq_masked: gpio_app0 (Bit 0)       */
#define gpio_app_gpio_app_irq_masked_gpio_app0_Msk (0x1UL)          /*!< gpio_app gpio_app_irq_masked: gpio_app0 (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_irq_mask_set  ================================================= */
#define gpio_app_gpio_app_irq_mask_set_gpio_app7_Pos (7UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app7 (Bit 7)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app7_Msk (0x80UL)       /*!< gpio_app gpio_app_irq_mask_set: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_set_gpio_app6_Pos (6UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app6 (Bit 6)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app6_Msk (0x40UL)       /*!< gpio_app gpio_app_irq_mask_set: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_set_gpio_app5_Pos (5UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app5 (Bit 5)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app5_Msk (0x20UL)       /*!< gpio_app gpio_app_irq_mask_set: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_set_gpio_app4_Pos (4UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app4 (Bit 4)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app4_Msk (0x10UL)       /*!< gpio_app gpio_app_irq_mask_set: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_set_gpio_app3_Pos (3UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app3 (Bit 3)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app3_Msk (0x8UL)        /*!< gpio_app gpio_app_irq_mask_set: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_set_gpio_app2_Pos (2UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app2 (Bit 2)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app2_Msk (0x4UL)        /*!< gpio_app gpio_app_irq_mask_set: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_set_gpio_app1_Pos (1UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app1 (Bit 1)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app1_Msk (0x2UL)        /*!< gpio_app gpio_app_irq_mask_set: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_set_gpio_app0_Pos (0UL)          /*!< gpio_app gpio_app_irq_mask_set: gpio_app0 (Bit 0)     */
#define gpio_app_gpio_app_irq_mask_set_gpio_app0_Msk (0x1UL)        /*!< gpio_app gpio_app_irq_mask_set: gpio_app0 (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_irq_mask_rst  ================================================= */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app7_Pos (7UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app7 (Bit 7)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app7_Msk (0x80UL)       /*!< gpio_app gpio_app_irq_mask_rst: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app6_Pos (6UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app6 (Bit 6)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app6_Msk (0x40UL)       /*!< gpio_app gpio_app_irq_mask_rst: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app5_Pos (5UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app5 (Bit 5)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app5_Msk (0x20UL)       /*!< gpio_app gpio_app_irq_mask_rst: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app4_Pos (4UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app4 (Bit 4)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app4_Msk (0x10UL)       /*!< gpio_app gpio_app_irq_mask_rst: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app3_Pos (3UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app3 (Bit 3)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app3_Msk (0x8UL)        /*!< gpio_app gpio_app_irq_mask_rst: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app2_Pos (2UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app2 (Bit 2)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app2_Msk (0x4UL)        /*!< gpio_app gpio_app_irq_mask_rst: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app1_Pos (1UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app1 (Bit 1)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app1_Msk (0x2UL)        /*!< gpio_app gpio_app_irq_mask_rst: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app0_Pos (0UL)          /*!< gpio_app gpio_app_irq_mask_rst: gpio_app0 (Bit 0)     */
#define gpio_app_gpio_app_irq_mask_rst_gpio_app0_Msk (0x1UL)        /*!< gpio_app gpio_app_irq_mask_rst: gpio_app0 (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_cnt_irq_raw  ================================================== */
#define gpio_app_gpio_app_cnt_irq_raw_cnt2_Pos (2UL)                /*!< gpio_app gpio_app_cnt_irq_raw: cnt2 (Bit 2)           */
#define gpio_app_gpio_app_cnt_irq_raw_cnt2_Msk (0x4UL)              /*!< gpio_app gpio_app_cnt_irq_raw: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_raw_cnt1_Pos (1UL)                /*!< gpio_app gpio_app_cnt_irq_raw: cnt1 (Bit 1)           */
#define gpio_app_gpio_app_cnt_irq_raw_cnt1_Msk (0x2UL)              /*!< gpio_app gpio_app_cnt_irq_raw: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_raw_cnt0_Pos (0UL)                /*!< gpio_app gpio_app_cnt_irq_raw: cnt0 (Bit 0)           */
#define gpio_app_gpio_app_cnt_irq_raw_cnt0_Msk (0x1UL)              /*!< gpio_app gpio_app_cnt_irq_raw: cnt0 (Bitfield-Mask: 0x01) */
/* ================================================  gpio_app_cnt_irq_masked  ================================================ */
#define gpio_app_gpio_app_cnt_irq_masked_cnt2_Pos (2UL)             /*!< gpio_app gpio_app_cnt_irq_masked: cnt2 (Bit 2)        */
#define gpio_app_gpio_app_cnt_irq_masked_cnt2_Msk (0x4UL)           /*!< gpio_app gpio_app_cnt_irq_masked: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_masked_cnt1_Pos (1UL)             /*!< gpio_app gpio_app_cnt_irq_masked: cnt1 (Bit 1)        */
#define gpio_app_gpio_app_cnt_irq_masked_cnt1_Msk (0x2UL)           /*!< gpio_app gpio_app_cnt_irq_masked: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_masked_cnt0_Pos (0UL)             /*!< gpio_app gpio_app_cnt_irq_masked: cnt0 (Bit 0)        */
#define gpio_app_gpio_app_cnt_irq_masked_cnt0_Msk (0x1UL)           /*!< gpio_app gpio_app_cnt_irq_masked: cnt0 (Bitfield-Mask: 0x01) */
/* ===============================================  gpio_app_cnt_irq_mask_set  =============================================== */
#define gpio_app_gpio_app_cnt_irq_mask_set_cnt2_Pos (2UL)           /*!< gpio_app gpio_app_cnt_irq_mask_set: cnt2 (Bit 2)      */
#define gpio_app_gpio_app_cnt_irq_mask_set_cnt2_Msk (0x4UL)         /*!< gpio_app gpio_app_cnt_irq_mask_set: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_mask_set_cnt1_Pos (1UL)           /*!< gpio_app gpio_app_cnt_irq_mask_set: cnt1 (Bit 1)      */
#define gpio_app_gpio_app_cnt_irq_mask_set_cnt1_Msk (0x2UL)         /*!< gpio_app gpio_app_cnt_irq_mask_set: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_mask_set_cnt0_Pos (0UL)           /*!< gpio_app gpio_app_cnt_irq_mask_set: cnt0 (Bit 0)      */
#define gpio_app_gpio_app_cnt_irq_mask_set_cnt0_Msk (0x1UL)         /*!< gpio_app gpio_app_cnt_irq_mask_set: cnt0 (Bitfield-Mask: 0x01) */
/* ===============================================  gpio_app_cnt_irq_mask_rst  =============================================== */
#define gpio_app_gpio_app_cnt_irq_mask_rst_cnt2_Pos (2UL)           /*!< gpio_app gpio_app_cnt_irq_mask_rst: cnt2 (Bit 2)      */
#define gpio_app_gpio_app_cnt_irq_mask_rst_cnt2_Msk (0x4UL)         /*!< gpio_app gpio_app_cnt_irq_mask_rst: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_mask_rst_cnt1_Pos (1UL)           /*!< gpio_app gpio_app_cnt_irq_mask_rst: cnt1 (Bit 1)      */
#define gpio_app_gpio_app_cnt_irq_mask_rst_cnt1_Msk (0x2UL)         /*!< gpio_app gpio_app_cnt_irq_mask_rst: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_app_gpio_app_cnt_irq_mask_rst_cnt0_Pos (0UL)           /*!< gpio_app gpio_app_cnt_irq_mask_rst: cnt0 (Bit 0)      */
#define gpio_app_gpio_app_cnt_irq_mask_rst_cnt0_Msk (0x1UL)         /*!< gpio_app gpio_app_cnt_irq_mask_rst: cnt0 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                      systime_lt_app                                       ================ */
/* =========================================================================================================================== */

/* ==============================================  intlogic_lt_systime_com_ns  =============================================== */
#define systime_lt_app_intlogic_lt_systime_com_ns_val_Pos (0UL)     /*!< systime_lt_app intlogic_lt_systime_com_ns: val (Bit 0) */
#define systime_lt_app_intlogic_lt_systime_com_ns_val_Msk (0xffffffffUL) /*!< systime_lt_app intlogic_lt_systime_com_ns: val (Bitfield-Mask: 0xffffffff) */
/* ===============================================  intlogic_lt_systime_com_s  =============================================== */
#define systime_lt_app_intlogic_lt_systime_com_s_val_Pos (0UL)      /*!< systime_lt_app intlogic_lt_systime_com_s: val (Bit 0) */
#define systime_lt_app_intlogic_lt_systime_com_s_val_Msk (0xffffffffUL) /*!< systime_lt_app intlogic_lt_systime_com_s: val (Bitfield-Mask: 0xffffffff) */
/* =============================================  intlogic_lt_systime_com_uc_ns  ============================================= */
#define systime_lt_app_intlogic_lt_systime_com_uc_ns_val_Pos (0UL)  /*!< systime_lt_app intlogic_lt_systime_com_uc_ns: val (Bit 0) */
#define systime_lt_app_intlogic_lt_systime_com_uc_ns_val_Msk (0xffffffffUL) /*!< systime_lt_app intlogic_lt_systime_com_uc_ns: val (Bitfield-Mask: 0xffffffff) */
/* =============================================  intlogic_lt_systime_com_uc_s  ============================================== */
#define systime_lt_app_intlogic_lt_systime_com_uc_s_val_Pos (0UL)   /*!< systime_lt_app intlogic_lt_systime_com_uc_s: val (Bit 0) */
#define systime_lt_app_intlogic_lt_systime_com_uc_s_val_Msk (0xffffffffUL) /*!< systime_lt_app intlogic_lt_systime_com_uc_s: val (Bitfield-Mask: 0xffffffff) */
/* ==============================================  intlogic_lt_systime_app_ns  =============================================== */
#define systime_lt_app_intlogic_lt_systime_app_ns_val_Pos (0UL)     /*!< systime_lt_app intlogic_lt_systime_app_ns: val (Bit 0) */
#define systime_lt_app_intlogic_lt_systime_app_ns_val_Msk (0xffffffffUL) /*!< systime_lt_app intlogic_lt_systime_app_ns: val (Bitfield-Mask: 0xffffffff) */
/* ===============================================  intlogic_lt_systime_app_s  =============================================== */
#define systime_lt_app_intlogic_lt_systime_app_s_val_Pos (0UL)      /*!< systime_lt_app intlogic_lt_systime_app_s: val (Bit 0) */
#define systime_lt_app_intlogic_lt_systime_app_s_val_Msk (0xffffffffUL) /*!< systime_lt_app intlogic_lt_systime_app_s: val (Bitfield-Mask: 0xffffffff) */
/* ==============================================  intlogic_lt_systimes_latch  =============================================== */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_app_s_Pos (5UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_app_s (Bit 5) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_app_s_Msk (0x20UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_app_s (Bitfield-Mask: 0x01) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_app_ns_Pos (4UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_app_ns (Bit 4) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_app_ns_Msk (0x10UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_app_ns (Bitfield-Mask: 0x01) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_uc_s_Pos (3UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_uc_s (Bit 3) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_uc_s_Msk (0x8UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_uc_s (Bitfield-Mask: 0x01) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_uc_ns_Pos (2UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_uc_ns (Bit 2) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_uc_ns_Msk (0x4UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_uc_ns (Bitfield-Mask: 0x01) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_s_Pos (1UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_s (Bit 1) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_s_Msk (0x2UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_s (Bitfield-Mask: 0x01) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_ns_Pos (0UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_ns (Bit 0) */
#define systime_lt_app_intlogic_lt_systimes_latch_systime_com_ns_Msk (0x1UL) /*!< systime_lt_app intlogic_lt_systimes_latch: systime_com_ns (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         timer_app                                         ================ */
/* =========================================================================================================================== */

/* ==================================================  timer_config_timer  =================================================== */
#define timer_app_timer_config_timer_systime_config_Pos (2UL)       /*!< timer_app timer_config_timer: systime_config (Bit 2)  */
#define timer_app_timer_config_timer_systime_config_Msk (0xcUL)     /*!< timer_app timer_config_timer: systime_config (Bitfield-Mask: 0x03) */
#define timer_app_timer_config_timer_mode_Pos (0UL)                 /*!< timer_app timer_config_timer: mode (Bit 0)            */
#define timer_app_timer_config_timer_mode_Msk (0x3UL)               /*!< timer_app timer_config_timer: mode (Bitfield-Mask: 0x03) */
/* ==================================================  timer_preload_timer  ================================================== */
#define timer_app_timer_preload_timer_val_Pos (0UL)                 /*!< timer_app timer_preload_timer: val (Bit 0)            */
#define timer_app_timer_preload_timer_val_Msk (0xffffffffUL)        /*!< timer_app timer_preload_timer: val (Bitfield-Mask: 0xffffffff) */
/* ======================================================  timer_timer  ====================================================== */
#define timer_app_timer_timer_val_Pos     (0UL)                     /*!< timer_app timer_timer: val (Bit 0)                    */
#define timer_app_timer_timer_val_Msk     (0xffffffffUL)            /*!< timer_app timer_timer: val (Bitfield-Mask: 0xffffffff) */
/* ====================================================  timer_systime_s  ==================================================== */
#define timer_app_timer_systime_s_val_Pos (0UL)                     /*!< timer_app timer_systime_s: val (Bit 0)                */
#define timer_app_timer_systime_s_val_Msk (0xffffffffUL)            /*!< timer_app timer_systime_s: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  timer_systime_ns  ==================================================== */
#define timer_app_timer_systime_ns_val_Pos (0UL)                    /*!< timer_app timer_systime_ns: val (Bit 0)               */
#define timer_app_timer_systime_ns_val_Msk (0xffffffffUL)           /*!< timer_app timer_systime_ns: val (Bitfield-Mask: 0xffffffff) */
/* =============================================  timer_compare_systime_s_value  ============================================= */
#define timer_app_timer_compare_systime_s_value_val_Pos (0UL)       /*!< timer_app timer_compare_systime_s_value: val (Bit 0)  */
#define timer_app_timer_compare_systime_s_value_val_Msk (0xffffffffUL) /*!< timer_app timer_compare_systime_s_value: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  timer_irq_raw  ===================================================== */
#define timer_app_timer_irq_raw_systime_s_irq_Pos (3UL)             /*!< timer_app timer_irq_raw: systime_s_irq (Bit 3)        */
#define timer_app_timer_irq_raw_systime_s_irq_Msk (0x8UL)           /*!< timer_app timer_irq_raw: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_raw_timer2_irq_Pos (2UL)                /*!< timer_app timer_irq_raw: timer2_irq (Bit 2)           */
#define timer_app_timer_irq_raw_timer2_irq_Msk (0x4UL)              /*!< timer_app timer_irq_raw: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_raw_timer1_irq_Pos (1UL)                /*!< timer_app timer_irq_raw: timer1_irq (Bit 1)           */
#define timer_app_timer_irq_raw_timer1_irq_Msk (0x2UL)              /*!< timer_app timer_irq_raw: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_raw_timer0_irq_Pos (0UL)                /*!< timer_app timer_irq_raw: timer0_irq (Bit 0)           */
#define timer_app_timer_irq_raw_timer0_irq_Msk (0x1UL)              /*!< timer_app timer_irq_raw: timer0_irq (Bitfield-Mask: 0x01) */
/* ===================================================  timer_irq_masked  ==================================================== */
#define timer_app_timer_irq_masked_systime_s_irq_Pos (3UL)          /*!< timer_app timer_irq_masked: systime_s_irq (Bit 3)     */
#define timer_app_timer_irq_masked_systime_s_irq_Msk (0x8UL)        /*!< timer_app timer_irq_masked: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_masked_timer2_irq_Pos (2UL)             /*!< timer_app timer_irq_masked: timer2_irq (Bit 2)        */
#define timer_app_timer_irq_masked_timer2_irq_Msk (0x4UL)           /*!< timer_app timer_irq_masked: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_masked_timer1_irq_Pos (1UL)             /*!< timer_app timer_irq_masked: timer1_irq (Bit 1)        */
#define timer_app_timer_irq_masked_timer1_irq_Msk (0x2UL)           /*!< timer_app timer_irq_masked: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_masked_timer0_irq_Pos (0UL)             /*!< timer_app timer_irq_masked: timer0_irq (Bit 0)        */
#define timer_app_timer_irq_masked_timer0_irq_Msk (0x1UL)           /*!< timer_app timer_irq_masked: timer0_irq (Bitfield-Mask: 0x01) */
/* ===================================================  timer_irq_msk_set  =================================================== */
#define timer_app_timer_irq_msk_set_systime_s_irq_Pos (3UL)         /*!< timer_app timer_irq_msk_set: systime_s_irq (Bit 3)    */
#define timer_app_timer_irq_msk_set_systime_s_irq_Msk (0x8UL)       /*!< timer_app timer_irq_msk_set: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_msk_set_timer2_irq_Pos (2UL)            /*!< timer_app timer_irq_msk_set: timer2_irq (Bit 2)       */
#define timer_app_timer_irq_msk_set_timer2_irq_Msk (0x4UL)          /*!< timer_app timer_irq_msk_set: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_msk_set_timer1_irq_Pos (1UL)            /*!< timer_app timer_irq_msk_set: timer1_irq (Bit 1)       */
#define timer_app_timer_irq_msk_set_timer1_irq_Msk (0x2UL)          /*!< timer_app timer_irq_msk_set: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_msk_set_timer0_irq_Pos (0UL)            /*!< timer_app timer_irq_msk_set: timer0_irq (Bit 0)       */
#define timer_app_timer_irq_msk_set_timer0_irq_Msk (0x1UL)          /*!< timer_app timer_irq_msk_set: timer0_irq (Bitfield-Mask: 0x01) */
/* ==================================================  timer_irq_msk_reset  ================================================== */
#define timer_app_timer_irq_msk_reset_systime_s_irq_Pos (3UL)       /*!< timer_app timer_irq_msk_reset: systime_s_irq (Bit 3)  */
#define timer_app_timer_irq_msk_reset_systime_s_irq_Msk (0x8UL)     /*!< timer_app timer_irq_msk_reset: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_msk_reset_timer2_irq_Pos (2UL)          /*!< timer_app timer_irq_msk_reset: timer2_irq (Bit 2)     */
#define timer_app_timer_irq_msk_reset_timer2_irq_Msk (0x4UL)        /*!< timer_app timer_irq_msk_reset: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_msk_reset_timer1_irq_Pos (1UL)          /*!< timer_app timer_irq_msk_reset: timer1_irq (Bit 1)     */
#define timer_app_timer_irq_msk_reset_timer1_irq_Msk (0x2UL)        /*!< timer_app timer_irq_msk_reset: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_app_timer_irq_msk_reset_timer0_irq_Pos (0UL)          /*!< timer_app timer_irq_msk_reset: timer0_irq (Bit 0)     */
#define timer_app_timer_irq_msk_reset_timer0_irq_Msk (0x1UL)        /*!< timer_app timer_irq_msk_reset: timer0_irq (Bitfield-Mask: 0x01) */
/* =================================================  timer_systime_config  ================================================== */
#define timer_app_timer_systime_config_systime_config_Pos (0UL)     /*!< timer_app timer_systime_config: systime_config (Bit 0) */
#define timer_app_timer_systime_config_systime_config_Msk (0x3UL)   /*!< timer_app timer_systime_config: systime_config (Bitfield-Mask: 0x03) */


/* =========================================================================================================================== */
/* ================                                        systime_app                                        ================ */
/* =========================================================================================================================== */

/* =======================================================  systime_s  ======================================================= */
#define systime_app_systime_s_systime_s_Pos (0UL)                   /*!< systime_app systime_s: systime_s (Bit 0)              */
#define systime_app_systime_s_systime_s_Msk (0xffffffffUL)          /*!< systime_app systime_s: systime_s (Bitfield-Mask: 0xffffffff) */
/* ======================================================  systime_ns  ======================================================= */
#define systime_app_systime_ns_systime_ns_Pos (0UL)                 /*!< systime_app systime_ns: systime_ns (Bit 0)            */
#define systime_app_systime_ns_systime_ns_Msk (0xffffffffUL)        /*!< systime_app systime_ns: systime_ns (Bitfield-Mask: 0xffffffff) */
/* ====================================================  systime_border  ===================================================== */
#define systime_app_systime_border_systime_border_Pos (0UL)         /*!< systime_app systime_border: systime_border (Bit 0)    */
#define systime_app_systime_border_systime_border_Msk (0xffffffffUL) /*!< systime_app systime_border: systime_border (Bitfield-Mask: 0xffffffff) */
/* ==================================================  systime_count_value  ================================================== */
#define systime_app_systime_count_value_systime_count_value_Pos (0UL) /*!< systime_app systime_count_value: systime_count_value (Bit 0) */
#define systime_app_systime_count_value_systime_count_value_Msk (0xffffffffUL) /*!< systime_app systime_count_value: systime_count_value (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                          mcp_app                                          ================ */
/* =========================================================================================================================== */

/* ====================================================  hs_irq_set_raw  ===================================================== */
#define mcp_app_hs_irq_set_raw_hs_irq_set_bits_Pos (0UL)            /*!< mcp_app hs_irq_set_raw: hs_irq_set_bits (Bit 0)       */
#define mcp_app_hs_irq_set_raw_hs_irq_set_bits_Msk (0xffffffffUL)   /*!< mcp_app hs_irq_set_raw: hs_irq_set_bits (Bitfield-Mask: 0xffffffff) */
/* ===================================================  hs_irq_reset_raw  ==================================================== */
#define mcp_app_hs_irq_reset_raw_hs_irq_reset_bits_Pos (0UL)        /*!< mcp_app hs_irq_reset_raw: hs_irq_reset_bits (Bit 0)   */
#define mcp_app_hs_irq_reset_raw_hs_irq_reset_bits_Msk (0xffffffffUL) /*!< mcp_app hs_irq_reset_raw: hs_irq_reset_bits (Bitfield-Mask: 0xffffffff) */
/* ====================================================  hs_irq_set_mask  ==================================================== */
#define mcp_app_hs_irq_set_mask_hs_irq_set_mask_Pos (0UL)           /*!< mcp_app hs_irq_set_mask: hs_irq_set_mask (Bit 0)      */
#define mcp_app_hs_irq_set_mask_hs_irq_set_mask_Msk (0xffffffffUL)  /*!< mcp_app hs_irq_set_mask: hs_irq_set_mask (Bitfield-Mask: 0xffffffff) */
/* ===================================================  hs_irq_reset_mask  =================================================== */
#define mcp_app_hs_irq_reset_mask_hs_irq_reset_mask_Pos (0UL)       /*!< mcp_app hs_irq_reset_mask: hs_irq_reset_mask (Bit 0)  */
#define mcp_app_hs_irq_reset_mask_hs_irq_reset_mask_Msk (0xffffffffUL) /*!< mcp_app hs_irq_reset_mask: hs_irq_reset_mask (Bitfield-Mask: 0xffffffff) */
/* =====================================================  hs_irq_masked  ===================================================== */
#define mcp_app_hs_irq_masked_hs_irq_masked_Pos (0UL)               /*!< mcp_app hs_irq_masked: hs_irq_masked (Bit 0)          */
#define mcp_app_hs_irq_masked_hs_irq_masked_Msk (0xffffffffUL)      /*!< mcp_app hs_irq_masked: hs_irq_masked (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                          wdg_app                                          ================ */
/* =========================================================================================================================== */

/* ===================================================  netx_sys_wdg_ctrl  =================================================== */
#define wdg_app_netx_sys_wdg_ctrl_write_enable_Pos (31UL)           /*!< wdg_app netx_sys_wdg_ctrl: write_enable (Bit 31)      */
#define wdg_app_netx_sys_wdg_ctrl_write_enable_Msk (0x80000000UL)   /*!< wdg_app netx_sys_wdg_ctrl: write_enable (Bitfield-Mask: 0x01) */
#define wdg_app_netx_sys_wdg_ctrl_reserved2_Pos (29UL)              /*!< wdg_app netx_sys_wdg_ctrl: reserved2 (Bit 29)         */
#define wdg_app_netx_sys_wdg_ctrl_reserved2_Msk (0x60000000UL)      /*!< wdg_app netx_sys_wdg_ctrl: reserved2 (Bitfield-Mask: 0x03) */
#define wdg_app_netx_sys_wdg_ctrl_wdg_counter_trigger_w_Pos (28UL)  /*!< wdg_app netx_sys_wdg_ctrl: wdg_counter_trigger_w (Bit 28) */
#define wdg_app_netx_sys_wdg_ctrl_wdg_counter_trigger_w_Msk (0x10000000UL) /*!< wdg_app netx_sys_wdg_ctrl: wdg_counter_trigger_w (Bitfield-Mask: 0x01) */
#define wdg_app_netx_sys_wdg_ctrl_reserved1_Pos (25UL)              /*!< wdg_app netx_sys_wdg_ctrl: reserved1 (Bit 25)         */
#define wdg_app_netx_sys_wdg_ctrl_reserved1_Msk (0xe000000UL)       /*!< wdg_app netx_sys_wdg_ctrl: reserved1 (Bitfield-Mask: 0x07) */
#define wdg_app_netx_sys_wdg_ctrl_irq_req_watchdog_Pos (24UL)       /*!< wdg_app netx_sys_wdg_ctrl: irq_req_watchdog (Bit 24)  */
#define wdg_app_netx_sys_wdg_ctrl_irq_req_watchdog_Msk (0x1000000UL) /*!< wdg_app netx_sys_wdg_ctrl: irq_req_watchdog (Bitfield-Mask: 0x01) */
#define wdg_app_netx_sys_wdg_ctrl_reserved0_Pos (20UL)              /*!< wdg_app netx_sys_wdg_ctrl: reserved0 (Bit 20)         */
#define wdg_app_netx_sys_wdg_ctrl_reserved0_Msk (0xf00000UL)        /*!< wdg_app netx_sys_wdg_ctrl: reserved0 (Bitfield-Mask: 0x0f) */
#define wdg_app_netx_sys_wdg_ctrl_wdg_access_code_Pos (0UL)         /*!< wdg_app netx_sys_wdg_ctrl: wdg_access_code (Bit 0)    */
#define wdg_app_netx_sys_wdg_ctrl_wdg_access_code_Msk (0xfffffUL)   /*!< wdg_app netx_sys_wdg_ctrl: wdg_access_code (Bitfield-Mask: 0xfffff) */
/* =====================================================  netx_sys_wdg  ====================================================== */
#define wdg_app_netx_sys_wdg_wdg_counter_Pos (0UL)                  /*!< wdg_app netx_sys_wdg: wdg_counter (Bit 0)             */
#define wdg_app_netx_sys_wdg_wdg_counter_Msk (0x1ffffUL)            /*!< wdg_app netx_sys_wdg: wdg_counter (Bitfield-Mask: 0x1ffff) */
/* ===============================================  netx_sys_wdg_irq_timeout  ================================================ */
#define wdg_app_netx_sys_wdg_irq_timeout_wdg_irq_timeout_Pos (0UL)  /*!< wdg_app netx_sys_wdg_irq_timeout: wdg_irq_timeout (Bit 0) */
#define wdg_app_netx_sys_wdg_irq_timeout_wdg_irq_timeout_Msk (0xffffUL) /*!< wdg_app netx_sys_wdg_irq_timeout: wdg_irq_timeout (Bitfield-Mask: 0xffff) */
/* ===============================================  netx_sys_wdg_res_timeout  ================================================ */
#define wdg_app_netx_sys_wdg_res_timeout_wdg_res_timeout_Pos (0UL)  /*!< wdg_app netx_sys_wdg_res_timeout: wdg_res_timeout (Bit 0) */
#define wdg_app_netx_sys_wdg_res_timeout_wdg_res_timeout_Msk (0xffffUL) /*!< wdg_app netx_sys_wdg_res_timeout: wdg_res_timeout (Bitfield-Mask: 0xffff) */
/* =================================================  netx_sys_wdg_irq_raw  ================================================== */
#define wdg_app_netx_sys_wdg_irq_raw_wdg_res_irq_Pos (0UL)          /*!< wdg_app netx_sys_wdg_irq_raw: wdg_res_irq (Bit 0)     */
#define wdg_app_netx_sys_wdg_irq_raw_wdg_res_irq_Msk (0x1UL)        /*!< wdg_app netx_sys_wdg_irq_raw: wdg_res_irq (Bitfield-Mask: 0x01) */
/* ================================================  netx_sys_wdg_irq_masked  ================================================ */
#define wdg_app_netx_sys_wdg_irq_masked_wdg_res_irq_Pos (0UL)       /*!< wdg_app netx_sys_wdg_irq_masked: wdg_res_irq (Bit 0)  */
#define wdg_app_netx_sys_wdg_irq_masked_wdg_res_irq_Msk (0x1UL)     /*!< wdg_app netx_sys_wdg_irq_masked: wdg_res_irq (Bitfield-Mask: 0x01) */
/* ===============================================  netx_sys_wdg_irq_msk_set  ================================================ */
#define wdg_app_netx_sys_wdg_irq_msk_set_wdg_res_irq_Pos (0UL)      /*!< wdg_app netx_sys_wdg_irq_msk_set: wdg_res_irq (Bit 0) */
#define wdg_app_netx_sys_wdg_irq_msk_set_wdg_res_irq_Msk (0x1UL)    /*!< wdg_app netx_sys_wdg_irq_msk_set: wdg_res_irq (Bitfield-Mask: 0x01) */
/* ==============================================  netx_sys_wdg_irq_msk_reset  =============================================== */
#define wdg_app_netx_sys_wdg_irq_msk_reset_wdg_res_irq_Pos (0UL)    /*!< wdg_app netx_sys_wdg_irq_msk_reset: wdg_res_irq (Bit 0) */
#define wdg_app_netx_sys_wdg_irq_msk_reset_wdg_res_irq_Msk (0x1UL)  /*!< wdg_app netx_sys_wdg_irq_msk_reset: wdg_res_irq (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                      trigger_irq_app                                      ================ */
/* =========================================================================================================================== */

/* ====================================================  trigger_irq_cfg  ==================================================== */
#define trigger_irq_app_trigger_irq_cfg_xc_trigger_out_polarity_Pos (0UL) /*!< trigger_irq_app trigger_irq_cfg: xc_trigger_out_polarity (Bit 0) */
#define trigger_irq_app_trigger_irq_cfg_xc_trigger_out_polarity_Msk (0x3UL) /*!< trigger_irq_app trigger_irq_cfg: xc_trigger_out_polarity (Bitfield-Mask: 0x03) */
/* ====================================================  trigger_irq_raw  ==================================================== */
#define trigger_irq_app_trigger_irq_raw_xc_trigger_out_edge_Pos (0UL) /*!< trigger_irq_app trigger_irq_raw: xc_trigger_out_edge (Bit 0) */
#define trigger_irq_app_trigger_irq_raw_xc_trigger_out_edge_Msk (0x3UL) /*!< trigger_irq_app trigger_irq_raw: xc_trigger_out_edge (Bitfield-Mask: 0x03) */
/* ==================================================  trigger_irq_masked  =================================================== */
#define trigger_irq_app_trigger_irq_masked_xc_trigger_out_edge_Pos (0UL) /*!< trigger_irq_app trigger_irq_masked: xc_trigger_out_edge (Bit 0) */
#define trigger_irq_app_trigger_irq_masked_xc_trigger_out_edge_Msk (0x3UL) /*!< trigger_irq_app trigger_irq_masked: xc_trigger_out_edge (Bitfield-Mask: 0x03) */
/* ==================================================  trigger_irq_msk_set  ================================================== */
#define trigger_irq_app_trigger_irq_msk_set_xc_trigger_out_edge_Pos (0UL) /*!< trigger_irq_app trigger_irq_msk_set: xc_trigger_out_edge (Bit 0) */
#define trigger_irq_app_trigger_irq_msk_set_xc_trigger_out_edge_Msk (0x3UL) /*!< trigger_irq_app trigger_irq_msk_set: xc_trigger_out_edge (Bitfield-Mask: 0x03) */
/* =================================================  trigger_irq_msk_reset  ================================================= */
#define trigger_irq_app_trigger_irq_msk_reset_xc_trigger_out_edge_Pos (0UL) /*!< trigger_irq_app trigger_irq_msk_reset: xc_trigger_out_edge (Bit 0) */
#define trigger_irq_app_trigger_irq_msk_reset_xc_trigger_out_edge_Msk (0x3UL) /*!< trigger_irq_app trigger_irq_msk_reset: xc_trigger_out_edge (Bitfield-Mask: 0x03) */


/* =========================================================================================================================== */
/* ================                                        endat0_app                                         ================ */
/* =========================================================================================================================== */

/* ======================================================  endat_send  ======================================================= */
#define endat0_app_endat_send_byte4_Pos   (24UL)                    /*!< endat0_app endat_send: byte4 (Bit 24)                 */
#define endat0_app_endat_send_byte4_Msk   (0x3f000000UL)            /*!< endat0_app endat_send: byte4 (Bitfield-Mask: 0x3f)    */
#define endat0_app_endat_send_byte3_Pos   (16UL)                    /*!< endat0_app endat_send: byte3 (Bit 16)                 */
#define endat0_app_endat_send_byte3_Msk   (0xff0000UL)              /*!< endat0_app endat_send: byte3 (Bitfield-Mask: 0xff)    */
#define endat0_app_endat_send_byte2_Pos   (8UL)                     /*!< endat0_app endat_send: byte2 (Bit 8)                  */
#define endat0_app_endat_send_byte2_Msk   (0xff00UL)                /*!< endat0_app endat_send: byte2 (Bitfield-Mask: 0xff)    */
#define endat0_app_endat_send_byte1_Pos   (0UL)                     /*!< endat0_app endat_send: byte1 (Bit 0)                  */
#define endat0_app_endat_send_byte1_Msk   (0xffUL)                  /*!< endat0_app endat_send: byte1 (Bitfield-Mask: 0xff)    */
/* ===================================================  endat_receive1_0  ==================================================== */
#define endat0_app_endat_receive1_0_byte4_Pos (24UL)                /*!< endat0_app endat_receive1_0: byte4 (Bit 24)           */
#define endat0_app_endat_receive1_0_byte4_Msk (0xff000000UL)        /*!< endat0_app endat_receive1_0: byte4 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive1_0_byte3_Pos (16UL)                /*!< endat0_app endat_receive1_0: byte3 (Bit 16)           */
#define endat0_app_endat_receive1_0_byte3_Msk (0xff0000UL)          /*!< endat0_app endat_receive1_0: byte3 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive1_0_byte2_Pos (8UL)                 /*!< endat0_app endat_receive1_0: byte2 (Bit 8)            */
#define endat0_app_endat_receive1_0_byte2_Msk (0xff00UL)            /*!< endat0_app endat_receive1_0: byte2 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive1_0_byte1_Pos (0UL)                 /*!< endat0_app endat_receive1_0: byte1 (Bit 0)            */
#define endat0_app_endat_receive1_0_byte1_Msk (0xffUL)              /*!< endat0_app endat_receive1_0: byte1 (Bitfield-Mask: 0xff) */
/* ===================================================  endat_receive1_1  ==================================================== */
#define endat0_app_endat_receive1_1_byte7_Pos (16UL)                /*!< endat0_app endat_receive1_1: byte7 (Bit 16)           */
#define endat0_app_endat_receive1_1_byte7_Msk (0xff0000UL)          /*!< endat0_app endat_receive1_1: byte7 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive1_1_byte6_Pos (8UL)                 /*!< endat0_app endat_receive1_1: byte6 (Bit 8)            */
#define endat0_app_endat_receive1_1_byte6_Msk (0xff00UL)            /*!< endat0_app endat_receive1_1: byte6 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive1_1_byte5_Pos (0UL)                 /*!< endat0_app endat_receive1_1: byte5 (Bit 0)            */
#define endat0_app_endat_receive1_1_byte5_Msk (0xffUL)              /*!< endat0_app endat_receive1_1: byte5 (Bitfield-Mask: 0xff) */
/* ====================================================  endat_receive2  ===================================================== */
#define endat0_app_endat_receive2_byte4_Pos (24UL)                  /*!< endat0_app endat_receive2: byte4 (Bit 24)             */
#define endat0_app_endat_receive2_byte4_Msk (0xff000000UL)          /*!< endat0_app endat_receive2: byte4 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive2_byte3_Pos (16UL)                  /*!< endat0_app endat_receive2: byte3 (Bit 16)             */
#define endat0_app_endat_receive2_byte3_Msk (0xff0000UL)            /*!< endat0_app endat_receive2: byte3 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive2_byte2_Pos (8UL)                   /*!< endat0_app endat_receive2: byte2 (Bit 8)              */
#define endat0_app_endat_receive2_byte2_Msk (0xff00UL)              /*!< endat0_app endat_receive2: byte2 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive2_byte1_Pos (0UL)                   /*!< endat0_app endat_receive2: byte1 (Bit 0)              */
#define endat0_app_endat_receive2_byte1_Msk (0xffUL)                /*!< endat0_app endat_receive2: byte1 (Bitfield-Mask: 0xff) */
/* ====================================================  endat_receive3  ===================================================== */
#define endat0_app_endat_receive3_byte4_Pos (24UL)                  /*!< endat0_app endat_receive3: byte4 (Bit 24)             */
#define endat0_app_endat_receive3_byte4_Msk (0xff000000UL)          /*!< endat0_app endat_receive3: byte4 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive3_byte3_Pos (16UL)                  /*!< endat0_app endat_receive3: byte3 (Bit 16)             */
#define endat0_app_endat_receive3_byte3_Msk (0xff0000UL)            /*!< endat0_app endat_receive3: byte3 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive3_byte2_Pos (8UL)                   /*!< endat0_app endat_receive3: byte2 (Bit 8)              */
#define endat0_app_endat_receive3_byte2_Msk (0xff00UL)              /*!< endat0_app endat_receive3: byte2 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive3_byte1_Pos (0UL)                   /*!< endat0_app endat_receive3: byte1 (Bit 0)              */
#define endat0_app_endat_receive3_byte1_Msk (0xffUL)                /*!< endat0_app endat_receive3: byte1 (Bitfield-Mask: 0xff) */
/* ======================================================  endat_conf1  ====================================================== */
#define endat0_app_endat_conf1_endat_ssi_Pos (30UL)                 /*!< endat0_app endat_conf1: endat_ssi (Bit 30)            */
#define endat0_app_endat_conf1_endat_ssi_Msk (0xc0000000UL)         /*!< endat0_app endat_conf1: endat_ssi (Bitfield-Mask: 0x03) */
#define endat0_app_endat_conf1_ic_reset_Pos (29UL)                  /*!< endat0_app endat_conf1: ic_reset (Bit 29)             */
#define endat0_app_endat_conf1_ic_reset_Msk (0x20000000UL)          /*!< endat0_app endat_conf1: ic_reset (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_f_sys_Pos  (26UL)                    /*!< endat0_app endat_conf1: f_sys (Bit 26)                */
#define endat0_app_endat_conf1_f_sys_Msk  (0x1c000000UL)            /*!< endat0_app endat_conf1: f_sys (Bitfield-Mask: 0x07)   */
#define endat0_app_endat_conf1_reserved1_Pos (25UL)                 /*!< endat0_app endat_conf1: reserved1 (Bit 25)            */
#define endat0_app_endat_conf1_reserved1_Msk (0x2000000UL)          /*!< endat0_app endat_conf1: reserved1 (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_delay_comp_Pos (24UL)                /*!< endat0_app endat_conf1: delay_comp (Bit 24)           */
#define endat0_app_endat_conf1_delay_comp_Msk (0x1000000UL)         /*!< endat0_app endat_conf1: delay_comp (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_cable_prop_time_Pos (16UL)           /*!< endat0_app endat_conf1: cable_prop_time (Bit 16)      */
#define endat0_app_endat_conf1_cable_prop_time_Msk (0xff0000UL)     /*!< endat0_app endat_conf1: cable_prop_time (Bitfield-Mask: 0xff) */
#define endat0_app_endat_conf1_auto_reset_Pos (15UL)                /*!< endat0_app endat_conf1: auto_reset (Bit 15)           */
#define endat0_app_endat_conf1_auto_reset_Msk (0x8000UL)            /*!< endat0_app endat_conf1: auto_reset (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_reset_window_Pos (14UL)              /*!< endat0_app endat_conf1: reset_window (Bit 14)         */
#define endat0_app_endat_conf1_reset_window_Msk (0x4000UL)          /*!< endat0_app endat_conf1: reset_window (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_data_word_len_Pos (8UL)              /*!< endat0_app endat_conf1: data_word_len (Bit 8)         */
#define endat0_app_endat_conf1_data_word_len_Msk (0x3f00UL)         /*!< endat0_app endat_conf1: data_word_len (Bitfield-Mask: 0x3f) */
#define endat0_app_endat_conf1_f_tclk_Pos (4UL)                     /*!< endat0_app endat_conf1: f_tclk (Bit 4)                */
#define endat0_app_endat_conf1_f_tclk_Msk (0xf0UL)                  /*!< endat0_app endat_conf1: f_tclk (Bitfield-Mask: 0x0f)  */
#define endat0_app_endat_conf1_reserved0_Pos (3UL)                  /*!< endat0_app endat_conf1: reserved0 (Bit 3)             */
#define endat0_app_endat_conf1_reserved0_Msk (0x8UL)                /*!< endat0_app endat_conf1: reserved0 (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_endat_cont_clk_mode_Pos (2UL)        /*!< endat0_app endat_conf1: endat_cont_clk_mode (Bit 2)   */
#define endat0_app_endat_conf1_endat_cont_clk_mode_Msk (0x4UL)      /*!< endat0_app endat_conf1: endat_cont_clk_mode (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_uncond_transfer_Pos (1UL)            /*!< endat0_app endat_conf1: uncond_transfer (Bit 1)       */
#define endat0_app_endat_conf1_uncond_transfer_Msk (0x2UL)          /*!< endat0_app endat_conf1: uncond_transfer (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf1_hw_strobe_Pos (0UL)                  /*!< endat0_app endat_conf1: hw_strobe (Bit 0)             */
#define endat0_app_endat_conf1_hw_strobe_Msk (0x1UL)                /*!< endat0_app endat_conf1: hw_strobe (Bitfield-Mask: 0x01) */
/* ======================================================  endat_conf2  ====================================================== */
#define endat0_app_endat_conf2_hw_strobe_delay_Pos (24UL)           /*!< endat0_app endat_conf2: hw_strobe_delay (Bit 24)      */
#define endat0_app_endat_conf2_hw_strobe_delay_Msk (0xff000000UL)   /*!< endat0_app endat_conf2: hw_strobe_delay (Bitfield-Mask: 0xff) */
#define endat0_app_endat_conf2_reserved0_Pos (23UL)                 /*!< endat0_app endat_conf2: reserved0 (Bit 23)            */
#define endat0_app_endat_conf2_reserved0_Msk (0x800000UL)           /*!< endat0_app endat_conf2: reserved0 (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf2_rtm_Pos    (22UL)                    /*!< endat0_app endat_conf2: rtm (Bit 22)                  */
#define endat0_app_endat_conf2_rtm_Msk    (0x400000UL)              /*!< endat0_app endat_conf2: rtm (Bitfield-Mask: 0x01)     */
#define endat0_app_endat_conf2_filter_Pos (19UL)                    /*!< endat0_app endat_conf2: filter (Bit 19)               */
#define endat0_app_endat_conf2_filter_Msk (0x380000UL)              /*!< endat0_app endat_conf2: filter (Bitfield-Mask: 0x07)  */
#define endat0_app_endat_conf2_t_st_Pos   (16UL)                    /*!< endat0_app endat_conf2: t_st (Bit 16)                 */
#define endat0_app_endat_conf2_t_st_Msk   (0x70000UL)               /*!< endat0_app endat_conf2: t_st (Bitfield-Mask: 0x07)    */
#define endat0_app_endat_conf2_watchdog_Pos (8UL)                   /*!< endat0_app endat_conf2: watchdog (Bit 8)              */
#define endat0_app_endat_conf2_watchdog_Msk (0xff00UL)              /*!< endat0_app endat_conf2: watchdog (Bitfield-Mask: 0xff) */
#define endat0_app_endat_conf2_timer_for_sampling_rate_Pos (0UL)    /*!< endat0_app endat_conf2: timer_for_sampling_rate (Bit 0) */
#define endat0_app_endat_conf2_timer_for_sampling_rate_Msk (0xffUL) /*!< endat0_app endat_conf2: timer_for_sampling_rate (Bitfield-Mask: 0xff) */
/* ======================================================  endat_conf3  ====================================================== */
#define endat0_app_endat_conf3_reserved1_Pos (16UL)                 /*!< endat0_app endat_conf3: reserved1 (Bit 16)            */
#define endat0_app_endat_conf3_reserved1_Msk (0xffff0000UL)         /*!< endat0_app endat_conf3: reserved1 (Bitfield-Mask: 0xffff) */
#define endat0_app_endat_conf3_speed_Pos  (15UL)                    /*!< endat0_app endat_conf3: speed (Bit 15)                */
#define endat0_app_endat_conf3_speed_Msk  (0x8000UL)                /*!< endat0_app endat_conf3: speed (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_conf3_reserved0_Pos (9UL)                  /*!< endat0_app endat_conf3: reserved0 (Bit 9)             */
#define endat0_app_endat_conf3_reserved0_Msk (0x7e00UL)             /*!< endat0_app endat_conf3: reserved0 (Bitfield-Mask: 0x3f) */
#define endat0_app_endat_conf3_dw_Pos     (8UL)                     /*!< endat0_app endat_conf3: dw (Bit 8)                    */
#define endat0_app_endat_conf3_dw_Msk     (0x100UL)                 /*!< endat0_app endat_conf3: dw (Bitfield-Mask: 0x01)      */
#define endat0_app_endat_conf3_singleturn_res_Pos (3UL)             /*!< endat0_app endat_conf3: singleturn_res (Bit 3)        */
#define endat0_app_endat_conf3_singleturn_res_Msk (0xf8UL)          /*!< endat0_app endat_conf3: singleturn_res (Bitfield-Mask: 0x1f) */
#define endat0_app_endat_conf3_gray_to_binary_Pos (2UL)             /*!< endat0_app endat_conf3: gray_to_binary (Bit 2)        */
#define endat0_app_endat_conf3_gray_to_binary_Msk (0x4UL)           /*!< endat0_app endat_conf3: gray_to_binary (Bitfield-Mask: 0x01) */
#define endat0_app_endat_conf3_format_Pos (1UL)                     /*!< endat0_app endat_conf3: format (Bit 1)                */
#define endat0_app_endat_conf3_format_Msk (0x2UL)                   /*!< endat0_app endat_conf3: format (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_conf3_parity_Pos (0UL)                     /*!< endat0_app endat_conf3: parity (Bit 0)                */
#define endat0_app_endat_conf3_parity_Msk (0x1UL)                   /*!< endat0_app endat_conf3: parity (Bitfield-Mask: 0x01)  */
/* ======================================================  endat_stat  ======================================================= */
#define endat0_app_endat_stat_ready_Pos   (31UL)                    /*!< endat0_app endat_stat: ready (Bit 31)                 */
#define endat0_app_endat_stat_ready_Msk   (0x80000000UL)            /*!< endat0_app endat_stat: ready (Bitfield-Mask: 0x01)    */
#define endat0_app_endat_stat_ready_for_strobe_Pos (30UL)           /*!< endat0_app endat_stat: ready_for_strobe (Bit 30)      */
#define endat0_app_endat_stat_ready_for_strobe_Msk (0x40000000UL)   /*!< endat0_app endat_stat: ready_for_strobe (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_speed_ready_Pos (29UL)                /*!< endat0_app endat_stat: speed_ready (Bit 29)           */
#define endat0_app_endat_stat_speed_ready_Msk (0x20000000UL)        /*!< endat0_app endat_stat: speed_ready (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_rtm_stop_Pos (28UL)                   /*!< endat0_app endat_stat: rtm_stop (Bit 28)              */
#define endat0_app_endat_stat_rtm_stop_Msk (0x10000000UL)           /*!< endat0_app endat_stat: rtm_stop (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_rtm_start_Pos (27UL)                  /*!< endat0_app endat_stat: rtm_start (Bit 27)             */
#define endat0_app_endat_stat_rtm_start_Msk (0x8000000UL)           /*!< endat0_app endat_stat: rtm_start (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_reserved1_Pos (24UL)                  /*!< endat0_app endat_stat: reserved1 (Bit 24)             */
#define endat0_app_endat_stat_reserved1_Msk (0x7000000UL)           /*!< endat0_app endat_stat: reserved1 (Bitfield-Mask: 0x07) */
#define endat0_app_endat_stat_prop_time_measurement_Pos (23UL)      /*!< endat0_app endat_stat: prop_time_measurement (Bit 23) */
#define endat0_app_endat_stat_prop_time_measurement_Msk (0x800000UL) /*!< endat0_app endat_stat: prop_time_measurement (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_delay_comp_Pos (22UL)                 /*!< endat0_app endat_stat: delay_comp (Bit 22)            */
#define endat0_app_endat_stat_delay_comp_Msk (0x400000UL)           /*!< endat0_app endat_stat: delay_comp (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_reserved0_Pos (19UL)                  /*!< endat0_app endat_stat: reserved0 (Bit 19)             */
#define endat0_app_endat_stat_reserved0_Msk (0x380000UL)            /*!< endat0_app endat_stat: reserved0 (Bitfield-Mask: 0x07) */
#define endat0_app_endat_stat_f_type3_Pos (18UL)                    /*!< endat0_app endat_stat: f_type3 (Bit 18)               */
#define endat0_app_endat_stat_f_type3_Msk (0x40000UL)               /*!< endat0_app endat_stat: f_type3 (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_stat_watchdog_Pos (17UL)                   /*!< endat0_app endat_stat: watchdog (Bit 17)              */
#define endat0_app_endat_stat_watchdog_Msk (0x20000UL)              /*!< endat0_app endat_stat: watchdog (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_spike_Pos   (16UL)                    /*!< endat0_app endat_stat: spike (Bit 16)                 */
#define endat0_app_endat_stat_spike_Msk   (0x10000UL)               /*!< endat0_app endat_stat: spike (Bitfield-Mask: 0x01)    */
#define endat0_app_endat_stat_wrn_Pos     (15UL)                    /*!< endat0_app endat_stat: wrn (Bit 15)                   */
#define endat0_app_endat_stat_wrn_Msk     (0x8000UL)                /*!< endat0_app endat_stat: wrn (Bitfield-Mask: 0x01)      */
#define endat0_app_endat_stat_rm_Pos      (14UL)                    /*!< endat0_app endat_stat: rm (Bit 14)                    */
#define endat0_app_endat_stat_rm_Msk      (0x4000UL)                /*!< endat0_app endat_stat: rm (Bitfield-Mask: 0x01)       */
#define endat0_app_endat_stat_busy_Pos    (13UL)                    /*!< endat0_app endat_stat: busy (Bit 13)                  */
#define endat0_app_endat_stat_busy_Msk    (0x2000UL)                /*!< endat0_app endat_stat: busy (Bitfield-Mask: 0x01)     */
#define endat0_app_endat_stat_crc_zi2_Pos (12UL)                    /*!< endat0_app endat_stat: crc_zi2 (Bit 12)               */
#define endat0_app_endat_stat_crc_zi2_Msk (0x1000UL)                /*!< endat0_app endat_stat: crc_zi2 (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_stat_crc_zi1_Pos (11UL)                    /*!< endat0_app endat_stat: crc_zi1 (Bit 11)               */
#define endat0_app_endat_stat_crc_zi1_Msk (0x800UL)                 /*!< endat0_app endat_stat: crc_zi1 (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_stat_error2_Pos  (10UL)                    /*!< endat0_app endat_stat: error2 (Bit 10)                */
#define endat0_app_endat_stat_error2_Msk  (0x400UL)                 /*!< endat0_app endat_stat: error2 (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_stat_receive3_reg_Pos (9UL)                /*!< endat0_app endat_stat: receive3_reg (Bit 9)           */
#define endat0_app_endat_stat_receive3_reg_Msk (0x200UL)            /*!< endat0_app endat_stat: receive3_reg (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_receive2_reg_Pos (8UL)                /*!< endat0_app endat_stat: receive2_reg (Bit 8)           */
#define endat0_app_endat_stat_receive2_reg_Msk (0x100UL)            /*!< endat0_app endat_stat: receive2_reg (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_ir7_Pos     (7UL)                     /*!< endat0_app endat_stat: ir7 (Bit 7)                    */
#define endat0_app_endat_stat_ir7_Msk     (0x80UL)                  /*!< endat0_app endat_stat: ir7 (Bitfield-Mask: 0x01)      */
#define endat0_app_endat_stat_ir6_Pos     (6UL)                     /*!< endat0_app endat_stat: ir6 (Bit 6)                    */
#define endat0_app_endat_stat_ir6_Msk     (0x40UL)                  /*!< endat0_app endat_stat: ir6 (Bitfield-Mask: 0x01)      */
#define endat0_app_endat_stat_mrs_adr_Pos (5UL)                     /*!< endat0_app endat_stat: mrs_adr (Bit 5)                */
#define endat0_app_endat_stat_mrs_adr_Msk (0x20UL)                  /*!< endat0_app endat_stat: mrs_adr (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_stat_f_type2_Pos (4UL)                     /*!< endat0_app endat_stat: f_type2 (Bit 4)                */
#define endat0_app_endat_stat_f_type2_Msk (0x10UL)                  /*!< endat0_app endat_stat: f_type2 (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_stat_f_type1_Pos (3UL)                     /*!< endat0_app endat_stat: f_type1 (Bit 3)                */
#define endat0_app_endat_stat_f_type1_Msk (0x8UL)                   /*!< endat0_app endat_stat: f_type1 (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_stat_crcpw_parity_Pos (2UL)                /*!< endat0_app endat_stat: crcpw_parity (Bit 2)           */
#define endat0_app_endat_stat_crcpw_parity_Msk (0x4UL)              /*!< endat0_app endat_stat: crcpw_parity (Bitfield-Mask: 0x01) */
#define endat0_app_endat_stat_error1_Pos  (1UL)                     /*!< endat0_app endat_stat: error1 (Bit 1)                 */
#define endat0_app_endat_stat_error1_Msk  (0x2UL)                   /*!< endat0_app endat_stat: error1 (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_stat_receive1_reg_Pos (0UL)                /*!< endat0_app endat_stat: receive1_reg (Bit 0)           */
#define endat0_app_endat_stat_receive1_reg_Msk (0x1UL)              /*!< endat0_app endat_stat: receive1_reg (Bitfield-Mask: 0x01) */
/* =======================================================  endat_int  ======================================================= */
#define endat0_app_endat_int_ready_Pos    (31UL)                    /*!< endat0_app endat_int: ready (Bit 31)                  */
#define endat0_app_endat_int_ready_Msk    (0x80000000UL)            /*!< endat0_app endat_int: ready (Bitfield-Mask: 0x01)     */
#define endat0_app_endat_int_reserved1_Pos (30UL)                   /*!< endat0_app endat_int: reserved1 (Bit 30)              */
#define endat0_app_endat_int_reserved1_Msk (0x40000000UL)           /*!< endat0_app endat_int: reserved1 (Bitfield-Mask: 0x01) */
#define endat0_app_endat_int_speed_ready_Pos (29UL)                 /*!< endat0_app endat_int: speed_ready (Bit 29)            */
#define endat0_app_endat_int_speed_ready_Msk (0x20000000UL)         /*!< endat0_app endat_int: speed_ready (Bitfield-Mask: 0x01) */
#define endat0_app_endat_int_reserved0_Pos (19UL)                   /*!< endat0_app endat_int: reserved0 (Bit 19)              */
#define endat0_app_endat_int_reserved0_Msk (0x1ff80000UL)           /*!< endat0_app endat_int: reserved0 (Bitfield-Mask: 0x3ff) */
#define endat0_app_endat_int_f_type3_Pos  (18UL)                    /*!< endat0_app endat_int: f_type3 (Bit 18)                */
#define endat0_app_endat_int_f_type3_Msk  (0x40000UL)               /*!< endat0_app endat_int: f_type3 (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_int_watchdog_Pos (17UL)                    /*!< endat0_app endat_int: watchdog (Bit 17)               */
#define endat0_app_endat_int_watchdog_Msk (0x20000UL)               /*!< endat0_app endat_int: watchdog (Bitfield-Mask: 0x01)  */
#define endat0_app_endat_int_spike_Pos    (16UL)                    /*!< endat0_app endat_int: spike (Bit 16)                  */
#define endat0_app_endat_int_spike_Msk    (0x10000UL)               /*!< endat0_app endat_int: spike (Bitfield-Mask: 0x01)     */
#define endat0_app_endat_int_wrn_Pos      (15UL)                    /*!< endat0_app endat_int: wrn (Bit 15)                    */
#define endat0_app_endat_int_wrn_Msk      (0x8000UL)                /*!< endat0_app endat_int: wrn (Bitfield-Mask: 0x01)       */
#define endat0_app_endat_int_RM_Pos       (14UL)                    /*!< endat0_app endat_int: RM (Bit 14)                     */
#define endat0_app_endat_int_RM_Msk       (0x4000UL)                /*!< endat0_app endat_int: RM (Bitfield-Mask: 0x01)        */
#define endat0_app_endat_int_busy_Pos     (13UL)                    /*!< endat0_app endat_int: busy (Bit 13)                   */
#define endat0_app_endat_int_busy_Msk     (0x2000UL)                /*!< endat0_app endat_int: busy (Bitfield-Mask: 0x01)      */
#define endat0_app_endat_int_crc_zi2_Pos  (12UL)                    /*!< endat0_app endat_int: crc_zi2 (Bit 12)                */
#define endat0_app_endat_int_crc_zi2_Msk  (0x1000UL)                /*!< endat0_app endat_int: crc_zi2 (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_int_crc_zi1_Pos  (11UL)                    /*!< endat0_app endat_int: crc_zi1 (Bit 11)                */
#define endat0_app_endat_int_crc_zi1_Msk  (0x800UL)                 /*!< endat0_app endat_int: crc_zi1 (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_int_error2_Pos   (10UL)                    /*!< endat0_app endat_int: error2 (Bit 10)                 */
#define endat0_app_endat_int_error2_Msk   (0x400UL)                 /*!< endat0_app endat_int: error2 (Bitfield-Mask: 0x01)    */
#define endat0_app_endat_int_receive3_reg_Pos (9UL)                 /*!< endat0_app endat_int: receive3_reg (Bit 9)            */
#define endat0_app_endat_int_receive3_reg_Msk (0x200UL)             /*!< endat0_app endat_int: receive3_reg (Bitfield-Mask: 0x01) */
#define endat0_app_endat_int_receive2_reg_Pos (8UL)                 /*!< endat0_app endat_int: receive2_reg (Bit 8)            */
#define endat0_app_endat_int_receive2_reg_Msk (0x100UL)             /*!< endat0_app endat_int: receive2_reg (Bitfield-Mask: 0x01) */
#define endat0_app_endat_int_ir7_Pos      (7UL)                     /*!< endat0_app endat_int: ir7 (Bit 7)                     */
#define endat0_app_endat_int_ir7_Msk      (0x80UL)                  /*!< endat0_app endat_int: ir7 (Bitfield-Mask: 0x01)       */
#define endat0_app_endat_int_ir6_Pos      (6UL)                     /*!< endat0_app endat_int: ir6 (Bit 6)                     */
#define endat0_app_endat_int_ir6_Msk      (0x40UL)                  /*!< endat0_app endat_int: ir6 (Bitfield-Mask: 0x01)       */
#define endat0_app_endat_int_mrs_adr_Pos  (5UL)                     /*!< endat0_app endat_int: mrs_adr (Bit 5)                 */
#define endat0_app_endat_int_mrs_adr_Msk  (0x20UL)                  /*!< endat0_app endat_int: mrs_adr (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_int_f_type2_Pos  (4UL)                     /*!< endat0_app endat_int: f_type2 (Bit 4)                 */
#define endat0_app_endat_int_f_type2_Msk  (0x10UL)                  /*!< endat0_app endat_int: f_type2 (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_int_f_type1_Pos  (3UL)                     /*!< endat0_app endat_int: f_type1 (Bit 3)                 */
#define endat0_app_endat_int_f_type1_Msk  (0x8UL)                   /*!< endat0_app endat_int: f_type1 (Bitfield-Mask: 0x01)   */
#define endat0_app_endat_int_crcpw_parity_Pos (2UL)                 /*!< endat0_app endat_int: crcpw_parity (Bit 2)            */
#define endat0_app_endat_int_crcpw_parity_Msk (0x4UL)               /*!< endat0_app endat_int: crcpw_parity (Bitfield-Mask: 0x01) */
#define endat0_app_endat_int_error1_Pos   (1UL)                     /*!< endat0_app endat_int: error1 (Bit 1)                  */
#define endat0_app_endat_int_error1_Msk   (0x2UL)                   /*!< endat0_app endat_int: error1 (Bitfield-Mask: 0x01)    */
#define endat0_app_endat_int_receive1_reg_Pos (0UL)                 /*!< endat0_app endat_int: receive1_reg (Bit 0)            */
#define endat0_app_endat_int_receive1_reg_Msk (0x1UL)               /*!< endat0_app endat_int: receive1_reg (Bitfield-Mask: 0x01) */
/* ======================================================  endat_test1  ====================================================== */
#define endat0_app_endat_test1_ic_test_values_Pos (10UL)            /*!< endat0_app endat_test1: ic_test_values (Bit 10)       */
#define endat0_app_endat_test1_ic_test_values_Msk (0xfffffc00UL)    /*!< endat0_app endat_test1: ic_test_values (Bitfield-Mask: 0x3fffff) */
#define endat0_app_endat_test1_enDat_automation_engine_Pos (4UL)    /*!< endat0_app endat_test1: enDat_automation_engine (Bit 4) */
#define endat0_app_endat_test1_enDat_automation_engine_Msk (0x3f0UL) /*!< endat0_app endat_test1: enDat_automation_engine (Bitfield-Mask: 0x3f) */
#define endat0_app_endat_test1_reserved0_Pos (3UL)                  /*!< endat0_app endat_test1: reserved0 (Bit 3)             */
#define endat0_app_endat_test1_reserved0_Msk (0x8UL)                /*!< endat0_app endat_test1: reserved0 (Bitfield-Mask: 0x01) */
#define endat0_app_endat_test1_status_zi_Pos (1UL)                  /*!< endat0_app endat_test1: status_zi (Bit 1)             */
#define endat0_app_endat_test1_status_zi_Msk (0x6UL)                /*!< endat0_app endat_test1: status_zi (Bitfield-Mask: 0x03) */
#define endat0_app_endat_test1_dl_high_Pos (0UL)                    /*!< endat0_app endat_test1: dl_high (Bit 0)               */
#define endat0_app_endat_test1_dl_high_Msk (0x1UL)                  /*!< endat0_app endat_test1: dl_high (Bitfield-Mask: 0x01) */
/* ======================================================  endat_test2  ====================================================== */
#define endat0_app_endat_test2_ic_test_data_Pos (16UL)              /*!< endat0_app endat_test2: ic_test_data (Bit 16)         */
#define endat0_app_endat_test2_ic_test_data_Msk (0xffff0000UL)      /*!< endat0_app endat_test2: ic_test_data (Bitfield-Mask: 0xffff) */
#define endat0_app_endat_test2_sel_test_mux3_Pos (14UL)             /*!< endat0_app endat_test2: sel_test_mux3 (Bit 14)        */
#define endat0_app_endat_test2_sel_test_mux3_Msk (0xc000UL)         /*!< endat0_app endat_test2: sel_test_mux3 (Bitfield-Mask: 0x03) */
#define endat0_app_endat_test2_sel_test_mux2_Pos (12UL)             /*!< endat0_app endat_test2: sel_test_mux2 (Bit 12)        */
#define endat0_app_endat_test2_sel_test_mux2_Msk (0x3000UL)         /*!< endat0_app endat_test2: sel_test_mux2 (Bitfield-Mask: 0x03) */
#define endat0_app_endat_test2_test_mode_divider_Pos (11UL)         /*!< endat0_app endat_test2: test_mode_divider (Bit 11)    */
#define endat0_app_endat_test2_test_mode_divider_Msk (0x800UL)      /*!< endat0_app endat_test2: test_mode_divider (Bitfield-Mask: 0x01) */
#define endat0_app_endat_test2_selection_add_info_Pos (8UL)         /*!< endat0_app endat_test2: selection_add_info (Bit 8)    */
#define endat0_app_endat_test2_selection_add_info_Msk (0x700UL)     /*!< endat0_app endat_test2: selection_add_info (Bitfield-Mask: 0x07) */
#define endat0_app_endat_test2_ic_test_mode_Pos (7UL)               /*!< endat0_app endat_test2: ic_test_mode (Bit 7)          */
#define endat0_app_endat_test2_ic_test_mode_Msk (0x80UL)            /*!< endat0_app endat_test2: ic_test_mode (Bitfield-Mask: 0x01) */
#define endat0_app_endat_test2_reserved1_Pos (6UL)                  /*!< endat0_app endat_test2: reserved1 (Bit 6)             */
#define endat0_app_endat_test2_reserved1_Msk (0x40UL)               /*!< endat0_app endat_test2: reserved1 (Bitfield-Mask: 0x01) */
#define endat0_app_endat_test2_sel_test_mux_Pos (4UL)               /*!< endat0_app endat_test2: sel_test_mux (Bit 4)          */
#define endat0_app_endat_test2_sel_test_mux_Msk (0x30UL)            /*!< endat0_app endat_test2: sel_test_mux (Bitfield-Mask: 0x03) */
#define endat0_app_endat_test2_test_receive_reg_Pos (3UL)           /*!< endat0_app endat_test2: test_receive_reg (Bit 3)      */
#define endat0_app_endat_test2_test_receive_reg_Msk (0x8UL)         /*!< endat0_app endat_test2: test_receive_reg (Bitfield-Mask: 0x01) */
#define endat0_app_endat_test2_selection_tst_out_Pos (2UL)          /*!< endat0_app endat_test2: selection_tst_out (Bit 2)     */
#define endat0_app_endat_test2_selection_tst_out_Msk (0x4UL)        /*!< endat0_app endat_test2: selection_tst_out (Bitfield-Mask: 0x01) */
#define endat0_app_endat_test2_reserved0_Pos (0UL)                  /*!< endat0_app endat_test2: reserved0 (Bit 0)             */
#define endat0_app_endat_test2_reserved0_Msk (0x3UL)                /*!< endat0_app endat_test2: reserved0 (Bitfield-Mask: 0x03) */
/* ===================================================  endat_receive4_0  ==================================================== */
#define endat0_app_endat_receive4_0_byte4_Pos (24UL)                /*!< endat0_app endat_receive4_0: byte4 (Bit 24)           */
#define endat0_app_endat_receive4_0_byte4_Msk (0xff000000UL)        /*!< endat0_app endat_receive4_0: byte4 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive4_0_byte3_Pos (16UL)                /*!< endat0_app endat_receive4_0: byte3 (Bit 16)           */
#define endat0_app_endat_receive4_0_byte3_Msk (0xff0000UL)          /*!< endat0_app endat_receive4_0: byte3 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive4_0_byte2_Pos (8UL)                 /*!< endat0_app endat_receive4_0: byte2 (Bit 8)            */
#define endat0_app_endat_receive4_0_byte2_Msk (0xff00UL)            /*!< endat0_app endat_receive4_0: byte2 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive4_0_byte1_Pos (0UL)                 /*!< endat0_app endat_receive4_0: byte1 (Bit 0)            */
#define endat0_app_endat_receive4_0_byte1_Msk (0xffUL)              /*!< endat0_app endat_receive4_0: byte1 (Bitfield-Mask: 0xff) */
/* ===================================================  endat_receive4_1  ==================================================== */
#define endat0_app_endat_receive4_1_byte6_Pos (8UL)                 /*!< endat0_app endat_receive4_1: byte6 (Bit 8)            */
#define endat0_app_endat_receive4_1_byte6_Msk (0xff00UL)            /*!< endat0_app endat_receive4_1: byte6 (Bitfield-Mask: 0xff) */
#define endat0_app_endat_receive4_1_byte5_Pos (0UL)                 /*!< endat0_app endat_receive4_1: byte5 (Bit 0)            */
#define endat0_app_endat_receive4_1_byte5_Msk (0xffUL)              /*!< endat0_app endat_receive4_1: byte5 (Bitfield-Mask: 0xff) */
/* ====================================================  endat_sw_strobe  ==================================================== */
#define endat0_app_endat_sw_strobe_sw_strobe_Pos (0UL)              /*!< endat0_app endat_sw_strobe: sw_strobe (Bit 0)         */
#define endat0_app_endat_sw_strobe_sw_strobe_Msk (0xffffffffUL)     /*!< endat0_app endat_sw_strobe: sw_strobe (Bitfield-Mask: 0xffffffff) */
/* =======================================================  endat_id  ======================================================== */
#define endat0_app_endat_id_id_Pos        (0UL)                     /*!< endat0_app endat_id: id (Bit 0)                       */
#define endat0_app_endat_id_id_Msk        (0xffffffffUL)            /*!< endat0_app endat_id: id (Bitfield-Mask: 0xffffffff)   */


/* =========================================================================================================================== */
/* ================                                        endat1_app                                         ================ */
/* =========================================================================================================================== */

/* ======================================================  endat_send  ======================================================= */
#define endat1_app_endat_send_byte4_Pos   (24UL)                    /*!< endat1_app endat_send: byte4 (Bit 24)                 */
#define endat1_app_endat_send_byte4_Msk   (0x3f000000UL)            /*!< endat1_app endat_send: byte4 (Bitfield-Mask: 0x3f)    */
#define endat1_app_endat_send_byte3_Pos   (16UL)                    /*!< endat1_app endat_send: byte3 (Bit 16)                 */
#define endat1_app_endat_send_byte3_Msk   (0xff0000UL)              /*!< endat1_app endat_send: byte3 (Bitfield-Mask: 0xff)    */
#define endat1_app_endat_send_byte2_Pos   (8UL)                     /*!< endat1_app endat_send: byte2 (Bit 8)                  */
#define endat1_app_endat_send_byte2_Msk   (0xff00UL)                /*!< endat1_app endat_send: byte2 (Bitfield-Mask: 0xff)    */
#define endat1_app_endat_send_byte1_Pos   (0UL)                     /*!< endat1_app endat_send: byte1 (Bit 0)                  */
#define endat1_app_endat_send_byte1_Msk   (0xffUL)                  /*!< endat1_app endat_send: byte1 (Bitfield-Mask: 0xff)    */
/* ===================================================  endat_receive1_0  ==================================================== */
#define endat1_app_endat_receive1_0_byte4_Pos (24UL)                /*!< endat1_app endat_receive1_0: byte4 (Bit 24)           */
#define endat1_app_endat_receive1_0_byte4_Msk (0xff000000UL)        /*!< endat1_app endat_receive1_0: byte4 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive1_0_byte3_Pos (16UL)                /*!< endat1_app endat_receive1_0: byte3 (Bit 16)           */
#define endat1_app_endat_receive1_0_byte3_Msk (0xff0000UL)          /*!< endat1_app endat_receive1_0: byte3 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive1_0_byte2_Pos (8UL)                 /*!< endat1_app endat_receive1_0: byte2 (Bit 8)            */
#define endat1_app_endat_receive1_0_byte2_Msk (0xff00UL)            /*!< endat1_app endat_receive1_0: byte2 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive1_0_byte1_Pos (0UL)                 /*!< endat1_app endat_receive1_0: byte1 (Bit 0)            */
#define endat1_app_endat_receive1_0_byte1_Msk (0xffUL)              /*!< endat1_app endat_receive1_0: byte1 (Bitfield-Mask: 0xff) */
/* ===================================================  endat_receive1_1  ==================================================== */
#define endat1_app_endat_receive1_1_byte7_Pos (16UL)                /*!< endat1_app endat_receive1_1: byte7 (Bit 16)           */
#define endat1_app_endat_receive1_1_byte7_Msk (0xff0000UL)          /*!< endat1_app endat_receive1_1: byte7 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive1_1_byte6_Pos (8UL)                 /*!< endat1_app endat_receive1_1: byte6 (Bit 8)            */
#define endat1_app_endat_receive1_1_byte6_Msk (0xff00UL)            /*!< endat1_app endat_receive1_1: byte6 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive1_1_byte5_Pos (0UL)                 /*!< endat1_app endat_receive1_1: byte5 (Bit 0)            */
#define endat1_app_endat_receive1_1_byte5_Msk (0xffUL)              /*!< endat1_app endat_receive1_1: byte5 (Bitfield-Mask: 0xff) */
/* ====================================================  endat_receive2  ===================================================== */
#define endat1_app_endat_receive2_byte4_Pos (24UL)                  /*!< endat1_app endat_receive2: byte4 (Bit 24)             */
#define endat1_app_endat_receive2_byte4_Msk (0xff000000UL)          /*!< endat1_app endat_receive2: byte4 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive2_byte3_Pos (16UL)                  /*!< endat1_app endat_receive2: byte3 (Bit 16)             */
#define endat1_app_endat_receive2_byte3_Msk (0xff0000UL)            /*!< endat1_app endat_receive2: byte3 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive2_byte2_Pos (8UL)                   /*!< endat1_app endat_receive2: byte2 (Bit 8)              */
#define endat1_app_endat_receive2_byte2_Msk (0xff00UL)              /*!< endat1_app endat_receive2: byte2 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive2_byte1_Pos (0UL)                   /*!< endat1_app endat_receive2: byte1 (Bit 0)              */
#define endat1_app_endat_receive2_byte1_Msk (0xffUL)                /*!< endat1_app endat_receive2: byte1 (Bitfield-Mask: 0xff) */
/* ====================================================  endat_receive3  ===================================================== */
#define endat1_app_endat_receive3_byte4_Pos (24UL)                  /*!< endat1_app endat_receive3: byte4 (Bit 24)             */
#define endat1_app_endat_receive3_byte4_Msk (0xff000000UL)          /*!< endat1_app endat_receive3: byte4 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive3_byte3_Pos (16UL)                  /*!< endat1_app endat_receive3: byte3 (Bit 16)             */
#define endat1_app_endat_receive3_byte3_Msk (0xff0000UL)            /*!< endat1_app endat_receive3: byte3 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive3_byte2_Pos (8UL)                   /*!< endat1_app endat_receive3: byte2 (Bit 8)              */
#define endat1_app_endat_receive3_byte2_Msk (0xff00UL)              /*!< endat1_app endat_receive3: byte2 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive3_byte1_Pos (0UL)                   /*!< endat1_app endat_receive3: byte1 (Bit 0)              */
#define endat1_app_endat_receive3_byte1_Msk (0xffUL)                /*!< endat1_app endat_receive3: byte1 (Bitfield-Mask: 0xff) */
/* ======================================================  endat_conf1  ====================================================== */
#define endat1_app_endat_conf1_endat_ssi_Pos (30UL)                 /*!< endat1_app endat_conf1: endat_ssi (Bit 30)            */
#define endat1_app_endat_conf1_endat_ssi_Msk (0xc0000000UL)         /*!< endat1_app endat_conf1: endat_ssi (Bitfield-Mask: 0x03) */
#define endat1_app_endat_conf1_ic_reset_Pos (29UL)                  /*!< endat1_app endat_conf1: ic_reset (Bit 29)             */
#define endat1_app_endat_conf1_ic_reset_Msk (0x20000000UL)          /*!< endat1_app endat_conf1: ic_reset (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_f_sys_Pos  (26UL)                    /*!< endat1_app endat_conf1: f_sys (Bit 26)                */
#define endat1_app_endat_conf1_f_sys_Msk  (0x1c000000UL)            /*!< endat1_app endat_conf1: f_sys (Bitfield-Mask: 0x07)   */
#define endat1_app_endat_conf1_reserved1_Pos (25UL)                 /*!< endat1_app endat_conf1: reserved1 (Bit 25)            */
#define endat1_app_endat_conf1_reserved1_Msk (0x2000000UL)          /*!< endat1_app endat_conf1: reserved1 (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_delay_comp_Pos (24UL)                /*!< endat1_app endat_conf1: delay_comp (Bit 24)           */
#define endat1_app_endat_conf1_delay_comp_Msk (0x1000000UL)         /*!< endat1_app endat_conf1: delay_comp (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_cable_prop_time_Pos (16UL)           /*!< endat1_app endat_conf1: cable_prop_time (Bit 16)      */
#define endat1_app_endat_conf1_cable_prop_time_Msk (0xff0000UL)     /*!< endat1_app endat_conf1: cable_prop_time (Bitfield-Mask: 0xff) */
#define endat1_app_endat_conf1_auto_reset_Pos (15UL)                /*!< endat1_app endat_conf1: auto_reset (Bit 15)           */
#define endat1_app_endat_conf1_auto_reset_Msk (0x8000UL)            /*!< endat1_app endat_conf1: auto_reset (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_reset_window_Pos (14UL)              /*!< endat1_app endat_conf1: reset_window (Bit 14)         */
#define endat1_app_endat_conf1_reset_window_Msk (0x4000UL)          /*!< endat1_app endat_conf1: reset_window (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_data_word_len_Pos (8UL)              /*!< endat1_app endat_conf1: data_word_len (Bit 8)         */
#define endat1_app_endat_conf1_data_word_len_Msk (0x3f00UL)         /*!< endat1_app endat_conf1: data_word_len (Bitfield-Mask: 0x3f) */
#define endat1_app_endat_conf1_f_tclk_Pos (4UL)                     /*!< endat1_app endat_conf1: f_tclk (Bit 4)                */
#define endat1_app_endat_conf1_f_tclk_Msk (0xf0UL)                  /*!< endat1_app endat_conf1: f_tclk (Bitfield-Mask: 0x0f)  */
#define endat1_app_endat_conf1_reserved0_Pos (3UL)                  /*!< endat1_app endat_conf1: reserved0 (Bit 3)             */
#define endat1_app_endat_conf1_reserved0_Msk (0x8UL)                /*!< endat1_app endat_conf1: reserved0 (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_endat_cont_clk_mode_Pos (2UL)        /*!< endat1_app endat_conf1: endat_cont_clk_mode (Bit 2)   */
#define endat1_app_endat_conf1_endat_cont_clk_mode_Msk (0x4UL)      /*!< endat1_app endat_conf1: endat_cont_clk_mode (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_uncond_transfer_Pos (1UL)            /*!< endat1_app endat_conf1: uncond_transfer (Bit 1)       */
#define endat1_app_endat_conf1_uncond_transfer_Msk (0x2UL)          /*!< endat1_app endat_conf1: uncond_transfer (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf1_hw_strobe_Pos (0UL)                  /*!< endat1_app endat_conf1: hw_strobe (Bit 0)             */
#define endat1_app_endat_conf1_hw_strobe_Msk (0x1UL)                /*!< endat1_app endat_conf1: hw_strobe (Bitfield-Mask: 0x01) */
/* ======================================================  endat_conf2  ====================================================== */
#define endat1_app_endat_conf2_hw_strobe_delay_Pos (24UL)           /*!< endat1_app endat_conf2: hw_strobe_delay (Bit 24)      */
#define endat1_app_endat_conf2_hw_strobe_delay_Msk (0xff000000UL)   /*!< endat1_app endat_conf2: hw_strobe_delay (Bitfield-Mask: 0xff) */
#define endat1_app_endat_conf2_reserved0_Pos (23UL)                 /*!< endat1_app endat_conf2: reserved0 (Bit 23)            */
#define endat1_app_endat_conf2_reserved0_Msk (0x800000UL)           /*!< endat1_app endat_conf2: reserved0 (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf2_rtm_Pos    (22UL)                    /*!< endat1_app endat_conf2: rtm (Bit 22)                  */
#define endat1_app_endat_conf2_rtm_Msk    (0x400000UL)              /*!< endat1_app endat_conf2: rtm (Bitfield-Mask: 0x01)     */
#define endat1_app_endat_conf2_filter_Pos (19UL)                    /*!< endat1_app endat_conf2: filter (Bit 19)               */
#define endat1_app_endat_conf2_filter_Msk (0x380000UL)              /*!< endat1_app endat_conf2: filter (Bitfield-Mask: 0x07)  */
#define endat1_app_endat_conf2_t_st_Pos   (16UL)                    /*!< endat1_app endat_conf2: t_st (Bit 16)                 */
#define endat1_app_endat_conf2_t_st_Msk   (0x70000UL)               /*!< endat1_app endat_conf2: t_st (Bitfield-Mask: 0x07)    */
#define endat1_app_endat_conf2_watchdog_Pos (8UL)                   /*!< endat1_app endat_conf2: watchdog (Bit 8)              */
#define endat1_app_endat_conf2_watchdog_Msk (0xff00UL)              /*!< endat1_app endat_conf2: watchdog (Bitfield-Mask: 0xff) */
#define endat1_app_endat_conf2_timer_for_sampling_rate_Pos (0UL)    /*!< endat1_app endat_conf2: timer_for_sampling_rate (Bit 0) */
#define endat1_app_endat_conf2_timer_for_sampling_rate_Msk (0xffUL) /*!< endat1_app endat_conf2: timer_for_sampling_rate (Bitfield-Mask: 0xff) */
/* ======================================================  endat_conf3  ====================================================== */
#define endat1_app_endat_conf3_reserved1_Pos (16UL)                 /*!< endat1_app endat_conf3: reserved1 (Bit 16)            */
#define endat1_app_endat_conf3_reserved1_Msk (0xffff0000UL)         /*!< endat1_app endat_conf3: reserved1 (Bitfield-Mask: 0xffff) */
#define endat1_app_endat_conf3_speed_Pos  (15UL)                    /*!< endat1_app endat_conf3: speed (Bit 15)                */
#define endat1_app_endat_conf3_speed_Msk  (0x8000UL)                /*!< endat1_app endat_conf3: speed (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_conf3_reserved0_Pos (9UL)                  /*!< endat1_app endat_conf3: reserved0 (Bit 9)             */
#define endat1_app_endat_conf3_reserved0_Msk (0x7e00UL)             /*!< endat1_app endat_conf3: reserved0 (Bitfield-Mask: 0x3f) */
#define endat1_app_endat_conf3_dw_Pos     (8UL)                     /*!< endat1_app endat_conf3: dw (Bit 8)                    */
#define endat1_app_endat_conf3_dw_Msk     (0x100UL)                 /*!< endat1_app endat_conf3: dw (Bitfield-Mask: 0x01)      */
#define endat1_app_endat_conf3_singleturn_res_Pos (3UL)             /*!< endat1_app endat_conf3: singleturn_res (Bit 3)        */
#define endat1_app_endat_conf3_singleturn_res_Msk (0xf8UL)          /*!< endat1_app endat_conf3: singleturn_res (Bitfield-Mask: 0x1f) */
#define endat1_app_endat_conf3_gray_to_binary_Pos (2UL)             /*!< endat1_app endat_conf3: gray_to_binary (Bit 2)        */
#define endat1_app_endat_conf3_gray_to_binary_Msk (0x4UL)           /*!< endat1_app endat_conf3: gray_to_binary (Bitfield-Mask: 0x01) */
#define endat1_app_endat_conf3_format_Pos (1UL)                     /*!< endat1_app endat_conf3: format (Bit 1)                */
#define endat1_app_endat_conf3_format_Msk (0x2UL)                   /*!< endat1_app endat_conf3: format (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_conf3_parity_Pos (0UL)                     /*!< endat1_app endat_conf3: parity (Bit 0)                */
#define endat1_app_endat_conf3_parity_Msk (0x1UL)                   /*!< endat1_app endat_conf3: parity (Bitfield-Mask: 0x01)  */
/* ======================================================  endat_stat  ======================================================= */
#define endat1_app_endat_stat_ready_Pos   (31UL)                    /*!< endat1_app endat_stat: ready (Bit 31)                 */
#define endat1_app_endat_stat_ready_Msk   (0x80000000UL)            /*!< endat1_app endat_stat: ready (Bitfield-Mask: 0x01)    */
#define endat1_app_endat_stat_ready_for_strobe_Pos (30UL)           /*!< endat1_app endat_stat: ready_for_strobe (Bit 30)      */
#define endat1_app_endat_stat_ready_for_strobe_Msk (0x40000000UL)   /*!< endat1_app endat_stat: ready_for_strobe (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_speed_ready_Pos (29UL)                /*!< endat1_app endat_stat: speed_ready (Bit 29)           */
#define endat1_app_endat_stat_speed_ready_Msk (0x20000000UL)        /*!< endat1_app endat_stat: speed_ready (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_rtm_stop_Pos (28UL)                   /*!< endat1_app endat_stat: rtm_stop (Bit 28)              */
#define endat1_app_endat_stat_rtm_stop_Msk (0x10000000UL)           /*!< endat1_app endat_stat: rtm_stop (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_rtm_start_Pos (27UL)                  /*!< endat1_app endat_stat: rtm_start (Bit 27)             */
#define endat1_app_endat_stat_rtm_start_Msk (0x8000000UL)           /*!< endat1_app endat_stat: rtm_start (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_reserved1_Pos (24UL)                  /*!< endat1_app endat_stat: reserved1 (Bit 24)             */
#define endat1_app_endat_stat_reserved1_Msk (0x7000000UL)           /*!< endat1_app endat_stat: reserved1 (Bitfield-Mask: 0x07) */
#define endat1_app_endat_stat_prop_time_measurement_Pos (23UL)      /*!< endat1_app endat_stat: prop_time_measurement (Bit 23) */
#define endat1_app_endat_stat_prop_time_measurement_Msk (0x800000UL) /*!< endat1_app endat_stat: prop_time_measurement (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_delay_comp_Pos (22UL)                 /*!< endat1_app endat_stat: delay_comp (Bit 22)            */
#define endat1_app_endat_stat_delay_comp_Msk (0x400000UL)           /*!< endat1_app endat_stat: delay_comp (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_reserved0_Pos (19UL)                  /*!< endat1_app endat_stat: reserved0 (Bit 19)             */
#define endat1_app_endat_stat_reserved0_Msk (0x380000UL)            /*!< endat1_app endat_stat: reserved0 (Bitfield-Mask: 0x07) */
#define endat1_app_endat_stat_f_type3_Pos (18UL)                    /*!< endat1_app endat_stat: f_type3 (Bit 18)               */
#define endat1_app_endat_stat_f_type3_Msk (0x40000UL)               /*!< endat1_app endat_stat: f_type3 (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_stat_watchdog_Pos (17UL)                   /*!< endat1_app endat_stat: watchdog (Bit 17)              */
#define endat1_app_endat_stat_watchdog_Msk (0x20000UL)              /*!< endat1_app endat_stat: watchdog (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_spike_Pos   (16UL)                    /*!< endat1_app endat_stat: spike (Bit 16)                 */
#define endat1_app_endat_stat_spike_Msk   (0x10000UL)               /*!< endat1_app endat_stat: spike (Bitfield-Mask: 0x01)    */
#define endat1_app_endat_stat_wrn_Pos     (15UL)                    /*!< endat1_app endat_stat: wrn (Bit 15)                   */
#define endat1_app_endat_stat_wrn_Msk     (0x8000UL)                /*!< endat1_app endat_stat: wrn (Bitfield-Mask: 0x01)      */
#define endat1_app_endat_stat_rm_Pos      (14UL)                    /*!< endat1_app endat_stat: rm (Bit 14)                    */
#define endat1_app_endat_stat_rm_Msk      (0x4000UL)                /*!< endat1_app endat_stat: rm (Bitfield-Mask: 0x01)       */
#define endat1_app_endat_stat_busy_Pos    (13UL)                    /*!< endat1_app endat_stat: busy (Bit 13)                  */
#define endat1_app_endat_stat_busy_Msk    (0x2000UL)                /*!< endat1_app endat_stat: busy (Bitfield-Mask: 0x01)     */
#define endat1_app_endat_stat_crc_zi2_Pos (12UL)                    /*!< endat1_app endat_stat: crc_zi2 (Bit 12)               */
#define endat1_app_endat_stat_crc_zi2_Msk (0x1000UL)                /*!< endat1_app endat_stat: crc_zi2 (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_stat_crc_zi1_Pos (11UL)                    /*!< endat1_app endat_stat: crc_zi1 (Bit 11)               */
#define endat1_app_endat_stat_crc_zi1_Msk (0x800UL)                 /*!< endat1_app endat_stat: crc_zi1 (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_stat_error2_Pos  (10UL)                    /*!< endat1_app endat_stat: error2 (Bit 10)                */
#define endat1_app_endat_stat_error2_Msk  (0x400UL)                 /*!< endat1_app endat_stat: error2 (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_stat_receive3_reg_Pos (9UL)                /*!< endat1_app endat_stat: receive3_reg (Bit 9)           */
#define endat1_app_endat_stat_receive3_reg_Msk (0x200UL)            /*!< endat1_app endat_stat: receive3_reg (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_receive2_reg_Pos (8UL)                /*!< endat1_app endat_stat: receive2_reg (Bit 8)           */
#define endat1_app_endat_stat_receive2_reg_Msk (0x100UL)            /*!< endat1_app endat_stat: receive2_reg (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_ir7_Pos     (7UL)                     /*!< endat1_app endat_stat: ir7 (Bit 7)                    */
#define endat1_app_endat_stat_ir7_Msk     (0x80UL)                  /*!< endat1_app endat_stat: ir7 (Bitfield-Mask: 0x01)      */
#define endat1_app_endat_stat_ir6_Pos     (6UL)                     /*!< endat1_app endat_stat: ir6 (Bit 6)                    */
#define endat1_app_endat_stat_ir6_Msk     (0x40UL)                  /*!< endat1_app endat_stat: ir6 (Bitfield-Mask: 0x01)      */
#define endat1_app_endat_stat_mrs_adr_Pos (5UL)                     /*!< endat1_app endat_stat: mrs_adr (Bit 5)                */
#define endat1_app_endat_stat_mrs_adr_Msk (0x20UL)                  /*!< endat1_app endat_stat: mrs_adr (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_stat_f_type2_Pos (4UL)                     /*!< endat1_app endat_stat: f_type2 (Bit 4)                */
#define endat1_app_endat_stat_f_type2_Msk (0x10UL)                  /*!< endat1_app endat_stat: f_type2 (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_stat_f_type1_Pos (3UL)                     /*!< endat1_app endat_stat: f_type1 (Bit 3)                */
#define endat1_app_endat_stat_f_type1_Msk (0x8UL)                   /*!< endat1_app endat_stat: f_type1 (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_stat_crcpw_parity_Pos (2UL)                /*!< endat1_app endat_stat: crcpw_parity (Bit 2)           */
#define endat1_app_endat_stat_crcpw_parity_Msk (0x4UL)              /*!< endat1_app endat_stat: crcpw_parity (Bitfield-Mask: 0x01) */
#define endat1_app_endat_stat_error1_Pos  (1UL)                     /*!< endat1_app endat_stat: error1 (Bit 1)                 */
#define endat1_app_endat_stat_error1_Msk  (0x2UL)                   /*!< endat1_app endat_stat: error1 (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_stat_receive1_reg_Pos (0UL)                /*!< endat1_app endat_stat: receive1_reg (Bit 0)           */
#define endat1_app_endat_stat_receive1_reg_Msk (0x1UL)              /*!< endat1_app endat_stat: receive1_reg (Bitfield-Mask: 0x01) */
/* =======================================================  endat_int  ======================================================= */
#define endat1_app_endat_int_ready_Pos    (31UL)                    /*!< endat1_app endat_int: ready (Bit 31)                  */
#define endat1_app_endat_int_ready_Msk    (0x80000000UL)            /*!< endat1_app endat_int: ready (Bitfield-Mask: 0x01)     */
#define endat1_app_endat_int_reserved1_Pos (30UL)                   /*!< endat1_app endat_int: reserved1 (Bit 30)              */
#define endat1_app_endat_int_reserved1_Msk (0x40000000UL)           /*!< endat1_app endat_int: reserved1 (Bitfield-Mask: 0x01) */
#define endat1_app_endat_int_speed_ready_Pos (29UL)                 /*!< endat1_app endat_int: speed_ready (Bit 29)            */
#define endat1_app_endat_int_speed_ready_Msk (0x20000000UL)         /*!< endat1_app endat_int: speed_ready (Bitfield-Mask: 0x01) */
#define endat1_app_endat_int_reserved0_Pos (19UL)                   /*!< endat1_app endat_int: reserved0 (Bit 19)              */
#define endat1_app_endat_int_reserved0_Msk (0x1ff80000UL)           /*!< endat1_app endat_int: reserved0 (Bitfield-Mask: 0x3ff) */
#define endat1_app_endat_int_f_type3_Pos  (18UL)                    /*!< endat1_app endat_int: f_type3 (Bit 18)                */
#define endat1_app_endat_int_f_type3_Msk  (0x40000UL)               /*!< endat1_app endat_int: f_type3 (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_int_watchdog_Pos (17UL)                    /*!< endat1_app endat_int: watchdog (Bit 17)               */
#define endat1_app_endat_int_watchdog_Msk (0x20000UL)               /*!< endat1_app endat_int: watchdog (Bitfield-Mask: 0x01)  */
#define endat1_app_endat_int_spike_Pos    (16UL)                    /*!< endat1_app endat_int: spike (Bit 16)                  */
#define endat1_app_endat_int_spike_Msk    (0x10000UL)               /*!< endat1_app endat_int: spike (Bitfield-Mask: 0x01)     */
#define endat1_app_endat_int_wrn_Pos      (15UL)                    /*!< endat1_app endat_int: wrn (Bit 15)                    */
#define endat1_app_endat_int_wrn_Msk      (0x8000UL)                /*!< endat1_app endat_int: wrn (Bitfield-Mask: 0x01)       */
#define endat1_app_endat_int_RM_Pos       (14UL)                    /*!< endat1_app endat_int: RM (Bit 14)                     */
#define endat1_app_endat_int_RM_Msk       (0x4000UL)                /*!< endat1_app endat_int: RM (Bitfield-Mask: 0x01)        */
#define endat1_app_endat_int_busy_Pos     (13UL)                    /*!< endat1_app endat_int: busy (Bit 13)                   */
#define endat1_app_endat_int_busy_Msk     (0x2000UL)                /*!< endat1_app endat_int: busy (Bitfield-Mask: 0x01)      */
#define endat1_app_endat_int_crc_zi2_Pos  (12UL)                    /*!< endat1_app endat_int: crc_zi2 (Bit 12)                */
#define endat1_app_endat_int_crc_zi2_Msk  (0x1000UL)                /*!< endat1_app endat_int: crc_zi2 (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_int_crc_zi1_Pos  (11UL)                    /*!< endat1_app endat_int: crc_zi1 (Bit 11)                */
#define endat1_app_endat_int_crc_zi1_Msk  (0x800UL)                 /*!< endat1_app endat_int: crc_zi1 (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_int_error2_Pos   (10UL)                    /*!< endat1_app endat_int: error2 (Bit 10)                 */
#define endat1_app_endat_int_error2_Msk   (0x400UL)                 /*!< endat1_app endat_int: error2 (Bitfield-Mask: 0x01)    */
#define endat1_app_endat_int_receive3_reg_Pos (9UL)                 /*!< endat1_app endat_int: receive3_reg (Bit 9)            */
#define endat1_app_endat_int_receive3_reg_Msk (0x200UL)             /*!< endat1_app endat_int: receive3_reg (Bitfield-Mask: 0x01) */
#define endat1_app_endat_int_receive2_reg_Pos (8UL)                 /*!< endat1_app endat_int: receive2_reg (Bit 8)            */
#define endat1_app_endat_int_receive2_reg_Msk (0x100UL)             /*!< endat1_app endat_int: receive2_reg (Bitfield-Mask: 0x01) */
#define endat1_app_endat_int_ir7_Pos      (7UL)                     /*!< endat1_app endat_int: ir7 (Bit 7)                     */
#define endat1_app_endat_int_ir7_Msk      (0x80UL)                  /*!< endat1_app endat_int: ir7 (Bitfield-Mask: 0x01)       */
#define endat1_app_endat_int_ir6_Pos      (6UL)                     /*!< endat1_app endat_int: ir6 (Bit 6)                     */
#define endat1_app_endat_int_ir6_Msk      (0x40UL)                  /*!< endat1_app endat_int: ir6 (Bitfield-Mask: 0x01)       */
#define endat1_app_endat_int_mrs_adr_Pos  (5UL)                     /*!< endat1_app endat_int: mrs_adr (Bit 5)                 */
#define endat1_app_endat_int_mrs_adr_Msk  (0x20UL)                  /*!< endat1_app endat_int: mrs_adr (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_int_f_type2_Pos  (4UL)                     /*!< endat1_app endat_int: f_type2 (Bit 4)                 */
#define endat1_app_endat_int_f_type2_Msk  (0x10UL)                  /*!< endat1_app endat_int: f_type2 (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_int_f_type1_Pos  (3UL)                     /*!< endat1_app endat_int: f_type1 (Bit 3)                 */
#define endat1_app_endat_int_f_type1_Msk  (0x8UL)                   /*!< endat1_app endat_int: f_type1 (Bitfield-Mask: 0x01)   */
#define endat1_app_endat_int_crcpw_parity_Pos (2UL)                 /*!< endat1_app endat_int: crcpw_parity (Bit 2)            */
#define endat1_app_endat_int_crcpw_parity_Msk (0x4UL)               /*!< endat1_app endat_int: crcpw_parity (Bitfield-Mask: 0x01) */
#define endat1_app_endat_int_error1_Pos   (1UL)                     /*!< endat1_app endat_int: error1 (Bit 1)                  */
#define endat1_app_endat_int_error1_Msk   (0x2UL)                   /*!< endat1_app endat_int: error1 (Bitfield-Mask: 0x01)    */
#define endat1_app_endat_int_receive1_reg_Pos (0UL)                 /*!< endat1_app endat_int: receive1_reg (Bit 0)            */
#define endat1_app_endat_int_receive1_reg_Msk (0x1UL)               /*!< endat1_app endat_int: receive1_reg (Bitfield-Mask: 0x01) */
/* ======================================================  endat_test1  ====================================================== */
#define endat1_app_endat_test1_ic_test_values_Pos (10UL)            /*!< endat1_app endat_test1: ic_test_values (Bit 10)       */
#define endat1_app_endat_test1_ic_test_values_Msk (0xfffffc00UL)    /*!< endat1_app endat_test1: ic_test_values (Bitfield-Mask: 0x3fffff) */
#define endat1_app_endat_test1_enDat_automation_engine_Pos (4UL)    /*!< endat1_app endat_test1: enDat_automation_engine (Bit 4) */
#define endat1_app_endat_test1_enDat_automation_engine_Msk (0x3f0UL) /*!< endat1_app endat_test1: enDat_automation_engine (Bitfield-Mask: 0x3f) */
#define endat1_app_endat_test1_reserved0_Pos (3UL)                  /*!< endat1_app endat_test1: reserved0 (Bit 3)             */
#define endat1_app_endat_test1_reserved0_Msk (0x8UL)                /*!< endat1_app endat_test1: reserved0 (Bitfield-Mask: 0x01) */
#define endat1_app_endat_test1_status_zi_Pos (1UL)                  /*!< endat1_app endat_test1: status_zi (Bit 1)             */
#define endat1_app_endat_test1_status_zi_Msk (0x6UL)                /*!< endat1_app endat_test1: status_zi (Bitfield-Mask: 0x03) */
#define endat1_app_endat_test1_dl_high_Pos (0UL)                    /*!< endat1_app endat_test1: dl_high (Bit 0)               */
#define endat1_app_endat_test1_dl_high_Msk (0x1UL)                  /*!< endat1_app endat_test1: dl_high (Bitfield-Mask: 0x01) */
/* ======================================================  endat_test2  ====================================================== */
#define endat1_app_endat_test2_ic_test_data_Pos (16UL)              /*!< endat1_app endat_test2: ic_test_data (Bit 16)         */
#define endat1_app_endat_test2_ic_test_data_Msk (0xffff0000UL)      /*!< endat1_app endat_test2: ic_test_data (Bitfield-Mask: 0xffff) */
#define endat1_app_endat_test2_sel_test_mux3_Pos (14UL)             /*!< endat1_app endat_test2: sel_test_mux3 (Bit 14)        */
#define endat1_app_endat_test2_sel_test_mux3_Msk (0xc000UL)         /*!< endat1_app endat_test2: sel_test_mux3 (Bitfield-Mask: 0x03) */
#define endat1_app_endat_test2_sel_test_mux2_Pos (12UL)             /*!< endat1_app endat_test2: sel_test_mux2 (Bit 12)        */
#define endat1_app_endat_test2_sel_test_mux2_Msk (0x3000UL)         /*!< endat1_app endat_test2: sel_test_mux2 (Bitfield-Mask: 0x03) */
#define endat1_app_endat_test2_test_mode_divider_Pos (11UL)         /*!< endat1_app endat_test2: test_mode_divider (Bit 11)    */
#define endat1_app_endat_test2_test_mode_divider_Msk (0x800UL)      /*!< endat1_app endat_test2: test_mode_divider (Bitfield-Mask: 0x01) */
#define endat1_app_endat_test2_selection_add_info_Pos (8UL)         /*!< endat1_app endat_test2: selection_add_info (Bit 8)    */
#define endat1_app_endat_test2_selection_add_info_Msk (0x700UL)     /*!< endat1_app endat_test2: selection_add_info (Bitfield-Mask: 0x07) */
#define endat1_app_endat_test2_ic_test_mode_Pos (7UL)               /*!< endat1_app endat_test2: ic_test_mode (Bit 7)          */
#define endat1_app_endat_test2_ic_test_mode_Msk (0x80UL)            /*!< endat1_app endat_test2: ic_test_mode (Bitfield-Mask: 0x01) */
#define endat1_app_endat_test2_reserved1_Pos (6UL)                  /*!< endat1_app endat_test2: reserved1 (Bit 6)             */
#define endat1_app_endat_test2_reserved1_Msk (0x40UL)               /*!< endat1_app endat_test2: reserved1 (Bitfield-Mask: 0x01) */
#define endat1_app_endat_test2_sel_test_mux_Pos (4UL)               /*!< endat1_app endat_test2: sel_test_mux (Bit 4)          */
#define endat1_app_endat_test2_sel_test_mux_Msk (0x30UL)            /*!< endat1_app endat_test2: sel_test_mux (Bitfield-Mask: 0x03) */
#define endat1_app_endat_test2_test_receive_reg_Pos (3UL)           /*!< endat1_app endat_test2: test_receive_reg (Bit 3)      */
#define endat1_app_endat_test2_test_receive_reg_Msk (0x8UL)         /*!< endat1_app endat_test2: test_receive_reg (Bitfield-Mask: 0x01) */
#define endat1_app_endat_test2_selection_tst_out_Pos (2UL)          /*!< endat1_app endat_test2: selection_tst_out (Bit 2)     */
#define endat1_app_endat_test2_selection_tst_out_Msk (0x4UL)        /*!< endat1_app endat_test2: selection_tst_out (Bitfield-Mask: 0x01) */
#define endat1_app_endat_test2_reserved0_Pos (0UL)                  /*!< endat1_app endat_test2: reserved0 (Bit 0)             */
#define endat1_app_endat_test2_reserved0_Msk (0x3UL)                /*!< endat1_app endat_test2: reserved0 (Bitfield-Mask: 0x03) */
/* ===================================================  endat_receive4_0  ==================================================== */
#define endat1_app_endat_receive4_0_byte4_Pos (24UL)                /*!< endat1_app endat_receive4_0: byte4 (Bit 24)           */
#define endat1_app_endat_receive4_0_byte4_Msk (0xff000000UL)        /*!< endat1_app endat_receive4_0: byte4 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive4_0_byte3_Pos (16UL)                /*!< endat1_app endat_receive4_0: byte3 (Bit 16)           */
#define endat1_app_endat_receive4_0_byte3_Msk (0xff0000UL)          /*!< endat1_app endat_receive4_0: byte3 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive4_0_byte2_Pos (8UL)                 /*!< endat1_app endat_receive4_0: byte2 (Bit 8)            */
#define endat1_app_endat_receive4_0_byte2_Msk (0xff00UL)            /*!< endat1_app endat_receive4_0: byte2 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive4_0_byte1_Pos (0UL)                 /*!< endat1_app endat_receive4_0: byte1 (Bit 0)            */
#define endat1_app_endat_receive4_0_byte1_Msk (0xffUL)              /*!< endat1_app endat_receive4_0: byte1 (Bitfield-Mask: 0xff) */
/* ===================================================  endat_receive4_1  ==================================================== */
#define endat1_app_endat_receive4_1_byte6_Pos (8UL)                 /*!< endat1_app endat_receive4_1: byte6 (Bit 8)            */
#define endat1_app_endat_receive4_1_byte6_Msk (0xff00UL)            /*!< endat1_app endat_receive4_1: byte6 (Bitfield-Mask: 0xff) */
#define endat1_app_endat_receive4_1_byte5_Pos (0UL)                 /*!< endat1_app endat_receive4_1: byte5 (Bit 0)            */
#define endat1_app_endat_receive4_1_byte5_Msk (0xffUL)              /*!< endat1_app endat_receive4_1: byte5 (Bitfield-Mask: 0xff) */
/* ====================================================  endat_sw_strobe  ==================================================== */
#define endat1_app_endat_sw_strobe_sw_strobe_Pos (0UL)              /*!< endat1_app endat_sw_strobe: sw_strobe (Bit 0)         */
#define endat1_app_endat_sw_strobe_sw_strobe_Msk (0xffffffffUL)     /*!< endat1_app endat_sw_strobe: sw_strobe (Bitfield-Mask: 0xffffffff) */
/* =======================================================  endat_id  ======================================================== */
#define endat1_app_endat_id_id_Pos        (0UL)                     /*!< endat1_app endat_id: id (Bit 0)                       */
#define endat1_app_endat_id_id_Msk        (0xffffffffUL)            /*!< endat1_app endat_id: id (Bitfield-Mask: 0xffffffff)   */


/* =========================================================================================================================== */
/* ================                                      endat_ctrl0_app                                      ================ */
/* =========================================================================================================================== */

/* ================================================  endat_ctrl_trigger_cfg  ================================================= */
#define endat_ctrl0_app_endat_ctrl_trigger_cfg_sel_Pos (0UL)        /*!< endat_ctrl0_app endat_ctrl_trigger_cfg: sel (Bit 0)   */
#define endat_ctrl0_app_endat_ctrl_trigger_cfg_sel_Msk (0xfUL)      /*!< endat_ctrl0_app endat_ctrl_trigger_cfg: sel (Bitfield-Mask: 0x0f) */
/* ==================================================  endat_ctrl_trigger  =================================================== */
#define endat_ctrl0_app_endat_ctrl_trigger_manual_Pos (0UL)         /*!< endat_ctrl0_app endat_ctrl_trigger: manual (Bit 0)    */
#define endat_ctrl0_app_endat_ctrl_trigger_manual_Msk (0x1UL)       /*!< endat_ctrl0_app endat_ctrl_trigger: manual (Bitfield-Mask: 0x01) */
/* =================================================  endat_ctrl_strobe_cfg  ================================================= */
#define endat_ctrl0_app_endat_ctrl_strobe_cfg_high_len_Pos (8UL)    /*!< endat_ctrl0_app endat_ctrl_strobe_cfg: high_len (Bit 8) */
#define endat_ctrl0_app_endat_ctrl_strobe_cfg_high_len_Msk (0xff00UL) /*!< endat_ctrl0_app endat_ctrl_strobe_cfg: high_len (Bitfield-Mask: 0xff) */
#define endat_ctrl0_app_endat_ctrl_strobe_cfg_low_len_Pos (0UL)     /*!< endat_ctrl0_app endat_ctrl_strobe_cfg: low_len (Bit 0) */
#define endat_ctrl0_app_endat_ctrl_strobe_cfg_low_len_Msk (0xffUL)  /*!< endat_ctrl0_app endat_ctrl_strobe_cfg: low_len (Bitfield-Mask: 0xff) */


/* =========================================================================================================================== */
/* ================                                      endat_ctrl1_app                                      ================ */
/* =========================================================================================================================== */

/* ================================================  endat_ctrl_trigger_cfg  ================================================= */
#define endat_ctrl1_app_endat_ctrl_trigger_cfg_sel_Pos (0UL)        /*!< endat_ctrl1_app endat_ctrl_trigger_cfg: sel (Bit 0)   */
#define endat_ctrl1_app_endat_ctrl_trigger_cfg_sel_Msk (0xfUL)      /*!< endat_ctrl1_app endat_ctrl_trigger_cfg: sel (Bitfield-Mask: 0x0f) */
/* ==================================================  endat_ctrl_trigger  =================================================== */
#define endat_ctrl1_app_endat_ctrl_trigger_manual_Pos (0UL)         /*!< endat_ctrl1_app endat_ctrl_trigger: manual (Bit 0)    */
#define endat_ctrl1_app_endat_ctrl_trigger_manual_Msk (0x1UL)       /*!< endat_ctrl1_app endat_ctrl_trigger: manual (Bitfield-Mask: 0x01) */
/* =================================================  endat_ctrl_strobe_cfg  ================================================= */
#define endat_ctrl1_app_endat_ctrl_strobe_cfg_high_len_Pos (8UL)    /*!< endat_ctrl1_app endat_ctrl_strobe_cfg: high_len (Bit 8) */
#define endat_ctrl1_app_endat_ctrl_strobe_cfg_high_len_Msk (0xff00UL) /*!< endat_ctrl1_app endat_ctrl_strobe_cfg: high_len (Bitfield-Mask: 0xff) */
#define endat_ctrl1_app_endat_ctrl_strobe_cfg_low_len_Pos (0UL)     /*!< endat_ctrl1_app endat_ctrl_strobe_cfg: low_len (Bit 0) */
#define endat_ctrl1_app_endat_ctrl_strobe_cfg_low_len_Msk (0xffUL)  /*!< endat_ctrl1_app endat_ctrl_strobe_cfg: low_len (Bitfield-Mask: 0xff) */


/* =========================================================================================================================== */
/* ================                                       can_ctrl0_app                                       ================ */
/* =========================================================================================================================== */

/* =====================================================  canctrl_mode  ====================================================== */
#define can_ctrl0_app_canctrl_mode_acceptance_mode_Pos (3UL)        /*!< can_ctrl0_app canctrl_mode: acceptance_mode (Bit 3)   */
#define can_ctrl0_app_canctrl_mode_acceptance_mode_Msk (0x8UL)      /*!< can_ctrl0_app canctrl_mode: acceptance_mode (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_mode_selftest_Pos (2UL)               /*!< can_ctrl0_app canctrl_mode: selftest (Bit 2)          */
#define can_ctrl0_app_canctrl_mode_selftest_Msk (0x4UL)             /*!< can_ctrl0_app canctrl_mode: selftest (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_mode_listen_mode_Pos (1UL)            /*!< can_ctrl0_app canctrl_mode: listen_mode (Bit 1)       */
#define can_ctrl0_app_canctrl_mode_listen_mode_Msk (0x2UL)          /*!< can_ctrl0_app canctrl_mode: listen_mode (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_mode_reset_mode_Pos (0UL)             /*!< can_ctrl0_app canctrl_mode: reset_mode (Bit 0)        */
#define can_ctrl0_app_canctrl_mode_reset_mode_Msk (0x1UL)           /*!< can_ctrl0_app canctrl_mode: reset_mode (Bitfield-Mask: 0x01) */
/* ====================================================  canctrl_command  ==================================================== */
#define can_ctrl0_app_canctrl_command_self_rx_request_Pos (4UL)     /*!< can_ctrl0_app canctrl_command: self_rx_request (Bit 4) */
#define can_ctrl0_app_canctrl_command_self_rx_request_Msk (0x10UL)  /*!< can_ctrl0_app canctrl_command: self_rx_request (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_command_clr_overrun_Pos (3UL)         /*!< can_ctrl0_app canctrl_command: clr_overrun (Bit 3)    */
#define can_ctrl0_app_canctrl_command_clr_overrun_Msk (0x8UL)       /*!< can_ctrl0_app canctrl_command: clr_overrun (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_command_release_rx_buf_Pos (2UL)      /*!< can_ctrl0_app canctrl_command: release_rx_buf (Bit 2) */
#define can_ctrl0_app_canctrl_command_release_rx_buf_Msk (0x4UL)    /*!< can_ctrl0_app canctrl_command: release_rx_buf (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_command_abort_tx_Pos (1UL)            /*!< can_ctrl0_app canctrl_command: abort_tx (Bit 1)       */
#define can_ctrl0_app_canctrl_command_abort_tx_Msk (0x2UL)          /*!< can_ctrl0_app canctrl_command: abort_tx (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_command_tx_request_Pos (0UL)          /*!< can_ctrl0_app canctrl_command: tx_request (Bit 0)     */
#define can_ctrl0_app_canctrl_command_tx_request_Msk (0x1UL)        /*!< can_ctrl0_app canctrl_command: tx_request (Bitfield-Mask: 0x01) */
/* ====================================================  canctrl_status  ===================================================== */
#define can_ctrl0_app_canctrl_status_bus_status_Pos (7UL)           /*!< can_ctrl0_app canctrl_status: bus_status (Bit 7)      */
#define can_ctrl0_app_canctrl_status_bus_status_Msk (0x80UL)        /*!< can_ctrl0_app canctrl_status: bus_status (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_status_error_status_Pos (6UL)         /*!< can_ctrl0_app canctrl_status: error_status (Bit 6)    */
#define can_ctrl0_app_canctrl_status_error_status_Msk (0x40UL)      /*!< can_ctrl0_app canctrl_status: error_status (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_status_tx_status_Pos (5UL)            /*!< can_ctrl0_app canctrl_status: tx_status (Bit 5)       */
#define can_ctrl0_app_canctrl_status_tx_status_Msk (0x20UL)         /*!< can_ctrl0_app canctrl_status: tx_status (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_status_rx_status_Pos (4UL)            /*!< can_ctrl0_app canctrl_status: rx_status (Bit 4)       */
#define can_ctrl0_app_canctrl_status_rx_status_Msk (0x10UL)         /*!< can_ctrl0_app canctrl_status: rx_status (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_status_tx_complete_Pos (3UL)          /*!< can_ctrl0_app canctrl_status: tx_complete (Bit 3)     */
#define can_ctrl0_app_canctrl_status_tx_complete_Msk (0x8UL)        /*!< can_ctrl0_app canctrl_status: tx_complete (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_status_tx_buf_status_Pos (2UL)        /*!< can_ctrl0_app canctrl_status: tx_buf_status (Bit 2)   */
#define can_ctrl0_app_canctrl_status_tx_buf_status_Msk (0x4UL)      /*!< can_ctrl0_app canctrl_status: tx_buf_status (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_status_overrun_Pos (1UL)              /*!< can_ctrl0_app canctrl_status: overrun (Bit 1)         */
#define can_ctrl0_app_canctrl_status_overrun_Msk (0x2UL)            /*!< can_ctrl0_app canctrl_status: overrun (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_status_rx_buf_status_Pos (0UL)        /*!< can_ctrl0_app canctrl_status: rx_buf_status (Bit 0)   */
#define can_ctrl0_app_canctrl_status_rx_buf_status_Msk (0x1UL)      /*!< can_ctrl0_app canctrl_status: rx_buf_status (Bitfield-Mask: 0x01) */
/* ======================================================  canctrl_irq  ====================================================== */
#define can_ctrl0_app_canctrl_irq_reserved1_Pos (8UL)               /*!< can_ctrl0_app canctrl_irq: reserved1 (Bit 8)          */
#define can_ctrl0_app_canctrl_irq_reserved1_Msk (0xffffff00UL)      /*!< can_ctrl0_app canctrl_irq: reserved1 (Bitfield-Mask: 0xffffff) */
#define can_ctrl0_app_canctrl_irq_bus_error_irq_Pos (7UL)           /*!< can_ctrl0_app canctrl_irq: bus_error_irq (Bit 7)      */
#define can_ctrl0_app_canctrl_irq_bus_error_irq_Msk (0x80UL)        /*!< can_ctrl0_app canctrl_irq: bus_error_irq (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_arb_lost_irq_Pos (6UL)            /*!< can_ctrl0_app canctrl_irq: arb_lost_irq (Bit 6)       */
#define can_ctrl0_app_canctrl_irq_arb_lost_irq_Msk (0x40UL)         /*!< can_ctrl0_app canctrl_irq: arb_lost_irq (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_err_passive_irq_Pos (5UL)         /*!< can_ctrl0_app canctrl_irq: err_passive_irq (Bit 5)    */
#define can_ctrl0_app_canctrl_irq_err_passive_irq_Msk (0x20UL)      /*!< can_ctrl0_app canctrl_irq: err_passive_irq (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_reserved0_Pos (4UL)               /*!< can_ctrl0_app canctrl_irq: reserved0 (Bit 4)          */
#define can_ctrl0_app_canctrl_irq_reserved0_Msk (0x10UL)            /*!< can_ctrl0_app canctrl_irq: reserved0 (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_overrun_irq_Pos (3UL)             /*!< can_ctrl0_app canctrl_irq: overrun_irq (Bit 3)        */
#define can_ctrl0_app_canctrl_irq_overrun_irq_Msk (0x8UL)           /*!< can_ctrl0_app canctrl_irq: overrun_irq (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_warning_irq_Pos (2UL)             /*!< can_ctrl0_app canctrl_irq: warning_irq (Bit 2)        */
#define can_ctrl0_app_canctrl_irq_warning_irq_Msk (0x4UL)           /*!< can_ctrl0_app canctrl_irq: warning_irq (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_tx_irq_Pos (1UL)                  /*!< can_ctrl0_app canctrl_irq: tx_irq (Bit 1)             */
#define can_ctrl0_app_canctrl_irq_tx_irq_Msk (0x2UL)                /*!< can_ctrl0_app canctrl_irq: tx_irq (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_rx_irq_Pos (0UL)                  /*!< can_ctrl0_app canctrl_irq: rx_irq (Bit 0)             */
#define can_ctrl0_app_canctrl_irq_rx_irq_Msk (0x1UL)                /*!< can_ctrl0_app canctrl_irq: rx_irq (Bitfield-Mask: 0x01) */
/* ====================================================  canctrl_irq_en  ===================================================== */
#define can_ctrl0_app_canctrl_irq_en_reserved1_Pos (8UL)            /*!< can_ctrl0_app canctrl_irq_en: reserved1 (Bit 8)       */
#define can_ctrl0_app_canctrl_irq_en_reserved1_Msk (0xffffff00UL)   /*!< can_ctrl0_app canctrl_irq_en: reserved1 (Bitfield-Mask: 0xffffff) */
#define can_ctrl0_app_canctrl_irq_en_bus_error_irq_en_Pos (7UL)     /*!< can_ctrl0_app canctrl_irq_en: bus_error_irq_en (Bit 7) */
#define can_ctrl0_app_canctrl_irq_en_bus_error_irq_en_Msk (0x80UL)  /*!< can_ctrl0_app canctrl_irq_en: bus_error_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_en_arb_lost_irq_en_Pos (6UL)      /*!< can_ctrl0_app canctrl_irq_en: arb_lost_irq_en (Bit 6) */
#define can_ctrl0_app_canctrl_irq_en_arb_lost_irq_en_Msk (0x40UL)   /*!< can_ctrl0_app canctrl_irq_en: arb_lost_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_en_err_passive_irq_en_Pos (5UL)   /*!< can_ctrl0_app canctrl_irq_en: err_passive_irq_en (Bit 5) */
#define can_ctrl0_app_canctrl_irq_en_err_passive_irq_en_Msk (0x20UL) /*!< can_ctrl0_app canctrl_irq_en: err_passive_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_en_reserved0_Pos (4UL)            /*!< can_ctrl0_app canctrl_irq_en: reserved0 (Bit 4)       */
#define can_ctrl0_app_canctrl_irq_en_reserved0_Msk (0x10UL)         /*!< can_ctrl0_app canctrl_irq_en: reserved0 (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_en_overrun_irq_en_Pos (3UL)       /*!< can_ctrl0_app canctrl_irq_en: overrun_irq_en (Bit 3)  */
#define can_ctrl0_app_canctrl_irq_en_overrun_irq_en_Msk (0x8UL)     /*!< can_ctrl0_app canctrl_irq_en: overrun_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_en_warning_irq_en_Pos (2UL)       /*!< can_ctrl0_app canctrl_irq_en: warning_irq_en (Bit 2)  */
#define can_ctrl0_app_canctrl_irq_en_warning_irq_en_Msk (0x4UL)     /*!< can_ctrl0_app canctrl_irq_en: warning_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_en_tx_irq_en_Pos (1UL)            /*!< can_ctrl0_app canctrl_irq_en: tx_irq_en (Bit 1)       */
#define can_ctrl0_app_canctrl_irq_en_tx_irq_en_Msk (0x2UL)          /*!< can_ctrl0_app canctrl_irq_en: tx_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_irq_en_rx_irq_en_Pos (0UL)            /*!< can_ctrl0_app canctrl_irq_en: rx_irq_en (Bit 0)       */
#define can_ctrl0_app_canctrl_irq_en_rx_irq_en_Msk (0x1UL)          /*!< can_ctrl0_app canctrl_irq_en: rx_irq_en (Bitfield-Mask: 0x01) */
/* =========================================  canctrl_not_extended_acceptance_mask0  ========================================= */
/* ==================================================  canctrl_bus_timing0  ================================================== */
#define can_ctrl0_app_canctrl_bus_timing0_sync_jump_width_Pos (9UL) /*!< can_ctrl0_app canctrl_bus_timing0: sync_jump_width (Bit 9) */
#define can_ctrl0_app_canctrl_bus_timing0_sync_jump_width_Msk (0x600UL) /*!< can_ctrl0_app canctrl_bus_timing0: sync_jump_width (Bitfield-Mask: 0x03) */
#define can_ctrl0_app_canctrl_bus_timing0_prescaler_Pos (0UL)       /*!< can_ctrl0_app canctrl_bus_timing0: prescaler (Bit 0)  */
#define can_ctrl0_app_canctrl_bus_timing0_prescaler_Msk (0x1ffUL)   /*!< can_ctrl0_app canctrl_bus_timing0: prescaler (Bitfield-Mask: 0x1ff) */
/* ==================================================  canctrl_bus_timing1  ================================================== */
#define can_ctrl0_app_canctrl_bus_timing1_reserved1_Pos (13UL)      /*!< can_ctrl0_app canctrl_bus_timing1: reserved1 (Bit 13) */
#define can_ctrl0_app_canctrl_bus_timing1_reserved1_Msk (0xffffe000UL) /*!< can_ctrl0_app canctrl_bus_timing1: reserved1 (Bitfield-Mask: 0x7ffff) */
#define can_ctrl0_app_canctrl_bus_timing1_tseg2_Pos (8UL)           /*!< can_ctrl0_app canctrl_bus_timing1: tseg2 (Bit 8)      */
#define can_ctrl0_app_canctrl_bus_timing1_tseg2_Msk (0x1f00UL)      /*!< can_ctrl0_app canctrl_bus_timing1: tseg2 (Bitfield-Mask: 0x1f) */
#define can_ctrl0_app_canctrl_bus_timing1_oversampling_Pos (7UL)    /*!< can_ctrl0_app canctrl_bus_timing1: oversampling (Bit 7) */
#define can_ctrl0_app_canctrl_bus_timing1_oversampling_Msk (0x80UL) /*!< can_ctrl0_app canctrl_bus_timing1: oversampling (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_bus_timing1_reserved0_Pos (6UL)       /*!< can_ctrl0_app canctrl_bus_timing1: reserved0 (Bit 6)  */
#define can_ctrl0_app_canctrl_bus_timing1_reserved0_Msk (0x40UL)    /*!< can_ctrl0_app canctrl_bus_timing1: reserved0 (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_bus_timing1_tseg1_Pos (0UL)           /*!< can_ctrl0_app canctrl_bus_timing1: tseg1 (Bit 0)      */
#define can_ctrl0_app_canctrl_bus_timing1_tseg1_Msk (0x3fUL)        /*!< can_ctrl0_app canctrl_bus_timing1: tseg1 (Bitfield-Mask: 0x3f) */
/* ==============================================  canctrl_not_extended_data0  =============================================== */
/* ===============================================  canctrl_arb_lost_capture  ================================================ */
#define can_ctrl0_app_canctrl_arb_lost_capture_position_Pos (0UL)   /*!< can_ctrl0_app canctrl_arb_lost_capture: position (Bit 0) */
#define can_ctrl0_app_canctrl_arb_lost_capture_position_Msk (0x1fUL) /*!< can_ctrl0_app canctrl_arb_lost_capture: position (Bitfield-Mask: 0x1f) */
/* ===============================================  canctrl_err_code_capture  ================================================ */
#define can_ctrl0_app_canctrl_err_code_capture_err_code_Pos (6UL)   /*!< can_ctrl0_app canctrl_err_code_capture: err_code (Bit 6) */
#define can_ctrl0_app_canctrl_err_code_capture_err_code_Msk (0xc0UL) /*!< can_ctrl0_app canctrl_err_code_capture: err_code (Bitfield-Mask: 0x03) */
#define can_ctrl0_app_canctrl_err_code_capture_direction_Pos (5UL)  /*!< can_ctrl0_app canctrl_err_code_capture: direction (Bit 5) */
#define can_ctrl0_app_canctrl_err_code_capture_direction_Msk (0x20UL) /*!< can_ctrl0_app canctrl_err_code_capture: direction (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_err_code_capture_segment_Pos (0UL)    /*!< can_ctrl0_app canctrl_err_code_capture: segment (Bit 0) */
#define can_ctrl0_app_canctrl_err_code_capture_segment_Msk (0x1fUL) /*!< can_ctrl0_app canctrl_err_code_capture: segment (Bitfield-Mask: 0x1f) */
/* ===============================================  canctrl_err_warning_limit  =============================================== */
#define can_ctrl0_app_canctrl_err_warning_limit_limit_Pos (0UL)     /*!< can_ctrl0_app canctrl_err_warning_limit: limit (Bit 0) */
#define can_ctrl0_app_canctrl_err_warning_limit_limit_Msk (0xffUL)  /*!< can_ctrl0_app canctrl_err_warning_limit: limit (Bitfield-Mask: 0xff) */
/* =================================================  canctrl_rx_error_cnt  ================================================== */
#define can_ctrl0_app_canctrl_rx_error_cnt_rx_err_Pos (0UL)         /*!< can_ctrl0_app canctrl_rx_error_cnt: rx_err (Bit 0)    */
#define can_ctrl0_app_canctrl_rx_error_cnt_rx_err_Msk (0xffUL)      /*!< can_ctrl0_app canctrl_rx_error_cnt: rx_err (Bitfield-Mask: 0xff) */
/* =================================================  canctrl_tx_error_cnt  ================================================== */
#define can_ctrl0_app_canctrl_tx_error_cnt_tx_err_Pos (0UL)         /*!< can_ctrl0_app canctrl_tx_error_cnt: tx_err (Bit 0)    */
#define can_ctrl0_app_canctrl_tx_error_cnt_tx_err_Msk (0xffUL)      /*!< can_ctrl0_app canctrl_tx_error_cnt: tx_err (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data0  ===================================================== */
#define can_ctrl0_app_canctrl_data0_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data0: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data0_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data0: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data1  ===================================================== */
#define can_ctrl0_app_canctrl_data1_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data1: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data1_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data1: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data2  ===================================================== */
#define can_ctrl0_app_canctrl_data2_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data2: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data2_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data2: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data3  ===================================================== */
#define can_ctrl0_app_canctrl_data3_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data3: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data3_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data3: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data4  ===================================================== */
#define can_ctrl0_app_canctrl_data4_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data4: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data4_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data4: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data5  ===================================================== */
#define can_ctrl0_app_canctrl_data5_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data5: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data5_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data5: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data6  ===================================================== */
#define can_ctrl0_app_canctrl_data6_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data6: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data6_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data6: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data7  ===================================================== */
#define can_ctrl0_app_canctrl_data7_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data7: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data7_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data7: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data8  ===================================================== */
#define can_ctrl0_app_canctrl_data8_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data8: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data8_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data8: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data9  ===================================================== */
#define can_ctrl0_app_canctrl_data9_data_Pos (0UL)                  /*!< can_ctrl0_app canctrl_data9: data (Bit 0)             */
#define can_ctrl0_app_canctrl_data9_data_Msk (0xffUL)               /*!< can_ctrl0_app canctrl_data9: data (Bitfield-Mask: 0xff) */
/* ====================================================  canctrl_data10  ===================================================== */
#define can_ctrl0_app_canctrl_data10_data_Pos (0UL)                 /*!< can_ctrl0_app canctrl_data10: data (Bit 0)            */
#define can_ctrl0_app_canctrl_data10_data_Msk (0xffUL)              /*!< can_ctrl0_app canctrl_data10: data (Bitfield-Mask: 0xff) */
/* ====================================================  canctrl_data11  ===================================================== */
#define can_ctrl0_app_canctrl_data11_data_Pos (0UL)                 /*!< can_ctrl0_app canctrl_data11: data (Bit 0)            */
#define can_ctrl0_app_canctrl_data11_data_Msk (0xffUL)              /*!< can_ctrl0_app canctrl_data11: data (Bitfield-Mask: 0xff) */
/* ====================================================  canctrl_data12  ===================================================== */
#define can_ctrl0_app_canctrl_data12_data_Pos (0UL)                 /*!< can_ctrl0_app canctrl_data12: data (Bit 0)            */
#define can_ctrl0_app_canctrl_data12_data_Msk (0xffUL)              /*!< can_ctrl0_app canctrl_data12: data (Bitfield-Mask: 0xff) */
/* ================================================  canctrl_rx_message_cnt  ================================================= */
#define can_ctrl0_app_canctrl_rx_message_cnt_rx_msg_cnt_Pos (0UL)   /*!< can_ctrl0_app canctrl_rx_message_cnt: rx_msg_cnt (Bit 0) */
#define can_ctrl0_app_canctrl_rx_message_cnt_rx_msg_cnt_Msk (0x7fUL) /*!< can_ctrl0_app canctrl_rx_message_cnt: rx_msg_cnt (Bitfield-Mask: 0x7f) */
/* =================================================  canctrl_mode_control  ================================================== */
#define can_ctrl0_app_canctrl_mode_control_reserved1_Pos (8UL)      /*!< can_ctrl0_app canctrl_mode_control: reserved1 (Bit 8) */
#define can_ctrl0_app_canctrl_mode_control_reserved1_Msk (0xffffff00UL) /*!< can_ctrl0_app canctrl_mode_control: reserved1 (Bitfield-Mask: 0xffffff) */
#define can_ctrl0_app_canctrl_mode_control_mode_Pos (7UL)           /*!< can_ctrl0_app canctrl_mode_control: mode (Bit 7)      */
#define can_ctrl0_app_canctrl_mode_control_mode_Msk (0x80UL)        /*!< can_ctrl0_app canctrl_mode_control: mode (Bitfield-Mask: 0x01) */
#define can_ctrl0_app_canctrl_mode_control_reserved0_Pos (0UL)      /*!< can_ctrl0_app canctrl_mode_control: reserved0 (Bit 0) */
#define can_ctrl0_app_canctrl_mode_control_reserved0_Msk (0x7fUL)   /*!< can_ctrl0_app canctrl_mode_control: reserved0 (Bitfield-Mask: 0x7f) */


/* =========================================================================================================================== */
/* ================                                       can_ctrl1_app                                       ================ */
/* =========================================================================================================================== */

/* =====================================================  canctrl_mode  ====================================================== */
#define can_ctrl1_app_canctrl_mode_acceptance_mode_Pos (3UL)        /*!< can_ctrl1_app canctrl_mode: acceptance_mode (Bit 3)   */
#define can_ctrl1_app_canctrl_mode_acceptance_mode_Msk (0x8UL)      /*!< can_ctrl1_app canctrl_mode: acceptance_mode (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_mode_selftest_Pos (2UL)               /*!< can_ctrl1_app canctrl_mode: selftest (Bit 2)          */
#define can_ctrl1_app_canctrl_mode_selftest_Msk (0x4UL)             /*!< can_ctrl1_app canctrl_mode: selftest (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_mode_listen_mode_Pos (1UL)            /*!< can_ctrl1_app canctrl_mode: listen_mode (Bit 1)       */
#define can_ctrl1_app_canctrl_mode_listen_mode_Msk (0x2UL)          /*!< can_ctrl1_app canctrl_mode: listen_mode (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_mode_reset_mode_Pos (0UL)             /*!< can_ctrl1_app canctrl_mode: reset_mode (Bit 0)        */
#define can_ctrl1_app_canctrl_mode_reset_mode_Msk (0x1UL)           /*!< can_ctrl1_app canctrl_mode: reset_mode (Bitfield-Mask: 0x01) */
/* ====================================================  canctrl_command  ==================================================== */
#define can_ctrl1_app_canctrl_command_self_rx_request_Pos (4UL)     /*!< can_ctrl1_app canctrl_command: self_rx_request (Bit 4) */
#define can_ctrl1_app_canctrl_command_self_rx_request_Msk (0x10UL)  /*!< can_ctrl1_app canctrl_command: self_rx_request (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_command_clr_overrun_Pos (3UL)         /*!< can_ctrl1_app canctrl_command: clr_overrun (Bit 3)    */
#define can_ctrl1_app_canctrl_command_clr_overrun_Msk (0x8UL)       /*!< can_ctrl1_app canctrl_command: clr_overrun (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_command_release_rx_buf_Pos (2UL)      /*!< can_ctrl1_app canctrl_command: release_rx_buf (Bit 2) */
#define can_ctrl1_app_canctrl_command_release_rx_buf_Msk (0x4UL)    /*!< can_ctrl1_app canctrl_command: release_rx_buf (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_command_abort_tx_Pos (1UL)            /*!< can_ctrl1_app canctrl_command: abort_tx (Bit 1)       */
#define can_ctrl1_app_canctrl_command_abort_tx_Msk (0x2UL)          /*!< can_ctrl1_app canctrl_command: abort_tx (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_command_tx_request_Pos (0UL)          /*!< can_ctrl1_app canctrl_command: tx_request (Bit 0)     */
#define can_ctrl1_app_canctrl_command_tx_request_Msk (0x1UL)        /*!< can_ctrl1_app canctrl_command: tx_request (Bitfield-Mask: 0x01) */
/* ====================================================  canctrl_status  ===================================================== */
#define can_ctrl1_app_canctrl_status_bus_status_Pos (7UL)           /*!< can_ctrl1_app canctrl_status: bus_status (Bit 7)      */
#define can_ctrl1_app_canctrl_status_bus_status_Msk (0x80UL)        /*!< can_ctrl1_app canctrl_status: bus_status (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_status_error_status_Pos (6UL)         /*!< can_ctrl1_app canctrl_status: error_status (Bit 6)    */
#define can_ctrl1_app_canctrl_status_error_status_Msk (0x40UL)      /*!< can_ctrl1_app canctrl_status: error_status (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_status_tx_status_Pos (5UL)            /*!< can_ctrl1_app canctrl_status: tx_status (Bit 5)       */
#define can_ctrl1_app_canctrl_status_tx_status_Msk (0x20UL)         /*!< can_ctrl1_app canctrl_status: tx_status (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_status_rx_status_Pos (4UL)            /*!< can_ctrl1_app canctrl_status: rx_status (Bit 4)       */
#define can_ctrl1_app_canctrl_status_rx_status_Msk (0x10UL)         /*!< can_ctrl1_app canctrl_status: rx_status (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_status_tx_complete_Pos (3UL)          /*!< can_ctrl1_app canctrl_status: tx_complete (Bit 3)     */
#define can_ctrl1_app_canctrl_status_tx_complete_Msk (0x8UL)        /*!< can_ctrl1_app canctrl_status: tx_complete (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_status_tx_buf_status_Pos (2UL)        /*!< can_ctrl1_app canctrl_status: tx_buf_status (Bit 2)   */
#define can_ctrl1_app_canctrl_status_tx_buf_status_Msk (0x4UL)      /*!< can_ctrl1_app canctrl_status: tx_buf_status (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_status_overrun_Pos (1UL)              /*!< can_ctrl1_app canctrl_status: overrun (Bit 1)         */
#define can_ctrl1_app_canctrl_status_overrun_Msk (0x2UL)            /*!< can_ctrl1_app canctrl_status: overrun (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_status_rx_buf_status_Pos (0UL)        /*!< can_ctrl1_app canctrl_status: rx_buf_status (Bit 0)   */
#define can_ctrl1_app_canctrl_status_rx_buf_status_Msk (0x1UL)      /*!< can_ctrl1_app canctrl_status: rx_buf_status (Bitfield-Mask: 0x01) */
/* ======================================================  canctrl_irq  ====================================================== */
#define can_ctrl1_app_canctrl_irq_reserved1_Pos (8UL)               /*!< can_ctrl1_app canctrl_irq: reserved1 (Bit 8)          */
#define can_ctrl1_app_canctrl_irq_reserved1_Msk (0xffffff00UL)      /*!< can_ctrl1_app canctrl_irq: reserved1 (Bitfield-Mask: 0xffffff) */
#define can_ctrl1_app_canctrl_irq_bus_error_irq_Pos (7UL)           /*!< can_ctrl1_app canctrl_irq: bus_error_irq (Bit 7)      */
#define can_ctrl1_app_canctrl_irq_bus_error_irq_Msk (0x80UL)        /*!< can_ctrl1_app canctrl_irq: bus_error_irq (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_arb_lost_irq_Pos (6UL)            /*!< can_ctrl1_app canctrl_irq: arb_lost_irq (Bit 6)       */
#define can_ctrl1_app_canctrl_irq_arb_lost_irq_Msk (0x40UL)         /*!< can_ctrl1_app canctrl_irq: arb_lost_irq (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_err_passive_irq_Pos (5UL)         /*!< can_ctrl1_app canctrl_irq: err_passive_irq (Bit 5)    */
#define can_ctrl1_app_canctrl_irq_err_passive_irq_Msk (0x20UL)      /*!< can_ctrl1_app canctrl_irq: err_passive_irq (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_reserved0_Pos (4UL)               /*!< can_ctrl1_app canctrl_irq: reserved0 (Bit 4)          */
#define can_ctrl1_app_canctrl_irq_reserved0_Msk (0x10UL)            /*!< can_ctrl1_app canctrl_irq: reserved0 (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_overrun_irq_Pos (3UL)             /*!< can_ctrl1_app canctrl_irq: overrun_irq (Bit 3)        */
#define can_ctrl1_app_canctrl_irq_overrun_irq_Msk (0x8UL)           /*!< can_ctrl1_app canctrl_irq: overrun_irq (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_warning_irq_Pos (2UL)             /*!< can_ctrl1_app canctrl_irq: warning_irq (Bit 2)        */
#define can_ctrl1_app_canctrl_irq_warning_irq_Msk (0x4UL)           /*!< can_ctrl1_app canctrl_irq: warning_irq (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_tx_irq_Pos (1UL)                  /*!< can_ctrl1_app canctrl_irq: tx_irq (Bit 1)             */
#define can_ctrl1_app_canctrl_irq_tx_irq_Msk (0x2UL)                /*!< can_ctrl1_app canctrl_irq: tx_irq (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_rx_irq_Pos (0UL)                  /*!< can_ctrl1_app canctrl_irq: rx_irq (Bit 0)             */
#define can_ctrl1_app_canctrl_irq_rx_irq_Msk (0x1UL)                /*!< can_ctrl1_app canctrl_irq: rx_irq (Bitfield-Mask: 0x01) */
/* ====================================================  canctrl_irq_en  ===================================================== */
#define can_ctrl1_app_canctrl_irq_en_reserved1_Pos (8UL)            /*!< can_ctrl1_app canctrl_irq_en: reserved1 (Bit 8)       */
#define can_ctrl1_app_canctrl_irq_en_reserved1_Msk (0xffffff00UL)   /*!< can_ctrl1_app canctrl_irq_en: reserved1 (Bitfield-Mask: 0xffffff) */
#define can_ctrl1_app_canctrl_irq_en_bus_error_irq_en_Pos (7UL)     /*!< can_ctrl1_app canctrl_irq_en: bus_error_irq_en (Bit 7) */
#define can_ctrl1_app_canctrl_irq_en_bus_error_irq_en_Msk (0x80UL)  /*!< can_ctrl1_app canctrl_irq_en: bus_error_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_en_arb_lost_irq_en_Pos (6UL)      /*!< can_ctrl1_app canctrl_irq_en: arb_lost_irq_en (Bit 6) */
#define can_ctrl1_app_canctrl_irq_en_arb_lost_irq_en_Msk (0x40UL)   /*!< can_ctrl1_app canctrl_irq_en: arb_lost_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_en_err_passive_irq_en_Pos (5UL)   /*!< can_ctrl1_app canctrl_irq_en: err_passive_irq_en (Bit 5) */
#define can_ctrl1_app_canctrl_irq_en_err_passive_irq_en_Msk (0x20UL) /*!< can_ctrl1_app canctrl_irq_en: err_passive_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_en_reserved0_Pos (4UL)            /*!< can_ctrl1_app canctrl_irq_en: reserved0 (Bit 4)       */
#define can_ctrl1_app_canctrl_irq_en_reserved0_Msk (0x10UL)         /*!< can_ctrl1_app canctrl_irq_en: reserved0 (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_en_overrun_irq_en_Pos (3UL)       /*!< can_ctrl1_app canctrl_irq_en: overrun_irq_en (Bit 3)  */
#define can_ctrl1_app_canctrl_irq_en_overrun_irq_en_Msk (0x8UL)     /*!< can_ctrl1_app canctrl_irq_en: overrun_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_en_warning_irq_en_Pos (2UL)       /*!< can_ctrl1_app canctrl_irq_en: warning_irq_en (Bit 2)  */
#define can_ctrl1_app_canctrl_irq_en_warning_irq_en_Msk (0x4UL)     /*!< can_ctrl1_app canctrl_irq_en: warning_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_en_tx_irq_en_Pos (1UL)            /*!< can_ctrl1_app canctrl_irq_en: tx_irq_en (Bit 1)       */
#define can_ctrl1_app_canctrl_irq_en_tx_irq_en_Msk (0x2UL)          /*!< can_ctrl1_app canctrl_irq_en: tx_irq_en (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_irq_en_rx_irq_en_Pos (0UL)            /*!< can_ctrl1_app canctrl_irq_en: rx_irq_en (Bit 0)       */
#define can_ctrl1_app_canctrl_irq_en_rx_irq_en_Msk (0x1UL)          /*!< can_ctrl1_app canctrl_irq_en: rx_irq_en (Bitfield-Mask: 0x01) */
/* =========================================  canctrl_not_extended_acceptance_mask0  ========================================= */
/* ==================================================  canctrl_bus_timing0  ================================================== */
#define can_ctrl1_app_canctrl_bus_timing0_sync_jump_width_Pos (9UL) /*!< can_ctrl1_app canctrl_bus_timing0: sync_jump_width (Bit 9) */
#define can_ctrl1_app_canctrl_bus_timing0_sync_jump_width_Msk (0x600UL) /*!< can_ctrl1_app canctrl_bus_timing0: sync_jump_width (Bitfield-Mask: 0x03) */
#define can_ctrl1_app_canctrl_bus_timing0_prescaler_Pos (0UL)       /*!< can_ctrl1_app canctrl_bus_timing0: prescaler (Bit 0)  */
#define can_ctrl1_app_canctrl_bus_timing0_prescaler_Msk (0x1ffUL)   /*!< can_ctrl1_app canctrl_bus_timing0: prescaler (Bitfield-Mask: 0x1ff) */
/* ==================================================  canctrl_bus_timing1  ================================================== */
#define can_ctrl1_app_canctrl_bus_timing1_reserved1_Pos (13UL)      /*!< can_ctrl1_app canctrl_bus_timing1: reserved1 (Bit 13) */
#define can_ctrl1_app_canctrl_bus_timing1_reserved1_Msk (0xffffe000UL) /*!< can_ctrl1_app canctrl_bus_timing1: reserved1 (Bitfield-Mask: 0x7ffff) */
#define can_ctrl1_app_canctrl_bus_timing1_tseg2_Pos (8UL)           /*!< can_ctrl1_app canctrl_bus_timing1: tseg2 (Bit 8)      */
#define can_ctrl1_app_canctrl_bus_timing1_tseg2_Msk (0x1f00UL)      /*!< can_ctrl1_app canctrl_bus_timing1: tseg2 (Bitfield-Mask: 0x1f) */
#define can_ctrl1_app_canctrl_bus_timing1_oversampling_Pos (7UL)    /*!< can_ctrl1_app canctrl_bus_timing1: oversampling (Bit 7) */
#define can_ctrl1_app_canctrl_bus_timing1_oversampling_Msk (0x80UL) /*!< can_ctrl1_app canctrl_bus_timing1: oversampling (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_bus_timing1_reserved0_Pos (6UL)       /*!< can_ctrl1_app canctrl_bus_timing1: reserved0 (Bit 6)  */
#define can_ctrl1_app_canctrl_bus_timing1_reserved0_Msk (0x40UL)    /*!< can_ctrl1_app canctrl_bus_timing1: reserved0 (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_bus_timing1_tseg1_Pos (0UL)           /*!< can_ctrl1_app canctrl_bus_timing1: tseg1 (Bit 0)      */
#define can_ctrl1_app_canctrl_bus_timing1_tseg1_Msk (0x3fUL)        /*!< can_ctrl1_app canctrl_bus_timing1: tseg1 (Bitfield-Mask: 0x3f) */
/* ==============================================  canctrl_not_extended_data0  =============================================== */
/* ===============================================  canctrl_arb_lost_capture  ================================================ */
#define can_ctrl1_app_canctrl_arb_lost_capture_position_Pos (0UL)   /*!< can_ctrl1_app canctrl_arb_lost_capture: position (Bit 0) */
#define can_ctrl1_app_canctrl_arb_lost_capture_position_Msk (0x1fUL) /*!< can_ctrl1_app canctrl_arb_lost_capture: position (Bitfield-Mask: 0x1f) */
/* ===============================================  canctrl_err_code_capture  ================================================ */
#define can_ctrl1_app_canctrl_err_code_capture_err_code_Pos (6UL)   /*!< can_ctrl1_app canctrl_err_code_capture: err_code (Bit 6) */
#define can_ctrl1_app_canctrl_err_code_capture_err_code_Msk (0xc0UL) /*!< can_ctrl1_app canctrl_err_code_capture: err_code (Bitfield-Mask: 0x03) */
#define can_ctrl1_app_canctrl_err_code_capture_direction_Pos (5UL)  /*!< can_ctrl1_app canctrl_err_code_capture: direction (Bit 5) */
#define can_ctrl1_app_canctrl_err_code_capture_direction_Msk (0x20UL) /*!< can_ctrl1_app canctrl_err_code_capture: direction (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_err_code_capture_segment_Pos (0UL)    /*!< can_ctrl1_app canctrl_err_code_capture: segment (Bit 0) */
#define can_ctrl1_app_canctrl_err_code_capture_segment_Msk (0x1fUL) /*!< can_ctrl1_app canctrl_err_code_capture: segment (Bitfield-Mask: 0x1f) */
/* ===============================================  canctrl_err_warning_limit  =============================================== */
#define can_ctrl1_app_canctrl_err_warning_limit_limit_Pos (0UL)     /*!< can_ctrl1_app canctrl_err_warning_limit: limit (Bit 0) */
#define can_ctrl1_app_canctrl_err_warning_limit_limit_Msk (0xffUL)  /*!< can_ctrl1_app canctrl_err_warning_limit: limit (Bitfield-Mask: 0xff) */
/* =================================================  canctrl_rx_error_cnt  ================================================== */
#define can_ctrl1_app_canctrl_rx_error_cnt_rx_err_Pos (0UL)         /*!< can_ctrl1_app canctrl_rx_error_cnt: rx_err (Bit 0)    */
#define can_ctrl1_app_canctrl_rx_error_cnt_rx_err_Msk (0xffUL)      /*!< can_ctrl1_app canctrl_rx_error_cnt: rx_err (Bitfield-Mask: 0xff) */
/* =================================================  canctrl_tx_error_cnt  ================================================== */
#define can_ctrl1_app_canctrl_tx_error_cnt_tx_err_Pos (0UL)         /*!< can_ctrl1_app canctrl_tx_error_cnt: tx_err (Bit 0)    */
#define can_ctrl1_app_canctrl_tx_error_cnt_tx_err_Msk (0xffUL)      /*!< can_ctrl1_app canctrl_tx_error_cnt: tx_err (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data0  ===================================================== */
#define can_ctrl1_app_canctrl_data0_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data0: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data0_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data0: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data1  ===================================================== */
#define can_ctrl1_app_canctrl_data1_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data1: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data1_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data1: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data2  ===================================================== */
#define can_ctrl1_app_canctrl_data2_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data2: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data2_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data2: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data3  ===================================================== */
#define can_ctrl1_app_canctrl_data3_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data3: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data3_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data3: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data4  ===================================================== */
#define can_ctrl1_app_canctrl_data4_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data4: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data4_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data4: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data5  ===================================================== */
#define can_ctrl1_app_canctrl_data5_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data5: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data5_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data5: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data6  ===================================================== */
#define can_ctrl1_app_canctrl_data6_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data6: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data6_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data6: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data7  ===================================================== */
#define can_ctrl1_app_canctrl_data7_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data7: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data7_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data7: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data8  ===================================================== */
#define can_ctrl1_app_canctrl_data8_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data8: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data8_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data8: data (Bitfield-Mask: 0xff) */
/* =====================================================  canctrl_data9  ===================================================== */
#define can_ctrl1_app_canctrl_data9_data_Pos (0UL)                  /*!< can_ctrl1_app canctrl_data9: data (Bit 0)             */
#define can_ctrl1_app_canctrl_data9_data_Msk (0xffUL)               /*!< can_ctrl1_app canctrl_data9: data (Bitfield-Mask: 0xff) */
/* ====================================================  canctrl_data10  ===================================================== */
#define can_ctrl1_app_canctrl_data10_data_Pos (0UL)                 /*!< can_ctrl1_app canctrl_data10: data (Bit 0)            */
#define can_ctrl1_app_canctrl_data10_data_Msk (0xffUL)              /*!< can_ctrl1_app canctrl_data10: data (Bitfield-Mask: 0xff) */
/* ====================================================  canctrl_data11  ===================================================== */
#define can_ctrl1_app_canctrl_data11_data_Pos (0UL)                 /*!< can_ctrl1_app canctrl_data11: data (Bit 0)            */
#define can_ctrl1_app_canctrl_data11_data_Msk (0xffUL)              /*!< can_ctrl1_app canctrl_data11: data (Bitfield-Mask: 0xff) */
/* ====================================================  canctrl_data12  ===================================================== */
#define can_ctrl1_app_canctrl_data12_data_Pos (0UL)                 /*!< can_ctrl1_app canctrl_data12: data (Bit 0)            */
#define can_ctrl1_app_canctrl_data12_data_Msk (0xffUL)              /*!< can_ctrl1_app canctrl_data12: data (Bitfield-Mask: 0xff) */
/* ================================================  canctrl_rx_message_cnt  ================================================= */
#define can_ctrl1_app_canctrl_rx_message_cnt_rx_msg_cnt_Pos (0UL)   /*!< can_ctrl1_app canctrl_rx_message_cnt: rx_msg_cnt (Bit 0) */
#define can_ctrl1_app_canctrl_rx_message_cnt_rx_msg_cnt_Msk (0x7fUL) /*!< can_ctrl1_app canctrl_rx_message_cnt: rx_msg_cnt (Bitfield-Mask: 0x7f) */
/* =================================================  canctrl_mode_control  ================================================== */
#define can_ctrl1_app_canctrl_mode_control_reserved1_Pos (8UL)      /*!< can_ctrl1_app canctrl_mode_control: reserved1 (Bit 8) */
#define can_ctrl1_app_canctrl_mode_control_reserved1_Msk (0xffffff00UL) /*!< can_ctrl1_app canctrl_mode_control: reserved1 (Bitfield-Mask: 0xffffff) */
#define can_ctrl1_app_canctrl_mode_control_mode_Pos (7UL)           /*!< can_ctrl1_app canctrl_mode_control: mode (Bit 7)      */
#define can_ctrl1_app_canctrl_mode_control_mode_Msk (0x80UL)        /*!< can_ctrl1_app canctrl_mode_control: mode (Bitfield-Mask: 0x01) */
#define can_ctrl1_app_canctrl_mode_control_reserved0_Pos (0UL)      /*!< can_ctrl1_app canctrl_mode_control: reserved0 (Bit 0) */
#define can_ctrl1_app_canctrl_mode_control_reserved0_Msk (0x7fUL)   /*!< can_ctrl1_app canctrl_mode_control: reserved0 (Bitfield-Mask: 0x7f) */


/* =========================================================================================================================== */
/* ================                                         spi0_app                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  spi_cr0  ======================================================== */
#define spi0_app_spi_cr0_netx100_comp_Pos (31UL)                    /*!< spi0_app spi_cr0: netx100_comp (Bit 31)               */
#define spi0_app_spi_cr0_netx100_comp_Msk (0x80000000UL)            /*!< spi0_app spi_cr0: netx100_comp (Bitfield-Mask: 0x01)  */
#define spi0_app_spi_cr0_reserved3_Pos    (29UL)                    /*!< spi0_app spi_cr0: reserved3 (Bit 29)                  */
#define spi0_app_spi_cr0_reserved3_Msk    (0x60000000UL)            /*!< spi0_app spi_cr0: reserved3 (Bitfield-Mask: 0x03)     */
#define spi0_app_spi_cr0_slave_sig_early_Pos (28UL)                 /*!< spi0_app spi_cr0: slave_sig_early (Bit 28)            */
#define spi0_app_spi_cr0_slave_sig_early_Msk (0x10000000UL)         /*!< spi0_app spi_cr0: slave_sig_early (Bitfield-Mask: 0x01) */
#define spi0_app_spi_cr0_filter_in_Pos    (27UL)                    /*!< spi0_app spi_cr0: filter_in (Bit 27)                  */
#define spi0_app_spi_cr0_filter_in_Msk    (0x8000000UL)             /*!< spi0_app spi_cr0: filter_in (Bitfield-Mask: 0x01)     */
#define spi0_app_spi_cr0_reserved2_Pos    (26UL)                    /*!< spi0_app spi_cr0: reserved2 (Bit 26)                  */
#define spi0_app_spi_cr0_reserved2_Msk    (0x4000000UL)             /*!< spi0_app spi_cr0: reserved2 (Bitfield-Mask: 0x01)     */
#define spi0_app_spi_cr0_format_Pos       (24UL)                    /*!< spi0_app spi_cr0: format (Bit 24)                     */
#define spi0_app_spi_cr0_format_Msk       (0x3000000UL)             /*!< spi0_app spi_cr0: format (Bitfield-Mask: 0x03)        */
#define spi0_app_spi_cr0_reserved1_Pos    (20UL)                    /*!< spi0_app spi_cr0: reserved1 (Bit 20)                  */
#define spi0_app_spi_cr0_reserved1_Msk    (0xf00000UL)              /*!< spi0_app spi_cr0: reserved1 (Bitfield-Mask: 0x0f)     */
#define spi0_app_spi_cr0_sck_muladd_Pos   (8UL)                     /*!< spi0_app spi_cr0: sck_muladd (Bit 8)                  */
#define spi0_app_spi_cr0_sck_muladd_Msk   (0xfff00UL)               /*!< spi0_app spi_cr0: sck_muladd (Bitfield-Mask: 0xfff)   */
#define spi0_app_spi_cr0_SPH_Pos          (7UL)                     /*!< spi0_app spi_cr0: SPH (Bit 7)                         */
#define spi0_app_spi_cr0_SPH_Msk          (0x80UL)                  /*!< spi0_app spi_cr0: SPH (Bitfield-Mask: 0x01)           */
#define spi0_app_spi_cr0_SPO_Pos          (6UL)                     /*!< spi0_app spi_cr0: SPO (Bit 6)                         */
#define spi0_app_spi_cr0_SPO_Msk          (0x40UL)                  /*!< spi0_app spi_cr0: SPO (Bitfield-Mask: 0x01)           */
#define spi0_app_spi_cr0_reserved0_Pos    (4UL)                     /*!< spi0_app spi_cr0: reserved0 (Bit 4)                   */
#define spi0_app_spi_cr0_reserved0_Msk    (0x30UL)                  /*!< spi0_app spi_cr0: reserved0 (Bitfield-Mask: 0x03)     */
#define spi0_app_spi_cr0_datasize_Pos     (0UL)                     /*!< spi0_app spi_cr0: datasize (Bit 0)                    */
#define spi0_app_spi_cr0_datasize_Msk     (0xfUL)                   /*!< spi0_app spi_cr0: datasize (Bitfield-Mask: 0x0f)      */
/* ========================================================  spi_cr1  ======================================================== */
#define spi0_app_spi_cr1_reserved3_Pos    (29UL)                    /*!< spi0_app spi_cr1: reserved3 (Bit 29)                  */
#define spi0_app_spi_cr1_reserved3_Msk    (0xe0000000UL)            /*!< spi0_app spi_cr1: reserved3 (Bitfield-Mask: 0x07)     */
#define spi0_app_spi_cr1_rx_fifo_clr_Pos  (28UL)                    /*!< spi0_app spi_cr1: rx_fifo_clr (Bit 28)                */
#define spi0_app_spi_cr1_rx_fifo_clr_Msk  (0x10000000UL)            /*!< spi0_app spi_cr1: rx_fifo_clr (Bitfield-Mask: 0x01)   */
#define spi0_app_spi_cr1_rx_fifo_wm_Pos   (24UL)                    /*!< spi0_app spi_cr1: rx_fifo_wm (Bit 24)                 */
#define spi0_app_spi_cr1_rx_fifo_wm_Msk   (0xf000000UL)             /*!< spi0_app spi_cr1: rx_fifo_wm (Bitfield-Mask: 0x0f)    */
#define spi0_app_spi_cr1_reserved2_Pos    (21UL)                    /*!< spi0_app spi_cr1: reserved2 (Bit 21)                  */
#define spi0_app_spi_cr1_reserved2_Msk    (0xe00000UL)              /*!< spi0_app spi_cr1: reserved2 (Bitfield-Mask: 0x07)     */
#define spi0_app_spi_cr1_tx_fifo_clr_Pos  (20UL)                    /*!< spi0_app spi_cr1: tx_fifo_clr (Bit 20)                */
#define spi0_app_spi_cr1_tx_fifo_clr_Msk  (0x100000UL)              /*!< spi0_app spi_cr1: tx_fifo_clr (Bitfield-Mask: 0x01)   */
#define spi0_app_spi_cr1_tx_fifo_wm_Pos   (16UL)                    /*!< spi0_app spi_cr1: tx_fifo_wm (Bit 16)                 */
#define spi0_app_spi_cr1_tx_fifo_wm_Msk   (0xf0000UL)               /*!< spi0_app spi_cr1: tx_fifo_wm (Bitfield-Mask: 0x0f)    */
#define spi0_app_spi_cr1_reserved1_Pos    (12UL)                    /*!< spi0_app spi_cr1: reserved1 (Bit 12)                  */
#define spi0_app_spi_cr1_reserved1_Msk    (0xf000UL)                /*!< spi0_app spi_cr1: reserved1 (Bitfield-Mask: 0x0f)     */
#define spi0_app_spi_cr1_fss_static_Pos   (11UL)                    /*!< spi0_app spi_cr1: fss_static (Bit 11)                 */
#define spi0_app_spi_cr1_fss_static_Msk   (0x800UL)                 /*!< spi0_app spi_cr1: fss_static (Bitfield-Mask: 0x01)    */
#define spi0_app_spi_cr1_fss_Pos          (8UL)                     /*!< spi0_app spi_cr1: fss (Bit 8)                         */
#define spi0_app_spi_cr1_fss_Msk          (0x700UL)                 /*!< spi0_app spi_cr1: fss (Bitfield-Mask: 0x07)           */
#define spi0_app_spi_cr1_reserved0_Pos    (4UL)                     /*!< spi0_app spi_cr1: reserved0 (Bit 4)                   */
#define spi0_app_spi_cr1_reserved0_Msk    (0xf0UL)                  /*!< spi0_app spi_cr1: reserved0 (Bitfield-Mask: 0x0f)     */
#define spi0_app_spi_cr1_SOD_Pos          (3UL)                     /*!< spi0_app spi_cr1: SOD (Bit 3)                         */
#define spi0_app_spi_cr1_SOD_Msk          (0x8UL)                   /*!< spi0_app spi_cr1: SOD (Bitfield-Mask: 0x01)           */
#define spi0_app_spi_cr1_MS_Pos           (2UL)                     /*!< spi0_app spi_cr1: MS (Bit 2)                          */
#define spi0_app_spi_cr1_MS_Msk           (0x4UL)                   /*!< spi0_app spi_cr1: MS (Bitfield-Mask: 0x01)            */
#define spi0_app_spi_cr1_SSE_Pos          (1UL)                     /*!< spi0_app spi_cr1: SSE (Bit 1)                         */
#define spi0_app_spi_cr1_SSE_Msk          (0x2UL)                   /*!< spi0_app spi_cr1: SSE (Bitfield-Mask: 0x01)           */
#define spi0_app_spi_cr1_LBM_Pos          (0UL)                     /*!< spi0_app spi_cr1: LBM (Bit 0)                         */
#define spi0_app_spi_cr1_LBM_Msk          (0x1UL)                   /*!< spi0_app spi_cr1: LBM (Bitfield-Mask: 0x01)           */
/* ========================================================  spi_dr  ========================================================= */
#define spi0_app_spi_dr_data_Pos          (0UL)                     /*!< spi0_app spi_dr: data (Bit 0)                         */
#define spi0_app_spi_dr_data_Msk          (0x1ffffUL)               /*!< spi0_app spi_dr: data (Bitfield-Mask: 0x1ffff)        */
/* ========================================================  spi_sr  ========================================================= */
#define spi0_app_spi_sr_rx_fifo_err_undr_Pos (31UL)                 /*!< spi0_app spi_sr: rx_fifo_err_undr (Bit 31)            */
#define spi0_app_spi_sr_rx_fifo_err_undr_Msk (0x80000000UL)         /*!< spi0_app spi_sr: rx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi0_app_spi_sr_rx_fifo_err_ovfl_Pos (30UL)                 /*!< spi0_app spi_sr: rx_fifo_err_ovfl (Bit 30)            */
#define spi0_app_spi_sr_rx_fifo_err_ovfl_Msk (0x40000000UL)         /*!< spi0_app spi_sr: rx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi0_app_spi_sr_reserved2_Pos     (29UL)                    /*!< spi0_app spi_sr: reserved2 (Bit 29)                   */
#define spi0_app_spi_sr_reserved2_Msk     (0x20000000UL)            /*!< spi0_app spi_sr: reserved2 (Bitfield-Mask: 0x01)      */
#define spi0_app_spi_sr_rx_fifo_level_Pos (24UL)                    /*!< spi0_app spi_sr: rx_fifo_level (Bit 24)               */
#define spi0_app_spi_sr_rx_fifo_level_Msk (0x1f000000UL)            /*!< spi0_app spi_sr: rx_fifo_level (Bitfield-Mask: 0x1f)  */
#define spi0_app_spi_sr_tx_fifo_err_undr_Pos (23UL)                 /*!< spi0_app spi_sr: tx_fifo_err_undr (Bit 23)            */
#define spi0_app_spi_sr_tx_fifo_err_undr_Msk (0x800000UL)           /*!< spi0_app spi_sr: tx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi0_app_spi_sr_tx_fifo_err_ovfl_Pos (22UL)                 /*!< spi0_app spi_sr: tx_fifo_err_ovfl (Bit 22)            */
#define spi0_app_spi_sr_tx_fifo_err_ovfl_Msk (0x400000UL)           /*!< spi0_app spi_sr: tx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi0_app_spi_sr_reserved1_Pos     (21UL)                    /*!< spi0_app spi_sr: reserved1 (Bit 21)                   */
#define spi0_app_spi_sr_reserved1_Msk     (0x200000UL)              /*!< spi0_app spi_sr: reserved1 (Bitfield-Mask: 0x01)      */
#define spi0_app_spi_sr_tx_fifo_level_Pos (16UL)                    /*!< spi0_app spi_sr: tx_fifo_level (Bit 16)               */
#define spi0_app_spi_sr_tx_fifo_level_Msk (0x1f0000UL)              /*!< spi0_app spi_sr: tx_fifo_level (Bitfield-Mask: 0x1f)  */
#define spi0_app_spi_sr_reserved0_Pos     (5UL)                     /*!< spi0_app spi_sr: reserved0 (Bit 5)                    */
#define spi0_app_spi_sr_reserved0_Msk     (0xffe0UL)                /*!< spi0_app spi_sr: reserved0 (Bitfield-Mask: 0x7ff)     */
#define spi0_app_spi_sr_BSY_Pos           (4UL)                     /*!< spi0_app spi_sr: BSY (Bit 4)                          */
#define spi0_app_spi_sr_BSY_Msk           (0x10UL)                  /*!< spi0_app spi_sr: BSY (Bitfield-Mask: 0x01)            */
#define spi0_app_spi_sr_RFF_Pos           (3UL)                     /*!< spi0_app spi_sr: RFF (Bit 3)                          */
#define spi0_app_spi_sr_RFF_Msk           (0x8UL)                   /*!< spi0_app spi_sr: RFF (Bitfield-Mask: 0x01)            */
#define spi0_app_spi_sr_RNE_Pos           (2UL)                     /*!< spi0_app spi_sr: RNE (Bit 2)                          */
#define spi0_app_spi_sr_RNE_Msk           (0x4UL)                   /*!< spi0_app spi_sr: RNE (Bitfield-Mask: 0x01)            */
#define spi0_app_spi_sr_TNF_Pos           (1UL)                     /*!< spi0_app spi_sr: TNF (Bit 1)                          */
#define spi0_app_spi_sr_TNF_Msk           (0x2UL)                   /*!< spi0_app spi_sr: TNF (Bitfield-Mask: 0x01)            */
#define spi0_app_spi_sr_TFE_Pos           (0UL)                     /*!< spi0_app spi_sr: TFE (Bit 0)                          */
#define spi0_app_spi_sr_TFE_Msk           (0x1UL)                   /*!< spi0_app spi_sr: TFE (Bitfield-Mask: 0x01)            */
/* =======================================================  spi_imsc  ======================================================== */
#define spi0_app_spi_imsc_txeim_Pos       (6UL)                     /*!< spi0_app spi_imsc: txeim (Bit 6)                      */
#define spi0_app_spi_imsc_txeim_Msk       (0x40UL)                  /*!< spi0_app spi_imsc: txeim (Bitfield-Mask: 0x01)        */
#define spi0_app_spi_imsc_rxfim_Pos       (5UL)                     /*!< spi0_app spi_imsc: rxfim (Bit 5)                      */
#define spi0_app_spi_imsc_rxfim_Msk       (0x20UL)                  /*!< spi0_app spi_imsc: rxfim (Bitfield-Mask: 0x01)        */
#define spi0_app_spi_imsc_rxneim_Pos      (4UL)                     /*!< spi0_app spi_imsc: rxneim (Bit 4)                     */
#define spi0_app_spi_imsc_rxneim_Msk      (0x10UL)                  /*!< spi0_app spi_imsc: rxneim (Bitfield-Mask: 0x01)       */
#define spi0_app_spi_imsc_TXIM_Pos        (3UL)                     /*!< spi0_app spi_imsc: TXIM (Bit 3)                       */
#define spi0_app_spi_imsc_TXIM_Msk        (0x8UL)                   /*!< spi0_app spi_imsc: TXIM (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_imsc_RXIM_Pos        (2UL)                     /*!< spi0_app spi_imsc: RXIM (Bit 2)                       */
#define spi0_app_spi_imsc_RXIM_Msk        (0x4UL)                   /*!< spi0_app spi_imsc: RXIM (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_imsc_RTIM_Pos        (1UL)                     /*!< spi0_app spi_imsc: RTIM (Bit 1)                       */
#define spi0_app_spi_imsc_RTIM_Msk        (0x2UL)                   /*!< spi0_app spi_imsc: RTIM (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_imsc_RORIM_Pos       (0UL)                     /*!< spi0_app spi_imsc: RORIM (Bit 0)                      */
#define spi0_app_spi_imsc_RORIM_Msk       (0x1UL)                   /*!< spi0_app spi_imsc: RORIM (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_ris  ======================================================== */
#define spi0_app_spi_ris_txeris_Pos       (6UL)                     /*!< spi0_app spi_ris: txeris (Bit 6)                      */
#define spi0_app_spi_ris_txeris_Msk       (0x40UL)                  /*!< spi0_app spi_ris: txeris (Bitfield-Mask: 0x01)        */
#define spi0_app_spi_ris_rxfris_Pos       (5UL)                     /*!< spi0_app spi_ris: rxfris (Bit 5)                      */
#define spi0_app_spi_ris_rxfris_Msk       (0x20UL)                  /*!< spi0_app spi_ris: rxfris (Bitfield-Mask: 0x01)        */
#define spi0_app_spi_ris_rxneris_Pos      (4UL)                     /*!< spi0_app spi_ris: rxneris (Bit 4)                     */
#define spi0_app_spi_ris_rxneris_Msk      (0x10UL)                  /*!< spi0_app spi_ris: rxneris (Bitfield-Mask: 0x01)       */
#define spi0_app_spi_ris_TXRIS_Pos        (3UL)                     /*!< spi0_app spi_ris: TXRIS (Bit 3)                       */
#define spi0_app_spi_ris_TXRIS_Msk        (0x8UL)                   /*!< spi0_app spi_ris: TXRIS (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_ris_RXRIS_Pos        (2UL)                     /*!< spi0_app spi_ris: RXRIS (Bit 2)                       */
#define spi0_app_spi_ris_RXRIS_Msk        (0x4UL)                   /*!< spi0_app spi_ris: RXRIS (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_ris_RTRIS_Pos        (1UL)                     /*!< spi0_app spi_ris: RTRIS (Bit 1)                       */
#define spi0_app_spi_ris_RTRIS_Msk        (0x2UL)                   /*!< spi0_app spi_ris: RTRIS (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_ris_RORRIS_Pos       (0UL)                     /*!< spi0_app spi_ris: RORRIS (Bit 0)                      */
#define spi0_app_spi_ris_RORRIS_Msk       (0x1UL)                   /*!< spi0_app spi_ris: RORRIS (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_mis  ======================================================== */
#define spi0_app_spi_mis_txemis_Pos       (6UL)                     /*!< spi0_app spi_mis: txemis (Bit 6)                      */
#define spi0_app_spi_mis_txemis_Msk       (0x40UL)                  /*!< spi0_app spi_mis: txemis (Bitfield-Mask: 0x01)        */
#define spi0_app_spi_mis_rxfmis_Pos       (5UL)                     /*!< spi0_app spi_mis: rxfmis (Bit 5)                      */
#define spi0_app_spi_mis_rxfmis_Msk       (0x20UL)                  /*!< spi0_app spi_mis: rxfmis (Bitfield-Mask: 0x01)        */
#define spi0_app_spi_mis_rxnemis_Pos      (4UL)                     /*!< spi0_app spi_mis: rxnemis (Bit 4)                     */
#define spi0_app_spi_mis_rxnemis_Msk      (0x10UL)                  /*!< spi0_app spi_mis: rxnemis (Bitfield-Mask: 0x01)       */
#define spi0_app_spi_mis_TXMIS_Pos        (3UL)                     /*!< spi0_app spi_mis: TXMIS (Bit 3)                       */
#define spi0_app_spi_mis_TXMIS_Msk        (0x8UL)                   /*!< spi0_app spi_mis: TXMIS (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_mis_RXMIS_Pos        (2UL)                     /*!< spi0_app spi_mis: RXMIS (Bit 2)                       */
#define spi0_app_spi_mis_RXMIS_Msk        (0x4UL)                   /*!< spi0_app spi_mis: RXMIS (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_mis_RTMIS_Pos        (1UL)                     /*!< spi0_app spi_mis: RTMIS (Bit 1)                       */
#define spi0_app_spi_mis_RTMIS_Msk        (0x2UL)                   /*!< spi0_app spi_mis: RTMIS (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_mis_RORMIS_Pos       (0UL)                     /*!< spi0_app spi_mis: RORMIS (Bit 0)                      */
#define spi0_app_spi_mis_RORMIS_Msk       (0x1UL)                   /*!< spi0_app spi_mis: RORMIS (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_icr  ======================================================== */
#define spi0_app_spi_icr_txeic_Pos        (6UL)                     /*!< spi0_app spi_icr: txeic (Bit 6)                       */
#define spi0_app_spi_icr_txeic_Msk        (0x40UL)                  /*!< spi0_app spi_icr: txeic (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_icr_rxfic_Pos        (5UL)                     /*!< spi0_app spi_icr: rxfic (Bit 5)                       */
#define spi0_app_spi_icr_rxfic_Msk        (0x20UL)                  /*!< spi0_app spi_icr: rxfic (Bitfield-Mask: 0x01)         */
#define spi0_app_spi_icr_rxneic_Pos       (4UL)                     /*!< spi0_app spi_icr: rxneic (Bit 4)                      */
#define spi0_app_spi_icr_rxneic_Msk       (0x10UL)                  /*!< spi0_app spi_icr: rxneic (Bitfield-Mask: 0x01)        */
#define spi0_app_spi_icr_TXIC_Pos         (3UL)                     /*!< spi0_app spi_icr: TXIC (Bit 3)                        */
#define spi0_app_spi_icr_TXIC_Msk         (0x8UL)                   /*!< spi0_app spi_icr: TXIC (Bitfield-Mask: 0x01)          */
#define spi0_app_spi_icr_RXIC_Pos         (2UL)                     /*!< spi0_app spi_icr: RXIC (Bit 2)                        */
#define spi0_app_spi_icr_RXIC_Msk         (0x4UL)                   /*!< spi0_app spi_icr: RXIC (Bitfield-Mask: 0x01)          */
#define spi0_app_spi_icr_RTIC_Pos         (1UL)                     /*!< spi0_app spi_icr: RTIC (Bit 1)                        */
#define spi0_app_spi_icr_RTIC_Msk         (0x2UL)                   /*!< spi0_app spi_icr: RTIC (Bitfield-Mask: 0x01)          */
#define spi0_app_spi_icr_RORIC_Pos        (0UL)                     /*!< spi0_app spi_icr: RORIC (Bit 0)                       */
#define spi0_app_spi_icr_RORIC_Msk        (0x1UL)                   /*!< spi0_app spi_icr: RORIC (Bitfield-Mask: 0x01)         */
/* =======================================================  spi_dmacr  ======================================================= */
#define spi0_app_spi_dmacr_TXDMAE_Pos     (1UL)                     /*!< spi0_app spi_dmacr: TXDMAE (Bit 1)                    */
#define spi0_app_spi_dmacr_TXDMAE_Msk     (0x2UL)                   /*!< spi0_app spi_dmacr: TXDMAE (Bitfield-Mask: 0x01)      */
#define spi0_app_spi_dmacr_RXDMAE_Pos     (0UL)                     /*!< spi0_app spi_dmacr: RXDMAE (Bit 0)                    */
#define spi0_app_spi_dmacr_RXDMAE_Msk     (0x1UL)                   /*!< spi0_app spi_dmacr: RXDMAE (Bitfield-Mask: 0x01)      */
/* ===================================================  spi_data_register  =================================================== */
#define spi0_app_spi_data_register_dr_valid1_Pos (17UL)             /*!< spi0_app spi_data_register: dr_valid1 (Bit 17)        */
#define spi0_app_spi_data_register_dr_valid1_Msk (0x20000UL)        /*!< spi0_app spi_data_register: dr_valid1 (Bitfield-Mask: 0x01) */
#define spi0_app_spi_data_register_dr_valid0_Pos (16UL)             /*!< spi0_app spi_data_register: dr_valid0 (Bit 16)        */
#define spi0_app_spi_data_register_dr_valid0_Msk (0x10000UL)        /*!< spi0_app spi_data_register: dr_valid0 (Bitfield-Mask: 0x01) */
#define spi0_app_spi_data_register_data_byte_1_Pos (8UL)            /*!< spi0_app spi_data_register: data_byte_1 (Bit 8)       */
#define spi0_app_spi_data_register_data_byte_1_Msk (0xff00UL)       /*!< spi0_app spi_data_register: data_byte_1 (Bitfield-Mask: 0xff) */
#define spi0_app_spi_data_register_data_byte_0_Pos (0UL)            /*!< spi0_app spi_data_register: data_byte_0 (Bit 0)       */
#define spi0_app_spi_data_register_data_byte_0_Msk (0xffUL)         /*!< spi0_app spi_data_register: data_byte_0 (Bitfield-Mask: 0xff) */
/* ==================================================  spi_status_register  ================================================== */
#define spi0_app_spi_status_register_SR_selected_Pos (25UL)         /*!< spi0_app spi_status_register: SR_selected (Bit 25)    */
#define spi0_app_spi_status_register_SR_selected_Msk (0x2000000UL)  /*!< spi0_app spi_status_register: SR_selected (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_out_full_Pos (24UL)         /*!< spi0_app spi_status_register: SR_out_full (Bit 24)    */
#define spi0_app_spi_status_register_SR_out_full_Msk (0x1000000UL)  /*!< spi0_app spi_status_register: SR_out_full (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_out_empty_Pos (23UL)        /*!< spi0_app spi_status_register: SR_out_empty (Bit 23)   */
#define spi0_app_spi_status_register_SR_out_empty_Msk (0x800000UL)  /*!< spi0_app spi_status_register: SR_out_empty (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_out_fw_Pos (22UL)           /*!< spi0_app spi_status_register: SR_out_fw (Bit 22)      */
#define spi0_app_spi_status_register_SR_out_fw_Msk (0x400000UL)     /*!< spi0_app spi_status_register: SR_out_fw (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_out_fuel_Pos (21UL)         /*!< spi0_app spi_status_register: SR_out_fuel (Bit 21)    */
#define spi0_app_spi_status_register_SR_out_fuel_Msk (0x200000UL)   /*!< spi0_app spi_status_register: SR_out_fuel (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_in_full_Pos (20UL)          /*!< spi0_app spi_status_register: SR_in_full (Bit 20)     */
#define spi0_app_spi_status_register_SR_in_full_Msk (0x100000UL)    /*!< spi0_app spi_status_register: SR_in_full (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_in_recdata_Pos (19UL)       /*!< spi0_app spi_status_register: SR_in_recdata (Bit 19)  */
#define spi0_app_spi_status_register_SR_in_recdata_Msk (0x80000UL)  /*!< spi0_app spi_status_register: SR_in_recdata (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_in_fuel_Pos (18UL)          /*!< spi0_app spi_status_register: SR_in_fuel (Bit 18)     */
#define spi0_app_spi_status_register_SR_in_fuel_Msk (0x40000UL)     /*!< spi0_app spi_status_register: SR_in_fuel (Bitfield-Mask: 0x01) */
#define spi0_app_spi_status_register_SR_out_fuel_val_Pos (9UL)      /*!< spi0_app spi_status_register: SR_out_fuel_val (Bit 9) */
#define spi0_app_spi_status_register_SR_out_fuel_val_Msk (0x3fe00UL) /*!< spi0_app spi_status_register: SR_out_fuel_val (Bitfield-Mask: 0x1ff) */
#define spi0_app_spi_status_register_SR_in_fuel_val_Pos (0UL)       /*!< spi0_app spi_status_register: SR_in_fuel_val (Bit 0)  */
#define spi0_app_spi_status_register_SR_in_fuel_val_Msk (0x1ffUL)   /*!< spi0_app spi_status_register: SR_in_fuel_val (Bitfield-Mask: 0x1ff) */
/* =================================================  spi_control_register  ================================================== */
#define spi0_app_spi_control_register_CR_en_Pos (31UL)              /*!< spi0_app spi_control_register: CR_en (Bit 31)         */
#define spi0_app_spi_control_register_CR_en_Msk (0x80000000UL)      /*!< spi0_app spi_control_register: CR_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_ms_Pos (30UL)              /*!< spi0_app spi_control_register: CR_ms (Bit 30)         */
#define spi0_app_spi_control_register_CR_ms_Msk (0x40000000UL)      /*!< spi0_app spi_control_register: CR_ms (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_cpol_Pos (29UL)            /*!< spi0_app spi_control_register: CR_cpol (Bit 29)       */
#define spi0_app_spi_control_register_CR_cpol_Msk (0x20000000UL)    /*!< spi0_app spi_control_register: CR_cpol (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_ncpha_Pos (28UL)           /*!< spi0_app spi_control_register: CR_ncpha (Bit 28)      */
#define spi0_app_spi_control_register_CR_ncpha_Msk (0x10000000UL)   /*!< spi0_app spi_control_register: CR_ncpha (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_burst_Pos (25UL)           /*!< spi0_app spi_control_register: CR_burst (Bit 25)      */
#define spi0_app_spi_control_register_CR_burst_Msk (0xe000000UL)    /*!< spi0_app spi_control_register: CR_burst (Bitfield-Mask: 0x07) */
#define spi0_app_spi_control_register_CR_burstdelay_Pos (22UL)      /*!< spi0_app spi_control_register: CR_burstdelay (Bit 22) */
#define spi0_app_spi_control_register_CR_burstdelay_Msk (0x1c00000UL) /*!< spi0_app spi_control_register: CR_burstdelay (Bitfield-Mask: 0x07) */
#define spi0_app_spi_control_register_CR_clr_outfifo_Pos (21UL)     /*!< spi0_app spi_control_register: CR_clr_outfifo (Bit 21) */
#define spi0_app_spi_control_register_CR_clr_outfifo_Msk (0x200000UL) /*!< spi0_app spi_control_register: CR_clr_outfifo (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_clr_infifo_Pos (20UL)      /*!< spi0_app spi_control_register: CR_clr_infifo (Bit 20) */
#define spi0_app_spi_control_register_CR_clr_infifo_Msk (0x100000UL) /*!< spi0_app spi_control_register: CR_clr_infifo (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_reserved1_Pos (12UL)          /*!< spi0_app spi_control_register: reserved1 (Bit 12)     */
#define spi0_app_spi_control_register_reserved1_Msk (0xff000UL)     /*!< spi0_app spi_control_register: reserved1 (Bitfield-Mask: 0xff) */
#define spi0_app_spi_control_register_CS_mode_Pos (11UL)            /*!< spi0_app spi_control_register: CS_mode (Bit 11)       */
#define spi0_app_spi_control_register_CS_mode_Msk (0x800UL)         /*!< spi0_app spi_control_register: CS_mode (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_ss_Pos (8UL)               /*!< spi0_app spi_control_register: CR_ss (Bit 8)          */
#define spi0_app_spi_control_register_CR_ss_Msk (0x700UL)           /*!< spi0_app spi_control_register: CR_ss (Bitfield-Mask: 0x07) */
#define spi0_app_spi_control_register_CR_write_Pos (7UL)            /*!< spi0_app spi_control_register: CR_write (Bit 7)       */
#define spi0_app_spi_control_register_CR_write_Msk (0x80UL)         /*!< spi0_app spi_control_register: CR_write (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_read_Pos (6UL)             /*!< spi0_app spi_control_register: CR_read (Bit 6)        */
#define spi0_app_spi_control_register_CR_read_Msk (0x40UL)          /*!< spi0_app spi_control_register: CR_read (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_reserved0_Pos (5UL)           /*!< spi0_app spi_control_register: reserved0 (Bit 5)      */
#define spi0_app_spi_control_register_reserved0_Msk (0x20UL)        /*!< spi0_app spi_control_register: reserved0 (Bitfield-Mask: 0x01) */
#define spi0_app_spi_control_register_CR_speed_Pos (1UL)            /*!< spi0_app spi_control_register: CR_speed (Bit 1)       */
#define spi0_app_spi_control_register_CR_speed_Msk (0x1eUL)         /*!< spi0_app spi_control_register: CR_speed (Bitfield-Mask: 0x0f) */
#define spi0_app_spi_control_register_CR_softreset_Pos (0UL)        /*!< spi0_app spi_control_register: CR_softreset (Bit 0)   */
#define spi0_app_spi_control_register_CR_softreset_Msk (0x1UL)      /*!< spi0_app spi_control_register: CR_softreset (Bitfield-Mask: 0x01) */
/* ============================================  spi_interrupt_control_register  ============================================= */
#define spi0_app_spi_interrupt_control_register_IR_out_full_en_Pos (24UL) /*!< spi0_app spi_interrupt_control_register: IR_out_full_en (Bit 24) */
#define spi0_app_spi_interrupt_control_register_IR_out_full_en_Msk (0x1000000UL) /*!< spi0_app spi_interrupt_control_register: IR_out_full_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_interrupt_control_register_IR_out_empty_en_Pos (23UL) /*!< spi0_app spi_interrupt_control_register: IR_out_empty_en (Bit 23) */
#define spi0_app_spi_interrupt_control_register_IR_out_empty_en_Msk (0x800000UL) /*!< spi0_app spi_interrupt_control_register: IR_out_empty_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_interrupt_control_register_IR_out_fw_en_Pos (22UL) /*!< spi0_app spi_interrupt_control_register: IR_out_fw_en (Bit 22) */
#define spi0_app_spi_interrupt_control_register_IR_out_fw_en_Msk (0x400000UL) /*!< spi0_app spi_interrupt_control_register: IR_out_fw_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_interrupt_control_register_IR_out_fuel_en_Pos (21UL) /*!< spi0_app spi_interrupt_control_register: IR_out_fuel_en (Bit 21) */
#define spi0_app_spi_interrupt_control_register_IR_out_fuel_en_Msk (0x200000UL) /*!< spi0_app spi_interrupt_control_register: IR_out_fuel_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_interrupt_control_register_IR_in_full_en_Pos (20UL) /*!< spi0_app spi_interrupt_control_register: IR_in_full_en (Bit 20) */
#define spi0_app_spi_interrupt_control_register_IR_in_full_en_Msk (0x100000UL) /*!< spi0_app spi_interrupt_control_register: IR_in_full_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_interrupt_control_register_IR_in_recdata_en_Pos (19UL) /*!< spi0_app spi_interrupt_control_register: IR_in_recdata_en (Bit 19) */
#define spi0_app_spi_interrupt_control_register_IR_in_recdata_en_Msk (0x80000UL) /*!< spi0_app spi_interrupt_control_register: IR_in_recdata_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_interrupt_control_register_IR_in_fuel_en_Pos (18UL) /*!< spi0_app spi_interrupt_control_register: IR_in_fuel_en (Bit 18) */
#define spi0_app_spi_interrupt_control_register_IR_in_fuel_en_Msk (0x40000UL) /*!< spi0_app spi_interrupt_control_register: IR_in_fuel_en (Bitfield-Mask: 0x01) */
#define spi0_app_spi_interrupt_control_register_IR_out_fuel_Pos (9UL) /*!< spi0_app spi_interrupt_control_register: IR_out_fuel (Bit 9) */
#define spi0_app_spi_interrupt_control_register_IR_out_fuel_Msk (0x3fe00UL) /*!< spi0_app spi_interrupt_control_register: IR_out_fuel (Bitfield-Mask: 0x1ff) */
#define spi0_app_spi_interrupt_control_register_IR_in_fuel_Pos (0UL) /*!< spi0_app spi_interrupt_control_register: IR_in_fuel (Bit 0) */
#define spi0_app_spi_interrupt_control_register_IR_in_fuel_Msk (0x1ffUL) /*!< spi0_app spi_interrupt_control_register: IR_in_fuel (Bitfield-Mask: 0x1ff) */


/* =========================================================================================================================== */
/* ================                                         spi1_app                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  spi_cr0  ======================================================== */
#define spi1_app_spi_cr0_netx100_comp_Pos (31UL)                    /*!< spi1_app spi_cr0: netx100_comp (Bit 31)               */
#define spi1_app_spi_cr0_netx100_comp_Msk (0x80000000UL)            /*!< spi1_app spi_cr0: netx100_comp (Bitfield-Mask: 0x01)  */
#define spi1_app_spi_cr0_reserved3_Pos    (29UL)                    /*!< spi1_app spi_cr0: reserved3 (Bit 29)                  */
#define spi1_app_spi_cr0_reserved3_Msk    (0x60000000UL)            /*!< spi1_app spi_cr0: reserved3 (Bitfield-Mask: 0x03)     */
#define spi1_app_spi_cr0_slave_sig_early_Pos (28UL)                 /*!< spi1_app spi_cr0: slave_sig_early (Bit 28)            */
#define spi1_app_spi_cr0_slave_sig_early_Msk (0x10000000UL)         /*!< spi1_app spi_cr0: slave_sig_early (Bitfield-Mask: 0x01) */
#define spi1_app_spi_cr0_filter_in_Pos    (27UL)                    /*!< spi1_app spi_cr0: filter_in (Bit 27)                  */
#define spi1_app_spi_cr0_filter_in_Msk    (0x8000000UL)             /*!< spi1_app spi_cr0: filter_in (Bitfield-Mask: 0x01)     */
#define spi1_app_spi_cr0_reserved2_Pos    (26UL)                    /*!< spi1_app spi_cr0: reserved2 (Bit 26)                  */
#define spi1_app_spi_cr0_reserved2_Msk    (0x4000000UL)             /*!< spi1_app spi_cr0: reserved2 (Bitfield-Mask: 0x01)     */
#define spi1_app_spi_cr0_format_Pos       (24UL)                    /*!< spi1_app spi_cr0: format (Bit 24)                     */
#define spi1_app_spi_cr0_format_Msk       (0x3000000UL)             /*!< spi1_app spi_cr0: format (Bitfield-Mask: 0x03)        */
#define spi1_app_spi_cr0_reserved1_Pos    (20UL)                    /*!< spi1_app spi_cr0: reserved1 (Bit 20)                  */
#define spi1_app_spi_cr0_reserved1_Msk    (0xf00000UL)              /*!< spi1_app spi_cr0: reserved1 (Bitfield-Mask: 0x0f)     */
#define spi1_app_spi_cr0_sck_muladd_Pos   (8UL)                     /*!< spi1_app spi_cr0: sck_muladd (Bit 8)                  */
#define spi1_app_spi_cr0_sck_muladd_Msk   (0xfff00UL)               /*!< spi1_app spi_cr0: sck_muladd (Bitfield-Mask: 0xfff)   */
#define spi1_app_spi_cr0_SPH_Pos          (7UL)                     /*!< spi1_app spi_cr0: SPH (Bit 7)                         */
#define spi1_app_spi_cr0_SPH_Msk          (0x80UL)                  /*!< spi1_app spi_cr0: SPH (Bitfield-Mask: 0x01)           */
#define spi1_app_spi_cr0_SPO_Pos          (6UL)                     /*!< spi1_app spi_cr0: SPO (Bit 6)                         */
#define spi1_app_spi_cr0_SPO_Msk          (0x40UL)                  /*!< spi1_app spi_cr0: SPO (Bitfield-Mask: 0x01)           */
#define spi1_app_spi_cr0_reserved0_Pos    (4UL)                     /*!< spi1_app spi_cr0: reserved0 (Bit 4)                   */
#define spi1_app_spi_cr0_reserved0_Msk    (0x30UL)                  /*!< spi1_app spi_cr0: reserved0 (Bitfield-Mask: 0x03)     */
#define spi1_app_spi_cr0_datasize_Pos     (0UL)                     /*!< spi1_app spi_cr0: datasize (Bit 0)                    */
#define spi1_app_spi_cr0_datasize_Msk     (0xfUL)                   /*!< spi1_app spi_cr0: datasize (Bitfield-Mask: 0x0f)      */
/* ========================================================  spi_cr1  ======================================================== */
#define spi1_app_spi_cr1_reserved3_Pos    (29UL)                    /*!< spi1_app spi_cr1: reserved3 (Bit 29)                  */
#define spi1_app_spi_cr1_reserved3_Msk    (0xe0000000UL)            /*!< spi1_app spi_cr1: reserved3 (Bitfield-Mask: 0x07)     */
#define spi1_app_spi_cr1_rx_fifo_clr_Pos  (28UL)                    /*!< spi1_app spi_cr1: rx_fifo_clr (Bit 28)                */
#define spi1_app_spi_cr1_rx_fifo_clr_Msk  (0x10000000UL)            /*!< spi1_app spi_cr1: rx_fifo_clr (Bitfield-Mask: 0x01)   */
#define spi1_app_spi_cr1_rx_fifo_wm_Pos   (24UL)                    /*!< spi1_app spi_cr1: rx_fifo_wm (Bit 24)                 */
#define spi1_app_spi_cr1_rx_fifo_wm_Msk   (0xf000000UL)             /*!< spi1_app spi_cr1: rx_fifo_wm (Bitfield-Mask: 0x0f)    */
#define spi1_app_spi_cr1_reserved2_Pos    (21UL)                    /*!< spi1_app spi_cr1: reserved2 (Bit 21)                  */
#define spi1_app_spi_cr1_reserved2_Msk    (0xe00000UL)              /*!< spi1_app spi_cr1: reserved2 (Bitfield-Mask: 0x07)     */
#define spi1_app_spi_cr1_tx_fifo_clr_Pos  (20UL)                    /*!< spi1_app spi_cr1: tx_fifo_clr (Bit 20)                */
#define spi1_app_spi_cr1_tx_fifo_clr_Msk  (0x100000UL)              /*!< spi1_app spi_cr1: tx_fifo_clr (Bitfield-Mask: 0x01)   */
#define spi1_app_spi_cr1_tx_fifo_wm_Pos   (16UL)                    /*!< spi1_app spi_cr1: tx_fifo_wm (Bit 16)                 */
#define spi1_app_spi_cr1_tx_fifo_wm_Msk   (0xf0000UL)               /*!< spi1_app spi_cr1: tx_fifo_wm (Bitfield-Mask: 0x0f)    */
#define spi1_app_spi_cr1_reserved1_Pos    (12UL)                    /*!< spi1_app spi_cr1: reserved1 (Bit 12)                  */
#define spi1_app_spi_cr1_reserved1_Msk    (0xf000UL)                /*!< spi1_app spi_cr1: reserved1 (Bitfield-Mask: 0x0f)     */
#define spi1_app_spi_cr1_fss_static_Pos   (11UL)                    /*!< spi1_app spi_cr1: fss_static (Bit 11)                 */
#define spi1_app_spi_cr1_fss_static_Msk   (0x800UL)                 /*!< spi1_app spi_cr1: fss_static (Bitfield-Mask: 0x01)    */
#define spi1_app_spi_cr1_fss_Pos          (8UL)                     /*!< spi1_app spi_cr1: fss (Bit 8)                         */
#define spi1_app_spi_cr1_fss_Msk          (0x700UL)                 /*!< spi1_app spi_cr1: fss (Bitfield-Mask: 0x07)           */
#define spi1_app_spi_cr1_reserved0_Pos    (4UL)                     /*!< spi1_app spi_cr1: reserved0 (Bit 4)                   */
#define spi1_app_spi_cr1_reserved0_Msk    (0xf0UL)                  /*!< spi1_app spi_cr1: reserved0 (Bitfield-Mask: 0x0f)     */
#define spi1_app_spi_cr1_SOD_Pos          (3UL)                     /*!< spi1_app spi_cr1: SOD (Bit 3)                         */
#define spi1_app_spi_cr1_SOD_Msk          (0x8UL)                   /*!< spi1_app spi_cr1: SOD (Bitfield-Mask: 0x01)           */
#define spi1_app_spi_cr1_MS_Pos           (2UL)                     /*!< spi1_app spi_cr1: MS (Bit 2)                          */
#define spi1_app_spi_cr1_MS_Msk           (0x4UL)                   /*!< spi1_app spi_cr1: MS (Bitfield-Mask: 0x01)            */
#define spi1_app_spi_cr1_SSE_Pos          (1UL)                     /*!< spi1_app spi_cr1: SSE (Bit 1)                         */
#define spi1_app_spi_cr1_SSE_Msk          (0x2UL)                   /*!< spi1_app spi_cr1: SSE (Bitfield-Mask: 0x01)           */
#define spi1_app_spi_cr1_LBM_Pos          (0UL)                     /*!< spi1_app spi_cr1: LBM (Bit 0)                         */
#define spi1_app_spi_cr1_LBM_Msk          (0x1UL)                   /*!< spi1_app spi_cr1: LBM (Bitfield-Mask: 0x01)           */
/* ========================================================  spi_dr  ========================================================= */
#define spi1_app_spi_dr_data_Pos          (0UL)                     /*!< spi1_app spi_dr: data (Bit 0)                         */
#define spi1_app_spi_dr_data_Msk          (0x1ffffUL)               /*!< spi1_app spi_dr: data (Bitfield-Mask: 0x1ffff)        */
/* ========================================================  spi_sr  ========================================================= */
#define spi1_app_spi_sr_rx_fifo_err_undr_Pos (31UL)                 /*!< spi1_app spi_sr: rx_fifo_err_undr (Bit 31)            */
#define spi1_app_spi_sr_rx_fifo_err_undr_Msk (0x80000000UL)         /*!< spi1_app spi_sr: rx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi1_app_spi_sr_rx_fifo_err_ovfl_Pos (30UL)                 /*!< spi1_app spi_sr: rx_fifo_err_ovfl (Bit 30)            */
#define spi1_app_spi_sr_rx_fifo_err_ovfl_Msk (0x40000000UL)         /*!< spi1_app spi_sr: rx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi1_app_spi_sr_reserved2_Pos     (29UL)                    /*!< spi1_app spi_sr: reserved2 (Bit 29)                   */
#define spi1_app_spi_sr_reserved2_Msk     (0x20000000UL)            /*!< spi1_app spi_sr: reserved2 (Bitfield-Mask: 0x01)      */
#define spi1_app_spi_sr_rx_fifo_level_Pos (24UL)                    /*!< spi1_app spi_sr: rx_fifo_level (Bit 24)               */
#define spi1_app_spi_sr_rx_fifo_level_Msk (0x1f000000UL)            /*!< spi1_app spi_sr: rx_fifo_level (Bitfield-Mask: 0x1f)  */
#define spi1_app_spi_sr_tx_fifo_err_undr_Pos (23UL)                 /*!< spi1_app spi_sr: tx_fifo_err_undr (Bit 23)            */
#define spi1_app_spi_sr_tx_fifo_err_undr_Msk (0x800000UL)           /*!< spi1_app spi_sr: tx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi1_app_spi_sr_tx_fifo_err_ovfl_Pos (22UL)                 /*!< spi1_app spi_sr: tx_fifo_err_ovfl (Bit 22)            */
#define spi1_app_spi_sr_tx_fifo_err_ovfl_Msk (0x400000UL)           /*!< spi1_app spi_sr: tx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi1_app_spi_sr_reserved1_Pos     (21UL)                    /*!< spi1_app spi_sr: reserved1 (Bit 21)                   */
#define spi1_app_spi_sr_reserved1_Msk     (0x200000UL)              /*!< spi1_app spi_sr: reserved1 (Bitfield-Mask: 0x01)      */
#define spi1_app_spi_sr_tx_fifo_level_Pos (16UL)                    /*!< spi1_app spi_sr: tx_fifo_level (Bit 16)               */
#define spi1_app_spi_sr_tx_fifo_level_Msk (0x1f0000UL)              /*!< spi1_app spi_sr: tx_fifo_level (Bitfield-Mask: 0x1f)  */
#define spi1_app_spi_sr_reserved0_Pos     (5UL)                     /*!< spi1_app spi_sr: reserved0 (Bit 5)                    */
#define spi1_app_spi_sr_reserved0_Msk     (0xffe0UL)                /*!< spi1_app spi_sr: reserved0 (Bitfield-Mask: 0x7ff)     */
#define spi1_app_spi_sr_BSY_Pos           (4UL)                     /*!< spi1_app spi_sr: BSY (Bit 4)                          */
#define spi1_app_spi_sr_BSY_Msk           (0x10UL)                  /*!< spi1_app spi_sr: BSY (Bitfield-Mask: 0x01)            */
#define spi1_app_spi_sr_RFF_Pos           (3UL)                     /*!< spi1_app spi_sr: RFF (Bit 3)                          */
#define spi1_app_spi_sr_RFF_Msk           (0x8UL)                   /*!< spi1_app spi_sr: RFF (Bitfield-Mask: 0x01)            */
#define spi1_app_spi_sr_RNE_Pos           (2UL)                     /*!< spi1_app spi_sr: RNE (Bit 2)                          */
#define spi1_app_spi_sr_RNE_Msk           (0x4UL)                   /*!< spi1_app spi_sr: RNE (Bitfield-Mask: 0x01)            */
#define spi1_app_spi_sr_TNF_Pos           (1UL)                     /*!< spi1_app spi_sr: TNF (Bit 1)                          */
#define spi1_app_spi_sr_TNF_Msk           (0x2UL)                   /*!< spi1_app spi_sr: TNF (Bitfield-Mask: 0x01)            */
#define spi1_app_spi_sr_TFE_Pos           (0UL)                     /*!< spi1_app spi_sr: TFE (Bit 0)                          */
#define spi1_app_spi_sr_TFE_Msk           (0x1UL)                   /*!< spi1_app spi_sr: TFE (Bitfield-Mask: 0x01)            */
/* =======================================================  spi_imsc  ======================================================== */
#define spi1_app_spi_imsc_txeim_Pos       (6UL)                     /*!< spi1_app spi_imsc: txeim (Bit 6)                      */
#define spi1_app_spi_imsc_txeim_Msk       (0x40UL)                  /*!< spi1_app spi_imsc: txeim (Bitfield-Mask: 0x01)        */
#define spi1_app_spi_imsc_rxfim_Pos       (5UL)                     /*!< spi1_app spi_imsc: rxfim (Bit 5)                      */
#define spi1_app_spi_imsc_rxfim_Msk       (0x20UL)                  /*!< spi1_app spi_imsc: rxfim (Bitfield-Mask: 0x01)        */
#define spi1_app_spi_imsc_rxneim_Pos      (4UL)                     /*!< spi1_app spi_imsc: rxneim (Bit 4)                     */
#define spi1_app_spi_imsc_rxneim_Msk      (0x10UL)                  /*!< spi1_app spi_imsc: rxneim (Bitfield-Mask: 0x01)       */
#define spi1_app_spi_imsc_TXIM_Pos        (3UL)                     /*!< spi1_app spi_imsc: TXIM (Bit 3)                       */
#define spi1_app_spi_imsc_TXIM_Msk        (0x8UL)                   /*!< spi1_app spi_imsc: TXIM (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_imsc_RXIM_Pos        (2UL)                     /*!< spi1_app spi_imsc: RXIM (Bit 2)                       */
#define spi1_app_spi_imsc_RXIM_Msk        (0x4UL)                   /*!< spi1_app spi_imsc: RXIM (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_imsc_RTIM_Pos        (1UL)                     /*!< spi1_app spi_imsc: RTIM (Bit 1)                       */
#define spi1_app_spi_imsc_RTIM_Msk        (0x2UL)                   /*!< spi1_app spi_imsc: RTIM (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_imsc_RORIM_Pos       (0UL)                     /*!< spi1_app spi_imsc: RORIM (Bit 0)                      */
#define spi1_app_spi_imsc_RORIM_Msk       (0x1UL)                   /*!< spi1_app spi_imsc: RORIM (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_ris  ======================================================== */
#define spi1_app_spi_ris_txeris_Pos       (6UL)                     /*!< spi1_app spi_ris: txeris (Bit 6)                      */
#define spi1_app_spi_ris_txeris_Msk       (0x40UL)                  /*!< spi1_app spi_ris: txeris (Bitfield-Mask: 0x01)        */
#define spi1_app_spi_ris_rxfris_Pos       (5UL)                     /*!< spi1_app spi_ris: rxfris (Bit 5)                      */
#define spi1_app_spi_ris_rxfris_Msk       (0x20UL)                  /*!< spi1_app spi_ris: rxfris (Bitfield-Mask: 0x01)        */
#define spi1_app_spi_ris_rxneris_Pos      (4UL)                     /*!< spi1_app spi_ris: rxneris (Bit 4)                     */
#define spi1_app_spi_ris_rxneris_Msk      (0x10UL)                  /*!< spi1_app spi_ris: rxneris (Bitfield-Mask: 0x01)       */
#define spi1_app_spi_ris_TXRIS_Pos        (3UL)                     /*!< spi1_app spi_ris: TXRIS (Bit 3)                       */
#define spi1_app_spi_ris_TXRIS_Msk        (0x8UL)                   /*!< spi1_app spi_ris: TXRIS (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_ris_RXRIS_Pos        (2UL)                     /*!< spi1_app spi_ris: RXRIS (Bit 2)                       */
#define spi1_app_spi_ris_RXRIS_Msk        (0x4UL)                   /*!< spi1_app spi_ris: RXRIS (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_ris_RTRIS_Pos        (1UL)                     /*!< spi1_app spi_ris: RTRIS (Bit 1)                       */
#define spi1_app_spi_ris_RTRIS_Msk        (0x2UL)                   /*!< spi1_app spi_ris: RTRIS (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_ris_RORRIS_Pos       (0UL)                     /*!< spi1_app spi_ris: RORRIS (Bit 0)                      */
#define spi1_app_spi_ris_RORRIS_Msk       (0x1UL)                   /*!< spi1_app spi_ris: RORRIS (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_mis  ======================================================== */
#define spi1_app_spi_mis_txemis_Pos       (6UL)                     /*!< spi1_app spi_mis: txemis (Bit 6)                      */
#define spi1_app_spi_mis_txemis_Msk       (0x40UL)                  /*!< spi1_app spi_mis: txemis (Bitfield-Mask: 0x01)        */
#define spi1_app_spi_mis_rxfmis_Pos       (5UL)                     /*!< spi1_app spi_mis: rxfmis (Bit 5)                      */
#define spi1_app_spi_mis_rxfmis_Msk       (0x20UL)                  /*!< spi1_app spi_mis: rxfmis (Bitfield-Mask: 0x01)        */
#define spi1_app_spi_mis_rxnemis_Pos      (4UL)                     /*!< spi1_app spi_mis: rxnemis (Bit 4)                     */
#define spi1_app_spi_mis_rxnemis_Msk      (0x10UL)                  /*!< spi1_app spi_mis: rxnemis (Bitfield-Mask: 0x01)       */
#define spi1_app_spi_mis_TXMIS_Pos        (3UL)                     /*!< spi1_app spi_mis: TXMIS (Bit 3)                       */
#define spi1_app_spi_mis_TXMIS_Msk        (0x8UL)                   /*!< spi1_app spi_mis: TXMIS (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_mis_RXMIS_Pos        (2UL)                     /*!< spi1_app spi_mis: RXMIS (Bit 2)                       */
#define spi1_app_spi_mis_RXMIS_Msk        (0x4UL)                   /*!< spi1_app spi_mis: RXMIS (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_mis_RTMIS_Pos        (1UL)                     /*!< spi1_app spi_mis: RTMIS (Bit 1)                       */
#define spi1_app_spi_mis_RTMIS_Msk        (0x2UL)                   /*!< spi1_app spi_mis: RTMIS (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_mis_RORMIS_Pos       (0UL)                     /*!< spi1_app spi_mis: RORMIS (Bit 0)                      */
#define spi1_app_spi_mis_RORMIS_Msk       (0x1UL)                   /*!< spi1_app spi_mis: RORMIS (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_icr  ======================================================== */
#define spi1_app_spi_icr_txeic_Pos        (6UL)                     /*!< spi1_app spi_icr: txeic (Bit 6)                       */
#define spi1_app_spi_icr_txeic_Msk        (0x40UL)                  /*!< spi1_app spi_icr: txeic (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_icr_rxfic_Pos        (5UL)                     /*!< spi1_app spi_icr: rxfic (Bit 5)                       */
#define spi1_app_spi_icr_rxfic_Msk        (0x20UL)                  /*!< spi1_app spi_icr: rxfic (Bitfield-Mask: 0x01)         */
#define spi1_app_spi_icr_rxneic_Pos       (4UL)                     /*!< spi1_app spi_icr: rxneic (Bit 4)                      */
#define spi1_app_spi_icr_rxneic_Msk       (0x10UL)                  /*!< spi1_app spi_icr: rxneic (Bitfield-Mask: 0x01)        */
#define spi1_app_spi_icr_TXIC_Pos         (3UL)                     /*!< spi1_app spi_icr: TXIC (Bit 3)                        */
#define spi1_app_spi_icr_TXIC_Msk         (0x8UL)                   /*!< spi1_app spi_icr: TXIC (Bitfield-Mask: 0x01)          */
#define spi1_app_spi_icr_RXIC_Pos         (2UL)                     /*!< spi1_app spi_icr: RXIC (Bit 2)                        */
#define spi1_app_spi_icr_RXIC_Msk         (0x4UL)                   /*!< spi1_app spi_icr: RXIC (Bitfield-Mask: 0x01)          */
#define spi1_app_spi_icr_RTIC_Pos         (1UL)                     /*!< spi1_app spi_icr: RTIC (Bit 1)                        */
#define spi1_app_spi_icr_RTIC_Msk         (0x2UL)                   /*!< spi1_app spi_icr: RTIC (Bitfield-Mask: 0x01)          */
#define spi1_app_spi_icr_RORIC_Pos        (0UL)                     /*!< spi1_app spi_icr: RORIC (Bit 0)                       */
#define spi1_app_spi_icr_RORIC_Msk        (0x1UL)                   /*!< spi1_app spi_icr: RORIC (Bitfield-Mask: 0x01)         */
/* =======================================================  spi_dmacr  ======================================================= */
#define spi1_app_spi_dmacr_TXDMAE_Pos     (1UL)                     /*!< spi1_app spi_dmacr: TXDMAE (Bit 1)                    */
#define spi1_app_spi_dmacr_TXDMAE_Msk     (0x2UL)                   /*!< spi1_app spi_dmacr: TXDMAE (Bitfield-Mask: 0x01)      */
#define spi1_app_spi_dmacr_RXDMAE_Pos     (0UL)                     /*!< spi1_app spi_dmacr: RXDMAE (Bit 0)                    */
#define spi1_app_spi_dmacr_RXDMAE_Msk     (0x1UL)                   /*!< spi1_app spi_dmacr: RXDMAE (Bitfield-Mask: 0x01)      */
/* ===================================================  spi_data_register  =================================================== */
#define spi1_app_spi_data_register_dr_valid1_Pos (17UL)             /*!< spi1_app spi_data_register: dr_valid1 (Bit 17)        */
#define spi1_app_spi_data_register_dr_valid1_Msk (0x20000UL)        /*!< spi1_app spi_data_register: dr_valid1 (Bitfield-Mask: 0x01) */
#define spi1_app_spi_data_register_dr_valid0_Pos (16UL)             /*!< spi1_app spi_data_register: dr_valid0 (Bit 16)        */
#define spi1_app_spi_data_register_dr_valid0_Msk (0x10000UL)        /*!< spi1_app spi_data_register: dr_valid0 (Bitfield-Mask: 0x01) */
#define spi1_app_spi_data_register_data_byte_1_Pos (8UL)            /*!< spi1_app spi_data_register: data_byte_1 (Bit 8)       */
#define spi1_app_spi_data_register_data_byte_1_Msk (0xff00UL)       /*!< spi1_app spi_data_register: data_byte_1 (Bitfield-Mask: 0xff) */
#define spi1_app_spi_data_register_data_byte_0_Pos (0UL)            /*!< spi1_app spi_data_register: data_byte_0 (Bit 0)       */
#define spi1_app_spi_data_register_data_byte_0_Msk (0xffUL)         /*!< spi1_app spi_data_register: data_byte_0 (Bitfield-Mask: 0xff) */
/* ==================================================  spi_status_register  ================================================== */
#define spi1_app_spi_status_register_SR_selected_Pos (25UL)         /*!< spi1_app spi_status_register: SR_selected (Bit 25)    */
#define spi1_app_spi_status_register_SR_selected_Msk (0x2000000UL)  /*!< spi1_app spi_status_register: SR_selected (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_out_full_Pos (24UL)         /*!< spi1_app spi_status_register: SR_out_full (Bit 24)    */
#define spi1_app_spi_status_register_SR_out_full_Msk (0x1000000UL)  /*!< spi1_app spi_status_register: SR_out_full (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_out_empty_Pos (23UL)        /*!< spi1_app spi_status_register: SR_out_empty (Bit 23)   */
#define spi1_app_spi_status_register_SR_out_empty_Msk (0x800000UL)  /*!< spi1_app spi_status_register: SR_out_empty (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_out_fw_Pos (22UL)           /*!< spi1_app spi_status_register: SR_out_fw (Bit 22)      */
#define spi1_app_spi_status_register_SR_out_fw_Msk (0x400000UL)     /*!< spi1_app spi_status_register: SR_out_fw (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_out_fuel_Pos (21UL)         /*!< spi1_app spi_status_register: SR_out_fuel (Bit 21)    */
#define spi1_app_spi_status_register_SR_out_fuel_Msk (0x200000UL)   /*!< spi1_app spi_status_register: SR_out_fuel (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_in_full_Pos (20UL)          /*!< spi1_app spi_status_register: SR_in_full (Bit 20)     */
#define spi1_app_spi_status_register_SR_in_full_Msk (0x100000UL)    /*!< spi1_app spi_status_register: SR_in_full (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_in_recdata_Pos (19UL)       /*!< spi1_app spi_status_register: SR_in_recdata (Bit 19)  */
#define spi1_app_spi_status_register_SR_in_recdata_Msk (0x80000UL)  /*!< spi1_app spi_status_register: SR_in_recdata (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_in_fuel_Pos (18UL)          /*!< spi1_app spi_status_register: SR_in_fuel (Bit 18)     */
#define spi1_app_spi_status_register_SR_in_fuel_Msk (0x40000UL)     /*!< spi1_app spi_status_register: SR_in_fuel (Bitfield-Mask: 0x01) */
#define spi1_app_spi_status_register_SR_out_fuel_val_Pos (9UL)      /*!< spi1_app spi_status_register: SR_out_fuel_val (Bit 9) */
#define spi1_app_spi_status_register_SR_out_fuel_val_Msk (0x3fe00UL) /*!< spi1_app spi_status_register: SR_out_fuel_val (Bitfield-Mask: 0x1ff) */
#define spi1_app_spi_status_register_SR_in_fuel_val_Pos (0UL)       /*!< spi1_app spi_status_register: SR_in_fuel_val (Bit 0)  */
#define spi1_app_spi_status_register_SR_in_fuel_val_Msk (0x1ffUL)   /*!< spi1_app spi_status_register: SR_in_fuel_val (Bitfield-Mask: 0x1ff) */
/* =================================================  spi_control_register  ================================================== */
#define spi1_app_spi_control_register_CR_en_Pos (31UL)              /*!< spi1_app spi_control_register: CR_en (Bit 31)         */
#define spi1_app_spi_control_register_CR_en_Msk (0x80000000UL)      /*!< spi1_app spi_control_register: CR_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_ms_Pos (30UL)              /*!< spi1_app spi_control_register: CR_ms (Bit 30)         */
#define spi1_app_spi_control_register_CR_ms_Msk (0x40000000UL)      /*!< spi1_app spi_control_register: CR_ms (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_cpol_Pos (29UL)            /*!< spi1_app spi_control_register: CR_cpol (Bit 29)       */
#define spi1_app_spi_control_register_CR_cpol_Msk (0x20000000UL)    /*!< spi1_app spi_control_register: CR_cpol (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_ncpha_Pos (28UL)           /*!< spi1_app spi_control_register: CR_ncpha (Bit 28)      */
#define spi1_app_spi_control_register_CR_ncpha_Msk (0x10000000UL)   /*!< spi1_app spi_control_register: CR_ncpha (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_burst_Pos (25UL)           /*!< spi1_app spi_control_register: CR_burst (Bit 25)      */
#define spi1_app_spi_control_register_CR_burst_Msk (0xe000000UL)    /*!< spi1_app spi_control_register: CR_burst (Bitfield-Mask: 0x07) */
#define spi1_app_spi_control_register_CR_burstdelay_Pos (22UL)      /*!< spi1_app spi_control_register: CR_burstdelay (Bit 22) */
#define spi1_app_spi_control_register_CR_burstdelay_Msk (0x1c00000UL) /*!< spi1_app spi_control_register: CR_burstdelay (Bitfield-Mask: 0x07) */
#define spi1_app_spi_control_register_CR_clr_outfifo_Pos (21UL)     /*!< spi1_app spi_control_register: CR_clr_outfifo (Bit 21) */
#define spi1_app_spi_control_register_CR_clr_outfifo_Msk (0x200000UL) /*!< spi1_app spi_control_register: CR_clr_outfifo (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_clr_infifo_Pos (20UL)      /*!< spi1_app spi_control_register: CR_clr_infifo (Bit 20) */
#define spi1_app_spi_control_register_CR_clr_infifo_Msk (0x100000UL) /*!< spi1_app spi_control_register: CR_clr_infifo (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_reserved1_Pos (12UL)          /*!< spi1_app spi_control_register: reserved1 (Bit 12)     */
#define spi1_app_spi_control_register_reserved1_Msk (0xff000UL)     /*!< spi1_app spi_control_register: reserved1 (Bitfield-Mask: 0xff) */
#define spi1_app_spi_control_register_CS_mode_Pos (11UL)            /*!< spi1_app spi_control_register: CS_mode (Bit 11)       */
#define spi1_app_spi_control_register_CS_mode_Msk (0x800UL)         /*!< spi1_app spi_control_register: CS_mode (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_ss_Pos (8UL)               /*!< spi1_app spi_control_register: CR_ss (Bit 8)          */
#define spi1_app_spi_control_register_CR_ss_Msk (0x700UL)           /*!< spi1_app spi_control_register: CR_ss (Bitfield-Mask: 0x07) */
#define spi1_app_spi_control_register_CR_write_Pos (7UL)            /*!< spi1_app spi_control_register: CR_write (Bit 7)       */
#define spi1_app_spi_control_register_CR_write_Msk (0x80UL)         /*!< spi1_app spi_control_register: CR_write (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_read_Pos (6UL)             /*!< spi1_app spi_control_register: CR_read (Bit 6)        */
#define spi1_app_spi_control_register_CR_read_Msk (0x40UL)          /*!< spi1_app spi_control_register: CR_read (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_reserved0_Pos (5UL)           /*!< spi1_app spi_control_register: reserved0 (Bit 5)      */
#define spi1_app_spi_control_register_reserved0_Msk (0x20UL)        /*!< spi1_app spi_control_register: reserved0 (Bitfield-Mask: 0x01) */
#define spi1_app_spi_control_register_CR_speed_Pos (1UL)            /*!< spi1_app spi_control_register: CR_speed (Bit 1)       */
#define spi1_app_spi_control_register_CR_speed_Msk (0x1eUL)         /*!< spi1_app spi_control_register: CR_speed (Bitfield-Mask: 0x0f) */
#define spi1_app_spi_control_register_CR_softreset_Pos (0UL)        /*!< spi1_app spi_control_register: CR_softreset (Bit 0)   */
#define spi1_app_spi_control_register_CR_softreset_Msk (0x1UL)      /*!< spi1_app spi_control_register: CR_softreset (Bitfield-Mask: 0x01) */
/* ============================================  spi_interrupt_control_register  ============================================= */
#define spi1_app_spi_interrupt_control_register_IR_out_full_en_Pos (24UL) /*!< spi1_app spi_interrupt_control_register: IR_out_full_en (Bit 24) */
#define spi1_app_spi_interrupt_control_register_IR_out_full_en_Msk (0x1000000UL) /*!< spi1_app spi_interrupt_control_register: IR_out_full_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_interrupt_control_register_IR_out_empty_en_Pos (23UL) /*!< spi1_app spi_interrupt_control_register: IR_out_empty_en (Bit 23) */
#define spi1_app_spi_interrupt_control_register_IR_out_empty_en_Msk (0x800000UL) /*!< spi1_app spi_interrupt_control_register: IR_out_empty_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_interrupt_control_register_IR_out_fw_en_Pos (22UL) /*!< spi1_app spi_interrupt_control_register: IR_out_fw_en (Bit 22) */
#define spi1_app_spi_interrupt_control_register_IR_out_fw_en_Msk (0x400000UL) /*!< spi1_app spi_interrupt_control_register: IR_out_fw_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_interrupt_control_register_IR_out_fuel_en_Pos (21UL) /*!< spi1_app spi_interrupt_control_register: IR_out_fuel_en (Bit 21) */
#define spi1_app_spi_interrupt_control_register_IR_out_fuel_en_Msk (0x200000UL) /*!< spi1_app spi_interrupt_control_register: IR_out_fuel_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_interrupt_control_register_IR_in_full_en_Pos (20UL) /*!< spi1_app spi_interrupt_control_register: IR_in_full_en (Bit 20) */
#define spi1_app_spi_interrupt_control_register_IR_in_full_en_Msk (0x100000UL) /*!< spi1_app spi_interrupt_control_register: IR_in_full_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_interrupt_control_register_IR_in_recdata_en_Pos (19UL) /*!< spi1_app spi_interrupt_control_register: IR_in_recdata_en (Bit 19) */
#define spi1_app_spi_interrupt_control_register_IR_in_recdata_en_Msk (0x80000UL) /*!< spi1_app spi_interrupt_control_register: IR_in_recdata_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_interrupt_control_register_IR_in_fuel_en_Pos (18UL) /*!< spi1_app spi_interrupt_control_register: IR_in_fuel_en (Bit 18) */
#define spi1_app_spi_interrupt_control_register_IR_in_fuel_en_Msk (0x40000UL) /*!< spi1_app spi_interrupt_control_register: IR_in_fuel_en (Bitfield-Mask: 0x01) */
#define spi1_app_spi_interrupt_control_register_IR_out_fuel_Pos (9UL) /*!< spi1_app spi_interrupt_control_register: IR_out_fuel (Bit 9) */
#define spi1_app_spi_interrupt_control_register_IR_out_fuel_Msk (0x3fe00UL) /*!< spi1_app spi_interrupt_control_register: IR_out_fuel (Bitfield-Mask: 0x1ff) */
#define spi1_app_spi_interrupt_control_register_IR_in_fuel_Pos (0UL) /*!< spi1_app spi_interrupt_control_register: IR_in_fuel (Bit 0) */
#define spi1_app_spi_interrupt_control_register_IR_in_fuel_Msk (0x1ffUL) /*!< spi1_app spi_interrupt_control_register: IR_in_fuel (Bitfield-Mask: 0x1ff) */


/* =========================================================================================================================== */
/* ================                                         spi2_app                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  spi_cr0  ======================================================== */
#define spi2_app_spi_cr0_netx100_comp_Pos (31UL)                    /*!< spi2_app spi_cr0: netx100_comp (Bit 31)               */
#define spi2_app_spi_cr0_netx100_comp_Msk (0x80000000UL)            /*!< spi2_app spi_cr0: netx100_comp (Bitfield-Mask: 0x01)  */
#define spi2_app_spi_cr0_reserved3_Pos    (29UL)                    /*!< spi2_app spi_cr0: reserved3 (Bit 29)                  */
#define spi2_app_spi_cr0_reserved3_Msk    (0x60000000UL)            /*!< spi2_app spi_cr0: reserved3 (Bitfield-Mask: 0x03)     */
#define spi2_app_spi_cr0_slave_sig_early_Pos (28UL)                 /*!< spi2_app spi_cr0: slave_sig_early (Bit 28)            */
#define spi2_app_spi_cr0_slave_sig_early_Msk (0x10000000UL)         /*!< spi2_app spi_cr0: slave_sig_early (Bitfield-Mask: 0x01) */
#define spi2_app_spi_cr0_filter_in_Pos    (27UL)                    /*!< spi2_app spi_cr0: filter_in (Bit 27)                  */
#define spi2_app_spi_cr0_filter_in_Msk    (0x8000000UL)             /*!< spi2_app spi_cr0: filter_in (Bitfield-Mask: 0x01)     */
#define spi2_app_spi_cr0_reserved2_Pos    (26UL)                    /*!< spi2_app spi_cr0: reserved2 (Bit 26)                  */
#define spi2_app_spi_cr0_reserved2_Msk    (0x4000000UL)             /*!< spi2_app spi_cr0: reserved2 (Bitfield-Mask: 0x01)     */
#define spi2_app_spi_cr0_format_Pos       (24UL)                    /*!< spi2_app spi_cr0: format (Bit 24)                     */
#define spi2_app_spi_cr0_format_Msk       (0x3000000UL)             /*!< spi2_app spi_cr0: format (Bitfield-Mask: 0x03)        */
#define spi2_app_spi_cr0_reserved1_Pos    (20UL)                    /*!< spi2_app spi_cr0: reserved1 (Bit 20)                  */
#define spi2_app_spi_cr0_reserved1_Msk    (0xf00000UL)              /*!< spi2_app spi_cr0: reserved1 (Bitfield-Mask: 0x0f)     */
#define spi2_app_spi_cr0_sck_muladd_Pos   (8UL)                     /*!< spi2_app spi_cr0: sck_muladd (Bit 8)                  */
#define spi2_app_spi_cr0_sck_muladd_Msk   (0xfff00UL)               /*!< spi2_app spi_cr0: sck_muladd (Bitfield-Mask: 0xfff)   */
#define spi2_app_spi_cr0_SPH_Pos          (7UL)                     /*!< spi2_app spi_cr0: SPH (Bit 7)                         */
#define spi2_app_spi_cr0_SPH_Msk          (0x80UL)                  /*!< spi2_app spi_cr0: SPH (Bitfield-Mask: 0x01)           */
#define spi2_app_spi_cr0_SPO_Pos          (6UL)                     /*!< spi2_app spi_cr0: SPO (Bit 6)                         */
#define spi2_app_spi_cr0_SPO_Msk          (0x40UL)                  /*!< spi2_app spi_cr0: SPO (Bitfield-Mask: 0x01)           */
#define spi2_app_spi_cr0_reserved0_Pos    (4UL)                     /*!< spi2_app spi_cr0: reserved0 (Bit 4)                   */
#define spi2_app_spi_cr0_reserved0_Msk    (0x30UL)                  /*!< spi2_app spi_cr0: reserved0 (Bitfield-Mask: 0x03)     */
#define spi2_app_spi_cr0_datasize_Pos     (0UL)                     /*!< spi2_app spi_cr0: datasize (Bit 0)                    */
#define spi2_app_spi_cr0_datasize_Msk     (0xfUL)                   /*!< spi2_app spi_cr0: datasize (Bitfield-Mask: 0x0f)      */
/* ========================================================  spi_cr1  ======================================================== */
#define spi2_app_spi_cr1_reserved3_Pos    (29UL)                    /*!< spi2_app spi_cr1: reserved3 (Bit 29)                  */
#define spi2_app_spi_cr1_reserved3_Msk    (0xe0000000UL)            /*!< spi2_app spi_cr1: reserved3 (Bitfield-Mask: 0x07)     */
#define spi2_app_spi_cr1_rx_fifo_clr_Pos  (28UL)                    /*!< spi2_app spi_cr1: rx_fifo_clr (Bit 28)                */
#define spi2_app_spi_cr1_rx_fifo_clr_Msk  (0x10000000UL)            /*!< spi2_app spi_cr1: rx_fifo_clr (Bitfield-Mask: 0x01)   */
#define spi2_app_spi_cr1_rx_fifo_wm_Pos   (24UL)                    /*!< spi2_app spi_cr1: rx_fifo_wm (Bit 24)                 */
#define spi2_app_spi_cr1_rx_fifo_wm_Msk   (0xf000000UL)             /*!< spi2_app spi_cr1: rx_fifo_wm (Bitfield-Mask: 0x0f)    */
#define spi2_app_spi_cr1_reserved2_Pos    (21UL)                    /*!< spi2_app spi_cr1: reserved2 (Bit 21)                  */
#define spi2_app_spi_cr1_reserved2_Msk    (0xe00000UL)              /*!< spi2_app spi_cr1: reserved2 (Bitfield-Mask: 0x07)     */
#define spi2_app_spi_cr1_tx_fifo_clr_Pos  (20UL)                    /*!< spi2_app spi_cr1: tx_fifo_clr (Bit 20)                */
#define spi2_app_spi_cr1_tx_fifo_clr_Msk  (0x100000UL)              /*!< spi2_app spi_cr1: tx_fifo_clr (Bitfield-Mask: 0x01)   */
#define spi2_app_spi_cr1_tx_fifo_wm_Pos   (16UL)                    /*!< spi2_app spi_cr1: tx_fifo_wm (Bit 16)                 */
#define spi2_app_spi_cr1_tx_fifo_wm_Msk   (0xf0000UL)               /*!< spi2_app spi_cr1: tx_fifo_wm (Bitfield-Mask: 0x0f)    */
#define spi2_app_spi_cr1_reserved1_Pos    (12UL)                    /*!< spi2_app spi_cr1: reserved1 (Bit 12)                  */
#define spi2_app_spi_cr1_reserved1_Msk    (0xf000UL)                /*!< spi2_app spi_cr1: reserved1 (Bitfield-Mask: 0x0f)     */
#define spi2_app_spi_cr1_fss_static_Pos   (11UL)                    /*!< spi2_app spi_cr1: fss_static (Bit 11)                 */
#define spi2_app_spi_cr1_fss_static_Msk   (0x800UL)                 /*!< spi2_app spi_cr1: fss_static (Bitfield-Mask: 0x01)    */
#define spi2_app_spi_cr1_fss_Pos          (8UL)                     /*!< spi2_app spi_cr1: fss (Bit 8)                         */
#define spi2_app_spi_cr1_fss_Msk          (0x700UL)                 /*!< spi2_app spi_cr1: fss (Bitfield-Mask: 0x07)           */
#define spi2_app_spi_cr1_reserved0_Pos    (4UL)                     /*!< spi2_app spi_cr1: reserved0 (Bit 4)                   */
#define spi2_app_spi_cr1_reserved0_Msk    (0xf0UL)                  /*!< spi2_app spi_cr1: reserved0 (Bitfield-Mask: 0x0f)     */
#define spi2_app_spi_cr1_SOD_Pos          (3UL)                     /*!< spi2_app spi_cr1: SOD (Bit 3)                         */
#define spi2_app_spi_cr1_SOD_Msk          (0x8UL)                   /*!< spi2_app spi_cr1: SOD (Bitfield-Mask: 0x01)           */
#define spi2_app_spi_cr1_MS_Pos           (2UL)                     /*!< spi2_app spi_cr1: MS (Bit 2)                          */
#define spi2_app_spi_cr1_MS_Msk           (0x4UL)                   /*!< spi2_app spi_cr1: MS (Bitfield-Mask: 0x01)            */
#define spi2_app_spi_cr1_SSE_Pos          (1UL)                     /*!< spi2_app spi_cr1: SSE (Bit 1)                         */
#define spi2_app_spi_cr1_SSE_Msk          (0x2UL)                   /*!< spi2_app spi_cr1: SSE (Bitfield-Mask: 0x01)           */
#define spi2_app_spi_cr1_LBM_Pos          (0UL)                     /*!< spi2_app spi_cr1: LBM (Bit 0)                         */
#define spi2_app_spi_cr1_LBM_Msk          (0x1UL)                   /*!< spi2_app spi_cr1: LBM (Bitfield-Mask: 0x01)           */
/* ========================================================  spi_dr  ========================================================= */
#define spi2_app_spi_dr_data_Pos          (0UL)                     /*!< spi2_app spi_dr: data (Bit 0)                         */
#define spi2_app_spi_dr_data_Msk          (0x1ffffUL)               /*!< spi2_app spi_dr: data (Bitfield-Mask: 0x1ffff)        */
/* ========================================================  spi_sr  ========================================================= */
#define spi2_app_spi_sr_rx_fifo_err_undr_Pos (31UL)                 /*!< spi2_app spi_sr: rx_fifo_err_undr (Bit 31)            */
#define spi2_app_spi_sr_rx_fifo_err_undr_Msk (0x80000000UL)         /*!< spi2_app spi_sr: rx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi2_app_spi_sr_rx_fifo_err_ovfl_Pos (30UL)                 /*!< spi2_app spi_sr: rx_fifo_err_ovfl (Bit 30)            */
#define spi2_app_spi_sr_rx_fifo_err_ovfl_Msk (0x40000000UL)         /*!< spi2_app spi_sr: rx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi2_app_spi_sr_reserved2_Pos     (29UL)                    /*!< spi2_app spi_sr: reserved2 (Bit 29)                   */
#define spi2_app_spi_sr_reserved2_Msk     (0x20000000UL)            /*!< spi2_app spi_sr: reserved2 (Bitfield-Mask: 0x01)      */
#define spi2_app_spi_sr_rx_fifo_level_Pos (24UL)                    /*!< spi2_app spi_sr: rx_fifo_level (Bit 24)               */
#define spi2_app_spi_sr_rx_fifo_level_Msk (0x1f000000UL)            /*!< spi2_app spi_sr: rx_fifo_level (Bitfield-Mask: 0x1f)  */
#define spi2_app_spi_sr_tx_fifo_err_undr_Pos (23UL)                 /*!< spi2_app spi_sr: tx_fifo_err_undr (Bit 23)            */
#define spi2_app_spi_sr_tx_fifo_err_undr_Msk (0x800000UL)           /*!< spi2_app spi_sr: tx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi2_app_spi_sr_tx_fifo_err_ovfl_Pos (22UL)                 /*!< spi2_app spi_sr: tx_fifo_err_ovfl (Bit 22)            */
#define spi2_app_spi_sr_tx_fifo_err_ovfl_Msk (0x400000UL)           /*!< spi2_app spi_sr: tx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi2_app_spi_sr_reserved1_Pos     (21UL)                    /*!< spi2_app spi_sr: reserved1 (Bit 21)                   */
#define spi2_app_spi_sr_reserved1_Msk     (0x200000UL)              /*!< spi2_app spi_sr: reserved1 (Bitfield-Mask: 0x01)      */
#define spi2_app_spi_sr_tx_fifo_level_Pos (16UL)                    /*!< spi2_app spi_sr: tx_fifo_level (Bit 16)               */
#define spi2_app_spi_sr_tx_fifo_level_Msk (0x1f0000UL)              /*!< spi2_app spi_sr: tx_fifo_level (Bitfield-Mask: 0x1f)  */
#define spi2_app_spi_sr_reserved0_Pos     (5UL)                     /*!< spi2_app spi_sr: reserved0 (Bit 5)                    */
#define spi2_app_spi_sr_reserved0_Msk     (0xffe0UL)                /*!< spi2_app spi_sr: reserved0 (Bitfield-Mask: 0x7ff)     */
#define spi2_app_spi_sr_BSY_Pos           (4UL)                     /*!< spi2_app spi_sr: BSY (Bit 4)                          */
#define spi2_app_spi_sr_BSY_Msk           (0x10UL)                  /*!< spi2_app spi_sr: BSY (Bitfield-Mask: 0x01)            */
#define spi2_app_spi_sr_RFF_Pos           (3UL)                     /*!< spi2_app spi_sr: RFF (Bit 3)                          */
#define spi2_app_spi_sr_RFF_Msk           (0x8UL)                   /*!< spi2_app spi_sr: RFF (Bitfield-Mask: 0x01)            */
#define spi2_app_spi_sr_RNE_Pos           (2UL)                     /*!< spi2_app spi_sr: RNE (Bit 2)                          */
#define spi2_app_spi_sr_RNE_Msk           (0x4UL)                   /*!< spi2_app spi_sr: RNE (Bitfield-Mask: 0x01)            */
#define spi2_app_spi_sr_TNF_Pos           (1UL)                     /*!< spi2_app spi_sr: TNF (Bit 1)                          */
#define spi2_app_spi_sr_TNF_Msk           (0x2UL)                   /*!< spi2_app spi_sr: TNF (Bitfield-Mask: 0x01)            */
#define spi2_app_spi_sr_TFE_Pos           (0UL)                     /*!< spi2_app spi_sr: TFE (Bit 0)                          */
#define spi2_app_spi_sr_TFE_Msk           (0x1UL)                   /*!< spi2_app spi_sr: TFE (Bitfield-Mask: 0x01)            */
/* =======================================================  spi_imsc  ======================================================== */
#define spi2_app_spi_imsc_txeim_Pos       (6UL)                     /*!< spi2_app spi_imsc: txeim (Bit 6)                      */
#define spi2_app_spi_imsc_txeim_Msk       (0x40UL)                  /*!< spi2_app spi_imsc: txeim (Bitfield-Mask: 0x01)        */
#define spi2_app_spi_imsc_rxfim_Pos       (5UL)                     /*!< spi2_app spi_imsc: rxfim (Bit 5)                      */
#define spi2_app_spi_imsc_rxfim_Msk       (0x20UL)                  /*!< spi2_app spi_imsc: rxfim (Bitfield-Mask: 0x01)        */
#define spi2_app_spi_imsc_rxneim_Pos      (4UL)                     /*!< spi2_app spi_imsc: rxneim (Bit 4)                     */
#define spi2_app_spi_imsc_rxneim_Msk      (0x10UL)                  /*!< spi2_app spi_imsc: rxneim (Bitfield-Mask: 0x01)       */
#define spi2_app_spi_imsc_TXIM_Pos        (3UL)                     /*!< spi2_app spi_imsc: TXIM (Bit 3)                       */
#define spi2_app_spi_imsc_TXIM_Msk        (0x8UL)                   /*!< spi2_app spi_imsc: TXIM (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_imsc_RXIM_Pos        (2UL)                     /*!< spi2_app spi_imsc: RXIM (Bit 2)                       */
#define spi2_app_spi_imsc_RXIM_Msk        (0x4UL)                   /*!< spi2_app spi_imsc: RXIM (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_imsc_RTIM_Pos        (1UL)                     /*!< spi2_app spi_imsc: RTIM (Bit 1)                       */
#define spi2_app_spi_imsc_RTIM_Msk        (0x2UL)                   /*!< spi2_app spi_imsc: RTIM (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_imsc_RORIM_Pos       (0UL)                     /*!< spi2_app spi_imsc: RORIM (Bit 0)                      */
#define spi2_app_spi_imsc_RORIM_Msk       (0x1UL)                   /*!< spi2_app spi_imsc: RORIM (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_ris  ======================================================== */
#define spi2_app_spi_ris_txeris_Pos       (6UL)                     /*!< spi2_app spi_ris: txeris (Bit 6)                      */
#define spi2_app_spi_ris_txeris_Msk       (0x40UL)                  /*!< spi2_app spi_ris: txeris (Bitfield-Mask: 0x01)        */
#define spi2_app_spi_ris_rxfris_Pos       (5UL)                     /*!< spi2_app spi_ris: rxfris (Bit 5)                      */
#define spi2_app_spi_ris_rxfris_Msk       (0x20UL)                  /*!< spi2_app spi_ris: rxfris (Bitfield-Mask: 0x01)        */
#define spi2_app_spi_ris_rxneris_Pos      (4UL)                     /*!< spi2_app spi_ris: rxneris (Bit 4)                     */
#define spi2_app_spi_ris_rxneris_Msk      (0x10UL)                  /*!< spi2_app spi_ris: rxneris (Bitfield-Mask: 0x01)       */
#define spi2_app_spi_ris_TXRIS_Pos        (3UL)                     /*!< spi2_app spi_ris: TXRIS (Bit 3)                       */
#define spi2_app_spi_ris_TXRIS_Msk        (0x8UL)                   /*!< spi2_app spi_ris: TXRIS (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_ris_RXRIS_Pos        (2UL)                     /*!< spi2_app spi_ris: RXRIS (Bit 2)                       */
#define spi2_app_spi_ris_RXRIS_Msk        (0x4UL)                   /*!< spi2_app spi_ris: RXRIS (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_ris_RTRIS_Pos        (1UL)                     /*!< spi2_app spi_ris: RTRIS (Bit 1)                       */
#define spi2_app_spi_ris_RTRIS_Msk        (0x2UL)                   /*!< spi2_app spi_ris: RTRIS (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_ris_RORRIS_Pos       (0UL)                     /*!< spi2_app spi_ris: RORRIS (Bit 0)                      */
#define spi2_app_spi_ris_RORRIS_Msk       (0x1UL)                   /*!< spi2_app spi_ris: RORRIS (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_mis  ======================================================== */
#define spi2_app_spi_mis_txemis_Pos       (6UL)                     /*!< spi2_app spi_mis: txemis (Bit 6)                      */
#define spi2_app_spi_mis_txemis_Msk       (0x40UL)                  /*!< spi2_app spi_mis: txemis (Bitfield-Mask: 0x01)        */
#define spi2_app_spi_mis_rxfmis_Pos       (5UL)                     /*!< spi2_app spi_mis: rxfmis (Bit 5)                      */
#define spi2_app_spi_mis_rxfmis_Msk       (0x20UL)                  /*!< spi2_app spi_mis: rxfmis (Bitfield-Mask: 0x01)        */
#define spi2_app_spi_mis_rxnemis_Pos      (4UL)                     /*!< spi2_app spi_mis: rxnemis (Bit 4)                     */
#define spi2_app_spi_mis_rxnemis_Msk      (0x10UL)                  /*!< spi2_app spi_mis: rxnemis (Bitfield-Mask: 0x01)       */
#define spi2_app_spi_mis_TXMIS_Pos        (3UL)                     /*!< spi2_app spi_mis: TXMIS (Bit 3)                       */
#define spi2_app_spi_mis_TXMIS_Msk        (0x8UL)                   /*!< spi2_app spi_mis: TXMIS (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_mis_RXMIS_Pos        (2UL)                     /*!< spi2_app spi_mis: RXMIS (Bit 2)                       */
#define spi2_app_spi_mis_RXMIS_Msk        (0x4UL)                   /*!< spi2_app spi_mis: RXMIS (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_mis_RTMIS_Pos        (1UL)                     /*!< spi2_app spi_mis: RTMIS (Bit 1)                       */
#define spi2_app_spi_mis_RTMIS_Msk        (0x2UL)                   /*!< spi2_app spi_mis: RTMIS (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_mis_RORMIS_Pos       (0UL)                     /*!< spi2_app spi_mis: RORMIS (Bit 0)                      */
#define spi2_app_spi_mis_RORMIS_Msk       (0x1UL)                   /*!< spi2_app spi_mis: RORMIS (Bitfield-Mask: 0x01)        */
/* ========================================================  spi_icr  ======================================================== */
#define spi2_app_spi_icr_txeic_Pos        (6UL)                     /*!< spi2_app spi_icr: txeic (Bit 6)                       */
#define spi2_app_spi_icr_txeic_Msk        (0x40UL)                  /*!< spi2_app spi_icr: txeic (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_icr_rxfic_Pos        (5UL)                     /*!< spi2_app spi_icr: rxfic (Bit 5)                       */
#define spi2_app_spi_icr_rxfic_Msk        (0x20UL)                  /*!< spi2_app spi_icr: rxfic (Bitfield-Mask: 0x01)         */
#define spi2_app_spi_icr_rxneic_Pos       (4UL)                     /*!< spi2_app spi_icr: rxneic (Bit 4)                      */
#define spi2_app_spi_icr_rxneic_Msk       (0x10UL)                  /*!< spi2_app spi_icr: rxneic (Bitfield-Mask: 0x01)        */
#define spi2_app_spi_icr_TXIC_Pos         (3UL)                     /*!< spi2_app spi_icr: TXIC (Bit 3)                        */
#define spi2_app_spi_icr_TXIC_Msk         (0x8UL)                   /*!< spi2_app spi_icr: TXIC (Bitfield-Mask: 0x01)          */
#define spi2_app_spi_icr_RXIC_Pos         (2UL)                     /*!< spi2_app spi_icr: RXIC (Bit 2)                        */
#define spi2_app_spi_icr_RXIC_Msk         (0x4UL)                   /*!< spi2_app spi_icr: RXIC (Bitfield-Mask: 0x01)          */
#define spi2_app_spi_icr_RTIC_Pos         (1UL)                     /*!< spi2_app spi_icr: RTIC (Bit 1)                        */
#define spi2_app_spi_icr_RTIC_Msk         (0x2UL)                   /*!< spi2_app spi_icr: RTIC (Bitfield-Mask: 0x01)          */
#define spi2_app_spi_icr_RORIC_Pos        (0UL)                     /*!< spi2_app spi_icr: RORIC (Bit 0)                       */
#define spi2_app_spi_icr_RORIC_Msk        (0x1UL)                   /*!< spi2_app spi_icr: RORIC (Bitfield-Mask: 0x01)         */
/* =======================================================  spi_dmacr  ======================================================= */
#define spi2_app_spi_dmacr_TXDMAE_Pos     (1UL)                     /*!< spi2_app spi_dmacr: TXDMAE (Bit 1)                    */
#define spi2_app_spi_dmacr_TXDMAE_Msk     (0x2UL)                   /*!< spi2_app spi_dmacr: TXDMAE (Bitfield-Mask: 0x01)      */
#define spi2_app_spi_dmacr_RXDMAE_Pos     (0UL)                     /*!< spi2_app spi_dmacr: RXDMAE (Bit 0)                    */
#define spi2_app_spi_dmacr_RXDMAE_Msk     (0x1UL)                   /*!< spi2_app spi_dmacr: RXDMAE (Bitfield-Mask: 0x01)      */
/* ===================================================  spi_data_register  =================================================== */
#define spi2_app_spi_data_register_dr_valid1_Pos (17UL)             /*!< spi2_app spi_data_register: dr_valid1 (Bit 17)        */
#define spi2_app_spi_data_register_dr_valid1_Msk (0x20000UL)        /*!< spi2_app spi_data_register: dr_valid1 (Bitfield-Mask: 0x01) */
#define spi2_app_spi_data_register_dr_valid0_Pos (16UL)             /*!< spi2_app spi_data_register: dr_valid0 (Bit 16)        */
#define spi2_app_spi_data_register_dr_valid0_Msk (0x10000UL)        /*!< spi2_app spi_data_register: dr_valid0 (Bitfield-Mask: 0x01) */
#define spi2_app_spi_data_register_data_byte_1_Pos (8UL)            /*!< spi2_app spi_data_register: data_byte_1 (Bit 8)       */
#define spi2_app_spi_data_register_data_byte_1_Msk (0xff00UL)       /*!< spi2_app spi_data_register: data_byte_1 (Bitfield-Mask: 0xff) */
#define spi2_app_spi_data_register_data_byte_0_Pos (0UL)            /*!< spi2_app spi_data_register: data_byte_0 (Bit 0)       */
#define spi2_app_spi_data_register_data_byte_0_Msk (0xffUL)         /*!< spi2_app spi_data_register: data_byte_0 (Bitfield-Mask: 0xff) */
/* ==================================================  spi_status_register  ================================================== */
#define spi2_app_spi_status_register_SR_selected_Pos (25UL)         /*!< spi2_app spi_status_register: SR_selected (Bit 25)    */
#define spi2_app_spi_status_register_SR_selected_Msk (0x2000000UL)  /*!< spi2_app spi_status_register: SR_selected (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_out_full_Pos (24UL)         /*!< spi2_app spi_status_register: SR_out_full (Bit 24)    */
#define spi2_app_spi_status_register_SR_out_full_Msk (0x1000000UL)  /*!< spi2_app spi_status_register: SR_out_full (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_out_empty_Pos (23UL)        /*!< spi2_app spi_status_register: SR_out_empty (Bit 23)   */
#define spi2_app_spi_status_register_SR_out_empty_Msk (0x800000UL)  /*!< spi2_app spi_status_register: SR_out_empty (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_out_fw_Pos (22UL)           /*!< spi2_app spi_status_register: SR_out_fw (Bit 22)      */
#define spi2_app_spi_status_register_SR_out_fw_Msk (0x400000UL)     /*!< spi2_app spi_status_register: SR_out_fw (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_out_fuel_Pos (21UL)         /*!< spi2_app spi_status_register: SR_out_fuel (Bit 21)    */
#define spi2_app_spi_status_register_SR_out_fuel_Msk (0x200000UL)   /*!< spi2_app spi_status_register: SR_out_fuel (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_in_full_Pos (20UL)          /*!< spi2_app spi_status_register: SR_in_full (Bit 20)     */
#define spi2_app_spi_status_register_SR_in_full_Msk (0x100000UL)    /*!< spi2_app spi_status_register: SR_in_full (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_in_recdata_Pos (19UL)       /*!< spi2_app spi_status_register: SR_in_recdata (Bit 19)  */
#define spi2_app_spi_status_register_SR_in_recdata_Msk (0x80000UL)  /*!< spi2_app spi_status_register: SR_in_recdata (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_in_fuel_Pos (18UL)          /*!< spi2_app spi_status_register: SR_in_fuel (Bit 18)     */
#define spi2_app_spi_status_register_SR_in_fuel_Msk (0x40000UL)     /*!< spi2_app spi_status_register: SR_in_fuel (Bitfield-Mask: 0x01) */
#define spi2_app_spi_status_register_SR_out_fuel_val_Pos (9UL)      /*!< spi2_app spi_status_register: SR_out_fuel_val (Bit 9) */
#define spi2_app_spi_status_register_SR_out_fuel_val_Msk (0x3fe00UL) /*!< spi2_app spi_status_register: SR_out_fuel_val (Bitfield-Mask: 0x1ff) */
#define spi2_app_spi_status_register_SR_in_fuel_val_Pos (0UL)       /*!< spi2_app spi_status_register: SR_in_fuel_val (Bit 0)  */
#define spi2_app_spi_status_register_SR_in_fuel_val_Msk (0x1ffUL)   /*!< spi2_app spi_status_register: SR_in_fuel_val (Bitfield-Mask: 0x1ff) */
/* =================================================  spi_control_register  ================================================== */
#define spi2_app_spi_control_register_CR_en_Pos (31UL)              /*!< spi2_app spi_control_register: CR_en (Bit 31)         */
#define spi2_app_spi_control_register_CR_en_Msk (0x80000000UL)      /*!< spi2_app spi_control_register: CR_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_ms_Pos (30UL)              /*!< spi2_app spi_control_register: CR_ms (Bit 30)         */
#define spi2_app_spi_control_register_CR_ms_Msk (0x40000000UL)      /*!< spi2_app spi_control_register: CR_ms (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_cpol_Pos (29UL)            /*!< spi2_app spi_control_register: CR_cpol (Bit 29)       */
#define spi2_app_spi_control_register_CR_cpol_Msk (0x20000000UL)    /*!< spi2_app spi_control_register: CR_cpol (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_ncpha_Pos (28UL)           /*!< spi2_app spi_control_register: CR_ncpha (Bit 28)      */
#define spi2_app_spi_control_register_CR_ncpha_Msk (0x10000000UL)   /*!< spi2_app spi_control_register: CR_ncpha (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_burst_Pos (25UL)           /*!< spi2_app spi_control_register: CR_burst (Bit 25)      */
#define spi2_app_spi_control_register_CR_burst_Msk (0xe000000UL)    /*!< spi2_app spi_control_register: CR_burst (Bitfield-Mask: 0x07) */
#define spi2_app_spi_control_register_CR_burstdelay_Pos (22UL)      /*!< spi2_app spi_control_register: CR_burstdelay (Bit 22) */
#define spi2_app_spi_control_register_CR_burstdelay_Msk (0x1c00000UL) /*!< spi2_app spi_control_register: CR_burstdelay (Bitfield-Mask: 0x07) */
#define spi2_app_spi_control_register_CR_clr_outfifo_Pos (21UL)     /*!< spi2_app spi_control_register: CR_clr_outfifo (Bit 21) */
#define spi2_app_spi_control_register_CR_clr_outfifo_Msk (0x200000UL) /*!< spi2_app spi_control_register: CR_clr_outfifo (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_clr_infifo_Pos (20UL)      /*!< spi2_app spi_control_register: CR_clr_infifo (Bit 20) */
#define spi2_app_spi_control_register_CR_clr_infifo_Msk (0x100000UL) /*!< spi2_app spi_control_register: CR_clr_infifo (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_reserved1_Pos (12UL)          /*!< spi2_app spi_control_register: reserved1 (Bit 12)     */
#define spi2_app_spi_control_register_reserved1_Msk (0xff000UL)     /*!< spi2_app spi_control_register: reserved1 (Bitfield-Mask: 0xff) */
#define spi2_app_spi_control_register_CS_mode_Pos (11UL)            /*!< spi2_app spi_control_register: CS_mode (Bit 11)       */
#define spi2_app_spi_control_register_CS_mode_Msk (0x800UL)         /*!< spi2_app spi_control_register: CS_mode (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_ss_Pos (8UL)               /*!< spi2_app spi_control_register: CR_ss (Bit 8)          */
#define spi2_app_spi_control_register_CR_ss_Msk (0x700UL)           /*!< spi2_app spi_control_register: CR_ss (Bitfield-Mask: 0x07) */
#define spi2_app_spi_control_register_CR_write_Pos (7UL)            /*!< spi2_app spi_control_register: CR_write (Bit 7)       */
#define spi2_app_spi_control_register_CR_write_Msk (0x80UL)         /*!< spi2_app spi_control_register: CR_write (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_read_Pos (6UL)             /*!< spi2_app spi_control_register: CR_read (Bit 6)        */
#define spi2_app_spi_control_register_CR_read_Msk (0x40UL)          /*!< spi2_app spi_control_register: CR_read (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_reserved0_Pos (5UL)           /*!< spi2_app spi_control_register: reserved0 (Bit 5)      */
#define spi2_app_spi_control_register_reserved0_Msk (0x20UL)        /*!< spi2_app spi_control_register: reserved0 (Bitfield-Mask: 0x01) */
#define spi2_app_spi_control_register_CR_speed_Pos (1UL)            /*!< spi2_app spi_control_register: CR_speed (Bit 1)       */
#define spi2_app_spi_control_register_CR_speed_Msk (0x1eUL)         /*!< spi2_app spi_control_register: CR_speed (Bitfield-Mask: 0x0f) */
#define spi2_app_spi_control_register_CR_softreset_Pos (0UL)        /*!< spi2_app spi_control_register: CR_softreset (Bit 0)   */
#define spi2_app_spi_control_register_CR_softreset_Msk (0x1UL)      /*!< spi2_app spi_control_register: CR_softreset (Bitfield-Mask: 0x01) */
/* ============================================  spi_interrupt_control_register  ============================================= */
#define spi2_app_spi_interrupt_control_register_IR_out_full_en_Pos (24UL) /*!< spi2_app spi_interrupt_control_register: IR_out_full_en (Bit 24) */
#define spi2_app_spi_interrupt_control_register_IR_out_full_en_Msk (0x1000000UL) /*!< spi2_app spi_interrupt_control_register: IR_out_full_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_interrupt_control_register_IR_out_empty_en_Pos (23UL) /*!< spi2_app spi_interrupt_control_register: IR_out_empty_en (Bit 23) */
#define spi2_app_spi_interrupt_control_register_IR_out_empty_en_Msk (0x800000UL) /*!< spi2_app spi_interrupt_control_register: IR_out_empty_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_interrupt_control_register_IR_out_fw_en_Pos (22UL) /*!< spi2_app spi_interrupt_control_register: IR_out_fw_en (Bit 22) */
#define spi2_app_spi_interrupt_control_register_IR_out_fw_en_Msk (0x400000UL) /*!< spi2_app spi_interrupt_control_register: IR_out_fw_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_interrupt_control_register_IR_out_fuel_en_Pos (21UL) /*!< spi2_app spi_interrupt_control_register: IR_out_fuel_en (Bit 21) */
#define spi2_app_spi_interrupt_control_register_IR_out_fuel_en_Msk (0x200000UL) /*!< spi2_app spi_interrupt_control_register: IR_out_fuel_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_interrupt_control_register_IR_in_full_en_Pos (20UL) /*!< spi2_app spi_interrupt_control_register: IR_in_full_en (Bit 20) */
#define spi2_app_spi_interrupt_control_register_IR_in_full_en_Msk (0x100000UL) /*!< spi2_app spi_interrupt_control_register: IR_in_full_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_interrupt_control_register_IR_in_recdata_en_Pos (19UL) /*!< spi2_app spi_interrupt_control_register: IR_in_recdata_en (Bit 19) */
#define spi2_app_spi_interrupt_control_register_IR_in_recdata_en_Msk (0x80000UL) /*!< spi2_app spi_interrupt_control_register: IR_in_recdata_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_interrupt_control_register_IR_in_fuel_en_Pos (18UL) /*!< spi2_app spi_interrupt_control_register: IR_in_fuel_en (Bit 18) */
#define spi2_app_spi_interrupt_control_register_IR_in_fuel_en_Msk (0x40000UL) /*!< spi2_app spi_interrupt_control_register: IR_in_fuel_en (Bitfield-Mask: 0x01) */
#define spi2_app_spi_interrupt_control_register_IR_out_fuel_Pos (9UL) /*!< spi2_app spi_interrupt_control_register: IR_out_fuel (Bit 9) */
#define spi2_app_spi_interrupt_control_register_IR_out_fuel_Msk (0x3fe00UL) /*!< spi2_app spi_interrupt_control_register: IR_out_fuel (Bitfield-Mask: 0x1ff) */
#define spi2_app_spi_interrupt_control_register_IR_in_fuel_Pos (0UL) /*!< spi2_app spi_interrupt_control_register: IR_in_fuel (Bit 0) */
#define spi2_app_spi_interrupt_control_register_IR_in_fuel_Msk (0x1ffUL) /*!< spi2_app spi_interrupt_control_register: IR_in_fuel (Bitfield-Mask: 0x1ff) */


/* =========================================================================================================================== */
/* ================                                          pio_app                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  pio_in  ========================================================= */
#define pio_app_pio_in_val_Pos            (0UL)                     /*!< pio_app pio_in: val (Bit 0)                           */
#define pio_app_pio_in_val_Msk            (0xffUL)                  /*!< pio_app pio_in: val (Bitfield-Mask: 0xff)             */
/* ========================================================  pio_out  ======================================================== */
#define pio_app_pio_out_val_Pos           (0UL)                     /*!< pio_app pio_out: val (Bit 0)                          */
#define pio_app_pio_out_val_Msk           (0xffUL)                  /*!< pio_app pio_out: val (Bitfield-Mask: 0xff)            */
/* ========================================================  pio_oe  ========================================================= */
#define pio_app_pio_oe_val_Pos            (0UL)                     /*!< pio_app pio_oe: val (Bit 0)                           */
#define pio_app_pio_oe_val_Msk            (0xffUL)                  /*!< pio_app pio_oe: val (Bitfield-Mask: 0xff)             */


/* =========================================================================================================================== */
/* ================                                         biss0_app                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  biss_scdata0_0  ===================================================== */
#define biss0_app_biss_scdata0_0_SCDATA0_0_Pos (0UL)                /*!< biss0_app biss_scdata0_0: SCDATA0_0 (Bit 0)           */
#define biss0_app_biss_scdata0_0_SCDATA0_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata0_0: SCDATA0_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata0_1  ===================================================== */
#define biss0_app_biss_scdata0_1_SCDATA0_1_Pos (0UL)                /*!< biss0_app biss_scdata0_1: SCDATA0_1 (Bit 0)           */
#define biss0_app_biss_scdata0_1_SCDATA0_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata0_1: SCDATA0_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata1_0  ===================================================== */
#define biss0_app_biss_scdata1_0_SCDATA1_0_Pos (0UL)                /*!< biss0_app biss_scdata1_0: SCDATA1_0 (Bit 0)           */
#define biss0_app_biss_scdata1_0_SCDATA1_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata1_0: SCDATA1_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata1_1  ===================================================== */
#define biss0_app_biss_scdata1_1_SCDATA1_1_Pos (0UL)                /*!< biss0_app biss_scdata1_1: SCDATA1_1 (Bit 0)           */
#define biss0_app_biss_scdata1_1_SCDATA1_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata1_1: SCDATA1_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata2_0  ===================================================== */
#define biss0_app_biss_scdata2_0_SCDATA2_0_Pos (0UL)                /*!< biss0_app biss_scdata2_0: SCDATA2_0 (Bit 0)           */
#define biss0_app_biss_scdata2_0_SCDATA2_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata2_0: SCDATA2_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata2_1  ===================================================== */
#define biss0_app_biss_scdata2_1_SCDATA2_1_Pos (0UL)                /*!< biss0_app biss_scdata2_1: SCDATA2_1 (Bit 0)           */
#define biss0_app_biss_scdata2_1_SCDATA2_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata2_1: SCDATA2_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata3_0  ===================================================== */
#define biss0_app_biss_scdata3_0_SCDATA3_0_Pos (0UL)                /*!< biss0_app biss_scdata3_0: SCDATA3_0 (Bit 0)           */
#define biss0_app_biss_scdata3_0_SCDATA3_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata3_0: SCDATA3_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata3_1  ===================================================== */
#define biss0_app_biss_scdata3_1_SCDATA3_1_Pos (0UL)                /*!< biss0_app biss_scdata3_1: SCDATA3_1 (Bit 0)           */
#define biss0_app_biss_scdata3_1_SCDATA3_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata3_1: SCDATA3_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata4_0  ===================================================== */
#define biss0_app_biss_scdata4_0_SCDATA4_0_Pos (0UL)                /*!< biss0_app biss_scdata4_0: SCDATA4_0 (Bit 0)           */
#define biss0_app_biss_scdata4_0_SCDATA4_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata4_0: SCDATA4_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata4_1  ===================================================== */
#define biss0_app_biss_scdata4_1_SCDATA4_1_Pos (0UL)                /*!< biss0_app biss_scdata4_1: SCDATA4_1 (Bit 0)           */
#define biss0_app_biss_scdata4_1_SCDATA4_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata4_1: SCDATA4_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata5_0  ===================================================== */
#define biss0_app_biss_scdata5_0_SCDATA5_0_Pos (0UL)                /*!< biss0_app biss_scdata5_0: SCDATA5_0 (Bit 0)           */
#define biss0_app_biss_scdata5_0_SCDATA5_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata5_0: SCDATA5_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata5_1  ===================================================== */
#define biss0_app_biss_scdata5_1_SCDATA5_1_Pos (0UL)                /*!< biss0_app biss_scdata5_1: SCDATA5_1 (Bit 0)           */
#define biss0_app_biss_scdata5_1_SCDATA5_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata5_1: SCDATA5_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata6_0  ===================================================== */
#define biss0_app_biss_scdata6_0_SCDATA6_0_Pos (0UL)                /*!< biss0_app biss_scdata6_0: SCDATA6_0 (Bit 0)           */
#define biss0_app_biss_scdata6_0_SCDATA6_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata6_0: SCDATA6_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata6_1  ===================================================== */
#define biss0_app_biss_scdata6_1_SCDATA6_1_Pos (0UL)                /*!< biss0_app biss_scdata6_1: SCDATA6_1 (Bit 0)           */
#define biss0_app_biss_scdata6_1_SCDATA6_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata6_1: SCDATA6_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata7_0  ===================================================== */
#define biss0_app_biss_scdata7_0_SCDATA7_0_Pos (0UL)                /*!< biss0_app biss_scdata7_0: SCDATA7_0 (Bit 0)           */
#define biss0_app_biss_scdata7_0_SCDATA7_0_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata7_0: SCDATA7_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata7_1  ===================================================== */
#define biss0_app_biss_scdata7_1_SCDATA7_1_Pos (0UL)                /*!< biss0_app biss_scdata7_1: SCDATA7_1 (Bit 0)           */
#define biss0_app_biss_scdata7_1_SCDATA7_1_Msk (0xffffffffUL)       /*!< biss0_app biss_scdata7_1: SCDATA7_1 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata0  ====================================================== */
#define biss0_app_biss_rdata0_RDATA0_Pos  (0UL)                     /*!< biss0_app biss_rdata0: RDATA0 (Bit 0)                 */
#define biss0_app_biss_rdata0_RDATA0_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata0: RDATA0 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata1  ====================================================== */
#define biss0_app_biss_rdata1_RDATA1_Pos  (0UL)                     /*!< biss0_app biss_rdata1: RDATA1 (Bit 0)                 */
#define biss0_app_biss_rdata1_RDATA1_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata1: RDATA1 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata2  ====================================================== */
#define biss0_app_biss_rdata2_RDATA2_Pos  (0UL)                     /*!< biss0_app biss_rdata2: RDATA2 (Bit 0)                 */
#define biss0_app_biss_rdata2_RDATA2_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata2: RDATA2 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata3  ====================================================== */
#define biss0_app_biss_rdata3_RDATA3_Pos  (0UL)                     /*!< biss0_app biss_rdata3: RDATA3 (Bit 0)                 */
#define biss0_app_biss_rdata3_RDATA3_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata3: RDATA3 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata4  ====================================================== */
#define biss0_app_biss_rdata4_RDATA4_Pos  (0UL)                     /*!< biss0_app biss_rdata4: RDATA4 (Bit 0)                 */
#define biss0_app_biss_rdata4_RDATA4_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata4: RDATA4 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata5  ====================================================== */
#define biss0_app_biss_rdata5_RDATA5_Pos  (0UL)                     /*!< biss0_app biss_rdata5: RDATA5 (Bit 0)                 */
#define biss0_app_biss_rdata5_RDATA5_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata5: RDATA5 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata6  ====================================================== */
#define biss0_app_biss_rdata6_RDATA6_Pos  (0UL)                     /*!< biss0_app biss_rdata6: RDATA6 (Bit 0)                 */
#define biss0_app_biss_rdata6_RDATA6_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata6: RDATA6 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata7  ====================================================== */
#define biss0_app_biss_rdata7_RDATA7_Pos  (0UL)                     /*!< biss0_app biss_rdata7: RDATA7 (Bit 0)                 */
#define biss0_app_biss_rdata7_RDATA7_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata7: RDATA7 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata8  ====================================================== */
#define biss0_app_biss_rdata8_RDATA8_Pos  (0UL)                     /*!< biss0_app biss_rdata8: RDATA8 (Bit 0)                 */
#define biss0_app_biss_rdata8_RDATA8_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata8: RDATA8 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata9  ====================================================== */
#define biss0_app_biss_rdata9_RDATA9_Pos  (0UL)                     /*!< biss0_app biss_rdata9: RDATA9 (Bit 0)                 */
#define biss0_app_biss_rdata9_RDATA9_Msk  (0xffffffffUL)            /*!< biss0_app biss_rdata9: RDATA9 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata10  ====================================================== */
#define biss0_app_biss_rdata10_RDATA10_Pos (0UL)                    /*!< biss0_app biss_rdata10: RDATA10 (Bit 0)               */
#define biss0_app_biss_rdata10_RDATA10_Msk (0xffffffffUL)           /*!< biss0_app biss_rdata10: RDATA10 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata11  ====================================================== */
#define biss0_app_biss_rdata11_RDATA11_Pos (0UL)                    /*!< biss0_app biss_rdata11: RDATA11 (Bit 0)               */
#define biss0_app_biss_rdata11_RDATA11_Msk (0xffffffffUL)           /*!< biss0_app biss_rdata11: RDATA11 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata12  ====================================================== */
#define biss0_app_biss_rdata12_RDATA12_Pos (0UL)                    /*!< biss0_app biss_rdata12: RDATA12 (Bit 0)               */
#define biss0_app_biss_rdata12_RDATA12_Msk (0xffffffffUL)           /*!< biss0_app biss_rdata12: RDATA12 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata13  ====================================================== */
#define biss0_app_biss_rdata13_RDATA13_Pos (0UL)                    /*!< biss0_app biss_rdata13: RDATA13 (Bit 0)               */
#define biss0_app_biss_rdata13_RDATA13_Msk (0xffffffffUL)           /*!< biss0_app biss_rdata13: RDATA13 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata14  ====================================================== */
#define biss0_app_biss_rdata14_RDATA14_Pos (0UL)                    /*!< biss0_app biss_rdata14: RDATA14 (Bit 0)               */
#define biss0_app_biss_rdata14_RDATA14_Msk (0xffffffffUL)           /*!< biss0_app biss_rdata14: RDATA14 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata15  ====================================================== */
#define biss0_app_biss_rdata15_RDATA15_Pos (0UL)                    /*!< biss0_app biss_rdata15: RDATA15 (Bit 0)               */
#define biss0_app_biss_rdata15_RDATA15_Msk (0xffffffffUL)           /*!< biss0_app biss_rdata15: RDATA15 (Bitfield-Mask: 0xffffffff) */
/* =======================================================  biss_sc0  ======================================================== */
#define biss0_app_biss_sc0_SCRCSTART0_Pos (16UL)                    /*!< biss0_app biss_sc0: SCRCSTART0 (Bit 16)               */
#define biss0_app_biss_sc0_SCRCSTART0_Msk (0xffff0000UL)            /*!< biss0_app biss_sc0: SCRCSTART0 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc0_SELCRCS0_Pos   (15UL)                    /*!< biss0_app biss_sc0: SELCRCS0 (Bit 15)                 */
#define biss0_app_biss_sc0_SELCRCS0_Msk   (0x8000UL)                /*!< biss0_app biss_sc0: SELCRCS0 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc0_SCRCPOLY0_Pos  (8UL)                     /*!< biss0_app biss_sc0: SCRCPOLY0 (Bit 8)                 */
#define biss0_app_biss_sc0_SCRCPOLY0_Msk  (0x7f00UL)                /*!< biss0_app biss_sc0: SCRCPOLY0 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc0_LSTOP0_Pos     (7UL)                     /*!< biss0_app biss_sc0: LSTOP0 (Bit 7)                    */
#define biss0_app_biss_sc0_LSTOP0_Msk     (0x80UL)                  /*!< biss0_app biss_sc0: LSTOP0 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc0_ENSCD0_Pos     (6UL)                     /*!< biss0_app biss_sc0: ENSCD0 (Bit 6)                    */
#define biss0_app_biss_sc0_ENSCD0_Msk     (0x40UL)                  /*!< biss0_app biss_sc0: ENSCD0 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc0_SCDLEN0_Pos    (0UL)                     /*!< biss0_app biss_sc0: SCDLEN0 (Bit 0)                   */
#define biss0_app_biss_sc0_SCDLEN0_Msk    (0x3fUL)                  /*!< biss0_app biss_sc0: SCDLEN0 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc1  ======================================================== */
#define biss0_app_biss_sc1_SCRCSTART1_Pos (16UL)                    /*!< biss0_app biss_sc1: SCRCSTART1 (Bit 16)               */
#define biss0_app_biss_sc1_SCRCSTART1_Msk (0xffff0000UL)            /*!< biss0_app biss_sc1: SCRCSTART1 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc1_SELCRCS1_Pos   (15UL)                    /*!< biss0_app biss_sc1: SELCRCS1 (Bit 15)                 */
#define biss0_app_biss_sc1_SELCRCS1_Msk   (0x8000UL)                /*!< biss0_app biss_sc1: SELCRCS1 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc1_SCRCPOLY1_Pos  (8UL)                     /*!< biss0_app biss_sc1: SCRCPOLY1 (Bit 8)                 */
#define biss0_app_biss_sc1_SCRCPOLY1_Msk  (0x7f00UL)                /*!< biss0_app biss_sc1: SCRCPOLY1 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc1_LSTOP1_Pos     (7UL)                     /*!< biss0_app biss_sc1: LSTOP1 (Bit 7)                    */
#define biss0_app_biss_sc1_LSTOP1_Msk     (0x80UL)                  /*!< biss0_app biss_sc1: LSTOP1 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc1_ENSCD1_Pos     (6UL)                     /*!< biss0_app biss_sc1: ENSCD1 (Bit 6)                    */
#define biss0_app_biss_sc1_ENSCD1_Msk     (0x40UL)                  /*!< biss0_app biss_sc1: ENSCD1 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc1_SCDLEN1_Pos    (0UL)                     /*!< biss0_app biss_sc1: SCDLEN1 (Bit 0)                   */
#define biss0_app_biss_sc1_SCDLEN1_Msk    (0x3fUL)                  /*!< biss0_app biss_sc1: SCDLEN1 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc2  ======================================================== */
#define biss0_app_biss_sc2_SCRCSTART2_Pos (16UL)                    /*!< biss0_app biss_sc2: SCRCSTART2 (Bit 16)               */
#define biss0_app_biss_sc2_SCRCSTART2_Msk (0xffff0000UL)            /*!< biss0_app biss_sc2: SCRCSTART2 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc2_SELCRCS2_Pos   (15UL)                    /*!< biss0_app biss_sc2: SELCRCS2 (Bit 15)                 */
#define biss0_app_biss_sc2_SELCRCS2_Msk   (0x8000UL)                /*!< biss0_app biss_sc2: SELCRCS2 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc2_SCRCPOLY2_Pos  (8UL)                     /*!< biss0_app biss_sc2: SCRCPOLY2 (Bit 8)                 */
#define biss0_app_biss_sc2_SCRCPOLY2_Msk  (0x7f00UL)                /*!< biss0_app biss_sc2: SCRCPOLY2 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc2_LSTOP2_Pos     (7UL)                     /*!< biss0_app biss_sc2: LSTOP2 (Bit 7)                    */
#define biss0_app_biss_sc2_LSTOP2_Msk     (0x80UL)                  /*!< biss0_app biss_sc2: LSTOP2 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc2_ENSCD2_Pos     (6UL)                     /*!< biss0_app biss_sc2: ENSCD2 (Bit 6)                    */
#define biss0_app_biss_sc2_ENSCD2_Msk     (0x40UL)                  /*!< biss0_app biss_sc2: ENSCD2 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc2_SCDLEN2_Pos    (0UL)                     /*!< biss0_app biss_sc2: SCDLEN2 (Bit 0)                   */
#define biss0_app_biss_sc2_SCDLEN2_Msk    (0x3fUL)                  /*!< biss0_app biss_sc2: SCDLEN2 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc3  ======================================================== */
#define biss0_app_biss_sc3_SCRCSTART3_Pos (16UL)                    /*!< biss0_app biss_sc3: SCRCSTART3 (Bit 16)               */
#define biss0_app_biss_sc3_SCRCSTART3_Msk (0xffff0000UL)            /*!< biss0_app biss_sc3: SCRCSTART3 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc3_SELCRCS3_Pos   (15UL)                    /*!< biss0_app biss_sc3: SELCRCS3 (Bit 15)                 */
#define biss0_app_biss_sc3_SELCRCS3_Msk   (0x8000UL)                /*!< biss0_app biss_sc3: SELCRCS3 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc3_SCRCPOLY3_Pos  (8UL)                     /*!< biss0_app biss_sc3: SCRCPOLY3 (Bit 8)                 */
#define biss0_app_biss_sc3_SCRCPOLY3_Msk  (0x7f00UL)                /*!< biss0_app biss_sc3: SCRCPOLY3 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc3_LSTOP3_Pos     (7UL)                     /*!< biss0_app biss_sc3: LSTOP3 (Bit 7)                    */
#define biss0_app_biss_sc3_LSTOP3_Msk     (0x80UL)                  /*!< biss0_app biss_sc3: LSTOP3 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc3_ENSCD3_Pos     (6UL)                     /*!< biss0_app biss_sc3: ENSCD3 (Bit 6)                    */
#define biss0_app_biss_sc3_ENSCD3_Msk     (0x40UL)                  /*!< biss0_app biss_sc3: ENSCD3 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc3_SCDLEN3_Pos    (0UL)                     /*!< biss0_app biss_sc3: SCDLEN3 (Bit 0)                   */
#define biss0_app_biss_sc3_SCDLEN3_Msk    (0x3fUL)                  /*!< biss0_app biss_sc3: SCDLEN3 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc4  ======================================================== */
#define biss0_app_biss_sc4_SCRCSTART4_Pos (16UL)                    /*!< biss0_app biss_sc4: SCRCSTART4 (Bit 16)               */
#define biss0_app_biss_sc4_SCRCSTART4_Msk (0xffff0000UL)            /*!< biss0_app biss_sc4: SCRCSTART4 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc4_SELCRCS4_Pos   (15UL)                    /*!< biss0_app biss_sc4: SELCRCS4 (Bit 15)                 */
#define biss0_app_biss_sc4_SELCRCS4_Msk   (0x8000UL)                /*!< biss0_app biss_sc4: SELCRCS4 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc4_SCRCPOLY4_Pos  (8UL)                     /*!< biss0_app biss_sc4: SCRCPOLY4 (Bit 8)                 */
#define biss0_app_biss_sc4_SCRCPOLY4_Msk  (0x7f00UL)                /*!< biss0_app biss_sc4: SCRCPOLY4 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc4_LSTOP4_Pos     (7UL)                     /*!< biss0_app biss_sc4: LSTOP4 (Bit 7)                    */
#define biss0_app_biss_sc4_LSTOP4_Msk     (0x80UL)                  /*!< biss0_app biss_sc4: LSTOP4 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc4_ENSCD4_Pos     (6UL)                     /*!< biss0_app biss_sc4: ENSCD4 (Bit 6)                    */
#define biss0_app_biss_sc4_ENSCD4_Msk     (0x40UL)                  /*!< biss0_app biss_sc4: ENSCD4 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc4_SCDLEN4_Pos    (0UL)                     /*!< biss0_app biss_sc4: SCDLEN4 (Bit 0)                   */
#define biss0_app_biss_sc4_SCDLEN4_Msk    (0x3fUL)                  /*!< biss0_app biss_sc4: SCDLEN4 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc5  ======================================================== */
#define biss0_app_biss_sc5_SCRCSTART5_Pos (16UL)                    /*!< biss0_app biss_sc5: SCRCSTART5 (Bit 16)               */
#define biss0_app_biss_sc5_SCRCSTART5_Msk (0xffff0000UL)            /*!< biss0_app biss_sc5: SCRCSTART5 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc5_SELCRCS5_Pos   (15UL)                    /*!< biss0_app biss_sc5: SELCRCS5 (Bit 15)                 */
#define biss0_app_biss_sc5_SELCRCS5_Msk   (0x8000UL)                /*!< biss0_app biss_sc5: SELCRCS5 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc5_SCRCPOLY5_Pos  (8UL)                     /*!< biss0_app biss_sc5: SCRCPOLY5 (Bit 8)                 */
#define biss0_app_biss_sc5_SCRCPOLY5_Msk  (0x7f00UL)                /*!< biss0_app biss_sc5: SCRCPOLY5 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc5_LSTOP5_Pos     (7UL)                     /*!< biss0_app biss_sc5: LSTOP5 (Bit 7)                    */
#define biss0_app_biss_sc5_LSTOP5_Msk     (0x80UL)                  /*!< biss0_app biss_sc5: LSTOP5 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc5_ENSCD5_Pos     (6UL)                     /*!< biss0_app biss_sc5: ENSCD5 (Bit 6)                    */
#define biss0_app_biss_sc5_ENSCD5_Msk     (0x40UL)                  /*!< biss0_app biss_sc5: ENSCD5 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc5_SCDLEN5_Pos    (0UL)                     /*!< biss0_app biss_sc5: SCDLEN5 (Bit 0)                   */
#define biss0_app_biss_sc5_SCDLEN5_Msk    (0x3fUL)                  /*!< biss0_app biss_sc5: SCDLEN5 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc6  ======================================================== */
#define biss0_app_biss_sc6_SCRCSTART6_Pos (16UL)                    /*!< biss0_app biss_sc6: SCRCSTART6 (Bit 16)               */
#define biss0_app_biss_sc6_SCRCSTART6_Msk (0xffff0000UL)            /*!< biss0_app biss_sc6: SCRCSTART6 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc6_SELCRCS6_Pos   (15UL)                    /*!< biss0_app biss_sc6: SELCRCS6 (Bit 15)                 */
#define biss0_app_biss_sc6_SELCRCS6_Msk   (0x8000UL)                /*!< biss0_app biss_sc6: SELCRCS6 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc6_SCRCPOLY6_Pos  (8UL)                     /*!< biss0_app biss_sc6: SCRCPOLY6 (Bit 8)                 */
#define biss0_app_biss_sc6_SCRCPOLY6_Msk  (0x7f00UL)                /*!< biss0_app biss_sc6: SCRCPOLY6 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc6_LSTOP6_Pos     (7UL)                     /*!< biss0_app biss_sc6: LSTOP6 (Bit 7)                    */
#define biss0_app_biss_sc6_LSTOP6_Msk     (0x80UL)                  /*!< biss0_app biss_sc6: LSTOP6 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc6_ENSCD6_Pos     (6UL)                     /*!< biss0_app biss_sc6: ENSCD6 (Bit 6)                    */
#define biss0_app_biss_sc6_ENSCD6_Msk     (0x40UL)                  /*!< biss0_app biss_sc6: ENSCD6 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc6_SCDLEN6_Pos    (0UL)                     /*!< biss0_app biss_sc6: SCDLEN6 (Bit 0)                   */
#define biss0_app_biss_sc6_SCDLEN6_Msk    (0x3fUL)                  /*!< biss0_app biss_sc6: SCDLEN6 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc7  ======================================================== */
#define biss0_app_biss_sc7_SCRCSTART7_Pos (16UL)                    /*!< biss0_app biss_sc7: SCRCSTART7 (Bit 16)               */
#define biss0_app_biss_sc7_SCRCSTART7_Msk (0xffff0000UL)            /*!< biss0_app biss_sc7: SCRCSTART7 (Bitfield-Mask: 0xffff) */
#define biss0_app_biss_sc7_SELCRCS7_Pos   (15UL)                    /*!< biss0_app biss_sc7: SELCRCS7 (Bit 15)                 */
#define biss0_app_biss_sc7_SELCRCS7_Msk   (0x8000UL)                /*!< biss0_app biss_sc7: SELCRCS7 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_sc7_SCRCPOLY7_Pos  (8UL)                     /*!< biss0_app biss_sc7: SCRCPOLY7 (Bit 8)                 */
#define biss0_app_biss_sc7_SCRCPOLY7_Msk  (0x7f00UL)                /*!< biss0_app biss_sc7: SCRCPOLY7 (Bitfield-Mask: 0x7f)   */
#define biss0_app_biss_sc7_LSTOP7_Pos     (7UL)                     /*!< biss0_app biss_sc7: LSTOP7 (Bit 7)                    */
#define biss0_app_biss_sc7_LSTOP7_Msk     (0x80UL)                  /*!< biss0_app biss_sc7: LSTOP7 (Bitfield-Mask: 0x01)      */
#define biss0_app_biss_sc7_ENSC7_Pos      (6UL)                     /*!< biss0_app biss_sc7: ENSC7 (Bit 6)                     */
#define biss0_app_biss_sc7_ENSC7_Msk      (0x40UL)                  /*!< biss0_app biss_sc7: ENSC7 (Bitfield-Mask: 0x01)       */
#define biss0_app_biss_sc7_SCDLEN7_Pos    (0UL)                     /*!< biss0_app biss_sc7: SCDLEN7 (Bit 0)                   */
#define biss0_app_biss_sc7_SCDLEN7_Msk    (0x3fUL)                  /*!< biss0_app biss_sc7: SCDLEN7 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_ccc0  ======================================================= */
#define biss0_app_biss_ccc0_reserved1_Pos (30UL)                    /*!< biss0_app biss_ccc0: reserved1 (Bit 30)               */
#define biss0_app_biss_ccc0_reserved1_Msk (0xc0000000UL)            /*!< biss0_app biss_ccc0: reserved1 (Bitfield-Mask: 0x03)  */
#define biss0_app_biss_ccc0_REGNUM_Pos    (24UL)                    /*!< biss0_app biss_ccc0: REGNUM (Bit 24)                  */
#define biss0_app_biss_ccc0_REGNUM_Msk    (0x3f000000UL)            /*!< biss0_app biss_ccc0: REGNUM (Bitfield-Mask: 0x3f)     */
#define biss0_app_biss_ccc0_WNR_Pos       (23UL)                    /*!< biss0_app biss_ccc0: WNR (Bit 23)                     */
#define biss0_app_biss_ccc0_WNR_Msk       (0x800000UL)              /*!< biss0_app biss_ccc0: WNR (Bitfield-Mask: 0x01)        */
#define biss0_app_biss_ccc0_REGADR_Pos    (16UL)                    /*!< biss0_app biss_ccc0: REGADR (Bit 16)                  */
#define biss0_app_biss_ccc0_REGADR_Msk    (0x7f0000UL)              /*!< biss0_app biss_ccc0: REGADR (Bitfield-Mask: 0x7f)     */
#define biss0_app_biss_ccc0_reserved0_Pos (0UL)                     /*!< biss0_app biss_ccc0: reserved0 (Bit 0)                */
#define biss0_app_biss_ccc0_reserved0_Msk (0xffffUL)                /*!< biss0_app biss_ccc0: reserved0 (Bitfield-Mask: 0xffff) */
/* =====================================================  biss_ccc1_mc0  ===================================================== */
#define biss0_app_biss_ccc1_mc0_reserved2_Pos (26UL)                /*!< biss0_app biss_ccc1_mc0: reserved2 (Bit 26)           */
#define biss0_app_biss_ccc1_mc0_reserved2_Msk (0xfc000000UL)        /*!< biss0_app biss_ccc1_mc0: reserved2 (Bitfield-Mask: 0x3f) */
#define biss0_app_biss_ccc1_mc0_NOCRC_Pos (25UL)                    /*!< biss0_app biss_ccc1_mc0: NOCRC (Bit 25)               */
#define biss0_app_biss_ccc1_mc0_NOCRC_Msk (0x2000000UL)             /*!< biss0_app biss_ccc1_mc0: NOCRC (Bitfield-Mask: 0x01)  */
#define biss0_app_biss_ccc1_mc0_SINGLEBANK_Pos (24UL)               /*!< biss0_app biss_ccc1_mc0: SINGLEBANK (Bit 24)          */
#define biss0_app_biss_ccc1_mc0_SINGLEBANK_Msk (0x1000000UL)        /*!< biss0_app biss_ccc1_mc0: SINGLEBANK (Bitfield-Mask: 0x01) */
#define biss0_app_biss_ccc1_mc0_FREQR_Pos (21UL)                    /*!< biss0_app biss_ccc1_mc0: FREQR (Bit 21)               */
#define biss0_app_biss_ccc1_mc0_FREQR_Msk (0xe00000UL)              /*!< biss0_app biss_ccc1_mc0: FREQR (Bitfield-Mask: 0x07)  */
#define biss0_app_biss_ccc1_mc0_FREQS_Pos (16UL)                    /*!< biss0_app biss_ccc1_mc0: FREQS (Bit 16)               */
#define biss0_app_biss_ccc1_mc0_FREQS_Msk (0x1f0000UL)              /*!< biss0_app biss_ccc1_mc0: FREQS (Bitfield-Mask: 0x1f)  */
#define biss0_app_biss_ccc1_mc0_CTS_Pos   (15UL)                    /*!< biss0_app biss_ccc1_mc0: CTS (Bit 15)                 */
#define biss0_app_biss_ccc1_mc0_CTS_Msk   (0x8000UL)                /*!< biss0_app biss_ccc1_mc0: CTS (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_ccc1_mc0_REGVERS_Pos (14UL)                  /*!< biss0_app biss_ccc1_mc0: REGVERS (Bit 14)             */
#define biss0_app_biss_ccc1_mc0_REGVERS_Msk (0x4000UL)              /*!< biss0_app biss_ccc1_mc0: REGVERS (Bitfield-Mask: 0x01) */
#define biss0_app_biss_ccc1_mc0_CMD_Pos   (12UL)                    /*!< biss0_app biss_ccc1_mc0: CMD (Bit 12)                 */
#define biss0_app_biss_ccc1_mc0_CMD_Msk   (0x3000UL)                /*!< biss0_app biss_ccc1_mc0: CMD (Bitfield-Mask: 0x03)    */
#define biss0_app_biss_ccc1_mc0_IDA_TEST_Pos (11UL)                 /*!< biss0_app biss_ccc1_mc0: IDA_TEST (Bit 11)            */
#define biss0_app_biss_ccc1_mc0_IDA_TEST_Msk (0x800UL)              /*!< biss0_app biss_ccc1_mc0: IDA_TEST (Bitfield-Mask: 0x01) */
#define biss0_app_biss_ccc1_mc0_reserved1_Pos (10UL)                /*!< biss0_app biss_ccc1_mc0: reserved1 (Bit 10)           */
#define biss0_app_biss_ccc1_mc0_reserved1_Msk (0x400UL)             /*!< biss0_app biss_ccc1_mc0: reserved1 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_ccc1_mc0_EN_MO_Pos (9UL)                     /*!< biss0_app biss_ccc1_mc0: EN_MO (Bit 9)                */
#define biss0_app_biss_ccc1_mc0_EN_MO_Msk (0x200UL)                 /*!< biss0_app biss_ccc1_mc0: EN_MO (Bitfield-Mask: 0x01)  */
#define biss0_app_biss_ccc1_mc0_HOLDCDM_Pos (8UL)                   /*!< biss0_app biss_ccc1_mc0: HOLDCDM (Bit 8)              */
#define biss0_app_biss_ccc1_mc0_HOLDCDM_Msk (0x100UL)               /*!< biss0_app biss_ccc1_mc0: HOLDCDM (Bitfield-Mask: 0x01) */
#define biss0_app_biss_ccc1_mc0_reserved0_Pos (2UL)                 /*!< biss0_app biss_ccc1_mc0: reserved0 (Bit 2)            */
#define biss0_app_biss_ccc1_mc0_reserved0_Msk (0xfcUL)              /*!< biss0_app biss_ccc1_mc0: reserved0 (Bitfield-Mask: 0x3f) */
#define biss0_app_biss_ccc1_mc0_CHSEL_Pos (0UL)                     /*!< biss0_app biss_ccc1_mc0: CHSEL (Bit 0)                */
#define biss0_app_biss_ccc1_mc0_CHSEL_Msk (0x3UL)                   /*!< biss0_app biss_ccc1_mc0: CHSEL (Bitfield-Mask: 0x03)  */
/* =======================================================  biss_mc1  ======================================================== */
#define biss0_app_biss_mc1_VERSION_Pos    (24UL)                    /*!< biss0_app biss_mc1: VERSION (Bit 24)                  */
#define biss0_app_biss_mc1_VERSION_Msk    (0xff000000UL)            /*!< biss0_app biss_mc1: VERSION (Bitfield-Mask: 0xff)     */
#define biss0_app_biss_mc1_REVISION_Pos   (16UL)                    /*!< biss0_app biss_mc1: REVISION (Bit 16)                 */
#define biss0_app_biss_mc1_REVISION_Msk   (0xff0000UL)              /*!< biss0_app biss_mc1: REVISION (Bitfield-Mask: 0xff)    */
#define biss0_app_biss_mc1_MO_BUSY_Pos    (8UL)                     /*!< biss0_app biss_mc1: MO_BUSY (Bit 8)                   */
#define biss0_app_biss_mc1_MO_BUSY_Msk    (0xff00UL)                /*!< biss0_app biss_mc1: MO_BUSY (Bitfield-Mask: 0xff)     */
#define biss0_app_biss_mc1_FREQAGS_Pos    (0UL)                     /*!< biss0_app biss_mc1: FREQAGS (Bit 0)                   */
#define biss0_app_biss_mc1_FREQAGS_Msk    (0xffUL)                  /*!< biss0_app biss_mc1: FREQAGS (Bitfield-Mask: 0xff)     */
/* ======================================================  biss_cc_sl  ======================================================= */
#define biss0_app_biss_cc_sl_ACTnSENS_Pos (24UL)                    /*!< biss0_app biss_cc_sl: ACTnSENS (Bit 24)               */
#define biss0_app_biss_cc_sl_ACTnSENS_Msk (0xff000000UL)            /*!< biss0_app biss_cc_sl: ACTnSENS (Bitfield-Mask: 0xff)  */
#define biss0_app_biss_cc_sl_reserved1_Pos (12UL)                   /*!< biss0_app biss_cc_sl: reserved1 (Bit 12)              */
#define biss0_app_biss_cc_sl_reserved1_Msk (0xfff000UL)             /*!< biss0_app biss_cc_sl: reserved1 (Bitfield-Mask: 0xfff) */
#define biss0_app_biss_cc_sl_CFGCH2_Pos   (10UL)                    /*!< biss0_app biss_cc_sl: CFGCH2 (Bit 10)                 */
#define biss0_app_biss_cc_sl_CFGCH2_Msk   (0xc00UL)                 /*!< biss0_app biss_cc_sl: CFGCH2 (Bitfield-Mask: 0x03)    */
#define biss0_app_biss_cc_sl_CFGCH1_Pos   (8UL)                     /*!< biss0_app biss_cc_sl: CFGCH1 (Bit 8)                  */
#define biss0_app_biss_cc_sl_CFGCH1_Msk   (0x300UL)                 /*!< biss0_app biss_cc_sl: CFGCH1 (Bitfield-Mask: 0x03)    */
#define biss0_app_biss_cc_sl_reserved0_Pos (5UL)                    /*!< biss0_app biss_cc_sl: reserved0 (Bit 5)               */
#define biss0_app_biss_cc_sl_reserved0_Msk (0xe0UL)                 /*!< biss0_app biss_cc_sl: reserved0 (Bitfield-Mask: 0x07) */
#define biss0_app_biss_cc_sl_SLAVELOC5_Pos (4UL)                    /*!< biss0_app biss_cc_sl: SLAVELOC5 (Bit 4)               */
#define biss0_app_biss_cc_sl_SLAVELOC5_Msk (0x10UL)                 /*!< biss0_app biss_cc_sl: SLAVELOC5 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_cc_sl_cc_sl_reserved1_Pos (0UL)              /*!< biss0_app biss_cc_sl: cc_sl_reserved1 (Bit 0)         */
#define biss0_app_biss_cc_sl_cc_sl_reserved1_Msk (0xfUL)            /*!< biss0_app biss_cc_sl: cc_sl_reserved1 (Bitfield-Mask: 0x0f) */
/* =====================================================  biss_status0  ====================================================== */
#define biss0_app_biss_status0_CDMTIMEOUT_Pos (31UL)                /*!< biss0_app biss_status0: CDMTIMEOUT (Bit 31)           */
#define biss0_app_biss_status0_CDMTIMEOUT_Msk (0x80000000UL)        /*!< biss0_app biss_status0: CDMTIMEOUT (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_CDSSEL_Pos (30UL)                    /*!< biss0_app biss_status0: CDSSEL (Bit 30)               */
#define biss0_app_biss_status0_CDSSEL_Msk (0x40000000UL)            /*!< biss0_app biss_status0: CDSSEL (Bitfield-Mask: 0x01)  */
#define biss0_app_biss_status0_REGBYTES_Pos (24UL)                  /*!< biss0_app biss_status0: REGBYTES (Bit 24)             */
#define biss0_app_biss_status0_REGBYTES_Msk (0x3f000000UL)          /*!< biss0_app biss_status0: REGBYTES (Bitfield-Mask: 0x3f) */
#define biss0_app_biss_status0_SVALID7_Pos (23UL)                   /*!< biss0_app biss_status0: SVALID7 (Bit 23)              */
#define biss0_app_biss_status0_SVALID7_Msk (0x800000UL)             /*!< biss0_app biss_status0: SVALID7 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved7_Pos (22UL)                 /*!< biss0_app biss_status0: reserved7 (Bit 22)            */
#define biss0_app_biss_status0_reserved7_Msk (0x400000UL)           /*!< biss0_app biss_status0: reserved7 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_SVALID6_Pos (21UL)                   /*!< biss0_app biss_status0: SVALID6 (Bit 21)              */
#define biss0_app_biss_status0_SVALID6_Msk (0x200000UL)             /*!< biss0_app biss_status0: SVALID6 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved6_Pos (20UL)                 /*!< biss0_app biss_status0: reserved6 (Bit 20)            */
#define biss0_app_biss_status0_reserved6_Msk (0x100000UL)           /*!< biss0_app biss_status0: reserved6 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_SVALID5_Pos (19UL)                   /*!< biss0_app biss_status0: SVALID5 (Bit 19)              */
#define biss0_app_biss_status0_SVALID5_Msk (0x80000UL)              /*!< biss0_app biss_status0: SVALID5 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved5_Pos (18UL)                 /*!< biss0_app biss_status0: reserved5 (Bit 18)            */
#define biss0_app_biss_status0_reserved5_Msk (0x40000UL)            /*!< biss0_app biss_status0: reserved5 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_SVALID4_Pos (17UL)                   /*!< biss0_app biss_status0: SVALID4 (Bit 17)              */
#define biss0_app_biss_status0_SVALID4_Msk (0x20000UL)              /*!< biss0_app biss_status0: SVALID4 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved4_Pos (16UL)                 /*!< biss0_app biss_status0: reserved4 (Bit 16)            */
#define biss0_app_biss_status0_reserved4_Msk (0x10000UL)            /*!< biss0_app biss_status0: reserved4 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_SVALID3_Pos (15UL)                   /*!< biss0_app biss_status0: SVALID3 (Bit 15)              */
#define biss0_app_biss_status0_SVALID3_Msk (0x8000UL)               /*!< biss0_app biss_status0: SVALID3 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved3_Pos (14UL)                 /*!< biss0_app biss_status0: reserved3 (Bit 14)            */
#define biss0_app_biss_status0_reserved3_Msk (0x4000UL)             /*!< biss0_app biss_status0: reserved3 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_SVALID2_Pos (13UL)                   /*!< biss0_app biss_status0: SVALID2 (Bit 13)              */
#define biss0_app_biss_status0_SVALID2_Msk (0x2000UL)               /*!< biss0_app biss_status0: SVALID2 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved2_Pos (12UL)                 /*!< biss0_app biss_status0: reserved2 (Bit 12)            */
#define biss0_app_biss_status0_reserved2_Msk (0x1000UL)             /*!< biss0_app biss_status0: reserved2 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_SVALID1_Pos (11UL)                   /*!< biss0_app biss_status0: SVALID1 (Bit 11)              */
#define biss0_app_biss_status0_SVALID1_Msk (0x800UL)                /*!< biss0_app biss_status0: SVALID1 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved1_Pos (10UL)                 /*!< biss0_app biss_status0: reserved1 (Bit 10)            */
#define biss0_app_biss_status0_reserved1_Msk (0x400UL)              /*!< biss0_app biss_status0: reserved1 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_SVALID0_Pos (9UL)                    /*!< biss0_app biss_status0: SVALID0 (Bit 9)               */
#define biss0_app_biss_status0_SVALID0_Msk (0x200UL)                /*!< biss0_app biss_status0: SVALID0 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_reserved0_Pos (8UL)                  /*!< biss0_app biss_status0: reserved0 (Bit 8)             */
#define biss0_app_biss_status0_reserved0_Msk (0x100UL)              /*!< biss0_app biss_status0: reserved0 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_nERR_Pos   (7UL)                     /*!< biss0_app biss_status0: nERR (Bit 7)                  */
#define biss0_app_biss_status0_nERR_Msk   (0x80UL)                  /*!< biss0_app biss_status0: nERR (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_status0_nAGSERR_Pos (6UL)                    /*!< biss0_app biss_status0: nAGSERR (Bit 6)               */
#define biss0_app_biss_status0_nAGSERR_Msk (0x40UL)                 /*!< biss0_app biss_status0: nAGSERR (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_nDELAYERR_Pos (5UL)                  /*!< biss0_app biss_status0: nDELAYERR (Bit 5)             */
#define biss0_app_biss_status0_nDELAYERR_Msk (0x20UL)               /*!< biss0_app biss_status0: nDELAYERR (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_nSCDERR_Pos (4UL)                    /*!< biss0_app biss_status0: nSCDERR (Bit 4)               */
#define biss0_app_biss_status0_nSCDERR_Msk (0x10UL)                 /*!< biss0_app biss_status0: nSCDERR (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_nREGERR_Pos (3UL)                    /*!< biss0_app biss_status0: nREGERR (Bit 3)               */
#define biss0_app_biss_status0_nREGERR_Msk (0x8UL)                  /*!< biss0_app biss_status0: nREGERR (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_REGEND_Pos (2UL)                     /*!< biss0_app biss_status0: REGEND (Bit 2)                */
#define biss0_app_biss_status0_REGEND_Msk (0x4UL)                   /*!< biss0_app biss_status0: REGEND (Bitfield-Mask: 0x01)  */
#define biss0_app_biss_status0_status0_reserved1_Pos (1UL)          /*!< biss0_app biss_status0: status0_reserved1 (Bit 1)     */
#define biss0_app_biss_status0_status0_reserved1_Msk (0x2UL)        /*!< biss0_app biss_status0: status0_reserved1 (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status0_EOT_Pos    (0UL)                     /*!< biss0_app biss_status0: EOT (Bit 0)                   */
#define biss0_app_biss_status0_EOT_Msk    (0x1UL)                   /*!< biss0_app biss_status0: EOT (Bitfield-Mask: 0x01)     */
/* ========================================================  biss_ir  ======================================================== */
#define biss0_app_biss_ir_MAVO_Pos        (15UL)                    /*!< biss0_app biss_ir: MAVO (Bit 15)                      */
#define biss0_app_biss_ir_MAVO_Msk        (0x8000UL)                /*!< biss0_app biss_ir: MAVO (Bitfield-Mask: 0x01)         */
#define biss0_app_biss_ir_MAFO_Pos        (14UL)                    /*!< biss0_app biss_ir: MAFO (Bit 14)                      */
#define biss0_app_biss_ir_MAFO_Msk        (0x4000UL)                /*!< biss0_app biss_ir: MAFO (Bitfield-Mask: 0x01)         */
#define biss0_app_biss_ir_MAVS_Pos        (13UL)                    /*!< biss0_app biss_ir: MAVS (Bit 13)                      */
#define biss0_app_biss_ir_MAVS_Msk        (0x2000UL)                /*!< biss0_app biss_ir: MAVS (Bitfield-Mask: 0x01)         */
#define biss0_app_biss_ir_MAFS_Pos        (12UL)                    /*!< biss0_app biss_ir: MAFS (Bit 12)                      */
#define biss0_app_biss_ir_MAFS_Msk        (0x1000UL)                /*!< biss0_app biss_ir: MAFS (Bitfield-Mask: 0x01)         */
#define biss0_app_biss_ir_CFGIF_Pos       (10UL)                    /*!< biss0_app biss_ir: CFGIF (Bit 10)                     */
#define biss0_app_biss_ir_CFGIF_Msk       (0xc00UL)                 /*!< biss0_app biss_ir: CFGIF (Bitfield-Mask: 0x03)        */
#define biss0_app_biss_ir_ENTEST_Pos      (9UL)                     /*!< biss0_app biss_ir: ENTEST (Bit 9)                     */
#define biss0_app_biss_ir_ENTEST_Msk      (0x200UL)                 /*!< biss0_app biss_ir: ENTEST (Bitfield-Mask: 0x01)       */
#define biss0_app_biss_ir_CLKENI_Pos      (8UL)                     /*!< biss0_app biss_ir: CLKENI (Bit 8)                     */
#define biss0_app_biss_ir_CLKENI_Msk      (0x100UL)                 /*!< biss0_app biss_ir: CLKENI (Bitfield-Mask: 0x01)       */
#define biss0_app_biss_ir_BREAK_Pos       (7UL)                     /*!< biss0_app biss_ir: BREAK (Bit 7)                      */
#define biss0_app_biss_ir_BREAK_Msk       (0x80UL)                  /*!< biss0_app biss_ir: BREAK (Bitfield-Mask: 0x01)        */
#define biss0_app_biss_ir_HOLDBANK_Pos    (6UL)                     /*!< biss0_app biss_ir: HOLDBANK (Bit 6)                   */
#define biss0_app_biss_ir_HOLDBANK_Msk    (0x40UL)                  /*!< biss0_app biss_ir: HOLDBANK (Bitfield-Mask: 0x01)     */
#define biss0_app_biss_ir_SWBANK_Pos      (5UL)                     /*!< biss0_app biss_ir: SWBANK (Bit 5)                     */
#define biss0_app_biss_ir_SWBANK_Msk      (0x20UL)                  /*!< biss0_app biss_ir: SWBANK (Bitfield-Mask: 0x01)       */
#define biss0_app_biss_ir_INIT_Pos        (4UL)                     /*!< biss0_app biss_ir: INIT (Bit 4)                       */
#define biss0_app_biss_ir_INIT_Msk        (0x10UL)                  /*!< biss0_app biss_ir: INIT (Bitfield-Mask: 0x01)         */
#define biss0_app_biss_ir_INSTR_Pos       (1UL)                     /*!< biss0_app biss_ir: INSTR (Bit 1)                      */
#define biss0_app_biss_ir_INSTR_Msk       (0xeUL)                   /*!< biss0_app biss_ir: INSTR (Bitfield-Mask: 0x07)        */
#define biss0_app_biss_ir_AGS_Pos         (0UL)                     /*!< biss0_app biss_ir: AGS (Bit 0)                        */
#define biss0_app_biss_ir_AGS_Msk         (0x1UL)                   /*!< biss0_app biss_ir: AGS (Bitfield-Mask: 0x01)          */
/* =====================================================  biss_status1  ====================================================== */
#define biss0_app_biss_status1_reserved1_Pos (25UL)                 /*!< biss0_app biss_status1: reserved1 (Bit 25)            */
#define biss0_app_biss_status1_reserved1_Msk (0xfe000000UL)         /*!< biss0_app biss_status1: reserved1 (Bitfield-Mask: 0x7f) */
#define biss0_app_biss_status1_SWBANKFAILS_Pos (24UL)               /*!< biss0_app biss_status1: SWBANKFAILS (Bit 24)          */
#define biss0_app_biss_status1_SWBANKFAILS_Msk (0x1000000UL)        /*!< biss0_app biss_status1: SWBANKFAILS (Bitfield-Mask: 0x01) */
#define biss0_app_biss_status1_reserved0_Pos (2UL)                  /*!< biss0_app biss_status1: reserved0 (Bit 2)             */
#define biss0_app_biss_status1_reserved0_Msk (0xfffffcUL)           /*!< biss0_app biss_status1: reserved0 (Bitfield-Mask: 0x3fffff) */
#define biss0_app_biss_status1_CDS1_Pos   (1UL)                     /*!< biss0_app biss_status1: CDS1 (Bit 1)                  */
#define biss0_app_biss_status1_CDS1_Msk   (0x2UL)                   /*!< biss0_app biss_status1: CDS1 (Bitfield-Mask: 0x01)    */
#define biss0_app_biss_status1_SL1_Pos    (0UL)                     /*!< biss0_app biss_status1: SL1 (Bit 0)                   */
#define biss0_app_biss_status1_SL1_Msk    (0x1UL)                   /*!< biss0_app biss_status1: SL1 (Bitfield-Mask: 0x01)     */


/* =========================================================================================================================== */
/* ================                                         biss1_app                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  biss_scdata0_0  ===================================================== */
#define biss1_app_biss_scdata0_0_SCDATA0_0_Pos (0UL)                /*!< biss1_app biss_scdata0_0: SCDATA0_0 (Bit 0)           */
#define biss1_app_biss_scdata0_0_SCDATA0_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata0_0: SCDATA0_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata0_1  ===================================================== */
#define biss1_app_biss_scdata0_1_SCDATA0_1_Pos (0UL)                /*!< biss1_app biss_scdata0_1: SCDATA0_1 (Bit 0)           */
#define biss1_app_biss_scdata0_1_SCDATA0_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata0_1: SCDATA0_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata1_0  ===================================================== */
#define biss1_app_biss_scdata1_0_SCDATA1_0_Pos (0UL)                /*!< biss1_app biss_scdata1_0: SCDATA1_0 (Bit 0)           */
#define biss1_app_biss_scdata1_0_SCDATA1_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata1_0: SCDATA1_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata1_1  ===================================================== */
#define biss1_app_biss_scdata1_1_SCDATA1_1_Pos (0UL)                /*!< biss1_app biss_scdata1_1: SCDATA1_1 (Bit 0)           */
#define biss1_app_biss_scdata1_1_SCDATA1_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata1_1: SCDATA1_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata2_0  ===================================================== */
#define biss1_app_biss_scdata2_0_SCDATA2_0_Pos (0UL)                /*!< biss1_app biss_scdata2_0: SCDATA2_0 (Bit 0)           */
#define biss1_app_biss_scdata2_0_SCDATA2_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata2_0: SCDATA2_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata2_1  ===================================================== */
#define biss1_app_biss_scdata2_1_SCDATA2_1_Pos (0UL)                /*!< biss1_app biss_scdata2_1: SCDATA2_1 (Bit 0)           */
#define biss1_app_biss_scdata2_1_SCDATA2_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata2_1: SCDATA2_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata3_0  ===================================================== */
#define biss1_app_biss_scdata3_0_SCDATA3_0_Pos (0UL)                /*!< biss1_app biss_scdata3_0: SCDATA3_0 (Bit 0)           */
#define biss1_app_biss_scdata3_0_SCDATA3_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata3_0: SCDATA3_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata3_1  ===================================================== */
#define biss1_app_biss_scdata3_1_SCDATA3_1_Pos (0UL)                /*!< biss1_app biss_scdata3_1: SCDATA3_1 (Bit 0)           */
#define biss1_app_biss_scdata3_1_SCDATA3_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata3_1: SCDATA3_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata4_0  ===================================================== */
#define biss1_app_biss_scdata4_0_SCDATA4_0_Pos (0UL)                /*!< biss1_app biss_scdata4_0: SCDATA4_0 (Bit 0)           */
#define biss1_app_biss_scdata4_0_SCDATA4_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata4_0: SCDATA4_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata4_1  ===================================================== */
#define biss1_app_biss_scdata4_1_SCDATA4_1_Pos (0UL)                /*!< biss1_app biss_scdata4_1: SCDATA4_1 (Bit 0)           */
#define biss1_app_biss_scdata4_1_SCDATA4_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata4_1: SCDATA4_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata5_0  ===================================================== */
#define biss1_app_biss_scdata5_0_SCDATA5_0_Pos (0UL)                /*!< biss1_app biss_scdata5_0: SCDATA5_0 (Bit 0)           */
#define biss1_app_biss_scdata5_0_SCDATA5_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata5_0: SCDATA5_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata5_1  ===================================================== */
#define biss1_app_biss_scdata5_1_SCDATA5_1_Pos (0UL)                /*!< biss1_app biss_scdata5_1: SCDATA5_1 (Bit 0)           */
#define biss1_app_biss_scdata5_1_SCDATA5_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata5_1: SCDATA5_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata6_0  ===================================================== */
#define biss1_app_biss_scdata6_0_SCDATA6_0_Pos (0UL)                /*!< biss1_app biss_scdata6_0: SCDATA6_0 (Bit 0)           */
#define biss1_app_biss_scdata6_0_SCDATA6_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata6_0: SCDATA6_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata6_1  ===================================================== */
#define biss1_app_biss_scdata6_1_SCDATA6_1_Pos (0UL)                /*!< biss1_app biss_scdata6_1: SCDATA6_1 (Bit 0)           */
#define biss1_app_biss_scdata6_1_SCDATA6_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata6_1: SCDATA6_1 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata7_0  ===================================================== */
#define biss1_app_biss_scdata7_0_SCDATA7_0_Pos (0UL)                /*!< biss1_app biss_scdata7_0: SCDATA7_0 (Bit 0)           */
#define biss1_app_biss_scdata7_0_SCDATA7_0_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata7_0: SCDATA7_0 (Bitfield-Mask: 0xffffffff) */
/* ====================================================  biss_scdata7_1  ===================================================== */
#define biss1_app_biss_scdata7_1_SCDATA7_1_Pos (0UL)                /*!< biss1_app biss_scdata7_1: SCDATA7_1 (Bit 0)           */
#define biss1_app_biss_scdata7_1_SCDATA7_1_Msk (0xffffffffUL)       /*!< biss1_app biss_scdata7_1: SCDATA7_1 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata0  ====================================================== */
#define biss1_app_biss_rdata0_RDATA0_Pos  (0UL)                     /*!< biss1_app biss_rdata0: RDATA0 (Bit 0)                 */
#define biss1_app_biss_rdata0_RDATA0_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata0: RDATA0 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata1  ====================================================== */
#define biss1_app_biss_rdata1_RDATA1_Pos  (0UL)                     /*!< biss1_app biss_rdata1: RDATA1 (Bit 0)                 */
#define biss1_app_biss_rdata1_RDATA1_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata1: RDATA1 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata2  ====================================================== */
#define biss1_app_biss_rdata2_RDATA2_Pos  (0UL)                     /*!< biss1_app biss_rdata2: RDATA2 (Bit 0)                 */
#define biss1_app_biss_rdata2_RDATA2_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata2: RDATA2 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata3  ====================================================== */
#define biss1_app_biss_rdata3_RDATA3_Pos  (0UL)                     /*!< biss1_app biss_rdata3: RDATA3 (Bit 0)                 */
#define biss1_app_biss_rdata3_RDATA3_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata3: RDATA3 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata4  ====================================================== */
#define biss1_app_biss_rdata4_RDATA4_Pos  (0UL)                     /*!< biss1_app biss_rdata4: RDATA4 (Bit 0)                 */
#define biss1_app_biss_rdata4_RDATA4_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata4: RDATA4 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata5  ====================================================== */
#define biss1_app_biss_rdata5_RDATA5_Pos  (0UL)                     /*!< biss1_app biss_rdata5: RDATA5 (Bit 0)                 */
#define biss1_app_biss_rdata5_RDATA5_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata5: RDATA5 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata6  ====================================================== */
#define biss1_app_biss_rdata6_RDATA6_Pos  (0UL)                     /*!< biss1_app biss_rdata6: RDATA6 (Bit 0)                 */
#define biss1_app_biss_rdata6_RDATA6_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata6: RDATA6 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata7  ====================================================== */
#define biss1_app_biss_rdata7_RDATA7_Pos  (0UL)                     /*!< biss1_app biss_rdata7: RDATA7 (Bit 0)                 */
#define biss1_app_biss_rdata7_RDATA7_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata7: RDATA7 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata8  ====================================================== */
#define biss1_app_biss_rdata8_RDATA8_Pos  (0UL)                     /*!< biss1_app biss_rdata8: RDATA8 (Bit 0)                 */
#define biss1_app_biss_rdata8_RDATA8_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata8: RDATA8 (Bitfield-Mask: 0xffffffff) */
/* ======================================================  biss_rdata9  ====================================================== */
#define biss1_app_biss_rdata9_RDATA9_Pos  (0UL)                     /*!< biss1_app biss_rdata9: RDATA9 (Bit 0)                 */
#define biss1_app_biss_rdata9_RDATA9_Msk  (0xffffffffUL)            /*!< biss1_app biss_rdata9: RDATA9 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata10  ====================================================== */
#define biss1_app_biss_rdata10_RDATA10_Pos (0UL)                    /*!< biss1_app biss_rdata10: RDATA10 (Bit 0)               */
#define biss1_app_biss_rdata10_RDATA10_Msk (0xffffffffUL)           /*!< biss1_app biss_rdata10: RDATA10 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata11  ====================================================== */
#define biss1_app_biss_rdata11_RDATA11_Pos (0UL)                    /*!< biss1_app biss_rdata11: RDATA11 (Bit 0)               */
#define biss1_app_biss_rdata11_RDATA11_Msk (0xffffffffUL)           /*!< biss1_app biss_rdata11: RDATA11 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata12  ====================================================== */
#define biss1_app_biss_rdata12_RDATA12_Pos (0UL)                    /*!< biss1_app biss_rdata12: RDATA12 (Bit 0)               */
#define biss1_app_biss_rdata12_RDATA12_Msk (0xffffffffUL)           /*!< biss1_app biss_rdata12: RDATA12 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata13  ====================================================== */
#define biss1_app_biss_rdata13_RDATA13_Pos (0UL)                    /*!< biss1_app biss_rdata13: RDATA13 (Bit 0)               */
#define biss1_app_biss_rdata13_RDATA13_Msk (0xffffffffUL)           /*!< biss1_app biss_rdata13: RDATA13 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata14  ====================================================== */
#define biss1_app_biss_rdata14_RDATA14_Pos (0UL)                    /*!< biss1_app biss_rdata14: RDATA14 (Bit 0)               */
#define biss1_app_biss_rdata14_RDATA14_Msk (0xffffffffUL)           /*!< biss1_app biss_rdata14: RDATA14 (Bitfield-Mask: 0xffffffff) */
/* =====================================================  biss_rdata15  ====================================================== */
#define biss1_app_biss_rdata15_RDATA15_Pos (0UL)                    /*!< biss1_app biss_rdata15: RDATA15 (Bit 0)               */
#define biss1_app_biss_rdata15_RDATA15_Msk (0xffffffffUL)           /*!< biss1_app biss_rdata15: RDATA15 (Bitfield-Mask: 0xffffffff) */
/* =======================================================  biss_sc0  ======================================================== */
#define biss1_app_biss_sc0_SCRCSTART0_Pos (16UL)                    /*!< biss1_app biss_sc0: SCRCSTART0 (Bit 16)               */
#define biss1_app_biss_sc0_SCRCSTART0_Msk (0xffff0000UL)            /*!< biss1_app biss_sc0: SCRCSTART0 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc0_SELCRCS0_Pos   (15UL)                    /*!< biss1_app biss_sc0: SELCRCS0 (Bit 15)                 */
#define biss1_app_biss_sc0_SELCRCS0_Msk   (0x8000UL)                /*!< biss1_app biss_sc0: SELCRCS0 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc0_SCRCPOLY0_Pos  (8UL)                     /*!< biss1_app biss_sc0: SCRCPOLY0 (Bit 8)                 */
#define biss1_app_biss_sc0_SCRCPOLY0_Msk  (0x7f00UL)                /*!< biss1_app biss_sc0: SCRCPOLY0 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc0_LSTOP0_Pos     (7UL)                     /*!< biss1_app biss_sc0: LSTOP0 (Bit 7)                    */
#define biss1_app_biss_sc0_LSTOP0_Msk     (0x80UL)                  /*!< biss1_app biss_sc0: LSTOP0 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc0_ENSCD0_Pos     (6UL)                     /*!< biss1_app biss_sc0: ENSCD0 (Bit 6)                    */
#define biss1_app_biss_sc0_ENSCD0_Msk     (0x40UL)                  /*!< biss1_app biss_sc0: ENSCD0 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc0_SCDLEN0_Pos    (0UL)                     /*!< biss1_app biss_sc0: SCDLEN0 (Bit 0)                   */
#define biss1_app_biss_sc0_SCDLEN0_Msk    (0x3fUL)                  /*!< biss1_app biss_sc0: SCDLEN0 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc1  ======================================================== */
#define biss1_app_biss_sc1_SCRCSTART1_Pos (16UL)                    /*!< biss1_app biss_sc1: SCRCSTART1 (Bit 16)               */
#define biss1_app_biss_sc1_SCRCSTART1_Msk (0xffff0000UL)            /*!< biss1_app biss_sc1: SCRCSTART1 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc1_SELCRCS1_Pos   (15UL)                    /*!< biss1_app biss_sc1: SELCRCS1 (Bit 15)                 */
#define biss1_app_biss_sc1_SELCRCS1_Msk   (0x8000UL)                /*!< biss1_app biss_sc1: SELCRCS1 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc1_SCRCPOLY1_Pos  (8UL)                     /*!< biss1_app biss_sc1: SCRCPOLY1 (Bit 8)                 */
#define biss1_app_biss_sc1_SCRCPOLY1_Msk  (0x7f00UL)                /*!< biss1_app biss_sc1: SCRCPOLY1 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc1_LSTOP1_Pos     (7UL)                     /*!< biss1_app biss_sc1: LSTOP1 (Bit 7)                    */
#define biss1_app_biss_sc1_LSTOP1_Msk     (0x80UL)                  /*!< biss1_app biss_sc1: LSTOP1 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc1_ENSCD1_Pos     (6UL)                     /*!< biss1_app biss_sc1: ENSCD1 (Bit 6)                    */
#define biss1_app_biss_sc1_ENSCD1_Msk     (0x40UL)                  /*!< biss1_app biss_sc1: ENSCD1 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc1_SCDLEN1_Pos    (0UL)                     /*!< biss1_app biss_sc1: SCDLEN1 (Bit 0)                   */
#define biss1_app_biss_sc1_SCDLEN1_Msk    (0x3fUL)                  /*!< biss1_app biss_sc1: SCDLEN1 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc2  ======================================================== */
#define biss1_app_biss_sc2_SCRCSTART2_Pos (16UL)                    /*!< biss1_app biss_sc2: SCRCSTART2 (Bit 16)               */
#define biss1_app_biss_sc2_SCRCSTART2_Msk (0xffff0000UL)            /*!< biss1_app biss_sc2: SCRCSTART2 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc2_SELCRCS2_Pos   (15UL)                    /*!< biss1_app biss_sc2: SELCRCS2 (Bit 15)                 */
#define biss1_app_biss_sc2_SELCRCS2_Msk   (0x8000UL)                /*!< biss1_app biss_sc2: SELCRCS2 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc2_SCRCPOLY2_Pos  (8UL)                     /*!< biss1_app biss_sc2: SCRCPOLY2 (Bit 8)                 */
#define biss1_app_biss_sc2_SCRCPOLY2_Msk  (0x7f00UL)                /*!< biss1_app biss_sc2: SCRCPOLY2 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc2_LSTOP2_Pos     (7UL)                     /*!< biss1_app biss_sc2: LSTOP2 (Bit 7)                    */
#define biss1_app_biss_sc2_LSTOP2_Msk     (0x80UL)                  /*!< biss1_app biss_sc2: LSTOP2 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc2_ENSCD2_Pos     (6UL)                     /*!< biss1_app biss_sc2: ENSCD2 (Bit 6)                    */
#define biss1_app_biss_sc2_ENSCD2_Msk     (0x40UL)                  /*!< biss1_app biss_sc2: ENSCD2 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc2_SCDLEN2_Pos    (0UL)                     /*!< biss1_app biss_sc2: SCDLEN2 (Bit 0)                   */
#define biss1_app_biss_sc2_SCDLEN2_Msk    (0x3fUL)                  /*!< biss1_app biss_sc2: SCDLEN2 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc3  ======================================================== */
#define biss1_app_biss_sc3_SCRCSTART3_Pos (16UL)                    /*!< biss1_app biss_sc3: SCRCSTART3 (Bit 16)               */
#define biss1_app_biss_sc3_SCRCSTART3_Msk (0xffff0000UL)            /*!< biss1_app biss_sc3: SCRCSTART3 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc3_SELCRCS3_Pos   (15UL)                    /*!< biss1_app biss_sc3: SELCRCS3 (Bit 15)                 */
#define biss1_app_biss_sc3_SELCRCS3_Msk   (0x8000UL)                /*!< biss1_app biss_sc3: SELCRCS3 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc3_SCRCPOLY3_Pos  (8UL)                     /*!< biss1_app biss_sc3: SCRCPOLY3 (Bit 8)                 */
#define biss1_app_biss_sc3_SCRCPOLY3_Msk  (0x7f00UL)                /*!< biss1_app biss_sc3: SCRCPOLY3 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc3_LSTOP3_Pos     (7UL)                     /*!< biss1_app biss_sc3: LSTOP3 (Bit 7)                    */
#define biss1_app_biss_sc3_LSTOP3_Msk     (0x80UL)                  /*!< biss1_app biss_sc3: LSTOP3 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc3_ENSCD3_Pos     (6UL)                     /*!< biss1_app biss_sc3: ENSCD3 (Bit 6)                    */
#define biss1_app_biss_sc3_ENSCD3_Msk     (0x40UL)                  /*!< biss1_app biss_sc3: ENSCD3 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc3_SCDLEN3_Pos    (0UL)                     /*!< biss1_app biss_sc3: SCDLEN3 (Bit 0)                   */
#define biss1_app_biss_sc3_SCDLEN3_Msk    (0x3fUL)                  /*!< biss1_app biss_sc3: SCDLEN3 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc4  ======================================================== */
#define biss1_app_biss_sc4_SCRCSTART4_Pos (16UL)                    /*!< biss1_app biss_sc4: SCRCSTART4 (Bit 16)               */
#define biss1_app_biss_sc4_SCRCSTART4_Msk (0xffff0000UL)            /*!< biss1_app biss_sc4: SCRCSTART4 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc4_SELCRCS4_Pos   (15UL)                    /*!< biss1_app biss_sc4: SELCRCS4 (Bit 15)                 */
#define biss1_app_biss_sc4_SELCRCS4_Msk   (0x8000UL)                /*!< biss1_app biss_sc4: SELCRCS4 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc4_SCRCPOLY4_Pos  (8UL)                     /*!< biss1_app biss_sc4: SCRCPOLY4 (Bit 8)                 */
#define biss1_app_biss_sc4_SCRCPOLY4_Msk  (0x7f00UL)                /*!< biss1_app biss_sc4: SCRCPOLY4 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc4_LSTOP4_Pos     (7UL)                     /*!< biss1_app biss_sc4: LSTOP4 (Bit 7)                    */
#define biss1_app_biss_sc4_LSTOP4_Msk     (0x80UL)                  /*!< biss1_app biss_sc4: LSTOP4 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc4_ENSCD4_Pos     (6UL)                     /*!< biss1_app biss_sc4: ENSCD4 (Bit 6)                    */
#define biss1_app_biss_sc4_ENSCD4_Msk     (0x40UL)                  /*!< biss1_app biss_sc4: ENSCD4 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc4_SCDLEN4_Pos    (0UL)                     /*!< biss1_app biss_sc4: SCDLEN4 (Bit 0)                   */
#define biss1_app_biss_sc4_SCDLEN4_Msk    (0x3fUL)                  /*!< biss1_app biss_sc4: SCDLEN4 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc5  ======================================================== */
#define biss1_app_biss_sc5_SCRCSTART5_Pos (16UL)                    /*!< biss1_app biss_sc5: SCRCSTART5 (Bit 16)               */
#define biss1_app_biss_sc5_SCRCSTART5_Msk (0xffff0000UL)            /*!< biss1_app biss_sc5: SCRCSTART5 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc5_SELCRCS5_Pos   (15UL)                    /*!< biss1_app biss_sc5: SELCRCS5 (Bit 15)                 */
#define biss1_app_biss_sc5_SELCRCS5_Msk   (0x8000UL)                /*!< biss1_app biss_sc5: SELCRCS5 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc5_SCRCPOLY5_Pos  (8UL)                     /*!< biss1_app biss_sc5: SCRCPOLY5 (Bit 8)                 */
#define biss1_app_biss_sc5_SCRCPOLY5_Msk  (0x7f00UL)                /*!< biss1_app biss_sc5: SCRCPOLY5 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc5_LSTOP5_Pos     (7UL)                     /*!< biss1_app biss_sc5: LSTOP5 (Bit 7)                    */
#define biss1_app_biss_sc5_LSTOP5_Msk     (0x80UL)                  /*!< biss1_app biss_sc5: LSTOP5 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc5_ENSCD5_Pos     (6UL)                     /*!< biss1_app biss_sc5: ENSCD5 (Bit 6)                    */
#define biss1_app_biss_sc5_ENSCD5_Msk     (0x40UL)                  /*!< biss1_app biss_sc5: ENSCD5 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc5_SCDLEN5_Pos    (0UL)                     /*!< biss1_app biss_sc5: SCDLEN5 (Bit 0)                   */
#define biss1_app_biss_sc5_SCDLEN5_Msk    (0x3fUL)                  /*!< biss1_app biss_sc5: SCDLEN5 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc6  ======================================================== */
#define biss1_app_biss_sc6_SCRCSTART6_Pos (16UL)                    /*!< biss1_app biss_sc6: SCRCSTART6 (Bit 16)               */
#define biss1_app_biss_sc6_SCRCSTART6_Msk (0xffff0000UL)            /*!< biss1_app biss_sc6: SCRCSTART6 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc6_SELCRCS6_Pos   (15UL)                    /*!< biss1_app biss_sc6: SELCRCS6 (Bit 15)                 */
#define biss1_app_biss_sc6_SELCRCS6_Msk   (0x8000UL)                /*!< biss1_app biss_sc6: SELCRCS6 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc6_SCRCPOLY6_Pos  (8UL)                     /*!< biss1_app biss_sc6: SCRCPOLY6 (Bit 8)                 */
#define biss1_app_biss_sc6_SCRCPOLY6_Msk  (0x7f00UL)                /*!< biss1_app biss_sc6: SCRCPOLY6 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc6_LSTOP6_Pos     (7UL)                     /*!< biss1_app biss_sc6: LSTOP6 (Bit 7)                    */
#define biss1_app_biss_sc6_LSTOP6_Msk     (0x80UL)                  /*!< biss1_app biss_sc6: LSTOP6 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc6_ENSCD6_Pos     (6UL)                     /*!< biss1_app biss_sc6: ENSCD6 (Bit 6)                    */
#define biss1_app_biss_sc6_ENSCD6_Msk     (0x40UL)                  /*!< biss1_app biss_sc6: ENSCD6 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc6_SCDLEN6_Pos    (0UL)                     /*!< biss1_app biss_sc6: SCDLEN6 (Bit 0)                   */
#define biss1_app_biss_sc6_SCDLEN6_Msk    (0x3fUL)                  /*!< biss1_app biss_sc6: SCDLEN6 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_sc7  ======================================================== */
#define biss1_app_biss_sc7_SCRCSTART7_Pos (16UL)                    /*!< biss1_app biss_sc7: SCRCSTART7 (Bit 16)               */
#define biss1_app_biss_sc7_SCRCSTART7_Msk (0xffff0000UL)            /*!< biss1_app biss_sc7: SCRCSTART7 (Bitfield-Mask: 0xffff) */
#define biss1_app_biss_sc7_SELCRCS7_Pos   (15UL)                    /*!< biss1_app biss_sc7: SELCRCS7 (Bit 15)                 */
#define biss1_app_biss_sc7_SELCRCS7_Msk   (0x8000UL)                /*!< biss1_app biss_sc7: SELCRCS7 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_sc7_SCRCPOLY7_Pos  (8UL)                     /*!< biss1_app biss_sc7: SCRCPOLY7 (Bit 8)                 */
#define biss1_app_biss_sc7_SCRCPOLY7_Msk  (0x7f00UL)                /*!< biss1_app biss_sc7: SCRCPOLY7 (Bitfield-Mask: 0x7f)   */
#define biss1_app_biss_sc7_LSTOP7_Pos     (7UL)                     /*!< biss1_app biss_sc7: LSTOP7 (Bit 7)                    */
#define biss1_app_biss_sc7_LSTOP7_Msk     (0x80UL)                  /*!< biss1_app biss_sc7: LSTOP7 (Bitfield-Mask: 0x01)      */
#define biss1_app_biss_sc7_ENSC7_Pos      (6UL)                     /*!< biss1_app biss_sc7: ENSC7 (Bit 6)                     */
#define biss1_app_biss_sc7_ENSC7_Msk      (0x40UL)                  /*!< biss1_app biss_sc7: ENSC7 (Bitfield-Mask: 0x01)       */
#define biss1_app_biss_sc7_SCDLEN7_Pos    (0UL)                     /*!< biss1_app biss_sc7: SCDLEN7 (Bit 0)                   */
#define biss1_app_biss_sc7_SCDLEN7_Msk    (0x3fUL)                  /*!< biss1_app biss_sc7: SCDLEN7 (Bitfield-Mask: 0x3f)     */
/* =======================================================  biss_ccc0  ======================================================= */
#define biss1_app_biss_ccc0_reserved1_Pos (30UL)                    /*!< biss1_app biss_ccc0: reserved1 (Bit 30)               */
#define biss1_app_biss_ccc0_reserved1_Msk (0xc0000000UL)            /*!< biss1_app biss_ccc0: reserved1 (Bitfield-Mask: 0x03)  */
#define biss1_app_biss_ccc0_REGNUM_Pos    (24UL)                    /*!< biss1_app biss_ccc0: REGNUM (Bit 24)                  */
#define biss1_app_biss_ccc0_REGNUM_Msk    (0x3f000000UL)            /*!< biss1_app biss_ccc0: REGNUM (Bitfield-Mask: 0x3f)     */
#define biss1_app_biss_ccc0_WNR_Pos       (23UL)                    /*!< biss1_app biss_ccc0: WNR (Bit 23)                     */
#define biss1_app_biss_ccc0_WNR_Msk       (0x800000UL)              /*!< biss1_app biss_ccc0: WNR (Bitfield-Mask: 0x01)        */
#define biss1_app_biss_ccc0_REGADR_Pos    (16UL)                    /*!< biss1_app biss_ccc0: REGADR (Bit 16)                  */
#define biss1_app_biss_ccc0_REGADR_Msk    (0x7f0000UL)              /*!< biss1_app biss_ccc0: REGADR (Bitfield-Mask: 0x7f)     */
#define biss1_app_biss_ccc0_reserved0_Pos (0UL)                     /*!< biss1_app biss_ccc0: reserved0 (Bit 0)                */
#define biss1_app_biss_ccc0_reserved0_Msk (0xffffUL)                /*!< biss1_app biss_ccc0: reserved0 (Bitfield-Mask: 0xffff) */
/* =====================================================  biss_ccc1_mc0  ===================================================== */
#define biss1_app_biss_ccc1_mc0_reserved2_Pos (26UL)                /*!< biss1_app biss_ccc1_mc0: reserved2 (Bit 26)           */
#define biss1_app_biss_ccc1_mc0_reserved2_Msk (0xfc000000UL)        /*!< biss1_app biss_ccc1_mc0: reserved2 (Bitfield-Mask: 0x3f) */
#define biss1_app_biss_ccc1_mc0_NOCRC_Pos (25UL)                    /*!< biss1_app biss_ccc1_mc0: NOCRC (Bit 25)               */
#define biss1_app_biss_ccc1_mc0_NOCRC_Msk (0x2000000UL)             /*!< biss1_app biss_ccc1_mc0: NOCRC (Bitfield-Mask: 0x01)  */
#define biss1_app_biss_ccc1_mc0_SINGLEBANK_Pos (24UL)               /*!< biss1_app biss_ccc1_mc0: SINGLEBANK (Bit 24)          */
#define biss1_app_biss_ccc1_mc0_SINGLEBANK_Msk (0x1000000UL)        /*!< biss1_app biss_ccc1_mc0: SINGLEBANK (Bitfield-Mask: 0x01) */
#define biss1_app_biss_ccc1_mc0_FREQR_Pos (21UL)                    /*!< biss1_app biss_ccc1_mc0: FREQR (Bit 21)               */
#define biss1_app_biss_ccc1_mc0_FREQR_Msk (0xe00000UL)              /*!< biss1_app biss_ccc1_mc0: FREQR (Bitfield-Mask: 0x07)  */
#define biss1_app_biss_ccc1_mc0_FREQS_Pos (16UL)                    /*!< biss1_app biss_ccc1_mc0: FREQS (Bit 16)               */
#define biss1_app_biss_ccc1_mc0_FREQS_Msk (0x1f0000UL)              /*!< biss1_app biss_ccc1_mc0: FREQS (Bitfield-Mask: 0x1f)  */
#define biss1_app_biss_ccc1_mc0_CTS_Pos   (15UL)                    /*!< biss1_app biss_ccc1_mc0: CTS (Bit 15)                 */
#define biss1_app_biss_ccc1_mc0_CTS_Msk   (0x8000UL)                /*!< biss1_app biss_ccc1_mc0: CTS (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_ccc1_mc0_REGVERS_Pos (14UL)                  /*!< biss1_app biss_ccc1_mc0: REGVERS (Bit 14)             */
#define biss1_app_biss_ccc1_mc0_REGVERS_Msk (0x4000UL)              /*!< biss1_app biss_ccc1_mc0: REGVERS (Bitfield-Mask: 0x01) */
#define biss1_app_biss_ccc1_mc0_CMD_Pos   (12UL)                    /*!< biss1_app biss_ccc1_mc0: CMD (Bit 12)                 */
#define biss1_app_biss_ccc1_mc0_CMD_Msk   (0x3000UL)                /*!< biss1_app biss_ccc1_mc0: CMD (Bitfield-Mask: 0x03)    */
#define biss1_app_biss_ccc1_mc0_IDA_TEST_Pos (11UL)                 /*!< biss1_app biss_ccc1_mc0: IDA_TEST (Bit 11)            */
#define biss1_app_biss_ccc1_mc0_IDA_TEST_Msk (0x800UL)              /*!< biss1_app biss_ccc1_mc0: IDA_TEST (Bitfield-Mask: 0x01) */
#define biss1_app_biss_ccc1_mc0_reserved1_Pos (10UL)                /*!< biss1_app biss_ccc1_mc0: reserved1 (Bit 10)           */
#define biss1_app_biss_ccc1_mc0_reserved1_Msk (0x400UL)             /*!< biss1_app biss_ccc1_mc0: reserved1 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_ccc1_mc0_EN_MO_Pos (9UL)                     /*!< biss1_app biss_ccc1_mc0: EN_MO (Bit 9)                */
#define biss1_app_biss_ccc1_mc0_EN_MO_Msk (0x200UL)                 /*!< biss1_app biss_ccc1_mc0: EN_MO (Bitfield-Mask: 0x01)  */
#define biss1_app_biss_ccc1_mc0_HOLDCDM_Pos (8UL)                   /*!< biss1_app biss_ccc1_mc0: HOLDCDM (Bit 8)              */
#define biss1_app_biss_ccc1_mc0_HOLDCDM_Msk (0x100UL)               /*!< biss1_app biss_ccc1_mc0: HOLDCDM (Bitfield-Mask: 0x01) */
#define biss1_app_biss_ccc1_mc0_reserved0_Pos (2UL)                 /*!< biss1_app biss_ccc1_mc0: reserved0 (Bit 2)            */
#define biss1_app_biss_ccc1_mc0_reserved0_Msk (0xfcUL)              /*!< biss1_app biss_ccc1_mc0: reserved0 (Bitfield-Mask: 0x3f) */
#define biss1_app_biss_ccc1_mc0_CHSEL_Pos (0UL)                     /*!< biss1_app biss_ccc1_mc0: CHSEL (Bit 0)                */
#define biss1_app_biss_ccc1_mc0_CHSEL_Msk (0x3UL)                   /*!< biss1_app biss_ccc1_mc0: CHSEL (Bitfield-Mask: 0x03)  */
/* =======================================================  biss_mc1  ======================================================== */
#define biss1_app_biss_mc1_VERSION_Pos    (24UL)                    /*!< biss1_app biss_mc1: VERSION (Bit 24)                  */
#define biss1_app_biss_mc1_VERSION_Msk    (0xff000000UL)            /*!< biss1_app biss_mc1: VERSION (Bitfield-Mask: 0xff)     */
#define biss1_app_biss_mc1_REVISION_Pos   (16UL)                    /*!< biss1_app biss_mc1: REVISION (Bit 16)                 */
#define biss1_app_biss_mc1_REVISION_Msk   (0xff0000UL)              /*!< biss1_app biss_mc1: REVISION (Bitfield-Mask: 0xff)    */
#define biss1_app_biss_mc1_MO_BUSY_Pos    (8UL)                     /*!< biss1_app biss_mc1: MO_BUSY (Bit 8)                   */
#define biss1_app_biss_mc1_MO_BUSY_Msk    (0xff00UL)                /*!< biss1_app biss_mc1: MO_BUSY (Bitfield-Mask: 0xff)     */
#define biss1_app_biss_mc1_FREQAGS_Pos    (0UL)                     /*!< biss1_app biss_mc1: FREQAGS (Bit 0)                   */
#define biss1_app_biss_mc1_FREQAGS_Msk    (0xffUL)                  /*!< biss1_app biss_mc1: FREQAGS (Bitfield-Mask: 0xff)     */
/* ======================================================  biss_cc_sl  ======================================================= */
#define biss1_app_biss_cc_sl_ACTnSENS_Pos (24UL)                    /*!< biss1_app biss_cc_sl: ACTnSENS (Bit 24)               */
#define biss1_app_biss_cc_sl_ACTnSENS_Msk (0xff000000UL)            /*!< biss1_app biss_cc_sl: ACTnSENS (Bitfield-Mask: 0xff)  */
#define biss1_app_biss_cc_sl_reserved1_Pos (12UL)                   /*!< biss1_app biss_cc_sl: reserved1 (Bit 12)              */
#define biss1_app_biss_cc_sl_reserved1_Msk (0xfff000UL)             /*!< biss1_app biss_cc_sl: reserved1 (Bitfield-Mask: 0xfff) */
#define biss1_app_biss_cc_sl_CFGCH2_Pos   (10UL)                    /*!< biss1_app biss_cc_sl: CFGCH2 (Bit 10)                 */
#define biss1_app_biss_cc_sl_CFGCH2_Msk   (0xc00UL)                 /*!< biss1_app biss_cc_sl: CFGCH2 (Bitfield-Mask: 0x03)    */
#define biss1_app_biss_cc_sl_CFGCH1_Pos   (8UL)                     /*!< biss1_app biss_cc_sl: CFGCH1 (Bit 8)                  */
#define biss1_app_biss_cc_sl_CFGCH1_Msk   (0x300UL)                 /*!< biss1_app biss_cc_sl: CFGCH1 (Bitfield-Mask: 0x03)    */
#define biss1_app_biss_cc_sl_reserved0_Pos (5UL)                    /*!< biss1_app biss_cc_sl: reserved0 (Bit 5)               */
#define biss1_app_biss_cc_sl_reserved0_Msk (0xe0UL)                 /*!< biss1_app biss_cc_sl: reserved0 (Bitfield-Mask: 0x07) */
#define biss1_app_biss_cc_sl_SLAVELOC5_Pos (4UL)                    /*!< biss1_app biss_cc_sl: SLAVELOC5 (Bit 4)               */
#define biss1_app_biss_cc_sl_SLAVELOC5_Msk (0x10UL)                 /*!< biss1_app biss_cc_sl: SLAVELOC5 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_cc_sl_cc_sl_reserved1_Pos (0UL)              /*!< biss1_app biss_cc_sl: cc_sl_reserved1 (Bit 0)         */
#define biss1_app_biss_cc_sl_cc_sl_reserved1_Msk (0xfUL)            /*!< biss1_app biss_cc_sl: cc_sl_reserved1 (Bitfield-Mask: 0x0f) */
/* =====================================================  biss_status0  ====================================================== */
#define biss1_app_biss_status0_CDMTIMEOUT_Pos (31UL)                /*!< biss1_app biss_status0: CDMTIMEOUT (Bit 31)           */
#define biss1_app_biss_status0_CDMTIMEOUT_Msk (0x80000000UL)        /*!< biss1_app biss_status0: CDMTIMEOUT (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_CDSSEL_Pos (30UL)                    /*!< biss1_app biss_status0: CDSSEL (Bit 30)               */
#define biss1_app_biss_status0_CDSSEL_Msk (0x40000000UL)            /*!< biss1_app biss_status0: CDSSEL (Bitfield-Mask: 0x01)  */
#define biss1_app_biss_status0_REGBYTES_Pos (24UL)                  /*!< biss1_app biss_status0: REGBYTES (Bit 24)             */
#define biss1_app_biss_status0_REGBYTES_Msk (0x3f000000UL)          /*!< biss1_app biss_status0: REGBYTES (Bitfield-Mask: 0x3f) */
#define biss1_app_biss_status0_SVALID7_Pos (23UL)                   /*!< biss1_app biss_status0: SVALID7 (Bit 23)              */
#define biss1_app_biss_status0_SVALID7_Msk (0x800000UL)             /*!< biss1_app biss_status0: SVALID7 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved7_Pos (22UL)                 /*!< biss1_app biss_status0: reserved7 (Bit 22)            */
#define biss1_app_biss_status0_reserved7_Msk (0x400000UL)           /*!< biss1_app biss_status0: reserved7 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_SVALID6_Pos (21UL)                   /*!< biss1_app biss_status0: SVALID6 (Bit 21)              */
#define biss1_app_biss_status0_SVALID6_Msk (0x200000UL)             /*!< biss1_app biss_status0: SVALID6 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved6_Pos (20UL)                 /*!< biss1_app biss_status0: reserved6 (Bit 20)            */
#define biss1_app_biss_status0_reserved6_Msk (0x100000UL)           /*!< biss1_app biss_status0: reserved6 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_SVALID5_Pos (19UL)                   /*!< biss1_app biss_status0: SVALID5 (Bit 19)              */
#define biss1_app_biss_status0_SVALID5_Msk (0x80000UL)              /*!< biss1_app biss_status0: SVALID5 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved5_Pos (18UL)                 /*!< biss1_app biss_status0: reserved5 (Bit 18)            */
#define biss1_app_biss_status0_reserved5_Msk (0x40000UL)            /*!< biss1_app biss_status0: reserved5 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_SVALID4_Pos (17UL)                   /*!< biss1_app biss_status0: SVALID4 (Bit 17)              */
#define biss1_app_biss_status0_SVALID4_Msk (0x20000UL)              /*!< biss1_app biss_status0: SVALID4 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved4_Pos (16UL)                 /*!< biss1_app biss_status0: reserved4 (Bit 16)            */
#define biss1_app_biss_status0_reserved4_Msk (0x10000UL)            /*!< biss1_app biss_status0: reserved4 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_SVALID3_Pos (15UL)                   /*!< biss1_app biss_status0: SVALID3 (Bit 15)              */
#define biss1_app_biss_status0_SVALID3_Msk (0x8000UL)               /*!< biss1_app biss_status0: SVALID3 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved3_Pos (14UL)                 /*!< biss1_app biss_status0: reserved3 (Bit 14)            */
#define biss1_app_biss_status0_reserved3_Msk (0x4000UL)             /*!< biss1_app biss_status0: reserved3 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_SVALID2_Pos (13UL)                   /*!< biss1_app biss_status0: SVALID2 (Bit 13)              */
#define biss1_app_biss_status0_SVALID2_Msk (0x2000UL)               /*!< biss1_app biss_status0: SVALID2 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved2_Pos (12UL)                 /*!< biss1_app biss_status0: reserved2 (Bit 12)            */
#define biss1_app_biss_status0_reserved2_Msk (0x1000UL)             /*!< biss1_app biss_status0: reserved2 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_SVALID1_Pos (11UL)                   /*!< biss1_app biss_status0: SVALID1 (Bit 11)              */
#define biss1_app_biss_status0_SVALID1_Msk (0x800UL)                /*!< biss1_app biss_status0: SVALID1 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved1_Pos (10UL)                 /*!< biss1_app biss_status0: reserved1 (Bit 10)            */
#define biss1_app_biss_status0_reserved1_Msk (0x400UL)              /*!< biss1_app biss_status0: reserved1 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_SVALID0_Pos (9UL)                    /*!< biss1_app biss_status0: SVALID0 (Bit 9)               */
#define biss1_app_biss_status0_SVALID0_Msk (0x200UL)                /*!< biss1_app biss_status0: SVALID0 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_reserved0_Pos (8UL)                  /*!< biss1_app biss_status0: reserved0 (Bit 8)             */
#define biss1_app_biss_status0_reserved0_Msk (0x100UL)              /*!< biss1_app biss_status0: reserved0 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_nERR_Pos   (7UL)                     /*!< biss1_app biss_status0: nERR (Bit 7)                  */
#define biss1_app_biss_status0_nERR_Msk   (0x80UL)                  /*!< biss1_app biss_status0: nERR (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_status0_nAGSERR_Pos (6UL)                    /*!< biss1_app biss_status0: nAGSERR (Bit 6)               */
#define biss1_app_biss_status0_nAGSERR_Msk (0x40UL)                 /*!< biss1_app biss_status0: nAGSERR (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_nDELAYERR_Pos (5UL)                  /*!< biss1_app biss_status0: nDELAYERR (Bit 5)             */
#define biss1_app_biss_status0_nDELAYERR_Msk (0x20UL)               /*!< biss1_app biss_status0: nDELAYERR (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_nSCDERR_Pos (4UL)                    /*!< biss1_app biss_status0: nSCDERR (Bit 4)               */
#define biss1_app_biss_status0_nSCDERR_Msk (0x10UL)                 /*!< biss1_app biss_status0: nSCDERR (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_nREGERR_Pos (3UL)                    /*!< biss1_app biss_status0: nREGERR (Bit 3)               */
#define biss1_app_biss_status0_nREGERR_Msk (0x8UL)                  /*!< biss1_app biss_status0: nREGERR (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_REGEND_Pos (2UL)                     /*!< biss1_app biss_status0: REGEND (Bit 2)                */
#define biss1_app_biss_status0_REGEND_Msk (0x4UL)                   /*!< biss1_app biss_status0: REGEND (Bitfield-Mask: 0x01)  */
#define biss1_app_biss_status0_status0_reserved1_Pos (1UL)          /*!< biss1_app biss_status0: status0_reserved1 (Bit 1)     */
#define biss1_app_biss_status0_status0_reserved1_Msk (0x2UL)        /*!< biss1_app biss_status0: status0_reserved1 (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status0_EOT_Pos    (0UL)                     /*!< biss1_app biss_status0: EOT (Bit 0)                   */
#define biss1_app_biss_status0_EOT_Msk    (0x1UL)                   /*!< biss1_app biss_status0: EOT (Bitfield-Mask: 0x01)     */
/* ========================================================  biss_ir  ======================================================== */
#define biss1_app_biss_ir_MAVO_Pos        (15UL)                    /*!< biss1_app biss_ir: MAVO (Bit 15)                      */
#define biss1_app_biss_ir_MAVO_Msk        (0x8000UL)                /*!< biss1_app biss_ir: MAVO (Bitfield-Mask: 0x01)         */
#define biss1_app_biss_ir_MAFO_Pos        (14UL)                    /*!< biss1_app biss_ir: MAFO (Bit 14)                      */
#define biss1_app_biss_ir_MAFO_Msk        (0x4000UL)                /*!< biss1_app biss_ir: MAFO (Bitfield-Mask: 0x01)         */
#define biss1_app_biss_ir_MAVS_Pos        (13UL)                    /*!< biss1_app biss_ir: MAVS (Bit 13)                      */
#define biss1_app_biss_ir_MAVS_Msk        (0x2000UL)                /*!< biss1_app biss_ir: MAVS (Bitfield-Mask: 0x01)         */
#define biss1_app_biss_ir_MAFS_Pos        (12UL)                    /*!< biss1_app biss_ir: MAFS (Bit 12)                      */
#define biss1_app_biss_ir_MAFS_Msk        (0x1000UL)                /*!< biss1_app biss_ir: MAFS (Bitfield-Mask: 0x01)         */
#define biss1_app_biss_ir_CFGIF_Pos       (10UL)                    /*!< biss1_app biss_ir: CFGIF (Bit 10)                     */
#define biss1_app_biss_ir_CFGIF_Msk       (0xc00UL)                 /*!< biss1_app biss_ir: CFGIF (Bitfield-Mask: 0x03)        */
#define biss1_app_biss_ir_ENTEST_Pos      (9UL)                     /*!< biss1_app biss_ir: ENTEST (Bit 9)                     */
#define biss1_app_biss_ir_ENTEST_Msk      (0x200UL)                 /*!< biss1_app biss_ir: ENTEST (Bitfield-Mask: 0x01)       */
#define biss1_app_biss_ir_CLKENI_Pos      (8UL)                     /*!< biss1_app biss_ir: CLKENI (Bit 8)                     */
#define biss1_app_biss_ir_CLKENI_Msk      (0x100UL)                 /*!< biss1_app biss_ir: CLKENI (Bitfield-Mask: 0x01)       */
#define biss1_app_biss_ir_BREAK_Pos       (7UL)                     /*!< biss1_app biss_ir: BREAK (Bit 7)                      */
#define biss1_app_biss_ir_BREAK_Msk       (0x80UL)                  /*!< biss1_app biss_ir: BREAK (Bitfield-Mask: 0x01)        */
#define biss1_app_biss_ir_HOLDBANK_Pos    (6UL)                     /*!< biss1_app biss_ir: HOLDBANK (Bit 6)                   */
#define biss1_app_biss_ir_HOLDBANK_Msk    (0x40UL)                  /*!< biss1_app biss_ir: HOLDBANK (Bitfield-Mask: 0x01)     */
#define biss1_app_biss_ir_SWBANK_Pos      (5UL)                     /*!< biss1_app biss_ir: SWBANK (Bit 5)                     */
#define biss1_app_biss_ir_SWBANK_Msk      (0x20UL)                  /*!< biss1_app biss_ir: SWBANK (Bitfield-Mask: 0x01)       */
#define biss1_app_biss_ir_INIT_Pos        (4UL)                     /*!< biss1_app biss_ir: INIT (Bit 4)                       */
#define biss1_app_biss_ir_INIT_Msk        (0x10UL)                  /*!< biss1_app biss_ir: INIT (Bitfield-Mask: 0x01)         */
#define biss1_app_biss_ir_INSTR_Pos       (1UL)                     /*!< biss1_app biss_ir: INSTR (Bit 1)                      */
#define biss1_app_biss_ir_INSTR_Msk       (0xeUL)                   /*!< biss1_app biss_ir: INSTR (Bitfield-Mask: 0x07)        */
#define biss1_app_biss_ir_AGS_Pos         (0UL)                     /*!< biss1_app biss_ir: AGS (Bit 0)                        */
#define biss1_app_biss_ir_AGS_Msk         (0x1UL)                   /*!< biss1_app biss_ir: AGS (Bitfield-Mask: 0x01)          */
/* =====================================================  biss_status1  ====================================================== */
#define biss1_app_biss_status1_reserved1_Pos (25UL)                 /*!< biss1_app biss_status1: reserved1 (Bit 25)            */
#define biss1_app_biss_status1_reserved1_Msk (0xfe000000UL)         /*!< biss1_app biss_status1: reserved1 (Bitfield-Mask: 0x7f) */
#define biss1_app_biss_status1_SWBANKFAILS_Pos (24UL)               /*!< biss1_app biss_status1: SWBANKFAILS (Bit 24)          */
#define biss1_app_biss_status1_SWBANKFAILS_Msk (0x1000000UL)        /*!< biss1_app biss_status1: SWBANKFAILS (Bitfield-Mask: 0x01) */
#define biss1_app_biss_status1_reserved0_Pos (2UL)                  /*!< biss1_app biss_status1: reserved0 (Bit 2)             */
#define biss1_app_biss_status1_reserved0_Msk (0xfffffcUL)           /*!< biss1_app biss_status1: reserved0 (Bitfield-Mask: 0x3fffff) */
#define biss1_app_biss_status1_CDS1_Pos   (1UL)                     /*!< biss1_app biss_status1: CDS1 (Bit 1)                  */
#define biss1_app_biss_status1_CDS1_Msk   (0x2UL)                   /*!< biss1_app biss_status1: CDS1 (Bitfield-Mask: 0x01)    */
#define biss1_app_biss_status1_SL1_Pos    (0UL)                     /*!< biss1_app biss_status1: SL1 (Bit 0)                   */
#define biss1_app_biss_status1_SL1_Msk    (0x1UL)                   /*!< biss1_app biss_status1: SL1 (Bitfield-Mask: 0x01)     */


/* =========================================================================================================================== */
/* ================                                      biss_ctrl0_app                                       ================ */
/* =========================================================================================================================== */

/* =================================================  biss_ctrl_trigger_cfg  ================================================= */
#define biss_ctrl0_app_biss_ctrl_trigger_cfg_sel_Pos (0UL)          /*!< biss_ctrl0_app biss_ctrl_trigger_cfg: sel (Bit 0)     */
#define biss_ctrl0_app_biss_ctrl_trigger_cfg_sel_Msk (0xfUL)        /*!< biss_ctrl0_app biss_ctrl_trigger_cfg: sel (Bitfield-Mask: 0x0f) */
/* ===================================================  biss_ctrl_trigger  =================================================== */
#define biss_ctrl0_app_biss_ctrl_trigger_manual_Pos (0UL)           /*!< biss_ctrl0_app biss_ctrl_trigger: manual (Bit 0)      */
#define biss_ctrl0_app_biss_ctrl_trigger_manual_Msk (0x1UL)         /*!< biss_ctrl0_app biss_ctrl_trigger: manual (Bitfield-Mask: 0x01) */
/* ===================================================  biss_ctrl_irq_raw  =================================================== */
#define biss_ctrl0_app_biss_ctrl_irq_raw_err_Pos (1UL)              /*!< biss_ctrl0_app biss_ctrl_irq_raw: err (Bit 1)         */
#define biss_ctrl0_app_biss_ctrl_irq_raw_err_Msk (0x2UL)            /*!< biss_ctrl0_app biss_ctrl_irq_raw: err (Bitfield-Mask: 0x01) */
#define biss_ctrl0_app_biss_ctrl_irq_raw_eot_Pos (0UL)              /*!< biss_ctrl0_app biss_ctrl_irq_raw: eot (Bit 0)         */
#define biss_ctrl0_app_biss_ctrl_irq_raw_eot_Msk (0x1UL)            /*!< biss_ctrl0_app biss_ctrl_irq_raw: eot (Bitfield-Mask: 0x01) */
/* =================================================  biss_ctrl_irq_masked  ================================================== */
#define biss_ctrl0_app_biss_ctrl_irq_masked_err_Pos (1UL)           /*!< biss_ctrl0_app biss_ctrl_irq_masked: err (Bit 1)      */
#define biss_ctrl0_app_biss_ctrl_irq_masked_err_Msk (0x2UL)         /*!< biss_ctrl0_app biss_ctrl_irq_masked: err (Bitfield-Mask: 0x01) */
#define biss_ctrl0_app_biss_ctrl_irq_masked_eot_Pos (0UL)           /*!< biss_ctrl0_app biss_ctrl_irq_masked: eot (Bit 0)      */
#define biss_ctrl0_app_biss_ctrl_irq_masked_eot_Msk (0x1UL)         /*!< biss_ctrl0_app biss_ctrl_irq_masked: eot (Bitfield-Mask: 0x01) */
/* =================================================  biss_ctrl_irq_msk_set  ================================================= */
#define biss_ctrl0_app_biss_ctrl_irq_msk_set_err_Pos (1UL)          /*!< biss_ctrl0_app biss_ctrl_irq_msk_set: err (Bit 1)     */
#define biss_ctrl0_app_biss_ctrl_irq_msk_set_err_Msk (0x2UL)        /*!< biss_ctrl0_app biss_ctrl_irq_msk_set: err (Bitfield-Mask: 0x01) */
#define biss_ctrl0_app_biss_ctrl_irq_msk_set_eot_Pos (0UL)          /*!< biss_ctrl0_app biss_ctrl_irq_msk_set: eot (Bit 0)     */
#define biss_ctrl0_app_biss_ctrl_irq_msk_set_eot_Msk (0x1UL)        /*!< biss_ctrl0_app biss_ctrl_irq_msk_set: eot (Bitfield-Mask: 0x01) */
/* ================================================  biss_ctrl_irq_msk_reset  ================================================ */
#define biss_ctrl0_app_biss_ctrl_irq_msk_reset_err_Pos (1UL)        /*!< biss_ctrl0_app biss_ctrl_irq_msk_reset: err (Bit 1)   */
#define biss_ctrl0_app_biss_ctrl_irq_msk_reset_err_Msk (0x2UL)      /*!< biss_ctrl0_app biss_ctrl_irq_msk_reset: err (Bitfield-Mask: 0x01) */
#define biss_ctrl0_app_biss_ctrl_irq_msk_reset_eot_Pos (0UL)        /*!< biss_ctrl0_app biss_ctrl_irq_msk_reset: eot (Bit 0)   */
#define biss_ctrl0_app_biss_ctrl_irq_msk_reset_eot_Msk (0x1UL)      /*!< biss_ctrl0_app biss_ctrl_irq_msk_reset: eot (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                      biss_ctrl1_app                                       ================ */
/* =========================================================================================================================== */

/* =================================================  biss_ctrl_trigger_cfg  ================================================= */
#define biss_ctrl1_app_biss_ctrl_trigger_cfg_sel_Pos (0UL)          /*!< biss_ctrl1_app biss_ctrl_trigger_cfg: sel (Bit 0)     */
#define biss_ctrl1_app_biss_ctrl_trigger_cfg_sel_Msk (0xfUL)        /*!< biss_ctrl1_app biss_ctrl_trigger_cfg: sel (Bitfield-Mask: 0x0f) */
/* ===================================================  biss_ctrl_trigger  =================================================== */
#define biss_ctrl1_app_biss_ctrl_trigger_manual_Pos (0UL)           /*!< biss_ctrl1_app biss_ctrl_trigger: manual (Bit 0)      */
#define biss_ctrl1_app_biss_ctrl_trigger_manual_Msk (0x1UL)         /*!< biss_ctrl1_app biss_ctrl_trigger: manual (Bitfield-Mask: 0x01) */
/* ===================================================  biss_ctrl_irq_raw  =================================================== */
#define biss_ctrl1_app_biss_ctrl_irq_raw_err_Pos (1UL)              /*!< biss_ctrl1_app biss_ctrl_irq_raw: err (Bit 1)         */
#define biss_ctrl1_app_biss_ctrl_irq_raw_err_Msk (0x2UL)            /*!< biss_ctrl1_app biss_ctrl_irq_raw: err (Bitfield-Mask: 0x01) */
#define biss_ctrl1_app_biss_ctrl_irq_raw_eot_Pos (0UL)              /*!< biss_ctrl1_app biss_ctrl_irq_raw: eot (Bit 0)         */
#define biss_ctrl1_app_biss_ctrl_irq_raw_eot_Msk (0x1UL)            /*!< biss_ctrl1_app biss_ctrl_irq_raw: eot (Bitfield-Mask: 0x01) */
/* =================================================  biss_ctrl_irq_masked  ================================================== */
#define biss_ctrl1_app_biss_ctrl_irq_masked_err_Pos (1UL)           /*!< biss_ctrl1_app biss_ctrl_irq_masked: err (Bit 1)      */
#define biss_ctrl1_app_biss_ctrl_irq_masked_err_Msk (0x2UL)         /*!< biss_ctrl1_app biss_ctrl_irq_masked: err (Bitfield-Mask: 0x01) */
#define biss_ctrl1_app_biss_ctrl_irq_masked_eot_Pos (0UL)           /*!< biss_ctrl1_app biss_ctrl_irq_masked: eot (Bit 0)      */
#define biss_ctrl1_app_biss_ctrl_irq_masked_eot_Msk (0x1UL)         /*!< biss_ctrl1_app biss_ctrl_irq_masked: eot (Bitfield-Mask: 0x01) */
/* =================================================  biss_ctrl_irq_msk_set  ================================================= */
#define biss_ctrl1_app_biss_ctrl_irq_msk_set_err_Pos (1UL)          /*!< biss_ctrl1_app biss_ctrl_irq_msk_set: err (Bit 1)     */
#define biss_ctrl1_app_biss_ctrl_irq_msk_set_err_Msk (0x2UL)        /*!< biss_ctrl1_app biss_ctrl_irq_msk_set: err (Bitfield-Mask: 0x01) */
#define biss_ctrl1_app_biss_ctrl_irq_msk_set_eot_Pos (0UL)          /*!< biss_ctrl1_app biss_ctrl_irq_msk_set: eot (Bit 0)     */
#define biss_ctrl1_app_biss_ctrl_irq_msk_set_eot_Msk (0x1UL)        /*!< biss_ctrl1_app biss_ctrl_irq_msk_set: eot (Bitfield-Mask: 0x01) */
/* ================================================  biss_ctrl_irq_msk_reset  ================================================ */
#define biss_ctrl1_app_biss_ctrl_irq_msk_reset_err_Pos (1UL)        /*!< biss_ctrl1_app biss_ctrl_irq_msk_reset: err (Bit 1)   */
#define biss_ctrl1_app_biss_ctrl_irq_msk_reset_err_Msk (0x2UL)      /*!< biss_ctrl1_app biss_ctrl_irq_msk_reset: err (Bitfield-Mask: 0x01) */
#define biss_ctrl1_app_biss_ctrl_irq_msk_reset_eot_Pos (0UL)        /*!< biss_ctrl1_app biss_ctrl_irq_msk_reset: eot (Bit 0)   */
#define biss_ctrl1_app_biss_ctrl_irq_msk_reset_eot_Msk (0x1UL)      /*!< biss_ctrl1_app biss_ctrl_irq_msk_reset: eot (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                       xpic_app_regs                                       ================ */
/* =========================================================================================================================== */

/* ========================================================  xpic_r0  ======================================================== */
#define xpic_app_regs_xpic_r0_r0_Pos      (0UL)                     /*!< xpic_app_regs xpic_r0: r0 (Bit 0)                     */
#define xpic_app_regs_xpic_r0_r0_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r0: r0 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_r1  ======================================================== */
#define xpic_app_regs_xpic_r1_r1_Pos      (0UL)                     /*!< xpic_app_regs xpic_r1: r1 (Bit 0)                     */
#define xpic_app_regs_xpic_r1_r1_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r1: r1 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_r2  ======================================================== */
#define xpic_app_regs_xpic_r2_r2_Pos      (0UL)                     /*!< xpic_app_regs xpic_r2: r2 (Bit 0)                     */
#define xpic_app_regs_xpic_r2_r2_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r2: r2 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_r3  ======================================================== */
#define xpic_app_regs_xpic_r3_r3_Pos      (0UL)                     /*!< xpic_app_regs xpic_r3: r3 (Bit 0)                     */
#define xpic_app_regs_xpic_r3_r3_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r3: r3 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_r4  ======================================================== */
#define xpic_app_regs_xpic_r4_r4_Pos      (0UL)                     /*!< xpic_app_regs xpic_r4: r4 (Bit 0)                     */
#define xpic_app_regs_xpic_r4_r4_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r4: r4 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_r5  ======================================================== */
#define xpic_app_regs_xpic_r5_r5_Pos      (0UL)                     /*!< xpic_app_regs xpic_r5: r5 (Bit 0)                     */
#define xpic_app_regs_xpic_r5_r5_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r5: r5 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_r6  ======================================================== */
#define xpic_app_regs_xpic_r6_r6_Pos      (0UL)                     /*!< xpic_app_regs xpic_r6: r6 (Bit 0)                     */
#define xpic_app_regs_xpic_r6_r6_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r6: r6 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_r7  ======================================================== */
#define xpic_app_regs_xpic_r7_r7_Pos      (0UL)                     /*!< xpic_app_regs xpic_r7: r7 (Bit 0)                     */
#define xpic_app_regs_xpic_r7_r7_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_r7: r7 (Bitfield-Mask: 0xffffffff) */
/* =======================================================  xpic_usr0  ======================================================= */
#define xpic_app_regs_xpic_usr0_usr0_Pos  (0UL)                     /*!< xpic_app_regs xpic_usr0: usr0 (Bit 0)                 */
#define xpic_app_regs_xpic_usr0_usr0_Msk  (0xffffffffUL)            /*!< xpic_app_regs xpic_usr0: usr0 (Bitfield-Mask: 0xffffffff) */
/* =======================================================  xpic_usr1  ======================================================= */
#define xpic_app_regs_xpic_usr1_usr1_Pos  (0UL)                     /*!< xpic_app_regs xpic_usr1: usr1 (Bit 0)                 */
#define xpic_app_regs_xpic_usr1_usr1_Msk  (0xffffffffUL)            /*!< xpic_app_regs xpic_usr1: usr1 (Bitfield-Mask: 0xffffffff) */
/* =======================================================  xpic_usr2  ======================================================= */
#define xpic_app_regs_xpic_usr2_usr2_Pos  (0UL)                     /*!< xpic_app_regs xpic_usr2: usr2 (Bit 0)                 */
#define xpic_app_regs_xpic_usr2_usr2_Msk  (0xffffffffUL)            /*!< xpic_app_regs xpic_usr2: usr2 (Bitfield-Mask: 0xffffffff) */
/* =======================================================  xpic_usr3  ======================================================= */
#define xpic_app_regs_xpic_usr3_usr3_Pos  (0UL)                     /*!< xpic_app_regs xpic_usr3: usr3 (Bit 0)                 */
#define xpic_app_regs_xpic_usr3_usr3_Msk  (0xffffffffUL)            /*!< xpic_app_regs xpic_usr3: usr3 (Bitfield-Mask: 0xffffffff) */
/* =======================================================  xpic_usr4  ======================================================= */
#define xpic_app_regs_xpic_usr4_usr4_Pos  (0UL)                     /*!< xpic_app_regs xpic_usr4: usr4 (Bit 0)                 */
#define xpic_app_regs_xpic_usr4_usr4_Msk  (0xffffffffUL)            /*!< xpic_app_regs xpic_usr4: usr4 (Bitfield-Mask: 0xffffffff) */
/* ========================================================  xpic_pc  ======================================================== */
#define xpic_app_regs_xpic_pc_pc_Pos      (0UL)                     /*!< xpic_app_regs xpic_pc: pc (Bit 0)                     */
#define xpic_app_regs_xpic_pc_pc_Msk      (0xffffffffUL)            /*!< xpic_app_regs xpic_pc: pc (Bitfield-Mask: 0xffffffff) */
/* =======================================================  xpic_stat  ======================================================= */
#define xpic_app_regs_xpic_stat_stat_Pos  (0UL)                     /*!< xpic_app_regs xpic_stat: stat (Bit 0)                 */
#define xpic_app_regs_xpic_stat_stat_Msk  (0xffffffffUL)            /*!< xpic_app_regs xpic_stat: stat (Bitfield-Mask: 0xffffffff) */
/* =======================================================  xpic_zero  ======================================================= */
#define xpic_app_regs_xpic_zero_zero_Pos  (0UL)                     /*!< xpic_app_regs xpic_zero: zero (Bit 0)                 */
#define xpic_app_regs_xpic_zero_zero_Msk  (0xffffffffUL)            /*!< xpic_app_regs xpic_zero: zero (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                      xpic_app_debug                                       ================ */
/* =========================================================================================================================== */

/* =====================================================  xpic_hold_pc  ====================================================== */
#define xpic_app_debug_xpic_hold_pc_reset_xpic_Pos (7UL)            /*!< xpic_app_debug xpic_hold_pc: reset_xpic (Bit 7)       */
#define xpic_app_debug_xpic_hold_pc_reset_xpic_Msk (0x80UL)         /*!< xpic_app_debug xpic_hold_pc: reset_xpic (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_hold_pc_bank_control_Pos (6UL)          /*!< xpic_app_debug xpic_hold_pc: bank_control (Bit 6)     */
#define xpic_app_debug_xpic_hold_pc_bank_control_Msk (0x40UL)       /*!< xpic_app_debug xpic_hold_pc: bank_control (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_hold_pc_bank_select_Pos (5UL)           /*!< xpic_app_debug xpic_hold_pc: bank_select (Bit 5)      */
#define xpic_app_debug_xpic_hold_pc_bank_select_Msk (0x20UL)        /*!< xpic_app_debug xpic_hold_pc: bank_select (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_hold_pc_misalignment_hold_Pos (4UL)     /*!< xpic_app_debug xpic_hold_pc: misalignment_hold (Bit 4) */
#define xpic_app_debug_xpic_hold_pc_misalignment_hold_Msk (0x10UL)  /*!< xpic_app_debug xpic_hold_pc: misalignment_hold (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_hold_pc_disable_int_Pos (3UL)           /*!< xpic_app_debug xpic_hold_pc: disable_int (Bit 3)      */
#define xpic_app_debug_xpic_hold_pc_disable_int_Msk (0x8UL)         /*!< xpic_app_debug xpic_hold_pc: disable_int (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_hold_pc_monitor_mode_Pos (2UL)          /*!< xpic_app_debug xpic_hold_pc: monitor_mode (Bit 2)     */
#define xpic_app_debug_xpic_hold_pc_monitor_mode_Msk (0x4UL)        /*!< xpic_app_debug xpic_hold_pc: monitor_mode (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_hold_pc_single_step_Pos (1UL)           /*!< xpic_app_debug xpic_hold_pc: single_step (Bit 1)      */
#define xpic_app_debug_xpic_hold_pc_single_step_Msk (0x2UL)         /*!< xpic_app_debug xpic_hold_pc: single_step (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_hold_pc_hold_Pos (0UL)                  /*!< xpic_app_debug xpic_hold_pc: hold (Bit 0)             */
#define xpic_app_debug_xpic_hold_pc_hold_Msk (0x1UL)                /*!< xpic_app_debug xpic_hold_pc: hold (Bitfield-Mask: 0x01) */
/* ===================================================  xpic_break0_addr  ==================================================== */
#define xpic_app_debug_xpic_break0_addr_val_Pos (0UL)               /*!< xpic_app_debug xpic_break0_addr: val (Bit 0)          */
#define xpic_app_debug_xpic_break0_addr_val_Msk (0xffffffffUL)      /*!< xpic_app_debug xpic_break0_addr: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_break0_addr_mask  ================================================= */
#define xpic_app_debug_xpic_break0_addr_mask_val_Pos (0UL)          /*!< xpic_app_debug xpic_break0_addr_mask: val (Bit 0)     */
#define xpic_app_debug_xpic_break0_addr_mask_val_Msk (0xffffffffUL) /*!< xpic_app_debug xpic_break0_addr_mask: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_break0_data  ==================================================== */
#define xpic_app_debug_xpic_break0_data_val_Pos (0UL)               /*!< xpic_app_debug xpic_break0_data: val (Bit 0)          */
#define xpic_app_debug_xpic_break0_data_val_Msk (0xffffffffUL)      /*!< xpic_app_debug xpic_break0_data: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_break0_data_mask  ================================================= */
#define xpic_app_debug_xpic_break0_data_mask_val_Pos (0UL)          /*!< xpic_app_debug xpic_break0_data_mask: val (Bit 0)     */
#define xpic_app_debug_xpic_break0_data_mask_val_Msk (0xffffffffUL) /*!< xpic_app_debug xpic_break0_data_mask: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_break0_contr  =================================================== */
#define xpic_app_debug_xpic_break0_contr_enable_Pos (8UL)           /*!< xpic_app_debug xpic_break0_contr: enable (Bit 8)      */
#define xpic_app_debug_xpic_break0_contr_enable_Msk (0x100UL)       /*!< xpic_app_debug xpic_break0_contr: enable (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break0_contr_range_Pos (7UL)            /*!< xpic_app_debug xpic_break0_contr: range (Bit 7)       */
#define xpic_app_debug_xpic_break0_contr_range_Msk (0x80UL)         /*!< xpic_app_debug xpic_break0_contr: range (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break0_contr_chain_Pos (6UL)            /*!< xpic_app_debug xpic_break0_contr: chain (Bit 6)       */
#define xpic_app_debug_xpic_break0_contr_chain_Msk (0x40UL)         /*!< xpic_app_debug xpic_break0_contr: chain (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break0_contr_irq_mode_Pos (5UL)         /*!< xpic_app_debug xpic_break0_contr: irq_mode (Bit 5)    */
#define xpic_app_debug_xpic_break0_contr_irq_mode_Msk (0x20UL)      /*!< xpic_app_debug xpic_break0_contr: irq_mode (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break0_contr_fiq_mode_Pos (4UL)         /*!< xpic_app_debug xpic_break0_contr: fiq_mode (Bit 4)    */
#define xpic_app_debug_xpic_break0_contr_fiq_mode_Msk (0x10UL)      /*!< xpic_app_debug xpic_break0_contr: fiq_mode (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break0_contr_data_access_Pos (3UL)      /*!< xpic_app_debug xpic_break0_contr: data_access (Bit 3) */
#define xpic_app_debug_xpic_break0_contr_data_access_Msk (0x8UL)    /*!< xpic_app_debug xpic_break0_contr: data_access (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break0_contr_mas_Pos (1UL)              /*!< xpic_app_debug xpic_break0_contr: mas (Bit 1)         */
#define xpic_app_debug_xpic_break0_contr_mas_Msk (0x6UL)            /*!< xpic_app_debug xpic_break0_contr: mas (Bitfield-Mask: 0x03) */
#define xpic_app_debug_xpic_break0_contr_write_Pos (0UL)            /*!< xpic_app_debug xpic_break0_contr: write (Bit 0)       */
#define xpic_app_debug_xpic_break0_contr_write_Msk (0x1UL)          /*!< xpic_app_debug xpic_break0_contr: write (Bitfield-Mask: 0x01) */
/* ================================================  xpic_break0_contr_mask  ================================================= */
#define xpic_app_debug_xpic_break0_contr_mask_val_Pos (0UL)         /*!< xpic_app_debug xpic_break0_contr_mask: val (Bit 0)    */
#define xpic_app_debug_xpic_break0_contr_mask_val_Msk (0xffUL)      /*!< xpic_app_debug xpic_break0_contr_mask: val (Bitfield-Mask: 0xff) */
/* ===================================================  xpic_break1_addr  ==================================================== */
#define xpic_app_debug_xpic_break1_addr_val_Pos (0UL)               /*!< xpic_app_debug xpic_break1_addr: val (Bit 0)          */
#define xpic_app_debug_xpic_break1_addr_val_Msk (0xffffffffUL)      /*!< xpic_app_debug xpic_break1_addr: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_break1_addr_mask  ================================================= */
#define xpic_app_debug_xpic_break1_addr_mask_val_Pos (0UL)          /*!< xpic_app_debug xpic_break1_addr_mask: val (Bit 0)     */
#define xpic_app_debug_xpic_break1_addr_mask_val_Msk (0xffffffffUL) /*!< xpic_app_debug xpic_break1_addr_mask: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_break1_data  ==================================================== */
#define xpic_app_debug_xpic_break1_data_val_Pos (0UL)               /*!< xpic_app_debug xpic_break1_data: val (Bit 0)          */
#define xpic_app_debug_xpic_break1_data_val_Msk (0xffffffffUL)      /*!< xpic_app_debug xpic_break1_data: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_break1_data_mask  ================================================= */
#define xpic_app_debug_xpic_break1_data_mask_val_Pos (0UL)          /*!< xpic_app_debug xpic_break1_data_mask: val (Bit 0)     */
#define xpic_app_debug_xpic_break1_data_mask_val_Msk (0xffffffffUL) /*!< xpic_app_debug xpic_break1_data_mask: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_break1_contr  =================================================== */
#define xpic_app_debug_xpic_break1_contr_enable_Pos (8UL)           /*!< xpic_app_debug xpic_break1_contr: enable (Bit 8)      */
#define xpic_app_debug_xpic_break1_contr_enable_Msk (0x100UL)       /*!< xpic_app_debug xpic_break1_contr: enable (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break1_contr_range_Pos (7UL)            /*!< xpic_app_debug xpic_break1_contr: range (Bit 7)       */
#define xpic_app_debug_xpic_break1_contr_range_Msk (0x80UL)         /*!< xpic_app_debug xpic_break1_contr: range (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break1_contr_chain_Pos (6UL)            /*!< xpic_app_debug xpic_break1_contr: chain (Bit 6)       */
#define xpic_app_debug_xpic_break1_contr_chain_Msk (0x40UL)         /*!< xpic_app_debug xpic_break1_contr: chain (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break1_contr_irq_mode_Pos (5UL)         /*!< xpic_app_debug xpic_break1_contr: irq_mode (Bit 5)    */
#define xpic_app_debug_xpic_break1_contr_irq_mode_Msk (0x20UL)      /*!< xpic_app_debug xpic_break1_contr: irq_mode (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break1_contr_fiq_mode_Pos (4UL)         /*!< xpic_app_debug xpic_break1_contr: fiq_mode (Bit 4)    */
#define xpic_app_debug_xpic_break1_contr_fiq_mode_Msk (0x10UL)      /*!< xpic_app_debug xpic_break1_contr: fiq_mode (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break1_contr_data_access_Pos (3UL)      /*!< xpic_app_debug xpic_break1_contr: data_access (Bit 3) */
#define xpic_app_debug_xpic_break1_contr_data_access_Msk (0x8UL)    /*!< xpic_app_debug xpic_break1_contr: data_access (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break1_contr_mas_Pos (1UL)              /*!< xpic_app_debug xpic_break1_contr: mas (Bit 1)         */
#define xpic_app_debug_xpic_break1_contr_mas_Msk (0x6UL)            /*!< xpic_app_debug xpic_break1_contr: mas (Bitfield-Mask: 0x03) */
#define xpic_app_debug_xpic_break1_contr_write_Pos (0UL)            /*!< xpic_app_debug xpic_break1_contr: write (Bit 0)       */
#define xpic_app_debug_xpic_break1_contr_write_Msk (0x1UL)          /*!< xpic_app_debug xpic_break1_contr: write (Bitfield-Mask: 0x01) */
/* ================================================  xpic_break1_contr_mask  ================================================= */
#define xpic_app_debug_xpic_break1_contr_mask_val_Pos (0UL)         /*!< xpic_app_debug xpic_break1_contr_mask: val (Bit 0)    */
#define xpic_app_debug_xpic_break1_contr_mask_val_Msk (0xffUL)      /*!< xpic_app_debug xpic_break1_contr_mask: val (Bitfield-Mask: 0xff) */
/* ==================================================  xpic_break_last_pc  =================================================== */
#define xpic_app_debug_xpic_break_last_pc_val_Pos (0UL)             /*!< xpic_app_debug xpic_break_last_pc: val (Bit 0)        */
#define xpic_app_debug_xpic_break_last_pc_val_Msk (0xffffffffUL)    /*!< xpic_app_debug xpic_break_last_pc: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_break_status  =================================================== */
#define xpic_app_debug_xpic_break_status_xpic_reset_status_Pos (9UL) /*!< xpic_app_debug xpic_break_status: xpic_reset_status (Bit 9) */
#define xpic_app_debug_xpic_break_status_xpic_reset_status_Msk (0x200UL) /*!< xpic_app_debug xpic_break_status: xpic_reset_status (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_break1_read_data_Pos (8UL) /*!< xpic_app_debug xpic_break_status: break1_read_data (Bit 8) */
#define xpic_app_debug_xpic_break_status_break1_read_data_Msk (0x100UL) /*!< xpic_app_debug xpic_break_status: break1_read_data (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_break0_read_data_Pos (7UL) /*!< xpic_app_debug xpic_break_status: break0_read_data (Bit 7) */
#define xpic_app_debug_xpic_break_status_break0_read_data_Msk (0x80UL) /*!< xpic_app_debug xpic_break_status: break0_read_data (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_data_misalignment_Pos (6UL) /*!< xpic_app_debug xpic_break_status: data_misalignment (Bit 6) */
#define xpic_app_debug_xpic_break_status_data_misalignment_Msk (0x40UL) /*!< xpic_app_debug xpic_break_status: data_misalignment (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_single_step_Pos (5UL)      /*!< xpic_app_debug xpic_break_status: single_step (Bit 5) */
#define xpic_app_debug_xpic_break_status_single_step_Msk (0x20UL)   /*!< xpic_app_debug xpic_break_status: single_step (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_soft_break_Pos (4UL)       /*!< xpic_app_debug xpic_break_status: soft_break (Bit 4)  */
#define xpic_app_debug_xpic_break_status_soft_break_Msk (0x10UL)    /*!< xpic_app_debug xpic_break_status: soft_break (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_break1_Pos (3UL)           /*!< xpic_app_debug xpic_break_status: break1 (Bit 3)      */
#define xpic_app_debug_xpic_break_status_break1_Msk (0x8UL)         /*!< xpic_app_debug xpic_break_status: break1 (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_break0_Pos (2UL)           /*!< xpic_app_debug xpic_break_status: break0 (Bit 2)      */
#define xpic_app_debug_xpic_break_status_break0_Msk (0x4UL)         /*!< xpic_app_debug xpic_break_status: break0 (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_hold_Pos (1UL)             /*!< xpic_app_debug xpic_break_status: hold (Bit 1)        */
#define xpic_app_debug_xpic_break_status_hold_Msk (0x2UL)           /*!< xpic_app_debug xpic_break_status: hold (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_status_xpic_in_hold_Pos (0UL)     /*!< xpic_app_debug xpic_break_status: xpic_in_hold (Bit 0) */
#define xpic_app_debug_xpic_break_status_xpic_in_hold_Msk (0x1UL)   /*!< xpic_app_debug xpic_break_status: xpic_in_hold (Bitfield-Mask: 0x01) */
/* ==================================================  xpic_break_irq_raw  =================================================== */
#define xpic_app_debug_xpic_break_irq_raw_misalignment_irq_Pos (4UL) /*!< xpic_app_debug xpic_break_irq_raw: misalignment_irq (Bit 4) */
#define xpic_app_debug_xpic_break_irq_raw_misalignment_irq_Msk (0x10UL) /*!< xpic_app_debug xpic_break_irq_raw: misalignment_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_raw_single_step_irq_Pos (3UL) /*!< xpic_app_debug xpic_break_irq_raw: single_step_irq (Bit 3) */
#define xpic_app_debug_xpic_break_irq_raw_single_step_irq_Msk (0x8UL) /*!< xpic_app_debug xpic_break_irq_raw: single_step_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_raw_soft_break_irq_Pos (2UL)  /*!< xpic_app_debug xpic_break_irq_raw: soft_break_irq (Bit 2) */
#define xpic_app_debug_xpic_break_irq_raw_soft_break_irq_Msk (0x4UL) /*!< xpic_app_debug xpic_break_irq_raw: soft_break_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_raw_break1_irq_Pos (1UL)      /*!< xpic_app_debug xpic_break_irq_raw: break1_irq (Bit 1) */
#define xpic_app_debug_xpic_break_irq_raw_break1_irq_Msk (0x2UL)    /*!< xpic_app_debug xpic_break_irq_raw: break1_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_raw_break0_irq_Pos (0UL)      /*!< xpic_app_debug xpic_break_irq_raw: break0_irq (Bit 0) */
#define xpic_app_debug_xpic_break_irq_raw_break0_irq_Msk (0x1UL)    /*!< xpic_app_debug xpic_break_irq_raw: break0_irq (Bitfield-Mask: 0x01) */
/* =================================================  xpic_break_irq_masked  ================================================= */
#define xpic_app_debug_xpic_break_irq_masked_misalignment_irq_Pos (4UL) /*!< xpic_app_debug xpic_break_irq_masked: misalignment_irq (Bit 4) */
#define xpic_app_debug_xpic_break_irq_masked_misalignment_irq_Msk (0x10UL) /*!< xpic_app_debug xpic_break_irq_masked: misalignment_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_masked_single_step_irq_Pos (3UL) /*!< xpic_app_debug xpic_break_irq_masked: single_step_irq (Bit 3) */
#define xpic_app_debug_xpic_break_irq_masked_single_step_irq_Msk (0x8UL) /*!< xpic_app_debug xpic_break_irq_masked: single_step_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_masked_soft_break_irq_Pos (2UL) /*!< xpic_app_debug xpic_break_irq_masked: soft_break_irq (Bit 2) */
#define xpic_app_debug_xpic_break_irq_masked_soft_break_irq_Msk (0x4UL) /*!< xpic_app_debug xpic_break_irq_masked: soft_break_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_masked_break1_irq_Pos (1UL)   /*!< xpic_app_debug xpic_break_irq_masked: break1_irq (Bit 1) */
#define xpic_app_debug_xpic_break_irq_masked_break1_irq_Msk (0x2UL) /*!< xpic_app_debug xpic_break_irq_masked: break1_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_masked_break0_irq_Pos (0UL)   /*!< xpic_app_debug xpic_break_irq_masked: break0_irq (Bit 0) */
#define xpic_app_debug_xpic_break_irq_masked_break0_irq_Msk (0x1UL) /*!< xpic_app_debug xpic_break_irq_masked: break0_irq (Bitfield-Mask: 0x01) */
/* ================================================  xpic_break_irq_msk_set  ================================================= */
#define xpic_app_debug_xpic_break_irq_msk_set_misalignment_irq_Pos (4UL) /*!< xpic_app_debug xpic_break_irq_msk_set: misalignment_irq (Bit 4) */
#define xpic_app_debug_xpic_break_irq_msk_set_misalignment_irq_Msk (0x10UL) /*!< xpic_app_debug xpic_break_irq_msk_set: misalignment_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_set_single_step_irq_Pos (3UL) /*!< xpic_app_debug xpic_break_irq_msk_set: single_step_irq (Bit 3) */
#define xpic_app_debug_xpic_break_irq_msk_set_single_step_irq_Msk (0x8UL) /*!< xpic_app_debug xpic_break_irq_msk_set: single_step_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_set_soft_break_irq_Pos (2UL) /*!< xpic_app_debug xpic_break_irq_msk_set: soft_break_irq (Bit 2) */
#define xpic_app_debug_xpic_break_irq_msk_set_soft_break_irq_Msk (0x4UL) /*!< xpic_app_debug xpic_break_irq_msk_set: soft_break_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_set_break1_irq_Pos (1UL)  /*!< xpic_app_debug xpic_break_irq_msk_set: break1_irq (Bit 1) */
#define xpic_app_debug_xpic_break_irq_msk_set_break1_irq_Msk (0x2UL) /*!< xpic_app_debug xpic_break_irq_msk_set: break1_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_set_break0_irq_Pos (0UL)  /*!< xpic_app_debug xpic_break_irq_msk_set: break0_irq (Bit 0) */
#define xpic_app_debug_xpic_break_irq_msk_set_break0_irq_Msk (0x1UL) /*!< xpic_app_debug xpic_break_irq_msk_set: break0_irq (Bitfield-Mask: 0x01) */
/* ===============================================  xpic_break_irq_msk_reset  ================================================ */
#define xpic_app_debug_xpic_break_irq_msk_reset_misalignment_irq_Pos (4UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: misalignment_irq (Bit 4) */
#define xpic_app_debug_xpic_break_irq_msk_reset_misalignment_irq_Msk (0x10UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: misalignment_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_reset_single_step_irq_Pos (3UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: single_step_irq (Bit 3) */
#define xpic_app_debug_xpic_break_irq_msk_reset_single_step_irq_Msk (0x8UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: single_step_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_reset_soft_break_irq_Pos (2UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: soft_break_irq (Bit 2) */
#define xpic_app_debug_xpic_break_irq_msk_reset_soft_break_irq_Msk (0x4UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: soft_break_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_reset_break1_irq_Pos (1UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: break1_irq (Bit 1) */
#define xpic_app_debug_xpic_break_irq_msk_reset_break1_irq_Msk (0x2UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: break1_irq (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_break_irq_msk_reset_break0_irq_Pos (0UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: break0_irq (Bit 0) */
#define xpic_app_debug_xpic_break_irq_msk_reset_break0_irq_Msk (0x1UL) /*!< xpic_app_debug xpic_break_irq_msk_reset: break0_irq (Bitfield-Mask: 0x01) */
/* ===============================================  xpic_break_own_irq_masked  =============================================== */
#define xpic_app_debug_xpic_break_own_irq_masked_misalignment_irq_Pos (0UL) /*!< xpic_app_debug xpic_break_own_irq_masked: misalignment_irq (Bit 0) */
#define xpic_app_debug_xpic_break_own_irq_masked_misalignment_irq_Msk (0x1UL) /*!< xpic_app_debug xpic_break_own_irq_masked: misalignment_irq (Bitfield-Mask: 0x01) */
/* ==============================================  xpic_break_own_irq_msk_set  =============================================== */
#define xpic_app_debug_xpic_break_own_irq_msk_set_misalignment_irq_Pos (0UL) /*!< xpic_app_debug xpic_break_own_irq_msk_set: misalignment_irq (Bit 0) */
#define xpic_app_debug_xpic_break_own_irq_msk_set_misalignment_irq_Msk (0x1UL) /*!< xpic_app_debug xpic_break_own_irq_msk_set: misalignment_irq (Bitfield-Mask: 0x01) */
/* =============================================  xpic_break_own_irq_msk_reset  ============================================== */
#define xpic_app_debug_xpic_break_own_irq_msk_reset_misalignment_irq_Pos (0UL) /*!< xpic_app_debug xpic_break_own_irq_msk_reset: misalignment_irq (Bit 0) */
#define xpic_app_debug_xpic_break_own_irq_msk_reset_misalignment_irq_Msk (0x1UL) /*!< xpic_app_debug xpic_break_own_irq_msk_reset: misalignment_irq (Bitfield-Mask: 0x01) */
/* ===============================================  xpic_break_return_fiq_pc  ================================================ */
#define xpic_app_debug_xpic_break_return_fiq_pc_val_Pos (0UL)       /*!< xpic_app_debug xpic_break_return_fiq_pc: val (Bit 0)  */
#define xpic_app_debug_xpic_break_return_fiq_pc_val_Msk (0xffffffffUL) /*!< xpic_app_debug xpic_break_return_fiq_pc: val (Bitfield-Mask: 0xffffffff) */
/* ===============================================  xpic_break_return_irq_pc  ================================================ */
#define xpic_app_debug_xpic_break_return_irq_pc_val_Pos (0UL)       /*!< xpic_app_debug xpic_break_return_irq_pc: val (Bit 0)  */
#define xpic_app_debug_xpic_break_return_irq_pc_val_Msk (0xffffffffUL) /*!< xpic_app_debug xpic_break_return_irq_pc: val (Bitfield-Mask: 0xffffffff) */
/* ====================================================  xpic_irq_status  ==================================================== */
#define xpic_app_debug_xpic_irq_status_fiq_enable_Pos (3UL)         /*!< xpic_app_debug xpic_irq_status: fiq_enable (Bit 3)    */
#define xpic_app_debug_xpic_irq_status_fiq_enable_Msk (0x8UL)       /*!< xpic_app_debug xpic_irq_status: fiq_enable (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_irq_status_irq_enable_Pos (2UL)         /*!< xpic_app_debug xpic_irq_status: irq_enable (Bit 2)    */
#define xpic_app_debug_xpic_irq_status_irq_enable_Msk (0x4UL)       /*!< xpic_app_debug xpic_irq_status: irq_enable (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_irq_status_fiq_status_Pos (1UL)         /*!< xpic_app_debug xpic_irq_status: fiq_status (Bit 1)    */
#define xpic_app_debug_xpic_irq_status_fiq_status_Msk (0x2UL)       /*!< xpic_app_debug xpic_irq_status: fiq_status (Bitfield-Mask: 0x01) */
#define xpic_app_debug_xpic_irq_status_irq_status_Pos (0UL)         /*!< xpic_app_debug xpic_irq_status: irq_status (Bit 0)    */
#define xpic_app_debug_xpic_irq_status_irq_status_Msk (0x1UL)       /*!< xpic_app_debug xpic_irq_status: irq_status (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                       vic_xpic_app                                        ================ */
/* =========================================================================================================================== */

/* ====================================================  xpic_vic_config  ==================================================== */
#define vic_xpic_app_xpic_vic_config_table_Pos (1UL)                /*!< vic_xpic_app xpic_vic_config: table (Bit 1)           */
#define vic_xpic_app_xpic_vic_config_table_Msk (0x2UL)              /*!< vic_xpic_app xpic_vic_config: table (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_config_enable_Pos (0UL)               /*!< vic_xpic_app xpic_vic_config: enable (Bit 0)          */
#define vic_xpic_app_xpic_vic_config_enable_Msk (0x1UL)             /*!< vic_xpic_app xpic_vic_config: enable (Bitfield-Mask: 0x01) */
/* ==================================================  xpic_vic_raw_intr0  =================================================== */
#define vic_xpic_app_xpic_vic_raw_intr0_irqs_Pos (0UL)              /*!< vic_xpic_app xpic_vic_raw_intr0: irqs (Bit 0)         */
#define vic_xpic_app_xpic_vic_raw_intr0_irqs_Msk (0xffffffffUL)     /*!< vic_xpic_app xpic_vic_raw_intr0: irqs (Bitfield-Mask: 0xffffffff) */
/* ==================================================  xpic_vic_raw_intr1  =================================================== */
#define vic_xpic_app_xpic_vic_raw_intr1_irqs_Pos (0UL)              /*!< vic_xpic_app xpic_vic_raw_intr1: irqs (Bit 0)         */
#define vic_xpic_app_xpic_vic_raw_intr1_irqs_Msk (0xffffffffUL)     /*!< vic_xpic_app xpic_vic_raw_intr1: irqs (Bitfield-Mask: 0xffffffff) */
/* ==================================================  xpic_vic_raw_intr2  =================================================== */
#define vic_xpic_app_xpic_vic_raw_intr2_irqs_Pos (0UL)              /*!< vic_xpic_app xpic_vic_raw_intr2: irqs (Bit 0)         */
#define vic_xpic_app_xpic_vic_raw_intr2_irqs_Msk (0xffffffffUL)     /*!< vic_xpic_app xpic_vic_raw_intr2: irqs (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_vic_softint0_set  ================================================= */
#define vic_xpic_app_xpic_vic_softint0_set_irqs_Pos (0UL)           /*!< vic_xpic_app xpic_vic_softint0_set: irqs (Bit 0)      */
#define vic_xpic_app_xpic_vic_softint0_set_irqs_Msk (0xffffffffUL)  /*!< vic_xpic_app xpic_vic_softint0_set: irqs (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_vic_softint1_set  ================================================= */
#define vic_xpic_app_xpic_vic_softint1_set_irqs_Pos (0UL)           /*!< vic_xpic_app xpic_vic_softint1_set: irqs (Bit 0)      */
#define vic_xpic_app_xpic_vic_softint1_set_irqs_Msk (0xffffffffUL)  /*!< vic_xpic_app xpic_vic_softint1_set: irqs (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_vic_softint2_set  ================================================= */
#define vic_xpic_app_xpic_vic_softint2_set_irqs_Pos (0UL)           /*!< vic_xpic_app xpic_vic_softint2_set: irqs (Bit 0)      */
#define vic_xpic_app_xpic_vic_softint2_set_irqs_Msk (0xffffffffUL)  /*!< vic_xpic_app xpic_vic_softint2_set: irqs (Bitfield-Mask: 0xffffffff) */
/* ================================================  xpic_vic_softint0_reset  ================================================ */
#define vic_xpic_app_xpic_vic_softint0_reset_irqs_Pos (0UL)         /*!< vic_xpic_app xpic_vic_softint0_reset: irqs (Bit 0)    */
#define vic_xpic_app_xpic_vic_softint0_reset_irqs_Msk (0xffffffffUL) /*!< vic_xpic_app xpic_vic_softint0_reset: irqs (Bitfield-Mask: 0xffffffff) */
/* ================================================  xpic_vic_softint1_reset  ================================================ */
#define vic_xpic_app_xpic_vic_softint1_reset_irqs_Pos (0UL)         /*!< vic_xpic_app xpic_vic_softint1_reset: irqs (Bit 0)    */
#define vic_xpic_app_xpic_vic_softint1_reset_irqs_Msk (0xffffffffUL) /*!< vic_xpic_app xpic_vic_softint1_reset: irqs (Bitfield-Mask: 0xffffffff) */
/* ================================================  xpic_vic_softint2_reset  ================================================ */
#define vic_xpic_app_xpic_vic_softint2_reset_irqs_Pos (0UL)         /*!< vic_xpic_app xpic_vic_softint2_reset: irqs (Bit 0)    */
#define vic_xpic_app_xpic_vic_softint2_reset_irqs_Msk (0xffffffffUL) /*!< vic_xpic_app xpic_vic_softint2_reset: irqs (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_vic_fiq_addr  =================================================== */
#define vic_xpic_app_xpic_vic_fiq_addr_val_Pos (0UL)                /*!< vic_xpic_app xpic_vic_fiq_addr: val (Bit 0)           */
#define vic_xpic_app_xpic_vic_fiq_addr_val_Msk (0xffffffffUL)       /*!< vic_xpic_app xpic_vic_fiq_addr: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_vic_irq_addr  =================================================== */
#define vic_xpic_app_xpic_vic_irq_addr_val_Pos (0UL)                /*!< vic_xpic_app xpic_vic_irq_addr: val (Bit 0)           */
#define vic_xpic_app_xpic_vic_irq_addr_val_Msk (0xffffffffUL)       /*!< vic_xpic_app xpic_vic_irq_addr: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_vic_vector_addr  ================================================== */
#define vic_xpic_app_xpic_vic_vector_addr_val_Pos (0UL)             /*!< vic_xpic_app xpic_vic_vector_addr: val (Bit 0)        */
#define vic_xpic_app_xpic_vic_vector_addr_val_Msk (0xffffffffUL)    /*!< vic_xpic_app xpic_vic_vector_addr: val (Bitfield-Mask: 0xffffffff) */
/* ===============================================  xpic_vic_table_base_addr  ================================================ */
#define vic_xpic_app_xpic_vic_table_base_addr_val_Pos (0UL)         /*!< vic_xpic_app xpic_vic_table_base_addr: val (Bit 0)    */
#define vic_xpic_app_xpic_vic_table_base_addr_val_Msk (0xffffffffUL) /*!< vic_xpic_app xpic_vic_table_base_addr: val (Bitfield-Mask: 0xffffffff) */
/* ===============================================  xpic_vic_fiq_vect_config  ================================================ */
#define vic_xpic_app_xpic_vic_fiq_vect_config_enable_Pos (31UL)     /*!< vic_xpic_app xpic_vic_fiq_vect_config: enable (Bit 31) */
#define vic_xpic_app_xpic_vic_fiq_vect_config_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_fiq_vect_config: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_fiq_vect_config_select_fiq_default_Pos (30UL) /*!< vic_xpic_app xpic_vic_fiq_vect_config: select_fiq_default (Bit 30) */
#define vic_xpic_app_xpic_vic_fiq_vect_config_select_fiq_default_Msk (0x40000000UL) /*!< vic_xpic_app xpic_vic_fiq_vect_config: select_fiq_default (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_fiq_vect_config_reserved0_Pos (7UL)   /*!< vic_xpic_app xpic_vic_fiq_vect_config: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_fiq_vect_config_reserved0_Msk (0x3fffff80UL) /*!< vic_xpic_app xpic_vic_fiq_vect_config: reserved0 (Bitfield-Mask: 0x7fffff) */
#define vic_xpic_app_xpic_vic_fiq_vect_config_int_source_Pos (0UL)  /*!< vic_xpic_app xpic_vic_fiq_vect_config: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_fiq_vect_config_int_source_Msk (0x7fUL) /*!< vic_xpic_app xpic_vic_fiq_vect_config: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config0  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config0_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config0: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config0_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config0: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config0_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config0: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config0_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config0: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config0_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config0: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config0_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config0: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config1  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config1_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config1: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config1_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config1: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config1_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config1: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config1_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config1: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config1_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config1: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config1_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config1: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config2  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config2_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config2: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config2_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config2: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config2_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config2: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config2_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config2: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config2_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config2: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config2_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config2: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config3  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config3_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config3: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config3_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config3: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config3_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config3: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config3_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config3: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config3_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config3: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config3_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config3: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config4  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config4_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config4: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config4_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config4: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config4_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config4: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config4_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config4: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config4_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config4: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config4_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config4: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config5  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config5_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config5: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config5_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config5: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config5_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config5: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config5_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config5: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config5_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config5: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config5_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config5: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config6  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config6_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config6: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config6_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config6: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config6_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config6: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config6_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config6: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config6_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config6: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config6_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config6: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config7  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config7_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config7: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config7_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config7: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config7_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config7: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config7_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config7: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config7_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config7: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config7_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config7: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config8  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config8_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config8: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config8_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config8: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config8_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config8: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config8_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config8: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config8_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config8: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config8_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config8: int_source (Bitfield-Mask: 0x7f) */
/* =================================================  xpic_vic_vect_config9  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config9_enable_Pos (31UL)        /*!< vic_xpic_app xpic_vic_vect_config9: enable (Bit 31)   */
#define vic_xpic_app_xpic_vic_vect_config9_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config9: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config9_reserved0_Pos (7UL)      /*!< vic_xpic_app xpic_vic_vect_config9: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config9_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config9: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config9_int_source_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config9: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config9_int_source_Msk (0x7fUL)  /*!< vic_xpic_app xpic_vic_vect_config9: int_source (Bitfield-Mask: 0x7f) */
/* ================================================  xpic_vic_vect_config10  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config10_enable_Pos (31UL)       /*!< vic_xpic_app xpic_vic_vect_config10: enable (Bit 31)  */
#define vic_xpic_app_xpic_vic_vect_config10_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config10: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config10_reserved0_Pos (7UL)     /*!< vic_xpic_app xpic_vic_vect_config10: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config10_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config10: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config10_int_source_Pos (0UL)    /*!< vic_xpic_app xpic_vic_vect_config10: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config10_int_source_Msk (0x7fUL) /*!< vic_xpic_app xpic_vic_vect_config10: int_source (Bitfield-Mask: 0x7f) */
/* ================================================  xpic_vic_vect_config11  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config11_enable_Pos (31UL)       /*!< vic_xpic_app xpic_vic_vect_config11: enable (Bit 31)  */
#define vic_xpic_app_xpic_vic_vect_config11_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config11: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config11_reserved0_Pos (7UL)     /*!< vic_xpic_app xpic_vic_vect_config11: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config11_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config11: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config11_int_source_Pos (0UL)    /*!< vic_xpic_app xpic_vic_vect_config11: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config11_int_source_Msk (0x7fUL) /*!< vic_xpic_app xpic_vic_vect_config11: int_source (Bitfield-Mask: 0x7f) */
/* ================================================  xpic_vic_vect_config12  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config12_enable_Pos (31UL)       /*!< vic_xpic_app xpic_vic_vect_config12: enable (Bit 31)  */
#define vic_xpic_app_xpic_vic_vect_config12_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config12: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config12_reserved0_Pos (7UL)     /*!< vic_xpic_app xpic_vic_vect_config12: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config12_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config12: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config12_int_source_Pos (0UL)    /*!< vic_xpic_app xpic_vic_vect_config12: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config12_int_source_Msk (0x7fUL) /*!< vic_xpic_app xpic_vic_vect_config12: int_source (Bitfield-Mask: 0x7f) */
/* ================================================  xpic_vic_vect_config13  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config13_enable_Pos (31UL)       /*!< vic_xpic_app xpic_vic_vect_config13: enable (Bit 31)  */
#define vic_xpic_app_xpic_vic_vect_config13_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config13: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config13_reserved0_Pos (7UL)     /*!< vic_xpic_app xpic_vic_vect_config13: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config13_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config13: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config13_int_source_Pos (0UL)    /*!< vic_xpic_app xpic_vic_vect_config13: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config13_int_source_Msk (0x7fUL) /*!< vic_xpic_app xpic_vic_vect_config13: int_source (Bitfield-Mask: 0x7f) */
/* ================================================  xpic_vic_vect_config14  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config14_enable_Pos (31UL)       /*!< vic_xpic_app xpic_vic_vect_config14: enable (Bit 31)  */
#define vic_xpic_app_xpic_vic_vect_config14_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config14: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config14_reserved0_Pos (7UL)     /*!< vic_xpic_app xpic_vic_vect_config14: reserved0 (Bit 7) */
#define vic_xpic_app_xpic_vic_vect_config14_reserved0_Msk (0x7fffff80UL) /*!< vic_xpic_app xpic_vic_vect_config14: reserved0 (Bitfield-Mask: 0xffffff) */
#define vic_xpic_app_xpic_vic_vect_config14_int_source_Pos (0UL)    /*!< vic_xpic_app xpic_vic_vect_config14: int_source (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config14_int_source_Msk (0x7fUL) /*!< vic_xpic_app xpic_vic_vect_config14: int_source (Bitfield-Mask: 0x7f) */
/* ================================================  xpic_vic_vect_config15  ================================================= */
#define vic_xpic_app_xpic_vic_vect_config15_enable_Pos (31UL)       /*!< vic_xpic_app xpic_vic_vect_config15: enable (Bit 31)  */
#define vic_xpic_app_xpic_vic_vect_config15_enable_Msk (0x80000000UL) /*!< vic_xpic_app xpic_vic_vect_config15: enable (Bitfield-Mask: 0x01) */
#define vic_xpic_app_xpic_vic_vect_config15_reserved0_Pos (0UL)     /*!< vic_xpic_app xpic_vic_vect_config15: reserved0 (Bit 0) */
#define vic_xpic_app_xpic_vic_vect_config15_reserved0_Msk (0x7fffffffUL) /*!< vic_xpic_app xpic_vic_vect_config15: reserved0 (Bitfield-Mask: 0x7fffffff) */
/* ===================================================  xpic_vic_default0  =================================================== */
#define vic_xpic_app_xpic_vic_default0_val_Pos (0UL)                /*!< vic_xpic_app xpic_vic_default0: val (Bit 0)           */
#define vic_xpic_app_xpic_vic_default0_val_Msk (0xffffffffUL)       /*!< vic_xpic_app xpic_vic_default0: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_vic_default1  =================================================== */
#define vic_xpic_app_xpic_vic_default1_val_Pos (0UL)                /*!< vic_xpic_app xpic_vic_default1: val (Bit 0)           */
#define vic_xpic_app_xpic_vic_default1_val_Msk (0xffffffffUL)       /*!< vic_xpic_app xpic_vic_default1: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  xpic_vic_default2  =================================================== */
#define vic_xpic_app_xpic_vic_default2_val_Pos (0UL)                /*!< vic_xpic_app xpic_vic_default2: val (Bit 0)           */
#define vic_xpic_app_xpic_vic_default2_val_Msk (0xffffffffUL)       /*!< vic_xpic_app xpic_vic_default2: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_vic_fiq_default0  ================================================= */
#define vic_xpic_app_xpic_vic_fiq_default0_val_Pos (0UL)            /*!< vic_xpic_app xpic_vic_fiq_default0: val (Bit 0)       */
#define vic_xpic_app_xpic_vic_fiq_default0_val_Msk (0xffffffffUL)   /*!< vic_xpic_app xpic_vic_fiq_default0: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_vic_fiq_default1  ================================================= */
#define vic_xpic_app_xpic_vic_fiq_default1_val_Pos (0UL)            /*!< vic_xpic_app xpic_vic_fiq_default1: val (Bit 0)       */
#define vic_xpic_app_xpic_vic_fiq_default1_val_Msk (0xffffffffUL)   /*!< vic_xpic_app xpic_vic_fiq_default1: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  xpic_vic_fiq_default2  ================================================= */
#define vic_xpic_app_xpic_vic_fiq_default2_val_Pos (0UL)            /*!< vic_xpic_app xpic_vic_fiq_default2: val (Bit 0)       */
#define vic_xpic_app_xpic_vic_fiq_default2_val_Msk (0xffffffffUL)   /*!< vic_xpic_app xpic_vic_fiq_default2: val (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                      timer_xpic_app                                       ================ */
/* =========================================================================================================================== */

/* ==================================================  timer_config_timer0  ================================================== */
#define timer_xpic_app_timer_config_timer0_systime_config_Pos (2UL) /*!< timer_xpic_app timer_config_timer0: systime_config (Bit 2) */
#define timer_xpic_app_timer_config_timer0_systime_config_Msk (0xcUL) /*!< timer_xpic_app timer_config_timer0: systime_config (Bitfield-Mask: 0x03) */
#define timer_xpic_app_timer_config_timer0_mode_Pos (0UL)           /*!< timer_xpic_app timer_config_timer0: mode (Bit 0)      */
#define timer_xpic_app_timer_config_timer0_mode_Msk (0x3UL)         /*!< timer_xpic_app timer_config_timer0: mode (Bitfield-Mask: 0x03) */
/* ==================================================  timer_config_timer1  ================================================== */
#define timer_xpic_app_timer_config_timer1_systime_config_Pos (2UL) /*!< timer_xpic_app timer_config_timer1: systime_config (Bit 2) */
#define timer_xpic_app_timer_config_timer1_systime_config_Msk (0xcUL) /*!< timer_xpic_app timer_config_timer1: systime_config (Bitfield-Mask: 0x03) */
#define timer_xpic_app_timer_config_timer1_mode_Pos (0UL)           /*!< timer_xpic_app timer_config_timer1: mode (Bit 0)      */
#define timer_xpic_app_timer_config_timer1_mode_Msk (0x3UL)         /*!< timer_xpic_app timer_config_timer1: mode (Bitfield-Mask: 0x03) */
/* ==================================================  timer_config_timer2  ================================================== */
#define timer_xpic_app_timer_config_timer2_systime_config_Pos (2UL) /*!< timer_xpic_app timer_config_timer2: systime_config (Bit 2) */
#define timer_xpic_app_timer_config_timer2_systime_config_Msk (0xcUL) /*!< timer_xpic_app timer_config_timer2: systime_config (Bitfield-Mask: 0x03) */
#define timer_xpic_app_timer_config_timer2_mode_Pos (0UL)           /*!< timer_xpic_app timer_config_timer2: mode (Bit 0)      */
#define timer_xpic_app_timer_config_timer2_mode_Msk (0x3UL)         /*!< timer_xpic_app timer_config_timer2: mode (Bitfield-Mask: 0x03) */
/* =================================================  timer_preload_timer0  ================================================== */
#define timer_xpic_app_timer_preload_timer0_val_Pos (0UL)           /*!< timer_xpic_app timer_preload_timer0: val (Bit 0)      */
#define timer_xpic_app_timer_preload_timer0_val_Msk (0xffffffffUL)  /*!< timer_xpic_app timer_preload_timer0: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  timer_preload_timer1  ================================================== */
#define timer_xpic_app_timer_preload_timer1_val_Pos (0UL)           /*!< timer_xpic_app timer_preload_timer1: val (Bit 0)      */
#define timer_xpic_app_timer_preload_timer1_val_Msk (0xffffffffUL)  /*!< timer_xpic_app timer_preload_timer1: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  timer_preload_timer2  ================================================== */
#define timer_xpic_app_timer_preload_timer2_val_Pos (0UL)           /*!< timer_xpic_app timer_preload_timer2: val (Bit 0)      */
#define timer_xpic_app_timer_preload_timer2_val_Msk (0xffffffffUL)  /*!< timer_xpic_app timer_preload_timer2: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  timer_timer0  ====================================================== */
#define timer_xpic_app_timer_timer0_val_Pos (0UL)                   /*!< timer_xpic_app timer_timer0: val (Bit 0)              */
#define timer_xpic_app_timer_timer0_val_Msk (0xffffffffUL)          /*!< timer_xpic_app timer_timer0: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  timer_timer1  ====================================================== */
#define timer_xpic_app_timer_timer1_val_Pos (0UL)                   /*!< timer_xpic_app timer_timer1: val (Bit 0)              */
#define timer_xpic_app_timer_timer1_val_Msk (0xffffffffUL)          /*!< timer_xpic_app timer_timer1: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  timer_timer2  ====================================================== */
#define timer_xpic_app_timer_timer2_val_Pos (0UL)                   /*!< timer_xpic_app timer_timer2: val (Bit 0)              */
#define timer_xpic_app_timer_timer2_val_Msk (0xffffffffUL)          /*!< timer_xpic_app timer_timer2: val (Bitfield-Mask: 0xffffffff) */
/* ====================================================  timer_systime_s  ==================================================== */
#define timer_xpic_app_timer_systime_s_val_Pos (0UL)                /*!< timer_xpic_app timer_systime_s: val (Bit 0)           */
#define timer_xpic_app_timer_systime_s_val_Msk (0xffffffffUL)       /*!< timer_xpic_app timer_systime_s: val (Bitfield-Mask: 0xffffffff) */
/* ===================================================  timer_systime_ns  ==================================================== */
#define timer_xpic_app_timer_systime_ns_val_Pos (0UL)               /*!< timer_xpic_app timer_systime_ns: val (Bit 0)          */
#define timer_xpic_app_timer_systime_ns_val_Msk (0xffffffffUL)      /*!< timer_xpic_app timer_systime_ns: val (Bitfield-Mask: 0xffffffff) */
/* =============================================  timer_compare_systime_s_value  ============================================= */
#define timer_xpic_app_timer_compare_systime_s_value_val_Pos (0UL)  /*!< timer_xpic_app timer_compare_systime_s_value: val (Bit 0) */
#define timer_xpic_app_timer_compare_systime_s_value_val_Msk (0xffffffffUL) /*!< timer_xpic_app timer_compare_systime_s_value: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  timer_irq_raw  ===================================================== */
#define timer_xpic_app_timer_irq_raw_systime_s_irq_Pos (3UL)        /*!< timer_xpic_app timer_irq_raw: systime_s_irq (Bit 3)   */
#define timer_xpic_app_timer_irq_raw_systime_s_irq_Msk (0x8UL)      /*!< timer_xpic_app timer_irq_raw: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_raw_timer2_irq_Pos (2UL)           /*!< timer_xpic_app timer_irq_raw: timer2_irq (Bit 2)      */
#define timer_xpic_app_timer_irq_raw_timer2_irq_Msk (0x4UL)         /*!< timer_xpic_app timer_irq_raw: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_raw_timer1_irq_Pos (1UL)           /*!< timer_xpic_app timer_irq_raw: timer1_irq (Bit 1)      */
#define timer_xpic_app_timer_irq_raw_timer1_irq_Msk (0x2UL)         /*!< timer_xpic_app timer_irq_raw: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_raw_timer0_irq_Pos (0UL)           /*!< timer_xpic_app timer_irq_raw: timer0_irq (Bit 0)      */
#define timer_xpic_app_timer_irq_raw_timer0_irq_Msk (0x1UL)         /*!< timer_xpic_app timer_irq_raw: timer0_irq (Bitfield-Mask: 0x01) */
/* ===================================================  timer_irq_masked  ==================================================== */
#define timer_xpic_app_timer_irq_masked_systime_s_irq_Pos (3UL)     /*!< timer_xpic_app timer_irq_masked: systime_s_irq (Bit 3) */
#define timer_xpic_app_timer_irq_masked_systime_s_irq_Msk (0x8UL)   /*!< timer_xpic_app timer_irq_masked: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_masked_timer2_irq_Pos (2UL)        /*!< timer_xpic_app timer_irq_masked: timer2_irq (Bit 2)   */
#define timer_xpic_app_timer_irq_masked_timer2_irq_Msk (0x4UL)      /*!< timer_xpic_app timer_irq_masked: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_masked_timer1_irq_Pos (1UL)        /*!< timer_xpic_app timer_irq_masked: timer1_irq (Bit 1)   */
#define timer_xpic_app_timer_irq_masked_timer1_irq_Msk (0x2UL)      /*!< timer_xpic_app timer_irq_masked: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_masked_timer0_irq_Pos (0UL)        /*!< timer_xpic_app timer_irq_masked: timer0_irq (Bit 0)   */
#define timer_xpic_app_timer_irq_masked_timer0_irq_Msk (0x1UL)      /*!< timer_xpic_app timer_irq_masked: timer0_irq (Bitfield-Mask: 0x01) */
/* ===================================================  timer_irq_msk_set  =================================================== */
#define timer_xpic_app_timer_irq_msk_set_systime_s_irq_Pos (3UL)    /*!< timer_xpic_app timer_irq_msk_set: systime_s_irq (Bit 3) */
#define timer_xpic_app_timer_irq_msk_set_systime_s_irq_Msk (0x8UL)  /*!< timer_xpic_app timer_irq_msk_set: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_msk_set_timer2_irq_Pos (2UL)       /*!< timer_xpic_app timer_irq_msk_set: timer2_irq (Bit 2)  */
#define timer_xpic_app_timer_irq_msk_set_timer2_irq_Msk (0x4UL)     /*!< timer_xpic_app timer_irq_msk_set: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_msk_set_timer1_irq_Pos (1UL)       /*!< timer_xpic_app timer_irq_msk_set: timer1_irq (Bit 1)  */
#define timer_xpic_app_timer_irq_msk_set_timer1_irq_Msk (0x2UL)     /*!< timer_xpic_app timer_irq_msk_set: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_msk_set_timer0_irq_Pos (0UL)       /*!< timer_xpic_app timer_irq_msk_set: timer0_irq (Bit 0)  */
#define timer_xpic_app_timer_irq_msk_set_timer0_irq_Msk (0x1UL)     /*!< timer_xpic_app timer_irq_msk_set: timer0_irq (Bitfield-Mask: 0x01) */
/* ==================================================  timer_irq_msk_reset  ================================================== */
#define timer_xpic_app_timer_irq_msk_reset_systime_s_irq_Pos (3UL)  /*!< timer_xpic_app timer_irq_msk_reset: systime_s_irq (Bit 3) */
#define timer_xpic_app_timer_irq_msk_reset_systime_s_irq_Msk (0x8UL) /*!< timer_xpic_app timer_irq_msk_reset: systime_s_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_msk_reset_timer2_irq_Pos (2UL)     /*!< timer_xpic_app timer_irq_msk_reset: timer2_irq (Bit 2) */
#define timer_xpic_app_timer_irq_msk_reset_timer2_irq_Msk (0x4UL)   /*!< timer_xpic_app timer_irq_msk_reset: timer2_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_msk_reset_timer1_irq_Pos (1UL)     /*!< timer_xpic_app timer_irq_msk_reset: timer1_irq (Bit 1) */
#define timer_xpic_app_timer_irq_msk_reset_timer1_irq_Msk (0x2UL)   /*!< timer_xpic_app timer_irq_msk_reset: timer1_irq (Bitfield-Mask: 0x01) */
#define timer_xpic_app_timer_irq_msk_reset_timer0_irq_Pos (0UL)     /*!< timer_xpic_app timer_irq_msk_reset: timer0_irq (Bit 0) */
#define timer_xpic_app_timer_irq_msk_reset_timer0_irq_Msk (0x1UL)   /*!< timer_xpic_app timer_irq_msk_reset: timer0_irq (Bitfield-Mask: 0x01) */
/* =================================================  timer_systime_config  ================================================== */
#define timer_xpic_app_timer_systime_config_systime_config_Pos (0UL) /*!< timer_xpic_app timer_systime_config: systime_config (Bit 0) */
#define timer_xpic_app_timer_systime_config_systime_config_Msk (0x3UL) /*!< timer_xpic_app timer_systime_config: systime_config (Bitfield-Mask: 0x03) */


/* =========================================================================================================================== */
/* ================                                       wdg_xpic_app                                        ================ */
/* =========================================================================================================================== */

/* =====================================================  xpic_wdg_trig  ===================================================== */
#define wdg_xpic_app_xpic_wdg_trig_write_enable_Pos (31UL)          /*!< wdg_xpic_app xpic_wdg_trig: write_enable (Bit 31)     */
#define wdg_xpic_app_xpic_wdg_trig_write_enable_Msk (0x80000000UL)  /*!< wdg_xpic_app xpic_wdg_trig: write_enable (Bitfield-Mask: 0x01) */
#define wdg_xpic_app_xpic_wdg_trig_reserved2_Pos (29UL)             /*!< wdg_xpic_app xpic_wdg_trig: reserved2 (Bit 29)        */
#define wdg_xpic_app_xpic_wdg_trig_reserved2_Msk (0x60000000UL)     /*!< wdg_xpic_app xpic_wdg_trig: reserved2 (Bitfield-Mask: 0x03) */
#define wdg_xpic_app_xpic_wdg_trig_wdg_counter_trigger_w_Pos (28UL) /*!< wdg_xpic_app xpic_wdg_trig: wdg_counter_trigger_w (Bit 28) */
#define wdg_xpic_app_xpic_wdg_trig_wdg_counter_trigger_w_Msk (0x10000000UL) /*!< wdg_xpic_app xpic_wdg_trig: wdg_counter_trigger_w (Bitfield-Mask: 0x01) */
#define wdg_xpic_app_xpic_wdg_trig_reserved1_Pos (25UL)             /*!< wdg_xpic_app xpic_wdg_trig: reserved1 (Bit 25)        */
#define wdg_xpic_app_xpic_wdg_trig_reserved1_Msk (0xe000000UL)      /*!< wdg_xpic_app xpic_wdg_trig: reserved1 (Bitfield-Mask: 0x07) */
#define wdg_xpic_app_xpic_wdg_trig_irq_req_watchdog_Pos (24UL)      /*!< wdg_xpic_app xpic_wdg_trig: irq_req_watchdog (Bit 24) */
#define wdg_xpic_app_xpic_wdg_trig_irq_req_watchdog_Msk (0x1000000UL) /*!< wdg_xpic_app xpic_wdg_trig: irq_req_watchdog (Bitfield-Mask: 0x01) */
#define wdg_xpic_app_xpic_wdg_trig_reserved0_Pos (20UL)             /*!< wdg_xpic_app xpic_wdg_trig: reserved0 (Bit 20)        */
#define wdg_xpic_app_xpic_wdg_trig_reserved0_Msk (0xf00000UL)       /*!< wdg_xpic_app xpic_wdg_trig: reserved0 (Bitfield-Mask: 0x0f) */
#define wdg_xpic_app_xpic_wdg_trig_wdg_access_code_Pos (0UL)        /*!< wdg_xpic_app xpic_wdg_trig: wdg_access_code (Bit 0)   */
#define wdg_xpic_app_xpic_wdg_trig_wdg_access_code_Msk (0xfffffUL)  /*!< wdg_xpic_app xpic_wdg_trig: wdg_access_code (Bitfield-Mask: 0xfffff) */
/* ===================================================  xpic_wdg_counter  ==================================================== */
#define wdg_xpic_app_xpic_wdg_counter_val_Pos (0UL)                 /*!< wdg_xpic_app xpic_wdg_counter: val (Bit 0)            */
#define wdg_xpic_app_xpic_wdg_counter_val_Msk (0x1ffffUL)           /*!< wdg_xpic_app xpic_wdg_counter: val (Bitfield-Mask: 0x1ffff) */
/* ===============================================  xpic_wdg_xpic_irq_timeout  =============================================== */
#define wdg_xpic_app_xpic_wdg_xpic_irq_timeout_val_Pos (0UL)        /*!< wdg_xpic_app xpic_wdg_xpic_irq_timeout: val (Bit 0)   */
#define wdg_xpic_app_xpic_wdg_xpic_irq_timeout_val_Msk (0xffffUL)   /*!< wdg_xpic_app xpic_wdg_xpic_irq_timeout: val (Bitfield-Mask: 0xffff) */
/* ===============================================  xpic_wdg_arm_irq_timeout  ================================================ */
#define wdg_xpic_app_xpic_wdg_arm_irq_timeout_val_Pos (0UL)         /*!< wdg_xpic_app xpic_wdg_arm_irq_timeout: val (Bit 0)    */
#define wdg_xpic_app_xpic_wdg_arm_irq_timeout_val_Msk (0xffffUL)    /*!< wdg_xpic_app xpic_wdg_arm_irq_timeout: val (Bitfield-Mask: 0xffff) */
/* ===================================================  xpic_wdg_irq_raw  ==================================================== */
#define wdg_xpic_app_xpic_wdg_irq_raw_wdg_arm_irq_Pos (0UL)         /*!< wdg_xpic_app xpic_wdg_irq_raw: wdg_arm_irq (Bit 0)    */
#define wdg_xpic_app_xpic_wdg_irq_raw_wdg_arm_irq_Msk (0x1UL)       /*!< wdg_xpic_app xpic_wdg_irq_raw: wdg_arm_irq (Bitfield-Mask: 0x01) */
/* ==================================================  xpic_wdg_irq_masked  ================================================== */
#define wdg_xpic_app_xpic_wdg_irq_masked_wdg_arm_irq_Pos (0UL)      /*!< wdg_xpic_app xpic_wdg_irq_masked: wdg_arm_irq (Bit 0) */
#define wdg_xpic_app_xpic_wdg_irq_masked_wdg_arm_irq_Msk (0x1UL)    /*!< wdg_xpic_app xpic_wdg_irq_masked: wdg_arm_irq (Bitfield-Mask: 0x01) */
/* =================================================  xpic_wdg_irq_msk_set  ================================================== */
#define wdg_xpic_app_xpic_wdg_irq_msk_set_wdg_arm_irq_Pos (0UL)     /*!< wdg_xpic_app xpic_wdg_irq_msk_set: wdg_arm_irq (Bit 0) */
#define wdg_xpic_app_xpic_wdg_irq_msk_set_wdg_arm_irq_Msk (0x1UL)   /*!< wdg_xpic_app xpic_wdg_irq_msk_set: wdg_arm_irq (Bitfield-Mask: 0x01) */
/* ================================================  xpic_wdg_irq_msk_reset  ================================================= */
#define wdg_xpic_app_xpic_wdg_irq_msk_reset_wdg_arm_irq_Pos (0UL)   /*!< wdg_xpic_app xpic_wdg_irq_msk_reset: wdg_arm_irq (Bit 0) */
#define wdg_xpic_app_xpic_wdg_irq_msk_reset_wdg_arm_irq_Msk (0x1UL) /*!< wdg_xpic_app xpic_wdg_irq_msk_reset: wdg_arm_irq (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                       mcp_xpic_app                                        ================ */
/* =========================================================================================================================== */

/* ====================================================  hs_irq_set_raw  ===================================================== */
#define mcp_xpic_app_hs_irq_set_raw_hs_irq_set_bits_Pos (0UL)       /*!< mcp_xpic_app hs_irq_set_raw: hs_irq_set_bits (Bit 0)  */
#define mcp_xpic_app_hs_irq_set_raw_hs_irq_set_bits_Msk (0xffffffffUL) /*!< mcp_xpic_app hs_irq_set_raw: hs_irq_set_bits (Bitfield-Mask: 0xffffffff) */
/* ===================================================  hs_irq_reset_raw  ==================================================== */
#define mcp_xpic_app_hs_irq_reset_raw_hs_irq_reset_bits_Pos (0UL)   /*!< mcp_xpic_app hs_irq_reset_raw: hs_irq_reset_bits (Bit 0) */
#define mcp_xpic_app_hs_irq_reset_raw_hs_irq_reset_bits_Msk (0xffffffffUL) /*!< mcp_xpic_app hs_irq_reset_raw: hs_irq_reset_bits (Bitfield-Mask: 0xffffffff) */
/* ====================================================  hs_irq_set_mask  ==================================================== */
#define mcp_xpic_app_hs_irq_set_mask_hs_irq_set_mask_Pos (0UL)      /*!< mcp_xpic_app hs_irq_set_mask: hs_irq_set_mask (Bit 0) */
#define mcp_xpic_app_hs_irq_set_mask_hs_irq_set_mask_Msk (0xffffffffUL) /*!< mcp_xpic_app hs_irq_set_mask: hs_irq_set_mask (Bitfield-Mask: 0xffffffff) */
/* ===================================================  hs_irq_reset_mask  =================================================== */
#define mcp_xpic_app_hs_irq_reset_mask_hs_irq_reset_mask_Pos (0UL)  /*!< mcp_xpic_app hs_irq_reset_mask: hs_irq_reset_mask (Bit 0) */
#define mcp_xpic_app_hs_irq_reset_mask_hs_irq_reset_mask_Msk (0xffffffffUL) /*!< mcp_xpic_app hs_irq_reset_mask: hs_irq_reset_mask (Bitfield-Mask: 0xffffffff) */
/* =====================================================  hs_irq_masked  ===================================================== */
#define mcp_xpic_app_hs_irq_masked_hs_irq_masked_Pos (0UL)          /*!< mcp_xpic_app hs_irq_masked: hs_irq_masked (Bit 0)     */
#define mcp_xpic_app_hs_irq_masked_hs_irq_masked_Msk (0xffffffffUL) /*!< mcp_xpic_app hs_irq_masked: hs_irq_masked (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                    systime_lt_xpic_app                                    ================ */
/* =========================================================================================================================== */

/* ==============================================  intlogic_lt_systime_com_ns  =============================================== */
#define systime_lt_xpic_app_intlogic_lt_systime_com_ns_val_Pos (0UL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_ns: val (Bit 0) */
#define systime_lt_xpic_app_intlogic_lt_systime_com_ns_val_Msk (0xffffffffUL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_ns: val (Bitfield-Mask: 0xffffffff) */
/* ===============================================  intlogic_lt_systime_com_s  =============================================== */
#define systime_lt_xpic_app_intlogic_lt_systime_com_s_val_Pos (0UL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_s: val (Bit 0) */
#define systime_lt_xpic_app_intlogic_lt_systime_com_s_val_Msk (0xffffffffUL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_s: val (Bitfield-Mask: 0xffffffff) */
/* =============================================  intlogic_lt_systime_com_uc_ns  ============================================= */
#define systime_lt_xpic_app_intlogic_lt_systime_com_uc_ns_val_Pos (0UL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_uc_ns: val (Bit 0) */
#define systime_lt_xpic_app_intlogic_lt_systime_com_uc_ns_val_Msk (0xffffffffUL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_uc_ns: val (Bitfield-Mask: 0xffffffff) */
/* =============================================  intlogic_lt_systime_com_uc_s  ============================================== */
#define systime_lt_xpic_app_intlogic_lt_systime_com_uc_s_val_Pos (0UL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_uc_s: val (Bit 0) */
#define systime_lt_xpic_app_intlogic_lt_systime_com_uc_s_val_Msk (0xffffffffUL) /*!< systime_lt_xpic_app intlogic_lt_systime_com_uc_s: val (Bitfield-Mask: 0xffffffff) */
/* ==============================================  intlogic_lt_systime_app_ns  =============================================== */
#define systime_lt_xpic_app_intlogic_lt_systime_app_ns_val_Pos (0UL) /*!< systime_lt_xpic_app intlogic_lt_systime_app_ns: val (Bit 0) */
#define systime_lt_xpic_app_intlogic_lt_systime_app_ns_val_Msk (0xffffffffUL) /*!< systime_lt_xpic_app intlogic_lt_systime_app_ns: val (Bitfield-Mask: 0xffffffff) */
/* ===============================================  intlogic_lt_systime_app_s  =============================================== */
#define systime_lt_xpic_app_intlogic_lt_systime_app_s_val_Pos (0UL) /*!< systime_lt_xpic_app intlogic_lt_systime_app_s: val (Bit 0) */
#define systime_lt_xpic_app_intlogic_lt_systime_app_s_val_Msk (0xffffffffUL) /*!< systime_lt_xpic_app intlogic_lt_systime_app_s: val (Bitfield-Mask: 0xffffffff) */
/* ==============================================  intlogic_lt_systimes_latch  =============================================== */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_app_s_Pos (5UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_app_s (Bit 5) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_app_s_Msk (0x20UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_app_s (Bitfield-Mask: 0x01) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_app_ns_Pos (4UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_app_ns (Bit 4) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_app_ns_Msk (0x10UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_app_ns (Bitfield-Mask: 0x01) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_uc_s_Pos (3UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_uc_s (Bit 3) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_uc_s_Msk (0x8UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_uc_s (Bitfield-Mask: 0x01) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_uc_ns_Pos (2UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_uc_ns (Bit 2) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_uc_ns_Msk (0x4UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_uc_ns (Bitfield-Mask: 0x01) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_s_Pos (1UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_s (Bit 1) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_s_Msk (0x2UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_s (Bitfield-Mask: 0x01) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_ns_Pos (0UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_ns (Bit 0) */
#define systime_lt_xpic_app_intlogic_lt_systimes_latch_systime_com_ns_Msk (0x1UL) /*!< systime_lt_xpic_app intlogic_lt_systimes_latch: systime_com_ns (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                       gpio_xpic_app                                       ================ */
/* =========================================================================================================================== */

/* =====================================================  gpio_app_cfg0  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg0_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg0: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg0_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg0: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg0_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg0: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg0_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg0: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg0_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg0: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg0_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg0: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg0_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg0: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg0_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg0: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg0_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg0: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg0_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg0: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_cfg1  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg1_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg1: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg1_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg1: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg1_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg1: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg1_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg1: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg1_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg1: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg1_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg1: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg1_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg1: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg1_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg1: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg1_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg1: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg1_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg1: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_cfg2  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg2_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg2: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg2_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg2: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg2_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg2: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg2_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg2: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg2_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg2: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg2_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg2: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg2_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg2: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg2_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg2: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg2_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg2: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg2_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg2: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_cfg3  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg3_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg3: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg3_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg3: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg3_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg3: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg3_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg3: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg3_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg3: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg3_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg3: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg3_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg3: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg3_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg3: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg3_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg3: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg3_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg3: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_cfg4  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg4_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg4: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg4_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg4: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg4_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg4: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg4_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg4: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg4_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg4: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg4_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg4: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg4_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg4: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg4_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg4: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg4_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg4: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg4_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg4: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_cfg5  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg5_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg5: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg5_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg5: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg5_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg5: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg5_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg5: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg5_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg5: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg5_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg5: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg5_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg5: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg5_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg5: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg5_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg5: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg5_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg5: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_cfg6  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg6_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg6: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg6_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg6: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg6_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg6: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg6_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg6: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg6_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg6: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg6_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg6: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg6_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg6: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg6_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg6: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg6_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg6: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg6_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg6: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_cfg7  ===================================================== */
#define gpio_xpic_app_gpio_app_cfg7_blink_once_Pos (12UL)           /*!< gpio_xpic_app gpio_app_cfg7: blink_once (Bit 12)      */
#define gpio_xpic_app_gpio_app_cfg7_blink_once_Msk (0x1000UL)       /*!< gpio_xpic_app gpio_app_cfg7: blink_once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg7_blink_len_Pos (7UL)             /*!< gpio_xpic_app gpio_app_cfg7: blink_len (Bit 7)        */
#define gpio_xpic_app_gpio_app_cfg7_blink_len_Msk (0xf80UL)         /*!< gpio_xpic_app gpio_app_cfg7: blink_len (Bitfield-Mask: 0x1f) */
#define gpio_xpic_app_gpio_app_cfg7_count_ref_Pos (5UL)             /*!< gpio_xpic_app gpio_app_cfg7: count_ref (Bit 5)        */
#define gpio_xpic_app_gpio_app_cfg7_count_ref_Msk (0x60UL)          /*!< gpio_xpic_app gpio_app_cfg7: count_ref (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_cfg7_inv_Pos (4UL)                   /*!< gpio_xpic_app gpio_app_cfg7: inv (Bit 4)              */
#define gpio_xpic_app_gpio_app_cfg7_inv_Msk (0x10UL)                /*!< gpio_xpic_app gpio_app_cfg7: inv (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cfg7_mode_Pos (0UL)                  /*!< gpio_xpic_app gpio_app_cfg7: mode (Bit 0)             */
#define gpio_xpic_app_gpio_app_cfg7_mode_Msk (0xfUL)                /*!< gpio_xpic_app gpio_app_cfg7: mode (Bitfield-Mask: 0x0f) */
/* =====================================================  gpio_app_tc0  ====================================================== */
#define gpio_xpic_app_gpio_app_tc0_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc0: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc0_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc0: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_tc1  ====================================================== */
#define gpio_xpic_app_gpio_app_tc1_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc1: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc1_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc1: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_tc2  ====================================================== */
#define gpio_xpic_app_gpio_app_tc2_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc2: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc2_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc2: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_tc3  ====================================================== */
#define gpio_xpic_app_gpio_app_tc3_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc3: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc3_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc3: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_tc4  ====================================================== */
#define gpio_xpic_app_gpio_app_tc4_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc4: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc4_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc4: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_tc5  ====================================================== */
#define gpio_xpic_app_gpio_app_tc5_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc5: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc5_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc5: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_tc6  ====================================================== */
#define gpio_xpic_app_gpio_app_tc6_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc6: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc6_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc6: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_tc7  ====================================================== */
#define gpio_xpic_app_gpio_app_tc7_val_Pos (0UL)                    /*!< gpio_xpic_app gpio_app_tc7: val (Bit 0)               */
#define gpio_xpic_app_gpio_app_tc7_val_Msk (0xffffffffUL)           /*!< gpio_xpic_app gpio_app_tc7: val (Bitfield-Mask: 0xffffffff) */
/* ================================================  gpio_app_counter0_ctrl  ================================================= */
#define gpio_xpic_app_gpio_app_counter0_ctrl_gpio_ref_Pos (7UL)     /*!< gpio_xpic_app gpio_app_counter0_ctrl: gpio_ref (Bit 7) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_gpio_ref_Msk (0x380UL) /*!< gpio_xpic_app gpio_app_counter0_ctrl: gpio_ref (Bitfield-Mask: 0x07) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_event_act_Pos (5UL)    /*!< gpio_xpic_app gpio_app_counter0_ctrl: event_act (Bit 5) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_event_act_Msk (0x60UL) /*!< gpio_xpic_app gpio_app_counter0_ctrl: event_act (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_once_Pos (4UL)         /*!< gpio_xpic_app gpio_app_counter0_ctrl: once (Bit 4)    */
#define gpio_xpic_app_gpio_app_counter0_ctrl_once_Msk (0x10UL)      /*!< gpio_xpic_app gpio_app_counter0_ctrl: once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_sel_event_Pos (3UL)    /*!< gpio_xpic_app gpio_app_counter0_ctrl: sel_event (Bit 3) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_sel_event_Msk (0x8UL)  /*!< gpio_xpic_app gpio_app_counter0_ctrl: sel_event (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_irq_en_Pos (2UL)       /*!< gpio_xpic_app gpio_app_counter0_ctrl: irq_en (Bit 2)  */
#define gpio_xpic_app_gpio_app_counter0_ctrl_irq_en_Msk (0x4UL)     /*!< gpio_xpic_app gpio_app_counter0_ctrl: irq_en (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_sym_nasym_Pos (1UL)    /*!< gpio_xpic_app gpio_app_counter0_ctrl: sym_nasym (Bit 1) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_sym_nasym_Msk (0x2UL)  /*!< gpio_xpic_app gpio_app_counter0_ctrl: sym_nasym (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter0_ctrl_run_Pos (0UL)          /*!< gpio_xpic_app gpio_app_counter0_ctrl: run (Bit 0)     */
#define gpio_xpic_app_gpio_app_counter0_ctrl_run_Msk (0x1UL)        /*!< gpio_xpic_app gpio_app_counter0_ctrl: run (Bitfield-Mask: 0x01) */
/* ================================================  gpio_app_counter1_ctrl  ================================================= */
#define gpio_xpic_app_gpio_app_counter1_ctrl_gpio_ref_Pos (7UL)     /*!< gpio_xpic_app gpio_app_counter1_ctrl: gpio_ref (Bit 7) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_gpio_ref_Msk (0x380UL) /*!< gpio_xpic_app gpio_app_counter1_ctrl: gpio_ref (Bitfield-Mask: 0x07) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_event_act_Pos (5UL)    /*!< gpio_xpic_app gpio_app_counter1_ctrl: event_act (Bit 5) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_event_act_Msk (0x60UL) /*!< gpio_xpic_app gpio_app_counter1_ctrl: event_act (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_once_Pos (4UL)         /*!< gpio_xpic_app gpio_app_counter1_ctrl: once (Bit 4)    */
#define gpio_xpic_app_gpio_app_counter1_ctrl_once_Msk (0x10UL)      /*!< gpio_xpic_app gpio_app_counter1_ctrl: once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_sel_event_Pos (3UL)    /*!< gpio_xpic_app gpio_app_counter1_ctrl: sel_event (Bit 3) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_sel_event_Msk (0x8UL)  /*!< gpio_xpic_app gpio_app_counter1_ctrl: sel_event (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_irq_en_Pos (2UL)       /*!< gpio_xpic_app gpio_app_counter1_ctrl: irq_en (Bit 2)  */
#define gpio_xpic_app_gpio_app_counter1_ctrl_irq_en_Msk (0x4UL)     /*!< gpio_xpic_app gpio_app_counter1_ctrl: irq_en (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_sym_nasym_Pos (1UL)    /*!< gpio_xpic_app gpio_app_counter1_ctrl: sym_nasym (Bit 1) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_sym_nasym_Msk (0x2UL)  /*!< gpio_xpic_app gpio_app_counter1_ctrl: sym_nasym (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter1_ctrl_run_Pos (0UL)          /*!< gpio_xpic_app gpio_app_counter1_ctrl: run (Bit 0)     */
#define gpio_xpic_app_gpio_app_counter1_ctrl_run_Msk (0x1UL)        /*!< gpio_xpic_app gpio_app_counter1_ctrl: run (Bitfield-Mask: 0x01) */
/* ================================================  gpio_app_counter2_ctrl  ================================================= */
#define gpio_xpic_app_gpio_app_counter2_ctrl_gpio_ref_Pos (7UL)     /*!< gpio_xpic_app gpio_app_counter2_ctrl: gpio_ref (Bit 7) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_gpio_ref_Msk (0x380UL) /*!< gpio_xpic_app gpio_app_counter2_ctrl: gpio_ref (Bitfield-Mask: 0x07) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_event_act_Pos (5UL)    /*!< gpio_xpic_app gpio_app_counter2_ctrl: event_act (Bit 5) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_event_act_Msk (0x60UL) /*!< gpio_xpic_app gpio_app_counter2_ctrl: event_act (Bitfield-Mask: 0x03) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_once_Pos (4UL)         /*!< gpio_xpic_app gpio_app_counter2_ctrl: once (Bit 4)    */
#define gpio_xpic_app_gpio_app_counter2_ctrl_once_Msk (0x10UL)      /*!< gpio_xpic_app gpio_app_counter2_ctrl: once (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_sel_event_Pos (3UL)    /*!< gpio_xpic_app gpio_app_counter2_ctrl: sel_event (Bit 3) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_sel_event_Msk (0x8UL)  /*!< gpio_xpic_app gpio_app_counter2_ctrl: sel_event (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_irq_en_Pos (2UL)       /*!< gpio_xpic_app gpio_app_counter2_ctrl: irq_en (Bit 2)  */
#define gpio_xpic_app_gpio_app_counter2_ctrl_irq_en_Msk (0x4UL)     /*!< gpio_xpic_app gpio_app_counter2_ctrl: irq_en (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_sym_nasym_Pos (1UL)    /*!< gpio_xpic_app gpio_app_counter2_ctrl: sym_nasym (Bit 1) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_sym_nasym_Msk (0x2UL)  /*!< gpio_xpic_app gpio_app_counter2_ctrl: sym_nasym (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_counter2_ctrl_run_Pos (0UL)          /*!< gpio_xpic_app gpio_app_counter2_ctrl: run (Bit 0)     */
#define gpio_xpic_app_gpio_app_counter2_ctrl_run_Msk (0x1UL)        /*!< gpio_xpic_app gpio_app_counter2_ctrl: run (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_counter0_max  ================================================= */
#define gpio_xpic_app_gpio_app_counter0_max_val_Pos (0UL)           /*!< gpio_xpic_app gpio_app_counter0_max: val (Bit 0)      */
#define gpio_xpic_app_gpio_app_counter0_max_val_Msk (0xffffffffUL)  /*!< gpio_xpic_app gpio_app_counter0_max: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  gpio_app_counter1_max  ================================================= */
#define gpio_xpic_app_gpio_app_counter1_max_val_Pos (0UL)           /*!< gpio_xpic_app gpio_app_counter1_max: val (Bit 0)      */
#define gpio_xpic_app_gpio_app_counter1_max_val_Msk (0xffffffffUL)  /*!< gpio_xpic_app gpio_app_counter1_max: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  gpio_app_counter2_max  ================================================= */
#define gpio_xpic_app_gpio_app_counter2_max_val_Pos (0UL)           /*!< gpio_xpic_app gpio_app_counter2_max: val (Bit 0)      */
#define gpio_xpic_app_gpio_app_counter2_max_val_Msk (0xffffffffUL)  /*!< gpio_xpic_app gpio_app_counter2_max: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  gpio_app_counter0_cnt  ================================================= */
#define gpio_xpic_app_gpio_app_counter0_cnt_val_Pos (0UL)           /*!< gpio_xpic_app gpio_app_counter0_cnt: val (Bit 0)      */
#define gpio_xpic_app_gpio_app_counter0_cnt_val_Msk (0xffffffffUL)  /*!< gpio_xpic_app gpio_app_counter0_cnt: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  gpio_app_counter1_cnt  ================================================= */
#define gpio_xpic_app_gpio_app_counter1_cnt_val_Pos (0UL)           /*!< gpio_xpic_app gpio_app_counter1_cnt: val (Bit 0)      */
#define gpio_xpic_app_gpio_app_counter1_cnt_val_Msk (0xffffffffUL)  /*!< gpio_xpic_app gpio_app_counter1_cnt: val (Bitfield-Mask: 0xffffffff) */
/* =================================================  gpio_app_counter2_cnt  ================================================= */
#define gpio_xpic_app_gpio_app_counter2_cnt_val_Pos (0UL)           /*!< gpio_xpic_app gpio_app_counter2_cnt: val (Bit 0)      */
#define gpio_xpic_app_gpio_app_counter2_cnt_val_Msk (0xffffffffUL)  /*!< gpio_xpic_app gpio_app_counter2_cnt: val (Bitfield-Mask: 0xffffffff) */
/* =====================================================  gpio_app_line  ===================================================== */
#define gpio_xpic_app_gpio_app_line_val_Pos (0UL)                   /*!< gpio_xpic_app gpio_app_line: val (Bit 0)              */
#define gpio_xpic_app_gpio_app_line_val_Msk (0xffUL)                /*!< gpio_xpic_app gpio_app_line: val (Bitfield-Mask: 0xff) */
/* ======================================================  gpio_app_in  ====================================================== */
#define gpio_xpic_app_gpio_app_in_val_Pos (0UL)                     /*!< gpio_xpic_app gpio_app_in: val (Bit 0)                */
#define gpio_xpic_app_gpio_app_in_val_Msk (0xffUL)                  /*!< gpio_xpic_app gpio_app_in: val (Bitfield-Mask: 0xff)  */
/* ===================================================  gpio_app_irq_raw  ==================================================== */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app7_Pos (7UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app7 (Bit 7)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app7_Msk (0x80UL)       /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app6_Pos (6UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app6 (Bit 6)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app6_Msk (0x40UL)       /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app5_Pos (5UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app5 (Bit 5)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app5_Msk (0x20UL)       /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app4_Pos (4UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app4 (Bit 4)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app4_Msk (0x10UL)       /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app3_Pos (3UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app3 (Bit 3)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app3_Msk (0x8UL)        /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app2_Pos (2UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app2 (Bit 2)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app2_Msk (0x4UL)        /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app1_Pos (1UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app1 (Bit 1)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app1_Msk (0x2UL)        /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app0_Pos (0UL)          /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app0 (Bit 0)     */
#define gpio_xpic_app_gpio_app_irq_raw_gpio_app0_Msk (0x1UL)        /*!< gpio_xpic_app gpio_app_irq_raw: gpio_app0 (Bitfield-Mask: 0x01) */
/* ==================================================  gpio_app_irq_masked  ================================================== */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app7_Pos (7UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app7 (Bit 7)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app7_Msk (0x80UL)    /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app6_Pos (6UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app6 (Bit 6)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app6_Msk (0x40UL)    /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app5_Pos (5UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app5 (Bit 5)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app5_Msk (0x20UL)    /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app4_Pos (4UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app4 (Bit 4)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app4_Msk (0x10UL)    /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app3_Pos (3UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app3 (Bit 3)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app3_Msk (0x8UL)     /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app2_Pos (2UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app2 (Bit 2)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app2_Msk (0x4UL)     /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app1_Pos (1UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app1 (Bit 1)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app1_Msk (0x2UL)     /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app0_Pos (0UL)       /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app0 (Bit 0)  */
#define gpio_xpic_app_gpio_app_irq_masked_gpio_app0_Msk (0x1UL)     /*!< gpio_xpic_app gpio_app_irq_masked: gpio_app0 (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_irq_mask_set  ================================================= */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app7_Pos (7UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app7 (Bit 7) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app7_Msk (0x80UL)  /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app6_Pos (6UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app6 (Bit 6) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app6_Msk (0x40UL)  /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app5_Pos (5UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app5 (Bit 5) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app5_Msk (0x20UL)  /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app4_Pos (4UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app4 (Bit 4) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app4_Msk (0x10UL)  /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app3_Pos (3UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app3 (Bit 3) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app3_Msk (0x8UL)   /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app2_Pos (2UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app2 (Bit 2) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app2_Msk (0x4UL)   /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app1_Pos (1UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app1 (Bit 1) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app1_Msk (0x2UL)   /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app0_Pos (0UL)     /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app0 (Bit 0) */
#define gpio_xpic_app_gpio_app_irq_mask_set_gpio_app0_Msk (0x1UL)   /*!< gpio_xpic_app gpio_app_irq_mask_set: gpio_app0 (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_irq_mask_rst  ================================================= */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app7_Pos (7UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app7 (Bit 7) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app7_Msk (0x80UL)  /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app7 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app6_Pos (6UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app6 (Bit 6) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app6_Msk (0x40UL)  /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app6 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app5_Pos (5UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app5 (Bit 5) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app5_Msk (0x20UL)  /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app5 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app4_Pos (4UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app4 (Bit 4) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app4_Msk (0x10UL)  /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app4 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app3_Pos (3UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app3 (Bit 3) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app3_Msk (0x8UL)   /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app3 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app2_Pos (2UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app2 (Bit 2) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app2_Msk (0x4UL)   /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app1_Pos (1UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app1 (Bit 1) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app1_Msk (0x2UL)   /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app0_Pos (0UL)     /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app0 (Bit 0) */
#define gpio_xpic_app_gpio_app_irq_mask_rst_gpio_app0_Msk (0x1UL)   /*!< gpio_xpic_app gpio_app_irq_mask_rst: gpio_app0 (Bitfield-Mask: 0x01) */
/* =================================================  gpio_app_cnt_irq_raw  ================================================== */
#define gpio_xpic_app_gpio_app_cnt_irq_raw_cnt2_Pos (2UL)           /*!< gpio_xpic_app gpio_app_cnt_irq_raw: cnt2 (Bit 2)      */
#define gpio_xpic_app_gpio_app_cnt_irq_raw_cnt2_Msk (0x4UL)         /*!< gpio_xpic_app gpio_app_cnt_irq_raw: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_raw_cnt1_Pos (1UL)           /*!< gpio_xpic_app gpio_app_cnt_irq_raw: cnt1 (Bit 1)      */
#define gpio_xpic_app_gpio_app_cnt_irq_raw_cnt1_Msk (0x2UL)         /*!< gpio_xpic_app gpio_app_cnt_irq_raw: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_raw_cnt0_Pos (0UL)           /*!< gpio_xpic_app gpio_app_cnt_irq_raw: cnt0 (Bit 0)      */
#define gpio_xpic_app_gpio_app_cnt_irq_raw_cnt0_Msk (0x1UL)         /*!< gpio_xpic_app gpio_app_cnt_irq_raw: cnt0 (Bitfield-Mask: 0x01) */
/* ================================================  gpio_app_cnt_irq_masked  ================================================ */
#define gpio_xpic_app_gpio_app_cnt_irq_masked_cnt2_Pos (2UL)        /*!< gpio_xpic_app gpio_app_cnt_irq_masked: cnt2 (Bit 2)   */
#define gpio_xpic_app_gpio_app_cnt_irq_masked_cnt2_Msk (0x4UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_masked: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_masked_cnt1_Pos (1UL)        /*!< gpio_xpic_app gpio_app_cnt_irq_masked: cnt1 (Bit 1)   */
#define gpio_xpic_app_gpio_app_cnt_irq_masked_cnt1_Msk (0x2UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_masked: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_masked_cnt0_Pos (0UL)        /*!< gpio_xpic_app gpio_app_cnt_irq_masked: cnt0 (Bit 0)   */
#define gpio_xpic_app_gpio_app_cnt_irq_masked_cnt0_Msk (0x1UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_masked: cnt0 (Bitfield-Mask: 0x01) */
/* ===============================================  gpio_app_cnt_irq_mask_set  =============================================== */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_set_cnt2_Pos (2UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_mask_set: cnt2 (Bit 2) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_set_cnt2_Msk (0x4UL)    /*!< gpio_xpic_app gpio_app_cnt_irq_mask_set: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_set_cnt1_Pos (1UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_mask_set: cnt1 (Bit 1) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_set_cnt1_Msk (0x2UL)    /*!< gpio_xpic_app gpio_app_cnt_irq_mask_set: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_set_cnt0_Pos (0UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_mask_set: cnt0 (Bit 0) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_set_cnt0_Msk (0x1UL)    /*!< gpio_xpic_app gpio_app_cnt_irq_mask_set: cnt0 (Bitfield-Mask: 0x01) */
/* ===============================================  gpio_app_cnt_irq_mask_rst  =============================================== */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_rst_cnt2_Pos (2UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_mask_rst: cnt2 (Bit 2) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_rst_cnt2_Msk (0x4UL)    /*!< gpio_xpic_app gpio_app_cnt_irq_mask_rst: cnt2 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_rst_cnt1_Pos (1UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_mask_rst: cnt1 (Bit 1) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_rst_cnt1_Msk (0x2UL)    /*!< gpio_xpic_app gpio_app_cnt_irq_mask_rst: cnt1 (Bitfield-Mask: 0x01) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_rst_cnt0_Pos (0UL)      /*!< gpio_xpic_app gpio_app_cnt_irq_mask_rst: cnt0 (Bit 0) */
#define gpio_xpic_app_gpio_app_cnt_irq_mask_rst_cnt0_Msk (0x1UL)    /*!< gpio_xpic_app gpio_app_cnt_irq_mask_rst: cnt0 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                       uart_xpic_app                                       ================ */
/* =========================================================================================================================== */

/* ========================================================  uartdr  ========================================================= */
#define uart_xpic_app_uartdr_BE_Pos       (10UL)                    /*!< uart_xpic_app uartdr: BE (Bit 10)                     */
#define uart_xpic_app_uartdr_BE_Msk       (0x400UL)                 /*!< uart_xpic_app uartdr: BE (Bitfield-Mask: 0x01)        */
#define uart_xpic_app_uartdr_PE_Pos       (9UL)                     /*!< uart_xpic_app uartdr: PE (Bit 9)                      */
#define uart_xpic_app_uartdr_PE_Msk       (0x200UL)                 /*!< uart_xpic_app uartdr: PE (Bitfield-Mask: 0x01)        */
#define uart_xpic_app_uartdr_FE_Pos       (8UL)                     /*!< uart_xpic_app uartdr: FE (Bit 8)                      */
#define uart_xpic_app_uartdr_FE_Msk       (0x100UL)                 /*!< uart_xpic_app uartdr: FE (Bitfield-Mask: 0x01)        */
#define uart_xpic_app_uartdr_DATA_Pos     (0UL)                     /*!< uart_xpic_app uartdr: DATA (Bit 0)                    */
#define uart_xpic_app_uartdr_DATA_Msk     (0xffUL)                  /*!< uart_xpic_app uartdr: DATA (Bitfield-Mask: 0xff)      */
/* ========================================================  uartrsr  ======================================================== */
#define uart_xpic_app_uartrsr_OE_Pos      (3UL)                     /*!< uart_xpic_app uartrsr: OE (Bit 3)                     */
#define uart_xpic_app_uartrsr_OE_Msk      (0x8UL)                   /*!< uart_xpic_app uartrsr: OE (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartrsr_BE_Pos      (2UL)                     /*!< uart_xpic_app uartrsr: BE (Bit 2)                     */
#define uart_xpic_app_uartrsr_BE_Msk      (0x4UL)                   /*!< uart_xpic_app uartrsr: BE (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartrsr_PE_Pos      (1UL)                     /*!< uart_xpic_app uartrsr: PE (Bit 1)                     */
#define uart_xpic_app_uartrsr_PE_Msk      (0x2UL)                   /*!< uart_xpic_app uartrsr: PE (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartrsr_FE_Pos      (0UL)                     /*!< uart_xpic_app uartrsr: FE (Bit 0)                     */
#define uart_xpic_app_uartrsr_FE_Msk      (0x1UL)                   /*!< uart_xpic_app uartrsr: FE (Bitfield-Mask: 0x01)       */
/* =======================================================  uartlcr_h  ======================================================= */
#define uart_xpic_app_uartlcr_h_WLEN_Pos  (5UL)                     /*!< uart_xpic_app uartlcr_h: WLEN (Bit 5)                 */
#define uart_xpic_app_uartlcr_h_WLEN_Msk  (0x60UL)                  /*!< uart_xpic_app uartlcr_h: WLEN (Bitfield-Mask: 0x03)   */
#define uart_xpic_app_uartlcr_h_FEN_Pos   (4UL)                     /*!< uart_xpic_app uartlcr_h: FEN (Bit 4)                  */
#define uart_xpic_app_uartlcr_h_FEN_Msk   (0x10UL)                  /*!< uart_xpic_app uartlcr_h: FEN (Bitfield-Mask: 0x01)    */
#define uart_xpic_app_uartlcr_h_STP2_Pos  (3UL)                     /*!< uart_xpic_app uartlcr_h: STP2 (Bit 3)                 */
#define uart_xpic_app_uartlcr_h_STP2_Msk  (0x8UL)                   /*!< uart_xpic_app uartlcr_h: STP2 (Bitfield-Mask: 0x01)   */
#define uart_xpic_app_uartlcr_h_EPS_Pos   (2UL)                     /*!< uart_xpic_app uartlcr_h: EPS (Bit 2)                  */
#define uart_xpic_app_uartlcr_h_EPS_Msk   (0x4UL)                   /*!< uart_xpic_app uartlcr_h: EPS (Bitfield-Mask: 0x01)    */
#define uart_xpic_app_uartlcr_h_PEN_Pos   (1UL)                     /*!< uart_xpic_app uartlcr_h: PEN (Bit 1)                  */
#define uart_xpic_app_uartlcr_h_PEN_Msk   (0x2UL)                   /*!< uart_xpic_app uartlcr_h: PEN (Bitfield-Mask: 0x01)    */
#define uart_xpic_app_uartlcr_h_BRK_Pos   (0UL)                     /*!< uart_xpic_app uartlcr_h: BRK (Bit 0)                  */
#define uart_xpic_app_uartlcr_h_BRK_Msk   (0x1UL)                   /*!< uart_xpic_app uartlcr_h: BRK (Bitfield-Mask: 0x01)    */
/* =======================================================  uartlcr_m  ======================================================= */
#define uart_xpic_app_uartlcr_m_BAUDDIVMS_Pos (0UL)                 /*!< uart_xpic_app uartlcr_m: BAUDDIVMS (Bit 0)            */
#define uart_xpic_app_uartlcr_m_BAUDDIVMS_Msk (0xffUL)              /*!< uart_xpic_app uartlcr_m: BAUDDIVMS (Bitfield-Mask: 0xff) */
/* =======================================================  uartlcr_l  ======================================================= */
#define uart_xpic_app_uartlcr_l_BAUDDIVLS_Pos (0UL)                 /*!< uart_xpic_app uartlcr_l: BAUDDIVLS (Bit 0)            */
#define uart_xpic_app_uartlcr_l_BAUDDIVLS_Msk (0xffUL)              /*!< uart_xpic_app uartlcr_l: BAUDDIVLS (Bitfield-Mask: 0xff) */
/* ========================================================  uartcr  ========================================================= */
#define uart_xpic_app_uartcr_TX_RX_LOOP_Pos (8UL)                   /*!< uart_xpic_app uartcr: TX_RX_LOOP (Bit 8)              */
#define uart_xpic_app_uartcr_TX_RX_LOOP_Msk (0x100UL)               /*!< uart_xpic_app uartcr: TX_RX_LOOP (Bitfield-Mask: 0x01) */
#define uart_xpic_app_uartcr_LBE_Pos      (7UL)                     /*!< uart_xpic_app uartcr: LBE (Bit 7)                     */
#define uart_xpic_app_uartcr_LBE_Msk      (0x80UL)                  /*!< uart_xpic_app uartcr: LBE (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartcr_RTIE_Pos     (6UL)                     /*!< uart_xpic_app uartcr: RTIE (Bit 6)                    */
#define uart_xpic_app_uartcr_RTIE_Msk     (0x40UL)                  /*!< uart_xpic_app uartcr: RTIE (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartcr_TIE_Pos      (5UL)                     /*!< uart_xpic_app uartcr: TIE (Bit 5)                     */
#define uart_xpic_app_uartcr_TIE_Msk      (0x20UL)                  /*!< uart_xpic_app uartcr: TIE (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartcr_RIE_Pos      (4UL)                     /*!< uart_xpic_app uartcr: RIE (Bit 4)                     */
#define uart_xpic_app_uartcr_RIE_Msk      (0x10UL)                  /*!< uart_xpic_app uartcr: RIE (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartcr_MSIE_Pos     (3UL)                     /*!< uart_xpic_app uartcr: MSIE (Bit 3)                    */
#define uart_xpic_app_uartcr_MSIE_Msk     (0x8UL)                   /*!< uart_xpic_app uartcr: MSIE (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartcr_SIRLP_Pos    (2UL)                     /*!< uart_xpic_app uartcr: SIRLP (Bit 2)                   */
#define uart_xpic_app_uartcr_SIRLP_Msk    (0x4UL)                   /*!< uart_xpic_app uartcr: SIRLP (Bitfield-Mask: 0x01)     */
#define uart_xpic_app_uartcr_SIREN_Pos    (1UL)                     /*!< uart_xpic_app uartcr: SIREN (Bit 1)                   */
#define uart_xpic_app_uartcr_SIREN_Msk    (0x2UL)                   /*!< uart_xpic_app uartcr: SIREN (Bitfield-Mask: 0x01)     */
#define uart_xpic_app_uartcr_uartEN_Pos   (0UL)                     /*!< uart_xpic_app uartcr: uartEN (Bit 0)                  */
#define uart_xpic_app_uartcr_uartEN_Msk   (0x1UL)                   /*!< uart_xpic_app uartcr: uartEN (Bitfield-Mask: 0x01)    */
/* ========================================================  uartfr  ========================================================= */
#define uart_xpic_app_uartfr_TXFE_Pos     (7UL)                     /*!< uart_xpic_app uartfr: TXFE (Bit 7)                    */
#define uart_xpic_app_uartfr_TXFE_Msk     (0x80UL)                  /*!< uart_xpic_app uartfr: TXFE (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartfr_RXFF_Pos     (6UL)                     /*!< uart_xpic_app uartfr: RXFF (Bit 6)                    */
#define uart_xpic_app_uartfr_RXFF_Msk     (0x40UL)                  /*!< uart_xpic_app uartfr: RXFF (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartfr_TXFF_Pos     (5UL)                     /*!< uart_xpic_app uartfr: TXFF (Bit 5)                    */
#define uart_xpic_app_uartfr_TXFF_Msk     (0x20UL)                  /*!< uart_xpic_app uartfr: TXFF (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartfr_RXFE_Pos     (4UL)                     /*!< uart_xpic_app uartfr: RXFE (Bit 4)                    */
#define uart_xpic_app_uartfr_RXFE_Msk     (0x10UL)                  /*!< uart_xpic_app uartfr: RXFE (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartfr_BUSY_Pos     (3UL)                     /*!< uart_xpic_app uartfr: BUSY (Bit 3)                    */
#define uart_xpic_app_uartfr_BUSY_Msk     (0x8UL)                   /*!< uart_xpic_app uartfr: BUSY (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartfr_DCD_Pos      (2UL)                     /*!< uart_xpic_app uartfr: DCD (Bit 2)                     */
#define uart_xpic_app_uartfr_DCD_Msk      (0x4UL)                   /*!< uart_xpic_app uartfr: DCD (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartfr_DSR_Pos      (1UL)                     /*!< uart_xpic_app uartfr: DSR (Bit 1)                     */
#define uart_xpic_app_uartfr_DSR_Msk      (0x2UL)                   /*!< uart_xpic_app uartfr: DSR (Bitfield-Mask: 0x01)       */
#define uart_xpic_app_uartfr_CTS_Pos      (0UL)                     /*!< uart_xpic_app uartfr: CTS (Bit 0)                     */
#define uart_xpic_app_uartfr_CTS_Msk      (0x1UL)                   /*!< uart_xpic_app uartfr: CTS (Bitfield-Mask: 0x01)       */
/* ========================================================  uartiir  ======================================================== */
#define uart_xpic_app_uartiir_RTIS_Pos    (3UL)                     /*!< uart_xpic_app uartiir: RTIS (Bit 3)                   */
#define uart_xpic_app_uartiir_RTIS_Msk    (0x8UL)                   /*!< uart_xpic_app uartiir: RTIS (Bitfield-Mask: 0x01)     */
#define uart_xpic_app_uartiir_TIS_Pos     (2UL)                     /*!< uart_xpic_app uartiir: TIS (Bit 2)                    */
#define uart_xpic_app_uartiir_TIS_Msk     (0x4UL)                   /*!< uart_xpic_app uartiir: TIS (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartiir_RIS_Pos     (1UL)                     /*!< uart_xpic_app uartiir: RIS (Bit 1)                    */
#define uart_xpic_app_uartiir_RIS_Msk     (0x2UL)                   /*!< uart_xpic_app uartiir: RIS (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartiir_MIS_Pos     (0UL)                     /*!< uart_xpic_app uartiir: MIS (Bit 0)                    */
#define uart_xpic_app_uartiir_MIS_Msk     (0x1UL)                   /*!< uart_xpic_app uartiir: MIS (Bitfield-Mask: 0x01)      */
/* =======================================================  uartilpr  ======================================================== */
#define uart_xpic_app_uartilpr_ILPDVSR_Pos (0UL)                    /*!< uart_xpic_app uartilpr: ILPDVSR (Bit 0)               */
#define uart_xpic_app_uartilpr_ILPDVSR_Msk (0xffUL)                 /*!< uart_xpic_app uartilpr: ILPDVSR (Bitfield-Mask: 0xff) */
/* ========================================================  uartrts  ======================================================== */
#define uart_xpic_app_uartrts_STICK_Pos   (7UL)                     /*!< uart_xpic_app uartrts: STICK (Bit 7)                  */
#define uart_xpic_app_uartrts_STICK_Msk   (0x80UL)                  /*!< uart_xpic_app uartrts: STICK (Bitfield-Mask: 0x01)    */
#define uart_xpic_app_uartrts_CTS_pol_Pos (6UL)                     /*!< uart_xpic_app uartrts: CTS_pol (Bit 6)                */
#define uart_xpic_app_uartrts_CTS_pol_Msk (0x40UL)                  /*!< uart_xpic_app uartrts: CTS_pol (Bitfield-Mask: 0x01)  */
#define uart_xpic_app_uartrts_CTS_ctr_Pos (5UL)                     /*!< uart_xpic_app uartrts: CTS_ctr (Bit 5)                */
#define uart_xpic_app_uartrts_CTS_ctr_Msk (0x20UL)                  /*!< uart_xpic_app uartrts: CTS_ctr (Bitfield-Mask: 0x01)  */
#define uart_xpic_app_uartrts_RTS_pol_Pos (4UL)                     /*!< uart_xpic_app uartrts: RTS_pol (Bit 4)                */
#define uart_xpic_app_uartrts_RTS_pol_Msk (0x10UL)                  /*!< uart_xpic_app uartrts: RTS_pol (Bitfield-Mask: 0x01)  */
#define uart_xpic_app_uartrts_MOD2_Pos    (3UL)                     /*!< uart_xpic_app uartrts: MOD2 (Bit 3)                   */
#define uart_xpic_app_uartrts_MOD2_Msk    (0x8UL)                   /*!< uart_xpic_app uartrts: MOD2 (Bitfield-Mask: 0x01)     */
#define uart_xpic_app_uartrts_COUNT_Pos   (2UL)                     /*!< uart_xpic_app uartrts: COUNT (Bit 2)                  */
#define uart_xpic_app_uartrts_COUNT_Msk   (0x4UL)                   /*!< uart_xpic_app uartrts: COUNT (Bitfield-Mask: 0x01)    */
#define uart_xpic_app_uartrts_RTS_Pos     (1UL)                     /*!< uart_xpic_app uartrts: RTS (Bit 1)                    */
#define uart_xpic_app_uartrts_RTS_Msk     (0x2UL)                   /*!< uart_xpic_app uartrts: RTS (Bitfield-Mask: 0x01)      */
#define uart_xpic_app_uartrts_AUTO_Pos    (0UL)                     /*!< uart_xpic_app uartrts: AUTO (Bit 0)                   */
#define uart_xpic_app_uartrts_AUTO_Msk    (0x1UL)                   /*!< uart_xpic_app uartrts: AUTO (Bitfield-Mask: 0x01)     */
/* ======================================================  uartforerun  ====================================================== */
#define uart_xpic_app_uartforerun_FORERUN_Pos (0UL)                 /*!< uart_xpic_app uartforerun: FORERUN (Bit 0)            */
#define uart_xpic_app_uartforerun_FORERUN_Msk (0xffUL)              /*!< uart_xpic_app uartforerun: FORERUN (Bitfield-Mask: 0xff) */
/* =======================================================  uarttrail  ======================================================= */
#define uart_xpic_app_uarttrail_TRAIL_Pos (0UL)                     /*!< uart_xpic_app uarttrail: TRAIL (Bit 0)                */
#define uart_xpic_app_uarttrail_TRAIL_Msk (0xffUL)                  /*!< uart_xpic_app uarttrail: TRAIL (Bitfield-Mask: 0xff)  */
/* ======================================================  uartdrvout  ======================================================= */
#define uart_xpic_app_uartdrvout_DRVRTS_Pos (1UL)                   /*!< uart_xpic_app uartdrvout: DRVRTS (Bit 1)              */
#define uart_xpic_app_uartdrvout_DRVRTS_Msk (0x2UL)                 /*!< uart_xpic_app uartdrvout: DRVRTS (Bitfield-Mask: 0x01) */
#define uart_xpic_app_uartdrvout_DRVTX_Pos (0UL)                    /*!< uart_xpic_app uartdrvout: DRVTX (Bit 0)               */
#define uart_xpic_app_uartdrvout_DRVTX_Msk (0x1UL)                  /*!< uart_xpic_app uartdrvout: DRVTX (Bitfield-Mask: 0x01) */
/* =======================================================  uartcr_2  ======================================================== */
#define uart_xpic_app_uartcr_2_Baud_Rate_Mode_Pos (0UL)             /*!< uart_xpic_app uartcr_2: Baud_Rate_Mode (Bit 0)        */
#define uart_xpic_app_uartcr_2_Baud_Rate_Mode_Msk (0x1UL)           /*!< uart_xpic_app uartcr_2: Baud_Rate_Mode (Bitfield-Mask: 0x01) */
/* =====================================================  uartrxiflsel  ====================================================== */
#define uart_xpic_app_uartrxiflsel_RXDMA_Pos (5UL)                  /*!< uart_xpic_app uartrxiflsel: RXDMA (Bit 5)             */
#define uart_xpic_app_uartrxiflsel_RXDMA_Msk (0x20UL)               /*!< uart_xpic_app uartrxiflsel: RXDMA (Bitfield-Mask: 0x01) */
#define uart_xpic_app_uartrxiflsel_RXIFLSEL_Pos (0UL)               /*!< uart_xpic_app uartrxiflsel: RXIFLSEL (Bit 0)          */
#define uart_xpic_app_uartrxiflsel_RXIFLSEL_Msk (0x1fUL)            /*!< uart_xpic_app uartrxiflsel: RXIFLSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  uarttxiflsel  ====================================================== */
#define uart_xpic_app_uarttxiflsel_TXDMA_Pos (5UL)                  /*!< uart_xpic_app uarttxiflsel: TXDMA (Bit 5)             */
#define uart_xpic_app_uarttxiflsel_TXDMA_Msk (0x20UL)               /*!< uart_xpic_app uarttxiflsel: TXDMA (Bitfield-Mask: 0x01) */
#define uart_xpic_app_uarttxiflsel_TXIFLSEL_Pos (0UL)               /*!< uart_xpic_app uarttxiflsel: TXIFLSEL (Bit 0)          */
#define uart_xpic_app_uarttxiflsel_TXIFLSEL_Msk (0x1fUL)            /*!< uart_xpic_app uarttxiflsel: TXIFLSEL (Bitfield-Mask: 0x1f) */


/* =========================================================================================================================== */
/* ================                                       i2c_xpic_app                                        ================ */
/* =========================================================================================================================== */

/* ========================================================  i2c_mcr  ======================================================== */
#define i2c_xpic_app_i2c_mcr_reserved1_Pos (19UL)                   /*!< i2c_xpic_app i2c_mcr: reserved1 (Bit 19)              */
#define i2c_xpic_app_i2c_mcr_reserved1_Msk (0xfff80000UL)           /*!< i2c_xpic_app i2c_mcr: reserved1 (Bitfield-Mask: 0x1fff) */
#define i2c_xpic_app_i2c_mcr_en_timeout_Pos (18UL)                  /*!< i2c_xpic_app i2c_mcr: en_timeout (Bit 18)             */
#define i2c_xpic_app_i2c_mcr_en_timeout_Msk (0x40000UL)             /*!< i2c_xpic_app i2c_mcr: en_timeout (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_mcr_rst_i2c_Pos  (17UL)                    /*!< i2c_xpic_app i2c_mcr: rst_i2c (Bit 17)                */
#define i2c_xpic_app_i2c_mcr_rst_i2c_Msk  (0x20000UL)               /*!< i2c_xpic_app i2c_mcr: rst_i2c (Bitfield-Mask: 0x01)   */
#define i2c_xpic_app_i2c_mcr_pio_mode_Pos (16UL)                    /*!< i2c_xpic_app i2c_mcr: pio_mode (Bit 16)               */
#define i2c_xpic_app_i2c_mcr_pio_mode_Msk (0x10000UL)               /*!< i2c_xpic_app i2c_mcr: pio_mode (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_mcr_reserved0_Pos (11UL)                   /*!< i2c_xpic_app i2c_mcr: reserved0 (Bit 11)              */
#define i2c_xpic_app_i2c_mcr_reserved0_Msk (0xf800UL)               /*!< i2c_xpic_app i2c_mcr: reserved0 (Bitfield-Mask: 0x1f) */
#define i2c_xpic_app_i2c_mcr_sadr_Pos     (4UL)                     /*!< i2c_xpic_app i2c_mcr: sadr (Bit 4)                    */
#define i2c_xpic_app_i2c_mcr_sadr_Msk     (0x7f0UL)                 /*!< i2c_xpic_app i2c_mcr: sadr (Bitfield-Mask: 0x7f)      */
#define i2c_xpic_app_i2c_mcr_mode_Pos     (1UL)                     /*!< i2c_xpic_app i2c_mcr: mode (Bit 1)                    */
#define i2c_xpic_app_i2c_mcr_mode_Msk     (0xeUL)                   /*!< i2c_xpic_app i2c_mcr: mode (Bitfield-Mask: 0x07)      */
#define i2c_xpic_app_i2c_mcr_en_i2c_Pos   (0UL)                     /*!< i2c_xpic_app i2c_mcr: en_i2c (Bit 0)                  */
#define i2c_xpic_app_i2c_mcr_en_i2c_Msk   (0x1UL)                   /*!< i2c_xpic_app i2c_mcr: en_i2c (Bitfield-Mask: 0x01)    */
/* ========================================================  i2c_scr  ======================================================== */
#define i2c_xpic_app_i2c_scr_reserved2_Pos (21UL)                   /*!< i2c_xpic_app i2c_scr: reserved2 (Bit 21)              */
#define i2c_xpic_app_i2c_scr_reserved2_Msk (0xffe00000UL)           /*!< i2c_xpic_app i2c_scr: reserved2 (Bitfield-Mask: 0x7ff) */
#define i2c_xpic_app_i2c_scr_autoreset_ac_start_Pos (20UL)          /*!< i2c_xpic_app i2c_scr: autoreset_ac_start (Bit 20)     */
#define i2c_xpic_app_i2c_scr_autoreset_ac_start_Msk (0x100000UL)    /*!< i2c_xpic_app i2c_scr: autoreset_ac_start (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_scr_reserved1_Pos (19UL)                   /*!< i2c_xpic_app i2c_scr: reserved1 (Bit 19)              */
#define i2c_xpic_app_i2c_scr_reserved1_Msk (0x80000UL)              /*!< i2c_xpic_app i2c_scr: reserved1 (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_scr_ac_gcall_Pos (18UL)                    /*!< i2c_xpic_app i2c_scr: ac_gcall (Bit 18)               */
#define i2c_xpic_app_i2c_scr_ac_gcall_Msk (0x40000UL)               /*!< i2c_xpic_app i2c_scr: ac_gcall (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_scr_ac_start_Pos (17UL)                    /*!< i2c_xpic_app i2c_scr: ac_start (Bit 17)               */
#define i2c_xpic_app_i2c_scr_ac_start_Msk (0x20000UL)               /*!< i2c_xpic_app i2c_scr: ac_start (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_scr_ac_srx_Pos   (16UL)                    /*!< i2c_xpic_app i2c_scr: ac_srx (Bit 16)                 */
#define i2c_xpic_app_i2c_scr_ac_srx_Msk   (0x10000UL)               /*!< i2c_xpic_app i2c_scr: ac_srx (Bitfield-Mask: 0x01)    */
#define i2c_xpic_app_i2c_scr_reserved0_Pos (11UL)                   /*!< i2c_xpic_app i2c_scr: reserved0 (Bit 11)              */
#define i2c_xpic_app_i2c_scr_reserved0_Msk (0xf800UL)               /*!< i2c_xpic_app i2c_scr: reserved0 (Bitfield-Mask: 0x1f) */
#define i2c_xpic_app_i2c_scr_sid10_Pos    (10UL)                    /*!< i2c_xpic_app i2c_scr: sid10 (Bit 10)                  */
#define i2c_xpic_app_i2c_scr_sid10_Msk    (0x400UL)                 /*!< i2c_xpic_app i2c_scr: sid10 (Bitfield-Mask: 0x01)     */
#define i2c_xpic_app_i2c_scr_sid_Pos      (0UL)                     /*!< i2c_xpic_app i2c_scr: sid (Bit 0)                     */
#define i2c_xpic_app_i2c_scr_sid_Msk      (0x3ffUL)                 /*!< i2c_xpic_app i2c_scr: sid (Bitfield-Mask: 0x3ff)      */
/* ========================================================  i2c_cmd  ======================================================== */
#define i2c_xpic_app_i2c_cmd_reserved2_Pos (28UL)                   /*!< i2c_xpic_app i2c_cmd: reserved2 (Bit 28)              */
#define i2c_xpic_app_i2c_cmd_reserved2_Msk (0xf0000000UL)           /*!< i2c_xpic_app i2c_cmd: reserved2 (Bitfield-Mask: 0x0f) */
#define i2c_xpic_app_i2c_cmd_acpollmax_Pos (20UL)                   /*!< i2c_xpic_app i2c_cmd: acpollmax (Bit 20)              */
#define i2c_xpic_app_i2c_cmd_acpollmax_Msk (0xff00000UL)            /*!< i2c_xpic_app i2c_cmd: acpollmax (Bitfield-Mask: 0xff) */
#define i2c_xpic_app_i2c_cmd_reserved1_Pos (18UL)                   /*!< i2c_xpic_app i2c_cmd: reserved1 (Bit 18)              */
#define i2c_xpic_app_i2c_cmd_reserved1_Msk (0xc0000UL)              /*!< i2c_xpic_app i2c_cmd: reserved1 (Bitfield-Mask: 0x03) */
#define i2c_xpic_app_i2c_cmd_tsize_Pos    (8UL)                     /*!< i2c_xpic_app i2c_cmd: tsize (Bit 8)                   */
#define i2c_xpic_app_i2c_cmd_tsize_Msk    (0x3ff00UL)               /*!< i2c_xpic_app i2c_cmd: tsize (Bitfield-Mask: 0x3ff)    */
#define i2c_xpic_app_i2c_cmd_reserved0_Pos (4UL)                    /*!< i2c_xpic_app i2c_cmd: reserved0 (Bit 4)               */
#define i2c_xpic_app_i2c_cmd_reserved0_Msk (0xf0UL)                 /*!< i2c_xpic_app i2c_cmd: reserved0 (Bitfield-Mask: 0x0f) */
#define i2c_xpic_app_i2c_cmd_cmd_Pos      (1UL)                     /*!< i2c_xpic_app i2c_cmd: cmd (Bit 1)                     */
#define i2c_xpic_app_i2c_cmd_cmd_Msk      (0xeUL)                   /*!< i2c_xpic_app i2c_cmd: cmd (Bitfield-Mask: 0x07)       */
#define i2c_xpic_app_i2c_cmd_nwr_Pos      (0UL)                     /*!< i2c_xpic_app i2c_cmd: nwr (Bit 0)                     */
#define i2c_xpic_app_i2c_cmd_nwr_Msk      (0x1UL)                   /*!< i2c_xpic_app i2c_cmd: nwr (Bitfield-Mask: 0x01)       */
/* ========================================================  i2c_mdr  ======================================================== */
#define i2c_xpic_app_i2c_mdr_mdata_Pos    (0UL)                     /*!< i2c_xpic_app i2c_mdr: mdata (Bit 0)                   */
#define i2c_xpic_app_i2c_mdr_mdata_Msk    (0xffUL)                  /*!< i2c_xpic_app i2c_mdr: mdata (Bitfield-Mask: 0xff)     */
/* ========================================================  i2c_sdr  ======================================================== */
#define i2c_xpic_app_i2c_sdr_sdata_Pos    (0UL)                     /*!< i2c_xpic_app i2c_sdr: sdata (Bit 0)                   */
#define i2c_xpic_app_i2c_sdr_sdata_Msk    (0xffUL)                  /*!< i2c_xpic_app i2c_sdr: sdata (Bitfield-Mask: 0xff)     */
/* =====================================================  i2c_mfifo_cr  ====================================================== */
#define i2c_xpic_app_i2c_mfifo_cr_reserved1_Pos (9UL)               /*!< i2c_xpic_app i2c_mfifo_cr: reserved1 (Bit 9)          */
#define i2c_xpic_app_i2c_mfifo_cr_reserved1_Msk (0xfffffe00UL)      /*!< i2c_xpic_app i2c_mfifo_cr: reserved1 (Bitfield-Mask: 0x7fffff) */
#define i2c_xpic_app_i2c_mfifo_cr_mfifo_clr_Pos (8UL)               /*!< i2c_xpic_app i2c_mfifo_cr: mfifo_clr (Bit 8)          */
#define i2c_xpic_app_i2c_mfifo_cr_mfifo_clr_Msk (0x100UL)           /*!< i2c_xpic_app i2c_mfifo_cr: mfifo_clr (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_mfifo_cr_reserved0_Pos (4UL)               /*!< i2c_xpic_app i2c_mfifo_cr: reserved0 (Bit 4)          */
#define i2c_xpic_app_i2c_mfifo_cr_reserved0_Msk (0xf0UL)            /*!< i2c_xpic_app i2c_mfifo_cr: reserved0 (Bitfield-Mask: 0x0f) */
#define i2c_xpic_app_i2c_mfifo_cr_mfifo_wm_Pos (0UL)                /*!< i2c_xpic_app i2c_mfifo_cr: mfifo_wm (Bit 0)           */
#define i2c_xpic_app_i2c_mfifo_cr_mfifo_wm_Msk (0xfUL)              /*!< i2c_xpic_app i2c_mfifo_cr: mfifo_wm (Bitfield-Mask: 0x0f) */
/* =====================================================  i2c_sfifo_cr  ====================================================== */
#define i2c_xpic_app_i2c_sfifo_cr_reserved1_Pos (9UL)               /*!< i2c_xpic_app i2c_sfifo_cr: reserved1 (Bit 9)          */
#define i2c_xpic_app_i2c_sfifo_cr_reserved1_Msk (0xfffffe00UL)      /*!< i2c_xpic_app i2c_sfifo_cr: reserved1 (Bitfield-Mask: 0x7fffff) */
#define i2c_xpic_app_i2c_sfifo_cr_sfifo_clr_Pos (8UL)               /*!< i2c_xpic_app i2c_sfifo_cr: sfifo_clr (Bit 8)          */
#define i2c_xpic_app_i2c_sfifo_cr_sfifo_clr_Msk (0x100UL)           /*!< i2c_xpic_app i2c_sfifo_cr: sfifo_clr (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sfifo_cr_reserved0_Pos (4UL)               /*!< i2c_xpic_app i2c_sfifo_cr: reserved0 (Bit 4)          */
#define i2c_xpic_app_i2c_sfifo_cr_reserved0_Msk (0xf0UL)            /*!< i2c_xpic_app i2c_sfifo_cr: reserved0 (Bitfield-Mask: 0x0f) */
#define i2c_xpic_app_i2c_sfifo_cr_sfifo_wm_Pos (0UL)                /*!< i2c_xpic_app i2c_sfifo_cr: sfifo_wm (Bit 0)           */
#define i2c_xpic_app_i2c_sfifo_cr_sfifo_wm_Msk (0xfUL)              /*!< i2c_xpic_app i2c_sfifo_cr: sfifo_wm (Bitfield-Mask: 0x0f) */
/* ========================================================  i2c_sr  ========================================================= */
#define i2c_xpic_app_i2c_sr_sda_state_Pos (31UL)                    /*!< i2c_xpic_app i2c_sr: sda_state (Bit 31)               */
#define i2c_xpic_app_i2c_sr_sda_state_Msk (0x80000000UL)            /*!< i2c_xpic_app i2c_sr: sda_state (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_sr_scl_state_Pos (30UL)                    /*!< i2c_xpic_app i2c_sr: scl_state (Bit 30)               */
#define i2c_xpic_app_i2c_sr_scl_state_Msk (0x40000000UL)            /*!< i2c_xpic_app i2c_sr: scl_state (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_sr_reserved2_Pos (29UL)                    /*!< i2c_xpic_app i2c_sr: reserved2 (Bit 29)               */
#define i2c_xpic_app_i2c_sr_reserved2_Msk (0x20000000UL)            /*!< i2c_xpic_app i2c_sr: reserved2 (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_sr_timeout_Pos   (28UL)                    /*!< i2c_xpic_app i2c_sr: timeout (Bit 28)                 */
#define i2c_xpic_app_i2c_sr_timeout_Msk   (0x10000000UL)            /*!< i2c_xpic_app i2c_sr: timeout (Bitfield-Mask: 0x01)    */
#define i2c_xpic_app_i2c_sr_sid10_aced_Pos (27UL)                   /*!< i2c_xpic_app i2c_sr: sid10_aced (Bit 27)              */
#define i2c_xpic_app_i2c_sr_sid10_aced_Msk (0x8000000UL)            /*!< i2c_xpic_app i2c_sr: sid10_aced (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_gcall_aced_Pos (26UL)                   /*!< i2c_xpic_app i2c_sr: gcall_aced (Bit 26)              */
#define i2c_xpic_app_i2c_sr_gcall_aced_Msk (0x4000000UL)            /*!< i2c_xpic_app i2c_sr: gcall_aced (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_nwr_aced_Pos  (25UL)                    /*!< i2c_xpic_app i2c_sr: nwr_aced (Bit 25)                */
#define i2c_xpic_app_i2c_sr_nwr_aced_Msk  (0x2000000UL)             /*!< i2c_xpic_app i2c_sr: nwr_aced (Bitfield-Mask: 0x01)   */
#define i2c_xpic_app_i2c_sr_last_ac_Pos   (24UL)                    /*!< i2c_xpic_app i2c_sr: last_ac (Bit 24)                 */
#define i2c_xpic_app_i2c_sr_last_ac_Msk   (0x1000000UL)             /*!< i2c_xpic_app i2c_sr: last_ac (Bitfield-Mask: 0x01)    */
#define i2c_xpic_app_i2c_sr_slave_access_Pos (23UL)                 /*!< i2c_xpic_app i2c_sr: slave_access (Bit 23)            */
#define i2c_xpic_app_i2c_sr_slave_access_Msk (0x800000UL)           /*!< i2c_xpic_app i2c_sr: slave_access (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_started_Pos   (22UL)                    /*!< i2c_xpic_app i2c_sr: started (Bit 22)                 */
#define i2c_xpic_app_i2c_sr_started_Msk   (0x400000UL)              /*!< i2c_xpic_app i2c_sr: started (Bitfield-Mask: 0x01)    */
#define i2c_xpic_app_i2c_sr_nwr_Pos       (21UL)                    /*!< i2c_xpic_app i2c_sr: nwr (Bit 21)                     */
#define i2c_xpic_app_i2c_sr_nwr_Msk       (0x200000UL)              /*!< i2c_xpic_app i2c_sr: nwr (Bitfield-Mask: 0x01)        */
#define i2c_xpic_app_i2c_sr_bus_master_Pos (20UL)                   /*!< i2c_xpic_app i2c_sr: bus_master (Bit 20)              */
#define i2c_xpic_app_i2c_sr_bus_master_Msk (0x100000UL)             /*!< i2c_xpic_app i2c_sr: bus_master (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_sfifo_err_undr_Pos (19UL)               /*!< i2c_xpic_app i2c_sr: sfifo_err_undr (Bit 19)          */
#define i2c_xpic_app_i2c_sr_sfifo_err_undr_Msk (0x80000UL)          /*!< i2c_xpic_app i2c_sr: sfifo_err_undr (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_sfifo_err_ovfl_Pos (18UL)               /*!< i2c_xpic_app i2c_sr: sfifo_err_ovfl (Bit 18)          */
#define i2c_xpic_app_i2c_sr_sfifo_err_ovfl_Msk (0x40000UL)          /*!< i2c_xpic_app i2c_sr: sfifo_err_ovfl (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_sfifo_full_Pos (17UL)                   /*!< i2c_xpic_app i2c_sr: sfifo_full (Bit 17)              */
#define i2c_xpic_app_i2c_sr_sfifo_full_Msk (0x20000UL)              /*!< i2c_xpic_app i2c_sr: sfifo_full (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_sfifo_empty_Pos (16UL)                  /*!< i2c_xpic_app i2c_sr: sfifo_empty (Bit 16)             */
#define i2c_xpic_app_i2c_sr_sfifo_empty_Msk (0x10000UL)             /*!< i2c_xpic_app i2c_sr: sfifo_empty (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_reserved1_Pos (15UL)                    /*!< i2c_xpic_app i2c_sr: reserved1 (Bit 15)               */
#define i2c_xpic_app_i2c_sr_reserved1_Msk (0x8000UL)                /*!< i2c_xpic_app i2c_sr: reserved1 (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_sr_sfifo_level_Pos (10UL)                  /*!< i2c_xpic_app i2c_sr: sfifo_level (Bit 10)             */
#define i2c_xpic_app_i2c_sr_sfifo_level_Msk (0x7c00UL)              /*!< i2c_xpic_app i2c_sr: sfifo_level (Bitfield-Mask: 0x1f) */
#define i2c_xpic_app_i2c_sr_mfifo_err_undr_Pos (9UL)                /*!< i2c_xpic_app i2c_sr: mfifo_err_undr (Bit 9)           */
#define i2c_xpic_app_i2c_sr_mfifo_err_undr_Msk (0x200UL)            /*!< i2c_xpic_app i2c_sr: mfifo_err_undr (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_mfifo_err_ovfl_Pos (8UL)                /*!< i2c_xpic_app i2c_sr: mfifo_err_ovfl (Bit 8)           */
#define i2c_xpic_app_i2c_sr_mfifo_err_ovfl_Msk (0x100UL)            /*!< i2c_xpic_app i2c_sr: mfifo_err_ovfl (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_mfifo_full_Pos (7UL)                    /*!< i2c_xpic_app i2c_sr: mfifo_full (Bit 7)               */
#define i2c_xpic_app_i2c_sr_mfifo_full_Msk (0x80UL)                 /*!< i2c_xpic_app i2c_sr: mfifo_full (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_mfifo_empty_Pos (6UL)                   /*!< i2c_xpic_app i2c_sr: mfifo_empty (Bit 6)              */
#define i2c_xpic_app_i2c_sr_mfifo_empty_Msk (0x40UL)                /*!< i2c_xpic_app i2c_sr: mfifo_empty (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_sr_reserved0_Pos (5UL)                     /*!< i2c_xpic_app i2c_sr: reserved0 (Bit 5)                */
#define i2c_xpic_app_i2c_sr_reserved0_Msk (0x20UL)                  /*!< i2c_xpic_app i2c_sr: reserved0 (Bitfield-Mask: 0x01)  */
#define i2c_xpic_app_i2c_sr_mfifo_level_Pos (0UL)                   /*!< i2c_xpic_app i2c_sr: mfifo_level (Bit 0)              */
#define i2c_xpic_app_i2c_sr_mfifo_level_Msk (0x1fUL)                /*!< i2c_xpic_app i2c_sr: mfifo_level (Bitfield-Mask: 0x1f) */
/* ======================================================  i2c_irqmsk  ======================================================= */
#define i2c_xpic_app_i2c_irqmsk_sreq_Pos  (6UL)                     /*!< i2c_xpic_app i2c_irqmsk: sreq (Bit 6)                 */
#define i2c_xpic_app_i2c_irqmsk_sreq_Msk  (0x40UL)                  /*!< i2c_xpic_app i2c_irqmsk: sreq (Bitfield-Mask: 0x01)   */
#define i2c_xpic_app_i2c_irqmsk_sfifo_req_Pos (5UL)                 /*!< i2c_xpic_app i2c_irqmsk: sfifo_req (Bit 5)            */
#define i2c_xpic_app_i2c_irqmsk_sfifo_req_Msk (0x20UL)              /*!< i2c_xpic_app i2c_irqmsk: sfifo_req (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsk_mfifo_req_Pos (4UL)                 /*!< i2c_xpic_app i2c_irqmsk: mfifo_req (Bit 4)            */
#define i2c_xpic_app_i2c_irqmsk_mfifo_req_Msk (0x10UL)              /*!< i2c_xpic_app i2c_irqmsk: mfifo_req (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsk_bus_busy_Pos (3UL)                  /*!< i2c_xpic_app i2c_irqmsk: bus_busy (Bit 3)             */
#define i2c_xpic_app_i2c_irqmsk_bus_busy_Msk (0x8UL)                /*!< i2c_xpic_app i2c_irqmsk: bus_busy (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsk_fifo_err_Pos (2UL)                  /*!< i2c_xpic_app i2c_irqmsk: fifo_err (Bit 2)             */
#define i2c_xpic_app_i2c_irqmsk_fifo_err_Msk (0x4UL)                /*!< i2c_xpic_app i2c_irqmsk: fifo_err (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsk_cmd_err_Pos (1UL)                   /*!< i2c_xpic_app i2c_irqmsk: cmd_err (Bit 1)              */
#define i2c_xpic_app_i2c_irqmsk_cmd_err_Msk (0x2UL)                 /*!< i2c_xpic_app i2c_irqmsk: cmd_err (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsk_cmd_ok_Pos (0UL)                    /*!< i2c_xpic_app i2c_irqmsk: cmd_ok (Bit 0)               */
#define i2c_xpic_app_i2c_irqmsk_cmd_ok_Msk (0x1UL)                  /*!< i2c_xpic_app i2c_irqmsk: cmd_ok (Bitfield-Mask: 0x01) */
/* =======================================================  i2c_irqsr  ======================================================= */
#define i2c_xpic_app_i2c_irqsr_sreq_Pos   (6UL)                     /*!< i2c_xpic_app i2c_irqsr: sreq (Bit 6)                  */
#define i2c_xpic_app_i2c_irqsr_sreq_Msk   (0x40UL)                  /*!< i2c_xpic_app i2c_irqsr: sreq (Bitfield-Mask: 0x01)    */
#define i2c_xpic_app_i2c_irqsr_sfifo_req_Pos (5UL)                  /*!< i2c_xpic_app i2c_irqsr: sfifo_req (Bit 5)             */
#define i2c_xpic_app_i2c_irqsr_sfifo_req_Msk (0x20UL)               /*!< i2c_xpic_app i2c_irqsr: sfifo_req (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqsr_mfifo_req_Pos (4UL)                  /*!< i2c_xpic_app i2c_irqsr: mfifo_req (Bit 4)             */
#define i2c_xpic_app_i2c_irqsr_mfifo_req_Msk (0x10UL)               /*!< i2c_xpic_app i2c_irqsr: mfifo_req (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqsr_bus_busy_Pos (3UL)                   /*!< i2c_xpic_app i2c_irqsr: bus_busy (Bit 3)              */
#define i2c_xpic_app_i2c_irqsr_bus_busy_Msk (0x8UL)                 /*!< i2c_xpic_app i2c_irqsr: bus_busy (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqsr_fifo_err_Pos (2UL)                   /*!< i2c_xpic_app i2c_irqsr: fifo_err (Bit 2)              */
#define i2c_xpic_app_i2c_irqsr_fifo_err_Msk (0x4UL)                 /*!< i2c_xpic_app i2c_irqsr: fifo_err (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqsr_cmd_err_Pos (1UL)                    /*!< i2c_xpic_app i2c_irqsr: cmd_err (Bit 1)               */
#define i2c_xpic_app_i2c_irqsr_cmd_err_Msk (0x2UL)                  /*!< i2c_xpic_app i2c_irqsr: cmd_err (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqsr_cmd_ok_Pos (0UL)                     /*!< i2c_xpic_app i2c_irqsr: cmd_ok (Bit 0)                */
#define i2c_xpic_app_i2c_irqsr_cmd_ok_Msk (0x1UL)                   /*!< i2c_xpic_app i2c_irqsr: cmd_ok (Bitfield-Mask: 0x01)  */
/* =====================================================  i2c_irqmsked  ====================================================== */
#define i2c_xpic_app_i2c_irqmsked_sreq_Pos (6UL)                    /*!< i2c_xpic_app i2c_irqmsked: sreq (Bit 6)               */
#define i2c_xpic_app_i2c_irqmsked_sreq_Msk (0x40UL)                 /*!< i2c_xpic_app i2c_irqmsked: sreq (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsked_sfifo_req_Pos (5UL)               /*!< i2c_xpic_app i2c_irqmsked: sfifo_req (Bit 5)          */
#define i2c_xpic_app_i2c_irqmsked_sfifo_req_Msk (0x20UL)            /*!< i2c_xpic_app i2c_irqmsked: sfifo_req (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsked_mfifo_req_Pos (4UL)               /*!< i2c_xpic_app i2c_irqmsked: mfifo_req (Bit 4)          */
#define i2c_xpic_app_i2c_irqmsked_mfifo_req_Msk (0x10UL)            /*!< i2c_xpic_app i2c_irqmsked: mfifo_req (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsked_bus_busy_Pos (3UL)                /*!< i2c_xpic_app i2c_irqmsked: bus_busy (Bit 3)           */
#define i2c_xpic_app_i2c_irqmsked_bus_busy_Msk (0x8UL)              /*!< i2c_xpic_app i2c_irqmsked: bus_busy (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsked_fifo_err_Pos (2UL)                /*!< i2c_xpic_app i2c_irqmsked: fifo_err (Bit 2)           */
#define i2c_xpic_app_i2c_irqmsked_fifo_err_Msk (0x4UL)              /*!< i2c_xpic_app i2c_irqmsked: fifo_err (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsked_cmd_err_Pos (1UL)                 /*!< i2c_xpic_app i2c_irqmsked: cmd_err (Bit 1)            */
#define i2c_xpic_app_i2c_irqmsked_cmd_err_Msk (0x2UL)               /*!< i2c_xpic_app i2c_irqmsked: cmd_err (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_irqmsked_cmd_ok_Pos (0UL)                  /*!< i2c_xpic_app i2c_irqmsked: cmd_ok (Bit 0)             */
#define i2c_xpic_app_i2c_irqmsked_cmd_ok_Msk (0x1UL)                /*!< i2c_xpic_app i2c_irqmsked: cmd_ok (Bitfield-Mask: 0x01) */
/* =======================================================  i2c_dmacr  ======================================================= */
#define i2c_xpic_app_i2c_dmacr_sdmab_en_Pos (3UL)                   /*!< i2c_xpic_app i2c_dmacr: sdmab_en (Bit 3)              */
#define i2c_xpic_app_i2c_dmacr_sdmab_en_Msk (0x8UL)                 /*!< i2c_xpic_app i2c_dmacr: sdmab_en (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_dmacr_sdmas_en_Pos (2UL)                   /*!< i2c_xpic_app i2c_dmacr: sdmas_en (Bit 2)              */
#define i2c_xpic_app_i2c_dmacr_sdmas_en_Msk (0x4UL)                 /*!< i2c_xpic_app i2c_dmacr: sdmas_en (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_dmacr_mdmab_en_Pos (1UL)                   /*!< i2c_xpic_app i2c_dmacr: mdmab_en (Bit 1)              */
#define i2c_xpic_app_i2c_dmacr_mdmab_en_Msk (0x2UL)                 /*!< i2c_xpic_app i2c_dmacr: mdmab_en (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_dmacr_mdmas_en_Pos (0UL)                   /*!< i2c_xpic_app i2c_dmacr: mdmas_en (Bit 0)              */
#define i2c_xpic_app_i2c_dmacr_mdmas_en_Msk (0x1UL)                 /*!< i2c_xpic_app i2c_dmacr: mdmas_en (Bitfield-Mask: 0x01) */
/* ========================================================  i2c_pio  ======================================================== */
#define i2c_xpic_app_i2c_pio_reserved1_Pos (7UL)                    /*!< i2c_xpic_app i2c_pio: reserved1 (Bit 7)               */
#define i2c_xpic_app_i2c_pio_reserved1_Msk (0xffffff80UL)           /*!< i2c_xpic_app i2c_pio: reserved1 (Bitfield-Mask: 0x1ffffff) */
#define i2c_xpic_app_i2c_pio_sda_in_ro_Pos (6UL)                    /*!< i2c_xpic_app i2c_pio: sda_in_ro (Bit 6)               */
#define i2c_xpic_app_i2c_pio_sda_in_ro_Msk (0x40UL)                 /*!< i2c_xpic_app i2c_pio: sda_in_ro (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_pio_sda_oe_Pos   (5UL)                     /*!< i2c_xpic_app i2c_pio: sda_oe (Bit 5)                  */
#define i2c_xpic_app_i2c_pio_sda_oe_Msk   (0x20UL)                  /*!< i2c_xpic_app i2c_pio: sda_oe (Bitfield-Mask: 0x01)    */
#define i2c_xpic_app_i2c_pio_sda_out_Pos  (4UL)                     /*!< i2c_xpic_app i2c_pio: sda_out (Bit 4)                 */
#define i2c_xpic_app_i2c_pio_sda_out_Msk  (0x10UL)                  /*!< i2c_xpic_app i2c_pio: sda_out (Bitfield-Mask: 0x01)   */
#define i2c_xpic_app_i2c_pio_reserved0_Pos (3UL)                    /*!< i2c_xpic_app i2c_pio: reserved0 (Bit 3)               */
#define i2c_xpic_app_i2c_pio_reserved0_Msk (0x8UL)                  /*!< i2c_xpic_app i2c_pio: reserved0 (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_pio_scl_in_ro_Pos (2UL)                    /*!< i2c_xpic_app i2c_pio: scl_in_ro (Bit 2)               */
#define i2c_xpic_app_i2c_pio_scl_in_ro_Msk (0x4UL)                  /*!< i2c_xpic_app i2c_pio: scl_in_ro (Bitfield-Mask: 0x01) */
#define i2c_xpic_app_i2c_pio_scl_oe_Pos   (1UL)                     /*!< i2c_xpic_app i2c_pio: scl_oe (Bit 1)                  */
#define i2c_xpic_app_i2c_pio_scl_oe_Msk   (0x2UL)                   /*!< i2c_xpic_app i2c_pio: scl_oe (Bitfield-Mask: 0x01)    */
#define i2c_xpic_app_i2c_pio_scl_out_Pos  (0UL)                     /*!< i2c_xpic_app i2c_pio: scl_out (Bit 0)                 */
#define i2c_xpic_app_i2c_pio_scl_out_Msk  (0x1UL)                   /*!< i2c_xpic_app i2c_pio: scl_out (Bitfield-Mask: 0x01)   */


/* =========================================================================================================================== */
/* ================                                       spi_xpic_app                                        ================ */
/* =========================================================================================================================== */

/* ========================================================  spi_cr0  ======================================================== */
#define spi_xpic_app_spi_cr0_netx100_comp_Pos (31UL)                /*!< spi_xpic_app spi_cr0: netx100_comp (Bit 31)           */
#define spi_xpic_app_spi_cr0_netx100_comp_Msk (0x80000000UL)        /*!< spi_xpic_app spi_cr0: netx100_comp (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_cr0_reserved3_Pos (29UL)                   /*!< spi_xpic_app spi_cr0: reserved3 (Bit 29)              */
#define spi_xpic_app_spi_cr0_reserved3_Msk (0x60000000UL)           /*!< spi_xpic_app spi_cr0: reserved3 (Bitfield-Mask: 0x03) */
#define spi_xpic_app_spi_cr0_slave_sig_early_Pos (28UL)             /*!< spi_xpic_app spi_cr0: slave_sig_early (Bit 28)        */
#define spi_xpic_app_spi_cr0_slave_sig_early_Msk (0x10000000UL)     /*!< spi_xpic_app spi_cr0: slave_sig_early (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_cr0_filter_in_Pos (27UL)                   /*!< spi_xpic_app spi_cr0: filter_in (Bit 27)              */
#define spi_xpic_app_spi_cr0_filter_in_Msk (0x8000000UL)            /*!< spi_xpic_app spi_cr0: filter_in (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_cr0_reserved2_Pos (26UL)                   /*!< spi_xpic_app spi_cr0: reserved2 (Bit 26)              */
#define spi_xpic_app_spi_cr0_reserved2_Msk (0x4000000UL)            /*!< spi_xpic_app spi_cr0: reserved2 (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_cr0_format_Pos   (24UL)                    /*!< spi_xpic_app spi_cr0: format (Bit 24)                 */
#define spi_xpic_app_spi_cr0_format_Msk   (0x3000000UL)             /*!< spi_xpic_app spi_cr0: format (Bitfield-Mask: 0x03)    */
#define spi_xpic_app_spi_cr0_reserved1_Pos (20UL)                   /*!< spi_xpic_app spi_cr0: reserved1 (Bit 20)              */
#define spi_xpic_app_spi_cr0_reserved1_Msk (0xf00000UL)             /*!< spi_xpic_app spi_cr0: reserved1 (Bitfield-Mask: 0x0f) */
#define spi_xpic_app_spi_cr0_sck_muladd_Pos (8UL)                   /*!< spi_xpic_app spi_cr0: sck_muladd (Bit 8)              */
#define spi_xpic_app_spi_cr0_sck_muladd_Msk (0xfff00UL)             /*!< spi_xpic_app spi_cr0: sck_muladd (Bitfield-Mask: 0xfff) */
#define spi_xpic_app_spi_cr0_SPH_Pos      (7UL)                     /*!< spi_xpic_app spi_cr0: SPH (Bit 7)                     */
#define spi_xpic_app_spi_cr0_SPH_Msk      (0x80UL)                  /*!< spi_xpic_app spi_cr0: SPH (Bitfield-Mask: 0x01)       */
#define spi_xpic_app_spi_cr0_SPO_Pos      (6UL)                     /*!< spi_xpic_app spi_cr0: SPO (Bit 6)                     */
#define spi_xpic_app_spi_cr0_SPO_Msk      (0x40UL)                  /*!< spi_xpic_app spi_cr0: SPO (Bitfield-Mask: 0x01)       */
#define spi_xpic_app_spi_cr0_reserved0_Pos (4UL)                    /*!< spi_xpic_app spi_cr0: reserved0 (Bit 4)               */
#define spi_xpic_app_spi_cr0_reserved0_Msk (0x30UL)                 /*!< spi_xpic_app spi_cr0: reserved0 (Bitfield-Mask: 0x03) */
#define spi_xpic_app_spi_cr0_datasize_Pos (0UL)                     /*!< spi_xpic_app spi_cr0: datasize (Bit 0)                */
#define spi_xpic_app_spi_cr0_datasize_Msk (0xfUL)                   /*!< spi_xpic_app spi_cr0: datasize (Bitfield-Mask: 0x0f)  */
/* ========================================================  spi_cr1  ======================================================== */
#define spi_xpic_app_spi_cr1_reserved3_Pos (29UL)                   /*!< spi_xpic_app spi_cr1: reserved3 (Bit 29)              */
#define spi_xpic_app_spi_cr1_reserved3_Msk (0xe0000000UL)           /*!< spi_xpic_app spi_cr1: reserved3 (Bitfield-Mask: 0x07) */
#define spi_xpic_app_spi_cr1_rx_fifo_clr_Pos (28UL)                 /*!< spi_xpic_app spi_cr1: rx_fifo_clr (Bit 28)            */
#define spi_xpic_app_spi_cr1_rx_fifo_clr_Msk (0x10000000UL)         /*!< spi_xpic_app spi_cr1: rx_fifo_clr (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_cr1_rx_fifo_wm_Pos (24UL)                  /*!< spi_xpic_app spi_cr1: rx_fifo_wm (Bit 24)             */
#define spi_xpic_app_spi_cr1_rx_fifo_wm_Msk (0xf000000UL)           /*!< spi_xpic_app spi_cr1: rx_fifo_wm (Bitfield-Mask: 0x0f) */
#define spi_xpic_app_spi_cr1_reserved2_Pos (21UL)                   /*!< spi_xpic_app spi_cr1: reserved2 (Bit 21)              */
#define spi_xpic_app_spi_cr1_reserved2_Msk (0xe00000UL)             /*!< spi_xpic_app spi_cr1: reserved2 (Bitfield-Mask: 0x07) */
#define spi_xpic_app_spi_cr1_tx_fifo_clr_Pos (20UL)                 /*!< spi_xpic_app spi_cr1: tx_fifo_clr (Bit 20)            */
#define spi_xpic_app_spi_cr1_tx_fifo_clr_Msk (0x100000UL)           /*!< spi_xpic_app spi_cr1: tx_fifo_clr (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_cr1_tx_fifo_wm_Pos (16UL)                  /*!< spi_xpic_app spi_cr1: tx_fifo_wm (Bit 16)             */
#define spi_xpic_app_spi_cr1_tx_fifo_wm_Msk (0xf0000UL)             /*!< spi_xpic_app spi_cr1: tx_fifo_wm (Bitfield-Mask: 0x0f) */
#define spi_xpic_app_spi_cr1_reserved1_Pos (12UL)                   /*!< spi_xpic_app spi_cr1: reserved1 (Bit 12)              */
#define spi_xpic_app_spi_cr1_reserved1_Msk (0xf000UL)               /*!< spi_xpic_app spi_cr1: reserved1 (Bitfield-Mask: 0x0f) */
#define spi_xpic_app_spi_cr1_fss_static_Pos (11UL)                  /*!< spi_xpic_app spi_cr1: fss_static (Bit 11)             */
#define spi_xpic_app_spi_cr1_fss_static_Msk (0x800UL)               /*!< spi_xpic_app spi_cr1: fss_static (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_cr1_fss_Pos      (8UL)                     /*!< spi_xpic_app spi_cr1: fss (Bit 8)                     */
#define spi_xpic_app_spi_cr1_fss_Msk      (0x700UL)                 /*!< spi_xpic_app spi_cr1: fss (Bitfield-Mask: 0x07)       */
#define spi_xpic_app_spi_cr1_reserved0_Pos (4UL)                    /*!< spi_xpic_app spi_cr1: reserved0 (Bit 4)               */
#define spi_xpic_app_spi_cr1_reserved0_Msk (0xf0UL)                 /*!< spi_xpic_app spi_cr1: reserved0 (Bitfield-Mask: 0x0f) */
#define spi_xpic_app_spi_cr1_SOD_Pos      (3UL)                     /*!< spi_xpic_app spi_cr1: SOD (Bit 3)                     */
#define spi_xpic_app_spi_cr1_SOD_Msk      (0x8UL)                   /*!< spi_xpic_app spi_cr1: SOD (Bitfield-Mask: 0x01)       */
#define spi_xpic_app_spi_cr1_MS_Pos       (2UL)                     /*!< spi_xpic_app spi_cr1: MS (Bit 2)                      */
#define spi_xpic_app_spi_cr1_MS_Msk       (0x4UL)                   /*!< spi_xpic_app spi_cr1: MS (Bitfield-Mask: 0x01)        */
#define spi_xpic_app_spi_cr1_SSE_Pos      (1UL)                     /*!< spi_xpic_app spi_cr1: SSE (Bit 1)                     */
#define spi_xpic_app_spi_cr1_SSE_Msk      (0x2UL)                   /*!< spi_xpic_app spi_cr1: SSE (Bitfield-Mask: 0x01)       */
#define spi_xpic_app_spi_cr1_LBM_Pos      (0UL)                     /*!< spi_xpic_app spi_cr1: LBM (Bit 0)                     */
#define spi_xpic_app_spi_cr1_LBM_Msk      (0x1UL)                   /*!< spi_xpic_app spi_cr1: LBM (Bitfield-Mask: 0x01)       */
/* ========================================================  spi_dr  ========================================================= */
#define spi_xpic_app_spi_dr_data_Pos      (0UL)                     /*!< spi_xpic_app spi_dr: data (Bit 0)                     */
#define spi_xpic_app_spi_dr_data_Msk      (0x1ffffUL)               /*!< spi_xpic_app spi_dr: data (Bitfield-Mask: 0x1ffff)    */
/* ========================================================  spi_sr  ========================================================= */
#define spi_xpic_app_spi_sr_rx_fifo_err_undr_Pos (31UL)             /*!< spi_xpic_app spi_sr: rx_fifo_err_undr (Bit 31)        */
#define spi_xpic_app_spi_sr_rx_fifo_err_undr_Msk (0x80000000UL)     /*!< spi_xpic_app spi_sr: rx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_sr_rx_fifo_err_ovfl_Pos (30UL)             /*!< spi_xpic_app spi_sr: rx_fifo_err_ovfl (Bit 30)        */
#define spi_xpic_app_spi_sr_rx_fifo_err_ovfl_Msk (0x40000000UL)     /*!< spi_xpic_app spi_sr: rx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_sr_reserved2_Pos (29UL)                    /*!< spi_xpic_app spi_sr: reserved2 (Bit 29)               */
#define spi_xpic_app_spi_sr_reserved2_Msk (0x20000000UL)            /*!< spi_xpic_app spi_sr: reserved2 (Bitfield-Mask: 0x01)  */
#define spi_xpic_app_spi_sr_rx_fifo_level_Pos (24UL)                /*!< spi_xpic_app spi_sr: rx_fifo_level (Bit 24)           */
#define spi_xpic_app_spi_sr_rx_fifo_level_Msk (0x1f000000UL)        /*!< spi_xpic_app spi_sr: rx_fifo_level (Bitfield-Mask: 0x1f) */
#define spi_xpic_app_spi_sr_tx_fifo_err_undr_Pos (23UL)             /*!< spi_xpic_app spi_sr: tx_fifo_err_undr (Bit 23)        */
#define spi_xpic_app_spi_sr_tx_fifo_err_undr_Msk (0x800000UL)       /*!< spi_xpic_app spi_sr: tx_fifo_err_undr (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_sr_tx_fifo_err_ovfl_Pos (22UL)             /*!< spi_xpic_app spi_sr: tx_fifo_err_ovfl (Bit 22)        */
#define spi_xpic_app_spi_sr_tx_fifo_err_ovfl_Msk (0x400000UL)       /*!< spi_xpic_app spi_sr: tx_fifo_err_ovfl (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_sr_reserved1_Pos (21UL)                    /*!< spi_xpic_app spi_sr: reserved1 (Bit 21)               */
#define spi_xpic_app_spi_sr_reserved1_Msk (0x200000UL)              /*!< spi_xpic_app spi_sr: reserved1 (Bitfield-Mask: 0x01)  */
#define spi_xpic_app_spi_sr_tx_fifo_level_Pos (16UL)                /*!< spi_xpic_app spi_sr: tx_fifo_level (Bit 16)           */
#define spi_xpic_app_spi_sr_tx_fifo_level_Msk (0x1f0000UL)          /*!< spi_xpic_app spi_sr: tx_fifo_level (Bitfield-Mask: 0x1f) */
#define spi_xpic_app_spi_sr_reserved0_Pos (5UL)                     /*!< spi_xpic_app spi_sr: reserved0 (Bit 5)                */
#define spi_xpic_app_spi_sr_reserved0_Msk (0xffe0UL)                /*!< spi_xpic_app spi_sr: reserved0 (Bitfield-Mask: 0x7ff) */
#define spi_xpic_app_spi_sr_BSY_Pos       (4UL)                     /*!< spi_xpic_app spi_sr: BSY (Bit 4)                      */
#define spi_xpic_app_spi_sr_BSY_Msk       (0x10UL)                  /*!< spi_xpic_app spi_sr: BSY (Bitfield-Mask: 0x01)        */
#define spi_xpic_app_spi_sr_RFF_Pos       (3UL)                     /*!< spi_xpic_app spi_sr: RFF (Bit 3)                      */
#define spi_xpic_app_spi_sr_RFF_Msk       (0x8UL)                   /*!< spi_xpic_app spi_sr: RFF (Bitfield-Mask: 0x01)        */
#define spi_xpic_app_spi_sr_RNE_Pos       (2UL)                     /*!< spi_xpic_app spi_sr: RNE (Bit 2)                      */
#define spi_xpic_app_spi_sr_RNE_Msk       (0x4UL)                   /*!< spi_xpic_app spi_sr: RNE (Bitfield-Mask: 0x01)        */
#define spi_xpic_app_spi_sr_TNF_Pos       (1UL)                     /*!< spi_xpic_app spi_sr: TNF (Bit 1)                      */
#define spi_xpic_app_spi_sr_TNF_Msk       (0x2UL)                   /*!< spi_xpic_app spi_sr: TNF (Bitfield-Mask: 0x01)        */
#define spi_xpic_app_spi_sr_TFE_Pos       (0UL)                     /*!< spi_xpic_app spi_sr: TFE (Bit 0)                      */
#define spi_xpic_app_spi_sr_TFE_Msk       (0x1UL)                   /*!< spi_xpic_app spi_sr: TFE (Bitfield-Mask: 0x01)        */
/* =======================================================  spi_imsc  ======================================================== */
#define spi_xpic_app_spi_imsc_txeim_Pos   (6UL)                     /*!< spi_xpic_app spi_imsc: txeim (Bit 6)                  */
#define spi_xpic_app_spi_imsc_txeim_Msk   (0x40UL)                  /*!< spi_xpic_app spi_imsc: txeim (Bitfield-Mask: 0x01)    */
#define spi_xpic_app_spi_imsc_rxfim_Pos   (5UL)                     /*!< spi_xpic_app spi_imsc: rxfim (Bit 5)                  */
#define spi_xpic_app_spi_imsc_rxfim_Msk   (0x20UL)                  /*!< spi_xpic_app spi_imsc: rxfim (Bitfield-Mask: 0x01)    */
#define spi_xpic_app_spi_imsc_rxneim_Pos  (4UL)                     /*!< spi_xpic_app spi_imsc: rxneim (Bit 4)                 */
#define spi_xpic_app_spi_imsc_rxneim_Msk  (0x10UL)                  /*!< spi_xpic_app spi_imsc: rxneim (Bitfield-Mask: 0x01)   */
#define spi_xpic_app_spi_imsc_TXIM_Pos    (3UL)                     /*!< spi_xpic_app spi_imsc: TXIM (Bit 3)                   */
#define spi_xpic_app_spi_imsc_TXIM_Msk    (0x8UL)                   /*!< spi_xpic_app spi_imsc: TXIM (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_imsc_RXIM_Pos    (2UL)                     /*!< spi_xpic_app spi_imsc: RXIM (Bit 2)                   */
#define spi_xpic_app_spi_imsc_RXIM_Msk    (0x4UL)                   /*!< spi_xpic_app spi_imsc: RXIM (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_imsc_RTIM_Pos    (1UL)                     /*!< spi_xpic_app spi_imsc: RTIM (Bit 1)                   */
#define spi_xpic_app_spi_imsc_RTIM_Msk    (0x2UL)                   /*!< spi_xpic_app spi_imsc: RTIM (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_imsc_RORIM_Pos   (0UL)                     /*!< spi_xpic_app spi_imsc: RORIM (Bit 0)                  */
#define spi_xpic_app_spi_imsc_RORIM_Msk   (0x1UL)                   /*!< spi_xpic_app spi_imsc: RORIM (Bitfield-Mask: 0x01)    */
/* ========================================================  spi_ris  ======================================================== */
#define spi_xpic_app_spi_ris_txeris_Pos   (6UL)                     /*!< spi_xpic_app spi_ris: txeris (Bit 6)                  */
#define spi_xpic_app_spi_ris_txeris_Msk   (0x40UL)                  /*!< spi_xpic_app spi_ris: txeris (Bitfield-Mask: 0x01)    */
#define spi_xpic_app_spi_ris_rxfris_Pos   (5UL)                     /*!< spi_xpic_app spi_ris: rxfris (Bit 5)                  */
#define spi_xpic_app_spi_ris_rxfris_Msk   (0x20UL)                  /*!< spi_xpic_app spi_ris: rxfris (Bitfield-Mask: 0x01)    */
#define spi_xpic_app_spi_ris_rxneris_Pos  (4UL)                     /*!< spi_xpic_app spi_ris: rxneris (Bit 4)                 */
#define spi_xpic_app_spi_ris_rxneris_Msk  (0x10UL)                  /*!< spi_xpic_app spi_ris: rxneris (Bitfield-Mask: 0x01)   */
#define spi_xpic_app_spi_ris_TXRIS_Pos    (3UL)                     /*!< spi_xpic_app spi_ris: TXRIS (Bit 3)                   */
#define spi_xpic_app_spi_ris_TXRIS_Msk    (0x8UL)                   /*!< spi_xpic_app spi_ris: TXRIS (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_ris_RXRIS_Pos    (2UL)                     /*!< spi_xpic_app spi_ris: RXRIS (Bit 2)                   */
#define spi_xpic_app_spi_ris_RXRIS_Msk    (0x4UL)                   /*!< spi_xpic_app spi_ris: RXRIS (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_ris_RTRIS_Pos    (1UL)                     /*!< spi_xpic_app spi_ris: RTRIS (Bit 1)                   */
#define spi_xpic_app_spi_ris_RTRIS_Msk    (0x2UL)                   /*!< spi_xpic_app spi_ris: RTRIS (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_ris_RORRIS_Pos   (0UL)                     /*!< spi_xpic_app spi_ris: RORRIS (Bit 0)                  */
#define spi_xpic_app_spi_ris_RORRIS_Msk   (0x1UL)                   /*!< spi_xpic_app spi_ris: RORRIS (Bitfield-Mask: 0x01)    */
/* ========================================================  spi_mis  ======================================================== */
#define spi_xpic_app_spi_mis_txemis_Pos   (6UL)                     /*!< spi_xpic_app spi_mis: txemis (Bit 6)                  */
#define spi_xpic_app_spi_mis_txemis_Msk   (0x40UL)                  /*!< spi_xpic_app spi_mis: txemis (Bitfield-Mask: 0x01)    */
#define spi_xpic_app_spi_mis_rxfmis_Pos   (5UL)                     /*!< spi_xpic_app spi_mis: rxfmis (Bit 5)                  */
#define spi_xpic_app_spi_mis_rxfmis_Msk   (0x20UL)                  /*!< spi_xpic_app spi_mis: rxfmis (Bitfield-Mask: 0x01)    */
#define spi_xpic_app_spi_mis_rxnemis_Pos  (4UL)                     /*!< spi_xpic_app spi_mis: rxnemis (Bit 4)                 */
#define spi_xpic_app_spi_mis_rxnemis_Msk  (0x10UL)                  /*!< spi_xpic_app spi_mis: rxnemis (Bitfield-Mask: 0x01)   */
#define spi_xpic_app_spi_mis_TXMIS_Pos    (3UL)                     /*!< spi_xpic_app spi_mis: TXMIS (Bit 3)                   */
#define spi_xpic_app_spi_mis_TXMIS_Msk    (0x8UL)                   /*!< spi_xpic_app spi_mis: TXMIS (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_mis_RXMIS_Pos    (2UL)                     /*!< spi_xpic_app spi_mis: RXMIS (Bit 2)                   */
#define spi_xpic_app_spi_mis_RXMIS_Msk    (0x4UL)                   /*!< spi_xpic_app spi_mis: RXMIS (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_mis_RTMIS_Pos    (1UL)                     /*!< spi_xpic_app spi_mis: RTMIS (Bit 1)                   */
#define spi_xpic_app_spi_mis_RTMIS_Msk    (0x2UL)                   /*!< spi_xpic_app spi_mis: RTMIS (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_mis_RORMIS_Pos   (0UL)                     /*!< spi_xpic_app spi_mis: RORMIS (Bit 0)                  */
#define spi_xpic_app_spi_mis_RORMIS_Msk   (0x1UL)                   /*!< spi_xpic_app spi_mis: RORMIS (Bitfield-Mask: 0x01)    */
/* ========================================================  spi_icr  ======================================================== */
#define spi_xpic_app_spi_icr_txeic_Pos    (6UL)                     /*!< spi_xpic_app spi_icr: txeic (Bit 6)                   */
#define spi_xpic_app_spi_icr_txeic_Msk    (0x40UL)                  /*!< spi_xpic_app spi_icr: txeic (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_icr_rxfic_Pos    (5UL)                     /*!< spi_xpic_app spi_icr: rxfic (Bit 5)                   */
#define spi_xpic_app_spi_icr_rxfic_Msk    (0x20UL)                  /*!< spi_xpic_app spi_icr: rxfic (Bitfield-Mask: 0x01)     */
#define spi_xpic_app_spi_icr_rxneic_Pos   (4UL)                     /*!< spi_xpic_app spi_icr: rxneic (Bit 4)                  */
#define spi_xpic_app_spi_icr_rxneic_Msk   (0x10UL)                  /*!< spi_xpic_app spi_icr: rxneic (Bitfield-Mask: 0x01)    */
#define spi_xpic_app_spi_icr_TXIC_Pos     (3UL)                     /*!< spi_xpic_app spi_icr: TXIC (Bit 3)                    */
#define spi_xpic_app_spi_icr_TXIC_Msk     (0x8UL)                   /*!< spi_xpic_app spi_icr: TXIC (Bitfield-Mask: 0x01)      */
#define spi_xpic_app_spi_icr_RXIC_Pos     (2UL)                     /*!< spi_xpic_app spi_icr: RXIC (Bit 2)                    */
#define spi_xpic_app_spi_icr_RXIC_Msk     (0x4UL)                   /*!< spi_xpic_app spi_icr: RXIC (Bitfield-Mask: 0x01)      */
#define spi_xpic_app_spi_icr_RTIC_Pos     (1UL)                     /*!< spi_xpic_app spi_icr: RTIC (Bit 1)                    */
#define spi_xpic_app_spi_icr_RTIC_Msk     (0x2UL)                   /*!< spi_xpic_app spi_icr: RTIC (Bitfield-Mask: 0x01)      */
#define spi_xpic_app_spi_icr_RORIC_Pos    (0UL)                     /*!< spi_xpic_app spi_icr: RORIC (Bit 0)                   */
#define spi_xpic_app_spi_icr_RORIC_Msk    (0x1UL)                   /*!< spi_xpic_app spi_icr: RORIC (Bitfield-Mask: 0x01)     */
/* =======================================================  spi_dmacr  ======================================================= */
#define spi_xpic_app_spi_dmacr_TXDMAE_Pos (1UL)                     /*!< spi_xpic_app spi_dmacr: TXDMAE (Bit 1)                */
#define spi_xpic_app_spi_dmacr_TXDMAE_Msk (0x2UL)                   /*!< spi_xpic_app spi_dmacr: TXDMAE (Bitfield-Mask: 0x01)  */
#define spi_xpic_app_spi_dmacr_RXDMAE_Pos (0UL)                     /*!< spi_xpic_app spi_dmacr: RXDMAE (Bit 0)                */
#define spi_xpic_app_spi_dmacr_RXDMAE_Msk (0x1UL)                   /*!< spi_xpic_app spi_dmacr: RXDMAE (Bitfield-Mask: 0x01)  */
/* ===================================================  spi_data_register  =================================================== */
#define spi_xpic_app_spi_data_register_dr_valid1_Pos (17UL)         /*!< spi_xpic_app spi_data_register: dr_valid1 (Bit 17)    */
#define spi_xpic_app_spi_data_register_dr_valid1_Msk (0x20000UL)    /*!< spi_xpic_app spi_data_register: dr_valid1 (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_data_register_dr_valid0_Pos (16UL)         /*!< spi_xpic_app spi_data_register: dr_valid0 (Bit 16)    */
#define spi_xpic_app_spi_data_register_dr_valid0_Msk (0x10000UL)    /*!< spi_xpic_app spi_data_register: dr_valid0 (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_data_register_data_byte_1_Pos (8UL)        /*!< spi_xpic_app spi_data_register: data_byte_1 (Bit 8)   */
#define spi_xpic_app_spi_data_register_data_byte_1_Msk (0xff00UL)   /*!< spi_xpic_app spi_data_register: data_byte_1 (Bitfield-Mask: 0xff) */
#define spi_xpic_app_spi_data_register_data_byte_0_Pos (0UL)        /*!< spi_xpic_app spi_data_register: data_byte_0 (Bit 0)   */
#define spi_xpic_app_spi_data_register_data_byte_0_Msk (0xffUL)     /*!< spi_xpic_app spi_data_register: data_byte_0 (Bitfield-Mask: 0xff) */
/* ==================================================  spi_status_register  ================================================== */
#define spi_xpic_app_spi_status_register_SR_selected_Pos (25UL)     /*!< spi_xpic_app spi_status_register: SR_selected (Bit 25) */
#define spi_xpic_app_spi_status_register_SR_selected_Msk (0x2000000UL) /*!< spi_xpic_app spi_status_register: SR_selected (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_out_full_Pos (24UL)     /*!< spi_xpic_app spi_status_register: SR_out_full (Bit 24) */
#define spi_xpic_app_spi_status_register_SR_out_full_Msk (0x1000000UL) /*!< spi_xpic_app spi_status_register: SR_out_full (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_out_empty_Pos (23UL)    /*!< spi_xpic_app spi_status_register: SR_out_empty (Bit 23) */
#define spi_xpic_app_spi_status_register_SR_out_empty_Msk (0x800000UL) /*!< spi_xpic_app spi_status_register: SR_out_empty (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_out_fw_Pos (22UL)       /*!< spi_xpic_app spi_status_register: SR_out_fw (Bit 22)  */
#define spi_xpic_app_spi_status_register_SR_out_fw_Msk (0x400000UL) /*!< spi_xpic_app spi_status_register: SR_out_fw (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_out_fuel_Pos (21UL)     /*!< spi_xpic_app spi_status_register: SR_out_fuel (Bit 21) */
#define spi_xpic_app_spi_status_register_SR_out_fuel_Msk (0x200000UL) /*!< spi_xpic_app spi_status_register: SR_out_fuel (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_in_full_Pos (20UL)      /*!< spi_xpic_app spi_status_register: SR_in_full (Bit 20) */
#define spi_xpic_app_spi_status_register_SR_in_full_Msk (0x100000UL) /*!< spi_xpic_app spi_status_register: SR_in_full (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_in_recdata_Pos (19UL)   /*!< spi_xpic_app spi_status_register: SR_in_recdata (Bit 19) */
#define spi_xpic_app_spi_status_register_SR_in_recdata_Msk (0x80000UL) /*!< spi_xpic_app spi_status_register: SR_in_recdata (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_in_fuel_Pos (18UL)      /*!< spi_xpic_app spi_status_register: SR_in_fuel (Bit 18) */
#define spi_xpic_app_spi_status_register_SR_in_fuel_Msk (0x40000UL) /*!< spi_xpic_app spi_status_register: SR_in_fuel (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_status_register_SR_out_fuel_val_Pos (9UL)  /*!< spi_xpic_app spi_status_register: SR_out_fuel_val (Bit 9) */
#define spi_xpic_app_spi_status_register_SR_out_fuel_val_Msk (0x3fe00UL) /*!< spi_xpic_app spi_status_register: SR_out_fuel_val (Bitfield-Mask: 0x1ff) */
#define spi_xpic_app_spi_status_register_SR_in_fuel_val_Pos (0UL)   /*!< spi_xpic_app spi_status_register: SR_in_fuel_val (Bit 0) */
#define spi_xpic_app_spi_status_register_SR_in_fuel_val_Msk (0x1ffUL) /*!< spi_xpic_app spi_status_register: SR_in_fuel_val (Bitfield-Mask: 0x1ff) */
/* =================================================  spi_control_register  ================================================== */
#define spi_xpic_app_spi_control_register_CR_en_Pos (31UL)          /*!< spi_xpic_app spi_control_register: CR_en (Bit 31)     */
#define spi_xpic_app_spi_control_register_CR_en_Msk (0x80000000UL)  /*!< spi_xpic_app spi_control_register: CR_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_ms_Pos (30UL)          /*!< spi_xpic_app spi_control_register: CR_ms (Bit 30)     */
#define spi_xpic_app_spi_control_register_CR_ms_Msk (0x40000000UL)  /*!< spi_xpic_app spi_control_register: CR_ms (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_cpol_Pos (29UL)        /*!< spi_xpic_app spi_control_register: CR_cpol (Bit 29)   */
#define spi_xpic_app_spi_control_register_CR_cpol_Msk (0x20000000UL) /*!< spi_xpic_app spi_control_register: CR_cpol (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_ncpha_Pos (28UL)       /*!< spi_xpic_app spi_control_register: CR_ncpha (Bit 28)  */
#define spi_xpic_app_spi_control_register_CR_ncpha_Msk (0x10000000UL) /*!< spi_xpic_app spi_control_register: CR_ncpha (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_burst_Pos (25UL)       /*!< spi_xpic_app spi_control_register: CR_burst (Bit 25)  */
#define spi_xpic_app_spi_control_register_CR_burst_Msk (0xe000000UL) /*!< spi_xpic_app spi_control_register: CR_burst (Bitfield-Mask: 0x07) */
#define spi_xpic_app_spi_control_register_CR_burstdelay_Pos (22UL)  /*!< spi_xpic_app spi_control_register: CR_burstdelay (Bit 22) */
#define spi_xpic_app_spi_control_register_CR_burstdelay_Msk (0x1c00000UL) /*!< spi_xpic_app spi_control_register: CR_burstdelay (Bitfield-Mask: 0x07) */
#define spi_xpic_app_spi_control_register_CR_clr_outfifo_Pos (21UL) /*!< spi_xpic_app spi_control_register: CR_clr_outfifo (Bit 21) */
#define spi_xpic_app_spi_control_register_CR_clr_outfifo_Msk (0x200000UL) /*!< spi_xpic_app spi_control_register: CR_clr_outfifo (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_clr_infifo_Pos (20UL)  /*!< spi_xpic_app spi_control_register: CR_clr_infifo (Bit 20) */
#define spi_xpic_app_spi_control_register_CR_clr_infifo_Msk (0x100000UL) /*!< spi_xpic_app spi_control_register: CR_clr_infifo (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_reserved1_Pos (12UL)      /*!< spi_xpic_app spi_control_register: reserved1 (Bit 12) */
#define spi_xpic_app_spi_control_register_reserved1_Msk (0xff000UL) /*!< spi_xpic_app spi_control_register: reserved1 (Bitfield-Mask: 0xff) */
#define spi_xpic_app_spi_control_register_CS_mode_Pos (11UL)        /*!< spi_xpic_app spi_control_register: CS_mode (Bit 11)   */
#define spi_xpic_app_spi_control_register_CS_mode_Msk (0x800UL)     /*!< spi_xpic_app spi_control_register: CS_mode (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_ss_Pos (8UL)           /*!< spi_xpic_app spi_control_register: CR_ss (Bit 8)      */
#define spi_xpic_app_spi_control_register_CR_ss_Msk (0x700UL)       /*!< spi_xpic_app spi_control_register: CR_ss (Bitfield-Mask: 0x07) */
#define spi_xpic_app_spi_control_register_CR_write_Pos (7UL)        /*!< spi_xpic_app spi_control_register: CR_write (Bit 7)   */
#define spi_xpic_app_spi_control_register_CR_write_Msk (0x80UL)     /*!< spi_xpic_app spi_control_register: CR_write (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_read_Pos (6UL)         /*!< spi_xpic_app spi_control_register: CR_read (Bit 6)    */
#define spi_xpic_app_spi_control_register_CR_read_Msk (0x40UL)      /*!< spi_xpic_app spi_control_register: CR_read (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_reserved0_Pos (5UL)       /*!< spi_xpic_app spi_control_register: reserved0 (Bit 5)  */
#define spi_xpic_app_spi_control_register_reserved0_Msk (0x20UL)    /*!< spi_xpic_app spi_control_register: reserved0 (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_control_register_CR_speed_Pos (1UL)        /*!< spi_xpic_app spi_control_register: CR_speed (Bit 1)   */
#define spi_xpic_app_spi_control_register_CR_speed_Msk (0x1eUL)     /*!< spi_xpic_app spi_control_register: CR_speed (Bitfield-Mask: 0x0f) */
#define spi_xpic_app_spi_control_register_CR_softreset_Pos (0UL)    /*!< spi_xpic_app spi_control_register: CR_softreset (Bit 0) */
#define spi_xpic_app_spi_control_register_CR_softreset_Msk (0x1UL)  /*!< spi_xpic_app spi_control_register: CR_softreset (Bitfield-Mask: 0x01) */
/* ============================================  spi_interrupt_control_register  ============================================= */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_full_en_Pos (24UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_full_en (Bit 24) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_full_en_Msk (0x1000000UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_full_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_empty_en_Pos (23UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_empty_en (Bit 23) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_empty_en_Msk (0x800000UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_empty_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_fw_en_Pos (22UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_fw_en (Bit 22) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_fw_en_Msk (0x400000UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_fw_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_fuel_en_Pos (21UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_fuel_en (Bit 21) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_fuel_en_Msk (0x200000UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_fuel_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_full_en_Pos (20UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_full_en (Bit 20) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_full_en_Msk (0x100000UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_full_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_recdata_en_Pos (19UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_recdata_en (Bit 19) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_recdata_en_Msk (0x80000UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_recdata_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_fuel_en_Pos (18UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_fuel_en (Bit 18) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_fuel_en_Msk (0x40000UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_fuel_en (Bitfield-Mask: 0x01) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_fuel_Pos (9UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_fuel (Bit 9) */
#define spi_xpic_app_spi_interrupt_control_register_IR_out_fuel_Msk (0x3fe00UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_out_fuel (Bitfield-Mask: 0x1ff) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_fuel_Pos (0UL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_fuel (Bit 0) */
#define spi_xpic_app_spi_interrupt_control_register_IR_in_fuel_Msk (0x1ffUL) /*!< spi_xpic_app spi_interrupt_control_register: IR_in_fuel (Bitfield-Mask: 0x1ff) */


/* =========================================================================================================================== */
/* ================                                          xlink0                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink0_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink0 xlink_cfg: end_spl (Bit 28)                    */
#define xlink0_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink0 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink0_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink0 xlink_cfg: start_spl (Bit 24)                  */
#define xlink0_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink0 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink0_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink0 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink0_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink0 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink0_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink0 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink0_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink0 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink0_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink0 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink0_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink0 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink0_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink0 xlink_cfg: fb_en (Bit 17)                      */
#define xlink0_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink0 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink0_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink0 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink0_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink0 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink0_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink0 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink0_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink0 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink0_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink0 xlink_tx: idle_ro (Bit 17)                     */
#define xlink0_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink0 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink0_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink0 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink0_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink0 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink0_xlink_tx_hold_Pos          (0UL)                     /*!< xlink0 xlink_tx: hold (Bit 0)                         */
#define xlink0_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink0 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink0_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink0 xlink_rx: reserved1 (Bit 22)                   */
#define xlink0_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink0 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink0_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink0 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink0_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink0 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink0_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink0 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink0_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink0 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink0_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink0 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink0_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink0 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink0_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink0 xlink_rx: reserved0 (Bit 17)                   */
#define xlink0_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink0 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink0_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink0 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink0_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink0 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink0_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink0 xlink_rx: hold_ro (Bit 0)                      */
#define xlink0_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink0 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink0_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink0 xlink_stat: filter_en (Bit 24)                 */
#define xlink0_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink0 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink0_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink0 xlink_stat: set_wakeup (Bit 23)                */
#define xlink0_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink0 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink0_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink0 xlink_stat: set_txoe (Bit 22)                  */
#define xlink0_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink0 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink0_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink0 xlink_stat: set_tx (Bit 21)                    */
#define xlink0_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink0 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink0_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink0 xlink_stat: io_mode (Bit 20)                   */
#define xlink0_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink0 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink0_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink0 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink0_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink0 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink0_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink0 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink0_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink0 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink0_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink0 xlink_stat: txo_ro (Bit 17)                    */
#define xlink0_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink0 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink0_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink0 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink0_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink0 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink0_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink0 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink0_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink0 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                          xlink1                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink1_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink1 xlink_cfg: end_spl (Bit 28)                    */
#define xlink1_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink1 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink1_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink1 xlink_cfg: start_spl (Bit 24)                  */
#define xlink1_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink1 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink1_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink1 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink1_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink1 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink1_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink1 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink1_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink1 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink1_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink1 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink1_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink1 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink1_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink1 xlink_cfg: fb_en (Bit 17)                      */
#define xlink1_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink1 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink1_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink1 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink1_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink1 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink1_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink1 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink1_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink1 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink1_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink1 xlink_tx: idle_ro (Bit 17)                     */
#define xlink1_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink1 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink1_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink1 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink1_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink1 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink1_xlink_tx_hold_Pos          (0UL)                     /*!< xlink1 xlink_tx: hold (Bit 0)                         */
#define xlink1_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink1 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink1_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink1 xlink_rx: reserved1 (Bit 22)                   */
#define xlink1_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink1 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink1_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink1 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink1_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink1 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink1_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink1 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink1_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink1 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink1_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink1 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink1_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink1 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink1_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink1 xlink_rx: reserved0 (Bit 17)                   */
#define xlink1_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink1 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink1_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink1 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink1_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink1 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink1_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink1 xlink_rx: hold_ro (Bit 0)                      */
#define xlink1_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink1 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink1_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink1 xlink_stat: filter_en (Bit 24)                 */
#define xlink1_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink1 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink1_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink1 xlink_stat: set_wakeup (Bit 23)                */
#define xlink1_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink1 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink1_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink1 xlink_stat: set_txoe (Bit 22)                  */
#define xlink1_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink1 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink1_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink1 xlink_stat: set_tx (Bit 21)                    */
#define xlink1_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink1 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink1_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink1 xlink_stat: io_mode (Bit 20)                   */
#define xlink1_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink1 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink1_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink1 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink1_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink1 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink1_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink1 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink1_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink1 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink1_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink1 xlink_stat: txo_ro (Bit 17)                    */
#define xlink1_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink1 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink1_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink1 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink1_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink1 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink1_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink1 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink1_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink1 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                          xlink2                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink2_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink2 xlink_cfg: end_spl (Bit 28)                    */
#define xlink2_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink2 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink2_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink2 xlink_cfg: start_spl (Bit 24)                  */
#define xlink2_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink2 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink2_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink2 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink2_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink2 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink2_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink2 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink2_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink2 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink2_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink2 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink2_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink2 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink2_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink2 xlink_cfg: fb_en (Bit 17)                      */
#define xlink2_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink2 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink2_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink2 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink2_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink2 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink2_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink2 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink2_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink2 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink2_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink2 xlink_tx: idle_ro (Bit 17)                     */
#define xlink2_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink2 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink2_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink2 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink2_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink2 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink2_xlink_tx_hold_Pos          (0UL)                     /*!< xlink2 xlink_tx: hold (Bit 0)                         */
#define xlink2_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink2 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink2_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink2 xlink_rx: reserved1 (Bit 22)                   */
#define xlink2_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink2 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink2_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink2 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink2_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink2 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink2_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink2 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink2_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink2 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink2_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink2 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink2_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink2 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink2_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink2 xlink_rx: reserved0 (Bit 17)                   */
#define xlink2_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink2 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink2_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink2 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink2_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink2 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink2_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink2 xlink_rx: hold_ro (Bit 0)                      */
#define xlink2_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink2 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink2_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink2 xlink_stat: filter_en (Bit 24)                 */
#define xlink2_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink2 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink2_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink2 xlink_stat: set_wakeup (Bit 23)                */
#define xlink2_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink2 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink2_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink2 xlink_stat: set_txoe (Bit 22)                  */
#define xlink2_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink2 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink2_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink2 xlink_stat: set_tx (Bit 21)                    */
#define xlink2_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink2 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink2_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink2 xlink_stat: io_mode (Bit 20)                   */
#define xlink2_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink2 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink2_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink2 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink2_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink2 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink2_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink2 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink2_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink2 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink2_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink2 xlink_stat: txo_ro (Bit 17)                    */
#define xlink2_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink2 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink2_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink2 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink2_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink2 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink2_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink2 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink2_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink2 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                          xlink3                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink3_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink3 xlink_cfg: end_spl (Bit 28)                    */
#define xlink3_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink3 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink3_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink3 xlink_cfg: start_spl (Bit 24)                  */
#define xlink3_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink3 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink3_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink3 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink3_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink3 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink3_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink3 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink3_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink3 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink3_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink3 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink3_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink3 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink3_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink3 xlink_cfg: fb_en (Bit 17)                      */
#define xlink3_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink3 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink3_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink3 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink3_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink3 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink3_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink3 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink3_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink3 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink3_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink3 xlink_tx: idle_ro (Bit 17)                     */
#define xlink3_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink3 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink3_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink3 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink3_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink3 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink3_xlink_tx_hold_Pos          (0UL)                     /*!< xlink3 xlink_tx: hold (Bit 0)                         */
#define xlink3_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink3 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink3_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink3 xlink_rx: reserved1 (Bit 22)                   */
#define xlink3_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink3 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink3_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink3 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink3_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink3 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink3_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink3 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink3_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink3 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink3_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink3 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink3_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink3 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink3_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink3 xlink_rx: reserved0 (Bit 17)                   */
#define xlink3_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink3 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink3_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink3 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink3_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink3 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink3_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink3 xlink_rx: hold_ro (Bit 0)                      */
#define xlink3_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink3 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink3_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink3 xlink_stat: filter_en (Bit 24)                 */
#define xlink3_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink3 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink3_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink3 xlink_stat: set_wakeup (Bit 23)                */
#define xlink3_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink3 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink3_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink3 xlink_stat: set_txoe (Bit 22)                  */
#define xlink3_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink3 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink3_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink3 xlink_stat: set_tx (Bit 21)                    */
#define xlink3_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink3 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink3_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink3 xlink_stat: io_mode (Bit 20)                   */
#define xlink3_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink3 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink3_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink3 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink3_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink3 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink3_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink3 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink3_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink3 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink3_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink3 xlink_stat: txo_ro (Bit 17)                    */
#define xlink3_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink3 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink3_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink3 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink3_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink3 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink3_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink3 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink3_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink3 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                          xlink4                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink4_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink4 xlink_cfg: end_spl (Bit 28)                    */
#define xlink4_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink4 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink4_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink4 xlink_cfg: start_spl (Bit 24)                  */
#define xlink4_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink4 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink4_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink4 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink4_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink4 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink4_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink4 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink4_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink4 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink4_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink4 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink4_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink4 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink4_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink4 xlink_cfg: fb_en (Bit 17)                      */
#define xlink4_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink4 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink4_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink4 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink4_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink4 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink4_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink4 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink4_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink4 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink4_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink4 xlink_tx: idle_ro (Bit 17)                     */
#define xlink4_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink4 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink4_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink4 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink4_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink4 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink4_xlink_tx_hold_Pos          (0UL)                     /*!< xlink4 xlink_tx: hold (Bit 0)                         */
#define xlink4_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink4 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink4_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink4 xlink_rx: reserved1 (Bit 22)                   */
#define xlink4_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink4 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink4_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink4 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink4_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink4 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink4_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink4 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink4_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink4 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink4_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink4 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink4_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink4 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink4_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink4 xlink_rx: reserved0 (Bit 17)                   */
#define xlink4_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink4 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink4_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink4 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink4_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink4 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink4_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink4 xlink_rx: hold_ro (Bit 0)                      */
#define xlink4_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink4 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink4_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink4 xlink_stat: filter_en (Bit 24)                 */
#define xlink4_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink4 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink4_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink4 xlink_stat: set_wakeup (Bit 23)                */
#define xlink4_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink4 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink4_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink4 xlink_stat: set_txoe (Bit 22)                  */
#define xlink4_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink4 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink4_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink4 xlink_stat: set_tx (Bit 21)                    */
#define xlink4_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink4 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink4_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink4 xlink_stat: io_mode (Bit 20)                   */
#define xlink4_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink4 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink4_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink4 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink4_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink4 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink4_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink4 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink4_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink4 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink4_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink4 xlink_stat: txo_ro (Bit 17)                    */
#define xlink4_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink4 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink4_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink4 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink4_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink4 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink4_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink4 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink4_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink4 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                          xlink5                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink5_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink5 xlink_cfg: end_spl (Bit 28)                    */
#define xlink5_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink5 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink5_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink5 xlink_cfg: start_spl (Bit 24)                  */
#define xlink5_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink5 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink5_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink5 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink5_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink5 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink5_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink5 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink5_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink5 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink5_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink5 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink5_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink5 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink5_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink5 xlink_cfg: fb_en (Bit 17)                      */
#define xlink5_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink5 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink5_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink5 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink5_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink5 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink5_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink5 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink5_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink5 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink5_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink5 xlink_tx: idle_ro (Bit 17)                     */
#define xlink5_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink5 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink5_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink5 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink5_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink5 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink5_xlink_tx_hold_Pos          (0UL)                     /*!< xlink5 xlink_tx: hold (Bit 0)                         */
#define xlink5_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink5 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink5_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink5 xlink_rx: reserved1 (Bit 22)                   */
#define xlink5_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink5 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink5_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink5 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink5_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink5 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink5_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink5 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink5_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink5 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink5_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink5 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink5_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink5 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink5_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink5 xlink_rx: reserved0 (Bit 17)                   */
#define xlink5_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink5 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink5_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink5 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink5_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink5 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink5_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink5 xlink_rx: hold_ro (Bit 0)                      */
#define xlink5_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink5 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink5_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink5 xlink_stat: filter_en (Bit 24)                 */
#define xlink5_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink5 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink5_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink5 xlink_stat: set_wakeup (Bit 23)                */
#define xlink5_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink5 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink5_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink5 xlink_stat: set_txoe (Bit 22)                  */
#define xlink5_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink5 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink5_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink5 xlink_stat: set_tx (Bit 21)                    */
#define xlink5_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink5 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink5_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink5 xlink_stat: io_mode (Bit 20)                   */
#define xlink5_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink5 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink5_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink5 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink5_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink5 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink5_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink5 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink5_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink5 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink5_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink5 xlink_stat: txo_ro (Bit 17)                    */
#define xlink5_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink5 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink5_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink5 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink5_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink5 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink5_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink5 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink5_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink5 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                          xlink6                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink6_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink6 xlink_cfg: end_spl (Bit 28)                    */
#define xlink6_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink6 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink6_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink6 xlink_cfg: start_spl (Bit 24)                  */
#define xlink6_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink6 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink6_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink6 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink6_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink6 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink6_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink6 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink6_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink6 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink6_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink6 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink6_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink6 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink6_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink6 xlink_cfg: fb_en (Bit 17)                      */
#define xlink6_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink6 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink6_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink6 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink6_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink6 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink6_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink6 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink6_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink6 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink6_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink6 xlink_tx: idle_ro (Bit 17)                     */
#define xlink6_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink6 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink6_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink6 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink6_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink6 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink6_xlink_tx_hold_Pos          (0UL)                     /*!< xlink6 xlink_tx: hold (Bit 0)                         */
#define xlink6_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink6 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink6_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink6 xlink_rx: reserved1 (Bit 22)                   */
#define xlink6_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink6 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink6_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink6 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink6_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink6 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink6_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink6 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink6_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink6 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink6_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink6 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink6_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink6 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink6_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink6 xlink_rx: reserved0 (Bit 17)                   */
#define xlink6_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink6 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink6_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink6 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink6_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink6 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink6_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink6 xlink_rx: hold_ro (Bit 0)                      */
#define xlink6_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink6 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink6_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink6 xlink_stat: filter_en (Bit 24)                 */
#define xlink6_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink6 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink6_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink6 xlink_stat: set_wakeup (Bit 23)                */
#define xlink6_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink6 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink6_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink6 xlink_stat: set_txoe (Bit 22)                  */
#define xlink6_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink6 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink6_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink6 xlink_stat: set_tx (Bit 21)                    */
#define xlink6_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink6 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink6_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink6 xlink_stat: io_mode (Bit 20)                   */
#define xlink6_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink6 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink6_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink6 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink6_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink6 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink6_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink6 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink6_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink6 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink6_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink6 xlink_stat: txo_ro (Bit 17)                    */
#define xlink6_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink6 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink6_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink6 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink6_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink6 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink6_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink6 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink6_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink6 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                          xlink7                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  xlink_cfg  ======================================================= */
#define xlink7_xlink_cfg_end_spl_Pos      (28UL)                    /*!< xlink7 xlink_cfg: end_spl (Bit 28)                    */
#define xlink7_xlink_cfg_end_spl_Msk      (0xf0000000UL)            /*!< xlink7 xlink_cfg: end_spl (Bitfield-Mask: 0x0f)       */
#define xlink7_xlink_cfg_start_spl_Pos    (24UL)                    /*!< xlink7 xlink_cfg: start_spl (Bit 24)                  */
#define xlink7_xlink_cfg_start_spl_Msk    (0xf000000UL)             /*!< xlink7 xlink_cfg: start_spl (Bitfield-Mask: 0x0f)     */
#define xlink7_xlink_cfg_bits2rec_Pos     (20UL)                    /*!< xlink7 xlink_cfg: bits2rec (Bit 20)                   */
#define xlink7_xlink_cfg_bits2rec_Msk     (0xf00000UL)              /*!< xlink7 xlink_cfg: bits2rec (Bitfield-Mask: 0x0f)      */
#define xlink7_xlink_cfg_cnt_da_Pos       (19UL)                    /*!< xlink7 xlink_cfg: cnt_da (Bit 19)                     */
#define xlink7_xlink_cfg_cnt_da_Msk       (0x80000UL)               /*!< xlink7 xlink_cfg: cnt_da (Bitfield-Mask: 0x01)        */
#define xlink7_xlink_cfg_bclk2oe_en_Pos   (18UL)                    /*!< xlink7 xlink_cfg: bclk2oe_en (Bit 18)                 */
#define xlink7_xlink_cfg_bclk2oe_en_Msk   (0x40000UL)               /*!< xlink7 xlink_cfg: bclk2oe_en (Bitfield-Mask: 0x01)    */
#define xlink7_xlink_cfg_fb_en_Pos        (17UL)                    /*!< xlink7 xlink_cfg: fb_en (Bit 17)                      */
#define xlink7_xlink_cfg_fb_en_Msk        (0x20000UL)               /*!< xlink7 xlink_cfg: fb_en (Bitfield-Mask: 0x01)         */
#define xlink7_xlink_cfg_xlink_en_Pos     (16UL)                    /*!< xlink7 xlink_cfg: xlink_en (Bit 16)                   */
#define xlink7_xlink_cfg_xlink_en_Msk     (0x10000UL)               /*!< xlink7 xlink_cfg: xlink_en (Bitfield-Mask: 0x01)      */
#define xlink7_xlink_cfg_rate_inc_Pos     (0UL)                     /*!< xlink7 xlink_cfg: rate_inc (Bit 0)                    */
#define xlink7_xlink_cfg_rate_inc_Msk     (0xffffUL)                /*!< xlink7 xlink_cfg: rate_inc (Bitfield-Mask: 0xffff)    */
/* =======================================================  xlink_tx  ======================================================== */
#define xlink7_xlink_tx_idle_ro_Pos       (17UL)                    /*!< xlink7 xlink_tx: idle_ro (Bit 17)                     */
#define xlink7_xlink_tx_idle_ro_Msk       (0x20000UL)               /*!< xlink7 xlink_tx: idle_ro (Bitfield-Mask: 0x01)        */
#define xlink7_xlink_tx_rdy_ro_Pos        (16UL)                    /*!< xlink7 xlink_tx: rdy_ro (Bit 16)                      */
#define xlink7_xlink_tx_rdy_ro_Msk        (0x10000UL)               /*!< xlink7 xlink_tx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink7_xlink_tx_hold_Pos          (0UL)                     /*!< xlink7 xlink_tx: hold (Bit 0)                         */
#define xlink7_xlink_tx_hold_Msk          (0xffffUL)                /*!< xlink7 xlink_tx: hold (Bitfield-Mask: 0xffff)         */
/* =======================================================  xlink_rx  ======================================================== */
#define xlink7_xlink_rx_reserved1_Pos     (22UL)                    /*!< xlink7 xlink_rx: reserved1 (Bit 22)                   */
#define xlink7_xlink_rx_reserved1_Msk     (0xffc00000UL)            /*!< xlink7 xlink_rx: reserved1 (Bitfield-Mask: 0x3ff)     */
#define xlink7_xlink_rx_spl_err_ro_Pos    (21UL)                    /*!< xlink7 xlink_rx: spl_err_ro (Bit 21)                  */
#define xlink7_xlink_rx_spl_err_ro_Msk    (0x200000UL)              /*!< xlink7 xlink_rx: spl_err_ro (Bitfield-Mask: 0x01)     */
#define xlink7_xlink_rx_ovf_err_ro_Pos    (20UL)                    /*!< xlink7 xlink_rx: ovf_err_ro (Bit 20)                  */
#define xlink7_xlink_rx_ovf_err_ro_Msk    (0x100000UL)              /*!< xlink7 xlink_rx: ovf_err_ro (Bitfield-Mask: 0x01)     */
#define xlink7_xlink_rx_rxd_ro_Pos        (19UL)                    /*!< xlink7 xlink_rx: rxd_ro (Bit 19)                      */
#define xlink7_xlink_rx_rxd_ro_Msk        (0x80000UL)               /*!< xlink7 xlink_rx: rxd_ro (Bitfield-Mask: 0x01)         */
#define xlink7_xlink_rx_reserved0_Pos     (17UL)                    /*!< xlink7 xlink_rx: reserved0 (Bit 17)                   */
#define xlink7_xlink_rx_reserved0_Msk     (0x60000UL)               /*!< xlink7 xlink_rx: reserved0 (Bitfield-Mask: 0x03)      */
#define xlink7_xlink_rx_rdy_ro_Pos        (16UL)                    /*!< xlink7 xlink_rx: rdy_ro (Bit 16)                      */
#define xlink7_xlink_rx_rdy_ro_Msk        (0x10000UL)               /*!< xlink7 xlink_rx: rdy_ro (Bitfield-Mask: 0x01)         */
#define xlink7_xlink_rx_hold_ro_Pos       (0UL)                     /*!< xlink7 xlink_rx: hold_ro (Bit 0)                      */
#define xlink7_xlink_rx_hold_ro_Msk       (0xffffUL)                /*!< xlink7 xlink_rx: hold_ro (Bitfield-Mask: 0xffff)      */
/* ======================================================  xlink_stat  ======================================================= */
#define xlink7_xlink_stat_filter_en_Pos   (24UL)                    /*!< xlink7 xlink_stat: filter_en (Bit 24)                 */
#define xlink7_xlink_stat_filter_en_Msk   (0x1000000UL)             /*!< xlink7 xlink_stat: filter_en (Bitfield-Mask: 0x01)    */
#define xlink7_xlink_stat_set_wakeup_Pos  (23UL)                    /*!< xlink7 xlink_stat: set_wakeup (Bit 23)                */
#define xlink7_xlink_stat_set_wakeup_Msk  (0x800000UL)              /*!< xlink7 xlink_stat: set_wakeup (Bitfield-Mask: 0x01)   */
#define xlink7_xlink_stat_set_txoe_Pos    (22UL)                    /*!< xlink7 xlink_stat: set_txoe (Bit 22)                  */
#define xlink7_xlink_stat_set_txoe_Msk    (0x400000UL)              /*!< xlink7 xlink_stat: set_txoe (Bitfield-Mask: 0x01)     */
#define xlink7_xlink_stat_set_tx_Pos      (21UL)                    /*!< xlink7 xlink_stat: set_tx (Bit 21)                    */
#define xlink7_xlink_stat_set_tx_Msk      (0x200000UL)              /*!< xlink7 xlink_stat: set_tx (Bitfield-Mask: 0x01)       */
#define xlink7_xlink_stat_io_mode_Pos     (20UL)                    /*!< xlink7 xlink_stat: io_mode (Bit 20)                   */
#define xlink7_xlink_stat_io_mode_Msk     (0x100000UL)              /*!< xlink7 xlink_stat: io_mode (Bitfield-Mask: 0x01)      */
#define xlink7_xlink_stat_txoe_ro_Pos     (19UL)                    /*!< xlink7 xlink_stat: txoe_ro (Bit 19)                   */
#define xlink7_xlink_stat_txoe_ro_Msk     (0x80000UL)               /*!< xlink7 xlink_stat: txoe_ro (Bitfield-Mask: 0x01)      */
#define xlink7_xlink_stat_rxo_ro_Pos      (18UL)                    /*!< xlink7 xlink_stat: rxo_ro (Bit 18)                    */
#define xlink7_xlink_stat_rxo_ro_Msk      (0x40000UL)               /*!< xlink7 xlink_stat: rxo_ro (Bitfield-Mask: 0x01)       */
#define xlink7_xlink_stat_txo_ro_Pos      (17UL)                    /*!< xlink7 xlink_stat: txo_ro (Bit 17)                    */
#define xlink7_xlink_stat_txo_ro_Msk      (0x20000UL)               /*!< xlink7 xlink_stat: txo_ro (Bitfield-Mask: 0x01)       */
#define xlink7_xlink_stat_bit_clk_ro_Pos  (16UL)                    /*!< xlink7 xlink_stat: bit_clk_ro (Bit 16)                */
#define xlink7_xlink_stat_bit_clk_ro_Msk  (0x10000UL)               /*!< xlink7 xlink_stat: bit_clk_ro (Bitfield-Mask: 0x01)   */
#define xlink7_xlink_stat_bit_cnt_ro_Pos  (0UL)                     /*!< xlink7 xlink_stat: bit_cnt_ro (Bit 0)                 */
#define xlink7_xlink_stat_bit_cnt_ro_Msk  (0xffffUL)                /*!< xlink7 xlink_stat: bit_cnt_ro (Bitfield-Mask: 0xffff) */


/* =========================================================================================================================== */
/* ================                                        io_link_irq                                        ================ */
/* =========================================================================================================================== */

/* ====================================================  io_link_irq_raw  ==================================================== */
#define io_link_irq_io_link_irq_raw_reserved7_Pos (31UL)            /*!< io_link_irq io_link_irq_raw: reserved7 (Bit 31)       */
#define io_link_irq_io_link_irq_raw_reserved7_Msk (0x80000000UL)    /*!< io_link_irq io_link_irq_raw: reserved7 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink7_shift_en_Pos (30UL)      /*!< io_link_irq io_link_irq_raw: xlink7_shift_en (Bit 30) */
#define io_link_irq_io_link_irq_raw_xlink7_shift_en_Msk (0x40000000UL) /*!< io_link_irq io_link_irq_raw: xlink7_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink7_rx_next_Pos (29UL)       /*!< io_link_irq io_link_irq_raw: xlink7_rx_next (Bit 29)  */
#define io_link_irq_io_link_irq_raw_xlink7_rx_next_Msk (0x20000000UL) /*!< io_link_irq io_link_irq_raw: xlink7_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink7_tx_next_Pos (28UL)       /*!< io_link_irq io_link_irq_raw: xlink7_tx_next (Bit 28)  */
#define io_link_irq_io_link_irq_raw_xlink7_tx_next_Msk (0x10000000UL) /*!< io_link_irq io_link_irq_raw: xlink7_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_reserved6_Pos (27UL)            /*!< io_link_irq io_link_irq_raw: reserved6 (Bit 27)       */
#define io_link_irq_io_link_irq_raw_reserved6_Msk (0x8000000UL)     /*!< io_link_irq io_link_irq_raw: reserved6 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink6_shift_en_Pos (26UL)      /*!< io_link_irq io_link_irq_raw: xlink6_shift_en (Bit 26) */
#define io_link_irq_io_link_irq_raw_xlink6_shift_en_Msk (0x4000000UL) /*!< io_link_irq io_link_irq_raw: xlink6_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink6_rx_next_Pos (25UL)       /*!< io_link_irq io_link_irq_raw: xlink6_rx_next (Bit 25)  */
#define io_link_irq_io_link_irq_raw_xlink6_rx_next_Msk (0x2000000UL) /*!< io_link_irq io_link_irq_raw: xlink6_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink6_tx_next_Pos (24UL)       /*!< io_link_irq io_link_irq_raw: xlink6_tx_next (Bit 24)  */
#define io_link_irq_io_link_irq_raw_xlink6_tx_next_Msk (0x1000000UL) /*!< io_link_irq io_link_irq_raw: xlink6_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_reserved5_Pos (23UL)            /*!< io_link_irq io_link_irq_raw: reserved5 (Bit 23)       */
#define io_link_irq_io_link_irq_raw_reserved5_Msk (0x800000UL)      /*!< io_link_irq io_link_irq_raw: reserved5 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink5_shift_en_Pos (22UL)      /*!< io_link_irq io_link_irq_raw: xlink5_shift_en (Bit 22) */
#define io_link_irq_io_link_irq_raw_xlink5_shift_en_Msk (0x400000UL) /*!< io_link_irq io_link_irq_raw: xlink5_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink5_rx_next_Pos (21UL)       /*!< io_link_irq io_link_irq_raw: xlink5_rx_next (Bit 21)  */
#define io_link_irq_io_link_irq_raw_xlink5_rx_next_Msk (0x200000UL) /*!< io_link_irq io_link_irq_raw: xlink5_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink5_tx_next_Pos (20UL)       /*!< io_link_irq io_link_irq_raw: xlink5_tx_next (Bit 20)  */
#define io_link_irq_io_link_irq_raw_xlink5_tx_next_Msk (0x100000UL) /*!< io_link_irq io_link_irq_raw: xlink5_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_reserved4_Pos (19UL)            /*!< io_link_irq io_link_irq_raw: reserved4 (Bit 19)       */
#define io_link_irq_io_link_irq_raw_reserved4_Msk (0x80000UL)       /*!< io_link_irq io_link_irq_raw: reserved4 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink4_shift_en_Pos (18UL)      /*!< io_link_irq io_link_irq_raw: xlink4_shift_en (Bit 18) */
#define io_link_irq_io_link_irq_raw_xlink4_shift_en_Msk (0x40000UL) /*!< io_link_irq io_link_irq_raw: xlink4_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink4_rx_next_Pos (17UL)       /*!< io_link_irq io_link_irq_raw: xlink4_rx_next (Bit 17)  */
#define io_link_irq_io_link_irq_raw_xlink4_rx_next_Msk (0x20000UL)  /*!< io_link_irq io_link_irq_raw: xlink4_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink4_tx_next_Pos (16UL)       /*!< io_link_irq io_link_irq_raw: xlink4_tx_next (Bit 16)  */
#define io_link_irq_io_link_irq_raw_xlink4_tx_next_Msk (0x10000UL)  /*!< io_link_irq io_link_irq_raw: xlink4_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_reserved3_Pos (15UL)            /*!< io_link_irq io_link_irq_raw: reserved3 (Bit 15)       */
#define io_link_irq_io_link_irq_raw_reserved3_Msk (0x8000UL)        /*!< io_link_irq io_link_irq_raw: reserved3 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink3_shift_en_Pos (14UL)      /*!< io_link_irq io_link_irq_raw: xlink3_shift_en (Bit 14) */
#define io_link_irq_io_link_irq_raw_xlink3_shift_en_Msk (0x4000UL)  /*!< io_link_irq io_link_irq_raw: xlink3_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink3_rx_next_Pos (13UL)       /*!< io_link_irq io_link_irq_raw: xlink3_rx_next (Bit 13)  */
#define io_link_irq_io_link_irq_raw_xlink3_rx_next_Msk (0x2000UL)   /*!< io_link_irq io_link_irq_raw: xlink3_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink3_tx_next_Pos (12UL)       /*!< io_link_irq io_link_irq_raw: xlink3_tx_next (Bit 12)  */
#define io_link_irq_io_link_irq_raw_xlink3_tx_next_Msk (0x1000UL)   /*!< io_link_irq io_link_irq_raw: xlink3_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_reserved2_Pos (11UL)            /*!< io_link_irq io_link_irq_raw: reserved2 (Bit 11)       */
#define io_link_irq_io_link_irq_raw_reserved2_Msk (0x800UL)         /*!< io_link_irq io_link_irq_raw: reserved2 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink2_shift_en_Pos (10UL)      /*!< io_link_irq io_link_irq_raw: xlink2_shift_en (Bit 10) */
#define io_link_irq_io_link_irq_raw_xlink2_shift_en_Msk (0x400UL)   /*!< io_link_irq io_link_irq_raw: xlink2_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink2_rx_next_Pos (9UL)        /*!< io_link_irq io_link_irq_raw: xlink2_rx_next (Bit 9)   */
#define io_link_irq_io_link_irq_raw_xlink2_rx_next_Msk (0x200UL)    /*!< io_link_irq io_link_irq_raw: xlink2_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink2_tx_next_Pos (8UL)        /*!< io_link_irq io_link_irq_raw: xlink2_tx_next (Bit 8)   */
#define io_link_irq_io_link_irq_raw_xlink2_tx_next_Msk (0x100UL)    /*!< io_link_irq io_link_irq_raw: xlink2_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_reserved1_Pos (7UL)             /*!< io_link_irq io_link_irq_raw: reserved1 (Bit 7)        */
#define io_link_irq_io_link_irq_raw_reserved1_Msk (0x80UL)          /*!< io_link_irq io_link_irq_raw: reserved1 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink1_shift_en_Pos (6UL)       /*!< io_link_irq io_link_irq_raw: xlink1_shift_en (Bit 6)  */
#define io_link_irq_io_link_irq_raw_xlink1_shift_en_Msk (0x40UL)    /*!< io_link_irq io_link_irq_raw: xlink1_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink1_rx_next_Pos (5UL)        /*!< io_link_irq io_link_irq_raw: xlink1_rx_next (Bit 5)   */
#define io_link_irq_io_link_irq_raw_xlink1_rx_next_Msk (0x20UL)     /*!< io_link_irq io_link_irq_raw: xlink1_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink1_tx_next_Pos (4UL)        /*!< io_link_irq io_link_irq_raw: xlink1_tx_next (Bit 4)   */
#define io_link_irq_io_link_irq_raw_xlink1_tx_next_Msk (0x10UL)     /*!< io_link_irq io_link_irq_raw: xlink1_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_reserved0_Pos (3UL)             /*!< io_link_irq io_link_irq_raw: reserved0 (Bit 3)        */
#define io_link_irq_io_link_irq_raw_reserved0_Msk (0x8UL)           /*!< io_link_irq io_link_irq_raw: reserved0 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink0_shift_en_Pos (2UL)       /*!< io_link_irq io_link_irq_raw: xlink0_shift_en (Bit 2)  */
#define io_link_irq_io_link_irq_raw_xlink0_shift_en_Msk (0x4UL)     /*!< io_link_irq io_link_irq_raw: xlink0_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink0_rx_next_Pos (1UL)        /*!< io_link_irq io_link_irq_raw: xlink0_rx_next (Bit 1)   */
#define io_link_irq_io_link_irq_raw_xlink0_rx_next_Msk (0x2UL)      /*!< io_link_irq io_link_irq_raw: xlink0_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_raw_xlink0_tx_next_Pos (0UL)        /*!< io_link_irq io_link_irq_raw: xlink0_tx_next (Bit 0)   */
#define io_link_irq_io_link_irq_raw_xlink0_tx_next_Msk (0x1UL)      /*!< io_link_irq io_link_irq_raw: xlink0_tx_next (Bitfield-Mask: 0x01) */
/* ==================================================  io_link_irq_masked  =================================================== */
#define io_link_irq_io_link_irq_masked_reserved7_Pos (31UL)         /*!< io_link_irq io_link_irq_masked: reserved7 (Bit 31)    */
#define io_link_irq_io_link_irq_masked_reserved7_Msk (0x80000000UL) /*!< io_link_irq io_link_irq_masked: reserved7 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink7_shift_en_Pos (30UL)   /*!< io_link_irq io_link_irq_masked: xlink7_shift_en (Bit 30) */
#define io_link_irq_io_link_irq_masked_xlink7_shift_en_Msk (0x40000000UL) /*!< io_link_irq io_link_irq_masked: xlink7_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink7_rx_next_Pos (29UL)    /*!< io_link_irq io_link_irq_masked: xlink7_rx_next (Bit 29) */
#define io_link_irq_io_link_irq_masked_xlink7_rx_next_Msk (0x20000000UL) /*!< io_link_irq io_link_irq_masked: xlink7_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink7_tx_next_Pos (28UL)    /*!< io_link_irq io_link_irq_masked: xlink7_tx_next (Bit 28) */
#define io_link_irq_io_link_irq_masked_xlink7_tx_next_Msk (0x10000000UL) /*!< io_link_irq io_link_irq_masked: xlink7_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_reserved6_Pos (27UL)         /*!< io_link_irq io_link_irq_masked: reserved6 (Bit 27)    */
#define io_link_irq_io_link_irq_masked_reserved6_Msk (0x8000000UL)  /*!< io_link_irq io_link_irq_masked: reserved6 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink6_shift_en_Pos (26UL)   /*!< io_link_irq io_link_irq_masked: xlink6_shift_en (Bit 26) */
#define io_link_irq_io_link_irq_masked_xlink6_shift_en_Msk (0x4000000UL) /*!< io_link_irq io_link_irq_masked: xlink6_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink6_rx_next_Pos (25UL)    /*!< io_link_irq io_link_irq_masked: xlink6_rx_next (Bit 25) */
#define io_link_irq_io_link_irq_masked_xlink6_rx_next_Msk (0x2000000UL) /*!< io_link_irq io_link_irq_masked: xlink6_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink6_tx_next_Pos (24UL)    /*!< io_link_irq io_link_irq_masked: xlink6_tx_next (Bit 24) */
#define io_link_irq_io_link_irq_masked_xlink6_tx_next_Msk (0x1000000UL) /*!< io_link_irq io_link_irq_masked: xlink6_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_reserved5_Pos (23UL)         /*!< io_link_irq io_link_irq_masked: reserved5 (Bit 23)    */
#define io_link_irq_io_link_irq_masked_reserved5_Msk (0x800000UL)   /*!< io_link_irq io_link_irq_masked: reserved5 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink5_shift_en_Pos (22UL)   /*!< io_link_irq io_link_irq_masked: xlink5_shift_en (Bit 22) */
#define io_link_irq_io_link_irq_masked_xlink5_shift_en_Msk (0x400000UL) /*!< io_link_irq io_link_irq_masked: xlink5_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink5_rx_next_Pos (21UL)    /*!< io_link_irq io_link_irq_masked: xlink5_rx_next (Bit 21) */
#define io_link_irq_io_link_irq_masked_xlink5_rx_next_Msk (0x200000UL) /*!< io_link_irq io_link_irq_masked: xlink5_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink5_tx_next_Pos (20UL)    /*!< io_link_irq io_link_irq_masked: xlink5_tx_next (Bit 20) */
#define io_link_irq_io_link_irq_masked_xlink5_tx_next_Msk (0x100000UL) /*!< io_link_irq io_link_irq_masked: xlink5_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_reserved4_Pos (19UL)         /*!< io_link_irq io_link_irq_masked: reserved4 (Bit 19)    */
#define io_link_irq_io_link_irq_masked_reserved4_Msk (0x80000UL)    /*!< io_link_irq io_link_irq_masked: reserved4 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink4_shift_en_Pos (18UL)   /*!< io_link_irq io_link_irq_masked: xlink4_shift_en (Bit 18) */
#define io_link_irq_io_link_irq_masked_xlink4_shift_en_Msk (0x40000UL) /*!< io_link_irq io_link_irq_masked: xlink4_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink4_rx_next_Pos (17UL)    /*!< io_link_irq io_link_irq_masked: xlink4_rx_next (Bit 17) */
#define io_link_irq_io_link_irq_masked_xlink4_rx_next_Msk (0x20000UL) /*!< io_link_irq io_link_irq_masked: xlink4_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink4_tx_next_Pos (16UL)    /*!< io_link_irq io_link_irq_masked: xlink4_tx_next (Bit 16) */
#define io_link_irq_io_link_irq_masked_xlink4_tx_next_Msk (0x10000UL) /*!< io_link_irq io_link_irq_masked: xlink4_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_reserved3_Pos (15UL)         /*!< io_link_irq io_link_irq_masked: reserved3 (Bit 15)    */
#define io_link_irq_io_link_irq_masked_reserved3_Msk (0x8000UL)     /*!< io_link_irq io_link_irq_masked: reserved3 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink3_shift_en_Pos (14UL)   /*!< io_link_irq io_link_irq_masked: xlink3_shift_en (Bit 14) */
#define io_link_irq_io_link_irq_masked_xlink3_shift_en_Msk (0x4000UL) /*!< io_link_irq io_link_irq_masked: xlink3_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink3_rx_next_Pos (13UL)    /*!< io_link_irq io_link_irq_masked: xlink3_rx_next (Bit 13) */
#define io_link_irq_io_link_irq_masked_xlink3_rx_next_Msk (0x2000UL) /*!< io_link_irq io_link_irq_masked: xlink3_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink3_tx_next_Pos (12UL)    /*!< io_link_irq io_link_irq_masked: xlink3_tx_next (Bit 12) */
#define io_link_irq_io_link_irq_masked_xlink3_tx_next_Msk (0x1000UL) /*!< io_link_irq io_link_irq_masked: xlink3_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_reserved2_Pos (11UL)         /*!< io_link_irq io_link_irq_masked: reserved2 (Bit 11)    */
#define io_link_irq_io_link_irq_masked_reserved2_Msk (0x800UL)      /*!< io_link_irq io_link_irq_masked: reserved2 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink2_shift_en_Pos (10UL)   /*!< io_link_irq io_link_irq_masked: xlink2_shift_en (Bit 10) */
#define io_link_irq_io_link_irq_masked_xlink2_shift_en_Msk (0x400UL) /*!< io_link_irq io_link_irq_masked: xlink2_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink2_rx_next_Pos (9UL)     /*!< io_link_irq io_link_irq_masked: xlink2_rx_next (Bit 9) */
#define io_link_irq_io_link_irq_masked_xlink2_rx_next_Msk (0x200UL) /*!< io_link_irq io_link_irq_masked: xlink2_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink2_tx_next_Pos (8UL)     /*!< io_link_irq io_link_irq_masked: xlink2_tx_next (Bit 8) */
#define io_link_irq_io_link_irq_masked_xlink2_tx_next_Msk (0x100UL) /*!< io_link_irq io_link_irq_masked: xlink2_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_reserved1_Pos (7UL)          /*!< io_link_irq io_link_irq_masked: reserved1 (Bit 7)     */
#define io_link_irq_io_link_irq_masked_reserved1_Msk (0x80UL)       /*!< io_link_irq io_link_irq_masked: reserved1 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink1_shift_en_Pos (6UL)    /*!< io_link_irq io_link_irq_masked: xlink1_shift_en (Bit 6) */
#define io_link_irq_io_link_irq_masked_xlink1_shift_en_Msk (0x40UL) /*!< io_link_irq io_link_irq_masked: xlink1_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink1_rx_next_Pos (5UL)     /*!< io_link_irq io_link_irq_masked: xlink1_rx_next (Bit 5) */
#define io_link_irq_io_link_irq_masked_xlink1_rx_next_Msk (0x20UL)  /*!< io_link_irq io_link_irq_masked: xlink1_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink1_tx_next_Pos (4UL)     /*!< io_link_irq io_link_irq_masked: xlink1_tx_next (Bit 4) */
#define io_link_irq_io_link_irq_masked_xlink1_tx_next_Msk (0x10UL)  /*!< io_link_irq io_link_irq_masked: xlink1_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_reserved0_Pos (3UL)          /*!< io_link_irq io_link_irq_masked: reserved0 (Bit 3)     */
#define io_link_irq_io_link_irq_masked_reserved0_Msk (0x8UL)        /*!< io_link_irq io_link_irq_masked: reserved0 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink0_shift_en_Pos (2UL)    /*!< io_link_irq io_link_irq_masked: xlink0_shift_en (Bit 2) */
#define io_link_irq_io_link_irq_masked_xlink0_shift_en_Msk (0x4UL)  /*!< io_link_irq io_link_irq_masked: xlink0_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink0_rx_next_Pos (1UL)     /*!< io_link_irq io_link_irq_masked: xlink0_rx_next (Bit 1) */
#define io_link_irq_io_link_irq_masked_xlink0_rx_next_Msk (0x2UL)   /*!< io_link_irq io_link_irq_masked: xlink0_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_masked_xlink0_tx_next_Pos (0UL)     /*!< io_link_irq io_link_irq_masked: xlink0_tx_next (Bit 0) */
#define io_link_irq_io_link_irq_masked_xlink0_tx_next_Msk (0x1UL)   /*!< io_link_irq io_link_irq_masked: xlink0_tx_next (Bitfield-Mask: 0x01) */
/* ==================================================  io_link_irq_msk_set  ================================================== */
#define io_link_irq_io_link_irq_msk_set_reserved7_Pos (31UL)        /*!< io_link_irq io_link_irq_msk_set: reserved7 (Bit 31)   */
#define io_link_irq_io_link_irq_msk_set_reserved7_Msk (0x80000000UL) /*!< io_link_irq io_link_irq_msk_set: reserved7 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink7_shift_en_Pos (30UL)  /*!< io_link_irq io_link_irq_msk_set: xlink7_shift_en (Bit 30) */
#define io_link_irq_io_link_irq_msk_set_xlink7_shift_en_Msk (0x40000000UL) /*!< io_link_irq io_link_irq_msk_set: xlink7_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink7_rx_next_Pos (29UL)   /*!< io_link_irq io_link_irq_msk_set: xlink7_rx_next (Bit 29) */
#define io_link_irq_io_link_irq_msk_set_xlink7_rx_next_Msk (0x20000000UL) /*!< io_link_irq io_link_irq_msk_set: xlink7_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink7_tx_next_Pos (28UL)   /*!< io_link_irq io_link_irq_msk_set: xlink7_tx_next (Bit 28) */
#define io_link_irq_io_link_irq_msk_set_xlink7_tx_next_Msk (0x10000000UL) /*!< io_link_irq io_link_irq_msk_set: xlink7_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_reserved6_Pos (27UL)        /*!< io_link_irq io_link_irq_msk_set: reserved6 (Bit 27)   */
#define io_link_irq_io_link_irq_msk_set_reserved6_Msk (0x8000000UL) /*!< io_link_irq io_link_irq_msk_set: reserved6 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink6_shift_en_Pos (26UL)  /*!< io_link_irq io_link_irq_msk_set: xlink6_shift_en (Bit 26) */
#define io_link_irq_io_link_irq_msk_set_xlink6_shift_en_Msk (0x4000000UL) /*!< io_link_irq io_link_irq_msk_set: xlink6_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink6_rx_next_Pos (25UL)   /*!< io_link_irq io_link_irq_msk_set: xlink6_rx_next (Bit 25) */
#define io_link_irq_io_link_irq_msk_set_xlink6_rx_next_Msk (0x2000000UL) /*!< io_link_irq io_link_irq_msk_set: xlink6_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink6_tx_next_Pos (24UL)   /*!< io_link_irq io_link_irq_msk_set: xlink6_tx_next (Bit 24) */
#define io_link_irq_io_link_irq_msk_set_xlink6_tx_next_Msk (0x1000000UL) /*!< io_link_irq io_link_irq_msk_set: xlink6_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_reserved5_Pos (23UL)        /*!< io_link_irq io_link_irq_msk_set: reserved5 (Bit 23)   */
#define io_link_irq_io_link_irq_msk_set_reserved5_Msk (0x800000UL)  /*!< io_link_irq io_link_irq_msk_set: reserved5 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink5_shift_en_Pos (22UL)  /*!< io_link_irq io_link_irq_msk_set: xlink5_shift_en (Bit 22) */
#define io_link_irq_io_link_irq_msk_set_xlink5_shift_en_Msk (0x400000UL) /*!< io_link_irq io_link_irq_msk_set: xlink5_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink5_rx_next_Pos (21UL)   /*!< io_link_irq io_link_irq_msk_set: xlink5_rx_next (Bit 21) */
#define io_link_irq_io_link_irq_msk_set_xlink5_rx_next_Msk (0x200000UL) /*!< io_link_irq io_link_irq_msk_set: xlink5_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink5_tx_next_Pos (20UL)   /*!< io_link_irq io_link_irq_msk_set: xlink5_tx_next (Bit 20) */
#define io_link_irq_io_link_irq_msk_set_xlink5_tx_next_Msk (0x100000UL) /*!< io_link_irq io_link_irq_msk_set: xlink5_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_reserved4_Pos (19UL)        /*!< io_link_irq io_link_irq_msk_set: reserved4 (Bit 19)   */
#define io_link_irq_io_link_irq_msk_set_reserved4_Msk (0x80000UL)   /*!< io_link_irq io_link_irq_msk_set: reserved4 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink4_shift_en_Pos (18UL)  /*!< io_link_irq io_link_irq_msk_set: xlink4_shift_en (Bit 18) */
#define io_link_irq_io_link_irq_msk_set_xlink4_shift_en_Msk (0x40000UL) /*!< io_link_irq io_link_irq_msk_set: xlink4_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink4_rx_next_Pos (17UL)   /*!< io_link_irq io_link_irq_msk_set: xlink4_rx_next (Bit 17) */
#define io_link_irq_io_link_irq_msk_set_xlink4_rx_next_Msk (0x20000UL) /*!< io_link_irq io_link_irq_msk_set: xlink4_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink4_tx_next_Pos (16UL)   /*!< io_link_irq io_link_irq_msk_set: xlink4_tx_next (Bit 16) */
#define io_link_irq_io_link_irq_msk_set_xlink4_tx_next_Msk (0x10000UL) /*!< io_link_irq io_link_irq_msk_set: xlink4_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_reserved3_Pos (15UL)        /*!< io_link_irq io_link_irq_msk_set: reserved3 (Bit 15)   */
#define io_link_irq_io_link_irq_msk_set_reserved3_Msk (0x8000UL)    /*!< io_link_irq io_link_irq_msk_set: reserved3 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink3_shift_en_Pos (14UL)  /*!< io_link_irq io_link_irq_msk_set: xlink3_shift_en (Bit 14) */
#define io_link_irq_io_link_irq_msk_set_xlink3_shift_en_Msk (0x4000UL) /*!< io_link_irq io_link_irq_msk_set: xlink3_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink3_rx_next_Pos (13UL)   /*!< io_link_irq io_link_irq_msk_set: xlink3_rx_next (Bit 13) */
#define io_link_irq_io_link_irq_msk_set_xlink3_rx_next_Msk (0x2000UL) /*!< io_link_irq io_link_irq_msk_set: xlink3_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink3_tx_next_Pos (12UL)   /*!< io_link_irq io_link_irq_msk_set: xlink3_tx_next (Bit 12) */
#define io_link_irq_io_link_irq_msk_set_xlink3_tx_next_Msk (0x1000UL) /*!< io_link_irq io_link_irq_msk_set: xlink3_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_reserved2_Pos (11UL)        /*!< io_link_irq io_link_irq_msk_set: reserved2 (Bit 11)   */
#define io_link_irq_io_link_irq_msk_set_reserved2_Msk (0x800UL)     /*!< io_link_irq io_link_irq_msk_set: reserved2 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink2_shift_en_Pos (10UL)  /*!< io_link_irq io_link_irq_msk_set: xlink2_shift_en (Bit 10) */
#define io_link_irq_io_link_irq_msk_set_xlink2_shift_en_Msk (0x400UL) /*!< io_link_irq io_link_irq_msk_set: xlink2_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink2_rx_next_Pos (9UL)    /*!< io_link_irq io_link_irq_msk_set: xlink2_rx_next (Bit 9) */
#define io_link_irq_io_link_irq_msk_set_xlink2_rx_next_Msk (0x200UL) /*!< io_link_irq io_link_irq_msk_set: xlink2_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink2_tx_next_Pos (8UL)    /*!< io_link_irq io_link_irq_msk_set: xlink2_tx_next (Bit 8) */
#define io_link_irq_io_link_irq_msk_set_xlink2_tx_next_Msk (0x100UL) /*!< io_link_irq io_link_irq_msk_set: xlink2_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_reserved1_Pos (7UL)         /*!< io_link_irq io_link_irq_msk_set: reserved1 (Bit 7)    */
#define io_link_irq_io_link_irq_msk_set_reserved1_Msk (0x80UL)      /*!< io_link_irq io_link_irq_msk_set: reserved1 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink1_shift_en_Pos (6UL)   /*!< io_link_irq io_link_irq_msk_set: xlink1_shift_en (Bit 6) */
#define io_link_irq_io_link_irq_msk_set_xlink1_shift_en_Msk (0x40UL) /*!< io_link_irq io_link_irq_msk_set: xlink1_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink1_rx_next_Pos (5UL)    /*!< io_link_irq io_link_irq_msk_set: xlink1_rx_next (Bit 5) */
#define io_link_irq_io_link_irq_msk_set_xlink1_rx_next_Msk (0x20UL) /*!< io_link_irq io_link_irq_msk_set: xlink1_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink1_tx_next_Pos (4UL)    /*!< io_link_irq io_link_irq_msk_set: xlink1_tx_next (Bit 4) */
#define io_link_irq_io_link_irq_msk_set_xlink1_tx_next_Msk (0x10UL) /*!< io_link_irq io_link_irq_msk_set: xlink1_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_reserved0_Pos (3UL)         /*!< io_link_irq io_link_irq_msk_set: reserved0 (Bit 3)    */
#define io_link_irq_io_link_irq_msk_set_reserved0_Msk (0x8UL)       /*!< io_link_irq io_link_irq_msk_set: reserved0 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink0_shift_en_Pos (2UL)   /*!< io_link_irq io_link_irq_msk_set: xlink0_shift_en (Bit 2) */
#define io_link_irq_io_link_irq_msk_set_xlink0_shift_en_Msk (0x4UL) /*!< io_link_irq io_link_irq_msk_set: xlink0_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink0_rx_next_Pos (1UL)    /*!< io_link_irq io_link_irq_msk_set: xlink0_rx_next (Bit 1) */
#define io_link_irq_io_link_irq_msk_set_xlink0_rx_next_Msk (0x2UL)  /*!< io_link_irq io_link_irq_msk_set: xlink0_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_set_xlink0_tx_next_Pos (0UL)    /*!< io_link_irq io_link_irq_msk_set: xlink0_tx_next (Bit 0) */
#define io_link_irq_io_link_irq_msk_set_xlink0_tx_next_Msk (0x1UL)  /*!< io_link_irq io_link_irq_msk_set: xlink0_tx_next (Bitfield-Mask: 0x01) */
/* =================================================  io_link_irq_msk_reset  ================================================= */
#define io_link_irq_io_link_irq_msk_reset_reserved7_Pos (31UL)      /*!< io_link_irq io_link_irq_msk_reset: reserved7 (Bit 31) */
#define io_link_irq_io_link_irq_msk_reset_reserved7_Msk (0x80000000UL) /*!< io_link_irq io_link_irq_msk_reset: reserved7 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink7_shift_en_Pos (30UL) /*!< io_link_irq io_link_irq_msk_reset: xlink7_shift_en (Bit 30) */
#define io_link_irq_io_link_irq_msk_reset_xlink7_shift_en_Msk (0x40000000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink7_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink7_rx_next_Pos (29UL) /*!< io_link_irq io_link_irq_msk_reset: xlink7_rx_next (Bit 29) */
#define io_link_irq_io_link_irq_msk_reset_xlink7_rx_next_Msk (0x20000000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink7_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink7_tx_next_Pos (28UL) /*!< io_link_irq io_link_irq_msk_reset: xlink7_tx_next (Bit 28) */
#define io_link_irq_io_link_irq_msk_reset_xlink7_tx_next_Msk (0x10000000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink7_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_reserved6_Pos (27UL)      /*!< io_link_irq io_link_irq_msk_reset: reserved6 (Bit 27) */
#define io_link_irq_io_link_irq_msk_reset_reserved6_Msk (0x8000000UL) /*!< io_link_irq io_link_irq_msk_reset: reserved6 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink6_shift_en_Pos (26UL) /*!< io_link_irq io_link_irq_msk_reset: xlink6_shift_en (Bit 26) */
#define io_link_irq_io_link_irq_msk_reset_xlink6_shift_en_Msk (0x4000000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink6_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink6_rx_next_Pos (25UL) /*!< io_link_irq io_link_irq_msk_reset: xlink6_rx_next (Bit 25) */
#define io_link_irq_io_link_irq_msk_reset_xlink6_rx_next_Msk (0x2000000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink6_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink6_tx_next_Pos (24UL) /*!< io_link_irq io_link_irq_msk_reset: xlink6_tx_next (Bit 24) */
#define io_link_irq_io_link_irq_msk_reset_xlink6_tx_next_Msk (0x1000000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink6_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_reserved5_Pos (23UL)      /*!< io_link_irq io_link_irq_msk_reset: reserved5 (Bit 23) */
#define io_link_irq_io_link_irq_msk_reset_reserved5_Msk (0x800000UL) /*!< io_link_irq io_link_irq_msk_reset: reserved5 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink5_shift_en_Pos (22UL) /*!< io_link_irq io_link_irq_msk_reset: xlink5_shift_en (Bit 22) */
#define io_link_irq_io_link_irq_msk_reset_xlink5_shift_en_Msk (0x400000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink5_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink5_rx_next_Pos (21UL) /*!< io_link_irq io_link_irq_msk_reset: xlink5_rx_next (Bit 21) */
#define io_link_irq_io_link_irq_msk_reset_xlink5_rx_next_Msk (0x200000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink5_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink5_tx_next_Pos (20UL) /*!< io_link_irq io_link_irq_msk_reset: xlink5_tx_next (Bit 20) */
#define io_link_irq_io_link_irq_msk_reset_xlink5_tx_next_Msk (0x100000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink5_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_reserved4_Pos (19UL)      /*!< io_link_irq io_link_irq_msk_reset: reserved4 (Bit 19) */
#define io_link_irq_io_link_irq_msk_reset_reserved4_Msk (0x80000UL) /*!< io_link_irq io_link_irq_msk_reset: reserved4 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink4_shift_en_Pos (18UL) /*!< io_link_irq io_link_irq_msk_reset: xlink4_shift_en (Bit 18) */
#define io_link_irq_io_link_irq_msk_reset_xlink4_shift_en_Msk (0x40000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink4_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink4_rx_next_Pos (17UL) /*!< io_link_irq io_link_irq_msk_reset: xlink4_rx_next (Bit 17) */
#define io_link_irq_io_link_irq_msk_reset_xlink4_rx_next_Msk (0x20000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink4_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink4_tx_next_Pos (16UL) /*!< io_link_irq io_link_irq_msk_reset: xlink4_tx_next (Bit 16) */
#define io_link_irq_io_link_irq_msk_reset_xlink4_tx_next_Msk (0x10000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink4_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_reserved3_Pos (15UL)      /*!< io_link_irq io_link_irq_msk_reset: reserved3 (Bit 15) */
#define io_link_irq_io_link_irq_msk_reset_reserved3_Msk (0x8000UL)  /*!< io_link_irq io_link_irq_msk_reset: reserved3 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink3_shift_en_Pos (14UL) /*!< io_link_irq io_link_irq_msk_reset: xlink3_shift_en (Bit 14) */
#define io_link_irq_io_link_irq_msk_reset_xlink3_shift_en_Msk (0x4000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink3_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink3_rx_next_Pos (13UL) /*!< io_link_irq io_link_irq_msk_reset: xlink3_rx_next (Bit 13) */
#define io_link_irq_io_link_irq_msk_reset_xlink3_rx_next_Msk (0x2000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink3_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink3_tx_next_Pos (12UL) /*!< io_link_irq io_link_irq_msk_reset: xlink3_tx_next (Bit 12) */
#define io_link_irq_io_link_irq_msk_reset_xlink3_tx_next_Msk (0x1000UL) /*!< io_link_irq io_link_irq_msk_reset: xlink3_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_reserved2_Pos (11UL)      /*!< io_link_irq io_link_irq_msk_reset: reserved2 (Bit 11) */
#define io_link_irq_io_link_irq_msk_reset_reserved2_Msk (0x800UL)   /*!< io_link_irq io_link_irq_msk_reset: reserved2 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink2_shift_en_Pos (10UL) /*!< io_link_irq io_link_irq_msk_reset: xlink2_shift_en (Bit 10) */
#define io_link_irq_io_link_irq_msk_reset_xlink2_shift_en_Msk (0x400UL) /*!< io_link_irq io_link_irq_msk_reset: xlink2_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink2_rx_next_Pos (9UL)  /*!< io_link_irq io_link_irq_msk_reset: xlink2_rx_next (Bit 9) */
#define io_link_irq_io_link_irq_msk_reset_xlink2_rx_next_Msk (0x200UL) /*!< io_link_irq io_link_irq_msk_reset: xlink2_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink2_tx_next_Pos (8UL)  /*!< io_link_irq io_link_irq_msk_reset: xlink2_tx_next (Bit 8) */
#define io_link_irq_io_link_irq_msk_reset_xlink2_tx_next_Msk (0x100UL) /*!< io_link_irq io_link_irq_msk_reset: xlink2_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_reserved1_Pos (7UL)       /*!< io_link_irq io_link_irq_msk_reset: reserved1 (Bit 7)  */
#define io_link_irq_io_link_irq_msk_reset_reserved1_Msk (0x80UL)    /*!< io_link_irq io_link_irq_msk_reset: reserved1 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink1_shift_en_Pos (6UL) /*!< io_link_irq io_link_irq_msk_reset: xlink1_shift_en (Bit 6) */
#define io_link_irq_io_link_irq_msk_reset_xlink1_shift_en_Msk (0x40UL) /*!< io_link_irq io_link_irq_msk_reset: xlink1_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink1_rx_next_Pos (5UL)  /*!< io_link_irq io_link_irq_msk_reset: xlink1_rx_next (Bit 5) */
#define io_link_irq_io_link_irq_msk_reset_xlink1_rx_next_Msk (0x20UL) /*!< io_link_irq io_link_irq_msk_reset: xlink1_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink1_tx_next_Pos (4UL)  /*!< io_link_irq io_link_irq_msk_reset: xlink1_tx_next (Bit 4) */
#define io_link_irq_io_link_irq_msk_reset_xlink1_tx_next_Msk (0x10UL) /*!< io_link_irq io_link_irq_msk_reset: xlink1_tx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_reserved0_Pos (3UL)       /*!< io_link_irq io_link_irq_msk_reset: reserved0 (Bit 3)  */
#define io_link_irq_io_link_irq_msk_reset_reserved0_Msk (0x8UL)     /*!< io_link_irq io_link_irq_msk_reset: reserved0 (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink0_shift_en_Pos (2UL) /*!< io_link_irq io_link_irq_msk_reset: xlink0_shift_en (Bit 2) */
#define io_link_irq_io_link_irq_msk_reset_xlink0_shift_en_Msk (0x4UL) /*!< io_link_irq io_link_irq_msk_reset: xlink0_shift_en (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink0_rx_next_Pos (1UL)  /*!< io_link_irq io_link_irq_msk_reset: xlink0_rx_next (Bit 1) */
#define io_link_irq_io_link_irq_msk_reset_xlink0_rx_next_Msk (0x2UL) /*!< io_link_irq io_link_irq_msk_reset: xlink0_rx_next (Bitfield-Mask: 0x01) */
#define io_link_irq_io_link_irq_msk_reset_xlink0_tx_next_Pos (0UL)  /*!< io_link_irq io_link_irq_msk_reset: xlink0_tx_next (Bit 0) */
#define io_link_irq_io_link_irq_msk_reset_xlink0_tx_next_Msk (0x1UL) /*!< io_link_irq io_link_irq_msk_reset: xlink0_tx_next (Bitfield-Mask: 0x01) */

/** @} */ /* End of group PosMask_peripherals */


/*lint -restore */

#ifdef __cplusplus
}
#endif

#endif /* NETX90_MPW_APP_H */

/** @} */ /* End of group netx90_mpw_app */

/** @} */ /* End of group  */
