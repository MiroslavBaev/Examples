/*********************************************************************/
/* Based on verilog file from: 180609_0830 */
/* SVN Revision: $Rev: 945 $        Release-1.3.0.0 */ 
/* from regdef.v by regdef2h auto-generated C-header file            */
/* please see the regdef.html file for detailed register description */
/*********************************************************************/

#ifndef __regdef_netx90_MPW_arm_app_h__
#define __regdef_netx90_MPW_arm_app_h__

#include <stdint.h>

/* ===================================================================== */

/* Area of intflash2_mirror_app_boot */

/* ===================================================================== */

#define Addr_NX90_intflash2_mirror_app_boot 0x00000000U

/* ===================================================================== */

/* AREA intram6 */
/* Area of intram6, intram6_mirror_sram, intram6_mirror_ocp */

/* ===================================================================== */

#define Addr_NX90_intram6             0x000B0000U
#define Addr_NX90_intram6_mirror_sram 0x200B0000U
#define Addr_NX90_intram6_mirror_ocp  0x400B0000U

/* --------------------------------------------------------------------- */
/* Register intram6_base */
/* => internal SRAM AHBL slave 6 start address */
/*    Area size: 32kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*     */
/*    Note: For byte- or 16-bit-write-access a read-modify-write is performed */
/*       to update the 32bit ECC. This is normally done in background without */
/*       performance penalty. However sometimes a wait-state could occur for this. */
/*       The 64kB XC memories (INTRAM3 and 4) never produce wait-states. They */
/*       have a 8-bit ECC which avoids read-modify-write. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intram6_base                 0x00000000U
#define Adr_NX90_intram6_intram6_base             0x000B0000U
#define Adr_NX90_intram6_mirror_sram_intram6_base 0x200B0000U
#define Adr_NX90_intram6_mirror_ocp_intram6_base  0x400B0000U

/* --------------------------------------------------------------------- */
/* Register intram6_end */
/* => internal SRAM AHBL slave 6 end address */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intram6_end                 0x00007FFCU
#define Adr_NX90_intram6_intram6_end             0x000B7FFCU
#define Adr_NX90_intram6_mirror_sram_intram6_end 0x200B7FFCU
#define Adr_NX90_intram6_mirror_ocp_intram6_end  0x400B7FFCU


/* ===================================================================== */

/* AREA intram7 */
/* Area of intram7, intram7_mirror_sram, intram7_mirror_ocp */

/* ===================================================================== */

#define Addr_NX90_intram7             0x000B8000U
#define Addr_NX90_intram7_mirror_sram 0x200B8000U
#define Addr_NX90_intram7_mirror_ocp  0x400B8000U

/* --------------------------------------------------------------------- */
/* Register intram7_base */
/* => internal SRAM AHBL slave 7 start address */
/*    Area size: 32kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*     */
/*    Note: For byte- or 16-bit-write-access a read-modify-write is performed */
/*       to update the 32bit ECC. This is normally done in background without */
/*       performance penalty. However sometimes a wait-state could occur for this. */
/*       The 64kB XC memories (INTRAM3 and 4) never produce wait-states. They */
/*       have a 8-bit ECC which avoids read-modify-write. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intram7_base                 0x00000000U
#define Adr_NX90_intram7_intram7_base             0x000B8000U
#define Adr_NX90_intram7_mirror_sram_intram7_base 0x200B8000U
#define Adr_NX90_intram7_mirror_ocp_intram7_base  0x400B8000U

/* --------------------------------------------------------------------- */
/* Register intram7_end */
/* => internal SRAM AHBL slave 7 end address */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intram7_end                 0x00007FFCU
#define Adr_NX90_intram7_intram7_end             0x000BFFFCU
#define Adr_NX90_intram7_mirror_sram_intram7_end 0x200BFFFCU
#define Adr_NX90_intram7_mirror_ocp_intram7_end  0x400BFFFCU


/* ===================================================================== */

/* Area of intflash2 */

/* ===================================================================== */

#define Addr_NX90_intflash2 0x00200000U

/* ===================================================================== */

/* Area of sdram */

/* ===================================================================== */

#define Addr_NX90_sdram 0x10000000U

/* --------------------------------------------------------------------- */
/* Register sdram_base */
/* => external SDRAM chip-select start address */
/*    Area size: 256MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sdram_base   0x00000000U
#define Adr_NX90_sdram_sdram_base 0x10000000U
#define Adr_NX90_sdram_base       0x10000000U

/* --------------------------------------------------------------------- */
/* Register sdram_end */
/* => external SDRAM chip-select end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sdram_end   0x0FFFFFFCU
#define Adr_NX90_sdram_sdram_end 0x1FFFFFFCU
#define Adr_NX90_sdram_end       0x1FFFFFFCU


/* ===================================================================== */

/* Area of sqirom */

/* ===================================================================== */

#define Addr_NX90_sqirom 0x64000000U

/* ===================================================================== */

/* Area of extsram */

/* ===================================================================== */

#define Addr_NX90_extsram 0x68000000U

/* --------------------------------------------------------------------- */
/* Register cs0_base */
/* => external SRAM/Flash/NVRAM,... chip-select 0 start address */
/*    Area size: 32MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs0_base     0x00000000U
#define Adr_NX90_extsram_cs0_base 0x68000000U
#define Adr_NX90_cs0_base         0x68000000U

/* --------------------------------------------------------------------- */
/* Register cs0_end */
/* => external SRAM/Flash/NVRAM,... chip-select 0 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs0_end     0x01FFFFFCU
#define Adr_NX90_extsram_cs0_end 0x69FFFFFCU
#define Adr_NX90_cs0_end         0x69FFFFFCU

/* --------------------------------------------------------------------- */
/* Register cs1_base */
/* => external SRAM/Flash/NVRAM,... chip-select 1 start address */
/*    Area size: 32MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs1_base     0x02000000U
#define Adr_NX90_extsram_cs1_base 0x6A000000U
#define Adr_NX90_cs1_base         0x6A000000U

/* --------------------------------------------------------------------- */
/* Register cs1_end */
/* => external SRAM/Flash/NVRAM,... chip-select 1 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs1_end     0x03FFFFFCU
#define Adr_NX90_extsram_cs1_end 0x6BFFFFFCU
#define Adr_NX90_cs1_end         0x6BFFFFFCU

/* --------------------------------------------------------------------- */
/* Register cs2_base */
/* => external SRAM/Flash/NVRAM,... chip-select 2 start address */
/*    Area size: 32MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs2_base     0x04000000U
#define Adr_NX90_extsram_cs2_base 0x6C000000U
#define Adr_NX90_cs2_base         0x6C000000U

/* --------------------------------------------------------------------- */
/* Register cs2_end */
/* => external SRAM/Flash/NVRAM,... chip-select 2 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs2_end     0x05FFFFFCU
#define Adr_NX90_extsram_cs2_end 0x6DFFFFFCU
#define Adr_NX90_cs2_end         0x6DFFFFFCU

/* --------------------------------------------------------------------- */
/* Register cs3_base */
/* => external SRAM/Flash/NVRAM,... chip-select 3 start address */
/*    Area size: 32MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs3_base     0x06000000U
#define Adr_NX90_extsram_cs3_base 0x6E000000U
#define Adr_NX90_cs3_base         0x6E000000U

/* --------------------------------------------------------------------- */
/* Register cs3_end */
/* => external SRAM/Flash/NVRAM,... chip-select 3 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cs3_end     0x07FFFFFCU
#define Adr_NX90_extsram_cs3_end 0x6FFFFFFCU
#define Adr_NX90_cs3_end         0x6FFFFFFCU


/* ===================================================================== */

/* Area of idpm_slave */

/* ===================================================================== */

#define Addr_NX90_idpm_slave 0x70000000U

/* ===================================================================== */

/* Area of sqirom_mirror_ext_peri */

/* ===================================================================== */

#define Addr_NX90_sqirom_mirror_ext_peri 0xA4000000U

/* ===================================================================== */

/* Area of extsram_mirror_ext_peri */

/* ===================================================================== */

#define Addr_NX90_extsram_mirror_ext_peri 0xA8000000U

/* ===================================================================== */

/* Area of idpm_slave_mirror_ext_peri */

/* ===================================================================== */

#define Addr_NX90_idpm_slave_mirror_ext_peri 0xB0000000U

/* ===================================================================== */

/* Area of cm4_private_peripherals */

/* ===================================================================== */

#define Addr_NX90_cm4_private_peripherals 0xE0000000U

/* ===================================================================== */

/* Area of cm4_itm */

/* ===================================================================== */

#define Addr_NX90_cm4_itm 0xE0000000U

/* ===================================================================== */

/* Area of cm4_dwt */

/* ===================================================================== */

#define Addr_NX90_cm4_dwt 0xE0001000U

/* ===================================================================== */

/* Area of cm4_fpb */

/* ===================================================================== */

#define Addr_NX90_cm4_fpb 0xE0002000U

/* ===================================================================== */

/* Area of cm4_scs */

/* ===================================================================== */

#define Addr_NX90_cm4_scs 0xE000E000U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_actlr */
/* => Auxiliary control register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_actlr     0x00000008U
#define Adr_NX90_cm4_scs_cm4_scs_actlr 0xE000E008U
#define Adr_NX90_cm4_scs_actlr         0xE000E008U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_stcsr */
/* => SysTick control and status register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_stcsr     0x00000010U
#define Adr_NX90_cm4_scs_cm4_scs_stcsr 0xE000E010U
#define Adr_NX90_cm4_scs_stcsr         0xE000E010U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_strvr */
/* => SysTick Reload Value register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_strvr     0x00000014U
#define Adr_NX90_cm4_scs_cm4_scs_strvr 0xE000E014U
#define Adr_NX90_cm4_scs_strvr         0xE000E014U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_stcvr */
/* => SysTick current value register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_stcvr     0x00000018U
#define Adr_NX90_cm4_scs_cm4_scs_stcvr 0xE000E018U
#define Adr_NX90_cm4_scs_stcvr         0xE000E018U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_stcr */
/* => SysTick calibration value register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_stcr     0x0000001CU
#define Adr_NX90_cm4_scs_cm4_scs_stcr 0xE000E01CU
#define Adr_NX90_cm4_scs_stcr         0xE000E01CU

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_iser0 */
/* => Interrupt set-enable register 0 */
/*    Enables, or reads the enable state of a group of interrupts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_iser0     0x00000100U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_iser0 0xE000E100U
#define Adr_NX90_cm4_scs_nvic_iser0         0xE000E100U
#define DFLT_VAL_NX90_cm4_scs_nvic_iser0    0x00000000U

#define MSK_NX90_cm4_scs_nvic_iser0_setena         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_iser0_setena         0
#define DFLT_VAL_NX90_cm4_scs_nvic_iser0_setena    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_iser0_setena 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_iser0': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_iser0 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_iser0_setena = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ISER0_BIT_Ttag {
  unsigned int setena : BFW_NX90_cm4_scs_nvic_iser0_setena; /* For register cm4_scs_nvic_iser[n], enables or shows the current  */
                                                            /* enabled state of interrupt (m+(32*n)):                           */
                                                            /* 0: On reads, interrupt disabled. On writes, no effect.           */
                                                            /* 1: On reads, interrupt enabled. On writes, enable interrupt.     */
                                                            /* Software can enable multiple interrupts in a single write to     */
                                                            /* cm4_scs_nvic_iser[n].                                            */
} NX90_CM4_SCS_NVIC_ISER0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ISER0_BIT_T bf;
} NX90_CM4_SCS_NVIC_ISER0_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_iser1 */
/* => Interrupt set-enable register 1 */
/*    Enables, or reads the enable state of a group of interrupts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_iser1     0x00000104U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_iser1 0xE000E104U
#define Adr_NX90_cm4_scs_nvic_iser1         0xE000E104U
#define DFLT_VAL_NX90_cm4_scs_nvic_iser1    0x00000000U

#define MSK_NX90_cm4_scs_nvic_iser1_setena         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_iser1_setena         0
#define DFLT_VAL_NX90_cm4_scs_nvic_iser1_setena    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_iser1_setena 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_iser1': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_iser1 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_iser1_setena = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ISER1_BIT_Ttag {
  unsigned int setena : BFW_NX90_cm4_scs_nvic_iser1_setena; /* For register cm4_scs_nvic_iser[n], enables or shows the current  */
                                                            /* enabled state of interrupt (m+(32*n)):                           */
                                                            /* 0: On reads, interrupt disabled. On writes, no effect.           */
                                                            /* 1: On reads, interrupt enabled. On writes, enable interrupt.     */
                                                            /* Software can enable multiple interrupts in a single write to     */
                                                            /* cm4_scs_nvic_iser[n].                                            */
} NX90_CM4_SCS_NVIC_ISER1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ISER1_BIT_T bf;
} NX90_CM4_SCS_NVIC_ISER1_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_iser2 */
/* => Interrupt set-enable register 2 */
/*    Enables, or reads the enable state of a group of interrupts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_iser2     0x00000108U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_iser2 0xE000E108U
#define Adr_NX90_cm4_scs_nvic_iser2         0xE000E108U
#define DFLT_VAL_NX90_cm4_scs_nvic_iser2    0x00000000U

#define MSK_NX90_cm4_scs_nvic_iser2_setena         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_iser2_setena         0
#define DFLT_VAL_NX90_cm4_scs_nvic_iser2_setena    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_iser2_setena 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_iser2': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_iser2 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_iser2_setena = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ISER2_BIT_Ttag {
  unsigned int setena : BFW_NX90_cm4_scs_nvic_iser2_setena; /* For register cm4_scs_nvic_iser[n], enables or shows the current  */
                                                            /* enabled state of interrupt (m+(32*n)):                           */
                                                            /* 0: On reads, interrupt disabled. On writes, no effect.           */
                                                            /* 1: On reads, interrupt enabled. On writes, enable interrupt.     */
                                                            /* Software can enable multiple interrupts in a single write to     */
                                                            /* cm4_scs_nvic_iser[n].                                            */
} NX90_CM4_SCS_NVIC_ISER2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ISER2_BIT_T bf;
} NX90_CM4_SCS_NVIC_ISER2_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_icer0 */
/* => Interrupt clear-enable register 0 */
/*    Disables, or reads the enable state of a group of interrupts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_icer0     0x00000180U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_icer0 0xE000E180U
#define Adr_NX90_cm4_scs_nvic_icer0         0xE000E180U
#define DFLT_VAL_NX90_cm4_scs_nvic_icer0    0x00000000U

#define MSK_NX90_cm4_scs_nvic_icer0_clrena         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_icer0_clrena         0
#define DFLT_VAL_NX90_cm4_scs_nvic_icer0_clrena    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_icer0_clrena 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_icer0': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_icer0 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_icer0_clrena = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ICER0_BIT_Ttag {
  unsigned int clrena : BFW_NX90_cm4_scs_nvic_icer0_clrena; /* For register cm4_scs_nvic_icer[n], disables or shows the current  */
                                                            /* enabled state of interrupt (m+(32*n)):                            */
                                                            /* 0: On reads, interrupt disabled. On writes, no effect.            */
                                                            /* 1: On reads, interrupt enabled. On writes, disable interrupt.     */
                                                            /* Software can disable multiple interrupts in a single write to     */
                                                            /* cm4_scs_nvic_icer[n].                                             */
} NX90_CM4_SCS_NVIC_ICER0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ICER0_BIT_T bf;
} NX90_CM4_SCS_NVIC_ICER0_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_icer1 */
/* => Interrupt clear-enable register 1 */
/*    Disables, or reads the enable state of a group of interrupts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_icer1     0x00000184U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_icer1 0xE000E184U
#define Adr_NX90_cm4_scs_nvic_icer1         0xE000E184U
#define DFLT_VAL_NX90_cm4_scs_nvic_icer1    0x00000000U

#define MSK_NX90_cm4_scs_nvic_icer1_clrena         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_icer1_clrena         0
#define DFLT_VAL_NX90_cm4_scs_nvic_icer1_clrena    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_icer1_clrena 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_icer1': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_icer1 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_icer1_clrena = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ICER1_BIT_Ttag {
  unsigned int clrena : BFW_NX90_cm4_scs_nvic_icer1_clrena; /* For register cm4_scs_nvic_icer[n], disables or shows the current  */
                                                            /* enabled state of interrupt (m+(32*n)):                            */
                                                            /* 0: On reads, interrupt disabled. On writes, no effect.            */
                                                            /* 1: On reads, interrupt enabled. On writes, disable interrupt.     */
                                                            /* Software can disable multiple interrupts in a single write to     */
                                                            /* cm4_scs_nvic_icer[n].                                             */
} NX90_CM4_SCS_NVIC_ICER1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ICER1_BIT_T bf;
} NX90_CM4_SCS_NVIC_ICER1_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_icer2 */
/* => Interrupt clear-enable register 2 */
/*    Disables, or reads the enable state of a group of interrupts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_icer2     0x00000188U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_icer2 0xE000E188U
#define Adr_NX90_cm4_scs_nvic_icer2         0xE000E188U
#define DFLT_VAL_NX90_cm4_scs_nvic_icer2    0x00000000U

#define MSK_NX90_cm4_scs_nvic_icer2_clrena         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_icer2_clrena         0
#define DFLT_VAL_NX90_cm4_scs_nvic_icer2_clrena    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_icer2_clrena 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_icer2': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_icer2 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_icer2_clrena = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ICER2_BIT_Ttag {
  unsigned int clrena : BFW_NX90_cm4_scs_nvic_icer2_clrena; /* For register cm4_scs_nvic_icer[n], disables or shows the current  */
                                                            /* enabled state of interrupt (m+(32*n)):                            */
                                                            /* 0: On reads, interrupt disabled. On writes, no effect.            */
                                                            /* 1: On reads, interrupt enabled. On writes, disable interrupt.     */
                                                            /* Software can disable multiple interrupts in a single write to     */
                                                            /* cm4_scs_nvic_icer[n].                                             */
} NX90_CM4_SCS_NVIC_ICER2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ICER2_BIT_T bf;
} NX90_CM4_SCS_NVIC_ICER2_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ispr0 */
/* => Interrupt set-pending register 0 */
/*    For a group of interrupts, changes interrupt status to pending, or shows the current \ */
/*    pending status. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ispr0     0x00000200U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ispr0 0xE000E200U
#define Adr_NX90_cm4_scs_nvic_ispr0         0xE000E200U
#define DFLT_VAL_NX90_cm4_scs_nvic_ispr0    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ispr0_setpend         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_ispr0_setpend         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ispr0_setpend    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ispr0_setpend 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ispr0': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ispr0 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ispr0_setpend = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ISPR0_BIT_Ttag {
  unsigned int setpend : BFW_NX90_cm4_scs_nvic_ispr0_setpend; /* For register cm4_scs_nvic_ispr[n], changes the state of interrupt   */
                                                              /* (m+(32*n)) to pending, or shows whether the state of the interrupt  */
                                                              /* is pending:                                                         */
                                                              /* 0: On reads, interrupt is not pending. On writes, no effect.        */
                                                              /* 1: On reads, interrupt is pending. On writes, change state of       */
                                                              /* interrupt to pending.                                               */
                                                              /* Software can set multiple interrupts to pending state in a single   */
                                                              /* write to cm4_scs_nvic_ispr[n].                                      */
} NX90_CM4_SCS_NVIC_ISPR0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ISPR0_BIT_T bf;
} NX90_CM4_SCS_NVIC_ISPR0_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ispr1 */
/* => Interrupt set-pending register 1 */
/*    For a group of interrupts, changes interrupt status to pending, or shows the current \ */
/*    pending status. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ispr1     0x00000204U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ispr1 0xE000E204U
#define Adr_NX90_cm4_scs_nvic_ispr1         0xE000E204U
#define DFLT_VAL_NX90_cm4_scs_nvic_ispr1    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ispr1_setpend         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_ispr1_setpend         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ispr1_setpend    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ispr1_setpend 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ispr1': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ispr1 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ispr1_setpend = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ISPR1_BIT_Ttag {
  unsigned int setpend : BFW_NX90_cm4_scs_nvic_ispr1_setpend; /* For register cm4_scs_nvic_ispr[n], changes the state of interrupt   */
                                                              /* (m+(32*n)) to pending, or shows whether the state of the interrupt  */
                                                              /* is pending:                                                         */
                                                              /* 0: On reads, interrupt is not pending. On writes, no effect.        */
                                                              /* 1: On reads, interrupt is pending. On writes, change state of       */
                                                              /* interrupt to pending.                                               */
                                                              /* Software can set multiple interrupts to pending state in a single   */
                                                              /* write to cm4_scs_nvic_ispr[n].                                      */
} NX90_CM4_SCS_NVIC_ISPR1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ISPR1_BIT_T bf;
} NX90_CM4_SCS_NVIC_ISPR1_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ispr2 */
/* => Interrupt set-pending register 2 */
/*    For a group of interrupts, changes interrupt status to pending, or shows the current \ */
/*    pending status. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ispr2     0x00000208U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ispr2 0xE000E208U
#define Adr_NX90_cm4_scs_nvic_ispr2         0xE000E208U
#define DFLT_VAL_NX90_cm4_scs_nvic_ispr2    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ispr2_setpend         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_ispr2_setpend         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ispr2_setpend    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ispr2_setpend 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ispr2': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ispr2 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ispr2_setpend = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ISPR2_BIT_Ttag {
  unsigned int setpend : BFW_NX90_cm4_scs_nvic_ispr2_setpend; /* For register cm4_scs_nvic_ispr[n], changes the state of interrupt   */
                                                              /* (m+(32*n)) to pending, or shows whether the state of the interrupt  */
                                                              /* is pending:                                                         */
                                                              /* 0: On reads, interrupt is not pending. On writes, no effect.        */
                                                              /* 1: On reads, interrupt is pending. On writes, change state of       */
                                                              /* interrupt to pending.                                               */
                                                              /* Software can set multiple interrupts to pending state in a single   */
                                                              /* write to cm4_scs_nvic_ispr[n].                                      */
} NX90_CM4_SCS_NVIC_ISPR2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ISPR2_BIT_T bf;
} NX90_CM4_SCS_NVIC_ISPR2_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_icpr0 */
/* => Interrupt clear-pending register 0 */
/*    For a group of interrupts, clears the interrupt pending status, or shows the current \ */
/*    pending status. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_icpr0     0x00000280U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_icpr0 0xE000E280U
#define Adr_NX90_cm4_scs_nvic_icpr0         0xE000E280U
#define DFLT_VAL_NX90_cm4_scs_nvic_icpr0    0x00000000U

#define MSK_NX90_cm4_scs_nvic_icpr0_clrpend         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_icpr0_clrpend         0
#define DFLT_VAL_NX90_cm4_scs_nvic_icpr0_clrpend    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_icpr0_clrpend 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_icpr0': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_icpr0 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_icpr0_clrpend = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ICPR0_BIT_Ttag {
  unsigned int clrpend : BFW_NX90_cm4_scs_nvic_icpr0_clrpend; /* For register cm4_scs_nvic_ispr[n], clears the pending state of interrupt   */
                                                              /* (m+(32*n)), or shows whether the state of the interrupt                    */
                                                              /* is pending:                                                                */
                                                              /* 0: On reads, interrupt is not pending. On writes, no effect.               */
                                                              /* 1: On reads, interrupt is pending. On writes, clears the pending state of  */
                                                              /* interrupt.                                                                 */
                                                              /* Software can clear the pending state of multiple interrupts in a single    */
                                                              /* write to cm4_scs_nvic_icpr[n].                                             */
} NX90_CM4_SCS_NVIC_ICPR0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ICPR0_BIT_T bf;
} NX90_CM4_SCS_NVIC_ICPR0_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_icpr1 */
/* => Interrupt clear-pending register 1 */
/*    For a group of interrupts, clears the interrupt pending status, or shows the current \ */
/*    pending status. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_icpr1     0x00000284U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_icpr1 0xE000E284U
#define Adr_NX90_cm4_scs_nvic_icpr1         0xE000E284U
#define DFLT_VAL_NX90_cm4_scs_nvic_icpr1    0x00000000U

#define MSK_NX90_cm4_scs_nvic_icpr1_clrpend         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_icpr1_clrpend         0
#define DFLT_VAL_NX90_cm4_scs_nvic_icpr1_clrpend    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_icpr1_clrpend 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_icpr1': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_icpr1 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_icpr1_clrpend = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ICPR1_BIT_Ttag {
  unsigned int clrpend : BFW_NX90_cm4_scs_nvic_icpr1_clrpend; /* For register cm4_scs_nvic_ispr[n], clears the pending state of interrupt   */
                                                              /* (m+(32*n)), or shows whether the state of the interrupt                    */
                                                              /* is pending:                                                                */
                                                              /* 0: On reads, interrupt is not pending. On writes, no effect.               */
                                                              /* 1: On reads, interrupt is pending. On writes, clears the pending state of  */
                                                              /* interrupt.                                                                 */
                                                              /* Software can clear the pending state of multiple interrupts in a single    */
                                                              /* write to cm4_scs_nvic_icpr[n].                                             */
} NX90_CM4_SCS_NVIC_ICPR1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ICPR1_BIT_T bf;
} NX90_CM4_SCS_NVIC_ICPR1_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_icpr2 */
/* => Interrupt clear-pending register 2 */
/*    For a group of interrupts, clears the interrupt pending status, or shows the current \ */
/*    pending status. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_icpr2     0x00000288U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_icpr2 0xE000E288U
#define Adr_NX90_cm4_scs_nvic_icpr2         0xE000E288U
#define DFLT_VAL_NX90_cm4_scs_nvic_icpr2    0x00000000U

#define MSK_NX90_cm4_scs_nvic_icpr2_clrpend         0xffffffffU
#define SRT_NX90_cm4_scs_nvic_icpr2_clrpend         0
#define DFLT_VAL_NX90_cm4_scs_nvic_icpr2_clrpend    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_icpr2_clrpend 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_icpr2': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_icpr2 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_icpr2_clrpend = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_ICPR2_BIT_Ttag {
  unsigned int clrpend : BFW_NX90_cm4_scs_nvic_icpr2_clrpend; /* For register cm4_scs_nvic_ispr[n], clears the pending state of interrupt   */
                                                              /* (m+(32*n)), or shows whether the state of the interrupt                    */
                                                              /* is pending:                                                                */
                                                              /* 0: On reads, interrupt is not pending. On writes, no effect.               */
                                                              /* 1: On reads, interrupt is pending. On writes, clears the pending state of  */
                                                              /* interrupt.                                                                 */
                                                              /* Software can clear the pending state of multiple interrupts in a single    */
                                                              /* write to cm4_scs_nvic_icpr[n].                                             */
} NX90_CM4_SCS_NVIC_ICPR2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_ICPR2_BIT_T bf;
} NX90_CM4_SCS_NVIC_ICPR2_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_iabr0 */
/* => Interrupt active bit register 0 */
/*    For a group of 32 interrupts, shows whether each interrupt is active. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_iabr0     0x00000300U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_iabr0 0xE000E300U
#define Adr_NX90_cm4_scs_nvic_iabr0         0xE000E300U

#define MSK_NX90_cm4_scs_nvic_iabr0_active 0xffffffffU
#define SRT_NX90_cm4_scs_nvic_iabr0_active 0

/* all used bits of 'NX90_cm4_scs_nvic_iabr0': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_iabr0 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_iabr0_active = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_IABR0_BIT_Ttag {
  unsigned int active : BFW_NX90_cm4_scs_nvic_iabr0_active; /* For register cm4_scs_nvic_iabr[n], shows whether interrupt (m+(32*n)) is active. */
} NX90_CM4_SCS_NVIC_IABR0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IABR0_BIT_T bf;
} NX90_CM4_SCS_NVIC_IABR0_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_iabr1 */
/* => Interrupt active bit register 1 */
/*    For a group of 32 interrupts, shows whether each interrupt is active. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_iabr1     0x00000304U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_iabr1 0xE000E304U
#define Adr_NX90_cm4_scs_nvic_iabr1         0xE000E304U

#define MSK_NX90_cm4_scs_nvic_iabr1_active 0xffffffffU
#define SRT_NX90_cm4_scs_nvic_iabr1_active 0

/* all used bits of 'NX90_cm4_scs_nvic_iabr1': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_iabr1 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_iabr1_active = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_IABR1_BIT_Ttag {
  unsigned int active : BFW_NX90_cm4_scs_nvic_iabr1_active; /* For register cm4_scs_nvic_iabr[n], shows whether interrupt (m+(32*n)) is active. */
} NX90_CM4_SCS_NVIC_IABR1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IABR1_BIT_T bf;
} NX90_CM4_SCS_NVIC_IABR1_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_iabr2 */
/* => Interrupt active bit register 2 */
/*    For a group of 32 interrupts, shows whether each interrupt is active. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_iabr2     0x00000308U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_iabr2 0xE000E308U
#define Adr_NX90_cm4_scs_nvic_iabr2         0xE000E308U

#define MSK_NX90_cm4_scs_nvic_iabr2_active 0xffffffffU
#define SRT_NX90_cm4_scs_nvic_iabr2_active 0

/* all used bits of 'NX90_cm4_scs_nvic_iabr2': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_iabr2 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_iabr2_active = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_NVIC_IABR2_BIT_Ttag {
  unsigned int active : BFW_NX90_cm4_scs_nvic_iabr2_active; /* For register cm4_scs_nvic_iabr[n], shows whether interrupt (m+(32*n)) is active. */
} NX90_CM4_SCS_NVIC_IABR2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IABR2_BIT_T bf;
} NX90_CM4_SCS_NVIC_IABR2_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr0 */
/* => Interrupt priority register 0 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr0     0x00000400U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr0 0xE000E400U
#define Adr_NX90_cm4_scs_nvic_ipr0         0xE000E400U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr0    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr0_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr0_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr0_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr0_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr0_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr0_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr0_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr0_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr0_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr0_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr0_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr0_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr0_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr0_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr0_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr0_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr0': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr0 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr0_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr0_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr0_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr0_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR0_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr0_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr0_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr0_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr0_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR0_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR0_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR0_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr1 */
/* => Interrupt priority register 1 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr1     0x00000404U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr1 0xE000E404U
#define Adr_NX90_cm4_scs_nvic_ipr1         0xE000E404U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr1    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr1_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr1_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr1_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr1_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr1_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr1_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr1_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr1_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr1_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr1_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr1_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr1_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr1_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr1_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr1_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr1_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr1': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr1 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr1_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr1_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr1_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr1_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR1_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr1_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr1_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr1_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr1_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR1_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR1_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR1_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr2 */
/* => Interrupt priority register 2 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr2     0x00000408U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr2 0xE000E408U
#define Adr_NX90_cm4_scs_nvic_ipr2         0xE000E408U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr2    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr2_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr2_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr2_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr2_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr2_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr2_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr2_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr2_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr2_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr2_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr2_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr2_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr2_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr2_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr2_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr2_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr2': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr2 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr2_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr2_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr2_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr2_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR2_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr2_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr2_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr2_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr2_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR2_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR2_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR2_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr3 */
/* => Interrupt priority register 3 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr3     0x0000040CU
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr3 0xE000E40CU
#define Adr_NX90_cm4_scs_nvic_ipr3         0xE000E40CU
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr3    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr3_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr3_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr3_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr3_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr3_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr3_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr3_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr3_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr3_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr3_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr3_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr3_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr3_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr3_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr3_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr3_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr3': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr3 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr3_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr3_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr3_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr3_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR3_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr3_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr3_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr3_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr3_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR3_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR3_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR3_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr4 */
/* => Interrupt priority register 4 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr4     0x00000410U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr4 0xE000E410U
#define Adr_NX90_cm4_scs_nvic_ipr4         0xE000E410U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr4    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr4_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr4_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr4_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr4_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr4_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr4_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr4_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr4_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr4_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr4_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr4_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr4_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr4_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr4_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr4_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr4_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr4': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr4 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr4_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr4_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr4_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr4_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR4_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr4_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr4_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr4_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr4_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR4_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR4_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR4_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr5 */
/* => Interrupt priority register 5 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr5     0x00000414U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr5 0xE000E414U
#define Adr_NX90_cm4_scs_nvic_ipr5         0xE000E414U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr5    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr5_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr5_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr5_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr5_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr5_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr5_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr5_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr5_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr5_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr5_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr5_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr5_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr5_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr5_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr5_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr5_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr5': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr5 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr5_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr5_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr5_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr5_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR5_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr5_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr5_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr5_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr5_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR5_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR5_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR5_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr6 */
/* => Interrupt priority register 6 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr6     0x00000418U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr6 0xE000E418U
#define Adr_NX90_cm4_scs_nvic_ipr6         0xE000E418U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr6    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr6_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr6_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr6_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr6_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr6_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr6_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr6_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr6_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr6_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr6_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr6_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr6_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr6_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr6_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr6_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr6_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr6': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr6 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr6_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr6_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr6_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr6_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR6_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr6_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr6_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr6_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr6_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR6_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR6_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR6_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr7 */
/* => Interrupt priority register 7 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr7     0x0000041CU
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr7 0xE000E41CU
#define Adr_NX90_cm4_scs_nvic_ipr7         0xE000E41CU
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr7    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr7_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr7_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr7_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr7_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr7_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr7_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr7_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr7_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr7_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr7_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr7_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr7_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr7_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr7_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr7_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr7_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr7': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr7 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr7_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr7_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr7_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr7_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR7_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr7_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr7_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr7_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr7_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR7_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR7_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR7_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr8 */
/* => Interrupt priority register 8 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr8     0x00000420U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr8 0xE000E420U
#define Adr_NX90_cm4_scs_nvic_ipr8         0xE000E420U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr8    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr8_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr8_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr8_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr8_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr8_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr8_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr8_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr8_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr8_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr8_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr8_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr8_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr8_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr8_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr8_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr8_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr8': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr8 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr8_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr8_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr8_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr8_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR8_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr8_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr8_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr8_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr8_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR8_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR8_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR8_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr9 */
/* => Interrupt priority register 9 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr9     0x00000424U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr9 0xE000E424U
#define Adr_NX90_cm4_scs_nvic_ipr9         0xE000E424U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr9    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr9_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr9_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr9_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr9_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr9_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr9_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr9_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr9_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr9_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr9_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr9_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr9_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr9_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr9_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr9_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr9_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr9': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr9 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr9_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr9_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr9_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr9_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR9_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr9_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr9_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr9_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr9_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR9_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_CM4_SCS_NVIC_IPR9_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR9_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr10 */
/* => Interrupt priority register 10 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr10     0x00000428U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr10 0xE000E428U
#define Adr_NX90_cm4_scs_nvic_ipr10         0xE000E428U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr10    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr10_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr10_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr10_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr10_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr10_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr10_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr10_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr10_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr10_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr10_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr10_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr10_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr10_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr10_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr10_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr10_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr10': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr10 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr10_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr10_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr10_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr10_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR10_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr10_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr10_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr10_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr10_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR10_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IPR10_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR10_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr11 */
/* => Interrupt priority register 11 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr11     0x0000042CU
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr11 0xE000E42CU
#define Adr_NX90_cm4_scs_nvic_ipr11         0xE000E42CU
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr11    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr11_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr11_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr11_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr11_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr11_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr11_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr11_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr11_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr11_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr11_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr11_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr11_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr11_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr11_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr11_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr11_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr11': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr11 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr11_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr11_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr11_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr11_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR11_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr11_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr11_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr11_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr11_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR11_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IPR11_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR11_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr12 */
/* => Interrupt priority register 12 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr12     0x00000430U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr12 0xE000E430U
#define Adr_NX90_cm4_scs_nvic_ipr12         0xE000E430U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr12    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr12_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr12_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr12_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr12_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr12_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr12_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr12_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr12_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr12_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr12_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr12_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr12_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr12_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr12_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr12_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr12_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr12': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr12 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr12_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr12_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr12_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr12_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR12_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr12_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr12_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr12_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr12_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR12_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IPR12_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR12_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr13 */
/* => Interrupt priority register 13 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr13     0x00000434U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr13 0xE000E434U
#define Adr_NX90_cm4_scs_nvic_ipr13         0xE000E434U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr13    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr13_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr13_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr13_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr13_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr13_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr13_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr13_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr13_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr13_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr13_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr13_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr13_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr13_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr13_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr13_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr13_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr13': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr13 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr13_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr13_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr13_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr13_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR13_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr13_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr13_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr13_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr13_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR13_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IPR13_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR13_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr14 */
/* => Interrupt priority register 14 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr14     0x00000438U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr14 0xE000E438U
#define Adr_NX90_cm4_scs_nvic_ipr14         0xE000E438U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr14    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr14_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr14_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr14_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr14_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr14_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr14_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr14_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr14_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr14_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr14_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr14_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr14_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr14_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr14_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr14_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr14_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr14': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr14 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr14_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr14_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr14_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr14_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR14_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr14_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr14_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr14_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr14_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR14_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IPR14_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR14_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr15 */
/* => Interrupt priority register 15 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr15     0x0000043CU
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr15 0xE000E43CU
#define Adr_NX90_cm4_scs_nvic_ipr15         0xE000E43CU
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr15    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr15_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr15_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr15_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr15_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr15_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr15_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr15_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr15_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr15_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr15_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr15_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr15_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr15_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr15_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr15_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr15_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr15': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr15 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr15_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr15_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr15_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr15_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR15_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr15_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr15_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr15_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr15_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR15_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IPR15_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR15_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_nvic_ipr16 */
/* => Interrupt priority register 16 */
/*    Sets or reads interrupt priorities. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_nvic_ipr16     0x00000440U
#define Adr_NX90_cm4_scs_cm4_scs_nvic_ipr16 0xE000E440U
#define Adr_NX90_cm4_scs_nvic_ipr16         0xE000E440U
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr16    0x00000000U

#define MSK_NX90_cm4_scs_nvic_ipr16_pri_n0         0x000000ffU
#define SRT_NX90_cm4_scs_nvic_ipr16_pri_n0         0
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr16_pri_n0    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr16_pri_n0 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr16_pri_n1         0x0000ff00U
#define SRT_NX90_cm4_scs_nvic_ipr16_pri_n1         8
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr16_pri_n1    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr16_pri_n1 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr16_pri_n2         0x00ff0000U
#define SRT_NX90_cm4_scs_nvic_ipr16_pri_n2         16
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr16_pri_n2    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr16_pri_n2 0x00000000U
#define MSK_NX90_cm4_scs_nvic_ipr16_pri_n3         0xff000000U
#define SRT_NX90_cm4_scs_nvic_ipr16_pri_n3         24
#define DFLT_VAL_NX90_cm4_scs_nvic_ipr16_pri_n3    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_nvic_ipr16_pri_n3 0x00000000U

/* all used bits of 'NX90_cm4_scs_nvic_ipr16': */
#define MSK_USED_BITS_NX90_cm4_scs_nvic_ipr16 0xffffffffU

enum {
  BFW_NX90_cm4_scs_nvic_ipr16_pri_n0 = 8, /* [7:0] */
  BFW_NX90_cm4_scs_nvic_ipr16_pri_n1 = 8, /* [15:8] */
  BFW_NX90_cm4_scs_nvic_ipr16_pri_n2 = 8, /* [23:16] */
  BFW_NX90_cm4_scs_nvic_ipr16_pri_n3 = 8  /* [31:24] */
};

typedef struct NX90_CM4_SCS_NVIC_IPR16_BIT_Ttag {
  unsigned int pri_n0 : BFW_NX90_cm4_scs_nvic_ipr16_pri_n0; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n.   */
  unsigned int pri_n1 : BFW_NX90_cm4_scs_nvic_ipr16_pri_n1; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. */
  unsigned int pri_n2 : BFW_NX90_cm4_scs_nvic_ipr16_pri_n2; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. */
  unsigned int pri_n3 : BFW_NX90_cm4_scs_nvic_ipr16_pri_n3; /* For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. */
} NX90_CM4_SCS_NVIC_IPR16_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CM4_SCS_NVIC_IPR16_BIT_T bf;
} NX90_CM4_SCS_NVIC_IPR16_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_cpuid */
/* => CPUID base register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_cpuid     0x00000D00U
#define Adr_NX90_cm4_scs_cm4_scs_cpuid 0xE000ED00U
#define Adr_NX90_cm4_scs_cpuid         0xE000ED00U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_icsr */
/* => Interrupt control and state register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_icsr     0x00000D04U
#define Adr_NX90_cm4_scs_cm4_scs_icsr 0xE000ED04U
#define Adr_NX90_cm4_scs_icsr         0xE000ED04U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_vtor */
/* => Vector table offset register */
/*    Holds the vector table address. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_vtor     0x00000D08U
#define Adr_NX90_cm4_scs_cm4_scs_vtor 0xE000ED08U
#define Adr_NX90_cm4_scs_vtor         0xE000ED08U
#define DFLT_VAL_NX90_cm4_scs_vtor    0x00000000U

#define MSK_NX90_cm4_scs_vtor_tbloff         0xffffff80U
#define SRT_NX90_cm4_scs_vtor_tbloff         7
#define DFLT_VAL_NX90_cm4_scs_vtor_tbloff    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_vtor_tbloff 0x00000000U

/* all used bits of 'NX90_cm4_scs_vtor': */
#define MSK_USED_BITS_NX90_cm4_scs_vtor 0xffffff80U

enum {
  BFW_NX90_cm4_scs_vtor_reserved1 = 7,  /* [6:0] */
  BFW_NX90_cm4_scs_vtor_tbloff    = 25  /* [31:7] */
};

typedef struct NX90_CM4_SCS_VTOR_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_cm4_scs_vtor_reserved1; /* reserved                                */
  unsigned int tbloff    : BFW_NX90_cm4_scs_vtor_tbloff;    /* Bits[31:7] of the vector table address. */
} NX90_CM4_SCS_VTOR_BIT_T;

typedef union {
  uint32_t                val;
  NX90_CM4_SCS_VTOR_BIT_T bf;
} NX90_CM4_SCS_VTOR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_aircr */
/* => Application interrupt and reset control reister */
/*    Sets or returns interrupt control data. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_aircr     0x00000D0CU
#define Adr_NX90_cm4_scs_cm4_scs_aircr 0xE000ED0CU
#define Adr_NX90_cm4_scs_aircr         0xE000ED0CU
#define DFLT_VAL_NX90_cm4_scs_aircr    0xfa050000U

#define MSK_NX90_cm4_scs_aircr_vectreset             0x00000001U
#define SRT_NX90_cm4_scs_aircr_vectreset             0
#define DFLT_VAL_NX90_cm4_scs_aircr_vectreset        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_aircr_vectreset     0x00000000U
#define MSK_NX90_cm4_scs_aircr_vectclractive         0x00000002U
#define SRT_NX90_cm4_scs_aircr_vectclractive         1
#define DFLT_VAL_NX90_cm4_scs_aircr_vectclractive    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_aircr_vectclractive 0x00000000U
#define MSK_NX90_cm4_scs_aircr_sysresetreq           0x00000004U
#define SRT_NX90_cm4_scs_aircr_sysresetreq           2
#define DFLT_VAL_NX90_cm4_scs_aircr_sysresetreq      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_aircr_sysresetreq   0x00000000U
#define MSK_NX90_cm4_scs_aircr_prigroup              0x00000700U
#define SRT_NX90_cm4_scs_aircr_prigroup              8
#define DFLT_VAL_NX90_cm4_scs_aircr_prigroup         0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_aircr_prigroup      0x00000000U
#define MSK_NX90_cm4_scs_aircr_endianness            0x00008000U
#define SRT_NX90_cm4_scs_aircr_endianness            15
#define DFLT_VAL_NX90_cm4_scs_aircr_endianness       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_aircr_endianness    0x00000000U
#define MSK_NX90_cm4_scs_aircr_vectkey               0xffff0000U
#define SRT_NX90_cm4_scs_aircr_vectkey               16
#define DFLT_VAL_NX90_cm4_scs_aircr_vectkey          0xfa050000U
#define DFLT_BF_VAL_NX90_cm4_scs_aircr_vectkey       0x0000fa05U

/* all used bits of 'NX90_cm4_scs_aircr': */
#define MSK_USED_BITS_NX90_cm4_scs_aircr 0xffff8707U

enum {
  BFW_NX90_cm4_scs_aircr_vectreset     = 1,  /* [0] */
  BFW_NX90_cm4_scs_aircr_vectclractive = 1,  /* [1] */
  BFW_NX90_cm4_scs_aircr_sysresetreq   = 1,  /* [2] */
  BFW_NX90_cm4_scs_aircr_reserved1     = 5,  /* [7:3] */
  BFW_NX90_cm4_scs_aircr_prigroup      = 3,  /* [10:8] */
  BFW_NX90_cm4_scs_aircr_reserved2     = 4,  /* [14:11] */
  BFW_NX90_cm4_scs_aircr_endianness    = 1,  /* [15] */
  BFW_NX90_cm4_scs_aircr_vectkey       = 16  /* [31:16] */
};

typedef struct NX90_CM4_SCS_AIRCR_BIT_Ttag {
  unsigned int vectreset     : BFW_NX90_cm4_scs_aircr_vectreset;     /* Writing 1 to this bit causes a local system reset. This bit self-clears.         */
                                                                     /* The effect of writing a 1 to this bit if the processor is not halted in          */
                                                                     /* Debug state is UNPREDICTABLE.                                                    */
                                                                     /* When the processor is halted in Debug state, if a write to the register          */
                                                                     /* writes a 1 to both VECTRESET and SYSRESETREQ, the behavior is UNPREDICTABLE.     */
                                                                     /* This bit is write only.                                                          */
                                                                     /* Note: The netx90 doesn't support a local system reset. Writing 1 results in      */
                                                                     /* UNPREDICTABLE behaviour of the whole system! Use sysresetreq instead!            */
  unsigned int vectclractive : BFW_NX90_cm4_scs_aircr_vectclractive; /* Writing 1 to this bit clears all active state information for fixed and          */
                                                                     /* configurable exceptions. This includes clearing the IPSR to zero.                */
                                                                     /* The effect of writing a 1 to this bit if the processor is not halted in          */
                                                                     /* Debug state is UNPREDICTABLE.                                                    */
                                                                     /* This bit is write only.                                                          */
  unsigned int sysresetreq   : BFW_NX90_cm4_scs_aircr_sysresetreq;   /* System Reset Request.                                                            */
                                                                     /* Writing 1 to this bit asserts a signal to the external system to request a       */
                                                                     /* Local reset. A Local or Power-on reset clears this bit to 0.                     */
  unsigned int reserved1     : BFW_NX90_cm4_scs_aircr_reserved1;     /* reserved                                                                         */
  unsigned int prigroup      : BFW_NX90_cm4_scs_aircr_prigroup;      /* Priority grouping, indicates the binary point position.                          */
  unsigned int reserved2     : BFW_NX90_cm4_scs_aircr_reserved2;     /* reserved                                                                         */
  unsigned int endianness    : BFW_NX90_cm4_scs_aircr_endianness;    /* Indicates the memory system endianness: 0 - Little endian, 1 - Big endian.       */
                                                                     /* This bit is static or configured by a hardware input on reset.                   */
                                                                     /* This bit is read only.                                                           */
  unsigned int vectkey       : BFW_NX90_cm4_scs_aircr_vectkey;       /* Vector Key.                                                                      */
                                                                     /* Register writes must write 0x05FA to this field, otherwise the write is ignored. */
                                                                     /* On reads, returns 0xFA05.                                                        */
} NX90_CM4_SCS_AIRCR_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_AIRCR_BIT_T bf;
} NX90_CM4_SCS_AIRCR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_scr */
/* => System control Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_scr     0x00000D10U
#define Adr_NX90_cm4_scs_cm4_scs_scr 0xE000ED10U
#define Adr_NX90_cm4_scs_scr         0xE000ED10U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_ccr */
/* => Configuration and control Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_ccr     0x00000D14U
#define Adr_NX90_cm4_scs_cm4_scs_ccr 0xE000ED14U
#define Adr_NX90_cm4_scs_ccr         0xE000ED14U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_shpr1 */
/* => System Handler Priority Register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_shpr1     0x00000D18U
#define Adr_NX90_cm4_scs_cm4_scs_shpr1 0xE000ED18U
#define Adr_NX90_cm4_scs_shpr1         0xE000ED18U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_shpr2 */
/* => System Handler Priority Register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_shpr2     0x00000D1CU
#define Adr_NX90_cm4_scs_cm4_scs_shpr2 0xE000ED1CU
#define Adr_NX90_cm4_scs_shpr2         0xE000ED1CU

/* --------------------------------------------------------------------- */
/* Register cm4_scs_shpr3 */
/* => System Handler Priority Register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_shpr3     0x00000D20U
#define Adr_NX90_cm4_scs_cm4_scs_shpr3 0xE000ED20U
#define Adr_NX90_cm4_scs_shpr3         0xE000ED20U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_shcsr */
/* => System Handler Control and State Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_shcsr     0x00000D24U
#define Adr_NX90_cm4_scs_cm4_scs_shcsr 0xE000ED24U
#define Adr_NX90_cm4_scs_shcsr         0xE000ED24U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_cfsr */
/* => Configurable Fault Status Register */
/*    Contains the three Configurable Fault Status Registers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_cfsr     0x00000D28U
#define Adr_NX90_cm4_scs_cm4_scs_cfsr 0xE000ED28U
#define Adr_NX90_cm4_scs_cfsr         0xE000ED28U
#define DFLT_VAL_NX90_cm4_scs_cfsr    0x00000000U

#define MSK_NX90_cm4_scs_cfsr_mmfsr_iaccviol           0x00000001U
#define SRT_NX90_cm4_scs_cfsr_mmfsr_iaccviol           0
#define DFLT_VAL_NX90_cm4_scs_cfsr_mmfsr_iaccviol      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_mmfsr_iaccviol   0x00000000U
#define MSK_NX90_cm4_scs_cfsr_mmfsr_daccviol           0x00000002U
#define SRT_NX90_cm4_scs_cfsr_mmfsr_daccviol           1
#define DFLT_VAL_NX90_cm4_scs_cfsr_mmfsr_daccviol      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_mmfsr_daccviol   0x00000000U
#define MSK_NX90_cm4_scs_cfsr_mmfsr_munstkerr          0x00000008U
#define SRT_NX90_cm4_scs_cfsr_mmfsr_munstkerr          3
#define DFLT_VAL_NX90_cm4_scs_cfsr_mmfsr_munstkerr     0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_mmfsr_munstkerr  0x00000000U
#define MSK_NX90_cm4_scs_cfsr_mmfsr_mstkerr            0x00000010U
#define SRT_NX90_cm4_scs_cfsr_mmfsr_mstkerr            4
#define DFLT_VAL_NX90_cm4_scs_cfsr_mmfsr_mstkerr       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_mmfsr_mstkerr    0x00000000U
#define MSK_NX90_cm4_scs_cfsr_mmfsr_lsperr             0x00000020U
#define SRT_NX90_cm4_scs_cfsr_mmfsr_lsperr             5
#define DFLT_VAL_NX90_cm4_scs_cfsr_mmfsr_lsperr        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_mmfsr_lsperr     0x00000000U
#define MSK_NX90_cm4_scs_cfsr_mmfsr_mmarvalid          0x00000080U
#define SRT_NX90_cm4_scs_cfsr_mmfsr_mmarvalid          7
#define DFLT_VAL_NX90_cm4_scs_cfsr_mmfsr_mmarvalid     0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_mmfsr_mmarvalid  0x00000000U
#define MSK_NX90_cm4_scs_cfsr_bfsr_ibuserr             0x00000100U
#define SRT_NX90_cm4_scs_cfsr_bfsr_ibuserr             8
#define DFLT_VAL_NX90_cm4_scs_cfsr_bfsr_ibuserr        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_bfsr_ibuserr     0x00000000U
#define MSK_NX90_cm4_scs_cfsr_bfsr_preciserr           0x00000200U
#define SRT_NX90_cm4_scs_cfsr_bfsr_preciserr           9
#define DFLT_VAL_NX90_cm4_scs_cfsr_bfsr_preciserr      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_bfsr_preciserr   0x00000000U
#define MSK_NX90_cm4_scs_cfsr_bfsr_impreciserr         0x00000400U
#define SRT_NX90_cm4_scs_cfsr_bfsr_impreciserr         10
#define DFLT_VAL_NX90_cm4_scs_cfsr_bfsr_impreciserr    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_bfsr_impreciserr 0x00000000U
#define MSK_NX90_cm4_scs_cfsr_bfsr_unstkerr            0x00000800U
#define SRT_NX90_cm4_scs_cfsr_bfsr_unstkerr            11
#define DFLT_VAL_NX90_cm4_scs_cfsr_bfsr_unstkerr       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_bfsr_unstkerr    0x00000000U
#define MSK_NX90_cm4_scs_cfsr_bfsr_stkerr              0x00001000U
#define SRT_NX90_cm4_scs_cfsr_bfsr_stkerr              12
#define DFLT_VAL_NX90_cm4_scs_cfsr_bfsr_stkerr         0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_bfsr_stkerr      0x00000000U
#define MSK_NX90_cm4_scs_cfsr_bfsr_lsperr              0x00002000U
#define SRT_NX90_cm4_scs_cfsr_bfsr_lsperr              13
#define DFLT_VAL_NX90_cm4_scs_cfsr_bfsr_lsperr         0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_bfsr_lsperr      0x00000000U
#define MSK_NX90_cm4_scs_cfsr_bfsr_bfarvalid           0x00008000U
#define SRT_NX90_cm4_scs_cfsr_bfsr_bfarvalid           15
#define DFLT_VAL_NX90_cm4_scs_cfsr_bfsr_bfarvalid      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_bfsr_bfarvalid   0x00000000U
#define MSK_NX90_cm4_scs_cfsr_ufsr_undefinstr          0x00010000U
#define SRT_NX90_cm4_scs_cfsr_ufsr_undefinstr          16
#define DFLT_VAL_NX90_cm4_scs_cfsr_ufsr_undefinstr     0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_ufsr_undefinstr  0x00000000U
#define MSK_NX90_cm4_scs_cfsr_ufsr_invstate            0x00020000U
#define SRT_NX90_cm4_scs_cfsr_ufsr_invstate            17
#define DFLT_VAL_NX90_cm4_scs_cfsr_ufsr_invstate       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_ufsr_invstate    0x00000000U
#define MSK_NX90_cm4_scs_cfsr_ufsr_invpc               0x00040000U
#define SRT_NX90_cm4_scs_cfsr_ufsr_invpc               18
#define DFLT_VAL_NX90_cm4_scs_cfsr_ufsr_invpc          0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_ufsr_invpc       0x00000000U
#define MSK_NX90_cm4_scs_cfsr_ufsr_nocp                0x00080000U
#define SRT_NX90_cm4_scs_cfsr_ufsr_nocp                19
#define DFLT_VAL_NX90_cm4_scs_cfsr_ufsr_nocp           0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_ufsr_nocp        0x00000000U
#define MSK_NX90_cm4_scs_cfsr_ufsr_unaligned           0x01000000U
#define SRT_NX90_cm4_scs_cfsr_ufsr_unaligned           24
#define DFLT_VAL_NX90_cm4_scs_cfsr_ufsr_unaligned      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_ufsr_unaligned   0x00000000U
#define MSK_NX90_cm4_scs_cfsr_ufsr_divbyzero           0x02000000U
#define SRT_NX90_cm4_scs_cfsr_ufsr_divbyzero           25
#define DFLT_VAL_NX90_cm4_scs_cfsr_ufsr_divbyzero      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_cfsr_ufsr_divbyzero   0x00000000U

/* all used bits of 'NX90_cm4_scs_cfsr': */
#define MSK_USED_BITS_NX90_cm4_scs_cfsr 0x030fbfbbU

enum {
  BFW_NX90_cm4_scs_cfsr_mmfsr_iaccviol   = 1, /* [0] */
  BFW_NX90_cm4_scs_cfsr_mmfsr_daccviol   = 1, /* [1] */
  BFW_NX90_cm4_scs_cfsr_reserved1        = 1, /* [2] */
  BFW_NX90_cm4_scs_cfsr_mmfsr_munstkerr  = 1, /* [3] */
  BFW_NX90_cm4_scs_cfsr_mmfsr_mstkerr    = 1, /* [4] */
  BFW_NX90_cm4_scs_cfsr_mmfsr_lsperr     = 1, /* [5] */
  BFW_NX90_cm4_scs_cfsr_reserved2        = 1, /* [6] */
  BFW_NX90_cm4_scs_cfsr_mmfsr_mmarvalid  = 1, /* [7] */
  BFW_NX90_cm4_scs_cfsr_bfsr_ibuserr     = 1, /* [8] */
  BFW_NX90_cm4_scs_cfsr_bfsr_preciserr   = 1, /* [9] */
  BFW_NX90_cm4_scs_cfsr_bfsr_impreciserr = 1, /* [10] */
  BFW_NX90_cm4_scs_cfsr_bfsr_unstkerr    = 1, /* [11] */
  BFW_NX90_cm4_scs_cfsr_bfsr_stkerr      = 1, /* [12] */
  BFW_NX90_cm4_scs_cfsr_bfsr_lsperr      = 1, /* [13] */
  BFW_NX90_cm4_scs_cfsr_reserved3        = 1, /* [14] */
  BFW_NX90_cm4_scs_cfsr_bfsr_bfarvalid   = 1, /* [15] */
  BFW_NX90_cm4_scs_cfsr_ufsr_undefinstr  = 1, /* [16] */
  BFW_NX90_cm4_scs_cfsr_ufsr_invstate    = 1, /* [17] */
  BFW_NX90_cm4_scs_cfsr_ufsr_invpc       = 1, /* [18] */
  BFW_NX90_cm4_scs_cfsr_ufsr_nocp        = 1, /* [19] */
  BFW_NX90_cm4_scs_cfsr_reserved4        = 4, /* [23:20] */
  BFW_NX90_cm4_scs_cfsr_ufsr_unaligned   = 1, /* [24] */
  BFW_NX90_cm4_scs_cfsr_ufsr_divbyzero   = 1, /* [25] */
  BFW_NX90_cm4_scs_cfsr_reserved5        = 6  /* [31:26] */
};

typedef struct NX90_CM4_SCS_CFSR_BIT_Ttag {
  unsigned int mmfsr_iaccviol   : BFW_NX90_cm4_scs_cfsr_mmfsr_iaccviol;   /* MPU or Execute Never (XN) default memory map access violation on an                     */
                                                                          /* instruction fetch has occurred. The fault is signalled only if the instruction is       */
                                                                          /* issued.                                                                                 */
  unsigned int mmfsr_daccviol   : BFW_NX90_cm4_scs_cfsr_mmfsr_daccviol;   /* Data access violation. The MMFAR shows the data address that the load or store          */
                                                                          /* tried to access.                                                                        */
  unsigned int reserved1        : BFW_NX90_cm4_scs_cfsr_reserved1;        /* reserved                                                                                */
  unsigned int mmfsr_munstkerr  : BFW_NX90_cm4_scs_cfsr_mmfsr_munstkerr;  /* A derived MemManage fault occurred on exception return.                                 */
  unsigned int mmfsr_mstkerr    : BFW_NX90_cm4_scs_cfsr_mmfsr_mstkerr;    /* A derived MemManage fault occurred on exception entry.                                  */
  unsigned int mmfsr_lsperr     : BFW_NX90_cm4_scs_cfsr_mmfsr_lsperr;     /* A MemManage fault occurred during FP lazy state preservation.                           */
  unsigned int reserved2        : BFW_NX90_cm4_scs_cfsr_reserved2;        /* reserved                                                                                */
  unsigned int mmfsr_mmarvalid  : BFW_NX90_cm4_scs_cfsr_mmfsr_mmarvalid;  /* MMFAR has valid contents.                                                               */
  unsigned int bfsr_ibuserr     : BFW_NX90_cm4_scs_cfsr_bfsr_ibuserr;     /* A bus fault on an instruction prefetch has occurred. The fault is signaled only if      */
                                                                          /* the instruction is issued.                                                              */
  unsigned int bfsr_preciserr   : BFW_NX90_cm4_scs_cfsr_bfsr_preciserr;   /* A precise data access error has occurred, and the processor has written the             */
                                                                          /* faulting address to the BFAR.                                                           */
  unsigned int bfsr_impreciserr : BFW_NX90_cm4_scs_cfsr_bfsr_impreciserr; /* Imprecise data access error has occurred.                                               */
  unsigned int bfsr_unstkerr    : BFW_NX90_cm4_scs_cfsr_bfsr_unstkerr;    /* A derived bus fault has occurred on exception return.                                   */
  unsigned int bfsr_stkerr      : BFW_NX90_cm4_scs_cfsr_bfsr_stkerr;      /* A derived bus fault has occurred on exception entry.                                    */
  unsigned int bfsr_lsperr      : BFW_NX90_cm4_scs_cfsr_bfsr_lsperr;      /* A bus fault occurred during FP lazy state preservation.                                 */
  unsigned int reserved3        : BFW_NX90_cm4_scs_cfsr_reserved3;        /* reserved                                                                                */
  unsigned int bfsr_bfarvalid   : BFW_NX90_cm4_scs_cfsr_bfsr_bfarvalid;   /* BFAR has valid contents.                                                                */
  unsigned int ufsr_undefinstr  : BFW_NX90_cm4_scs_cfsr_ufsr_undefinstr;  /* The processor has attempted to execute an undefined instruction. This might be          */
                                                                          /* an undefined instruction associated with an enabled coprocessor.                        */
  unsigned int ufsr_invstate    : BFW_NX90_cm4_scs_cfsr_ufsr_invstate;    /* Instruction executed with invalid EPSR.T or EPSR.IT field.                              */
  unsigned int ufsr_invpc       : BFW_NX90_cm4_scs_cfsr_ufsr_invpc;       /* An integrity check error has occurred on EXC_RETURN.                                    */
  unsigned int ufsr_nocp        : BFW_NX90_cm4_scs_cfsr_ufsr_nocp;        /* A coprocessor access error has occurred. This shows that the coprocessor is             */
                                                                          /* disabled or not present.                                                                */
  unsigned int reserved4        : BFW_NX90_cm4_scs_cfsr_reserved4;        /* reserved                                                                                */
  unsigned int ufsr_unaligned   : BFW_NX90_cm4_scs_cfsr_ufsr_unaligned;   /* Unaligned access error has occurred.                                                    */
                                                                          /* Multi-word accesses always fault if not word aligned. Software can configure unaligned  */
                                                                          /* word and halfword accesses to fault, by enabling UNALIGN_TRP in the CCR.                */
  unsigned int ufsr_divbyzero   : BFW_NX90_cm4_scs_cfsr_ufsr_divbyzero;   /* Divide by zero error has occurred.                                                      */
  unsigned int reserved5        : BFW_NX90_cm4_scs_cfsr_reserved5;        /* reserved                                                                                */
} NX90_CM4_SCS_CFSR_BIT_T;

typedef union {
  uint32_t                val;
  NX90_CM4_SCS_CFSR_BIT_T bf;
} NX90_CM4_SCS_CFSR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_hfsr */
/* => HardFault Status Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_hfsr     0x00000D2CU
#define Adr_NX90_cm4_scs_cm4_scs_hfsr 0xE000ED2CU
#define Adr_NX90_cm4_scs_hfsr         0xE000ED2CU

/* --------------------------------------------------------------------- */
/* Register cm4_scs_dfsr */
/* => Debug fault status Register */
/*    Shows which debug event occurred. */
/*    Note: Writing 1 to a register bit clears the bit to 0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_dfsr     0x00000D30U
#define Adr_NX90_cm4_scs_cm4_scs_dfsr 0xE000ED30U
#define Adr_NX90_cm4_scs_dfsr         0xE000ED30U
#define DFLT_VAL_NX90_cm4_scs_dfsr    0x00000000U

#define MSK_NX90_cm4_scs_dfsr_halted           0x00000001U
#define SRT_NX90_cm4_scs_dfsr_halted           0
#define DFLT_VAL_NX90_cm4_scs_dfsr_halted      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dfsr_halted   0x00000000U
#define MSK_NX90_cm4_scs_dfsr_bkpt             0x00000002U
#define SRT_NX90_cm4_scs_dfsr_bkpt             1
#define DFLT_VAL_NX90_cm4_scs_dfsr_bkpt        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dfsr_bkpt     0x00000000U
#define MSK_NX90_cm4_scs_dfsr_dwttrap          0x00000004U
#define SRT_NX90_cm4_scs_dfsr_dwttrap          2
#define DFLT_VAL_NX90_cm4_scs_dfsr_dwttrap     0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dfsr_dwttrap  0x00000000U
#define MSK_NX90_cm4_scs_dfsr_vcatch           0x00000008U
#define SRT_NX90_cm4_scs_dfsr_vcatch           3
#define DFLT_VAL_NX90_cm4_scs_dfsr_vcatch      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dfsr_vcatch   0x00000000U
#define MSK_NX90_cm4_scs_dfsr_external         0x00000010U
#define SRT_NX90_cm4_scs_dfsr_external         4
#define DFLT_VAL_NX90_cm4_scs_dfsr_external    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dfsr_external 0x00000000U

/* all used bits of 'NX90_cm4_scs_dfsr': */
#define MSK_USED_BITS_NX90_cm4_scs_dfsr 0x0000001fU

enum {
  BFW_NX90_cm4_scs_dfsr_halted    = 1,  /* [0] */
  BFW_NX90_cm4_scs_dfsr_bkpt      = 1,  /* [1] */
  BFW_NX90_cm4_scs_dfsr_dwttrap   = 1,  /* [2] */
  BFW_NX90_cm4_scs_dfsr_vcatch    = 1,  /* [3] */
  BFW_NX90_cm4_scs_dfsr_external  = 1,  /* [4] */
  BFW_NX90_cm4_scs_dfsr_reserved1 = 27  /* [31:5] */
};

typedef struct NX90_CM4_SCS_DFSR_BIT_Ttag {
  unsigned int halted    : BFW_NX90_cm4_scs_dfsr_halted;    /* Indicates a debug event generated by either:                                                  */
                                                            /* - A C_HALT or C_STEP request, triggered by a write to the DHCSR.                              */
                                                            /* - A step request triggered by setting DEMCR.MON_STEP to 1.                                    */
  unsigned int bkpt      : BFW_NX90_cm4_scs_dfsr_bkpt;      /* Indicates a debug event generated by BKPT instruction execution or a breakpoint match in FPB. */
  unsigned int dwttrap   : BFW_NX90_cm4_scs_dfsr_dwttrap;   /* Indicates a debug event generated by the DWT.                                                 */
  unsigned int vcatch    : BFW_NX90_cm4_scs_dfsr_vcatch;    /* Indicates triggering of a Vector catch.                                                       */
  unsigned int external  : BFW_NX90_cm4_scs_dfsr_external;  /* Indicates a debug event generated because of the assertion of an external debug request.      */
  unsigned int reserved1 : BFW_NX90_cm4_scs_dfsr_reserved1; /* reserved                                                                                      */
} NX90_CM4_SCS_DFSR_BIT_T;

typedef union {
  uint32_t                val;
  NX90_CM4_SCS_DFSR_BIT_T bf;
} NX90_CM4_SCS_DFSR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_mmfar */
/* => MemManage Faul Address Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_mmfar     0x00000D34U
#define Adr_NX90_cm4_scs_cm4_scs_mmfar 0xE000ED34U
#define Adr_NX90_cm4_scs_mmfar         0xE000ED34U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_bfar */
/* => BusFault Address Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_bfar     0x00000D38U
#define Adr_NX90_cm4_scs_cm4_scs_bfar 0xE000ED38U
#define Adr_NX90_cm4_scs_bfar         0xE000ED38U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_afsr */
/* => Auxiliary Fault Status Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_afsr     0x00000D3CU
#define Adr_NX90_cm4_scs_cm4_scs_afsr 0xE000ED3CU
#define Adr_NX90_cm4_scs_afsr         0xE000ED3CU

/* --------------------------------------------------------------------- */
/* Register cm4_scs_cpacr */
/* => Coprocessor Access Control Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_cpacr     0x00000D88U
#define Adr_NX90_cm4_scs_cm4_scs_cpacr 0xE000ED88U
#define Adr_NX90_cm4_scs_cpacr         0xE000ED88U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_dhcsr */
/* => Debug halting control and status register */
/*    Controls halting debug. */
/*    Note: On writes bits 31-16 (dbgkey) must be set to 0xA05F. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_dhcsr     0x00000DF0U
#define Adr_NX90_cm4_scs_cm4_scs_dhcsr 0xE000EDF0U
#define Adr_NX90_cm4_scs_dhcsr         0xE000EDF0U
#define DFLT_VAL_NX90_cm4_scs_dhcsr    0x00000000U

#define MSK_NX90_cm4_scs_dhcsr_c_debugen           0x00000001U
#define SRT_NX90_cm4_scs_dhcsr_c_debugen           0
#define DFLT_VAL_NX90_cm4_scs_dhcsr_c_debugen      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_c_debugen   0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_c_halt              0x00000002U
#define SRT_NX90_cm4_scs_dhcsr_c_halt              1
#define DFLT_VAL_NX90_cm4_scs_dhcsr_c_halt         0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_c_halt      0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_c_step              0x00000004U
#define SRT_NX90_cm4_scs_dhcsr_c_step              2
#define DFLT_VAL_NX90_cm4_scs_dhcsr_c_step         0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_c_step      0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_c_maskints          0x00000008U
#define SRT_NX90_cm4_scs_dhcsr_c_maskints          3
#define DFLT_VAL_NX90_cm4_scs_dhcsr_c_maskints     0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_c_maskints  0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_c_snapstall         0x00000020U
#define SRT_NX90_cm4_scs_dhcsr_c_snapstall         5
#define DFLT_VAL_NX90_cm4_scs_dhcsr_c_snapstall    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_c_snapstall 0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_s_regrdy            0x00010000U
#define SRT_NX90_cm4_scs_dhcsr_s_regrdy            16
#define DFLT_VAL_NX90_cm4_scs_dhcsr_s_regrdy       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_s_regrdy    0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_s_halt              0x00020000U
#define SRT_NX90_cm4_scs_dhcsr_s_halt              17
#define DFLT_VAL_NX90_cm4_scs_dhcsr_s_halt         0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_s_halt      0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_s_sleep             0x00040000U
#define SRT_NX90_cm4_scs_dhcsr_s_sleep             18
#define DFLT_VAL_NX90_cm4_scs_dhcsr_s_sleep        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_s_sleep     0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_s_lockup            0x00080000U
#define SRT_NX90_cm4_scs_dhcsr_s_lockup            19
#define DFLT_VAL_NX90_cm4_scs_dhcsr_s_lockup       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_s_lockup    0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_s_retire_st         0x01000000U
#define SRT_NX90_cm4_scs_dhcsr_s_retire_st         24
#define DFLT_VAL_NX90_cm4_scs_dhcsr_s_retire_st    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_s_retire_st 0x00000000U
#define MSK_NX90_cm4_scs_dhcsr_s_reset_st          0x02000000U
#define SRT_NX90_cm4_scs_dhcsr_s_reset_st          25
#define DFLT_VAL_NX90_cm4_scs_dhcsr_s_reset_st     0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dhcsr_s_reset_st  0x00000000U

/* all used bits of 'NX90_cm4_scs_dhcsr': */
#define MSK_USED_BITS_NX90_cm4_scs_dhcsr 0x030f002fU

enum {
  BFW_NX90_cm4_scs_dhcsr_c_debugen   = 1,  /* [0] */
  BFW_NX90_cm4_scs_dhcsr_c_halt      = 1,  /* [1] */
  BFW_NX90_cm4_scs_dhcsr_c_step      = 1,  /* [2] */
  BFW_NX90_cm4_scs_dhcsr_c_maskints  = 1,  /* [3] */
  BFW_NX90_cm4_scs_dhcsr_reserved1   = 1,  /* [4] */
  BFW_NX90_cm4_scs_dhcsr_c_snapstall = 1,  /* [5] */
  BFW_NX90_cm4_scs_dhcsr_reserved2   = 10, /* [15:6] */
  BFW_NX90_cm4_scs_dhcsr_s_regrdy    = 1,  /* [16] */
  BFW_NX90_cm4_scs_dhcsr_s_halt      = 1,  /* [17] */
  BFW_NX90_cm4_scs_dhcsr_s_sleep     = 1,  /* [18] */
  BFW_NX90_cm4_scs_dhcsr_s_lockup    = 1,  /* [19] */
  BFW_NX90_cm4_scs_dhcsr_reserved3   = 4,  /* [23:20] */
  BFW_NX90_cm4_scs_dhcsr_s_retire_st = 1,  /* [24] */
  BFW_NX90_cm4_scs_dhcsr_s_reset_st  = 1,  /* [25] */
  BFW_NX90_cm4_scs_dhcsr_reserved4   = 6   /* [31:26] */
};

typedef struct NX90_CM4_SCS_DHCSR_BIT_Ttag {
  unsigned int c_debugen   : BFW_NX90_cm4_scs_dhcsr_c_debugen;   /* Halting debug enable bit.                                                                         */
                                                                 /* If a debugger writes to DHCSR to change the value of this bit from 0 to 1, it must also write     */
                                                                 /* 0 to the C_MASKINTS bit, otherwise behavior is UNPREDICTABLE.                                     */
                                                                 /* This bit can only be written by the DAP, it ignores writes from software.                         */
  unsigned int c_halt      : BFW_NX90_cm4_scs_dhcsr_c_halt;      /* Processor halt bit. The effects of writes to this bit are:                                        */
                                                                 /* - 0: Causes the processor to leave Debug state, if in Debug state.                                */
                                                                 /* - 1: Halt the processor.                                                                          */
                                                                 /* This bit is UNKNOWN after a Power-on reset, and is 0 after a Local reset.                         */
  unsigned int c_step      : BFW_NX90_cm4_scs_dhcsr_c_step;      /* Processor step bit. The effects of writes to this bit are:                                        */
                                                                 /* - 0: No effect.                                                                                   */
                                                                 /* - 1: Single step enabled.                                                                         */
                                                                 /* This bit is UNKNOWN after a Power-on reset.                                                       */
  unsigned int c_maskints  : BFW_NX90_cm4_scs_dhcsr_c_maskints;  /* When debug is enabled, the debugger can write to this bit to mask PendSV, SysTick and             */
                                                                 /* external configurable interrupts:                                                                 */
                                                                 /* - 0: Do not mask.                                                                                 */
                                                                 /* - 1: Mask PendSV, SysTick and external configurable interrupts.                                   */
                                                                 /* The effect of any attempt to change the value of this bit is UNPREDICTABLE unless both:           */
                                                                 /* - Before the write to DHCSR, the value of the C_HALT bit is 1.                                    */
                                                                 /* - The write to the DHCSR that changes the C_MASKINTS bit also writes 1 to the                     */
                                                                 /* C_HALT bit.                                                                                       */
                                                                 /* This means that a single write to DHCSR cannot set the C_HALT to 0 and change the value           */
                                                                 /* of the C_MASKINTS bit.                                                                            */
                                                                 /* The bit does not affect NMI. When DHCSR.C_DEBUGEN is set to 0, the value of this bit              */
                                                                 /* is UNKNOWN.                                                                                       */
                                                                 /* This bit is UNKNOWN after a Power-on reset.                                                       */
  unsigned int reserved1   : BFW_NX90_cm4_scs_dhcsr_reserved1;   /* reserved                                                                                          */
  unsigned int c_snapstall : BFW_NX90_cm4_scs_dhcsr_c_snapstall; /* Allow imprecise entry to Debug state. The actions on writing to this bit are:                     */
                                                                 /* - 0: No action.                                                                                   */
                                                                 /* - 1: Allow imprecise entry to Debug state, for example by forcing any stalled load                */
                                                                 /* or store instruction to complete.                                                                 */
                                                                 /* Setting this bit to 1 allows a debugger to request imprecise entry to Debug state.                */
                                                                 /* The effect of setting this bit to 1 is UNPREDICTABLE unless the DHCSR write also sets             */
                                                                 /* C_DEBUGEN and C_HALT to 1. This means that if the processor is not already in Debug               */
                                                                 /* stateit enters Debug state when the stalled instruction completes.                                */
                                                                 /* Writing 1 to this bit makes the state of the memory system UNPREDICTABLE. Therefore, if a         */
                                                                 /* debugger writes 1 to this bit it must reset the processor before leaving Debug state.             */
                                                                 /* Note:                                                                                             */
                                                                 /* - A debugger can write to the DHCSR to clear this bit to 0. However, this does not                */
                                                                 /* remove the UNPREDICTABLE state of the memory system caused by setting                             */
                                                                 /* C_SNAPSTALL to 1.                                                                                 */
                                                                 /* - The architecture does not guarantee that setting this bit to 1 will force entry to Debug        */
                                                                 /* state.                                                                                            */
                                                                 /* - ARM strongly recommends that a value of 1 is never written to C_SNAPSTALL                       */
                                                                 /* when the processor is in Debug state.                                                             */
  unsigned int reserved2   : BFW_NX90_cm4_scs_dhcsr_reserved2;   /* reserved                                                                                          */
  unsigned int s_regrdy    : BFW_NX90_cm4_scs_dhcsr_s_regrdy;    /* A handshake flag for transfers through the DCRDR:                                                 */
                                                                 /* - Writing to DCRSR clears the bit to 0.                                                           */
                                                                 /* - Completion of the DCRDR transfer then sets the bit to 1.                                        */
                                                                 /* For more information about DCRDR transfers see Debug Core Register Data Register, DCRDR.          */
                                                                 /* This bit is valid only when the processor is in Debug state, otherwise the bit is UNKNOWN.        */
                                                                 /* This bit is read-only.                                                                            */
  unsigned int s_halt      : BFW_NX90_cm4_scs_dhcsr_s_halt;      /* Indicates whether the processor is in Debug state.                                                */
                                                                 /* This bit is read-only.                                                                            */
  unsigned int s_sleep     : BFW_NX90_cm4_scs_dhcsr_s_sleep;     /* Indicates whether the processor is sleeping.                                                      */
                                                                 /* The debugger must set the C_HALT bit to 1 to gain control, or wait for an interrupt or other      */
                                                                 /* wakeup event to wakeup the system.                                                                */
                                                                 /* This bit is read-only.                                                                            */
  unsigned int s_lockup    : BFW_NX90_cm4_scs_dhcsr_s_lockup;    /* Indicates whether the processor is locked up because of an unrecoverable exception.               */
                                                                 /* This bit can only be read as 1 by a remote debugger, using the DAP. The value of 1 indicates      */
                                                                 /* that the processor is running but locked up.                                                      */
                                                                 /* The bit clears to 0 when the processor enters Debug state.                                        */
                                                                 /* This bit is read-only.                                                                            */
  unsigned int reserved3   : BFW_NX90_cm4_scs_dhcsr_reserved3;   /* reserved                                                                                          */
  unsigned int s_retire_st : BFW_NX90_cm4_scs_dhcsr_s_retire_st; /* Set to 1 every time the processor retires one or more instructions.                               */
                                                                 /* This is a sticky bit, that clears to 0 on a read of DHCSR.                                        */
                                                                 /* The architecture does not define precisely when this bit is set to 1. It requires only that this  */
                                                                 /* happen periodically in Non-debug state to indicate that software execution is progressing.        */
                                                                 /* This bit is UNKNOWN after a Power-on or Local reset, but then is set to 1 as soon as the          */
                                                                 /* processor executes and retires an instruction.                                                    */
                                                                 /* This bit is read-only.                                                                            */
  unsigned int s_reset_st  : BFW_NX90_cm4_scs_dhcsr_s_reset_st;  /* Indicates whether the processor has been reset since the last read of DHCSR.                      */
                                                                 /* This is a sticky bit, that clears to 0 on a read of DHCSR. This bit is read-only.                 */
  unsigned int reserved4   : BFW_NX90_cm4_scs_dhcsr_reserved4;   /* reserved                                                                                          */
} NX90_CM4_SCS_DHCSR_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_DHCSR_BIT_T bf;
} NX90_CM4_SCS_DHCSR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_dcrsr */
/* => Debug core register selector register */
/*    With the DCRDR, the DCRSR provides debug access to the ARM core registers, special-purpose registers, and \ */
/*    Floating-point extension registers. A write to DCRSR specifies the register to transfer, \ */
/*    whether the transfer is a read or a write, and starts the transfer. */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_dcrsr     0x00000DF4U
#define Adr_NX90_cm4_scs_cm4_scs_dcrsr 0xE000EDF4U
#define Adr_NX90_cm4_scs_dcrsr         0xE000EDF4U
#define DFLT_VAL_NX90_cm4_scs_dcrsr    0x00000000U

#define MSK_NX90_cm4_scs_dcrsr_regsel         0x0000007fU
#define SRT_NX90_cm4_scs_dcrsr_regsel         0
#define DFLT_VAL_NX90_cm4_scs_dcrsr_regsel    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dcrsr_regsel 0x00000000U
#define MSK_NX90_cm4_scs_dcrsr_regwnr         0x00010000U
#define SRT_NX90_cm4_scs_dcrsr_regwnr         16
#define DFLT_VAL_NX90_cm4_scs_dcrsr_regwnr    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dcrsr_regwnr 0x00000000U

/* all used bits of 'NX90_cm4_scs_dcrsr': */
#define MSK_USED_BITS_NX90_cm4_scs_dcrsr 0x0001007fU

enum {
  BFW_NX90_cm4_scs_dcrsr_regsel    = 7,  /* [6:0] */
  BFW_NX90_cm4_scs_dcrsr_reserved1 = 9,  /* [15:7] */
  BFW_NX90_cm4_scs_dcrsr_regwnr    = 1,  /* [16] */
  BFW_NX90_cm4_scs_dcrsr_reserved2 = 15  /* [31:17] */
};

typedef struct NX90_CM4_SCS_DCRSR_BIT_Ttag {
  unsigned int regsel    : BFW_NX90_cm4_scs_dcrsr_regsel;    /* Specifies the ARM core register, special-purpose register, or Floating-point extension              */
                                                             /* register, to transfer:                                                                              */
                                                             /* {         |                                                                                         */
                                                             /*   0 - 12    ARM core registers R0-R12.                                                              */
                                                             /*       13    The current SP. See also values 17 (MSP) and 18 (PSP).                                  */
                                                             /*       14    LR.                                                                                     */
                                                             /*       15    DebugReturnAddress.                                                                     */
                                                             /*       16    xPSR.                                                                                   */
                                                             /*       17    Main stack pointer, MSP.                                                                */
                                                             /*       18    Process stack pointer, PSP.                                                             */
                                                             /*       20    Bits[31:24]: CONTROL, Bits[23:16]: FAULTMASK, Bits[15:8]: BASEPRI, Bits[7:0]: PRIMASK.  */
                                                             /*             In each field, the valid bits are packed with leading zeros. For example,               */
                                                             /*             FAULTMASK is always a single bit, DCRDR[16], and DCRDR[23:17] is 0.                     */
                                                             /*       33    Floating-point Status and Control Register, FPSCR.                                      */
                                                             /*   64 - 95   FP registers S0-S31.                                                                    */
                                                             /* }                                                                                                   */
                                                             /* All other values are Reserved.                                                                      */
                                                             /* If the processor does not implement the FP extension the REGSEL field is bits[4:0], and             */
                                                             /* bits[6:5] are Reserved, SBZ.                                                                        */
  unsigned int reserved1 : BFW_NX90_cm4_scs_dcrsr_reserved1; /* reserved                                                                                            */
  unsigned int regwnr    : BFW_NX90_cm4_scs_dcrsr_regwnr;    /* Specifies the access type for the transfer:                                                         */
                                                             /* 0 : Read.                                                                                           */
                                                             /* 1 : Write.                                                                                          */
  unsigned int reserved2 : BFW_NX90_cm4_scs_dcrsr_reserved2; /* reserved                                                                                            */
} NX90_CM4_SCS_DCRSR_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_DCRSR_BIT_T bf;
} NX90_CM4_SCS_DCRSR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_dcrdr */
/* => Debug core register data register */
/*    With the DCRSR, the DCRDR provides debug access to the ARM core registers, \ */
/*    special-purpose registers, and Floating-point extension registers. The DCRDR is the \ */
/*    data register for these accesses. */
/*    Used on its own, the DCRDR provides a message passing resource between an \ */
/*    external debugger and a debug agent running on the processor. */
/*    Note: The architecture does not define any handshaking mechanism for this use of DCRDR. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_dcrdr     0x00000DF8U
#define Adr_NX90_cm4_scs_cm4_scs_dcrdr 0xE000EDF8U
#define Adr_NX90_cm4_scs_dcrdr         0xE000EDF8U
#define DFLT_VAL_NX90_cm4_scs_dcrdr    0x00000000U

#define MSK_NX90_cm4_scs_dcrdr_dbgtmp         0xffffffffU
#define SRT_NX90_cm4_scs_dcrdr_dbgtmp         0
#define DFLT_VAL_NX90_cm4_scs_dcrdr_dbgtmp    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_dcrdr_dbgtmp 0x00000000U

/* all used bits of 'NX90_cm4_scs_dcrdr': */
#define MSK_USED_BITS_NX90_cm4_scs_dcrdr 0xffffffffU

enum {
  BFW_NX90_cm4_scs_dcrdr_dbgtmp = 32  /* [31:0] */
};

typedef struct NX90_CM4_SCS_DCRDR_BIT_Ttag {
  unsigned int dbgtmp : BFW_NX90_cm4_scs_dcrdr_dbgtmp; /* Data temporary cache, for reading and writing the ARM core registers, special-purpose  */
                                                       /* registers, and Floating-point extension registers.                                     */
} NX90_CM4_SCS_DCRDR_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_DCRDR_BIT_T bf;
} NX90_CM4_SCS_DCRDR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_demcr */
/* => Debug exception and monitor control register */
/*    Manages vector catch behavior and DebugMonitor handling when debugging. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_demcr     0x00000DFCU
#define Adr_NX90_cm4_scs_cm4_scs_demcr 0xE000EDFCU
#define Adr_NX90_cm4_scs_demcr         0xE000EDFCU
#define DFLT_VAL_NX90_cm4_scs_demcr    0x00000000U

#define MSK_NX90_cm4_scs_demcr_vc_corereset         0x00000001U
#define SRT_NX90_cm4_scs_demcr_vc_corereset         0
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_corereset    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_corereset 0x00000000U
#define MSK_NX90_cm4_scs_demcr_vc_mmerr             0x00000010U
#define SRT_NX90_cm4_scs_demcr_vc_mmerr             4
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_mmerr        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_mmerr     0x00000000U
#define MSK_NX90_cm4_scs_demcr_vc_nocperr           0x00000020U
#define SRT_NX90_cm4_scs_demcr_vc_nocperr           5
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_nocperr      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_nocperr   0x00000000U
#define MSK_NX90_cm4_scs_demcr_vc_chkerr            0x00000040U
#define SRT_NX90_cm4_scs_demcr_vc_chkerr            6
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_chkerr       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_chkerr    0x00000000U
#define MSK_NX90_cm4_scs_demcr_vc_staterr           0x00000080U
#define SRT_NX90_cm4_scs_demcr_vc_staterr           7
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_staterr      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_staterr   0x00000000U
#define MSK_NX90_cm4_scs_demcr_vc_buserr            0x00000100U
#define SRT_NX90_cm4_scs_demcr_vc_buserr            8
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_buserr       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_buserr    0x00000000U
#define MSK_NX90_cm4_scs_demcr_vc_interr            0x00000200U
#define SRT_NX90_cm4_scs_demcr_vc_interr            9
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_interr       0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_interr    0x00000000U
#define MSK_NX90_cm4_scs_demcr_vc_harderr           0x00000400U
#define SRT_NX90_cm4_scs_demcr_vc_harderr           10
#define DFLT_VAL_NX90_cm4_scs_demcr_vc_harderr      0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_vc_harderr   0x00000000U
#define MSK_NX90_cm4_scs_demcr_mon_en               0x00010000U
#define SRT_NX90_cm4_scs_demcr_mon_en               16
#define DFLT_VAL_NX90_cm4_scs_demcr_mon_en          0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_mon_en       0x00000000U
#define MSK_NX90_cm4_scs_demcr_mon_pend             0x00020000U
#define SRT_NX90_cm4_scs_demcr_mon_pend             17
#define DFLT_VAL_NX90_cm4_scs_demcr_mon_pend        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_mon_pend     0x00000000U
#define MSK_NX90_cm4_scs_demcr_mon_step             0x00040000U
#define SRT_NX90_cm4_scs_demcr_mon_step             18
#define DFLT_VAL_NX90_cm4_scs_demcr_mon_step        0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_mon_step     0x00000000U
#define MSK_NX90_cm4_scs_demcr_mon_req              0x00080000U
#define SRT_NX90_cm4_scs_demcr_mon_req              19
#define DFLT_VAL_NX90_cm4_scs_demcr_mon_req         0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_mon_req      0x00000000U
#define MSK_NX90_cm4_scs_demcr_trcena               0x01000000U
#define SRT_NX90_cm4_scs_demcr_trcena               24
#define DFLT_VAL_NX90_cm4_scs_demcr_trcena          0x00000000U
#define DFLT_BF_VAL_NX90_cm4_scs_demcr_trcena       0x00000000U

/* all used bits of 'NX90_cm4_scs_demcr': */
#define MSK_USED_BITS_NX90_cm4_scs_demcr 0x010f07f1U

enum {
  BFW_NX90_cm4_scs_demcr_vc_corereset = 1, /* [0] */
  BFW_NX90_cm4_scs_demcr_reserved1    = 3, /* [3:1] */
  BFW_NX90_cm4_scs_demcr_vc_mmerr     = 1, /* [4] */
  BFW_NX90_cm4_scs_demcr_vc_nocperr   = 1, /* [5] */
  BFW_NX90_cm4_scs_demcr_vc_chkerr    = 1, /* [6] */
  BFW_NX90_cm4_scs_demcr_vc_staterr   = 1, /* [7] */
  BFW_NX90_cm4_scs_demcr_vc_buserr    = 1, /* [8] */
  BFW_NX90_cm4_scs_demcr_vc_interr    = 1, /* [9] */
  BFW_NX90_cm4_scs_demcr_vc_harderr   = 1, /* [10] */
  BFW_NX90_cm4_scs_demcr_reserved2    = 5, /* [15:11] */
  BFW_NX90_cm4_scs_demcr_mon_en       = 1, /* [16] */
  BFW_NX90_cm4_scs_demcr_mon_pend     = 1, /* [17] */
  BFW_NX90_cm4_scs_demcr_mon_step     = 1, /* [18] */
  BFW_NX90_cm4_scs_demcr_mon_req      = 1, /* [19] */
  BFW_NX90_cm4_scs_demcr_reserved3    = 4, /* [23:20] */
  BFW_NX90_cm4_scs_demcr_trcena       = 1, /* [24] */
  BFW_NX90_cm4_scs_demcr_reserved4    = 7  /* [31:25] */
};

typedef struct NX90_CM4_SCS_DEMCR_BIT_Ttag {
  unsigned int vc_corereset : BFW_NX90_cm4_scs_demcr_vc_corereset; /* Enable Reset Vector Catch. This causes a Local reset to halt a running system.                    */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int reserved1    : BFW_NX90_cm4_scs_demcr_reserved1;    /* reserved                                                                                          */
  unsigned int vc_mmerr     : BFW_NX90_cm4_scs_demcr_vc_mmerr;     /* Enable halting debug trap on a MemManage exception.                                               */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int vc_nocperr   : BFW_NX90_cm4_scs_demcr_vc_nocperr;   /* Enable halting debug trap on a UsageFault caused by an access to a Coprocessor.                   */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int vc_chkerr    : BFW_NX90_cm4_scs_demcr_vc_chkerr;    /* Enable halting debug trap on a UsageFault exception caused by a checking error, for               */
                                                                   /* example an alignment check error.                                                                 */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int vc_staterr   : BFW_NX90_cm4_scs_demcr_vc_staterr;   /* Enable halting debug trap on a UsageFault exception caused by a state information error,          */
                                                                   /* for example an Undefined Instruction exception.                                                   */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int vc_buserr    : BFW_NX90_cm4_scs_demcr_vc_buserr;    /* Enable halting debug trap on a BusFault exception.                                                */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int vc_interr    : BFW_NX90_cm4_scs_demcr_vc_interr;    /* Enable halting debug trap on a fault occurring during exception entry or exception return.        */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int vc_harderr   : BFW_NX90_cm4_scs_demcr_vc_harderr;   /* Enable halting debug trap on a HardFault exception.                                               */
                                                                   /* If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit.                      */
  unsigned int reserved2    : BFW_NX90_cm4_scs_demcr_reserved2;    /* reserved                                                                                          */
  unsigned int mon_en       : BFW_NX90_cm4_scs_demcr_mon_en;       /* Enable the DebugMonitor exception.                                                                */
                                                                   /* If DHCSR.C_DEBUGEN is set to 1, the processor ignores the value of this bit.                      */
  unsigned int mon_pend     : BFW_NX90_cm4_scs_demcr_mon_pend;     /* Sets or clears the pending state of the DebugMonitor exception:                                   */
                                                                   /* - 0: Clear the status of the DebugMonitor exception to not pending.                               */
                                                                   /* - 1: Set the status of the DebugMonitor exception to pending.                                     */
                                                                   /* When the DebugMonitor exception is pending it becomes active subject to the exception             */
                                                                   /* priority rules. A debugger can use this bit to wakeup the monitor using the DAP.                  */
                                                                   /* The effect of setting this bit to 1 is not affected by the value of the MON_EN bit. A debugger    */
                                                                   /* can set MON_PEND to 1, and force the processor to take a DebugMonitor exception, even             */
                                                                   /* when MON_EN is set to 0.                                                                          */
  unsigned int mon_step     : BFW_NX90_cm4_scs_demcr_mon_step;     /* When MON_EN is set to 0, this feature is disabled and the processor ignores MON_STEP.             */
                                                                   /* When MON_EN is set to 1, the meaning of MON_STEP is:                                              */
                                                                   /* - 0: Do not step the processor.                                                                   */
                                                                   /* - 1: Step the processor.                                                                          */
                                                                   /* Setting this bit to 1 makes the step request pending.                                             */
                                                                   /* The effect of changing this bit at an execution priority that is lower than the priority of the   */
                                                                   /* DebugMonitor exception is UNPREDICTABLE.                                                          */
  unsigned int mon_req      : BFW_NX90_cm4_scs_demcr_mon_req;      /* DebugMonitor semaphore bit. The processor does not use this bit. The monitor software             */
                                                                   /* defines the meaning and use of this bit.                                                          */
  unsigned int reserved3    : BFW_NX90_cm4_scs_demcr_reserved3;    /* reserved                                                                                          */
  unsigned int trcena       : BFW_NX90_cm4_scs_demcr_trcena;       /* Global enable for all DWT and ITM features:                                                       */
                                                                   /* - 0: DWT and ITM units disabled.                                                                  */
                                                                   /* - 1: DWT and ITM units enabled.                                                                   */
                                                                   /* If the DWT and ITM units are not implemented, this bit is UNK/SBZP.                               */
                                                                   /* When TRCENA is set to 0:                                                                          */
                                                                   /* - DWT registers return UNKNOWN values on reads. Whether the processor ignores                     */
                                                                   /* writes to the DWT unit is IMPLEMENTATION DEFINED.                                                 */
                                                                   /* - ITM registers return UNKNOWN values on reads. Whether the processor ignores                     */
                                                                   /* writes to the ITM unit is IMPLEMENTATION DEFINED.                                                 */
                                                                   /* Setting this bit to 0 might not stop all events. To ensure all events are stopped, software must  */
                                                                   /* set all DWT and ITM feature enable bits to 0, and then set this bit to 0.                         */
  unsigned int reserved4    : BFW_NX90_cm4_scs_demcr_reserved4;    /* reserved                                                                                          */
} NX90_CM4_SCS_DEMCR_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_DEMCR_BIT_T bf;
} NX90_CM4_SCS_DEMCR_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_pidr4 */
/* => Peripheral ID Register 4 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_pidr4     0x00000FD0U
#define Adr_NX90_cm4_scs_cm4_scs_pidr4 0xE000EFD0U
#define Adr_NX90_cm4_scs_pidr4         0xE000EFD0U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_pidr0 */
/* => Peripheral ID Register 0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_pidr0     0x00000FE0U
#define Adr_NX90_cm4_scs_cm4_scs_pidr0 0xE000EFE0U
#define Adr_NX90_cm4_scs_pidr0         0xE000EFE0U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_pidr1 */
/* => Peripheral ID Register 1 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_pidr1     0x00000FE4U
#define Adr_NX90_cm4_scs_cm4_scs_pidr1 0xE000EFE4U
#define Adr_NX90_cm4_scs_pidr1         0xE000EFE4U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_pidr2 */
/* => Peripheral ID Register 2 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_pidr2     0x00000FE8U
#define Adr_NX90_cm4_scs_cm4_scs_pidr2 0xE000EFE8U
#define Adr_NX90_cm4_scs_pidr2         0xE000EFE8U

/* --------------------------------------------------------------------- */
/* Register cm4_scs_pidr3 */
/* => Peripheral ID Register 3 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_pidr3     0x00000FECU
#define Adr_NX90_cm4_scs_cm4_scs_pidr3 0xE000EFECU
#define Adr_NX90_cm4_scs_pidr3         0xE000EFECU

/* --------------------------------------------------------------------- */
/* Register cm4_scs_cidr0 */
/* => Component ID Register 0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_cidr0     0x00000FF0U
#define Adr_NX90_cm4_scs_cm4_scs_cidr0 0xE000EFF0U
#define Adr_NX90_cm4_scs_cidr0         0xE000EFF0U

#define MSK_NX90_cm4_scs_cidr0_prmbl_0 0x000000ffU
#define SRT_NX90_cm4_scs_cidr0_prmbl_0 0

/* all used bits of 'NX90_cm4_scs_cidr0': */
#define MSK_USED_BITS_NX90_cm4_scs_cidr0 0x000000ffU

enum {
  BFW_NX90_cm4_scs_cidr0_prmbl_0   = 8,  /* [7:0] */
  BFW_NX90_cm4_scs_cidr0_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CM4_SCS_CIDR0_BIT_Ttag {
  unsigned int prmbl_0   : BFW_NX90_cm4_scs_cidr0_prmbl_0;   /* Preamble byte 0. */
  unsigned int reserved1 : BFW_NX90_cm4_scs_cidr0_reserved1; /* reserved         */
} NX90_CM4_SCS_CIDR0_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_CIDR0_BIT_T bf;
} NX90_CM4_SCS_CIDR0_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_cidr1 */
/* => Component ID Register 1 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_cidr1     0x00000FF4U
#define Adr_NX90_cm4_scs_cm4_scs_cidr1 0xE000EFF4U
#define Adr_NX90_cm4_scs_cidr1         0xE000EFF4U

#define MSK_NX90_cm4_scs_cidr1_prmbl_1 0x0000000fU
#define SRT_NX90_cm4_scs_cidr1_prmbl_1 0
#define MSK_NX90_cm4_scs_cidr1_cclass  0x000000f0U
#define SRT_NX90_cm4_scs_cidr1_cclass  4

/* all used bits of 'NX90_cm4_scs_cidr1': */
#define MSK_USED_BITS_NX90_cm4_scs_cidr1 0x000000ffU

enum {
  BFW_NX90_cm4_scs_cidr1_prmbl_1   = 4,  /* [3:0] */
  BFW_NX90_cm4_scs_cidr1_cclass    = 4,  /* [7:4] */
  BFW_NX90_cm4_scs_cidr1_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CM4_SCS_CIDR1_BIT_Ttag {
  unsigned int prmbl_1   : BFW_NX90_cm4_scs_cidr1_prmbl_1;   /* Preamble bits[11:8]. */
  unsigned int cclass    : BFW_NX90_cm4_scs_cidr1_cclass;    /* Component class.     */
  unsigned int reserved1 : BFW_NX90_cm4_scs_cidr1_reserved1; /* reserved             */
} NX90_CM4_SCS_CIDR1_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_CIDR1_BIT_T bf;
} NX90_CM4_SCS_CIDR1_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_cidr2 */
/* => Component ID Register 2 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_cidr2     0x00000FF8U
#define Adr_NX90_cm4_scs_cm4_scs_cidr2 0xE000EFF8U
#define Adr_NX90_cm4_scs_cidr2         0xE000EFF8U

#define MSK_NX90_cm4_scs_cidr2_prmbl_2 0x000000ffU
#define SRT_NX90_cm4_scs_cidr2_prmbl_2 0

/* all used bits of 'NX90_cm4_scs_cidr2': */
#define MSK_USED_BITS_NX90_cm4_scs_cidr2 0x000000ffU

enum {
  BFW_NX90_cm4_scs_cidr2_prmbl_2   = 8,  /* [7:0] */
  BFW_NX90_cm4_scs_cidr2_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CM4_SCS_CIDR2_BIT_Ttag {
  unsigned int prmbl_2   : BFW_NX90_cm4_scs_cidr2_prmbl_2;   /* Preamble byte 2. */
  unsigned int reserved1 : BFW_NX90_cm4_scs_cidr2_reserved1; /* reserved         */
} NX90_CM4_SCS_CIDR2_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_CIDR2_BIT_T bf;
} NX90_CM4_SCS_CIDR2_T;

/* --------------------------------------------------------------------- */
/* Register cm4_scs_cidr3 */
/* => Component ID Register 3 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_scs_cidr3     0x00000FFCU
#define Adr_NX90_cm4_scs_cm4_scs_cidr3 0xE000EFFCU
#define Adr_NX90_cm4_scs_cidr3         0xE000EFFCU

#define MSK_NX90_cm4_scs_cidr3_prmbl_3 0x000000ffU
#define SRT_NX90_cm4_scs_cidr3_prmbl_3 0

/* all used bits of 'NX90_cm4_scs_cidr3': */
#define MSK_USED_BITS_NX90_cm4_scs_cidr3 0x000000ffU

enum {
  BFW_NX90_cm4_scs_cidr3_prmbl_3   = 8,  /* [7:0] */
  BFW_NX90_cm4_scs_cidr3_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CM4_SCS_CIDR3_BIT_Ttag {
  unsigned int prmbl_3   : BFW_NX90_cm4_scs_cidr3_prmbl_3;   /* Preamble byte 3. */
  unsigned int reserved1 : BFW_NX90_cm4_scs_cidr3_reserved1; /* reserved         */
} NX90_CM4_SCS_CIDR3_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CM4_SCS_CIDR3_BIT_T bf;
} NX90_CM4_SCS_CIDR3_T;


/* ===================================================================== */

/* Area of cm4_etm */

/* ===================================================================== */

#define Addr_NX90_cm4_etm 0xE0041000U

/* ===================================================================== */

/* Area of cm4_cti */

/* ===================================================================== */

#define Addr_NX90_cm4_cti 0xE0042000U

/* ===================================================================== */

/* Area of cm4_misc_ctrl */

/* ===================================================================== */

#define Addr_NX90_cm4_misc_ctrl 0xE0043000U

/* --------------------------------------------------------------------- */
/* Register cm4_misc_ctrl_cpu_info */
/* => CPU information register */
/*    Provides a processor identification mechanism to distinguish between Com ARM and App ARM. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_misc_ctrl_cpu_info           0x00000000U
#define Adr_NX90_cm4_misc_ctrl_cm4_misc_ctrl_cpu_info 0xE0043000U
#define Adr_NX90_cm4_misc_ctrl_cpu_info               0xE0043000U

#define MSK_NX90_cm4_misc_ctrl_cpu_info_id  0x00000001U
#define SRT_NX90_cm4_misc_ctrl_cpu_info_id  0
#define MSK_NX90_cm4_misc_ctrl_cpu_info_fpu 0x00000002U
#define SRT_NX90_cm4_misc_ctrl_cpu_info_fpu 1

/* all used bits of 'NX90_cm4_misc_ctrl_cpu_info': */
#define MSK_USED_BITS_NX90_cm4_misc_ctrl_cpu_info 0x00000003U

enum {
  BFW_NX90_cm4_misc_ctrl_cpu_info_id        = 1,  /* [0] */
  BFW_NX90_cm4_misc_ctrl_cpu_info_fpu       = 1,  /* [1] */
  BFW_NX90_cm4_misc_ctrl_cpu_info_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_CM4_MISC_CTRL_CPU_INFO_BIT_Ttag {
  unsigned int id        : BFW_NX90_cm4_misc_ctrl_cpu_info_id;        /* CPU identification                                                            */
                                                                      /* 0: Com ARM                                                                    */
                                                                      /* 1: App ARM                                                                    */
  unsigned int fpu       : BFW_NX90_cm4_misc_ctrl_cpu_info_fpu;       /* CPU has FPU                                                                   */
                                                                      /* If '0' all cm4_misc_ctrl_fpu_* registers have no effect and are read as zero. */
  unsigned int reserved1 : BFW_NX90_cm4_misc_ctrl_cpu_info_reserved1; /* reserved                                                                      */
} NX90_CM4_MISC_CTRL_CPU_INFO_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_CM4_MISC_CTRL_CPU_INFO_BIT_T bf;
} NX90_CM4_MISC_CTRL_CPU_INFO_T;

/* --------------------------------------------------------------------- */
/* Register cm4_misc_ctrl_fpu_irq_raw */
/* => FPU raw IRQ */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/*    Note: Before clearing an IRQ in this register, the corresponding exception status must be cleared within the FPU. Otherwise */
/*    the IRQ will be re-asserted immediately. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_misc_ctrl_fpu_irq_raw           0x00000004U
#define Adr_NX90_cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_raw 0xE0043004U
#define Adr_NX90_cm4_misc_ctrl_fpu_irq_raw               0xE0043004U
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw          0x00000000U

#define MSK_NX90_cm4_misc_ctrl_fpu_irq_raw_ixc         0x00000001U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_raw_ixc         0
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ixc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ixc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_raw_ufc         0x00000002U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_raw_ufc         1
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ufc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ufc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_raw_ofc         0x00000004U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_raw_ofc         2
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ofc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ofc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_raw_dzc         0x00000008U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_raw_dzc         3
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_dzc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_dzc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_raw_ioc         0x00000010U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_raw_ioc         4
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ioc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_ioc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_raw_idc         0x00000020U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_raw_idc         5
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_idc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_raw_idc 0x00000000U

/* all used bits of 'NX90_cm4_misc_ctrl_fpu_irq_raw': */
#define MSK_USED_BITS_NX90_cm4_misc_ctrl_fpu_irq_raw 0x0000003fU

enum {
  BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ixc       = 1,  /* [0] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ufc       = 1,  /* [1] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ofc       = 1,  /* [2] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_dzc       = 1,  /* [3] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ioc       = 1,  /* [4] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_idc       = 1,  /* [5] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_CM4_MISC_CTRL_FPU_IRQ_RAW_BIT_Ttag {
  unsigned int ixc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ixc;       /* Inexact (IEEE 754-2008 defined exception).           */
  unsigned int ufc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ufc;       /* Underflow (IEEE 754-2008 defined exception).         */
  unsigned int ofc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ofc;       /* Overflow (IEEE 754-2008 defined exception).          */
  unsigned int dzc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_dzc;       /* Division by zero (IEEE 754-2008 defined exception).  */
  unsigned int ioc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_ioc;       /* Invalid operation (IEEE 754-2008 defined exception). */
  unsigned int idc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_idc;       /* Input denormal (ARM-specific exception).             */
  unsigned int reserved1 : BFW_NX90_cm4_misc_ctrl_fpu_irq_raw_reserved1; /* reserved                                             */
} NX90_CM4_MISC_CTRL_FPU_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_CM4_MISC_CTRL_FPU_IRQ_RAW_BIT_T bf;
} NX90_CM4_MISC_CTRL_FPU_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register cm4_misc_ctrl_fpu_irq_masked */
/* => FPU masked IRQ */
/*    Shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_misc_ctrl_fpu_irq_masked           0x00000008U
#define Adr_NX90_cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_masked 0xE0043008U
#define Adr_NX90_cm4_misc_ctrl_fpu_irq_masked               0xE0043008U

#define MSK_NX90_cm4_misc_ctrl_fpu_irq_masked_ixc 0x00000001U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_masked_ixc 0
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_masked_ufc 0x00000002U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_masked_ufc 1
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_masked_ofc 0x00000004U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_masked_ofc 2
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_masked_dzc 0x00000008U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_masked_dzc 3
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_masked_ioc 0x00000010U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_masked_ioc 4
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_masked_idc 0x00000020U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_masked_idc 5

/* all used bits of 'NX90_cm4_misc_ctrl_fpu_irq_masked': */
#define MSK_USED_BITS_NX90_cm4_misc_ctrl_fpu_irq_masked 0x0000003fU

enum {
  BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ixc       = 1,  /* [0] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ufc       = 1,  /* [1] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ofc       = 1,  /* [2] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_dzc       = 1,  /* [3] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ioc       = 1,  /* [4] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_idc       = 1,  /* [5] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_CM4_MISC_CTRL_FPU_IRQ_MASKED_BIT_Ttag {
  unsigned int ixc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ixc;       /* Inexact (IEEE 754-2008 defined exception).           */
  unsigned int ufc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ufc;       /* Underflow (IEEE 754-2008 defined exception).         */
  unsigned int ofc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ofc;       /* Overflow (IEEE 754-2008 defined exception).          */
  unsigned int dzc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_dzc;       /* Division by zero (IEEE 754-2008 defined exception).  */
  unsigned int ioc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_ioc;       /* Invalid operation (IEEE 754-2008 defined exception). */
  unsigned int idc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_idc;       /* Input denormal (ARM-specific exception).             */
  unsigned int reserved1 : BFW_NX90_cm4_misc_ctrl_fpu_irq_masked_reserved1; /* reserved                                             */
} NX90_CM4_MISC_CTRL_FPU_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_CM4_MISC_CTRL_FPU_IRQ_MASKED_BIT_T bf;
} NX90_CM4_MISC_CTRL_FPU_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register cm4_misc_ctrl_fpu_irq_msk_set */
/* => FPU IRQ mask set */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to cm4_misc_ctrl_fpu_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_misc_ctrl_fpu_irq_msk_set           0x0000000CU
#define Adr_NX90_cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_set 0xE004300CU
#define Adr_NX90_cm4_misc_ctrl_fpu_irq_msk_set               0xE004300CU
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set          0x00000000U

#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ixc         0x00000001U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ixc         0
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ixc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ixc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ufc         0x00000002U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ufc         1
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ufc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ufc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ofc         0x00000004U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ofc         2
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ofc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ofc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_set_dzc         0x00000008U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_set_dzc         3
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_dzc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_dzc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ioc         0x00000010U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ioc         4
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ioc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ioc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_set_idc         0x00000020U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_set_idc         5
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_idc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_set_idc 0x00000000U

/* all used bits of 'NX90_cm4_misc_ctrl_fpu_irq_msk_set': */
#define MSK_USED_BITS_NX90_cm4_misc_ctrl_fpu_irq_msk_set 0x0000003fU

enum {
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ixc       = 1,  /* [0] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ufc       = 1,  /* [1] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ofc       = 1,  /* [2] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_dzc       = 1,  /* [3] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ioc       = 1,  /* [4] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_idc       = 1,  /* [5] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_SET_BIT_Ttag {
  unsigned int ixc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ixc;       /* Inexact (IEEE 754-2008 defined exception).           */
  unsigned int ufc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ufc;       /* Underflow (IEEE 754-2008 defined exception).         */
  unsigned int ofc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ofc;       /* Overflow (IEEE 754-2008 defined exception).          */
  unsigned int dzc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_dzc;       /* Division by zero (IEEE 754-2008 defined exception).  */
  unsigned int ioc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_ioc;       /* Invalid operation (IEEE 754-2008 defined exception). */
  unsigned int idc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_idc;       /* Input denormal (ARM-specific exception).             */
  unsigned int reserved1 : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_set_reserved1; /* reserved                                             */
} NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_SET_BIT_T bf;
} NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register cm4_misc_ctrl_fpu_irq_msk_reset */
/* => FPU IRQ mask reset */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_cm4_misc_ctrl_fpu_irq_msk_reset           0x00000010U
#define Adr_NX90_cm4_misc_ctrl_cm4_misc_ctrl_fpu_irq_msk_reset 0xE0043010U
#define Adr_NX90_cm4_misc_ctrl_fpu_irq_msk_reset               0xE0043010U
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset          0x00000000U

#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ixc         0x00000001U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ixc         0
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ixc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ixc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ufc         0x00000002U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ufc         1
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ufc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ufc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ofc         0x00000004U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ofc         2
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ofc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ofc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_dzc         0x00000008U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_dzc         3
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_dzc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_dzc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ioc         0x00000010U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ioc         4
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ioc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ioc 0x00000000U
#define MSK_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_idc         0x00000020U
#define SRT_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_idc         5
#define DFLT_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_idc    0x00000000U
#define DFLT_BF_VAL_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_idc 0x00000000U

/* all used bits of 'NX90_cm4_misc_ctrl_fpu_irq_msk_reset': */
#define MSK_USED_BITS_NX90_cm4_misc_ctrl_fpu_irq_msk_reset 0x0000003fU

enum {
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ixc       = 1,  /* [0] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ufc       = 1,  /* [1] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ofc       = 1,  /* [2] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_dzc       = 1,  /* [3] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ioc       = 1,  /* [4] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_idc       = 1,  /* [5] */
  BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int ixc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ixc;       /* Inexact (IEEE 754-2008 defined exception).           */
  unsigned int ufc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ufc;       /* Underflow (IEEE 754-2008 defined exception).         */
  unsigned int ofc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ofc;       /* Overflow (IEEE 754-2008 defined exception).          */
  unsigned int dzc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_dzc;       /* Division by zero (IEEE 754-2008 defined exception).  */
  unsigned int ioc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_ioc;       /* Invalid operation (IEEE 754-2008 defined exception). */
  unsigned int idc       : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_idc;       /* Input denormal (ARM-specific exception).             */
  unsigned int reserved1 : BFW_NX90_cm4_misc_ctrl_fpu_irq_msk_reset_reserved1; /* reserved                                             */
} NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                                   val;
  NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_RESET_BIT_T bf;
} NX90_CM4_MISC_CTRL_FPU_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* AREA idpm */
/* Area of idpm_com */

/* ===================================================================== */

#define Addr_NX90_idpm_com 0xFF001B00U

/* --------------------------------------------------------------------- */
/* Register idpm_cfg0x0 */
/* => DPM IO Control Register 0. */
/*    This register is accessible in any DPM-mode (8, 16, 32 bit, SRAM, Intel, Motorola, little endian, big endian) by access to DPM address 0. */
/*    Basic DPM settings are configurable here to make higher addresses accessible. */
/*    To avoid instable system configurations, global changes of important configuration registers must be confirmed */
/*    (re)writing 'mode' bit field of this register. View 'mode' description for details. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_cfg0x0      0x00000000U
#define Adr_NX90_idpm_com_idpm_cfg0x0 0xFF001B00U
#define Adr_NX90_idpm_cfg0x0          0xFF001B00U
#define DFLT_VAL_NX90_idpm_cfg0x0     0x00000000U

#define MSK_NX90_idpm_cfg0x0_enable         0x00000001U
#define SRT_NX90_idpm_cfg0x0_enable         0
#define DFLT_VAL_NX90_idpm_cfg0x0_enable    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_cfg0x0_enable 0x00000000U
#define MSK_NX90_idpm_cfg0x0_endian         0x00000030U
#define SRT_NX90_idpm_cfg0x0_endian         4
#define DFLT_VAL_NX90_idpm_cfg0x0_endian    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_cfg0x0_endian 0x00000000U

/* all used bits of 'NX90_idpm_cfg0x0': */
#define MSK_USED_BITS_NX90_idpm_cfg0x0 0x00000031U

enum {
  BFW_NX90_idpm_cfg0x0_enable    = 1,  /* [0] */
  BFW_NX90_idpm_cfg0x0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_idpm_cfg0x0_endian    = 2,  /* [5:4] */
  BFW_NX90_idpm_cfg0x0_reserved2 = 26  /* [31:6] */
};

typedef struct NX90_IDPM_CFG0X0_BIT_Ttag {
  unsigned int enable    : BFW_NX90_idpm_cfg0x0_enable;    /* Global IDPM enable bit.                                                                                               */
                                                           /* The IDPM module must be enabled by the INTLOGIC area before the host area (i.e. DPM mirrors of INTRAMHS) can be used. */
                                                           /* While disabled all host access (access to DPM mirrors of INTRAMHS) will be ignored. Read will return 0x0bad0bad.      */
  unsigned int reserved1 : BFW_NX90_idpm_cfg0x0_reserved1; /* reserved                                                                                                              */
  unsigned int endian    : BFW_NX90_idpm_cfg0x0_endian;    /* Endianess of 32 bit (DWord) address alignment (B0: least significant byte, B3: most significant byte):                */
                                                           /* {      |                     |      |      |      |                                                                   */
                                                           /*  coding   Address               A+3    A+2    A+1    A+0                                                              */
                                                           /*    00     little endian         B3     B2     B1     B0                                                               */
                                                           /*    01     16 bit big endian     B2     B3     B0     B1                                                               */
                                                           /*    10     32 bit big endian     B0     B1     B2     B3                                                               */
                                                           /*    11     reserved                                        }                                                           */
                                                           /* Little endian is used netX inside. If big endian host device is used, set to this 01 or 10 according to               */
                                                           /* host device data width.                                                                                               */
  unsigned int reserved2 : BFW_NX90_idpm_cfg0x0_reserved2; /* reserved                                                                                                              */
} NX90_IDPM_CFG0X0_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IDPM_CFG0X0_BIT_T bf;
} NX90_IDPM_CFG0X0_T;

/* --------------------------------------------------------------------- */
/* Register idpm_addr_cfg */
/* => DPM External Address Configuration Register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_addr_cfg      0x00000010U
#define Adr_NX90_idpm_com_idpm_addr_cfg 0xFF001B10U
#define Adr_NX90_idpm_addr_cfg          0xFF001B10U
#define DFLT_VAL_NX90_idpm_addr_cfg     0x00000000U

#define MSK_NX90_idpm_addr_cfg_cfg_win_addr_cfg         0x00000030U
#define SRT_NX90_idpm_addr_cfg_cfg_win_addr_cfg         4
#define DFLT_VAL_NX90_idpm_addr_cfg_cfg_win_addr_cfg    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_addr_cfg_cfg_win_addr_cfg 0x00000000U

/* all used bits of 'NX90_idpm_addr_cfg': */
#define MSK_USED_BITS_NX90_idpm_addr_cfg 0x00000030U

enum {
  BFW_NX90_idpm_addr_cfg_reserved1        = 4,  /* [3:0] */
  BFW_NX90_idpm_addr_cfg_cfg_win_addr_cfg = 2,  /* [5:4] */
  BFW_NX90_idpm_addr_cfg_reserved2        = 26  /* [31:6] */
};

typedef struct NX90_IDPM_ADDR_CFG_BIT_Ttag {
  unsigned int reserved1        : BFW_NX90_idpm_addr_cfg_reserved1;        /* reserved                                                                                                            */
  unsigned int cfg_win_addr_cfg : BFW_NX90_idpm_addr_cfg_cfg_win_addr_cfg; /* Location of the DPM Configuration Window (Window 0).                                                                */
                                                                           /* Supported settings are:                                                                                             */
                                                                           /*  00: Low Configuration Window: The Configuration Window is located in the first 256 bytes of external DPM address   */
                                                                           /*      range (0x0 to 0xff). It is located before the first enabled Data Window (1 to 4).                              */
                                                                           /*  01: High Configuration Window: The Configuration Window is located in the last 256 bytes of external DPM address   */
                                                                           /*      range.                                                                                                         */
                                                                           /*      Example: 'addr_range' is 8kB: Configuration Window is located in 0x1F00..0x1FFF.                               */
                                                                           /*  10: reserved.                                                                                                      */
                                                                           /*  11: Configuration Window is disabled for external DPM access. Full DPM address                                     */
                                                                           /*      range can be used for Windows 1 to 4.                                                                          */
                                                                           /* Note:                                                                                                               */
                                                                           /*   The Configuration Window 0 has higher priority than normal DPM Window. The location of the Configuration Window   */
                                                                           /*   does not depend on the Data Window configuration (the setting of the 'dpm_winX_end' or 'dpm_winX_map' registers). */
                                                                           /*   I.e. for setting '00' (low Configuration Window) the first enabled Data Window starts at address 0x100. For       */
                                                                           /*   setting '01' (high Configuration Window) it would hide the last 256 bytes of the last enabled Data Window when    */
                                                                           /*   this is configured to end on the last external address.                                                           */
                                                                           /*   The Configuration Window 0 has lower priority than Access Tunnel. I.e. the Access Tunnel could be laid over       */
                                                                           /*   the configuration window.                                                                                         */
  unsigned int reserved2        : BFW_NX90_idpm_addr_cfg_reserved2;        /* reserved                                                                                                            */
} NX90_IDPM_ADDR_CFG_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_ADDR_CFG_BIT_T bf;
} NX90_IDPM_ADDR_CFG_T;

/* --------------------------------------------------------------------- */
/* Register idpm_status */
/* => DPM Status Register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_status      0x0000001CU
#define Adr_NX90_idpm_com_idpm_status 0xFF001B1CU
#define Adr_NX90_idpm_status          0xFF001B1CU

#define MSK_NX90_idpm_status_unlocked 0x00000001U
#define SRT_NX90_idpm_status_unlocked 0

/* all used bits of 'NX90_idpm_status': */
#define MSK_USED_BITS_NX90_idpm_status 0x00000001U

enum {
  BFW_NX90_idpm_status_unlocked  = 1,  /* [0] */
  BFW_NX90_idpm_status_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_IDPM_STATUS_BIT_Ttag {
  unsigned int unlocked  : BFW_NX90_idpm_status_unlocked;  /* DPM is locked during netX power up and boot phase.                                              */
                                                           /* DPM access to other addresses than DPM configuration window 0 cannot be done before this bit is */
                                                           /* set to 1. Write access to data windows (netX AHB area) will be ignored and read access          */
                                                           /* will deliver invalid data while locked.                                                         */
                                                           /* Poll for 1 after power-up or reset.                                                             */
  unsigned int reserved1 : BFW_NX90_idpm_status_reserved1; /* reserved                                                                                        */
} NX90_IDPM_STATUS_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IDPM_STATUS_BIT_T bf;
} NX90_IDPM_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register idpm_tunnel_cfg */
/* => DPM Access Tunnel Configuration Register. */
/*    The DPM Access Tunnel (DATunnel) is a 64 byte (16DWord) address window which can be mapped on any 64 byte boundary of the external */
/*    visible address space. At the last DWord (offset 0x3C) of the DATunnel the Internal Target Base Address (ITBAddr) can be programmed. */
/*    This is the base address of the 64 byte tunnel target area inside the full 32-bit netX address range (however some address areas */
/*    could not be reachable as connections could be cut from the DPM inside the netX dataswitch, refer to the dataswitch documentation */
/*    of your netX). */
/*    By the DWords 0 to 14 of the tunnel the internal netX addresses starting at ITBAddr can be reached. The 'enable'-bit must be active */
/*    for this (read-only functionality can be configured by 'wp_data'-bit). */
/*    For access to netX data with ITBAddr DWord offset 15, the lower bits 5 to 2 of the programmed ITBAddr are interpreted as a mapping */
/*    value. This value will be added to the internal access address before tunneling (wrapping around at the 64 byte boundary). Hence it */
/*    is possible to access always 15 of the 16 netX DWord while the one hidden by the ITBAddr can be selected by an appropriate mapping */
/*    value. */
/*    The ITBAddr can also be programmed by the 'idpm_itbaddr' register of the configuration window 0 (or the INTLOGIC area). The ITBAddr on */
/*    tunnel offset 0x3C can be write-protected by the 'wp_itbaddr'-bit. This could be useful to protect the NETX from reconfiguring the */
/*    tunnel from the host side but provides the host the internal NETX destination address anyhow. However this only makes sense when */
/*    the configuration window 0 is disabled ('idpm_addr_cfg' register). Otherwise the host could reconfigure the tunnel by the 'idpm_itbaddr' */
/*    register. */
/*    Additionally the 'tunnel_all'-bit provides the possibility of tunneling all 16DWords to the NETX side. */
/*    To protect the NETX from reconfiguring the tunnel from the host side when the configuration window 0 is enabled, the 'wp_cfg_win' */
/*    can be activated. Then the tunnel configuration can only be changed from the NETX side (INTLOGIC area) but not from configuration */
/*    window 0 (in contrast to the 'wp_itbaddr'-bit which protects only offset 0x3C). */
/*     */
/*    External to internal address mapping for DATunnel area can be calculated by following formula: */
/*       INAAdr = (ITBAddr & 0xffffffc0) + ((EDAAdr + ITBAddr) & 0x3C) */
/*     */
/*    With: */
/*       INAAdr:  Internal netX Access Address */
/*       ITBAddr: Internal netX 32-bit Tunnel Target Base Address */
/*       EDAAdr:  External DPM Access Address */
/*     */
/*    Condition for DATunnel access is: */
/*       EDAAdr>>6 equals value of bit field 'base' from this register. */
/*     */
/*    To map netX internal DWord N to invisible last external DWord (15), use mapping value */
/*       map = (N - 15) & 0xf */
/*    on bits 5 to 2. */
/*    Internal to external address offset inside DATunnel area for internal DWord N can be calculated by following formula: */
/*       External offset = (N*4 - map*4) & 0x3C = (N*4 - ITBAddr) & 0x3C */
/*     */
/*    Example 1: */
/*       Access to netX sys_time module by host via DATunnel on external DPM addresses are starting at 0x240. */
/*       - Set bit field 'base' of this register to 9 (0x240>>6), set 'enable'-bit (and write protection depending on application). */
/*         DATunnel now is enabled on external DPM addresses 0x240 to 0x27f. */
/*       - ITBAddr of netX4000 sys_time module is 0xf409c180. */
/*         For direct DATunnel to this address, host must write 0xf409c180 to external DPM address 0x27c. This */
/*         can be done e.g. by four byte accesses to 0x27c, 0x27d, 0x27e and 0x27f or by two 16-bit accesses to 0x27c and 0x27e. */
/*         Now sys_time module registers 0 to 14 can be accessed on external DPM address 0x240 to 0x27b. */
/*     */
/*    Example 2: */
/*       Register 15 of sys_time is hidden by ITBAddr configuration on 0x27c in example 1 but must also be accessed. However, sys_time */
/*       Register 6 is never kind of interest. */
/*       - Configure this register like described in example 1. */
/*       - To map Register 6 (Module offset 6*4) to external offset 0x3C (hidden data on DWord 15), */
/*         the following rule must be complied: */
/*            0x3C + map*4 = 6*4. */
/*         That leads to a mapping value of: */
/*            map*4 = (6*4 - 0x3C) & 0x3C = 1C */
/*         Hence, write 0x101c101C to DATunnel DWord 15 (external DPM address 0x27c) to map sys_time Register 6 to */
/*         hidden DWord 15. */
/*         INAAdr now will be derived from EDAAdr before tunneling as follows: */
/*            INAAdr = 0xf409c180 + ((EDAAdr + 0x1C) & 0x3C) */
/*         External offset of Module DWord N results from: */
/*            External offset = (N*4 - 0x1C) & 0x3C */
/*         Register 15 of sys_time unit now can be accessed by external DPM address 0x240+((0xf*4-0x1C) & 0x3C) = 0x260 (i.e. Tunnel DWord 8). */
/*         Register 0  of sys_time unit now can be accessed by external DPM address 0x240+((0x0*4-0x1C) & 0x3C) = 0x264 (i.e. Tunnel DWord 9). */
/*         Register 1  of sys_time unit now can be accessed by external DPM address 0x240+((0x1*4-0x1C) & 0x3C) = 0x268 (i.e. Tunnel DWord 10). */
/*         and so on. */
/*         Register 6  of sys_time unit can not be accessed as it is hidden by ITBAddr configuration on 0x27c (i.e. Tunnel DWord 15). */
/*         Register 7  of sys_time unit now can be accessed by external DPM address 0x240+((0x7*4-0x1C) & 0x3C) = 0x240 (i.e. Tunnel DWord 0). */
/*     */
/*    Note: */
/*      The IDPM tunnel is capable to target the INTRAMHS-memory associated to the IDPM and additionally the INTLOGIC_SYS */
/*      area (addresses 0xf4080000 to 0xf80fffff, e.g. for SYSTIME). Other address areas can not be reached even when ITBAddr */
/*      is configured for it. Write access to non-reachable addresses will be ignored, read access will deliver invalid data. */
/*     */
/*    Attention: */
/*      The IDPM tunnel could bypass the AHB firewalls. Example: */
/*      The INTLOGIC_SYS firewall is configured to deny CA9 accesses while the CA9 is permitted for the INTRAMHS0 firewall. However, when */
/*      the tunnel is programmed to target the INTLOGIC_SYS area the CA9 can reach it as the initial access (before tunnel remapping) is */
/*      handled by the INTRAMHS0 firewall and not by the INTLOGIC_SYS firewall. To avoid abuse the 'tunnel_all' or the 'wp_itbaddr' bit */
/*      and the 'wp_cfg_win' must be enabled. Then the tunnel e.g. can be used to access the SYSTIME registers but it cannot be reconfigured */
/*      by the CA9 for abuse to other addresses. */
/*     */
/*    Note: */
/*      Configuration Window 0 access detection has higher priority than normal DPM Window */
/*      detection but lower priority than Access Tunnel access detection. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_tunnel_cfg      0x00000038U
#define Adr_NX90_idpm_com_idpm_tunnel_cfg 0xFF001B38U
#define Adr_NX90_idpm_tunnel_cfg          0xFF001B38U
#define DFLT_VAL_NX90_idpm_tunnel_cfg     0x00000101U

#define MSK_NX90_idpm_tunnel_cfg_wp_data            0x00000001U
#define SRT_NX90_idpm_tunnel_cfg_wp_data            0
#define DFLT_VAL_NX90_idpm_tunnel_cfg_wp_data       0x00000001U
#define DFLT_BF_VAL_NX90_idpm_tunnel_cfg_wp_data    0x00000001U
#define MSK_NX90_idpm_tunnel_cfg_wp_itbaddr         0x00000002U
#define SRT_NX90_idpm_tunnel_cfg_wp_itbaddr         1
#define DFLT_VAL_NX90_idpm_tunnel_cfg_wp_itbaddr    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_tunnel_cfg_wp_itbaddr 0x00000000U
#define MSK_NX90_idpm_tunnel_cfg_enable             0x00000004U
#define SRT_NX90_idpm_tunnel_cfg_enable             2
#define DFLT_VAL_NX90_idpm_tunnel_cfg_enable        0x00000000U
#define DFLT_BF_VAL_NX90_idpm_tunnel_cfg_enable     0x00000000U
#define MSK_NX90_idpm_tunnel_cfg_tunnel_all         0x00000008U
#define SRT_NX90_idpm_tunnel_cfg_tunnel_all         3
#define DFLT_VAL_NX90_idpm_tunnel_cfg_tunnel_all    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_tunnel_cfg_tunnel_all 0x00000000U
#define MSK_NX90_idpm_tunnel_cfg_base               0x00007fc0U
#define SRT_NX90_idpm_tunnel_cfg_base               6
#define DFLT_VAL_NX90_idpm_tunnel_cfg_base          0x00000100U
#define DFLT_BF_VAL_NX90_idpm_tunnel_cfg_base       0x00000004U
#define MSK_NX90_idpm_tunnel_cfg_wp_cfg_win         0x80000000U
#define SRT_NX90_idpm_tunnel_cfg_wp_cfg_win         31
#define DFLT_VAL_NX90_idpm_tunnel_cfg_wp_cfg_win    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_tunnel_cfg_wp_cfg_win 0x00000000U

/* all used bits of 'NX90_idpm_tunnel_cfg': */
#define MSK_USED_BITS_NX90_idpm_tunnel_cfg 0x80007fcfU

enum {
  BFW_NX90_idpm_tunnel_cfg_wp_data    = 1,  /* [0] */
  BFW_NX90_idpm_tunnel_cfg_wp_itbaddr = 1,  /* [1] */
  BFW_NX90_idpm_tunnel_cfg_enable     = 1,  /* [2] */
  BFW_NX90_idpm_tunnel_cfg_tunnel_all = 1,  /* [3] */
  BFW_NX90_idpm_tunnel_cfg_reserved1  = 2,  /* [5:4] */
  BFW_NX90_idpm_tunnel_cfg_base       = 9,  /* [14:6] */
  BFW_NX90_idpm_tunnel_cfg_reserved2  = 16, /* [30:15] */
  BFW_NX90_idpm_tunnel_cfg_wp_cfg_win = 1   /* [31] */
};

typedef struct NX90_IDPM_TUNNEL_CFG_BIT_Ttag {
  unsigned int wp_data    : BFW_NX90_idpm_tunnel_cfg_wp_data;    /* Access Tunnel function is write-protected for data access (DWords 0 to 14 (15 for 'tunnel_all') of DATunnel).  */
                                                                 /* 0: Write access is forwarded through the tunnel.                                                               */
                                                                 /* 1: Write access to DWords 0 to 14 (15 for 'tunnel_all') of DATunnel will be ignored.                           */
                                                                 /* Data write protection for host is enabled by default and can be disabled by clearing this bit.                 */
  unsigned int wp_itbaddr : BFW_NX90_idpm_tunnel_cfg_wp_itbaddr; /* ITBAddr is write-protected from host.                                                                          */
                                                                 /* 0: The ITBAddr is mirrored to offset 0x3C of the tunnel and can also be programmed there.                      */
                                                                 /* 1: ITBAddr (Internal netX 32 bit Tunnel Target Base Address) is read-only for tunnel offset 0x3C. It can only  */
                                                                 /*    be changed via configuration window 0 idpm_itbaddr address or the INTLOGIC IDPM area.                       */
  unsigned int enable     : BFW_NX90_idpm_tunnel_cfg_enable;     /* Enable/disable Access Tunnel function.                                                                         */
  unsigned int tunnel_all : BFW_NX90_idpm_tunnel_cfg_tunnel_all; /* Enable/disable the ITBAddr configuration register at tunnel offset 0x3C.                                       */
                                                                 /* 0: Only 15 DWords are tunneled to the internal tunnel target. The idpm_itbaddr is available at offset 0x3C.    */
                                                                 /*    One DWord of the tunnel target area is hidden by idpm_itbaddr.                                              */
                                                                 /* 1: All 16 DWords are tunneled to the internal tunnel target. The idpm_itbaddr is not available at offset 0x3C. */
                                                                 /*    All 64 tunnel target bytes can be reached (no hidden register).                                             */
                                                                 /* Note: Target mapping (base and map) will not be affected by this bit. Using a 'map' value not equal 0          */
                                                                 /*    will always rotate the tunnel target addresses.                                                             */
  unsigned int reserved1  : BFW_NX90_idpm_tunnel_cfg_reserved1;  /* reserved                                                                                                       */
  unsigned int base       : BFW_NX90_idpm_tunnel_cfg_base;       /* DPM Access Tunnel (DATunnel) Base Address divided by 64 on external visible address space.                     */
                                                                 /* Note:                                                                                                          */
                                                                 /*    Default setting for tunnel base is starting on external address 0x100.                                      */
  unsigned int reserved2  : BFW_NX90_idpm_tunnel_cfg_reserved2;  /* reserved                                                                                                       */
  unsigned int wp_cfg_win : BFW_NX90_idpm_tunnel_cfg_wp_cfg_win; /* Write-protect tunnel configuration inside the configuration window 0.                                          */
                                                                 /* 0: The two tunnel configuration registers ('idpm_tunnel_cfg' and 'idpm_itbaddr') can be programmed             */
                                                                 /*    via configuration window 0 and the INTLOGIC_SYS-IDPM address area.                                          */
                                                                 /* 1: The tunnel configuration registers ('idpm_tunnel_cfg' and 'idpm_itbaddr') cannot                            */
                                                                 /*    be programmed by the host via configuration window 0 (they are read-only for the host there).               */
                                                                 /*    They can only be programmed via the INTLOGIC_SYS-IDPM address area.                                         */
                                                                 /* Note: Set this bit to protect the NETX from reconfiguring the tunnel by the host when configuration            */
                                                                 /*    window 0 is activated for the host (e.g. for IRQ handling).                                                 */
} NX90_IDPM_TUNNEL_CFG_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IDPM_TUNNEL_CFG_BIT_T bf;
} NX90_IDPM_TUNNEL_CFG_T;

/* --------------------------------------------------------------------- */
/* Register idpm_itbaddr */
/* => DPM Access Tunnel (DATunnel) netX Internal Target Base Address (ITBAddr) Configuration Register. */
/*    For DPM Access Tunnel (DATunnel) function view description of dpm_tunnel_cfg register. */
/*    This register contains ITBAddr value that can also be changed by host on last offset 0x3c (last DWord) of */
/*    external DATunnel area (defined by bit field 'base' in 'dpm_tunnel_cfg' register). However this register can */
/*    also be write-protected from host if bit 'wp_itbaddr' in 'dpm_tunnel_cfg' register is set. */
/*    Write protection bits of DATunnel configured in 'dpm_tunnel_cfg' register can also be read from this register. Host */
/*    can read access rights from these bits on last DWord of external DATunnel address area. */
/*     */
/*    Note: This register can be write-protected by the 'wp_cfg_win' and the 'wp_itbaddr'-bit of the 'idpm_tunnel_cfg' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_itbaddr      0x0000003CU
#define Adr_NX90_idpm_com_idpm_itbaddr 0xFF001B3CU
#define Adr_NX90_idpm_itbaddr          0xFF001B3CU
#define DFLT_VAL_NX90_idpm_itbaddr     0x00000001U

#define MSK_NX90_idpm_itbaddr_wp_data_ro            0x00000001U
#define SRT_NX90_idpm_itbaddr_wp_data_ro            0
#define DFLT_VAL_NX90_idpm_itbaddr_wp_data_ro       0x00000001U
#define DFLT_BF_VAL_NX90_idpm_itbaddr_wp_data_ro    0x00000001U
#define MSK_NX90_idpm_itbaddr_wp_itbaddr_ro         0x00000002U
#define SRT_NX90_idpm_itbaddr_wp_itbaddr_ro         1
#define DFLT_VAL_NX90_idpm_itbaddr_wp_itbaddr_ro    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_itbaddr_wp_itbaddr_ro 0x00000000U
#define MSK_NX90_idpm_itbaddr_map                   0x0000003cU
#define SRT_NX90_idpm_itbaddr_map                   2
#define DFLT_VAL_NX90_idpm_itbaddr_map              0x00000000U
#define DFLT_BF_VAL_NX90_idpm_itbaddr_map           0x00000000U
#define MSK_NX90_idpm_itbaddr_base                  0xffffffc0U
#define SRT_NX90_idpm_itbaddr_base                  6
#define DFLT_VAL_NX90_idpm_itbaddr_base             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_itbaddr_base          0x00000000U

/* all used bits of 'NX90_idpm_itbaddr': */
#define MSK_USED_BITS_NX90_idpm_itbaddr 0xffffffffU

enum {
  BFW_NX90_idpm_itbaddr_wp_data_ro    = 1,  /* [0] */
  BFW_NX90_idpm_itbaddr_wp_itbaddr_ro = 1,  /* [1] */
  BFW_NX90_idpm_itbaddr_map           = 4,  /* [5:2] */
  BFW_NX90_idpm_itbaddr_base          = 26  /* [31:6] */
};

typedef struct NX90_IDPM_ITBADDR_BIT_Ttag {
  unsigned int wp_data_ro    : BFW_NX90_idpm_itbaddr_wp_data_ro;    /* Access Tunnel function is write-protected from data access (DWords 0 to 14 of DATunnel). */
                                                                    /* This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register.   */
                                                                    /* View description of dpm_tunnel_cfg register.                                             */
  unsigned int wp_itbaddr_ro : BFW_NX90_idpm_itbaddr_wp_itbaddr_ro; /* ITBAddr is write-protected from host.                                                    */
                                                                    /* This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register.   */
                                                                    /* View description of dpm_tunnel_cfg register.                                             */
  unsigned int map           : BFW_NX90_idpm_itbaddr_map;           /* Mapping part of ITBAddr.                                                                 */
                                                                    /* View description of dpm_tunnel_cfg register.                                             */
  unsigned int base          : BFW_NX90_idpm_itbaddr_base;          /* Internal netX Tunnel Target Base Address (ITBAddr) divided by 64.                        */
                                                                    /* View description of dpm_tunnel_cfg register.                                             */
} NX90_IDPM_ITBADDR_BIT_T;

typedef union {
  uint32_t                val;
  NX90_IDPM_ITBADDR_BIT_T bf;
} NX90_IDPM_ITBADDR_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win1_end */
/* => DPM Window 1 End Address Configuration Register. */
/*    Smallest DPM window configuration unit is 128 bytes (i.e. lowest 7 bits of address configuration are always 0). */
/*    At address 0x0 DPM configuration window is mapped after reset (length: 256 bytes, containing all DPM addresses defined here). Each window starts at */
/*    window end address of the preceding window. Hence external window 1 start address is 0x100, window 2 starts at value programmed in this register and so on. */
/*     */
/*    Note: */
/*      This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register. */
/*     */
/*    Note: */
/*      Configuration Window 0 access detection has higher priority than normal DPM Window */
/*      detection but lower priority than Access Tunnel access detection. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win1_end      0x00000040U
#define Adr_NX90_idpm_com_idpm_win1_end 0xFF001B40U
#define Adr_NX90_idpm_win1_end          0xFF001B40U
#define DFLT_VAL_NX90_idpm_win1_end     0x00000000U

#define MSK_NX90_idpm_win1_end_win_end         0x0000ff80U
#define SRT_NX90_idpm_win1_end_win_end         7
#define DFLT_VAL_NX90_idpm_win1_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win1_end_win_end 0x00000000U

/* all used bits of 'NX90_idpm_win1_end': */
#define MSK_USED_BITS_NX90_idpm_win1_end 0x0000ff80U

enum {
  BFW_NX90_idpm_win1_end_reserved1 = 7,  /* [6:0] */
  BFW_NX90_idpm_win1_end_win_end   = 9,  /* [15:7] */
  BFW_NX90_idpm_win1_end_reserved2 = 16  /* [31:16] */
};

typedef struct NX90_IDPM_WIN1_END_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_idpm_win1_end_reserved1; /* reserved                                       */
  unsigned int win_end   : BFW_NX90_idpm_win1_end_win_end;   /* Window 1 End Address divided by 128.           */
                                                             /* Last external address is win_end*128-1.        */
                                                             /* Setting win_end to 0 will disable this window. */
  unsigned int reserved2 : BFW_NX90_idpm_win1_end_reserved2; /* reserved                                       */
} NX90_IDPM_WIN1_END_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN1_END_BIT_T bf;
} NX90_IDPM_WIN1_END_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win1_map */
/* => DPM Window 1 Address Map Configuration Register. */
/*    Smallest DPM window configuration unit is 128 bytes (i.e. lowest 7 bits of address configuration are always 0). */
/*    For further information view description of 'dpm_win1_end' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win1_map      0x00000044U
#define Adr_NX90_idpm_com_idpm_win1_map 0xFF001B44U
#define Adr_NX90_idpm_win1_map          0xFF001B44U
#define DFLT_VAL_NX90_idpm_win1_map     0x00000000U

#define MSK_NX90_idpm_win1_map_win_map_alt         0x0000000cU
#define SRT_NX90_idpm_win1_map_win_map_alt         2
#define DFLT_VAL_NX90_idpm_win1_map_win_map_alt    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win1_map_win_map_alt 0x00000000U
#define MSK_NX90_idpm_win1_map_wp_cfg_win          0x00000020U
#define SRT_NX90_idpm_win1_map_wp_cfg_win          5
#define DFLT_VAL_NX90_idpm_win1_map_wp_cfg_win     0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win1_map_wp_cfg_win  0x00000000U
#define MSK_NX90_idpm_win1_map_win_map             0x00007f80U
#define SRT_NX90_idpm_win1_map_win_map             7
#define DFLT_VAL_NX90_idpm_win1_map_win_map        0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win1_map_win_map     0x00000000U

/* all used bits of 'NX90_idpm_win1_map': */
#define MSK_USED_BITS_NX90_idpm_win1_map 0x00007facU

enum {
  BFW_NX90_idpm_win1_map_reserved1   = 2,  /* [1:0] */
  BFW_NX90_idpm_win1_map_win_map_alt = 2,  /* [3:2] */
  BFW_NX90_idpm_win1_map_reserved2   = 1,  /* [4] */
  BFW_NX90_idpm_win1_map_wp_cfg_win  = 1,  /* [5] */
  BFW_NX90_idpm_win1_map_reserved3   = 1,  /* [6] */
  BFW_NX90_idpm_win1_map_win_map     = 8,  /* [14:7] */
  BFW_NX90_idpm_win1_map_reserved4   = 17  /* [31:15] */
};

typedef struct NX90_IDPM_WIN1_MAP_BIT_Ttag {
  unsigned int reserved1   : BFW_NX90_idpm_win1_map_reserved1;   /* reserved                                                                                                             */
  unsigned int win_map_alt : BFW_NX90_idpm_win1_map_win_map_alt; /* Window 1 Alternative Address Mapping Configuration.                                                                  */
                                                                 /* Alternative Address Mapping can be generated by Triple Buffer Managers inside HANDSHAKE_CTRL unit.                   */
                                                                 /* Coding:                                                                                                              */
                                                                 /*  00 : Alternative Address Mapping disabled.                                                                          */
                                                                 /*  01 : Alternative Address Mapping enabled: Use Triple Buffer Manager 0 from HANDSHAKE_CTRL unit.                     */
                                                                 /*  10 : Alternative Address Mapping enabled: Use Triple Buffer Manager 1 from HANDSHAKE_CTRL unit.                     */
                                                                 /*  11 : reserved                                                                                                       */
                                                                 /* If Alternative Address Mapping is enabled, mapping value is taken according to buffer status                         */
                                                                 /* of related HANDSHAKE_CTRL Triple Buffer Manager as follows.                                                          */
                                                                 /* {                    |                                                                                               */
                                                                 /*   buffer status        used mapping value                                                                            */
                                                                 /*   00 (buffer 0)        win_map entry of this register                                                                */
                                                                 /*   01 (buffer 1)        Alternative win_map value 1 of related HANDSHAKE_CTRL Triple Buffer Manager.                  */
                                                                 /*   10 (buffer 2)        Alternative win_map value 2 of related HANDSHAKE_CTRL Triple Buffer Manager.                  */
                                                                 /*   11 (invalid buffer)  win_map entry of this register }                                                              */
                                                                 /* Note:                                                                                                                */
                                                                 /*    Alternative Triple Buffer Manager win_map values can be programmed in HANDSHAKE_CTRL address area.                */
                                                                 /* Note:                                                                                                                */
                                                                 /*    For netX4000 there are 2 IDPM and 2 HANDSHAKE_CTRL units. IDPM0 is always associated with HANDSHAKE_CTRL0         */
                                                                 /*    while IDPM1 is always associated with HANDSHAKE_CTRL1.                                                            */
  unsigned int reserved2   : BFW_NX90_idpm_win1_map_reserved2;   /* reserved                                                                                                             */
  unsigned int wp_cfg_win  : BFW_NX90_idpm_win1_map_wp_cfg_win;  /* Write-protect window configuration inside the configuration window 0.                                                */
                                                                 /* 0: All 8 window configuration registers ('dpm_winX_and' and 'dpm_winX_map') can be programmed                        */
                                                                 /*    via configuration window 0 and the INTLOGIC-DPM address area.                                                     */
                                                                 /* 1: All 8 window configuration registers ('dpm_winX_and' and 'dpm_winX_map') cannot                                   */
                                                                 /*    be programmed by the host via configuration window 0 (they are read-only for the host there).                     */
                                                                 /*    They can only be programmed via the INTLOGIC-DPM address area.                                                    */
                                                                 /* Note: Set this bit to protect the NETX from reconfiguring the window mapping by the host when configuration          */
                                                                 /*    window 0 is activated for the host (e.g. for IRQ handling).                                                       */
                                                                 /* Note:                                                                                                                */
                                                                 /*    To protect the netX completely from host-access to not permitted address areas it must be ensured that also       */
                                                                 /*    the remapping of the DPM tunne cannot be changed by the host (refer to register 'dpm_tunnel_cfg').                */
                                                                 /* Note:                                                                                                                */
                                                                 /*    This bit does only exist in the 'dpm_win1_map'-register but not in the registers for the higher windows.          */
                                                                 /*    However this bit protect all DPM 'dpm_winX_and' and 'dpm_winX_map'-registers from being written via               */
                                                                 /*    configuration window 0.                                                                                           */
                                                                 /* Note:                                                                                                                */
                                                                 /*    The 'wp_cfg_win'-bit is a new feature since netX4000 and netX6.                                                   */
  unsigned int reserved3   : BFW_NX90_idpm_win1_map_reserved3;   /* reserved                                                                                                             */
  unsigned int win_map     : BFW_NX90_idpm_win1_map_win_map;     /* Window 1 Address Mapping.                                                                                            */
                                                                 /* Internal access address HADDR to netX logic is combined by DPM interface by:                                         */
                                                                 /* HADDR[31:16]: unchanged, as it comes form accessing master                                                           */
                                                                 /* HADDR[15:0]:  mapped DPM address. This part of address is defined by programmed win_map value for each window.       */
                                                                 /* The value to be programmed is address bits 15 to 0 of netX internal window start address minus start address of the  */
                                                                 /* external window (i.e. end address of preceding window) .                                                             */
                                                                 /* Example:                                                                                                             */
                                                                 /*    Window n starts at 0x400 of external DPM address range (i.e. programmed win_end value of window (n-1) and targets */
                                                                 /*    netX address 0x05218000.                                                                                          */
                                                                 /*    For address calculation only lower 16 bits of netX address are relevant, i.e. 0x8000.                             */
                                                                 /*    The complete 16 bit address map value is then:0x8000-0x400=0x7C00.                                                */
                                                                 /*    Hence the programmed 9 bit value must be 0x7C00>>7=0xf8.                                                          */
  unsigned int reserved4   : BFW_NX90_idpm_win1_map_reserved4;   /* reserved                                                                                                             */
} NX90_IDPM_WIN1_MAP_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN1_MAP_BIT_T bf;
} NX90_IDPM_WIN1_MAP_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win2_end */
/* => DPM Window 2 End Address Configuration Register. */
/*    For detailed information refer to 'idpm_win1_end' register description. */
/*     */
/*    Note: */
/*      This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win2_end      0x00000048U
#define Adr_NX90_idpm_com_idpm_win2_end 0xFF001B48U
#define Adr_NX90_idpm_win2_end          0xFF001B48U
#define DFLT_VAL_NX90_idpm_win2_end     0x00000000U

#define MSK_NX90_idpm_win2_end_win_end         0x0000ff80U
#define SRT_NX90_idpm_win2_end_win_end         7
#define DFLT_VAL_NX90_idpm_win2_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win2_end_win_end 0x00000000U

/* all used bits of 'NX90_idpm_win2_end': */
#define MSK_USED_BITS_NX90_idpm_win2_end 0x0000ff80U

enum {
  BFW_NX90_idpm_win2_end_reserved1 = 7,  /* [6:0] */
  BFW_NX90_idpm_win2_end_win_end   = 9,  /* [15:7] */
  BFW_NX90_idpm_win2_end_reserved2 = 16  /* [31:16] */
};

typedef struct NX90_IDPM_WIN2_END_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_idpm_win2_end_reserved1; /* reserved                                                                     */
  unsigned int win_end   : BFW_NX90_idpm_win2_end_win_end;   /* Window 2 End Address divided by 128. Last external address is win_end*128-1. */
  unsigned int reserved2 : BFW_NX90_idpm_win2_end_reserved2; /* reserved                                                                     */
} NX90_IDPM_WIN2_END_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN2_END_BIT_T bf;
} NX90_IDPM_WIN2_END_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win2_map */
/* => DPM Window 2 Address Map Configuration Register. */
/*    For detailed information refer to 'dpm_win1_map' register description. */
/*     */
/*    Note: */
/*      This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win2_map      0x0000004CU
#define Adr_NX90_idpm_com_idpm_win2_map 0xFF001B4CU
#define Adr_NX90_idpm_win2_map          0xFF001B4CU
#define DFLT_VAL_NX90_idpm_win2_map     0x00000000U

#define MSK_NX90_idpm_win2_map_win_map_alt         0x0000000cU
#define SRT_NX90_idpm_win2_map_win_map_alt         2
#define DFLT_VAL_NX90_idpm_win2_map_win_map_alt    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win2_map_win_map_alt 0x00000000U
#define MSK_NX90_idpm_win2_map_win_map             0x00007f80U
#define SRT_NX90_idpm_win2_map_win_map             7
#define DFLT_VAL_NX90_idpm_win2_map_win_map        0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win2_map_win_map     0x00000000U

/* all used bits of 'NX90_idpm_win2_map': */
#define MSK_USED_BITS_NX90_idpm_win2_map 0x00007f8cU

enum {
  BFW_NX90_idpm_win2_map_reserved1   = 2,  /* [1:0] */
  BFW_NX90_idpm_win2_map_win_map_alt = 2,  /* [3:2] */
  BFW_NX90_idpm_win2_map_reserved2   = 3,  /* [6:4] */
  BFW_NX90_idpm_win2_map_win_map     = 8,  /* [14:7] */
  BFW_NX90_idpm_win2_map_reserved3   = 17  /* [31:15] */
};

typedef struct NX90_IDPM_WIN2_MAP_BIT_Ttag {
  unsigned int reserved1   : BFW_NX90_idpm_win2_map_reserved1;   /* reserved                                          */
  unsigned int win_map_alt : BFW_NX90_idpm_win2_map_win_map_alt; /* Window Alternative Address Mapping Configuration. */
  unsigned int reserved2   : BFW_NX90_idpm_win2_map_reserved2;   /* reserved                                          */
  unsigned int win_map     : BFW_NX90_idpm_win2_map_win_map;     /* Window address mapping.                           */
  unsigned int reserved3   : BFW_NX90_idpm_win2_map_reserved3;   /* reserved                                          */
} NX90_IDPM_WIN2_MAP_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN2_MAP_BIT_T bf;
} NX90_IDPM_WIN2_MAP_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win3_end */
/* => DPM Window 3 End Address Configuration Register. */
/*    For detailed information refer to 'idpm_win1_end' register description. */
/*     */
/*    Note: */
/*      This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win3_end      0x00000050U
#define Adr_NX90_idpm_com_idpm_win3_end 0xFF001B50U
#define Adr_NX90_idpm_win3_end          0xFF001B50U
#define DFLT_VAL_NX90_idpm_win3_end     0x00000000U

#define MSK_NX90_idpm_win3_end_win_end         0x0000ff80U
#define SRT_NX90_idpm_win3_end_win_end         7
#define DFLT_VAL_NX90_idpm_win3_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win3_end_win_end 0x00000000U

/* all used bits of 'NX90_idpm_win3_end': */
#define MSK_USED_BITS_NX90_idpm_win3_end 0x0000ff80U

enum {
  BFW_NX90_idpm_win3_end_reserved1 = 7,  /* [6:0] */
  BFW_NX90_idpm_win3_end_win_end   = 9,  /* [15:7] */
  BFW_NX90_idpm_win3_end_reserved2 = 16  /* [31:16] */
};

typedef struct NX90_IDPM_WIN3_END_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_idpm_win3_end_reserved1; /* reserved                                                                     */
  unsigned int win_end   : BFW_NX90_idpm_win3_end_win_end;   /* Window 3 End Address divided by 128. Last external address is win_end*128-1. */
  unsigned int reserved2 : BFW_NX90_idpm_win3_end_reserved2; /* reserved                                                                     */
} NX90_IDPM_WIN3_END_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN3_END_BIT_T bf;
} NX90_IDPM_WIN3_END_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win3_map */
/* => DPM Window 3 Address Map Configuration Register. */
/*    For detailed information refer to 'dpm_win1_map' register description. */
/*     */
/*    Note: */
/*      This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win3_map      0x00000054U
#define Adr_NX90_idpm_com_idpm_win3_map 0xFF001B54U
#define Adr_NX90_idpm_win3_map          0xFF001B54U
#define DFLT_VAL_NX90_idpm_win3_map     0x00000000U

#define MSK_NX90_idpm_win3_map_win_map_alt         0x0000000cU
#define SRT_NX90_idpm_win3_map_win_map_alt         2
#define DFLT_VAL_NX90_idpm_win3_map_win_map_alt    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win3_map_win_map_alt 0x00000000U
#define MSK_NX90_idpm_win3_map_win_map             0x00007f80U
#define SRT_NX90_idpm_win3_map_win_map             7
#define DFLT_VAL_NX90_idpm_win3_map_win_map        0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win3_map_win_map     0x00000000U

/* all used bits of 'NX90_idpm_win3_map': */
#define MSK_USED_BITS_NX90_idpm_win3_map 0x00007f8cU

enum {
  BFW_NX90_idpm_win3_map_reserved1   = 2,  /* [1:0] */
  BFW_NX90_idpm_win3_map_win_map_alt = 2,  /* [3:2] */
  BFW_NX90_idpm_win3_map_reserved2   = 3,  /* [6:4] */
  BFW_NX90_idpm_win3_map_win_map     = 8,  /* [14:7] */
  BFW_NX90_idpm_win3_map_reserved3   = 17  /* [31:15] */
};

typedef struct NX90_IDPM_WIN3_MAP_BIT_Ttag {
  unsigned int reserved1   : BFW_NX90_idpm_win3_map_reserved1;   /* reserved                                          */
  unsigned int win_map_alt : BFW_NX90_idpm_win3_map_win_map_alt; /* Window Alternative Address Mapping Configuration. */
  unsigned int reserved2   : BFW_NX90_idpm_win3_map_reserved2;   /* reserved                                          */
  unsigned int win_map     : BFW_NX90_idpm_win3_map_win_map;     /* Window map address.                               */
  unsigned int reserved3   : BFW_NX90_idpm_win3_map_reserved3;   /* reserved                                          */
} NX90_IDPM_WIN3_MAP_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN3_MAP_BIT_T bf;
} NX90_IDPM_WIN3_MAP_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win4_end */
/* => DPM Window 4 End Address Configuration Register. */
/*    For detailed information refer to 'idpm_win1_end' register description. */
/*     */
/*    Note: */
/*      This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win4_end      0x00000058U
#define Adr_NX90_idpm_com_idpm_win4_end 0xFF001B58U
#define Adr_NX90_idpm_win4_end          0xFF001B58U
#define DFLT_VAL_NX90_idpm_win4_end     0x00000000U

#define MSK_NX90_idpm_win4_end_win_end         0x0000ff80U
#define SRT_NX90_idpm_win4_end_win_end         7
#define DFLT_VAL_NX90_idpm_win4_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win4_end_win_end 0x00000000U

/* all used bits of 'NX90_idpm_win4_end': */
#define MSK_USED_BITS_NX90_idpm_win4_end 0x0000ff80U

enum {
  BFW_NX90_idpm_win4_end_reserved1 = 7,  /* [6:0] */
  BFW_NX90_idpm_win4_end_win_end   = 9,  /* [15:7] */
  BFW_NX90_idpm_win4_end_reserved2 = 16  /* [31:16] */
};

typedef struct NX90_IDPM_WIN4_END_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_idpm_win4_end_reserved1; /* reserved                                                                     */
  unsigned int win_end   : BFW_NX90_idpm_win4_end_win_end;   /* Window 4 End Address divided by 128. Last external address is win_end*128-1. */
  unsigned int reserved2 : BFW_NX90_idpm_win4_end_reserved2; /* reserved                                                                     */
} NX90_IDPM_WIN4_END_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN4_END_BIT_T bf;
} NX90_IDPM_WIN4_END_T;

/* --------------------------------------------------------------------- */
/* Register idpm_win4_map */
/* => DPM Window 4 Address Map Configuration Register. */
/*    For detailed information refer to 'dpm_win1_map' register description. */
/*     */
/*    Note: */
/*      This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_win4_map      0x0000005CU
#define Adr_NX90_idpm_com_idpm_win4_map 0xFF001B5CU
#define Adr_NX90_idpm_win4_map          0xFF001B5CU
#define DFLT_VAL_NX90_idpm_win4_map     0x00000000U

#define MSK_NX90_idpm_win4_map_win_map_alt         0x0000000cU
#define SRT_NX90_idpm_win4_map_win_map_alt         2
#define DFLT_VAL_NX90_idpm_win4_map_win_map_alt    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win4_map_win_map_alt 0x00000000U
#define MSK_NX90_idpm_win4_map_win_map             0x00007f80U
#define SRT_NX90_idpm_win4_map_win_map             7
#define DFLT_VAL_NX90_idpm_win4_map_win_map        0x00000000U
#define DFLT_BF_VAL_NX90_idpm_win4_map_win_map     0x00000000U

/* all used bits of 'NX90_idpm_win4_map': */
#define MSK_USED_BITS_NX90_idpm_win4_map 0x00007f8cU

enum {
  BFW_NX90_idpm_win4_map_reserved1   = 2,  /* [1:0] */
  BFW_NX90_idpm_win4_map_win_map_alt = 2,  /* [3:2] */
  BFW_NX90_idpm_win4_map_reserved2   = 3,  /* [6:4] */
  BFW_NX90_idpm_win4_map_win_map     = 8,  /* [14:7] */
  BFW_NX90_idpm_win4_map_reserved3   = 17  /* [31:15] */
};

typedef struct NX90_IDPM_WIN4_MAP_BIT_Ttag {
  unsigned int reserved1   : BFW_NX90_idpm_win4_map_reserved1;   /* reserved                                          */
  unsigned int win_map_alt : BFW_NX90_idpm_win4_map_win_map_alt; /* Window Alternative Address Mapping Configuration. */
  unsigned int reserved2   : BFW_NX90_idpm_win4_map_reserved2;   /* reserved                                          */
  unsigned int win_map     : BFW_NX90_idpm_win4_map_win_map;     /* Window map address.                               */
  unsigned int reserved3   : BFW_NX90_idpm_win4_map_reserved3;   /* reserved                                          */
} NX90_IDPM_WIN4_MAP_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IDPM_WIN4_MAP_BIT_T bf;
} NX90_IDPM_WIN4_MAP_T;

/* --------------------------------------------------------------------- */
/* Register idpm_irq_raw */
/* => DPM Raw (before masking) IRQ Status Register. */
/*    If a bit is set, the related interrupt is asserted. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*     */
/*    Important: There are two completely independent sets of IRQ registers: */
/*       IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers). */
/*       IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). */
/*       Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs */
/*       can be found in both sets (e.g. com0). */
/*     */
/*    Note: */
/*       The 'dpm_sw' IRQ can be controlled by the 'dpm_sw_irq' register. */
/*       for each IRQ target. The 'dpm_sw' will be set inside the 'dpm_irq_raw' register */
/*       when the 'dpm_sw' is activated for at least one IRQ target. But each IRQ target */
/*       obtains only the 'dpm_sw' IRQ state programmed for this target inside the 'dpm_sw_irq' */
/*       register. For an example view description of 'dpm_sw_irq' register. */
/*     */
/*    Note: */
/*        The 'firmware' IRQ can be used to flag handshake and netX firmware system status events to the */
/*        host. Firmware IRQ generation can be controlled by dpm_firmware_irq_mask register. Detailed */
/*        firmware IRQ status can be read from dpm_firmware_irq_raw register. */
/*     */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_irq_raw      0x00000080U
#define Adr_NX90_idpm_com_idpm_irq_raw 0xFF001B80U
#define Adr_NX90_idpm_irq_raw          0xFF001B80U

#define MSK_NX90_idpm_irq_raw_dpm_sw   0x00000001U
#define SRT_NX90_idpm_irq_raw_dpm_sw   0
#define MSK_NX90_idpm_irq_raw_firmware 0x00000004U
#define SRT_NX90_idpm_irq_raw_firmware 2

/* all used bits of 'NX90_idpm_irq_raw': */
#define MSK_USED_BITS_NX90_idpm_irq_raw 0x00000005U

enum {
  BFW_NX90_idpm_irq_raw_dpm_sw    = 1,  /* [0] */
  BFW_NX90_idpm_irq_raw_reserved1 = 1,  /* [1] */
  BFW_NX90_idpm_irq_raw_firmware  = 1,  /* [2] */
  BFW_NX90_idpm_irq_raw_reserved2 = 29  /* [31:3] */
};

typedef struct NX90_IDPM_IRQ_RAW_BIT_Ttag {
  unsigned int dpm_sw    : BFW_NX90_idpm_irq_raw_dpm_sw;    /* raw software IRQ for IRQ targets interrupt                 */
  unsigned int reserved1 : BFW_NX90_idpm_irq_raw_reserved1; /* reserved                                                   */
  unsigned int firmware  : BFW_NX90_idpm_irq_raw_firmware;  /* raw combined handshake-cell and SYS_STA firmware interrupt */
  unsigned int reserved2 : BFW_NX90_idpm_irq_raw_reserved2; /* reserved                                                   */
} NX90_IDPM_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                val;
  NX90_IDPM_IRQ_RAW_BIT_T bf;
} NX90_IDPM_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register idpm_irq_host_mask_set */
/* => DPM Interrupt Mask Register for IDPM host interrupt. */
/*    Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for IDPM host interrupt. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for IDPM host interrupt without clearing interrupt in module, reset related mask bit to 0. */
/*     */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_irq_host_mask_set      0x00000084U
#define Adr_NX90_idpm_com_idpm_irq_host_mask_set 0xFF001B84U
#define Adr_NX90_idpm_irq_host_mask_set          0xFF001B84U
#define DFLT_VAL_NX90_idpm_irq_host_mask_set     0x00000000U

#define MSK_NX90_idpm_irq_host_mask_set_dpm_sw           0x00000001U
#define SRT_NX90_idpm_irq_host_mask_set_dpm_sw           0
#define DFLT_VAL_NX90_idpm_irq_host_mask_set_dpm_sw      0x00000000U
#define DFLT_BF_VAL_NX90_idpm_irq_host_mask_set_dpm_sw   0x00000000U
#define MSK_NX90_idpm_irq_host_mask_set_firmware         0x00000004U
#define SRT_NX90_idpm_irq_host_mask_set_firmware         2
#define DFLT_VAL_NX90_idpm_irq_host_mask_set_firmware    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_irq_host_mask_set_firmware 0x00000000U

/* all used bits of 'NX90_idpm_irq_host_mask_set': */
#define MSK_USED_BITS_NX90_idpm_irq_host_mask_set 0x00000005U

enum {
  BFW_NX90_idpm_irq_host_mask_set_dpm_sw    = 1,  /* [0] */
  BFW_NX90_idpm_irq_host_mask_set_reserved1 = 1,  /* [1] */
  BFW_NX90_idpm_irq_host_mask_set_firmware  = 1,  /* [2] */
  BFW_NX90_idpm_irq_host_mask_set_reserved2 = 29  /* [31:3] */
};

typedef struct NX90_IDPM_IRQ_HOST_MASK_SET_BIT_Ttag {
  unsigned int dpm_sw    : BFW_NX90_idpm_irq_host_mask_set_dpm_sw;    /* set software IRQ for IRQ targets interrupt mask for IDPM host interrupt                 */
  unsigned int reserved1 : BFW_NX90_idpm_irq_host_mask_set_reserved1; /* reserved                                                                                */
  unsigned int firmware  : BFW_NX90_idpm_irq_host_mask_set_firmware;  /* set combined handshake-cell and SYS_STA firmware interrupt mask for IDPM host interrupt */
  unsigned int reserved2 : BFW_NX90_idpm_irq_host_mask_set_reserved2; /* reserved                                                                                */
} NX90_IDPM_IRQ_HOST_MASK_SET_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_IDPM_IRQ_HOST_MASK_SET_BIT_T bf;
} NX90_IDPM_IRQ_HOST_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register idpm_irq_host_mask_reset */
/* => DPM Interrupt Mask Reset Register for IDPM host interrupt. */
/*    Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for IDPM host interrupt. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for IDPM host interrupt without clearing interrupt in module, reset related mask bit to 0. */
/*     */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_irq_host_mask_reset      0x00000088U
#define Adr_NX90_idpm_com_idpm_irq_host_mask_reset 0xFF001B88U
#define Adr_NX90_idpm_irq_host_mask_reset          0xFF001B88U
#define DFLT_VAL_NX90_idpm_irq_host_mask_reset     0x00000000U

#define MSK_NX90_idpm_irq_host_mask_reset_dpm_sw           0x00000001U
#define SRT_NX90_idpm_irq_host_mask_reset_dpm_sw           0
#define DFLT_VAL_NX90_idpm_irq_host_mask_reset_dpm_sw      0x00000000U
#define DFLT_BF_VAL_NX90_idpm_irq_host_mask_reset_dpm_sw   0x00000000U
#define MSK_NX90_idpm_irq_host_mask_reset_firmware         0x00000004U
#define SRT_NX90_idpm_irq_host_mask_reset_firmware         2
#define DFLT_VAL_NX90_idpm_irq_host_mask_reset_firmware    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_irq_host_mask_reset_firmware 0x00000000U

/* all used bits of 'NX90_idpm_irq_host_mask_reset': */
#define MSK_USED_BITS_NX90_idpm_irq_host_mask_reset 0x00000005U

enum {
  BFW_NX90_idpm_irq_host_mask_reset_dpm_sw    = 1,  /* [0] */
  BFW_NX90_idpm_irq_host_mask_reset_reserved1 = 1,  /* [1] */
  BFW_NX90_idpm_irq_host_mask_reset_firmware  = 1,  /* [2] */
  BFW_NX90_idpm_irq_host_mask_reset_reserved2 = 29  /* [31:3] */
};

typedef struct NX90_IDPM_IRQ_HOST_MASK_RESET_BIT_Ttag {
  unsigned int dpm_sw    : BFW_NX90_idpm_irq_host_mask_reset_dpm_sw;    /* reset software IRQ for IRQ targets interrupt mask for IDPM host interrupt                 */
  unsigned int reserved1 : BFW_NX90_idpm_irq_host_mask_reset_reserved1; /* reserved                                                                                  */
  unsigned int firmware  : BFW_NX90_idpm_irq_host_mask_reset_firmware;  /* reset combined handshake-cell and SYS_STA firmware interrupt mask for IDPM host interrupt */
  unsigned int reserved2 : BFW_NX90_idpm_irq_host_mask_reset_reserved2; /* reserved                                                                                  */
} NX90_IDPM_IRQ_HOST_MASK_RESET_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_IDPM_IRQ_HOST_MASK_RESET_BIT_T bf;
} NX90_IDPM_IRQ_HOST_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register idpm_irq_host_masked */
/* => DPM Masked Interrupt Status Register for IDPM host interrupt. */
/*    A bit is set, when the related mask bit is set in 'dpm_irq_host_mask'-register and the related interrupt is asserted. */
/*    IRQ for IDPM host interrupt is asserted if at least one bit is set here. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for IDPM host interrupt without clearing interrupt in module, reset related mask bit to 0. */
/*     */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/*     */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_irq_host_masked      0x0000008CU
#define Adr_NX90_idpm_com_idpm_irq_host_masked 0xFF001B8CU
#define Adr_NX90_idpm_irq_host_masked          0xFF001B8CU

#define MSK_NX90_idpm_irq_host_masked_dpm_sw   0x00000001U
#define SRT_NX90_idpm_irq_host_masked_dpm_sw   0
#define MSK_NX90_idpm_irq_host_masked_firmware 0x00000004U
#define SRT_NX90_idpm_irq_host_masked_firmware 2

/* all used bits of 'NX90_idpm_irq_host_masked': */
#define MSK_USED_BITS_NX90_idpm_irq_host_masked 0x00000005U

enum {
  BFW_NX90_idpm_irq_host_masked_dpm_sw    = 1,  /* [0] */
  BFW_NX90_idpm_irq_host_masked_reserved1 = 1,  /* [1] */
  BFW_NX90_idpm_irq_host_masked_firmware  = 1,  /* [2] */
  BFW_NX90_idpm_irq_host_masked_reserved2 = 29  /* [31:3] */
};

typedef struct NX90_IDPM_IRQ_HOST_MASKED_BIT_Ttag {
  unsigned int dpm_sw    : BFW_NX90_idpm_irq_host_masked_dpm_sw;    /* masked software IRQ for IRQ targets interrupt state for IDPM host interrupt                 */
  unsigned int reserved1 : BFW_NX90_idpm_irq_host_masked_reserved1; /* reserved                                                                                    */
  unsigned int firmware  : BFW_NX90_idpm_irq_host_masked_firmware;  /* masked combined handshake-cell and SYS_STA firmware interrupt state for IDPM host interrupt */
  unsigned int reserved2 : BFW_NX90_idpm_irq_host_masked_reserved2; /* reserved                                                                                    */
} NX90_IDPM_IRQ_HOST_MASKED_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_IDPM_IRQ_HOST_MASKED_BIT_T bf;
} NX90_IDPM_IRQ_HOST_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register idpm_sw_irq */
/* => DPM Register for Software Interrupt Generation to Host and netX Interrupt Targets. */
/*    Host and netX masters can generate an interrupt to netX interrupt targets (e.g. ARM-VIC) */
/*    by this register. */
/*    To propagate interrupt states from this register to the interrupt target the 'idpm_sw' IRQ must */
/*    be enabled inside the appropriate interrupt controller (e.g. the ARM-VIC). */
/*     */
/*    Note: */
/*       There is a set and a reset bit for the sw-IRQ to avoid read-modify-write sequences. */
/*       When both (set and reset) bits are set at the same time, the interrupt will be set (set will win). */
/*       The reset-bit is always 0 for read. The set-bit shows the current interrupt status when read. */
/*    Note: */
/*       This register is a new netx51/52 feature.. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_sw_irq      0x000000C0U
#define Adr_NX90_idpm_com_idpm_sw_irq 0xFF001BC0U
#define Adr_NX90_idpm_sw_irq          0xFF001BC0U
#define DFLT_VAL_NX90_idpm_sw_irq     0x00000000U

#define MSK_NX90_idpm_sw_irq_set_host           0x00000001U
#define SRT_NX90_idpm_sw_irq_set_host           0
#define DFLT_VAL_NX90_idpm_sw_irq_set_host      0x00000000U
#define DFLT_BF_VAL_NX90_idpm_sw_irq_set_host   0x00000000U
#define MSK_NX90_idpm_sw_irq_reset_host         0x00000100U
#define SRT_NX90_idpm_sw_irq_reset_host         8
#define DFLT_VAL_NX90_idpm_sw_irq_reset_host    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_sw_irq_reset_host 0x00000000U

/* all used bits of 'NX90_idpm_sw_irq': */
#define MSK_USED_BITS_NX90_idpm_sw_irq 0x00000101U

enum {
  BFW_NX90_idpm_sw_irq_set_host   = 1,  /* [0] */
  BFW_NX90_idpm_sw_irq_reserved1  = 7,  /* [7:1] */
  BFW_NX90_idpm_sw_irq_reset_host = 1,  /* [8] */
  BFW_NX90_idpm_sw_irq_reserved2  = 23  /* [31:9] */
};

typedef struct NX90_IDPM_SW_IRQ_BIT_Ttag {
  unsigned int set_host   : BFW_NX90_idpm_sw_irq_set_host;   /* Set 'dpm_sw' IRQ for host (current 'dpm_sw' status for host when read) */
  unsigned int reserved1  : BFW_NX90_idpm_sw_irq_reserved1;  /* reserved                                                               */
  unsigned int reset_host : BFW_NX90_idpm_sw_irq_reset_host; /* Reset 'dpm_sw' IRQ for host (always 0 when read)                       */
  unsigned int reserved2  : BFW_NX90_idpm_sw_irq_reserved2;  /* reserved                                                               */
} NX90_IDPM_SW_IRQ_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IDPM_SW_IRQ_BIT_T bf;
} NX90_IDPM_SW_IRQ_T;

/* --------------------------------------------------------------------- */
/* Register idpm_sys_sta */
/* => DPM System Status Information Register. */
/*    This register can be used for firmware status information. */
/*     */
/*    Note: */
/*       This register is NOT fully compatible to netx50 DPM_HOST_SYS_STAT register: */
/*       Only the HOST_STATE-bits of DPM0 can be read from the 'netx_status'-register inside ASIC_CTRL address area. */
/*       The HOST_STATE-bits of DPM1 and IDPM can not be read from the 'netx_status'-register inside */
/*       ASIC_CTRL address area. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_sys_sta      0x000000D8U
#define Adr_NX90_idpm_com_idpm_sys_sta 0xFF001BD8U
#define Adr_NX90_idpm_sys_sta          0xFF001BD8U
#define DFLT_VAL_NX90_idpm_sys_sta     0x00000000U

#define MSK_NX90_idpm_sys_sta_RDY_ro                   0x00000001U
#define SRT_NX90_idpm_sys_sta_RDY_ro                   0
#define DFLT_VAL_NX90_idpm_sys_sta_RDY_ro              0x00000000U
#define DFLT_BF_VAL_NX90_idpm_sys_sta_RDY_ro           0x00000000U
#define MSK_NX90_idpm_sys_sta_RUN_ro                   0x00000002U
#define SRT_NX90_idpm_sys_sta_RUN_ro                   1
#define DFLT_VAL_NX90_idpm_sys_sta_RUN_ro              0x00000000U
#define DFLT_BF_VAL_NX90_idpm_sys_sta_RUN_ro           0x00000000U
#define MSK_NX90_idpm_sys_sta_NETX_STATE_ro            0x0000000cU
#define SRT_NX90_idpm_sys_sta_NETX_STATE_ro            2
#define DFLT_VAL_NX90_idpm_sys_sta_NETX_STATE_ro       0x00000000U
#define DFLT_BF_VAL_NX90_idpm_sys_sta_NETX_STATE_ro    0x00000000U
#define MSK_NX90_idpm_sys_sta_HOST_STATE               0x000000f0U
#define SRT_NX90_idpm_sys_sta_HOST_STATE               4
#define DFLT_VAL_NX90_idpm_sys_sta_HOST_STATE          0x00000000U
#define DFLT_BF_VAL_NX90_idpm_sys_sta_HOST_STATE       0x00000000U
#define MSK_NX90_idpm_sys_sta_NETX_STA_CODE_ro         0x0000ff00U
#define SRT_NX90_idpm_sys_sta_NETX_STA_CODE_ro         8
#define DFLT_VAL_NX90_idpm_sys_sta_NETX_STA_CODE_ro    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_sys_sta_NETX_STA_CODE_ro 0x00000000U

/* all used bits of 'NX90_idpm_sys_sta': */
#define MSK_USED_BITS_NX90_idpm_sys_sta 0x0000ffffU

enum {
  BFW_NX90_idpm_sys_sta_RDY_ro           = 1,  /* [0] */
  BFW_NX90_idpm_sys_sta_RUN_ro           = 1,  /* [1] */
  BFW_NX90_idpm_sys_sta_NETX_STATE_ro    = 2,  /* [3:2] */
  BFW_NX90_idpm_sys_sta_HOST_STATE       = 4,  /* [7:4] */
  BFW_NX90_idpm_sys_sta_NETX_STA_CODE_ro = 8,  /* [15:8] */
  BFW_NX90_idpm_sys_sta_reserved1        = 16  /* [31:16] */
};

typedef struct NX90_IDPM_SYS_STA_BIT_Ttag {
  unsigned int RDY_ro           : BFW_NX90_idpm_sys_sta_RDY_ro;           /* Output state of netX RDY LED IO.                                                                */
                                                                          /* Note: This bit field can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL address area.    */
  unsigned int RUN_ro           : BFW_NX90_idpm_sys_sta_RUN_ro;           /* Output state of netX RUN LED IO.                                                                */
                                                                          /* Note: This bit field can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL address area.    */
  unsigned int NETX_STATE_ro    : BFW_NX90_idpm_sys_sta_NETX_STATE_ro;    /* Bit field for Hilscher firmware compatibility.                                                  */
                                                                          /* Note: This bit field can be changed by 'netx_status'-register inside ASIC_CTRL address area.    */
  unsigned int HOST_STATE       : BFW_NX90_idpm_sys_sta_HOST_STATE;       /* Bit field for Hilscher firmware.                                                                */
                                                                          /* Note: This bit field can NOT be read from 'netx_status'-register inside ASIC_CTRL address area. */
  unsigned int NETX_STA_CODE_ro : BFW_NX90_idpm_sys_sta_NETX_STA_CODE_ro; /* Bit field for Hilscher firmware compatibility (read only).                                      */
                                                                          /* Note: This bit field can be changed by 'netx_status'-register inside ASIC_CTRL address area.    */
  unsigned int reserved1        : BFW_NX90_idpm_sys_sta_reserved1;        /* reserved                                                                                        */
} NX90_IDPM_SYS_STA_BIT_T;

typedef union {
  uint32_t                val;
  NX90_IDPM_SYS_STA_BIT_T bf;
} NX90_IDPM_SYS_STA_T;

/* --------------------------------------------------------------------- */
/* Register idpm_reset_request */
/* => DPM Reset Request Register. */
/*     */
/*    Note: This register is compatible to netx50 DPM_HOST_RESET_REQ register */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_reset_request      0x000000DCU
#define Adr_NX90_idpm_com_idpm_reset_request 0xFF001BDCU
#define Adr_NX90_idpm_reset_request          0xFF001BDCU
#define DFLT_VAL_NX90_idpm_reset_request     0x00000000U

#define MSK_NX90_idpm_reset_request_reset_key         0x000000ffU
#define SRT_NX90_idpm_reset_request_reset_key         0
#define DFLT_VAL_NX90_idpm_reset_request_reset_key    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_reset_request_reset_key 0x00000000U

/* all used bits of 'NX90_idpm_reset_request': */
#define MSK_USED_BITS_NX90_idpm_reset_request 0x000000ffU

enum {
  BFW_NX90_idpm_reset_request_reset_key = 8,  /* [7:0] */
  BFW_NX90_idpm_reset_request_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_IDPM_RESET_REQUEST_BIT_Ttag {
  unsigned int reset_key : BFW_NX90_idpm_reset_request_reset_key; /* Reset key sequence register.                                                                        */
                                                                  /* A netx hardware reset is generated if the following sequence is written to this register:           */
                                                                  /*   1st access:    write 0x00                                                                         */
                                                                  /*   2nd access:    write 0x01                                                                         */
                                                                  /*   3rd access:    write 0x03                                                                         */
                                                                  /*   4th access:    write 0x07                                                                         */
                                                                  /*   5th access:    write 0x0f                                                                         */
                                                                  /*   6th access:    write 0x1f                                                                         */
                                                                  /*   7th access:    write 0x3f                                                                         */
                                                                  /*   8th access:    write 0x7f                                                                         */
                                                                  /* To issue a reset the sequence must not be interrupted by a write access to another register         */
                                                                  /* of this DPM module register area. Writing 0x00 will always restart the sequence.                    */
                                                                  /* Reading this register will always provide the next write data. Hence it is also possible            */
                                                                  /* performing 8 times a read-write sequence to this register (however this is not required,            */
                                                                  /* simply writing the sequence will also succeed).                                                     */
                                                                  /* Writing any other value than the next expected by the DPM module, the internal reset FSM will       */
                                                                  /* be cleared and the register will return 0x00 for the next read. The FSM will also be cleared        */
                                                                  /* if the sequence is interrupted by a write access to any other register of this DPM register         */
                                                                  /* area. The sequence must be restarted with the 1st access (writing 0x00) in this case.               */
                                                                  /* Note:                                                                                               */
                                                                  /*    The DPM reset request is internally a level-signal, not only a pulse. Additionally the           */
                                                                  /*    DPM reset request could be masked (disabled) by the global reset controller (netX4000).          */
                                                                  /*    If the DPM reset request is disabled globally but issued by the DPM module there are two         */
                                                                  /*    possibilities to get out of this:                                                                */
                                                                  /*    1.: Enable the DPM reset in the global reset controller. The NETX will be reset then             */
                                                                  /*        immediately (typically this must be done by the NETX-side CPU and cannot be done by a host). */
                                                                  /*    2.: Write 0x00 (or any other value except 0xFF) to this register or perform a write              */
                                                                  /*        access to any other register of this DPM register area. This will clear the DPM              */
                                                                  /*        reset FSM and the reset request of this DPM module to the global reset controller.           */
  unsigned int reserved1 : BFW_NX90_idpm_reset_request_reserved1; /* reserved                                                                                            */
} NX90_IDPM_RESET_REQUEST_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_IDPM_RESET_REQUEST_BIT_T bf;
} NX90_IDPM_RESET_REQUEST_T;

/* --------------------------------------------------------------------- */
/* Register idpm_firmware_irq_raw */
/* => 1st netx50 compatible DPM Interrupt Status Register (related to 'dpm_firmware_irq_mask'-register). */
/*    Writing a '1' to an IRQ flag will clear the Interrupt. This is always done even if related bit inside */
/*    'dpm_firmware_irq_mask'-register is not set (this is compatible to netx50). */
/*     */
/*    Important: */
/*       There are two completely independent sets of IRQ registers: */
/*       IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers). */
/*       IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). */
/*       Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs */
/*       can be found in both sets (e.g. com0). */
/*     */
/*    Note: */
/*       This register is compatible to netx50 DPM_HOST_INT_STAT0 register, however some unused */
/*       IRQs have been removed. */
/*     */
/*    Note: */
/*       For netX4000 there are 2 IDPM and 2 HANDSHAKE_CTRL units. IDPM0 is always associated with HANDSHAKE_CTRL0 */
/*       while IDPM1 is always associated with HANDSHAKE_CTRL1. */
/*     */
/*    Note: */
/*       The 2nd firmware IRQ register set (dpm_firmware_irq_mask2, DPM_HOST_INT_EN2, dpm_firmware_irq_raw2, DPM_HOST_INT_STAT2) */
/*       are obsolete since netx4000. Some functions moved to the main DPM IRQ register set (view dpm_irq_raw). */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_firmware_irq_raw      0x000000E0U
#define Adr_NX90_idpm_com_idpm_firmware_irq_raw 0xFF001BE0U
#define Adr_NX90_idpm_firmware_irq_raw          0xFF001BE0U
#define DFLT_VAL_NX90_idpm_firmware_irq_raw     0x00000000U

#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT0                  0x00000001U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT0                  0
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT0             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT0          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT1                  0x00000002U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT1                  1
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT1             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT1          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT2                  0x00000004U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT2                  2
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT2             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT2          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT3                  0x00000008U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT3                  3
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT3             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT3          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT4                  0x00000010U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT4                  4
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT4             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT4          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT5                  0x00000020U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT5                  5
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT5             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT5          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT6                  0x00000040U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT6                  6
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT6             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT6          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT7                  0x00000080U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT7                  7
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT7             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT7          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT8                  0x00000100U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT8                  8
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT8             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT8          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT9                  0x00000200U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT9                  9
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT9             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT9          0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT10                 0x00000400U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT10                 10
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT10            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT10         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT11                 0x00000800U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT11                 11
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT11            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT11         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT12                 0x00001000U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT12                 12
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT12            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT12         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT13                 0x00002000U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT13                 13
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT13            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT13         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT14                 0x00004000U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT14                 14
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT14            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT14         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_HS_EVENT15                 0x00008000U
#define SRT_NX90_idpm_firmware_irq_raw_HS_EVENT15                 15
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT15            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_HS_EVENT15         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_IRQ_VECTOR                 0x00ff0000U
#define SRT_NX90_idpm_firmware_irq_raw_IRQ_VECTOR                 16
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_IRQ_VECTOR            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_IRQ_VECTOR         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_res_TMR_ro                 0x02000000U
#define SRT_NX90_idpm_firmware_irq_raw_res_TMR_ro                 25
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_res_TMR_ro            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_res_TMR_ro         0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_SYS_STA                    0x04000000U
#define SRT_NX90_idpm_firmware_irq_raw_SYS_STA                    26
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_SYS_STA               0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_SYS_STA            0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro         0x10000000U
#define SRT_NX90_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro         28
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro 0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_res_WDG_NETX_ro            0x20000000U
#define SRT_NX90_idpm_firmware_irq_raw_res_WDG_NETX_ro            29
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_res_WDG_NETX_ro       0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_res_WDG_NETX_ro    0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_res_MEM_LCK_ro             0x40000000U
#define SRT_NX90_idpm_firmware_irq_raw_res_MEM_LCK_ro             30
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_res_MEM_LCK_ro        0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_res_MEM_LCK_ro     0x00000000U
#define MSK_NX90_idpm_firmware_irq_raw_INT_REQ                    0x80000000U
#define SRT_NX90_idpm_firmware_irq_raw_INT_REQ                    31
#define DFLT_VAL_NX90_idpm_firmware_irq_raw_INT_REQ               0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_raw_INT_REQ            0x00000000U

/* all used bits of 'NX90_idpm_firmware_irq_raw': */
#define MSK_USED_BITS_NX90_idpm_firmware_irq_raw 0xf6ffffffU

enum {
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT0          = 1, /* [0] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT1          = 1, /* [1] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT2          = 1, /* [2] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT3          = 1, /* [3] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT4          = 1, /* [4] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT5          = 1, /* [5] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT6          = 1, /* [6] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT7          = 1, /* [7] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT8          = 1, /* [8] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT9          = 1, /* [9] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT10         = 1, /* [10] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT11         = 1, /* [11] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT12         = 1, /* [12] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT13         = 1, /* [13] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT14         = 1, /* [14] */
  BFW_NX90_idpm_firmware_irq_raw_HS_EVENT15         = 1, /* [15] */
  BFW_NX90_idpm_firmware_irq_raw_IRQ_VECTOR         = 8, /* [23:16] */
  BFW_NX90_idpm_firmware_irq_raw_reserved1          = 1, /* [24] */
  BFW_NX90_idpm_firmware_irq_raw_res_TMR_ro         = 1, /* [25] */
  BFW_NX90_idpm_firmware_irq_raw_SYS_STA            = 1, /* [26] */
  BFW_NX90_idpm_firmware_irq_raw_reserved2          = 1, /* [27] */
  BFW_NX90_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro = 1, /* [28] */
  BFW_NX90_idpm_firmware_irq_raw_res_WDG_NETX_ro    = 1, /* [29] */
  BFW_NX90_idpm_firmware_irq_raw_res_MEM_LCK_ro     = 1, /* [30] */
  BFW_NX90_idpm_firmware_irq_raw_INT_REQ            = 1  /* [31] */
};

typedef struct NX90_IDPM_FIRMWARE_IRQ_RAW_BIT_Ttag {
  unsigned int HS_EVENT0          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT0;          /* Handshake Event 0  IRQ status flag.                                                              */
  unsigned int HS_EVENT1          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT1;          /* Handshake Event 1  IRQ status flag.                                                              */
  unsigned int HS_EVENT2          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT2;          /* Handshake Event 2  IRQ status flag.                                                              */
  unsigned int HS_EVENT3          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT3;          /* Handshake Event 3  IRQ status flag.                                                              */
  unsigned int HS_EVENT4          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT4;          /* Handshake Event 4  IRQ status flag.                                                              */
  unsigned int HS_EVENT5          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT5;          /* Handshake Event 5  IRQ status flag.                                                              */
  unsigned int HS_EVENT6          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT6;          /* Handshake Event 6  IRQ status flag.                                                              */
  unsigned int HS_EVENT7          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT7;          /* Handshake Event 7  IRQ status flag.                                                              */
  unsigned int HS_EVENT8          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT8;          /* Handshake Event 8  IRQ status flag.                                                              */
  unsigned int HS_EVENT9          : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT9;          /* Handshake Event 9  IRQ status flag.                                                              */
  unsigned int HS_EVENT10         : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT10;         /* Handshake Event 10 IRQ status flag.                                                              */
  unsigned int HS_EVENT11         : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT11;         /* Handshake Event 11 IRQ status flag.                                                              */
  unsigned int HS_EVENT12         : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT12;         /* Handshake Event 12 IRQ status flag.                                                              */
  unsigned int HS_EVENT13         : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT13;         /* Handshake Event 13 IRQ status flag.                                                              */
  unsigned int HS_EVENT14         : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT14;         /* Handshake Event 14 IRQ status flag.                                                              */
  unsigned int HS_EVENT15         : BFW_NX90_idpm_firmware_irq_raw_HS_EVENT15;         /* Handshake Event 15 IRQ status flag.                                                              */
  unsigned int IRQ_VECTOR         : BFW_NX90_idpm_firmware_irq_raw_IRQ_VECTOR;         /* Interrupt Vector according to status flags generated by enabled IRQ sources.                     */
                                                                                       /* {     |                                                                                          */
                                                                                       /*  Code   IRQ status                                                                               */
                                                                                       /*  0x00   No IRQ.                                                                                  */
                                                                                       /*  ----   -------                                                                                  */
                                                                                       /*  0x10   Handshake Cell 0 IRQ.                                                                    */
                                                                                       /*  0x11   Handshake Cell 1 IRQ.                                                                    */
                                                                                       /*  0x12   Handshake Cell 2 IRQ.                                                                    */
                                                                                       /*  0x13   Handshake Cell 3 IRQ.                                                                    */
                                                                                       /*  0x14   Handshake Cell 4 IRQ.                                                                    */
                                                                                       /*  0x15   Handshake Cell 5 IRQ.                                                                    */
                                                                                       /*  0x16   Handshake Cell 6 IRQ.                                                                    */
                                                                                       /*  0x17   Handshake Cell 7 IRQ.                                                                    */
                                                                                       /*  0x18   Handshake Cell 8 IRQ.                                                                    */
                                                                                       /*  0x19   Handshake Cell 9 IRQ.                                                                    */
                                                                                       /*  0x1a   Handshake Cell 10 IRQ.                                                                   */
                                                                                       /*  0x1b   Handshake Cell 11 IRQ.                                                                   */
                                                                                       /*  0x1c   Handshake Cell 12 IRQ.                                                                   */
                                                                                       /*  0x1d   Handshake Cell 13 IRQ.                                                                   */
                                                                                       /*  0x1e   Handshake Cell 14 IRQ.                                                                   */
                                                                                       /*  0x1f   Handshake Cell 15 IRQ.                                                                   */
                                                                                       /*  ----   -------                                                                                  */
                                                                                       /*  0x70   SYS_STA IRQ                                                                              */
                                                                                       /*  Other  values are reserved.}                                                                    */
                                                                                       /* Note:                                                                                            */
                                                                                       /*    The current IRQ state in VECTOR depends only on the single IRQ enable bits. It                */
                                                                                       /*    does not depend on global IRQ enable INT_EN. VECTOR shows always the highest priority enabled */
                                                                                       /*    flagged IRQ even is INT_EN is '0'.                                                            */
  unsigned int reserved1          : BFW_NX90_idpm_firmware_irq_raw_reserved1;          /* reserved                                                                                         */
  unsigned int res_TMR_ro         : BFW_NX90_idpm_firmware_irq_raw_res_TMR_ro;         /* reserved for Timer IRQ flag (not available in this netX version).                                */
  unsigned int SYS_STA            : BFW_NX90_idpm_firmware_irq_raw_SYS_STA;            /* System Status Change IRQ flag.                                                                   */
  unsigned int reserved2          : BFW_NX90_idpm_firmware_irq_raw_reserved2;          /* reserved                                                                                         */
  unsigned int res_RDY_TIMEOUT_ro : BFW_NX90_idpm_firmware_irq_raw_res_RDY_TIMEOUT_ro; /* reserved, DPM_RDY timeout error does not exist for IDPM.                                         */
  unsigned int res_WDG_NETX_ro    : BFW_NX90_idpm_firmware_irq_raw_res_WDG_NETX_ro;    /* reserved for netX supervision Watchdog Timeout IRQ flag (not available in this netX version).    */
  unsigned int res_MEM_LCK_ro     : BFW_NX90_idpm_firmware_irq_raw_res_MEM_LCK_ro;     /* reserved for Memory Lock IRQ flag (not available in this netX version).                          */
  unsigned int INT_REQ            : BFW_NX90_idpm_firmware_irq_raw_INT_REQ;            /* Interrupt Request for IRQs handled in this register.                                             */
                                                                                       /* 0: No Interrupts to host requested by IRQ sources handled in this register.                      */
                                                                                       /* 1: IRQ sources handled in this register request a host IRQ.                                      */
                                                                                       /* Note: This bit is masked by INT_EN-bit in dpm_firmware_irq_mask register.                        */
                                                                                       /*    For propagation of INT_REQ to host, ARM or xPIC, INT_EN-bit must be set and firmware IRQ      */
                                                                                       /*    must be activated in related dpm_irq_* register.                                              */
} NX90_IDPM_FIRMWARE_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_IDPM_FIRMWARE_IRQ_RAW_BIT_T bf;
} NX90_IDPM_FIRMWARE_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register idpm_firmware_irq_mask */
/* => DPM Handshake Interrupt Enable Register. */
/*    Only netx50 compatible 'dpm_firmware_irq' registers are related to settings of this register. */
/*     */
/*    Note: This register is compatible to netx50 DPM_HOST_INT_EN0 register, however some unused */
/*       IRQs have been removed. */
/*     */
/*    Note: HS_EVENT-bits are not read-only. This is netX50 compliant. */
/*       Recent netX50 Documentation marks HS_EVENT-bits as read-only. This is an dokumentation error. */
/*       For netX50 compatibility, these bits can also be controlled from netX-side in HANDSHAKE_CTRL address area. */
/*     */
/*    Note: The 2nd firmware IRQ register set (dpm_firmware_irq_mask2, DPM_HOST_INT_EN2, dpm_firmware_irq_raw2, DPM_HOST_INT_STAT2) */
/*       are obsolete since netx4000. Some functions moved to the main DPM IRQ register set (view dpm_irq_raw). */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_firmware_irq_mask      0x000000F0U
#define Adr_NX90_idpm_com_idpm_firmware_irq_mask 0xFF001BF0U
#define Adr_NX90_idpm_firmware_irq_mask          0xFF001BF0U
#define DFLT_VAL_NX90_idpm_firmware_irq_mask     0x00000000U

#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT0                  0x00000001U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT0                  0
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT0             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT0          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT1                  0x00000002U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT1                  1
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT1             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT1          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT2                  0x00000004U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT2                  2
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT2             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT2          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT3                  0x00000008U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT3                  3
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT3             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT3          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT4                  0x00000010U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT4                  4
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT4             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT4          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT5                  0x00000020U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT5                  5
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT5             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT5          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT6                  0x00000040U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT6                  6
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT6             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT6          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT7                  0x00000080U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT7                  7
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT7             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT7          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT8                  0x00000100U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT8                  8
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT8             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT8          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT9                  0x00000200U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT9                  9
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT9             0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT9          0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT10                 0x00000400U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT10                 10
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT10            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT10         0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT11                 0x00000800U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT11                 11
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT11            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT11         0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT12                 0x00001000U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT12                 12
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT12            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT12         0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT13                 0x00002000U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT13                 13
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT13            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT13         0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT14                 0x00004000U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT14                 14
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT14            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT14         0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_HS_EVENT15                 0x00008000U
#define SRT_NX90_idpm_firmware_irq_mask_HS_EVENT15                 15
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT15            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_HS_EVENT15         0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_res_TMR_ro                 0x02000000U
#define SRT_NX90_idpm_firmware_irq_mask_res_TMR_ro                 25
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_res_TMR_ro            0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_res_TMR_ro         0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_SYS_STA                    0x04000000U
#define SRT_NX90_idpm_firmware_irq_mask_SYS_STA                    26
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_SYS_STA               0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_SYS_STA            0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro         0x10000000U
#define SRT_NX90_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro         28
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro    0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro 0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_res_WDG_NETX_ro            0x20000000U
#define SRT_NX90_idpm_firmware_irq_mask_res_WDG_NETX_ro            29
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_res_WDG_NETX_ro       0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_res_WDG_NETX_ro    0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_res_MEM_LCK_ro             0x40000000U
#define SRT_NX90_idpm_firmware_irq_mask_res_MEM_LCK_ro             30
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_res_MEM_LCK_ro        0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_res_MEM_LCK_ro     0x00000000U
#define MSK_NX90_idpm_firmware_irq_mask_INT_EN                     0x80000000U
#define SRT_NX90_idpm_firmware_irq_mask_INT_EN                     31
#define DFLT_VAL_NX90_idpm_firmware_irq_mask_INT_EN                0x00000000U
#define DFLT_BF_VAL_NX90_idpm_firmware_irq_mask_INT_EN             0x00000000U

/* all used bits of 'NX90_idpm_firmware_irq_mask': */
#define MSK_USED_BITS_NX90_idpm_firmware_irq_mask 0xf600ffffU

enum {
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT0          = 1, /* [0] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT1          = 1, /* [1] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT2          = 1, /* [2] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT3          = 1, /* [3] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT4          = 1, /* [4] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT5          = 1, /* [5] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT6          = 1, /* [6] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT7          = 1, /* [7] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT8          = 1, /* [8] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT9          = 1, /* [9] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT10         = 1, /* [10] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT11         = 1, /* [11] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT12         = 1, /* [12] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT13         = 1, /* [13] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT14         = 1, /* [14] */
  BFW_NX90_idpm_firmware_irq_mask_HS_EVENT15         = 1, /* [15] */
  BFW_NX90_idpm_firmware_irq_mask_reserved1          = 9, /* [24:16] */
  BFW_NX90_idpm_firmware_irq_mask_res_TMR_ro         = 1, /* [25] */
  BFW_NX90_idpm_firmware_irq_mask_SYS_STA            = 1, /* [26] */
  BFW_NX90_idpm_firmware_irq_mask_reserved2          = 1, /* [27] */
  BFW_NX90_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro = 1, /* [28] */
  BFW_NX90_idpm_firmware_irq_mask_res_WDG_NETX_ro    = 1, /* [29] */
  BFW_NX90_idpm_firmware_irq_mask_res_MEM_LCK_ro     = 1, /* [30] */
  BFW_NX90_idpm_firmware_irq_mask_INT_EN             = 1  /* [31] */
};

typedef struct NX90_IDPM_FIRMWARE_IRQ_MASK_BIT_Ttag {
  unsigned int HS_EVENT0          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT0;          /* Handshake Event 0  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT1          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT1;          /* Handshake Event 1  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT2          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT2;          /* Handshake Event 2  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT3          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT3;          /* Handshake Event 3  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT4          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT4;          /* Handshake Event 4  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT5          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT5;          /* Handshake Event 5  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT6          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT6;          /* Handshake Event 6  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT7          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT7;          /* Handshake Event 7  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT8          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT8;          /* Handshake Event 8  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT9          : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT9;          /* Handshake Event 9  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT10         : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT10;         /* Handshake Event 10 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT11         : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT11;         /* Handshake Event 11 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT12         : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT12;         /* Handshake Event 12 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT13         : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT13;         /* Handshake Event 13 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT14         : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT14;         /* Handshake Event 14 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int HS_EVENT15         : BFW_NX90_idpm_firmware_irq_mask_HS_EVENT15;         /* Handshake Event 15 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
  unsigned int reserved1          : BFW_NX90_idpm_firmware_irq_mask_reserved1;          /* reserved                                                                                      */
  unsigned int res_TMR_ro         : BFW_NX90_idpm_firmware_irq_mask_res_TMR_ro;         /* reserved for Timer IRQ (not available in this netX version).                                  */
  unsigned int SYS_STA            : BFW_NX90_idpm_firmware_irq_mask_SYS_STA;            /* System Status Change IRQ Enable.                                                              */
  unsigned int reserved2          : BFW_NX90_idpm_firmware_irq_mask_reserved2;          /* reserved                                                                                      */
  unsigned int res_RDY_TIMEOUT_ro : BFW_NX90_idpm_firmware_irq_mask_res_RDY_TIMEOUT_ro; /* reserved, DPM_RDY timeout error does not exist for IDPM.                                      */
  unsigned int res_WDG_NETX_ro    : BFW_NX90_idpm_firmware_irq_mask_res_WDG_NETX_ro;    /* reserved for netX supervision Watchdog Timeout IRQ (not available in this netX version).      */
  unsigned int res_MEM_LCK_ro     : BFW_NX90_idpm_firmware_irq_mask_res_MEM_LCK_ro;     /* reserved for Memory Lock IRQ (not available in this netX version).                            */
  unsigned int INT_EN             : BFW_NX90_idpm_firmware_irq_mask_INT_EN;             /* Interrupt Enable for IRQs handled in this register.                                           */
                                                                                        /* Only if this bit is set, global firmware IRQ will be asserted to host CPU, ARM or xPIC        */
                                                                                        /* by dpm_irq_* registers.                                                                       */
                                                                                        /* 0: No Interrupts to host, ARM or xPIC are generated by IRQ sources handled in this register.  */
                                                                                        /* 1: Enabled IRQ sources handled in this register generate a host, ARM or xPIC IRQ if asserted. */
                                                                                        /* Note: Enable bits for single IRQ events are not affected if this bit is set or reset.         */
} NX90_IDPM_FIRMWARE_IRQ_MASK_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_IDPM_FIRMWARE_IRQ_MASK_BIT_T bf;
} NX90_IDPM_FIRMWARE_IRQ_MASK_T;

/* --------------------------------------------------------------------- */
/* Register idpm_netx_version */
/* => DPM netX Version Register. */
/*    This register is mirrored form asic_ctrl register area and can be set during netX booting phase by netX firmware. */
/*    This register is not valid if unlocked bit is not set in dpm_status register. */
/*    Together with dpm_netx_version register, full 32 bit version can be read by any host device, even if DPM interface is not initialized yet. */
/*    Bytes byte0 and byte2 can be always read here even if DPM is uninitialized (8 bit default from dpm_cfg0x0 after power on) and */
/*    host device has 8, 16 or 32 bit data width. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_idpm_netx_version      0x000000FCU
#define Adr_NX90_idpm_com_idpm_netx_version 0xFF001BFCU
#define Adr_NX90_idpm_netx_version          0xFF001BFCU

#define MSK_NX90_idpm_netx_version_netx_version 0xffffffffU
#define SRT_NX90_idpm_netx_version_netx_version 0

/* all used bits of 'NX90_idpm_netx_version': */
#define MSK_USED_BITS_NX90_idpm_netx_version 0xffffffffU

enum {
  BFW_NX90_idpm_netx_version_netx_version = 32  /* [31:0] */
};

typedef struct NX90_IDPM_NETX_VERSION_BIT_Ttag {
  unsigned int netx_version : BFW_NX90_idpm_netx_version_netx_version; /* netX version from version register. */
} NX90_IDPM_NETX_VERSION_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_IDPM_NETX_VERSION_BIT_T bf;
} NX90_IDPM_NETX_VERSION_T;


/* ===================================================================== */

/* Area of crypt */

/* ===================================================================== */

#define Addr_NX90_crypt 0xFF080000U

/* ===================================================================== */

/* Area of hash */

/* ===================================================================== */

#define Addr_NX90_hash 0xFF080000U

/* --------------------------------------------------------------------- */
/* Register hash_din */
/* => Hash FIFO input: */
/*    Unlike all other registers, this address can be written with DWord(32 Bit), Word(16 Bit) or Byte acccss. */
/*    The FIFO controller will automatically collect data and start HASH-calculation, */
/*    if enough data (complete DWords) are collected. */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_din  0x00000000U
#define Adr_NX90_hash_hash_din 0xFF080000U
#define Adr_NX90_hash_din      0xFF080000U
#define DFLT_VAL_NX90_hash_din 0x00000000U

#define MSK_NX90_hash_din_val         0xffffffffU
#define SRT_NX90_hash_din_val         0
#define DFLT_VAL_NX90_hash_din_val    0x00000000U
#define DFLT_BF_VAL_NX90_hash_din_val 0x00000000U

/* all used bits of 'NX90_hash_din': */
#define MSK_USED_BITS_NX90_hash_din 0xffffffffU

enum {
  BFW_NX90_hash_din_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DIN_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_din_val; /* data bits */
} NX90_HASH_DIN_BIT_T;

typedef union {
  uint32_t            val;
  NX90_HASH_DIN_BIT_T bf;
} NX90_HASH_DIN_T;

/* --------------------------------------------------------------------- */
/* Register hash_cfg */
/* => Hash config register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_cfg  0x00000004U
#define Adr_NX90_hash_hash_cfg 0xFF080004U
#define Adr_NX90_hash_cfg      0xFF080004U
#define DFLT_VAL_NX90_hash_cfg 0x00000020U

#define MSK_NX90_hash_cfg_mode                   0x00000007U
#define SRT_NX90_hash_cfg_mode                   0
#define DFLT_VAL_NX90_hash_cfg_mode              0x00000000U
#define DFLT_BF_VAL_NX90_hash_cfg_mode           0x00000000U
#define MSK_NX90_hash_cfg_reset                  0x00000008U
#define SRT_NX90_hash_cfg_reset                  3
#define DFLT_VAL_NX90_hash_cfg_reset             0x00000000U
#define DFLT_BF_VAL_NX90_hash_cfg_reset          0x00000000U
#define MSK_NX90_hash_cfg_dma_en                 0x00000010U
#define SRT_NX90_hash_cfg_dma_en                 4
#define DFLT_VAL_NX90_hash_cfg_dma_en            0x00000000U
#define DFLT_BF_VAL_NX90_hash_cfg_dma_en         0x00000000U
#define MSK_NX90_hash_cfg_dma_burst_only         0x00000020U
#define SRT_NX90_hash_cfg_dma_burst_only         5
#define DFLT_VAL_NX90_hash_cfg_dma_burst_only    0x00000020U
#define DFLT_BF_VAL_NX90_hash_cfg_dma_burst_only 0x00000001U

/* all used bits of 'NX90_hash_cfg': */
#define MSK_USED_BITS_NX90_hash_cfg 0x0000003fU

enum {
  BFW_NX90_hash_cfg_mode           = 3,  /* [2:0] */
  BFW_NX90_hash_cfg_reset          = 1,  /* [3] */
  BFW_NX90_hash_cfg_dma_en         = 1,  /* [4] */
  BFW_NX90_hash_cfg_dma_burst_only = 1,  /* [5] */
  BFW_NX90_hash_cfg_reserved1      = 26  /* [31:6] */
};

typedef struct NX90_HASH_CFG_BIT_Ttag {
  unsigned int mode           : BFW_NX90_hash_cfg_mode;           /* Hash core mode                                                            */
                                                                  /* 100: MD5                                                                  */
                                                                  /* 011: SHA2-512                                                             */
                                                                  /* 010: SHA2-384                                                             */
                                                                  /* 001: SHA2-256                                                             */
                                                                  /* 000: SHA1-160                                                             */
                                                                  /* Note: When changing the mode, a reset must be performed to correctly      */
                                                                  /* initialize the SHA/MD5 core. This can be done by setting the 'reset' bit  */
                                                                  /* together with the new mode or in a second access after setting the mode.  */
  unsigned int reset          : BFW_NX90_hash_cfg_reset;          /* Reset of SHA engine:                                                      */
                                                                  /* After writing '1', this bit will automatically be reset.                  */
                                                                  /* 1: reset internal registers, use this to start calculation of new hash    */
                                                                  /* 0: start calculation as soon as enough data in FIFO buffer                */
  unsigned int dma_en         : BFW_NX90_hash_cfg_dma_en;         /* Enable DMAC control signals                                               */
  unsigned int dma_burst_only : BFW_NX90_hash_cfg_dma_burst_only; /* Generate DMAC burst signal only.                                          */
                                                                  /* When set to '1' the DMAC logic will only generate burst requests to the   */
                                                                  /* DMAC. This is to overcome limitations of the current DMA controller       */
                                                                  /* implementation that only accepts burst requests for DMAC controlled       */
                                                                  /* memory to peripheral transfers.                                           */
  unsigned int reserved1      : BFW_NX90_hash_cfg_reserved1;      /* reserved                                                                  */
} NX90_HASH_CFG_BIT_T;

typedef union {
  uint32_t            val;
  NX90_HASH_CFG_BIT_T bf;
} NX90_HASH_CFG_T;

/* --------------------------------------------------------------------- */
/* Register hash_stat */
/* => Hash status register: */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_stat  0x00000008U
#define Adr_NX90_hash_hash_stat 0xFF080008U
#define Adr_NX90_hash_stat      0xFF080008U

#define MSK_NX90_hash_stat_fifo_fill 0x000001ffU
#define SRT_NX90_hash_stat_fifo_fill 0

/* all used bits of 'NX90_hash_stat': */
#define MSK_USED_BITS_NX90_hash_stat 0x000001ffU

enum {
  BFW_NX90_hash_stat_fifo_fill = 9,  /* [8:0] */
  BFW_NX90_hash_stat_reserved1 = 23  /* [31:9] */
};

typedef struct NX90_HASH_STAT_BIT_Ttag {
  unsigned int fifo_fill : BFW_NX90_hash_stat_fifo_fill; /* Fill level of FIFO in bytes (0..256) */
  unsigned int reserved1 : BFW_NX90_hash_stat_reserved1; /* reserved                             */
} NX90_HASH_STAT_BIT_T;

typedef union {
  uint32_t             val;
  NX90_HASH_STAT_BIT_T bf;
} NX90_HASH_STAT_T;

/* --------------------------------------------------------------------- */
/* Register hash_debug_info */
/* => Hash info register: */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_debug_info  0x0000000CU
#define Adr_NX90_hash_hash_debug_info 0xFF08000CU
#define Adr_NX90_hash_debug_info      0xFF08000CU

#define MSK_NX90_hash_debug_info_sha_round 0x0000007fU
#define SRT_NX90_hash_debug_info_sha_round 0

/* all used bits of 'NX90_hash_debug_info': */
#define MSK_USED_BITS_NX90_hash_debug_info 0x0000007fU

enum {
  BFW_NX90_hash_debug_info_sha_round = 7,  /* [6:0] */
  BFW_NX90_hash_debug_info_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_HASH_DEBUG_INFO_BIT_Ttag {
  unsigned int sha_round : BFW_NX90_hash_debug_info_sha_round; /* 7bit current state counter of the SHA core. */
  unsigned int reserved1 : BFW_NX90_hash_debug_info_reserved1; /* reserved                                    */
} NX90_HASH_DEBUG_INFO_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_HASH_DEBUG_INFO_BIT_T bf;
} NX90_HASH_DEBUG_INFO_T;

/* --------------------------------------------------------------------- */
/* Register hash_irq_raw */
/* => Hash raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_irq_raw  0x00000010U
#define Adr_NX90_hash_hash_irq_raw 0xFF080010U
#define Adr_NX90_hash_irq_raw      0xFF080010U
#define DFLT_VAL_NX90_hash_irq_raw 0x00000000U

#define MSK_NX90_hash_irq_raw_hash_ready            0x00000001U
#define SRT_NX90_hash_irq_raw_hash_ready            0
#define DFLT_VAL_NX90_hash_irq_raw_hash_ready       0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_raw_hash_ready    0x00000000U
#define MSK_NX90_hash_irq_raw_fifo_underrun         0x00000002U
#define SRT_NX90_hash_irq_raw_fifo_underrun         1
#define DFLT_VAL_NX90_hash_irq_raw_fifo_underrun    0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_raw_fifo_underrun 0x00000000U
#define MSK_NX90_hash_irq_raw_fifo_overflow         0x00000004U
#define SRT_NX90_hash_irq_raw_fifo_overflow         2
#define DFLT_VAL_NX90_hash_irq_raw_fifo_overflow    0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_raw_fifo_overflow 0x00000000U

/* all used bits of 'NX90_hash_irq_raw': */
#define MSK_USED_BITS_NX90_hash_irq_raw 0x00000007U

enum {
  BFW_NX90_hash_irq_raw_hash_ready    = 1,  /* [0] */
  BFW_NX90_hash_irq_raw_fifo_underrun = 1,  /* [1] */
  BFW_NX90_hash_irq_raw_fifo_overflow = 1,  /* [2] */
  BFW_NX90_hash_irq_raw_reserved1     = 29  /* [31:3] */
};

typedef struct NX90_HASH_IRQ_RAW_BIT_Ttag {
  unsigned int hash_ready    : BFW_NX90_hash_irq_raw_hash_ready;    /* Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid.  */
                                                                    /* Note: This interrupt will be asserted when the hash FIFO is empty and the calculation of the last  */
                                                                    /* block from the FIFO has finished. The interrupt will be re-asserted after clearing as long as      */
                                                                    /* no new data has been fed into the FIFO or a software reset has been performed (hash_cfg-reset=1).  */
                                                                    /* Note: This interrupt could have got asserted in situations where the FIFO runs empty, the hash     */
                                                                    /* core finished the operation and new data blocks will be fed into the FIFO afterwards.              */
                                                                    /* In this case the IRQ will have been asserted before the very last block has been processed.        */
                                                                    /* In such situations it is advised to either disable the interrupt (hash_irq_mask_reset) and enable  */
                                                                    /* it after putting the very last data into the FIFO (hash_irq_mask_set) or to clear the IRQ once     */
                                                                    /* after putting the very last data and ignore any previous IRQs.                                     */
  unsigned int fifo_underrun : BFW_NX90_hash_irq_raw_fifo_underrun; /* input buffer was underrun, set hash_cfg-reset=1 to reset this bit.                                 */
                                                                    /* Note: underrun is only a theoretical FIFO status, because the hardware logic of the hash core      */
                                                                    /* won't fetch data from the FIFO when it's empty.                                                    */
  unsigned int fifo_overflow : BFW_NX90_hash_irq_raw_fifo_overflow; /* input buffer was overflown, set hash_cfg-reset=1 to reset this bit.                                */
  unsigned int reserved1     : BFW_NX90_hash_irq_raw_reserved1;     /* reserved                                                                                           */
} NX90_HASH_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                val;
  NX90_HASH_IRQ_RAW_BIT_T bf;
} NX90_HASH_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register hash_irq_masked */
/* => Hash masked IRQ: */
/*    Shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_irq_masked  0x00000014U
#define Adr_NX90_hash_hash_irq_masked 0xFF080014U
#define Adr_NX90_hash_irq_masked      0xFF080014U

#define MSK_NX90_hash_irq_masked_hash_ready    0x00000001U
#define SRT_NX90_hash_irq_masked_hash_ready    0
#define MSK_NX90_hash_irq_masked_fifo_underrun 0x00000002U
#define SRT_NX90_hash_irq_masked_fifo_underrun 1
#define MSK_NX90_hash_irq_masked_fifo_overflow 0x00000004U
#define SRT_NX90_hash_irq_masked_fifo_overflow 2

/* all used bits of 'NX90_hash_irq_masked': */
#define MSK_USED_BITS_NX90_hash_irq_masked 0x00000007U

enum {
  BFW_NX90_hash_irq_masked_hash_ready    = 1,  /* [0] */
  BFW_NX90_hash_irq_masked_fifo_underrun = 1,  /* [1] */
  BFW_NX90_hash_irq_masked_fifo_overflow = 1,  /* [2] */
  BFW_NX90_hash_irq_masked_reserved1     = 29  /* [31:3] */
};

typedef struct NX90_HASH_IRQ_MASKED_BIT_Ttag {
  unsigned int hash_ready    : BFW_NX90_hash_irq_masked_hash_ready;    /* Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid */
  unsigned int fifo_underrun : BFW_NX90_hash_irq_masked_fifo_underrun; /* input buffer was underrun, set hash_cfg-reset=1 to reset this bit                                */
  unsigned int fifo_overflow : BFW_NX90_hash_irq_masked_fifo_overflow; /* input buffer was overflown, set hash_cfg-reset=1 to reset this bit                               */
  unsigned int reserved1     : BFW_NX90_hash_irq_masked_reserved1;     /* reserved                                                                                         */
} NX90_HASH_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_HASH_IRQ_MASKED_BIT_T bf;
} NX90_HASH_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register hash_irq_msk_set */
/* => Hash IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to crypt_hash_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_irq_msk_set  0x00000018U
#define Adr_NX90_hash_hash_irq_msk_set 0xFF080018U
#define Adr_NX90_hash_irq_msk_set      0xFF080018U
#define DFLT_VAL_NX90_hash_irq_msk_set 0x00000000U

#define MSK_NX90_hash_irq_msk_set_hash_ready            0x00000001U
#define SRT_NX90_hash_irq_msk_set_hash_ready            0
#define DFLT_VAL_NX90_hash_irq_msk_set_hash_ready       0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_msk_set_hash_ready    0x00000000U
#define MSK_NX90_hash_irq_msk_set_fifo_underrun         0x00000002U
#define SRT_NX90_hash_irq_msk_set_fifo_underrun         1
#define DFLT_VAL_NX90_hash_irq_msk_set_fifo_underrun    0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_msk_set_fifo_underrun 0x00000000U
#define MSK_NX90_hash_irq_msk_set_fifo_overflow         0x00000004U
#define SRT_NX90_hash_irq_msk_set_fifo_overflow         2
#define DFLT_VAL_NX90_hash_irq_msk_set_fifo_overflow    0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_msk_set_fifo_overflow 0x00000000U

/* all used bits of 'NX90_hash_irq_msk_set': */
#define MSK_USED_BITS_NX90_hash_irq_msk_set 0x00000007U

enum {
  BFW_NX90_hash_irq_msk_set_hash_ready    = 1,  /* [0] */
  BFW_NX90_hash_irq_msk_set_fifo_underrun = 1,  /* [1] */
  BFW_NX90_hash_irq_msk_set_fifo_overflow = 1,  /* [2] */
  BFW_NX90_hash_irq_msk_set_reserved1     = 29  /* [31:3] */
};

typedef struct NX90_HASH_IRQ_MSK_SET_BIT_Ttag {
  unsigned int hash_ready    : BFW_NX90_hash_irq_msk_set_hash_ready;    /* Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid */
  unsigned int fifo_underrun : BFW_NX90_hash_irq_msk_set_fifo_underrun; /* input buffer was underrun, set hash_cfg-reset=1 to reset this bit                                */
  unsigned int fifo_overflow : BFW_NX90_hash_irq_msk_set_fifo_overflow; /* input buffer was overflown, set hash_cfg-reset=1 to reset this bit                               */
  unsigned int reserved1     : BFW_NX90_hash_irq_msk_set_reserved1;     /* reserved                                                                                         */
} NX90_HASH_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_HASH_IRQ_MSK_SET_BIT_T bf;
} NX90_HASH_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register hash_irq_msk_reset */
/* => Hash IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_irq_msk_reset  0x0000001CU
#define Adr_NX90_hash_hash_irq_msk_reset 0xFF08001CU
#define Adr_NX90_hash_irq_msk_reset      0xFF08001CU
#define DFLT_VAL_NX90_hash_irq_msk_reset 0x00000000U

#define MSK_NX90_hash_irq_msk_reset_hash_ready            0x00000001U
#define SRT_NX90_hash_irq_msk_reset_hash_ready            0
#define DFLT_VAL_NX90_hash_irq_msk_reset_hash_ready       0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_msk_reset_hash_ready    0x00000000U
#define MSK_NX90_hash_irq_msk_reset_fifo_underrun         0x00000002U
#define SRT_NX90_hash_irq_msk_reset_fifo_underrun         1
#define DFLT_VAL_NX90_hash_irq_msk_reset_fifo_underrun    0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_msk_reset_fifo_underrun 0x00000000U
#define MSK_NX90_hash_irq_msk_reset_fifo_overflow         0x00000004U
#define SRT_NX90_hash_irq_msk_reset_fifo_overflow         2
#define DFLT_VAL_NX90_hash_irq_msk_reset_fifo_overflow    0x00000000U
#define DFLT_BF_VAL_NX90_hash_irq_msk_reset_fifo_overflow 0x00000000U

/* all used bits of 'NX90_hash_irq_msk_reset': */
#define MSK_USED_BITS_NX90_hash_irq_msk_reset 0x00000007U

enum {
  BFW_NX90_hash_irq_msk_reset_hash_ready    = 1,  /* [0] */
  BFW_NX90_hash_irq_msk_reset_fifo_underrun = 1,  /* [1] */
  BFW_NX90_hash_irq_msk_reset_fifo_overflow = 1,  /* [2] */
  BFW_NX90_hash_irq_msk_reset_reserved1     = 29  /* [31:3] */
};

typedef struct NX90_HASH_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int hash_ready    : BFW_NX90_hash_irq_msk_reset_hash_ready;    /* Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid */
  unsigned int fifo_underrun : BFW_NX90_hash_irq_msk_reset_fifo_underrun; /* input buffer was underrun, set hash_cfg-reset=1 to reset this bit                                */
  unsigned int fifo_overflow : BFW_NX90_hash_irq_msk_reset_fifo_overflow; /* input buffer was overflown, set hash_cfg-reset=1 to reset this bit                               */
  unsigned int reserved1     : BFW_NX90_hash_irq_msk_reset_reserved1;     /* reserved                                                                                         */
} NX90_HASH_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_HASH_IRQ_MSK_RESET_BIT_T bf;
} NX90_HASH_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout0 */
/* => Hash value0 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout0  0x00000020U
#define Adr_NX90_hash_hash_dout0 0xFF080020U
#define Adr_NX90_hash_dout0      0xFF080020U

#define MSK_NX90_hash_dout0_val 0xffffffffU
#define SRT_NX90_hash_dout0_val 0

/* all used bits of 'NX90_hash_dout0': */
#define MSK_USED_BITS_NX90_hash_dout0 0xffffffffU

enum {
  BFW_NX90_hash_dout0_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT0_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout0_val; /* data bits 31..0 */
} NX90_HASH_DOUT0_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT0_BIT_T bf;
} NX90_HASH_DOUT0_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout1 */
/* => Hash value1 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout1  0x00000024U
#define Adr_NX90_hash_hash_dout1 0xFF080024U
#define Adr_NX90_hash_dout1      0xFF080024U

#define MSK_NX90_hash_dout1_val 0xffffffffU
#define SRT_NX90_hash_dout1_val 0

/* all used bits of 'NX90_hash_dout1': */
#define MSK_USED_BITS_NX90_hash_dout1 0xffffffffU

enum {
  BFW_NX90_hash_dout1_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT1_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout1_val; /* data bits 63..32 */
} NX90_HASH_DOUT1_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT1_BIT_T bf;
} NX90_HASH_DOUT1_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout2 */
/* => Hash value2 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout2  0x00000028U
#define Adr_NX90_hash_hash_dout2 0xFF080028U
#define Adr_NX90_hash_dout2      0xFF080028U

#define MSK_NX90_hash_dout2_val 0xffffffffU
#define SRT_NX90_hash_dout2_val 0

/* all used bits of 'NX90_hash_dout2': */
#define MSK_USED_BITS_NX90_hash_dout2 0xffffffffU

enum {
  BFW_NX90_hash_dout2_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT2_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout2_val; /* data bits 95..64 */
} NX90_HASH_DOUT2_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT2_BIT_T bf;
} NX90_HASH_DOUT2_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout3 */
/* => Hash value3 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout3  0x0000002CU
#define Adr_NX90_hash_hash_dout3 0xFF08002CU
#define Adr_NX90_hash_dout3      0xFF08002CU

#define MSK_NX90_hash_dout3_val 0xffffffffU
#define SRT_NX90_hash_dout3_val 0

/* all used bits of 'NX90_hash_dout3': */
#define MSK_USED_BITS_NX90_hash_dout3 0xffffffffU

enum {
  BFW_NX90_hash_dout3_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT3_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout3_val; /* data bits 127..96 */
} NX90_HASH_DOUT3_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT3_BIT_T bf;
} NX90_HASH_DOUT3_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout4 */
/* => Hash value4 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout4  0x00000030U
#define Adr_NX90_hash_hash_dout4 0xFF080030U
#define Adr_NX90_hash_dout4      0xFF080030U

#define MSK_NX90_hash_dout4_val 0xffffffffU
#define SRT_NX90_hash_dout4_val 0

/* all used bits of 'NX90_hash_dout4': */
#define MSK_USED_BITS_NX90_hash_dout4 0xffffffffU

enum {
  BFW_NX90_hash_dout4_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT4_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout4_val; /* data bits 159..128 */
} NX90_HASH_DOUT4_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT4_BIT_T bf;
} NX90_HASH_DOUT4_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout5 */
/* => Hash value5 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout5  0x00000034U
#define Adr_NX90_hash_hash_dout5 0xFF080034U
#define Adr_NX90_hash_dout5      0xFF080034U

#define MSK_NX90_hash_dout5_val 0xffffffffU
#define SRT_NX90_hash_dout5_val 0

/* all used bits of 'NX90_hash_dout5': */
#define MSK_USED_BITS_NX90_hash_dout5 0xffffffffU

enum {
  BFW_NX90_hash_dout5_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT5_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout5_val; /* data bits 191..160 */
} NX90_HASH_DOUT5_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT5_BIT_T bf;
} NX90_HASH_DOUT5_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout6 */
/* => Hash value6 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout6  0x00000038U
#define Adr_NX90_hash_hash_dout6 0xFF080038U
#define Adr_NX90_hash_dout6      0xFF080038U

#define MSK_NX90_hash_dout6_val 0xffffffffU
#define SRT_NX90_hash_dout6_val 0

/* all used bits of 'NX90_hash_dout6': */
#define MSK_USED_BITS_NX90_hash_dout6 0xffffffffU

enum {
  BFW_NX90_hash_dout6_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT6_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout6_val; /* data bits 223..192 */
} NX90_HASH_DOUT6_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT6_BIT_T bf;
} NX90_HASH_DOUT6_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout7 */
/* => Hash value7 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout7  0x0000003CU
#define Adr_NX90_hash_hash_dout7 0xFF08003CU
#define Adr_NX90_hash_dout7      0xFF08003CU

#define MSK_NX90_hash_dout7_val 0xffffffffU
#define SRT_NX90_hash_dout7_val 0

/* all used bits of 'NX90_hash_dout7': */
#define MSK_USED_BITS_NX90_hash_dout7 0xffffffffU

enum {
  BFW_NX90_hash_dout7_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT7_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout7_val; /* data bits 255..224 */
} NX90_HASH_DOUT7_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT7_BIT_T bf;
} NX90_HASH_DOUT7_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout8 */
/* => Hash value8 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout8  0x00000040U
#define Adr_NX90_hash_hash_dout8 0xFF080040U
#define Adr_NX90_hash_dout8      0xFF080040U

#define MSK_NX90_hash_dout8_val 0xffffffffU
#define SRT_NX90_hash_dout8_val 0

/* all used bits of 'NX90_hash_dout8': */
#define MSK_USED_BITS_NX90_hash_dout8 0xffffffffU

enum {
  BFW_NX90_hash_dout8_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT8_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout8_val; /* data bits 287..256 */
} NX90_HASH_DOUT8_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT8_BIT_T bf;
} NX90_HASH_DOUT8_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout9 */
/* => Hash value9 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout9  0x00000044U
#define Adr_NX90_hash_hash_dout9 0xFF080044U
#define Adr_NX90_hash_dout9      0xFF080044U

#define MSK_NX90_hash_dout9_val 0xffffffffU
#define SRT_NX90_hash_dout9_val 0

/* all used bits of 'NX90_hash_dout9': */
#define MSK_USED_BITS_NX90_hash_dout9 0xffffffffU

enum {
  BFW_NX90_hash_dout9_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT9_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout9_val; /* data bits 319..288 */
} NX90_HASH_DOUT9_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HASH_DOUT9_BIT_T bf;
} NX90_HASH_DOUT9_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout10 */
/* => Hash value10 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout10  0x00000048U
#define Adr_NX90_hash_hash_dout10 0xFF080048U
#define Adr_NX90_hash_dout10      0xFF080048U

#define MSK_NX90_hash_dout10_val 0xffffffffU
#define SRT_NX90_hash_dout10_val 0

/* all used bits of 'NX90_hash_dout10': */
#define MSK_USED_BITS_NX90_hash_dout10 0xffffffffU

enum {
  BFW_NX90_hash_dout10_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT10_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout10_val; /* data bits 351..320 */
} NX90_HASH_DOUT10_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HASH_DOUT10_BIT_T bf;
} NX90_HASH_DOUT10_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout11 */
/* => Hash value11 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout11  0x0000004CU
#define Adr_NX90_hash_hash_dout11 0xFF08004CU
#define Adr_NX90_hash_dout11      0xFF08004CU

#define MSK_NX90_hash_dout11_val 0xffffffffU
#define SRT_NX90_hash_dout11_val 0

/* all used bits of 'NX90_hash_dout11': */
#define MSK_USED_BITS_NX90_hash_dout11 0xffffffffU

enum {
  BFW_NX90_hash_dout11_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT11_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout11_val; /* data bits 383..352 */
} NX90_HASH_DOUT11_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HASH_DOUT11_BIT_T bf;
} NX90_HASH_DOUT11_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout12 */
/* => Hash value12 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout12  0x00000050U
#define Adr_NX90_hash_hash_dout12 0xFF080050U
#define Adr_NX90_hash_dout12      0xFF080050U

#define MSK_NX90_hash_dout12_val 0xffffffffU
#define SRT_NX90_hash_dout12_val 0

/* all used bits of 'NX90_hash_dout12': */
#define MSK_USED_BITS_NX90_hash_dout12 0xffffffffU

enum {
  BFW_NX90_hash_dout12_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT12_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout12_val; /* data bits 415..384 */
} NX90_HASH_DOUT12_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HASH_DOUT12_BIT_T bf;
} NX90_HASH_DOUT12_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout13 */
/* => Hash value13 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout13  0x00000054U
#define Adr_NX90_hash_hash_dout13 0xFF080054U
#define Adr_NX90_hash_dout13      0xFF080054U

#define MSK_NX90_hash_dout13_val 0xffffffffU
#define SRT_NX90_hash_dout13_val 0

/* all used bits of 'NX90_hash_dout13': */
#define MSK_USED_BITS_NX90_hash_dout13 0xffffffffU

enum {
  BFW_NX90_hash_dout13_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT13_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout13_val; /* data bits 447..416 */
} NX90_HASH_DOUT13_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HASH_DOUT13_BIT_T bf;
} NX90_HASH_DOUT13_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout14 */
/* => Hash value14 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout14  0x00000058U
#define Adr_NX90_hash_hash_dout14 0xFF080058U
#define Adr_NX90_hash_dout14      0xFF080058U

#define MSK_NX90_hash_dout14_val 0xffffffffU
#define SRT_NX90_hash_dout14_val 0

/* all used bits of 'NX90_hash_dout14': */
#define MSK_USED_BITS_NX90_hash_dout14 0xffffffffU

enum {
  BFW_NX90_hash_dout14_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT14_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout14_val; /* data bits 479..448 */
} NX90_HASH_DOUT14_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HASH_DOUT14_BIT_T bf;
} NX90_HASH_DOUT14_T;

/* --------------------------------------------------------------------- */
/* Register hash_dout15 */
/* => Hash value15 register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hash_dout15  0x0000005CU
#define Adr_NX90_hash_hash_dout15 0xFF08005CU
#define Adr_NX90_hash_dout15      0xFF08005CU

#define MSK_NX90_hash_dout15_val 0xffffffffU
#define SRT_NX90_hash_dout15_val 0

/* all used bits of 'NX90_hash_dout15': */
#define MSK_USED_BITS_NX90_hash_dout15 0xffffffffU

enum {
  BFW_NX90_hash_dout15_val = 32  /* [31:0] */
};

typedef struct NX90_HASH_DOUT15_BIT_Ttag {
  unsigned int val : BFW_NX90_hash_dout15_val; /* data bits 511..480 */
} NX90_HASH_DOUT15_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HASH_DOUT15_BIT_T bf;
} NX90_HASH_DOUT15_T;


/* ===================================================================== */

/* Area of aes */

/* ===================================================================== */

#define Addr_NX90_aes 0xFF080080U

/* --------------------------------------------------------------------- */
/* Register aes_cfg */
/* => AES config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_cfg  0x00000000U
#define Adr_NX90_aes_aes_cfg  0xFF080080U
#define Adr_NX90_aes_cfg      0xFF080080U
#define DFLT_VAL_NX90_aes_cfg 0x00148200U

#define MSK_NX90_aes_cfg_enable                          0x00000001U
#define SRT_NX90_aes_cfg_enable                          0
#define DFLT_VAL_NX90_aes_cfg_enable                     0x00000000U
#define DFLT_BF_VAL_NX90_aes_cfg_enable                  0x00000000U
#define MSK_NX90_aes_cfg_mode                            0x00000002U
#define SRT_NX90_aes_cfg_mode                            1
#define DFLT_VAL_NX90_aes_cfg_mode                       0x00000000U
#define DFLT_BF_VAL_NX90_aes_cfg_mode                    0x00000000U
#define MSK_NX90_aes_cfg_key_len                         0x0000000cU
#define SRT_NX90_aes_cfg_key_len                         2
#define DFLT_VAL_NX90_aes_cfg_key_len                    0x00000000U
#define DFLT_BF_VAL_NX90_aes_cfg_key_len                 0x00000000U
#define MSK_NX90_aes_cfg_key_exp_start                   0x00000010U
#define SRT_NX90_aes_cfg_key_exp_start                   4
#define DFLT_VAL_NX90_aes_cfg_key_exp_start              0x00000000U
#define DFLT_BF_VAL_NX90_aes_cfg_key_exp_start           0x00000000U
#define MSK_NX90_aes_cfg_in_fifo_wm                      0x000007e0U
#define SRT_NX90_aes_cfg_in_fifo_wm                      5
#define DFLT_VAL_NX90_aes_cfg_in_fifo_wm                 0x00000200U
#define DFLT_BF_VAL_NX90_aes_cfg_in_fifo_wm              0x00000010U
#define MSK_NX90_aes_cfg_out_fifo_wm                     0x0001f800U
#define SRT_NX90_aes_cfg_out_fifo_wm                     11
#define DFLT_VAL_NX90_aes_cfg_out_fifo_wm                0x00008000U
#define DFLT_BF_VAL_NX90_aes_cfg_out_fifo_wm             0x00000010U
#define MSK_NX90_aes_cfg_in_fifo_dma_en                  0x00020000U
#define SRT_NX90_aes_cfg_in_fifo_dma_en                  17
#define DFLT_VAL_NX90_aes_cfg_in_fifo_dma_en             0x00000000U
#define DFLT_BF_VAL_NX90_aes_cfg_in_fifo_dma_en          0x00000000U
#define MSK_NX90_aes_cfg_in_fifo_dma_burst_only          0x00040000U
#define SRT_NX90_aes_cfg_in_fifo_dma_burst_only          18
#define DFLT_VAL_NX90_aes_cfg_in_fifo_dma_burst_only     0x00040000U
#define DFLT_BF_VAL_NX90_aes_cfg_in_fifo_dma_burst_only  0x00000001U
#define MSK_NX90_aes_cfg_out_fifo_dma_en                 0x00080000U
#define SRT_NX90_aes_cfg_out_fifo_dma_en                 19
#define DFLT_VAL_NX90_aes_cfg_out_fifo_dma_en            0x00000000U
#define DFLT_BF_VAL_NX90_aes_cfg_out_fifo_dma_en         0x00000000U
#define MSK_NX90_aes_cfg_out_fifo_dma_burst_only         0x00100000U
#define SRT_NX90_aes_cfg_out_fifo_dma_burst_only         20
#define DFLT_VAL_NX90_aes_cfg_out_fifo_dma_burst_only    0x00100000U
#define DFLT_BF_VAL_NX90_aes_cfg_out_fifo_dma_burst_only 0x00000001U

/* all used bits of 'NX90_aes_cfg': */
#define MSK_USED_BITS_NX90_aes_cfg 0x001fffffU

enum {
  BFW_NX90_aes_cfg_enable                  = 1,  /* [0] */
  BFW_NX90_aes_cfg_mode                    = 1,  /* [1] */
  BFW_NX90_aes_cfg_key_len                 = 2,  /* [3:2] */
  BFW_NX90_aes_cfg_key_exp_start           = 1,  /* [4] */
  BFW_NX90_aes_cfg_in_fifo_wm              = 6,  /* [10:5] */
  BFW_NX90_aes_cfg_out_fifo_wm             = 6,  /* [16:11] */
  BFW_NX90_aes_cfg_in_fifo_dma_en          = 1,  /* [17] */
  BFW_NX90_aes_cfg_in_fifo_dma_burst_only  = 1,  /* [18] */
  BFW_NX90_aes_cfg_out_fifo_dma_en         = 1,  /* [19] */
  BFW_NX90_aes_cfg_out_fifo_dma_burst_only = 1,  /* [20] */
  BFW_NX90_aes_cfg_reserved1               = 11  /* [31:21] */
};

typedef struct NX90_AES_CFG_BIT_Ttag {
  unsigned int enable                  : BFW_NX90_aes_cfg_enable;                  /* Enables the AES core operation.                                          */
  unsigned int mode                    : BFW_NX90_aes_cfg_mode;                    /* AES core operation mode                                                  */
                                                                                   /* 0: Encrypt                                                               */
                                                                                   /* 1: Decrypt                                                               */
  unsigned int key_len                 : BFW_NX90_aes_cfg_key_len;                 /* AES key length                                                           */
                                                                                   /* 0: 128 bit                                                               */
                                                                                   /* 1: 192 bit                                                               */
                                                                                   /* 2: 256 bit                                                               */
                                                                                   /* 3: reserved                                                              */
  unsigned int key_exp_start           : BFW_NX90_aes_cfg_key_exp_start;           /* Start AES key expansion                                                  */
                                                                                   /* After writing '1', this bit will automatically be reset.                 */
                                                                                   /* Data input can be started when key expansion is ready                    */
                                                                                   /* (see crypt_aes_stat bit 'key_exp_ready').                                */
  unsigned int in_fifo_wm              : BFW_NX90_aes_cfg_in_fifo_wm;              /* Input FIFO watermark level (0..63) used for in_fifo_wm interrupt         */
  unsigned int out_fifo_wm             : BFW_NX90_aes_cfg_out_fifo_wm;             /* Output FIFO watermark level (0..63) used for out_fifo_wm interrupt       */
  unsigned int in_fifo_dma_en          : BFW_NX90_aes_cfg_in_fifo_dma_en;          /* Enable DMAC control signals for the input FIFO                           */
  unsigned int in_fifo_dma_burst_only  : BFW_NX90_aes_cfg_in_fifo_dma_burst_only;  /* Generate DMAC burst signal only (input FIFO).                            */
                                                                                   /* When set to '1' the DMAC logic will only generate burst requests to the  */
                                                                                   /* DMAC. This is to overcome limitations of the current DMA controller      */
                                                                                   /* implementation that only accepts burst requests for DMAC controlled      */
                                                                                   /* memory to peripheral transfers.                                          */
  unsigned int out_fifo_dma_en         : BFW_NX90_aes_cfg_out_fifo_dma_en;         /* Enable DMAC control signals for the output FIFO.                         */
  unsigned int out_fifo_dma_burst_only : BFW_NX90_aes_cfg_out_fifo_dma_burst_only; /* Generate DMAC burst signal only (output FIFO).                           */
                                                                                   /* When set to '1' the DMAC logic will only generate burst requests to the  */
                                                                                   /* DMAC. This is not strictly needed for the DMAC implementation, but could */
                                                                                   /* result in better system performance.                                     */
  unsigned int reserved1               : BFW_NX90_aes_cfg_reserved1;               /* reserved                                                                 */
} NX90_AES_CFG_BIT_T;

typedef union {
  uint32_t           val;
  NX90_AES_CFG_BIT_T bf;
} NX90_AES_CFG_T;

/* --------------------------------------------------------------------- */
/* Register aes_stat */
/* => AES status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_stat 0x00000004U
#define Adr_NX90_aes_aes_stat 0xFF080084U
#define Adr_NX90_aes_stat     0xFF080084U

#define MSK_NX90_aes_stat_key_exp_ready      0x00000001U
#define SRT_NX90_aes_stat_key_exp_ready      0
#define MSK_NX90_aes_stat_op_ready           0x00000002U
#define SRT_NX90_aes_stat_op_ready           1
#define MSK_NX90_aes_stat_in_fifo_fill       0x000001fcU
#define SRT_NX90_aes_stat_in_fifo_fill       2
#define MSK_NX90_aes_stat_in_fifo_empty      0x00000200U
#define SRT_NX90_aes_stat_in_fifo_empty      9
#define MSK_NX90_aes_stat_in_fifo_not_empty  0x00000400U
#define SRT_NX90_aes_stat_in_fifo_not_empty  10
#define MSK_NX90_aes_stat_in_fifo_full       0x00000800U
#define SRT_NX90_aes_stat_in_fifo_full       11
#define MSK_NX90_aes_stat_in_fifo_not_full   0x00001000U
#define SRT_NX90_aes_stat_in_fifo_not_full   12
#define MSK_NX90_aes_stat_in_fifo_underrun   0x00002000U
#define SRT_NX90_aes_stat_in_fifo_underrun   13
#define MSK_NX90_aes_stat_in_fifo_overflow   0x00004000U
#define SRT_NX90_aes_stat_in_fifo_overflow   14
#define MSK_NX90_aes_stat_out_fifo_fill      0x003f8000U
#define SRT_NX90_aes_stat_out_fifo_fill      15
#define MSK_NX90_aes_stat_out_fifo_empty     0x00400000U
#define SRT_NX90_aes_stat_out_fifo_empty     22
#define MSK_NX90_aes_stat_out_fifo_not_empty 0x00800000U
#define SRT_NX90_aes_stat_out_fifo_not_empty 23
#define MSK_NX90_aes_stat_out_fifo_full      0x01000000U
#define SRT_NX90_aes_stat_out_fifo_full      24
#define MSK_NX90_aes_stat_out_fifo_not_full  0x02000000U
#define SRT_NX90_aes_stat_out_fifo_not_full  25
#define MSK_NX90_aes_stat_out_fifo_underrun  0x04000000U
#define SRT_NX90_aes_stat_out_fifo_underrun  26
#define MSK_NX90_aes_stat_out_fifo_overflow  0x08000000U
#define SRT_NX90_aes_stat_out_fifo_overflow  27

/* all used bits of 'NX90_aes_stat': */
#define MSK_USED_BITS_NX90_aes_stat 0x0fffffffU

enum {
  BFW_NX90_aes_stat_key_exp_ready      = 1, /* [0] */
  BFW_NX90_aes_stat_op_ready           = 1, /* [1] */
  BFW_NX90_aes_stat_in_fifo_fill       = 7, /* [8:2] */
  BFW_NX90_aes_stat_in_fifo_empty      = 1, /* [9] */
  BFW_NX90_aes_stat_in_fifo_not_empty  = 1, /* [10] */
  BFW_NX90_aes_stat_in_fifo_full       = 1, /* [11] */
  BFW_NX90_aes_stat_in_fifo_not_full   = 1, /* [12] */
  BFW_NX90_aes_stat_in_fifo_underrun   = 1, /* [13] */
  BFW_NX90_aes_stat_in_fifo_overflow   = 1, /* [14] */
  BFW_NX90_aes_stat_out_fifo_fill      = 7, /* [21:15] */
  BFW_NX90_aes_stat_out_fifo_empty     = 1, /* [22] */
  BFW_NX90_aes_stat_out_fifo_not_empty = 1, /* [23] */
  BFW_NX90_aes_stat_out_fifo_full      = 1, /* [24] */
  BFW_NX90_aes_stat_out_fifo_not_full  = 1, /* [25] */
  BFW_NX90_aes_stat_out_fifo_underrun  = 1, /* [26] */
  BFW_NX90_aes_stat_out_fifo_overflow  = 1, /* [27] */
  BFW_NX90_aes_stat_reserved1          = 4  /* [31:28] */
};

typedef struct NX90_AES_STAT_BIT_Ttag {
  unsigned int key_exp_ready      : BFW_NX90_aes_stat_key_exp_ready;      /* Set when key expansion procedure is done                            */
  unsigned int op_ready           : BFW_NX90_aes_stat_op_ready;           /* Set when AES operation ready, i.e. AES core not busy and input      */
                                                                          /* FIFO is empty                                                       */
  unsigned int in_fifo_fill       : BFW_NX90_aes_stat_in_fifo_fill;       /* Fill level of input FIFO in bytes (0..64)                           */
  unsigned int in_fifo_empty      : BFW_NX90_aes_stat_in_fifo_empty;      /* Input FIFO is empty                                                 */
  unsigned int in_fifo_not_empty  : BFW_NX90_aes_stat_in_fifo_not_empty;  /* Input FIFO is not empty                                             */
  unsigned int in_fifo_full       : BFW_NX90_aes_stat_in_fifo_full;       /* Input FIFO is full                                                  */
  unsigned int in_fifo_not_full   : BFW_NX90_aes_stat_in_fifo_not_full;   /* Input FIFO is not full                                              */
  unsigned int in_fifo_underrun   : BFW_NX90_aes_stat_in_fifo_underrun;   /* Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit     */
                                                                          /* Note: underrun is only a theoretical FIFO status, because the       */
                                                                          /* hardware logic of the AES core won't fetch data from the FIFO when  */
                                                                          /* it's empty.                                                         */
  unsigned int in_fifo_overflow   : BFW_NX90_aes_stat_in_fifo_overflow;   /* Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit    */
  unsigned int out_fifo_fill      : BFW_NX90_aes_stat_out_fifo_fill;      /* Fill level of output FIFO in bytes (0..64)                          */
  unsigned int out_fifo_empty     : BFW_NX90_aes_stat_out_fifo_empty;     /* Output FIFO is empty                                                */
  unsigned int out_fifo_not_empty : BFW_NX90_aes_stat_out_fifo_not_empty; /* Output FIFO is not empty                                            */
  unsigned int out_fifo_full      : BFW_NX90_aes_stat_out_fifo_full;      /* Output FIFO is full                                                 */
  unsigned int out_fifo_not_full  : BFW_NX90_aes_stat_out_fifo_not_full;  /* Output FIFO is not full                                             */
  unsigned int out_fifo_underrun  : BFW_NX90_aes_stat_out_fifo_underrun;  /* Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit    */
  unsigned int out_fifo_overflow  : BFW_NX90_aes_stat_out_fifo_overflow;  /* Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit   */
                                                                          /* Note: overflow is only a theoretical FIFO status, because the       */
                                                                          /* hardware logic of the AES core won't put data into the FIFO when    */
                                                                          /* it's full.                                                          */
  unsigned int reserved1          : BFW_NX90_aes_stat_reserved1;          /* reserved                                                            */
} NX90_AES_STAT_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_STAT_BIT_T bf;
} NX90_AES_STAT_T;

/* --------------------------------------------------------------------- */
/* Register aes_irq_raw */
/* => AES raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_irq_raw  0x00000008U
#define Adr_NX90_aes_aes_irq_raw  0xFF080088U
#define Adr_NX90_aes_irq_raw      0xFF080088U
#define DFLT_VAL_NX90_aes_irq_raw 0x00000000U

#define MSK_NX90_aes_irq_raw_key_exp_ready              0x00000001U
#define SRT_NX90_aes_irq_raw_key_exp_ready              0
#define DFLT_VAL_NX90_aes_irq_raw_key_exp_ready         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_key_exp_ready      0x00000000U
#define MSK_NX90_aes_irq_raw_op_ready                   0x00000002U
#define SRT_NX90_aes_irq_raw_op_ready                   1
#define DFLT_VAL_NX90_aes_irq_raw_op_ready              0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_op_ready           0x00000000U
#define MSK_NX90_aes_irq_raw_in_fifo_wm                 0x00000004U
#define SRT_NX90_aes_irq_raw_in_fifo_wm                 2
#define DFLT_VAL_NX90_aes_irq_raw_in_fifo_wm            0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_in_fifo_wm         0x00000000U
#define MSK_NX90_aes_irq_raw_in_fifo_empty              0x00000008U
#define SRT_NX90_aes_irq_raw_in_fifo_empty              3
#define DFLT_VAL_NX90_aes_irq_raw_in_fifo_empty         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_in_fifo_empty      0x00000000U
#define MSK_NX90_aes_irq_raw_in_fifo_not_empty          0x00000010U
#define SRT_NX90_aes_irq_raw_in_fifo_not_empty          4
#define DFLT_VAL_NX90_aes_irq_raw_in_fifo_not_empty     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_in_fifo_not_empty  0x00000000U
#define MSK_NX90_aes_irq_raw_in_fifo_full               0x00000020U
#define SRT_NX90_aes_irq_raw_in_fifo_full               5
#define DFLT_VAL_NX90_aes_irq_raw_in_fifo_full          0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_in_fifo_full       0x00000000U
#define MSK_NX90_aes_irq_raw_in_fifo_not_full           0x00000040U
#define SRT_NX90_aes_irq_raw_in_fifo_not_full           6
#define DFLT_VAL_NX90_aes_irq_raw_in_fifo_not_full      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_in_fifo_not_full   0x00000000U
#define MSK_NX90_aes_irq_raw_in_fifo_underrun           0x00000080U
#define SRT_NX90_aes_irq_raw_in_fifo_underrun           7
#define DFLT_VAL_NX90_aes_irq_raw_in_fifo_underrun      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_in_fifo_underrun   0x00000000U
#define MSK_NX90_aes_irq_raw_in_fifo_overflow           0x00000100U
#define SRT_NX90_aes_irq_raw_in_fifo_overflow           8
#define DFLT_VAL_NX90_aes_irq_raw_in_fifo_overflow      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_in_fifo_overflow   0x00000000U
#define MSK_NX90_aes_irq_raw_out_fifo_wm                0x00000200U
#define SRT_NX90_aes_irq_raw_out_fifo_wm                9
#define DFLT_VAL_NX90_aes_irq_raw_out_fifo_wm           0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_out_fifo_wm        0x00000000U
#define MSK_NX90_aes_irq_raw_out_fifo_empty             0x00000400U
#define SRT_NX90_aes_irq_raw_out_fifo_empty             10
#define DFLT_VAL_NX90_aes_irq_raw_out_fifo_empty        0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_out_fifo_empty     0x00000000U
#define MSK_NX90_aes_irq_raw_out_fifo_not_empty         0x00000800U
#define SRT_NX90_aes_irq_raw_out_fifo_not_empty         11
#define DFLT_VAL_NX90_aes_irq_raw_out_fifo_not_empty    0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_out_fifo_not_empty 0x00000000U
#define MSK_NX90_aes_irq_raw_out_fifo_full              0x00001000U
#define SRT_NX90_aes_irq_raw_out_fifo_full              12
#define DFLT_VAL_NX90_aes_irq_raw_out_fifo_full         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_out_fifo_full      0x00000000U
#define MSK_NX90_aes_irq_raw_out_fifo_not_full          0x00002000U
#define SRT_NX90_aes_irq_raw_out_fifo_not_full          13
#define DFLT_VAL_NX90_aes_irq_raw_out_fifo_not_full     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_out_fifo_not_full  0x00000000U
#define MSK_NX90_aes_irq_raw_out_fifo_underrun          0x00004000U
#define SRT_NX90_aes_irq_raw_out_fifo_underrun          14
#define DFLT_VAL_NX90_aes_irq_raw_out_fifo_underrun     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_out_fifo_underrun  0x00000000U
#define MSK_NX90_aes_irq_raw_out_fifo_overflow          0x00008000U
#define SRT_NX90_aes_irq_raw_out_fifo_overflow          15
#define DFLT_VAL_NX90_aes_irq_raw_out_fifo_overflow     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_raw_out_fifo_overflow  0x00000000U

/* all used bits of 'NX90_aes_irq_raw': */
#define MSK_USED_BITS_NX90_aes_irq_raw 0x0000ffffU

enum {
  BFW_NX90_aes_irq_raw_key_exp_ready      = 1,  /* [0] */
  BFW_NX90_aes_irq_raw_op_ready           = 1,  /* [1] */
  BFW_NX90_aes_irq_raw_in_fifo_wm         = 1,  /* [2] */
  BFW_NX90_aes_irq_raw_in_fifo_empty      = 1,  /* [3] */
  BFW_NX90_aes_irq_raw_in_fifo_not_empty  = 1,  /* [4] */
  BFW_NX90_aes_irq_raw_in_fifo_full       = 1,  /* [5] */
  BFW_NX90_aes_irq_raw_in_fifo_not_full   = 1,  /* [6] */
  BFW_NX90_aes_irq_raw_in_fifo_underrun   = 1,  /* [7] */
  BFW_NX90_aes_irq_raw_in_fifo_overflow   = 1,  /* [8] */
  BFW_NX90_aes_irq_raw_out_fifo_wm        = 1,  /* [9] */
  BFW_NX90_aes_irq_raw_out_fifo_empty     = 1,  /* [10] */
  BFW_NX90_aes_irq_raw_out_fifo_not_empty = 1,  /* [11] */
  BFW_NX90_aes_irq_raw_out_fifo_full      = 1,  /* [12] */
  BFW_NX90_aes_irq_raw_out_fifo_not_full  = 1,  /* [13] */
  BFW_NX90_aes_irq_raw_out_fifo_underrun  = 1,  /* [14] */
  BFW_NX90_aes_irq_raw_out_fifo_overflow  = 1,  /* [15] */
  BFW_NX90_aes_irq_raw_reserved1          = 16  /* [31:16] */
};

typedef struct NX90_AES_IRQ_RAW_BIT_Ttag {
  unsigned int key_exp_ready      : BFW_NX90_aes_irq_raw_key_exp_ready;      /* Set when key expansion procedure is done                            */
  unsigned int op_ready           : BFW_NX90_aes_irq_raw_op_ready;           /* Set when AES operation ready, i.e. AES core not busy and input      */
                                                                             /* FIFO is empty                                                       */
  unsigned int in_fifo_wm         : BFW_NX90_aes_irq_raw_in_fifo_wm;         /* Fill level of input FIFO is below or equal watermark (see           */
                                                                             /* crypt_aes_cfg bits 'in_fifo_wm')                                    */
  unsigned int in_fifo_empty      : BFW_NX90_aes_irq_raw_in_fifo_empty;      /* Input FIFO is empty                                                 */
  unsigned int in_fifo_not_empty  : BFW_NX90_aes_irq_raw_in_fifo_not_empty;  /* Input FIFO is not empty                                             */
  unsigned int in_fifo_full       : BFW_NX90_aes_irq_raw_in_fifo_full;       /* Input FIFO is full                                                  */
  unsigned int in_fifo_not_full   : BFW_NX90_aes_irq_raw_in_fifo_not_full;   /* Input FIFO is not full                                              */
  unsigned int in_fifo_underrun   : BFW_NX90_aes_irq_raw_in_fifo_underrun;   /* Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit     */
                                                                             /* Note: underrun is only a theoretical FIFO status, because the       */
                                                                             /* hardware logic of the AES core won't fetch data from the FIFO when  */
                                                                             /* it's empty.                                                         */
  unsigned int in_fifo_overflow   : BFW_NX90_aes_irq_raw_in_fifo_overflow;   /* Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit    */
  unsigned int out_fifo_wm        : BFW_NX90_aes_irq_raw_out_fifo_wm;        /* Fill level of output FIFO is above watermark (see crypt_aes_cfg     */
                                                                             /* bits 'out_fifo_wm')                                                 */
  unsigned int out_fifo_empty     : BFW_NX90_aes_irq_raw_out_fifo_empty;     /* Output FIFO is empty                                                */
  unsigned int out_fifo_not_empty : BFW_NX90_aes_irq_raw_out_fifo_not_empty; /* Output FIFO is not empty                                            */
  unsigned int out_fifo_full      : BFW_NX90_aes_irq_raw_out_fifo_full;      /* Output FIFO is full                                                 */
  unsigned int out_fifo_not_full  : BFW_NX90_aes_irq_raw_out_fifo_not_full;  /* Output FIFO is not full                                             */
  unsigned int out_fifo_underrun  : BFW_NX90_aes_irq_raw_out_fifo_underrun;  /* Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit    */
  unsigned int out_fifo_overflow  : BFW_NX90_aes_irq_raw_out_fifo_overflow;  /* Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit   */
                                                                             /* Note: overflow is only a theoretical FIFO status, because the       */
                                                                             /* hardware logic of the AES core won't put data into the FIFO when    */
                                                                             /* it's full.                                                          */
  unsigned int reserved1          : BFW_NX90_aes_irq_raw_reserved1;          /* reserved                                                            */
} NX90_AES_IRQ_RAW_BIT_T;

typedef union {
  uint32_t               val;
  NX90_AES_IRQ_RAW_BIT_T bf;
} NX90_AES_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register aes_irq_masked */
/* => AES masked IRQ: */
/*    Shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_irq_masked 0x0000000CU
#define Adr_NX90_aes_aes_irq_masked 0xFF08008CU
#define Adr_NX90_aes_irq_masked     0xFF08008CU

#define MSK_NX90_aes_irq_masked_key_exp_ready      0x00000001U
#define SRT_NX90_aes_irq_masked_key_exp_ready      0
#define MSK_NX90_aes_irq_masked_op_ready           0x00000002U
#define SRT_NX90_aes_irq_masked_op_ready           1
#define MSK_NX90_aes_irq_masked_in_fifo_wm         0x00000004U
#define SRT_NX90_aes_irq_masked_in_fifo_wm         2
#define MSK_NX90_aes_irq_masked_in_fifo_empty      0x00000008U
#define SRT_NX90_aes_irq_masked_in_fifo_empty      3
#define MSK_NX90_aes_irq_masked_in_fifo_not_empty  0x00000010U
#define SRT_NX90_aes_irq_masked_in_fifo_not_empty  4
#define MSK_NX90_aes_irq_masked_in_fifo_full       0x00000020U
#define SRT_NX90_aes_irq_masked_in_fifo_full       5
#define MSK_NX90_aes_irq_masked_in_fifo_not_full   0x00000040U
#define SRT_NX90_aes_irq_masked_in_fifo_not_full   6
#define MSK_NX90_aes_irq_masked_in_fifo_underrun   0x00000080U
#define SRT_NX90_aes_irq_masked_in_fifo_underrun   7
#define MSK_NX90_aes_irq_masked_in_fifo_overflow   0x00000100U
#define SRT_NX90_aes_irq_masked_in_fifo_overflow   8
#define MSK_NX90_aes_irq_masked_out_fifo_wm        0x00000200U
#define SRT_NX90_aes_irq_masked_out_fifo_wm        9
#define MSK_NX90_aes_irq_masked_out_fifo_empty     0x00000400U
#define SRT_NX90_aes_irq_masked_out_fifo_empty     10
#define MSK_NX90_aes_irq_masked_out_fifo_not_empty 0x00000800U
#define SRT_NX90_aes_irq_masked_out_fifo_not_empty 11
#define MSK_NX90_aes_irq_masked_out_fifo_full      0x00001000U
#define SRT_NX90_aes_irq_masked_out_fifo_full      12
#define MSK_NX90_aes_irq_masked_out_fifo_not_full  0x00002000U
#define SRT_NX90_aes_irq_masked_out_fifo_not_full  13
#define MSK_NX90_aes_irq_masked_out_fifo_underrun  0x00004000U
#define SRT_NX90_aes_irq_masked_out_fifo_underrun  14
#define MSK_NX90_aes_irq_masked_out_fifo_overflow  0x00008000U
#define SRT_NX90_aes_irq_masked_out_fifo_overflow  15

/* all used bits of 'NX90_aes_irq_masked': */
#define MSK_USED_BITS_NX90_aes_irq_masked 0x0000ffffU

enum {
  BFW_NX90_aes_irq_masked_key_exp_ready      = 1,  /* [0] */
  BFW_NX90_aes_irq_masked_op_ready           = 1,  /* [1] */
  BFW_NX90_aes_irq_masked_in_fifo_wm         = 1,  /* [2] */
  BFW_NX90_aes_irq_masked_in_fifo_empty      = 1,  /* [3] */
  BFW_NX90_aes_irq_masked_in_fifo_not_empty  = 1,  /* [4] */
  BFW_NX90_aes_irq_masked_in_fifo_full       = 1,  /* [5] */
  BFW_NX90_aes_irq_masked_in_fifo_not_full   = 1,  /* [6] */
  BFW_NX90_aes_irq_masked_in_fifo_underrun   = 1,  /* [7] */
  BFW_NX90_aes_irq_masked_in_fifo_overflow   = 1,  /* [8] */
  BFW_NX90_aes_irq_masked_out_fifo_wm        = 1,  /* [9] */
  BFW_NX90_aes_irq_masked_out_fifo_empty     = 1,  /* [10] */
  BFW_NX90_aes_irq_masked_out_fifo_not_empty = 1,  /* [11] */
  BFW_NX90_aes_irq_masked_out_fifo_full      = 1,  /* [12] */
  BFW_NX90_aes_irq_masked_out_fifo_not_full  = 1,  /* [13] */
  BFW_NX90_aes_irq_masked_out_fifo_underrun  = 1,  /* [14] */
  BFW_NX90_aes_irq_masked_out_fifo_overflow  = 1,  /* [15] */
  BFW_NX90_aes_irq_masked_reserved1          = 16  /* [31:16] */
};

typedef struct NX90_AES_IRQ_MASKED_BIT_Ttag {
  unsigned int key_exp_ready      : BFW_NX90_aes_irq_masked_key_exp_ready;      /* Set when key expansion procedure is done                          */
  unsigned int op_ready           : BFW_NX90_aes_irq_masked_op_ready;           /* Set when AES operation ready, i.e. AES core not busy and input    */
                                                                                /* FIFO is empty                                                     */
  unsigned int in_fifo_wm         : BFW_NX90_aes_irq_masked_in_fifo_wm;         /* Fill level of input FIFO is below or equal watermark (see         */
                                                                                /* crypt_aes_cfg bits 'in_fifo_wm')                                  */
  unsigned int in_fifo_empty      : BFW_NX90_aes_irq_masked_in_fifo_empty;      /* Input FIFO is empty                                               */
  unsigned int in_fifo_not_empty  : BFW_NX90_aes_irq_masked_in_fifo_not_empty;  /* Input FIFO is not empty                                           */
  unsigned int in_fifo_full       : BFW_NX90_aes_irq_masked_in_fifo_full;       /* Input FIFO is full                                                */
  unsigned int in_fifo_not_full   : BFW_NX90_aes_irq_masked_in_fifo_not_full;   /* Input FIFO is not full                                            */
  unsigned int in_fifo_underrun   : BFW_NX90_aes_irq_masked_in_fifo_underrun;   /* Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit   */
  unsigned int in_fifo_overflow   : BFW_NX90_aes_irq_masked_in_fifo_overflow;   /* Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit  */
  unsigned int out_fifo_wm        : BFW_NX90_aes_irq_masked_out_fifo_wm;        /* Fill level of output FIFO is above watermark (see crypt_aes_cfg   */
                                                                                /* bits 'out_fifo_wm')                                               */
  unsigned int out_fifo_empty     : BFW_NX90_aes_irq_masked_out_fifo_empty;     /* Output FIFO is empty                                              */
  unsigned int out_fifo_not_empty : BFW_NX90_aes_irq_masked_out_fifo_not_empty; /* Output FIFO is not empty                                          */
  unsigned int out_fifo_full      : BFW_NX90_aes_irq_masked_out_fifo_full;      /* Output FIFO is full                                               */
  unsigned int out_fifo_not_full  : BFW_NX90_aes_irq_masked_out_fifo_not_full;  /* Output FIFO is not full                                           */
  unsigned int out_fifo_underrun  : BFW_NX90_aes_irq_masked_out_fifo_underrun;  /* Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit  */
  unsigned int out_fifo_overflow  : BFW_NX90_aes_irq_masked_out_fifo_overflow;  /* Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit */
  unsigned int reserved1          : BFW_NX90_aes_irq_masked_reserved1;          /* reserved                                                          */
} NX90_AES_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_AES_IRQ_MASKED_BIT_T bf;
} NX90_AES_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register aes_irq_msk_set */
/* => AES IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to crypt_aes_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_irq_msk_set  0x00000010U
#define Adr_NX90_aes_aes_irq_msk_set  0xFF080090U
#define Adr_NX90_aes_irq_msk_set      0xFF080090U
#define DFLT_VAL_NX90_aes_irq_msk_set 0x00000000U

#define MSK_NX90_aes_irq_msk_set_key_exp_ready              0x00000001U
#define SRT_NX90_aes_irq_msk_set_key_exp_ready              0
#define DFLT_VAL_NX90_aes_irq_msk_set_key_exp_ready         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_key_exp_ready      0x00000000U
#define MSK_NX90_aes_irq_msk_set_op_ready                   0x00000002U
#define SRT_NX90_aes_irq_msk_set_op_ready                   1
#define DFLT_VAL_NX90_aes_irq_msk_set_op_ready              0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_op_ready           0x00000000U
#define MSK_NX90_aes_irq_msk_set_in_fifo_wm                 0x00000004U
#define SRT_NX90_aes_irq_msk_set_in_fifo_wm                 2
#define DFLT_VAL_NX90_aes_irq_msk_set_in_fifo_wm            0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_in_fifo_wm         0x00000000U
#define MSK_NX90_aes_irq_msk_set_in_fifo_empty              0x00000008U
#define SRT_NX90_aes_irq_msk_set_in_fifo_empty              3
#define DFLT_VAL_NX90_aes_irq_msk_set_in_fifo_empty         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_in_fifo_empty      0x00000000U
#define MSK_NX90_aes_irq_msk_set_in_fifo_not_empty          0x00000010U
#define SRT_NX90_aes_irq_msk_set_in_fifo_not_empty          4
#define DFLT_VAL_NX90_aes_irq_msk_set_in_fifo_not_empty     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_in_fifo_not_empty  0x00000000U
#define MSK_NX90_aes_irq_msk_set_in_fifo_full               0x00000020U
#define SRT_NX90_aes_irq_msk_set_in_fifo_full               5
#define DFLT_VAL_NX90_aes_irq_msk_set_in_fifo_full          0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_in_fifo_full       0x00000000U
#define MSK_NX90_aes_irq_msk_set_in_fifo_not_full           0x00000040U
#define SRT_NX90_aes_irq_msk_set_in_fifo_not_full           6
#define DFLT_VAL_NX90_aes_irq_msk_set_in_fifo_not_full      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_in_fifo_not_full   0x00000000U
#define MSK_NX90_aes_irq_msk_set_in_fifo_underrun           0x00000080U
#define SRT_NX90_aes_irq_msk_set_in_fifo_underrun           7
#define DFLT_VAL_NX90_aes_irq_msk_set_in_fifo_underrun      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_in_fifo_underrun   0x00000000U
#define MSK_NX90_aes_irq_msk_set_in_fifo_overflow           0x00000100U
#define SRT_NX90_aes_irq_msk_set_in_fifo_overflow           8
#define DFLT_VAL_NX90_aes_irq_msk_set_in_fifo_overflow      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_in_fifo_overflow   0x00000000U
#define MSK_NX90_aes_irq_msk_set_out_fifo_wm                0x00000200U
#define SRT_NX90_aes_irq_msk_set_out_fifo_wm                9
#define DFLT_VAL_NX90_aes_irq_msk_set_out_fifo_wm           0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_out_fifo_wm        0x00000000U
#define MSK_NX90_aes_irq_msk_set_out_fifo_empty             0x00000400U
#define SRT_NX90_aes_irq_msk_set_out_fifo_empty             10
#define DFLT_VAL_NX90_aes_irq_msk_set_out_fifo_empty        0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_out_fifo_empty     0x00000000U
#define MSK_NX90_aes_irq_msk_set_out_fifo_not_empty         0x00000800U
#define SRT_NX90_aes_irq_msk_set_out_fifo_not_empty         11
#define DFLT_VAL_NX90_aes_irq_msk_set_out_fifo_not_empty    0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_out_fifo_not_empty 0x00000000U
#define MSK_NX90_aes_irq_msk_set_out_fifo_full              0x00001000U
#define SRT_NX90_aes_irq_msk_set_out_fifo_full              12
#define DFLT_VAL_NX90_aes_irq_msk_set_out_fifo_full         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_out_fifo_full      0x00000000U
#define MSK_NX90_aes_irq_msk_set_out_fifo_not_full          0x00002000U
#define SRT_NX90_aes_irq_msk_set_out_fifo_not_full          13
#define DFLT_VAL_NX90_aes_irq_msk_set_out_fifo_not_full     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_out_fifo_not_full  0x00000000U
#define MSK_NX90_aes_irq_msk_set_out_fifo_underrun          0x00004000U
#define SRT_NX90_aes_irq_msk_set_out_fifo_underrun          14
#define DFLT_VAL_NX90_aes_irq_msk_set_out_fifo_underrun     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_out_fifo_underrun  0x00000000U
#define MSK_NX90_aes_irq_msk_set_out_fifo_overflow          0x00008000U
#define SRT_NX90_aes_irq_msk_set_out_fifo_overflow          15
#define DFLT_VAL_NX90_aes_irq_msk_set_out_fifo_overflow     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_set_out_fifo_overflow  0x00000000U

/* all used bits of 'NX90_aes_irq_msk_set': */
#define MSK_USED_BITS_NX90_aes_irq_msk_set 0x0000ffffU

enum {
  BFW_NX90_aes_irq_msk_set_key_exp_ready      = 1,  /* [0] */
  BFW_NX90_aes_irq_msk_set_op_ready           = 1,  /* [1] */
  BFW_NX90_aes_irq_msk_set_in_fifo_wm         = 1,  /* [2] */
  BFW_NX90_aes_irq_msk_set_in_fifo_empty      = 1,  /* [3] */
  BFW_NX90_aes_irq_msk_set_in_fifo_not_empty  = 1,  /* [4] */
  BFW_NX90_aes_irq_msk_set_in_fifo_full       = 1,  /* [5] */
  BFW_NX90_aes_irq_msk_set_in_fifo_not_full   = 1,  /* [6] */
  BFW_NX90_aes_irq_msk_set_in_fifo_underrun   = 1,  /* [7] */
  BFW_NX90_aes_irq_msk_set_in_fifo_overflow   = 1,  /* [8] */
  BFW_NX90_aes_irq_msk_set_out_fifo_wm        = 1,  /* [9] */
  BFW_NX90_aes_irq_msk_set_out_fifo_empty     = 1,  /* [10] */
  BFW_NX90_aes_irq_msk_set_out_fifo_not_empty = 1,  /* [11] */
  BFW_NX90_aes_irq_msk_set_out_fifo_full      = 1,  /* [12] */
  BFW_NX90_aes_irq_msk_set_out_fifo_not_full  = 1,  /* [13] */
  BFW_NX90_aes_irq_msk_set_out_fifo_underrun  = 1,  /* [14] */
  BFW_NX90_aes_irq_msk_set_out_fifo_overflow  = 1,  /* [15] */
  BFW_NX90_aes_irq_msk_set_reserved1          = 16  /* [31:16] */
};

typedef struct NX90_AES_IRQ_MSK_SET_BIT_Ttag {
  unsigned int key_exp_ready      : BFW_NX90_aes_irq_msk_set_key_exp_ready;      /* Set when key expansion procedure is done                          */
  unsigned int op_ready           : BFW_NX90_aes_irq_msk_set_op_ready;           /* Set when AES operation ready, i.e. AES core not busy and input    */
                                                                                 /* FIFO is empty                                                     */
  unsigned int in_fifo_wm         : BFW_NX90_aes_irq_msk_set_in_fifo_wm;         /* Fill level of input FIFO is below or equal watermark (see         */
                                                                                 /* crypt_aes_cfg bits 'in_fifo_wm')                                  */
  unsigned int in_fifo_empty      : BFW_NX90_aes_irq_msk_set_in_fifo_empty;      /* Input FIFO is empty                                               */
  unsigned int in_fifo_not_empty  : BFW_NX90_aes_irq_msk_set_in_fifo_not_empty;  /* Input FIFO is not empty                                           */
  unsigned int in_fifo_full       : BFW_NX90_aes_irq_msk_set_in_fifo_full;       /* Input FIFO is full                                                */
  unsigned int in_fifo_not_full   : BFW_NX90_aes_irq_msk_set_in_fifo_not_full;   /* Input FIFO is not full                                            */
  unsigned int in_fifo_underrun   : BFW_NX90_aes_irq_msk_set_in_fifo_underrun;   /* Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit   */
  unsigned int in_fifo_overflow   : BFW_NX90_aes_irq_msk_set_in_fifo_overflow;   /* Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit  */
  unsigned int out_fifo_wm        : BFW_NX90_aes_irq_msk_set_out_fifo_wm;        /* Fill level of output FIFO is above watermark (see crypt_aes_cfg   */
                                                                                 /* bits 'out_fifo_wm')                                               */
  unsigned int out_fifo_empty     : BFW_NX90_aes_irq_msk_set_out_fifo_empty;     /* Output FIFO is empty                                              */
  unsigned int out_fifo_not_empty : BFW_NX90_aes_irq_msk_set_out_fifo_not_empty; /* Output FIFO is not empty                                          */
  unsigned int out_fifo_full      : BFW_NX90_aes_irq_msk_set_out_fifo_full;      /* Output FIFO is full                                               */
  unsigned int out_fifo_not_full  : BFW_NX90_aes_irq_msk_set_out_fifo_not_full;  /* Output FIFO is not full                                           */
  unsigned int out_fifo_underrun  : BFW_NX90_aes_irq_msk_set_out_fifo_underrun;  /* Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit  */
  unsigned int out_fifo_overflow  : BFW_NX90_aes_irq_msk_set_out_fifo_overflow;  /* Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit */
  unsigned int reserved1          : BFW_NX90_aes_irq_msk_set_reserved1;          /* reserved                                                          */
} NX90_AES_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_AES_IRQ_MSK_SET_BIT_T bf;
} NX90_AES_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register aes_irq_msk_reset */
/* => AES IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_irq_msk_reset  0x00000014U
#define Adr_NX90_aes_aes_irq_msk_reset  0xFF080094U
#define Adr_NX90_aes_irq_msk_reset      0xFF080094U
#define DFLT_VAL_NX90_aes_irq_msk_reset 0x00000000U

#define MSK_NX90_aes_irq_msk_reset_key_exp_ready              0x00000001U
#define SRT_NX90_aes_irq_msk_reset_key_exp_ready              0
#define DFLT_VAL_NX90_aes_irq_msk_reset_key_exp_ready         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_key_exp_ready      0x00000000U
#define MSK_NX90_aes_irq_msk_reset_op_ready                   0x00000002U
#define SRT_NX90_aes_irq_msk_reset_op_ready                   1
#define DFLT_VAL_NX90_aes_irq_msk_reset_op_ready              0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_op_ready           0x00000000U
#define MSK_NX90_aes_irq_msk_reset_in_fifo_wm                 0x00000004U
#define SRT_NX90_aes_irq_msk_reset_in_fifo_wm                 2
#define DFLT_VAL_NX90_aes_irq_msk_reset_in_fifo_wm            0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_in_fifo_wm         0x00000000U
#define MSK_NX90_aes_irq_msk_reset_in_fifo_empty              0x00000008U
#define SRT_NX90_aes_irq_msk_reset_in_fifo_empty              3
#define DFLT_VAL_NX90_aes_irq_msk_reset_in_fifo_empty         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_in_fifo_empty      0x00000000U
#define MSK_NX90_aes_irq_msk_reset_in_fifo_not_empty          0x00000010U
#define SRT_NX90_aes_irq_msk_reset_in_fifo_not_empty          4
#define DFLT_VAL_NX90_aes_irq_msk_reset_in_fifo_not_empty     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_in_fifo_not_empty  0x00000000U
#define MSK_NX90_aes_irq_msk_reset_in_fifo_full               0x00000020U
#define SRT_NX90_aes_irq_msk_reset_in_fifo_full               5
#define DFLT_VAL_NX90_aes_irq_msk_reset_in_fifo_full          0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_in_fifo_full       0x00000000U
#define MSK_NX90_aes_irq_msk_reset_in_fifo_not_full           0x00000040U
#define SRT_NX90_aes_irq_msk_reset_in_fifo_not_full           6
#define DFLT_VAL_NX90_aes_irq_msk_reset_in_fifo_not_full      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_in_fifo_not_full   0x00000000U
#define MSK_NX90_aes_irq_msk_reset_in_fifo_underrun           0x00000080U
#define SRT_NX90_aes_irq_msk_reset_in_fifo_underrun           7
#define DFLT_VAL_NX90_aes_irq_msk_reset_in_fifo_underrun      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_in_fifo_underrun   0x00000000U
#define MSK_NX90_aes_irq_msk_reset_in_fifo_overflow           0x00000100U
#define SRT_NX90_aes_irq_msk_reset_in_fifo_overflow           8
#define DFLT_VAL_NX90_aes_irq_msk_reset_in_fifo_overflow      0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_in_fifo_overflow   0x00000000U
#define MSK_NX90_aes_irq_msk_reset_out_fifo_wm                0x00000200U
#define SRT_NX90_aes_irq_msk_reset_out_fifo_wm                9
#define DFLT_VAL_NX90_aes_irq_msk_reset_out_fifo_wm           0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_out_fifo_wm        0x00000000U
#define MSK_NX90_aes_irq_msk_reset_out_fifo_empty             0x00000400U
#define SRT_NX90_aes_irq_msk_reset_out_fifo_empty             10
#define DFLT_VAL_NX90_aes_irq_msk_reset_out_fifo_empty        0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_out_fifo_empty     0x00000000U
#define MSK_NX90_aes_irq_msk_reset_out_fifo_not_empty         0x00000800U
#define SRT_NX90_aes_irq_msk_reset_out_fifo_not_empty         11
#define DFLT_VAL_NX90_aes_irq_msk_reset_out_fifo_not_empty    0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_out_fifo_not_empty 0x00000000U
#define MSK_NX90_aes_irq_msk_reset_out_fifo_full              0x00001000U
#define SRT_NX90_aes_irq_msk_reset_out_fifo_full              12
#define DFLT_VAL_NX90_aes_irq_msk_reset_out_fifo_full         0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_out_fifo_full      0x00000000U
#define MSK_NX90_aes_irq_msk_reset_out_fifo_not_full          0x00002000U
#define SRT_NX90_aes_irq_msk_reset_out_fifo_not_full          13
#define DFLT_VAL_NX90_aes_irq_msk_reset_out_fifo_not_full     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_out_fifo_not_full  0x00000000U
#define MSK_NX90_aes_irq_msk_reset_out_fifo_underrun          0x00004000U
#define SRT_NX90_aes_irq_msk_reset_out_fifo_underrun          14
#define DFLT_VAL_NX90_aes_irq_msk_reset_out_fifo_underrun     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_out_fifo_underrun  0x00000000U
#define MSK_NX90_aes_irq_msk_reset_out_fifo_overflow          0x00008000U
#define SRT_NX90_aes_irq_msk_reset_out_fifo_overflow          15
#define DFLT_VAL_NX90_aes_irq_msk_reset_out_fifo_overflow     0x00000000U
#define DFLT_BF_VAL_NX90_aes_irq_msk_reset_out_fifo_overflow  0x00000000U

/* all used bits of 'NX90_aes_irq_msk_reset': */
#define MSK_USED_BITS_NX90_aes_irq_msk_reset 0x0000ffffU

enum {
  BFW_NX90_aes_irq_msk_reset_key_exp_ready      = 1,  /* [0] */
  BFW_NX90_aes_irq_msk_reset_op_ready           = 1,  /* [1] */
  BFW_NX90_aes_irq_msk_reset_in_fifo_wm         = 1,  /* [2] */
  BFW_NX90_aes_irq_msk_reset_in_fifo_empty      = 1,  /* [3] */
  BFW_NX90_aes_irq_msk_reset_in_fifo_not_empty  = 1,  /* [4] */
  BFW_NX90_aes_irq_msk_reset_in_fifo_full       = 1,  /* [5] */
  BFW_NX90_aes_irq_msk_reset_in_fifo_not_full   = 1,  /* [6] */
  BFW_NX90_aes_irq_msk_reset_in_fifo_underrun   = 1,  /* [7] */
  BFW_NX90_aes_irq_msk_reset_in_fifo_overflow   = 1,  /* [8] */
  BFW_NX90_aes_irq_msk_reset_out_fifo_wm        = 1,  /* [9] */
  BFW_NX90_aes_irq_msk_reset_out_fifo_empty     = 1,  /* [10] */
  BFW_NX90_aes_irq_msk_reset_out_fifo_not_empty = 1,  /* [11] */
  BFW_NX90_aes_irq_msk_reset_out_fifo_full      = 1,  /* [12] */
  BFW_NX90_aes_irq_msk_reset_out_fifo_not_full  = 1,  /* [13] */
  BFW_NX90_aes_irq_msk_reset_out_fifo_underrun  = 1,  /* [14] */
  BFW_NX90_aes_irq_msk_reset_out_fifo_overflow  = 1,  /* [15] */
  BFW_NX90_aes_irq_msk_reset_reserved1          = 16  /* [31:16] */
};

typedef struct NX90_AES_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int key_exp_ready      : BFW_NX90_aes_irq_msk_reset_key_exp_ready;      /* Set when key expansion procedure is done                          */
  unsigned int op_ready           : BFW_NX90_aes_irq_msk_reset_op_ready;           /* Set when AES operation ready, i.e. AES core not busy and input    */
                                                                                   /* FIFO is empty                                                     */
  unsigned int in_fifo_wm         : BFW_NX90_aes_irq_msk_reset_in_fifo_wm;         /* Fill level of input FIFO is below or equal watermark (see         */
                                                                                   /* crypt_aes_cfg bits 'in_fifo_wm')                                  */
  unsigned int in_fifo_empty      : BFW_NX90_aes_irq_msk_reset_in_fifo_empty;      /* Input FIFO is empty                                               */
  unsigned int in_fifo_not_empty  : BFW_NX90_aes_irq_msk_reset_in_fifo_not_empty;  /* Input FIFO is not empty                                           */
  unsigned int in_fifo_full       : BFW_NX90_aes_irq_msk_reset_in_fifo_full;       /* Input FIFO is full                                                */
  unsigned int in_fifo_not_full   : BFW_NX90_aes_irq_msk_reset_in_fifo_not_full;   /* Input FIFO is not full                                            */
  unsigned int in_fifo_underrun   : BFW_NX90_aes_irq_msk_reset_in_fifo_underrun;   /* Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit   */
  unsigned int in_fifo_overflow   : BFW_NX90_aes_irq_msk_reset_in_fifo_overflow;   /* Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit  */
  unsigned int out_fifo_wm        : BFW_NX90_aes_irq_msk_reset_out_fifo_wm;        /* Fill level of output FIFO is above watermark (see crypt_aes_cfg   */
                                                                                   /* bits 'out_fifo_wm')                                               */
  unsigned int out_fifo_empty     : BFW_NX90_aes_irq_msk_reset_out_fifo_empty;     /* Output FIFO is empty                                              */
  unsigned int out_fifo_not_empty : BFW_NX90_aes_irq_msk_reset_out_fifo_not_empty; /* Output FIFO is not empty                                          */
  unsigned int out_fifo_full      : BFW_NX90_aes_irq_msk_reset_out_fifo_full;      /* Output FIFO is full                                               */
  unsigned int out_fifo_not_full  : BFW_NX90_aes_irq_msk_reset_out_fifo_not_full;  /* Output FIFO is not full                                           */
  unsigned int out_fifo_underrun  : BFW_NX90_aes_irq_msk_reset_out_fifo_underrun;  /* Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit  */
  unsigned int out_fifo_overflow  : BFW_NX90_aes_irq_msk_reset_out_fifo_overflow;  /* Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit */
  unsigned int reserved1          : BFW_NX90_aes_irq_msk_reset_reserved1;          /* reserved                                                          */
} NX90_AES_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_AES_IRQ_MSK_RESET_BIT_T bf;
} NX90_AES_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register aes_key0 */
/* => AES key register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key0  0x00000018U
#define Adr_NX90_aes_aes_key0  0xFF080098U
#define Adr_NX90_aes_key0      0xFF080098U
#define DFLT_VAL_NX90_aes_key0 0x00000000U

#define MSK_NX90_aes_key0_val         0xffffffffU
#define SRT_NX90_aes_key0_val         0
#define DFLT_VAL_NX90_aes_key0_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key0_val 0x00000000U

/* all used bits of 'NX90_aes_key0': */
#define MSK_USED_BITS_NX90_aes_key0 0xffffffffU

enum {
  BFW_NX90_aes_key0_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY0_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key0_val; /* key bits 31..0 */
} NX90_AES_KEY0_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY0_BIT_T bf;
} NX90_AES_KEY0_T;

/* --------------------------------------------------------------------- */
/* Register aes_key1 */
/* => AES key register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key1  0x0000001CU
#define Adr_NX90_aes_aes_key1  0xFF08009CU
#define Adr_NX90_aes_key1      0xFF08009CU
#define DFLT_VAL_NX90_aes_key1 0x00000000U

#define MSK_NX90_aes_key1_val         0xffffffffU
#define SRT_NX90_aes_key1_val         0
#define DFLT_VAL_NX90_aes_key1_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key1_val 0x00000000U

/* all used bits of 'NX90_aes_key1': */
#define MSK_USED_BITS_NX90_aes_key1 0xffffffffU

enum {
  BFW_NX90_aes_key1_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY1_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key1_val; /* key bits 63..32 */
} NX90_AES_KEY1_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY1_BIT_T bf;
} NX90_AES_KEY1_T;

/* --------------------------------------------------------------------- */
/* Register aes_key2 */
/* => AES key register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key2  0x00000020U
#define Adr_NX90_aes_aes_key2  0xFF0800A0U
#define Adr_NX90_aes_key2      0xFF0800A0U
#define DFLT_VAL_NX90_aes_key2 0x00000000U

#define MSK_NX90_aes_key2_val         0xffffffffU
#define SRT_NX90_aes_key2_val         0
#define DFLT_VAL_NX90_aes_key2_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key2_val 0x00000000U

/* all used bits of 'NX90_aes_key2': */
#define MSK_USED_BITS_NX90_aes_key2 0xffffffffU

enum {
  BFW_NX90_aes_key2_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY2_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key2_val; /* key bits 95..64 */
} NX90_AES_KEY2_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY2_BIT_T bf;
} NX90_AES_KEY2_T;

/* --------------------------------------------------------------------- */
/* Register aes_key3 */
/* => AES key register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key3  0x00000024U
#define Adr_NX90_aes_aes_key3  0xFF0800A4U
#define Adr_NX90_aes_key3      0xFF0800A4U
#define DFLT_VAL_NX90_aes_key3 0x00000000U

#define MSK_NX90_aes_key3_val         0xffffffffU
#define SRT_NX90_aes_key3_val         0
#define DFLT_VAL_NX90_aes_key3_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key3_val 0x00000000U

/* all used bits of 'NX90_aes_key3': */
#define MSK_USED_BITS_NX90_aes_key3 0xffffffffU

enum {
  BFW_NX90_aes_key3_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY3_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key3_val; /* key bits 127..96 */
} NX90_AES_KEY3_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY3_BIT_T bf;
} NX90_AES_KEY3_T;

/* --------------------------------------------------------------------- */
/* Register aes_key4 */
/* => AES key register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key4  0x00000028U
#define Adr_NX90_aes_aes_key4  0xFF0800A8U
#define Adr_NX90_aes_key4      0xFF0800A8U
#define DFLT_VAL_NX90_aes_key4 0x00000000U

#define MSK_NX90_aes_key4_val         0xffffffffU
#define SRT_NX90_aes_key4_val         0
#define DFLT_VAL_NX90_aes_key4_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key4_val 0x00000000U

/* all used bits of 'NX90_aes_key4': */
#define MSK_USED_BITS_NX90_aes_key4 0xffffffffU

enum {
  BFW_NX90_aes_key4_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY4_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key4_val; /* key bits 159..128 */
} NX90_AES_KEY4_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY4_BIT_T bf;
} NX90_AES_KEY4_T;

/* --------------------------------------------------------------------- */
/* Register aes_key5 */
/* => AES key register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key5  0x0000002CU
#define Adr_NX90_aes_aes_key5  0xFF0800ACU
#define Adr_NX90_aes_key5      0xFF0800ACU
#define DFLT_VAL_NX90_aes_key5 0x00000000U

#define MSK_NX90_aes_key5_val         0xffffffffU
#define SRT_NX90_aes_key5_val         0
#define DFLT_VAL_NX90_aes_key5_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key5_val 0x00000000U

/* all used bits of 'NX90_aes_key5': */
#define MSK_USED_BITS_NX90_aes_key5 0xffffffffU

enum {
  BFW_NX90_aes_key5_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY5_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key5_val; /* key bits 191..160 */
} NX90_AES_KEY5_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY5_BIT_T bf;
} NX90_AES_KEY5_T;

/* --------------------------------------------------------------------- */
/* Register aes_key6 */
/* => AES key register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key6  0x00000030U
#define Adr_NX90_aes_aes_key6  0xFF0800B0U
#define Adr_NX90_aes_key6      0xFF0800B0U
#define DFLT_VAL_NX90_aes_key6 0x00000000U

#define MSK_NX90_aes_key6_val         0xffffffffU
#define SRT_NX90_aes_key6_val         0
#define DFLT_VAL_NX90_aes_key6_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key6_val 0x00000000U

/* all used bits of 'NX90_aes_key6': */
#define MSK_USED_BITS_NX90_aes_key6 0xffffffffU

enum {
  BFW_NX90_aes_key6_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY6_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key6_val; /* key bits 223..192 */
} NX90_AES_KEY6_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY6_BIT_T bf;
} NX90_AES_KEY6_T;

/* --------------------------------------------------------------------- */
/* Register aes_key7 */
/* => AES key register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_key7  0x00000034U
#define Adr_NX90_aes_aes_key7  0xFF0800B4U
#define Adr_NX90_aes_key7      0xFF0800B4U
#define DFLT_VAL_NX90_aes_key7 0x00000000U

#define MSK_NX90_aes_key7_val         0xffffffffU
#define SRT_NX90_aes_key7_val         0
#define DFLT_VAL_NX90_aes_key7_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_key7_val 0x00000000U

/* all used bits of 'NX90_aes_key7': */
#define MSK_USED_BITS_NX90_aes_key7 0xffffffffU

enum {
  BFW_NX90_aes_key7_val = 32  /* [31:0] */
};

typedef struct NX90_AES_KEY7_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_key7_val; /* key bits 255..224 */
} NX90_AES_KEY7_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_KEY7_BIT_T bf;
} NX90_AES_KEY7_T;

/* --------------------------------------------------------------------- */
/* Register aes_din */
/* => AES FIFO input */
/*    Unlike all other registers, this address can be written with DWord(32 Bit), Word(16 Bit) or Byte acccss. */
/*    The FIFO controller will automatically collect data and start AES-calculation, */
/*    if enough data (4 DWords) are collected. */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_din  0x00000038U
#define Adr_NX90_aes_aes_din  0xFF0800B8U
#define Adr_NX90_aes_din      0xFF0800B8U
#define DFLT_VAL_NX90_aes_din 0x00000000U

#define MSK_NX90_aes_din_val         0xffffffffU
#define SRT_NX90_aes_din_val         0
#define DFLT_VAL_NX90_aes_din_val    0x00000000U
#define DFLT_BF_VAL_NX90_aes_din_val 0x00000000U

/* all used bits of 'NX90_aes_din': */
#define MSK_USED_BITS_NX90_aes_din 0xffffffffU

enum {
  BFW_NX90_aes_din_val = 32  /* [31:0] */
};

typedef struct NX90_AES_DIN_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_din_val; /* data bits */
} NX90_AES_DIN_BIT_T;

typedef union {
  uint32_t           val;
  NX90_AES_DIN_BIT_T bf;
} NX90_AES_DIN_T;

/* --------------------------------------------------------------------- */
/* Register aes_dout */
/* => AES FIFO output */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_aes_dout 0x0000003CU
#define Adr_NX90_aes_aes_dout 0xFF0800BCU
#define Adr_NX90_aes_dout     0xFF0800BCU

#define MSK_NX90_aes_dout_val 0xffffffffU
#define SRT_NX90_aes_dout_val 0

/* all used bits of 'NX90_aes_dout': */
#define MSK_USED_BITS_NX90_aes_dout 0xffffffffU

enum {
  BFW_NX90_aes_dout_val = 32  /* [31:0] */
};

typedef struct NX90_AES_DOUT_BIT_Ttag {
  unsigned int val : BFW_NX90_aes_dout_val; /* data bits */
} NX90_AES_DOUT_BIT_T;

typedef union {
  uint32_t            val;
  NX90_AES_DOUT_BIT_T bf;
} NX90_AES_DOUT_T;


/* ===================================================================== */

/* Area of random */

/* ===================================================================== */

#define Addr_NX90_random 0xFF0800C0U

/* --------------------------------------------------------------------- */
/* Register random_init */
/* => Random initialization value: */
/*    Write a value depending on Chip ID to this register to generate a random sequence different for each netX. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_random_init    0x00000000U
#define Adr_NX90_random_random_init 0xFF0800C0U
#define Adr_NX90_random_init        0xFF0800C0U
#define DFLT_VAL_NX90_random_init   0x55555555U

#define MSK_NX90_random_init_val         0xffffffffU
#define SRT_NX90_random_init_val         0
#define DFLT_VAL_NX90_random_init_val    0x55555555U
#define DFLT_BF_VAL_NX90_random_init_val 0x55555555U

/* all used bits of 'NX90_random_init': */
#define MSK_USED_BITS_NX90_random_init 0xffffffffU

enum {
  BFW_NX90_random_init_val = 32  /* [31:0] */
};

typedef struct NX90_RANDOM_INIT_BIT_Ttag {
  unsigned int val : BFW_NX90_random_init_val; /* random init value */
} NX90_RANDOM_INIT_BIT_T;

typedef union {
  uint32_t               val;
  NX90_RANDOM_INIT_BIT_T bf;
} NX90_RANDOM_INIT_T;

/* --------------------------------------------------------------------- */
/* Register random_random */
/* => Random value: */
/*    This random value sequence is derived from many random events inside netX chip. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_random_random    0x00000004U
#define Adr_NX90_random_random_random 0xFF0800C4U
#define Adr_NX90_random_random        0xFF0800C4U

#define MSK_NX90_random_random_val 0xffffffffU
#define SRT_NX90_random_random_val 0

/* all used bits of 'NX90_random_random': */
#define MSK_USED_BITS_NX90_random_random 0xffffffffU

enum {
  BFW_NX90_random_random_val = 32  /* [31:0] */
};

typedef struct NX90_RANDOM_RANDOM_BIT_Ttag {
  unsigned int val : BFW_NX90_random_random_val; /* random value */
} NX90_RANDOM_RANDOM_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_RANDOM_RANDOM_BIT_T bf;
} NX90_RANDOM_RANDOM_T;


/* ===================================================================== */

/* Area of mtgy */

/* ===================================================================== */

#define Addr_NX90_mtgy 0xFF082000U

/* --------------------------------------------------------------------- */
/* Register mtgy_cmd */
/* => MWMM command register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_cmd  0x00000000U
#define Adr_NX90_mtgy_mtgy_cmd 0xFF082000U
#define Adr_NX90_mtgy_cmd      0xFF082000U
#define DFLT_VAL_NX90_mtgy_cmd 0x00000094U

#define MSK_NX90_mtgy_cmd_start              0x00000001U
#define SRT_NX90_mtgy_cmd_start              0
#define DFLT_VAL_NX90_mtgy_cmd_start         0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_cmd_start      0x00000000U
#define MSK_NX90_mtgy_cmd_abort              0x00000002U
#define SRT_NX90_mtgy_cmd_abort              1
#define DFLT_VAL_NX90_mtgy_cmd_abort         0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_cmd_abort      0x00000000U
#define MSK_NX90_mtgy_cmd_f_sel              0x00000004U
#define SRT_NX90_mtgy_cmd_f_sel              2
#define DFLT_VAL_NX90_mtgy_cmd_f_sel         0x00000004U
#define DFLT_BF_VAL_NX90_mtgy_cmd_f_sel      0x00000001U
#define MSK_NX90_mtgy_cmd_precision          0x000000f0U
#define SRT_NX90_mtgy_cmd_precision          4
#define DFLT_VAL_NX90_mtgy_cmd_precision     0x00000090U
#define DFLT_BF_VAL_NX90_mtgy_cmd_precision  0x00000009U
#define MSK_NX90_mtgy_cmd_op                 0x00000f00U
#define SRT_NX90_mtgy_cmd_op                 8
#define DFLT_VAL_NX90_mtgy_cmd_op            0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_cmd_op         0x00000000U
#define MSK_NX90_mtgy_cmd_src_addr           0x0001f000U
#define SRT_NX90_mtgy_cmd_src_addr           12
#define DFLT_VAL_NX90_mtgy_cmd_src_addr      0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_cmd_src_addr   0x00000000U
#define MSK_NX90_mtgy_cmd_dest_addr          0x003e0000U
#define SRT_NX90_mtgy_cmd_dest_addr          17
#define DFLT_VAL_NX90_mtgy_cmd_dest_addr     0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_cmd_dest_addr  0x00000000U
#define MSK_NX90_mtgy_cmd_src_addr_e         0x07c00000U
#define SRT_NX90_mtgy_cmd_src_addr_e         22
#define DFLT_VAL_NX90_mtgy_cmd_src_addr_e    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_cmd_src_addr_e 0x00000000U
#define MSK_NX90_mtgy_cmd_src_addr_x         0xf8000000U
#define SRT_NX90_mtgy_cmd_src_addr_x         27
#define DFLT_VAL_NX90_mtgy_cmd_src_addr_x    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_cmd_src_addr_x 0x00000000U

/* all used bits of 'NX90_mtgy_cmd': */
#define MSK_USED_BITS_NX90_mtgy_cmd 0xfffffff7U

enum {
  BFW_NX90_mtgy_cmd_start      = 1, /* [0] */
  BFW_NX90_mtgy_cmd_abort      = 1, /* [1] */
  BFW_NX90_mtgy_cmd_f_sel      = 1, /* [2] */
  BFW_NX90_mtgy_cmd_reserved1  = 1, /* [3] */
  BFW_NX90_mtgy_cmd_precision  = 4, /* [7:4] */
  BFW_NX90_mtgy_cmd_op         = 4, /* [11:8] */
  BFW_NX90_mtgy_cmd_src_addr   = 5, /* [16:12] */
  BFW_NX90_mtgy_cmd_dest_addr  = 5, /* [21:17] */
  BFW_NX90_mtgy_cmd_src_addr_e = 5, /* [26:22] */
  BFW_NX90_mtgy_cmd_src_addr_x = 5  /* [31:27] */
};

typedef struct NX90_MTGY_CMD_BIT_Ttag {
  unsigned int start      : BFW_NX90_mtgy_cmd_start;      /* Start Signal of the MWMM Core.                                       */
                                                          /* Setting this signal will instruct the Core to start                  */
                                                          /* the operation given by 'op' with precision specified by              */
                                                          /* 'precision'. Depending on the operation the core will use            */
                                                          /* the RAM location specified by 'src_addr', 'dest_addr',               */
                                                          /* 'src_addr_e' and 'src_addr_x'. Calculations will be                  */
                                                          /* performed in the underlying finite field specified by 'f_sel'.       */
                                                          /* After writing '1', this bit will automatically be reset.             */
  unsigned int abort      : BFW_NX90_mtgy_cmd_abort;      /* Abort Signal of the MWMM Core.                                       */
                                                          /* A running calculation can be aborted by issuing this signal.         */
                                                          /* After writing '1', this bit will automatically be reset.             */
  unsigned int f_sel      : BFW_NX90_mtgy_cmd_f_sel;      /* Finite Field Selection signal.                                       */
                                                          /* Defines if the calculations will be performed in                     */
                                                          /* 1: GF(p) or                                                          */
                                                          /* 0: GF(2^m).                                                          */
  unsigned int reserved1  : BFW_NX90_mtgy_cmd_reserved1;  /* reserved                                                             */
  unsigned int precision  : BFW_NX90_mtgy_cmd_precision;  /* Precision of executed operations.                                    */
                                                          /* 0: 192 bit                                                           */
                                                          /* 1: 224 bit                                                           */
                                                          /* 2: 256 bit                                                           */
                                                          /* 3: 320 bit                                                           */
                                                          /* 4: 384 bit                                                           */
                                                          /* 5: 512 bit                                                           */
                                                          /* 6: 768 bit                                                           */
                                                          /* 7: 1024 bit                                                          */
                                                          /* 8: 1536 bit                                                          */
                                                          /* 9: 2048 bit                                                          */
                                                          /* 10: 3072 bit                                                         */
                                                          /* 11: 4096 bit                                                         */
                                                          /* 15 - 12: reserved                                                    */
  unsigned int op         : BFW_NX90_mtgy_cmd_op;         /* The operation code of the core.                                      */
                                                          /* Following operations codes are supported:                            */
                                                          /* 0: MontMult (Montgomery Multiplication Step)                         */
                                                          /* 1: MontR (Montgomery Parameter R)                                    */
                                                          /* 2: MontR2 (Montgomery Parameter R2 )                                 */
                                                          /* 3: MontExp (Montgomery Exponentiation Step)                          */
                                                          /* 4: ModAdd (Modular Addition)                                         */
                                                          /* 5: ModSub (Modular Subtraction)                                      */
                                                          /* 6: CopyH2V (Copy from horizontal to vertical RAM location)           */
                                                          /* 7: CopyV2V (Copy from vertical to vertical RAM location)             */
                                                          /* 8: CopyH2H (Copy from horizontal to horizontal RAM location)         */
                                                          /* 9: CopyV2H (Copy from vertical to horizontal RAM location)           */
                                                          /* 10: MontMult1 (Montgomery Multiplication Step with '1' as A Operand) */
  unsigned int src_addr   : BFW_NX90_mtgy_cmd_src_addr;   /* Source Address specification.                                        */
                                                          /* Depending on the operation the source address                        */
                                                          /* specification will be interpreted as horizontal or                   */
                                                          /* vertical RAM location offset.                                        */
  unsigned int dest_addr  : BFW_NX90_mtgy_cmd_dest_addr;  /* Destination Address / Source Address A specification.                */
                                                          /* Depending on the operation the destination address                   */
                                                          /* specification will be interpreted as horizontal or                   */
                                                          /* vertical RAM location offset or as vertical RAM location             */
                                                          /* source address offset of operand A.                                  */
  unsigned int src_addr_e : BFW_NX90_mtgy_cmd_src_addr_e; /* Source Address E specification.                                      */
                                                          /* The source address E specification will be interpreted               */
                                                          /* as vertical RAM location source address offset of                    */
                                                          /* exponent E.                                                          */
  unsigned int src_addr_x : BFW_NX90_mtgy_cmd_src_addr_x; /* Source address X specification.                                      */
                                                          /* The source address X specification will be interpreted               */
                                                          /* as vertical RAM location source address offset of                    */
                                                          /* auxiliary operand E.                                                 */
} NX90_MTGY_CMD_BIT_T;

typedef union {
  uint32_t            val;
  NX90_MTGY_CMD_BIT_T bf;
} NX90_MTGY_CMD_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_stat */
/* => MWMM status register: */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_stat  0x00000004U
#define Adr_NX90_mtgy_mtgy_stat 0xFF082004U
#define Adr_NX90_mtgy_stat      0xFF082004U

#define MSK_NX90_mtgy_stat_done 0x00000001U
#define SRT_NX90_mtgy_stat_done 0

/* all used bits of 'NX90_mtgy_stat': */
#define MSK_USED_BITS_NX90_mtgy_stat 0x00000001U

enum {
  BFW_NX90_mtgy_stat_done      = 1,  /* [0] */
  BFW_NX90_mtgy_stat_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_MTGY_STAT_BIT_Ttag {
  unsigned int done      : BFW_NX90_mtgy_stat_done;      /* Done signal from the MWMM core. */
  unsigned int reserved1 : BFW_NX90_mtgy_stat_reserved1; /* reserved                        */
} NX90_MTGY_STAT_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MTGY_STAT_BIT_T bf;
} NX90_MTGY_STAT_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_irq_raw */
/* => MWMM raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_irq_raw  0x00000008U
#define Adr_NX90_mtgy_mtgy_irq_raw 0xFF082008U
#define Adr_NX90_mtgy_irq_raw      0xFF082008U
#define DFLT_VAL_NX90_mtgy_irq_raw 0x00000000U

#define MSK_NX90_mtgy_irq_raw_done         0x00000001U
#define SRT_NX90_mtgy_irq_raw_done         0
#define DFLT_VAL_NX90_mtgy_irq_raw_done    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_irq_raw_done 0x00000000U

/* all used bits of 'NX90_mtgy_irq_raw': */
#define MSK_USED_BITS_NX90_mtgy_irq_raw 0x00000001U

enum {
  BFW_NX90_mtgy_irq_raw_done      = 1,  /* [0] */
  BFW_NX90_mtgy_irq_raw_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_MTGY_IRQ_RAW_BIT_Ttag {
  unsigned int done      : BFW_NX90_mtgy_irq_raw_done;      /* Done signal from the MWMM core. Only a posedge on this signal  */
                                                            /* will set the interrupt.                                        */
  unsigned int reserved1 : BFW_NX90_mtgy_irq_raw_reserved1; /* reserved                                                       */
} NX90_MTGY_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_IRQ_RAW_BIT_T bf;
} NX90_MTGY_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_irq_masked */
/* => MWMM masked IRQ: */
/*    Shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_irq_masked  0x0000000CU
#define Adr_NX90_mtgy_mtgy_irq_masked 0xFF08200CU
#define Adr_NX90_mtgy_irq_masked      0xFF08200CU

#define MSK_NX90_mtgy_irq_masked_done 0x00000001U
#define SRT_NX90_mtgy_irq_masked_done 0

/* all used bits of 'NX90_mtgy_irq_masked': */
#define MSK_USED_BITS_NX90_mtgy_irq_masked 0x00000001U

enum {
  BFW_NX90_mtgy_irq_masked_done      = 1,  /* [0] */
  BFW_NX90_mtgy_irq_masked_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_MTGY_IRQ_MASKED_BIT_Ttag {
  unsigned int done      : BFW_NX90_mtgy_irq_masked_done;      /* Done signal from the MWMM core. */
  unsigned int reserved1 : BFW_NX90_mtgy_irq_masked_reserved1; /* reserved                        */
} NX90_MTGY_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_MTGY_IRQ_MASKED_BIT_T bf;
} NX90_MTGY_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_irq_msk_set */
/* => MWMM IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to mtgy_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_irq_msk_set  0x00000010U
#define Adr_NX90_mtgy_mtgy_irq_msk_set 0xFF082010U
#define Adr_NX90_mtgy_irq_msk_set      0xFF082010U
#define DFLT_VAL_NX90_mtgy_irq_msk_set 0x00000000U

#define MSK_NX90_mtgy_irq_msk_set_done         0x00000001U
#define SRT_NX90_mtgy_irq_msk_set_done         0
#define DFLT_VAL_NX90_mtgy_irq_msk_set_done    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_irq_msk_set_done 0x00000000U

/* all used bits of 'NX90_mtgy_irq_msk_set': */
#define MSK_USED_BITS_NX90_mtgy_irq_msk_set 0x00000001U

enum {
  BFW_NX90_mtgy_irq_msk_set_done      = 1,  /* [0] */
  BFW_NX90_mtgy_irq_msk_set_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_MTGY_IRQ_MSK_SET_BIT_Ttag {
  unsigned int done      : BFW_NX90_mtgy_irq_msk_set_done;      /* Done signal from the MWMM core. */
  unsigned int reserved1 : BFW_NX90_mtgy_irq_msk_set_reserved1; /* reserved                        */
} NX90_MTGY_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_MTGY_IRQ_MSK_SET_BIT_T bf;
} NX90_MTGY_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_irq_msk_reset */
/* => MWMM IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_irq_msk_reset  0x00000014U
#define Adr_NX90_mtgy_mtgy_irq_msk_reset 0xFF082014U
#define Adr_NX90_mtgy_irq_msk_reset      0xFF082014U
#define DFLT_VAL_NX90_mtgy_irq_msk_reset 0x00000000U

#define MSK_NX90_mtgy_irq_msk_reset_done         0x00000001U
#define SRT_NX90_mtgy_irq_msk_reset_done         0
#define DFLT_VAL_NX90_mtgy_irq_msk_reset_done    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_irq_msk_reset_done 0x00000000U

/* all used bits of 'NX90_mtgy_irq_msk_reset': */
#define MSK_USED_BITS_NX90_mtgy_irq_msk_reset 0x00000001U

enum {
  BFW_NX90_mtgy_irq_msk_reset_done      = 1,  /* [0] */
  BFW_NX90_mtgy_irq_msk_reset_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_MTGY_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int done      : BFW_NX90_mtgy_irq_msk_reset_done;      /* Done signal from the MWMM core. */
  unsigned int reserved1 : BFW_NX90_mtgy_irq_msk_reset_reserved1; /* reserved                        */
} NX90_MTGY_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_MTGY_IRQ_MSK_RESET_BIT_T bf;
} NX90_MTGY_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc0 */
/* => MWMM TC register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc0  0x00001000U
#define Adr_NX90_mtgy_mtgy_op_tc0 0xFF083000U
#define Adr_NX90_mtgy_op_tc0      0xFF083000U
#define DFLT_VAL_NX90_mtgy_op_tc0 0x00000000U

#define MSK_NX90_mtgy_op_tc0_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc0_val         0
#define DFLT_VAL_NX90_mtgy_op_tc0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc0_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc0': */
#define MSK_USED_BITS_NX90_mtgy_op_tc0 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc0_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC0_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc0_val; /* data bits 31..0 */
} NX90_MTGY_OP_TC0_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC0_BIT_T bf;
} NX90_MTGY_OP_TC0_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc1 */
/* => MWMM TC register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc1  0x00001004U
#define Adr_NX90_mtgy_mtgy_op_tc1 0xFF083004U
#define Adr_NX90_mtgy_op_tc1      0xFF083004U
#define DFLT_VAL_NX90_mtgy_op_tc1 0x00000000U

#define MSK_NX90_mtgy_op_tc1_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc1_val         0
#define DFLT_VAL_NX90_mtgy_op_tc1_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc1_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc1': */
#define MSK_USED_BITS_NX90_mtgy_op_tc1 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc1_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC1_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc1_val; /* data bits 63..32 */
} NX90_MTGY_OP_TC1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC1_BIT_T bf;
} NX90_MTGY_OP_TC1_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc2 */
/* => MWMM TC register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc2  0x00001008U
#define Adr_NX90_mtgy_mtgy_op_tc2 0xFF083008U
#define Adr_NX90_mtgy_op_tc2      0xFF083008U
#define DFLT_VAL_NX90_mtgy_op_tc2 0x00000000U

#define MSK_NX90_mtgy_op_tc2_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc2_val         0
#define DFLT_VAL_NX90_mtgy_op_tc2_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc2_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc2': */
#define MSK_USED_BITS_NX90_mtgy_op_tc2 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc2_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC2_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc2_val; /* data bits 95..64 */
} NX90_MTGY_OP_TC2_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC2_BIT_T bf;
} NX90_MTGY_OP_TC2_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc3 */
/* => MWMM TC register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc3  0x0000100CU
#define Adr_NX90_mtgy_mtgy_op_tc3 0xFF08300CU
#define Adr_NX90_mtgy_op_tc3      0xFF08300CU
#define DFLT_VAL_NX90_mtgy_op_tc3 0x00000000U

#define MSK_NX90_mtgy_op_tc3_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc3_val         0
#define DFLT_VAL_NX90_mtgy_op_tc3_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc3_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc3': */
#define MSK_USED_BITS_NX90_mtgy_op_tc3 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc3_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC3_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc3_val; /* data bits 127..96 */
} NX90_MTGY_OP_TC3_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC3_BIT_T bf;
} NX90_MTGY_OP_TC3_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc4 */
/* => MWMM TC register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc4  0x00001010U
#define Adr_NX90_mtgy_mtgy_op_tc4 0xFF083010U
#define Adr_NX90_mtgy_op_tc4      0xFF083010U
#define DFLT_VAL_NX90_mtgy_op_tc4 0x00000000U

#define MSK_NX90_mtgy_op_tc4_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc4_val         0
#define DFLT_VAL_NX90_mtgy_op_tc4_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc4_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc4': */
#define MSK_USED_BITS_NX90_mtgy_op_tc4 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc4_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC4_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc4_val; /* data bits 159..128 */
} NX90_MTGY_OP_TC4_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC4_BIT_T bf;
} NX90_MTGY_OP_TC4_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc5 */
/* => MWMM TC register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc5  0x00001014U
#define Adr_NX90_mtgy_mtgy_op_tc5 0xFF083014U
#define Adr_NX90_mtgy_op_tc5      0xFF083014U
#define DFLT_VAL_NX90_mtgy_op_tc5 0x00000000U

#define MSK_NX90_mtgy_op_tc5_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc5_val         0
#define DFLT_VAL_NX90_mtgy_op_tc5_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc5_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc5': */
#define MSK_USED_BITS_NX90_mtgy_op_tc5 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc5_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC5_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc5_val; /* data bits 191..160 */
} NX90_MTGY_OP_TC5_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC5_BIT_T bf;
} NX90_MTGY_OP_TC5_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc6 */
/* => MWMM TC register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc6  0x00001018U
#define Adr_NX90_mtgy_mtgy_op_tc6 0xFF083018U
#define Adr_NX90_mtgy_op_tc6      0xFF083018U
#define DFLT_VAL_NX90_mtgy_op_tc6 0x00000000U

#define MSK_NX90_mtgy_op_tc6_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc6_val         0
#define DFLT_VAL_NX90_mtgy_op_tc6_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc6_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc6': */
#define MSK_USED_BITS_NX90_mtgy_op_tc6 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc6_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC6_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc6_val; /* data bits 223..192 */
} NX90_MTGY_OP_TC6_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC6_BIT_T bf;
} NX90_MTGY_OP_TC6_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc7 */
/* => MWMM TC register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc7  0x0000101CU
#define Adr_NX90_mtgy_mtgy_op_tc7 0xFF08301CU
#define Adr_NX90_mtgy_op_tc7      0xFF08301CU
#define DFLT_VAL_NX90_mtgy_op_tc7 0x00000000U

#define MSK_NX90_mtgy_op_tc7_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc7_val         0
#define DFLT_VAL_NX90_mtgy_op_tc7_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc7_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc7': */
#define MSK_USED_BITS_NX90_mtgy_op_tc7 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc7_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC7_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc7_val; /* data bits 255..224 */
} NX90_MTGY_OP_TC7_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC7_BIT_T bf;
} NX90_MTGY_OP_TC7_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc8 */
/* => MWMM TC register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc8  0x00001020U
#define Adr_NX90_mtgy_mtgy_op_tc8 0xFF083020U
#define Adr_NX90_mtgy_op_tc8      0xFF083020U
#define DFLT_VAL_NX90_mtgy_op_tc8 0x00000000U

#define MSK_NX90_mtgy_op_tc8_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc8_val         0
#define DFLT_VAL_NX90_mtgy_op_tc8_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc8_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc8': */
#define MSK_USED_BITS_NX90_mtgy_op_tc8 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc8_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC8_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc8_val; /* data bits 287..256 */
} NX90_MTGY_OP_TC8_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC8_BIT_T bf;
} NX90_MTGY_OP_TC8_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc9 */
/* => MWMM TC register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc9  0x00001024U
#define Adr_NX90_mtgy_mtgy_op_tc9 0xFF083024U
#define Adr_NX90_mtgy_op_tc9      0xFF083024U
#define DFLT_VAL_NX90_mtgy_op_tc9 0x00000000U

#define MSK_NX90_mtgy_op_tc9_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc9_val         0
#define DFLT_VAL_NX90_mtgy_op_tc9_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc9_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc9': */
#define MSK_USED_BITS_NX90_mtgy_op_tc9 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc9_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC9_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc9_val; /* data bits 319..288 */
} NX90_MTGY_OP_TC9_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TC9_BIT_T bf;
} NX90_MTGY_OP_TC9_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc10 */
/* => MWMM TC register 10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc10  0x00001028U
#define Adr_NX90_mtgy_mtgy_op_tc10 0xFF083028U
#define Adr_NX90_mtgy_op_tc10      0xFF083028U
#define DFLT_VAL_NX90_mtgy_op_tc10 0x00000000U

#define MSK_NX90_mtgy_op_tc10_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc10_val         0
#define DFLT_VAL_NX90_mtgy_op_tc10_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc10_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc10': */
#define MSK_USED_BITS_NX90_mtgy_op_tc10 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc10_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC10_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc10_val; /* data bits 351..320 */
} NX90_MTGY_OP_TC10_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC10_BIT_T bf;
} NX90_MTGY_OP_TC10_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc11 */
/* => MWMM TC register 11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc11  0x0000102CU
#define Adr_NX90_mtgy_mtgy_op_tc11 0xFF08302CU
#define Adr_NX90_mtgy_op_tc11      0xFF08302CU
#define DFLT_VAL_NX90_mtgy_op_tc11 0x00000000U

#define MSK_NX90_mtgy_op_tc11_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc11_val         0
#define DFLT_VAL_NX90_mtgy_op_tc11_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc11_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc11': */
#define MSK_USED_BITS_NX90_mtgy_op_tc11 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc11_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC11_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc11_val; /* data bits 383..352 */
} NX90_MTGY_OP_TC11_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC11_BIT_T bf;
} NX90_MTGY_OP_TC11_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc12 */
/* => MWMM TC register 12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc12  0x00001030U
#define Adr_NX90_mtgy_mtgy_op_tc12 0xFF083030U
#define Adr_NX90_mtgy_op_tc12      0xFF083030U
#define DFLT_VAL_NX90_mtgy_op_tc12 0x00000000U

#define MSK_NX90_mtgy_op_tc12_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc12_val         0
#define DFLT_VAL_NX90_mtgy_op_tc12_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc12_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc12': */
#define MSK_USED_BITS_NX90_mtgy_op_tc12 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc12_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC12_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc12_val; /* data bits 415..384 */
} NX90_MTGY_OP_TC12_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC12_BIT_T bf;
} NX90_MTGY_OP_TC12_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc13 */
/* => MWMM TC register 13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc13  0x00001034U
#define Adr_NX90_mtgy_mtgy_op_tc13 0xFF083034U
#define Adr_NX90_mtgy_op_tc13      0xFF083034U
#define DFLT_VAL_NX90_mtgy_op_tc13 0x00000000U

#define MSK_NX90_mtgy_op_tc13_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc13_val         0
#define DFLT_VAL_NX90_mtgy_op_tc13_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc13_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc13': */
#define MSK_USED_BITS_NX90_mtgy_op_tc13 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc13_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC13_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc13_val; /* data bits 447..416 */
} NX90_MTGY_OP_TC13_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC13_BIT_T bf;
} NX90_MTGY_OP_TC13_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc14 */
/* => MWMM TC register 14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc14  0x00001038U
#define Adr_NX90_mtgy_mtgy_op_tc14 0xFF083038U
#define Adr_NX90_mtgy_op_tc14      0xFF083038U
#define DFLT_VAL_NX90_mtgy_op_tc14 0x00000000U

#define MSK_NX90_mtgy_op_tc14_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc14_val         0
#define DFLT_VAL_NX90_mtgy_op_tc14_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc14_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc14': */
#define MSK_USED_BITS_NX90_mtgy_op_tc14 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc14_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC14_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc14_val; /* data bits 479..448 */
} NX90_MTGY_OP_TC14_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC14_BIT_T bf;
} NX90_MTGY_OP_TC14_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc15 */
/* => MWMM TC register 15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc15  0x0000103CU
#define Adr_NX90_mtgy_mtgy_op_tc15 0xFF08303CU
#define Adr_NX90_mtgy_op_tc15      0xFF08303CU
#define DFLT_VAL_NX90_mtgy_op_tc15 0x00000000U

#define MSK_NX90_mtgy_op_tc15_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc15_val         0
#define DFLT_VAL_NX90_mtgy_op_tc15_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc15_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc15': */
#define MSK_USED_BITS_NX90_mtgy_op_tc15 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc15_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC15_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc15_val; /* data bits 511..480 */
} NX90_MTGY_OP_TC15_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC15_BIT_T bf;
} NX90_MTGY_OP_TC15_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc16 */
/* => MWMM TC register 16 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc16  0x00001040U
#define Adr_NX90_mtgy_mtgy_op_tc16 0xFF083040U
#define Adr_NX90_mtgy_op_tc16      0xFF083040U
#define DFLT_VAL_NX90_mtgy_op_tc16 0x00000000U

#define MSK_NX90_mtgy_op_tc16_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc16_val         0
#define DFLT_VAL_NX90_mtgy_op_tc16_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc16_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc16': */
#define MSK_USED_BITS_NX90_mtgy_op_tc16 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc16_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC16_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc16_val; /* data bits 543..512 */
} NX90_MTGY_OP_TC16_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC16_BIT_T bf;
} NX90_MTGY_OP_TC16_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc17 */
/* => MWMM TC register 17 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc17  0x00001044U
#define Adr_NX90_mtgy_mtgy_op_tc17 0xFF083044U
#define Adr_NX90_mtgy_op_tc17      0xFF083044U
#define DFLT_VAL_NX90_mtgy_op_tc17 0x00000000U

#define MSK_NX90_mtgy_op_tc17_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc17_val         0
#define DFLT_VAL_NX90_mtgy_op_tc17_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc17_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc17': */
#define MSK_USED_BITS_NX90_mtgy_op_tc17 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc17_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC17_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc17_val; /* data bits 575..544 */
} NX90_MTGY_OP_TC17_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC17_BIT_T bf;
} NX90_MTGY_OP_TC17_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc18 */
/* => MWMM TC register 18 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc18  0x00001048U
#define Adr_NX90_mtgy_mtgy_op_tc18 0xFF083048U
#define Adr_NX90_mtgy_op_tc18      0xFF083048U
#define DFLT_VAL_NX90_mtgy_op_tc18 0x00000000U

#define MSK_NX90_mtgy_op_tc18_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc18_val         0
#define DFLT_VAL_NX90_mtgy_op_tc18_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc18_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc18': */
#define MSK_USED_BITS_NX90_mtgy_op_tc18 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc18_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC18_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc18_val; /* data bits 607..576 */
} NX90_MTGY_OP_TC18_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC18_BIT_T bf;
} NX90_MTGY_OP_TC18_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc19 */
/* => MWMM TC register 19 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc19  0x0000104CU
#define Adr_NX90_mtgy_mtgy_op_tc19 0xFF08304CU
#define Adr_NX90_mtgy_op_tc19      0xFF08304CU
#define DFLT_VAL_NX90_mtgy_op_tc19 0x00000000U

#define MSK_NX90_mtgy_op_tc19_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc19_val         0
#define DFLT_VAL_NX90_mtgy_op_tc19_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc19_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc19': */
#define MSK_USED_BITS_NX90_mtgy_op_tc19 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc19_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC19_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc19_val; /* data bits 639..608 */
} NX90_MTGY_OP_TC19_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC19_BIT_T bf;
} NX90_MTGY_OP_TC19_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc20 */
/* => MWMM TC register 20 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc20  0x00001050U
#define Adr_NX90_mtgy_mtgy_op_tc20 0xFF083050U
#define Adr_NX90_mtgy_op_tc20      0xFF083050U
#define DFLT_VAL_NX90_mtgy_op_tc20 0x00000000U

#define MSK_NX90_mtgy_op_tc20_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc20_val         0
#define DFLT_VAL_NX90_mtgy_op_tc20_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc20_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc20': */
#define MSK_USED_BITS_NX90_mtgy_op_tc20 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc20_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC20_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc20_val; /* data bits 671..640 */
} NX90_MTGY_OP_TC20_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC20_BIT_T bf;
} NX90_MTGY_OP_TC20_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc21 */
/* => MWMM TC register 21 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc21  0x00001054U
#define Adr_NX90_mtgy_mtgy_op_tc21 0xFF083054U
#define Adr_NX90_mtgy_op_tc21      0xFF083054U
#define DFLT_VAL_NX90_mtgy_op_tc21 0x00000000U

#define MSK_NX90_mtgy_op_tc21_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc21_val         0
#define DFLT_VAL_NX90_mtgy_op_tc21_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc21_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc21': */
#define MSK_USED_BITS_NX90_mtgy_op_tc21 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc21_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC21_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc21_val; /* data bits 703..672 */
} NX90_MTGY_OP_TC21_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC21_BIT_T bf;
} NX90_MTGY_OP_TC21_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc22 */
/* => MWMM TC register 22 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc22  0x00001058U
#define Adr_NX90_mtgy_mtgy_op_tc22 0xFF083058U
#define Adr_NX90_mtgy_op_tc22      0xFF083058U
#define DFLT_VAL_NX90_mtgy_op_tc22 0x00000000U

#define MSK_NX90_mtgy_op_tc22_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc22_val         0
#define DFLT_VAL_NX90_mtgy_op_tc22_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc22_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc22': */
#define MSK_USED_BITS_NX90_mtgy_op_tc22 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc22_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC22_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc22_val; /* data bits 735..704 */
} NX90_MTGY_OP_TC22_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC22_BIT_T bf;
} NX90_MTGY_OP_TC22_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc23 */
/* => MWMM TC register 23 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc23  0x0000105CU
#define Adr_NX90_mtgy_mtgy_op_tc23 0xFF08305CU
#define Adr_NX90_mtgy_op_tc23      0xFF08305CU
#define DFLT_VAL_NX90_mtgy_op_tc23 0x00000000U

#define MSK_NX90_mtgy_op_tc23_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc23_val         0
#define DFLT_VAL_NX90_mtgy_op_tc23_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc23_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc23': */
#define MSK_USED_BITS_NX90_mtgy_op_tc23 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc23_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC23_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc23_val; /* data bits 767..736 */
} NX90_MTGY_OP_TC23_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC23_BIT_T bf;
} NX90_MTGY_OP_TC23_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc24 */
/* => MWMM TC register 24 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc24  0x00001060U
#define Adr_NX90_mtgy_mtgy_op_tc24 0xFF083060U
#define Adr_NX90_mtgy_op_tc24      0xFF083060U
#define DFLT_VAL_NX90_mtgy_op_tc24 0x00000000U

#define MSK_NX90_mtgy_op_tc24_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc24_val         0
#define DFLT_VAL_NX90_mtgy_op_tc24_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc24_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc24': */
#define MSK_USED_BITS_NX90_mtgy_op_tc24 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc24_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC24_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc24_val; /* data bits 799..768 */
} NX90_MTGY_OP_TC24_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC24_BIT_T bf;
} NX90_MTGY_OP_TC24_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc25 */
/* => MWMM TC register 25 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc25  0x00001064U
#define Adr_NX90_mtgy_mtgy_op_tc25 0xFF083064U
#define Adr_NX90_mtgy_op_tc25      0xFF083064U
#define DFLT_VAL_NX90_mtgy_op_tc25 0x00000000U

#define MSK_NX90_mtgy_op_tc25_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc25_val         0
#define DFLT_VAL_NX90_mtgy_op_tc25_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc25_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc25': */
#define MSK_USED_BITS_NX90_mtgy_op_tc25 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc25_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC25_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc25_val; /* data bits 831..800 */
} NX90_MTGY_OP_TC25_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC25_BIT_T bf;
} NX90_MTGY_OP_TC25_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc26 */
/* => MWMM TC register 26 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc26  0x00001068U
#define Adr_NX90_mtgy_mtgy_op_tc26 0xFF083068U
#define Adr_NX90_mtgy_op_tc26      0xFF083068U
#define DFLT_VAL_NX90_mtgy_op_tc26 0x00000000U

#define MSK_NX90_mtgy_op_tc26_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc26_val         0
#define DFLT_VAL_NX90_mtgy_op_tc26_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc26_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc26': */
#define MSK_USED_BITS_NX90_mtgy_op_tc26 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc26_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC26_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc26_val; /* data bits 863..832 */
} NX90_MTGY_OP_TC26_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC26_BIT_T bf;
} NX90_MTGY_OP_TC26_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc27 */
/* => MWMM TC register 27 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc27  0x0000106CU
#define Adr_NX90_mtgy_mtgy_op_tc27 0xFF08306CU
#define Adr_NX90_mtgy_op_tc27      0xFF08306CU
#define DFLT_VAL_NX90_mtgy_op_tc27 0x00000000U

#define MSK_NX90_mtgy_op_tc27_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc27_val         0
#define DFLT_VAL_NX90_mtgy_op_tc27_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc27_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc27': */
#define MSK_USED_BITS_NX90_mtgy_op_tc27 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc27_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC27_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc27_val; /* data bits 895..864 */
} NX90_MTGY_OP_TC27_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC27_BIT_T bf;
} NX90_MTGY_OP_TC27_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc28 */
/* => MWMM TC register 28 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc28  0x00001070U
#define Adr_NX90_mtgy_mtgy_op_tc28 0xFF083070U
#define Adr_NX90_mtgy_op_tc28      0xFF083070U
#define DFLT_VAL_NX90_mtgy_op_tc28 0x00000000U

#define MSK_NX90_mtgy_op_tc28_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc28_val         0
#define DFLT_VAL_NX90_mtgy_op_tc28_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc28_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc28': */
#define MSK_USED_BITS_NX90_mtgy_op_tc28 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc28_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC28_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc28_val; /* data bits 927..896 */
} NX90_MTGY_OP_TC28_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC28_BIT_T bf;
} NX90_MTGY_OP_TC28_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc29 */
/* => MWMM TC register 29 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc29  0x00001074U
#define Adr_NX90_mtgy_mtgy_op_tc29 0xFF083074U
#define Adr_NX90_mtgy_op_tc29      0xFF083074U
#define DFLT_VAL_NX90_mtgy_op_tc29 0x00000000U

#define MSK_NX90_mtgy_op_tc29_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc29_val         0
#define DFLT_VAL_NX90_mtgy_op_tc29_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc29_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc29': */
#define MSK_USED_BITS_NX90_mtgy_op_tc29 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc29_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC29_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc29_val; /* data bits 959..928 */
} NX90_MTGY_OP_TC29_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC29_BIT_T bf;
} NX90_MTGY_OP_TC29_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc30 */
/* => MWMM TC register 30 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc30  0x00001078U
#define Adr_NX90_mtgy_mtgy_op_tc30 0xFF083078U
#define Adr_NX90_mtgy_op_tc30      0xFF083078U
#define DFLT_VAL_NX90_mtgy_op_tc30 0x00000000U

#define MSK_NX90_mtgy_op_tc30_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc30_val         0
#define DFLT_VAL_NX90_mtgy_op_tc30_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc30_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc30': */
#define MSK_USED_BITS_NX90_mtgy_op_tc30 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc30_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC30_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc30_val; /* data bits 991..960 */
} NX90_MTGY_OP_TC30_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC30_BIT_T bf;
} NX90_MTGY_OP_TC30_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc31 */
/* => MWMM TC register 31 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc31  0x0000107CU
#define Adr_NX90_mtgy_mtgy_op_tc31 0xFF08307CU
#define Adr_NX90_mtgy_op_tc31      0xFF08307CU
#define DFLT_VAL_NX90_mtgy_op_tc31 0x00000000U

#define MSK_NX90_mtgy_op_tc31_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc31_val         0
#define DFLT_VAL_NX90_mtgy_op_tc31_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc31_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc31': */
#define MSK_USED_BITS_NX90_mtgy_op_tc31 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc31_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC31_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc31_val; /* data bits 1023..992 */
} NX90_MTGY_OP_TC31_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC31_BIT_T bf;
} NX90_MTGY_OP_TC31_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc32 */
/* => MWMM TC register 32 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc32  0x00001080U
#define Adr_NX90_mtgy_mtgy_op_tc32 0xFF083080U
#define Adr_NX90_mtgy_op_tc32      0xFF083080U
#define DFLT_VAL_NX90_mtgy_op_tc32 0x00000000U

#define MSK_NX90_mtgy_op_tc32_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc32_val         0
#define DFLT_VAL_NX90_mtgy_op_tc32_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc32_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc32': */
#define MSK_USED_BITS_NX90_mtgy_op_tc32 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc32_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC32_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc32_val; /* data bits 1055..1024 */
} NX90_MTGY_OP_TC32_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC32_BIT_T bf;
} NX90_MTGY_OP_TC32_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc33 */
/* => MWMM TC register 33 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc33  0x00001084U
#define Adr_NX90_mtgy_mtgy_op_tc33 0xFF083084U
#define Adr_NX90_mtgy_op_tc33      0xFF083084U
#define DFLT_VAL_NX90_mtgy_op_tc33 0x00000000U

#define MSK_NX90_mtgy_op_tc33_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc33_val         0
#define DFLT_VAL_NX90_mtgy_op_tc33_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc33_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc33': */
#define MSK_USED_BITS_NX90_mtgy_op_tc33 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc33_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC33_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc33_val; /* data bits 1087..1056 */
} NX90_MTGY_OP_TC33_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC33_BIT_T bf;
} NX90_MTGY_OP_TC33_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc34 */
/* => MWMM TC register 34 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc34  0x00001088U
#define Adr_NX90_mtgy_mtgy_op_tc34 0xFF083088U
#define Adr_NX90_mtgy_op_tc34      0xFF083088U
#define DFLT_VAL_NX90_mtgy_op_tc34 0x00000000U

#define MSK_NX90_mtgy_op_tc34_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc34_val         0
#define DFLT_VAL_NX90_mtgy_op_tc34_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc34_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc34': */
#define MSK_USED_BITS_NX90_mtgy_op_tc34 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc34_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC34_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc34_val; /* data bits 1119..1088 */
} NX90_MTGY_OP_TC34_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC34_BIT_T bf;
} NX90_MTGY_OP_TC34_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc35 */
/* => MWMM TC register 35 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc35  0x0000108CU
#define Adr_NX90_mtgy_mtgy_op_tc35 0xFF08308CU
#define Adr_NX90_mtgy_op_tc35      0xFF08308CU
#define DFLT_VAL_NX90_mtgy_op_tc35 0x00000000U

#define MSK_NX90_mtgy_op_tc35_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc35_val         0
#define DFLT_VAL_NX90_mtgy_op_tc35_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc35_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc35': */
#define MSK_USED_BITS_NX90_mtgy_op_tc35 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc35_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC35_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc35_val; /* data bits 1151..1120 */
} NX90_MTGY_OP_TC35_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC35_BIT_T bf;
} NX90_MTGY_OP_TC35_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc36 */
/* => MWMM TC register 36 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc36  0x00001090U
#define Adr_NX90_mtgy_mtgy_op_tc36 0xFF083090U
#define Adr_NX90_mtgy_op_tc36      0xFF083090U
#define DFLT_VAL_NX90_mtgy_op_tc36 0x00000000U

#define MSK_NX90_mtgy_op_tc36_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc36_val         0
#define DFLT_VAL_NX90_mtgy_op_tc36_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc36_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc36': */
#define MSK_USED_BITS_NX90_mtgy_op_tc36 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc36_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC36_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc36_val; /* data bits 1183..1152 */
} NX90_MTGY_OP_TC36_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC36_BIT_T bf;
} NX90_MTGY_OP_TC36_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc37 */
/* => MWMM TC register 37 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc37  0x00001094U
#define Adr_NX90_mtgy_mtgy_op_tc37 0xFF083094U
#define Adr_NX90_mtgy_op_tc37      0xFF083094U
#define DFLT_VAL_NX90_mtgy_op_tc37 0x00000000U

#define MSK_NX90_mtgy_op_tc37_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc37_val         0
#define DFLT_VAL_NX90_mtgy_op_tc37_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc37_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc37': */
#define MSK_USED_BITS_NX90_mtgy_op_tc37 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc37_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC37_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc37_val; /* data bits 1215..1184 */
} NX90_MTGY_OP_TC37_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC37_BIT_T bf;
} NX90_MTGY_OP_TC37_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc38 */
/* => MWMM TC register 38 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc38  0x00001098U
#define Adr_NX90_mtgy_mtgy_op_tc38 0xFF083098U
#define Adr_NX90_mtgy_op_tc38      0xFF083098U
#define DFLT_VAL_NX90_mtgy_op_tc38 0x00000000U

#define MSK_NX90_mtgy_op_tc38_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc38_val         0
#define DFLT_VAL_NX90_mtgy_op_tc38_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc38_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc38': */
#define MSK_USED_BITS_NX90_mtgy_op_tc38 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc38_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC38_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc38_val; /* data bits 1247..1216 */
} NX90_MTGY_OP_TC38_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC38_BIT_T bf;
} NX90_MTGY_OP_TC38_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc39 */
/* => MWMM TC register 39 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc39  0x0000109CU
#define Adr_NX90_mtgy_mtgy_op_tc39 0xFF08309CU
#define Adr_NX90_mtgy_op_tc39      0xFF08309CU
#define DFLT_VAL_NX90_mtgy_op_tc39 0x00000000U

#define MSK_NX90_mtgy_op_tc39_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc39_val         0
#define DFLT_VAL_NX90_mtgy_op_tc39_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc39_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc39': */
#define MSK_USED_BITS_NX90_mtgy_op_tc39 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc39_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC39_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc39_val; /* data bits 1279..1248 */
} NX90_MTGY_OP_TC39_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC39_BIT_T bf;
} NX90_MTGY_OP_TC39_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc40 */
/* => MWMM TC register 40 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc40  0x000010A0U
#define Adr_NX90_mtgy_mtgy_op_tc40 0xFF0830A0U
#define Adr_NX90_mtgy_op_tc40      0xFF0830A0U
#define DFLT_VAL_NX90_mtgy_op_tc40 0x00000000U

#define MSK_NX90_mtgy_op_tc40_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc40_val         0
#define DFLT_VAL_NX90_mtgy_op_tc40_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc40_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc40': */
#define MSK_USED_BITS_NX90_mtgy_op_tc40 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc40_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC40_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc40_val; /* data bits 1311..1280 */
} NX90_MTGY_OP_TC40_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC40_BIT_T bf;
} NX90_MTGY_OP_TC40_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc41 */
/* => MWMM TC register 41 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc41  0x000010A4U
#define Adr_NX90_mtgy_mtgy_op_tc41 0xFF0830A4U
#define Adr_NX90_mtgy_op_tc41      0xFF0830A4U
#define DFLT_VAL_NX90_mtgy_op_tc41 0x00000000U

#define MSK_NX90_mtgy_op_tc41_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc41_val         0
#define DFLT_VAL_NX90_mtgy_op_tc41_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc41_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc41': */
#define MSK_USED_BITS_NX90_mtgy_op_tc41 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc41_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC41_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc41_val; /* data bits 1343..1312 */
} NX90_MTGY_OP_TC41_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC41_BIT_T bf;
} NX90_MTGY_OP_TC41_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc42 */
/* => MWMM TC register 42 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc42  0x000010A8U
#define Adr_NX90_mtgy_mtgy_op_tc42 0xFF0830A8U
#define Adr_NX90_mtgy_op_tc42      0xFF0830A8U
#define DFLT_VAL_NX90_mtgy_op_tc42 0x00000000U

#define MSK_NX90_mtgy_op_tc42_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc42_val         0
#define DFLT_VAL_NX90_mtgy_op_tc42_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc42_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc42': */
#define MSK_USED_BITS_NX90_mtgy_op_tc42 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc42_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC42_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc42_val; /* data bits 1375..1344 */
} NX90_MTGY_OP_TC42_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC42_BIT_T bf;
} NX90_MTGY_OP_TC42_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc43 */
/* => MWMM TC register 43 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc43  0x000010ACU
#define Adr_NX90_mtgy_mtgy_op_tc43 0xFF0830ACU
#define Adr_NX90_mtgy_op_tc43      0xFF0830ACU
#define DFLT_VAL_NX90_mtgy_op_tc43 0x00000000U

#define MSK_NX90_mtgy_op_tc43_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc43_val         0
#define DFLT_VAL_NX90_mtgy_op_tc43_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc43_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc43': */
#define MSK_USED_BITS_NX90_mtgy_op_tc43 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc43_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC43_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc43_val; /* data bits 1407..1376 */
} NX90_MTGY_OP_TC43_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC43_BIT_T bf;
} NX90_MTGY_OP_TC43_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc44 */
/* => MWMM TC register 44 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc44  0x000010B0U
#define Adr_NX90_mtgy_mtgy_op_tc44 0xFF0830B0U
#define Adr_NX90_mtgy_op_tc44      0xFF0830B0U
#define DFLT_VAL_NX90_mtgy_op_tc44 0x00000000U

#define MSK_NX90_mtgy_op_tc44_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc44_val         0
#define DFLT_VAL_NX90_mtgy_op_tc44_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc44_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc44': */
#define MSK_USED_BITS_NX90_mtgy_op_tc44 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc44_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC44_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc44_val; /* data bits 1439..1408 */
} NX90_MTGY_OP_TC44_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC44_BIT_T bf;
} NX90_MTGY_OP_TC44_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc45 */
/* => MWMM TC register 45 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc45  0x000010B4U
#define Adr_NX90_mtgy_mtgy_op_tc45 0xFF0830B4U
#define Adr_NX90_mtgy_op_tc45      0xFF0830B4U
#define DFLT_VAL_NX90_mtgy_op_tc45 0x00000000U

#define MSK_NX90_mtgy_op_tc45_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc45_val         0
#define DFLT_VAL_NX90_mtgy_op_tc45_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc45_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc45': */
#define MSK_USED_BITS_NX90_mtgy_op_tc45 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc45_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC45_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc45_val; /* data bits 1471..1440 */
} NX90_MTGY_OP_TC45_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC45_BIT_T bf;
} NX90_MTGY_OP_TC45_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc46 */
/* => MWMM TC register 46 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc46  0x000010B8U
#define Adr_NX90_mtgy_mtgy_op_tc46 0xFF0830B8U
#define Adr_NX90_mtgy_op_tc46      0xFF0830B8U
#define DFLT_VAL_NX90_mtgy_op_tc46 0x00000000U

#define MSK_NX90_mtgy_op_tc46_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc46_val         0
#define DFLT_VAL_NX90_mtgy_op_tc46_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc46_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc46': */
#define MSK_USED_BITS_NX90_mtgy_op_tc46 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc46_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC46_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc46_val; /* data bits 1503..1472 */
} NX90_MTGY_OP_TC46_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC46_BIT_T bf;
} NX90_MTGY_OP_TC46_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc47 */
/* => MWMM TC register 47 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc47  0x000010BCU
#define Adr_NX90_mtgy_mtgy_op_tc47 0xFF0830BCU
#define Adr_NX90_mtgy_op_tc47      0xFF0830BCU
#define DFLT_VAL_NX90_mtgy_op_tc47 0x00000000U

#define MSK_NX90_mtgy_op_tc47_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc47_val         0
#define DFLT_VAL_NX90_mtgy_op_tc47_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc47_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc47': */
#define MSK_USED_BITS_NX90_mtgy_op_tc47 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc47_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC47_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc47_val; /* data bits 1535..1504 */
} NX90_MTGY_OP_TC47_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC47_BIT_T bf;
} NX90_MTGY_OP_TC47_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc48 */
/* => MWMM TC register 48 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc48  0x000010C0U
#define Adr_NX90_mtgy_mtgy_op_tc48 0xFF0830C0U
#define Adr_NX90_mtgy_op_tc48      0xFF0830C0U
#define DFLT_VAL_NX90_mtgy_op_tc48 0x00000000U

#define MSK_NX90_mtgy_op_tc48_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc48_val         0
#define DFLT_VAL_NX90_mtgy_op_tc48_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc48_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc48': */
#define MSK_USED_BITS_NX90_mtgy_op_tc48 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc48_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC48_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc48_val; /* data bits 1567..1536 */
} NX90_MTGY_OP_TC48_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC48_BIT_T bf;
} NX90_MTGY_OP_TC48_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc49 */
/* => MWMM TC register 49 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc49  0x000010C4U
#define Adr_NX90_mtgy_mtgy_op_tc49 0xFF0830C4U
#define Adr_NX90_mtgy_op_tc49      0xFF0830C4U
#define DFLT_VAL_NX90_mtgy_op_tc49 0x00000000U

#define MSK_NX90_mtgy_op_tc49_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc49_val         0
#define DFLT_VAL_NX90_mtgy_op_tc49_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc49_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc49': */
#define MSK_USED_BITS_NX90_mtgy_op_tc49 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc49_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC49_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc49_val; /* data bits 1599..1568 */
} NX90_MTGY_OP_TC49_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC49_BIT_T bf;
} NX90_MTGY_OP_TC49_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc50 */
/* => MWMM TC register 50 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc50  0x000010C8U
#define Adr_NX90_mtgy_mtgy_op_tc50 0xFF0830C8U
#define Adr_NX90_mtgy_op_tc50      0xFF0830C8U
#define DFLT_VAL_NX90_mtgy_op_tc50 0x00000000U

#define MSK_NX90_mtgy_op_tc50_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc50_val         0
#define DFLT_VAL_NX90_mtgy_op_tc50_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc50_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc50': */
#define MSK_USED_BITS_NX90_mtgy_op_tc50 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc50_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC50_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc50_val; /* data bits 1631..1600 */
} NX90_MTGY_OP_TC50_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC50_BIT_T bf;
} NX90_MTGY_OP_TC50_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc51 */
/* => MWMM TC register 51 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc51  0x000010CCU
#define Adr_NX90_mtgy_mtgy_op_tc51 0xFF0830CCU
#define Adr_NX90_mtgy_op_tc51      0xFF0830CCU
#define DFLT_VAL_NX90_mtgy_op_tc51 0x00000000U

#define MSK_NX90_mtgy_op_tc51_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc51_val         0
#define DFLT_VAL_NX90_mtgy_op_tc51_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc51_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc51': */
#define MSK_USED_BITS_NX90_mtgy_op_tc51 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc51_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC51_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc51_val; /* data bits 1663..1632 */
} NX90_MTGY_OP_TC51_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC51_BIT_T bf;
} NX90_MTGY_OP_TC51_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc52 */
/* => MWMM TC register 52 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc52  0x000010D0U
#define Adr_NX90_mtgy_mtgy_op_tc52 0xFF0830D0U
#define Adr_NX90_mtgy_op_tc52      0xFF0830D0U
#define DFLT_VAL_NX90_mtgy_op_tc52 0x00000000U

#define MSK_NX90_mtgy_op_tc52_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc52_val         0
#define DFLT_VAL_NX90_mtgy_op_tc52_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc52_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc52': */
#define MSK_USED_BITS_NX90_mtgy_op_tc52 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc52_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC52_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc52_val; /* data bits 1695..1664 */
} NX90_MTGY_OP_TC52_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC52_BIT_T bf;
} NX90_MTGY_OP_TC52_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc53 */
/* => MWMM TC register 53 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc53  0x000010D4U
#define Adr_NX90_mtgy_mtgy_op_tc53 0xFF0830D4U
#define Adr_NX90_mtgy_op_tc53      0xFF0830D4U
#define DFLT_VAL_NX90_mtgy_op_tc53 0x00000000U

#define MSK_NX90_mtgy_op_tc53_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc53_val         0
#define DFLT_VAL_NX90_mtgy_op_tc53_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc53_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc53': */
#define MSK_USED_BITS_NX90_mtgy_op_tc53 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc53_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC53_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc53_val; /* data bits 1727..1696 */
} NX90_MTGY_OP_TC53_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC53_BIT_T bf;
} NX90_MTGY_OP_TC53_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc54 */
/* => MWMM TC register 54 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc54  0x000010D8U
#define Adr_NX90_mtgy_mtgy_op_tc54 0xFF0830D8U
#define Adr_NX90_mtgy_op_tc54      0xFF0830D8U
#define DFLT_VAL_NX90_mtgy_op_tc54 0x00000000U

#define MSK_NX90_mtgy_op_tc54_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc54_val         0
#define DFLT_VAL_NX90_mtgy_op_tc54_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc54_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc54': */
#define MSK_USED_BITS_NX90_mtgy_op_tc54 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc54_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC54_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc54_val; /* data bits 1759..1728 */
} NX90_MTGY_OP_TC54_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC54_BIT_T bf;
} NX90_MTGY_OP_TC54_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc55 */
/* => MWMM TC register 55 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc55  0x000010DCU
#define Adr_NX90_mtgy_mtgy_op_tc55 0xFF0830DCU
#define Adr_NX90_mtgy_op_tc55      0xFF0830DCU
#define DFLT_VAL_NX90_mtgy_op_tc55 0x00000000U

#define MSK_NX90_mtgy_op_tc55_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc55_val         0
#define DFLT_VAL_NX90_mtgy_op_tc55_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc55_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc55': */
#define MSK_USED_BITS_NX90_mtgy_op_tc55 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc55_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC55_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc55_val; /* data bits 1791..1760 */
} NX90_MTGY_OP_TC55_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC55_BIT_T bf;
} NX90_MTGY_OP_TC55_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc56 */
/* => MWMM TC register 56 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc56  0x000010E0U
#define Adr_NX90_mtgy_mtgy_op_tc56 0xFF0830E0U
#define Adr_NX90_mtgy_op_tc56      0xFF0830E0U
#define DFLT_VAL_NX90_mtgy_op_tc56 0x00000000U

#define MSK_NX90_mtgy_op_tc56_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc56_val         0
#define DFLT_VAL_NX90_mtgy_op_tc56_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc56_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc56': */
#define MSK_USED_BITS_NX90_mtgy_op_tc56 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc56_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC56_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc56_val; /* data bits 1823..1792 */
} NX90_MTGY_OP_TC56_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC56_BIT_T bf;
} NX90_MTGY_OP_TC56_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc57 */
/* => MWMM TC register 57 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc57  0x000010E4U
#define Adr_NX90_mtgy_mtgy_op_tc57 0xFF0830E4U
#define Adr_NX90_mtgy_op_tc57      0xFF0830E4U
#define DFLT_VAL_NX90_mtgy_op_tc57 0x00000000U

#define MSK_NX90_mtgy_op_tc57_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc57_val         0
#define DFLT_VAL_NX90_mtgy_op_tc57_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc57_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc57': */
#define MSK_USED_BITS_NX90_mtgy_op_tc57 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc57_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC57_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc57_val; /* data bits 1855..1824 */
} NX90_MTGY_OP_TC57_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC57_BIT_T bf;
} NX90_MTGY_OP_TC57_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc58 */
/* => MWMM TC register 58 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc58  0x000010E8U
#define Adr_NX90_mtgy_mtgy_op_tc58 0xFF0830E8U
#define Adr_NX90_mtgy_op_tc58      0xFF0830E8U
#define DFLT_VAL_NX90_mtgy_op_tc58 0x00000000U

#define MSK_NX90_mtgy_op_tc58_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc58_val         0
#define DFLT_VAL_NX90_mtgy_op_tc58_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc58_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc58': */
#define MSK_USED_BITS_NX90_mtgy_op_tc58 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc58_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC58_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc58_val; /* data bits 1887..1856 */
} NX90_MTGY_OP_TC58_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC58_BIT_T bf;
} NX90_MTGY_OP_TC58_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc59 */
/* => MWMM TC register 59 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc59  0x000010ECU
#define Adr_NX90_mtgy_mtgy_op_tc59 0xFF0830ECU
#define Adr_NX90_mtgy_op_tc59      0xFF0830ECU
#define DFLT_VAL_NX90_mtgy_op_tc59 0x00000000U

#define MSK_NX90_mtgy_op_tc59_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc59_val         0
#define DFLT_VAL_NX90_mtgy_op_tc59_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc59_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc59': */
#define MSK_USED_BITS_NX90_mtgy_op_tc59 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc59_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC59_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc59_val; /* data bits 1919..1888 */
} NX90_MTGY_OP_TC59_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC59_BIT_T bf;
} NX90_MTGY_OP_TC59_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc60 */
/* => MWMM TC register 60 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc60  0x000010F0U
#define Adr_NX90_mtgy_mtgy_op_tc60 0xFF0830F0U
#define Adr_NX90_mtgy_op_tc60      0xFF0830F0U
#define DFLT_VAL_NX90_mtgy_op_tc60 0x00000000U

#define MSK_NX90_mtgy_op_tc60_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc60_val         0
#define DFLT_VAL_NX90_mtgy_op_tc60_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc60_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc60': */
#define MSK_USED_BITS_NX90_mtgy_op_tc60 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc60_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC60_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc60_val; /* data bits 1951..1920 */
} NX90_MTGY_OP_TC60_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC60_BIT_T bf;
} NX90_MTGY_OP_TC60_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc61 */
/* => MWMM TC register 61 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc61  0x000010F4U
#define Adr_NX90_mtgy_mtgy_op_tc61 0xFF0830F4U
#define Adr_NX90_mtgy_op_tc61      0xFF0830F4U
#define DFLT_VAL_NX90_mtgy_op_tc61 0x00000000U

#define MSK_NX90_mtgy_op_tc61_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc61_val         0
#define DFLT_VAL_NX90_mtgy_op_tc61_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc61_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc61': */
#define MSK_USED_BITS_NX90_mtgy_op_tc61 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc61_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC61_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc61_val; /* data bits 1983..1952 */
} NX90_MTGY_OP_TC61_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC61_BIT_T bf;
} NX90_MTGY_OP_TC61_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc62 */
/* => MWMM TC register 62 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc62  0x000010F8U
#define Adr_NX90_mtgy_mtgy_op_tc62 0xFF0830F8U
#define Adr_NX90_mtgy_op_tc62      0xFF0830F8U
#define DFLT_VAL_NX90_mtgy_op_tc62 0x00000000U

#define MSK_NX90_mtgy_op_tc62_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc62_val         0
#define DFLT_VAL_NX90_mtgy_op_tc62_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc62_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc62': */
#define MSK_USED_BITS_NX90_mtgy_op_tc62 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc62_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC62_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc62_val; /* data bits 2015..1984 */
} NX90_MTGY_OP_TC62_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC62_BIT_T bf;
} NX90_MTGY_OP_TC62_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc63 */
/* => MWMM TC register 63 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc63  0x000010FCU
#define Adr_NX90_mtgy_mtgy_op_tc63 0xFF0830FCU
#define Adr_NX90_mtgy_op_tc63      0xFF0830FCU
#define DFLT_VAL_NX90_mtgy_op_tc63 0x00000000U

#define MSK_NX90_mtgy_op_tc63_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc63_val         0
#define DFLT_VAL_NX90_mtgy_op_tc63_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc63_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc63': */
#define MSK_USED_BITS_NX90_mtgy_op_tc63 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc63_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC63_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc63_val; /* data bits 2047..2016 */
} NX90_MTGY_OP_TC63_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC63_BIT_T bf;
} NX90_MTGY_OP_TC63_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc64 */
/* => MWMM TC register 64 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc64  0x00001100U
#define Adr_NX90_mtgy_mtgy_op_tc64 0xFF083100U
#define Adr_NX90_mtgy_op_tc64      0xFF083100U
#define DFLT_VAL_NX90_mtgy_op_tc64 0x00000000U

#define MSK_NX90_mtgy_op_tc64_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc64_val         0
#define DFLT_VAL_NX90_mtgy_op_tc64_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc64_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc64': */
#define MSK_USED_BITS_NX90_mtgy_op_tc64 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc64_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC64_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc64_val; /* data bits 2079..2048 */
} NX90_MTGY_OP_TC64_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC64_BIT_T bf;
} NX90_MTGY_OP_TC64_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc65 */
/* => MWMM TC register 65 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc65  0x00001104U
#define Adr_NX90_mtgy_mtgy_op_tc65 0xFF083104U
#define Adr_NX90_mtgy_op_tc65      0xFF083104U
#define DFLT_VAL_NX90_mtgy_op_tc65 0x00000000U

#define MSK_NX90_mtgy_op_tc65_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc65_val         0
#define DFLT_VAL_NX90_mtgy_op_tc65_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc65_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc65': */
#define MSK_USED_BITS_NX90_mtgy_op_tc65 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc65_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC65_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc65_val; /* data bits 2111..2080 */
} NX90_MTGY_OP_TC65_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC65_BIT_T bf;
} NX90_MTGY_OP_TC65_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc66 */
/* => MWMM TC register 66 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc66  0x00001108U
#define Adr_NX90_mtgy_mtgy_op_tc66 0xFF083108U
#define Adr_NX90_mtgy_op_tc66      0xFF083108U
#define DFLT_VAL_NX90_mtgy_op_tc66 0x00000000U

#define MSK_NX90_mtgy_op_tc66_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc66_val         0
#define DFLT_VAL_NX90_mtgy_op_tc66_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc66_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc66': */
#define MSK_USED_BITS_NX90_mtgy_op_tc66 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc66_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC66_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc66_val; /* data bits 2143..2112 */
} NX90_MTGY_OP_TC66_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC66_BIT_T bf;
} NX90_MTGY_OP_TC66_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc67 */
/* => MWMM TC register 67 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc67  0x0000110CU
#define Adr_NX90_mtgy_mtgy_op_tc67 0xFF08310CU
#define Adr_NX90_mtgy_op_tc67      0xFF08310CU
#define DFLT_VAL_NX90_mtgy_op_tc67 0x00000000U

#define MSK_NX90_mtgy_op_tc67_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc67_val         0
#define DFLT_VAL_NX90_mtgy_op_tc67_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc67_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc67': */
#define MSK_USED_BITS_NX90_mtgy_op_tc67 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc67_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC67_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc67_val; /* data bits 2175..2144 */
} NX90_MTGY_OP_TC67_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC67_BIT_T bf;
} NX90_MTGY_OP_TC67_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc68 */
/* => MWMM TC register 68 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc68  0x00001110U
#define Adr_NX90_mtgy_mtgy_op_tc68 0xFF083110U
#define Adr_NX90_mtgy_op_tc68      0xFF083110U
#define DFLT_VAL_NX90_mtgy_op_tc68 0x00000000U

#define MSK_NX90_mtgy_op_tc68_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc68_val         0
#define DFLT_VAL_NX90_mtgy_op_tc68_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc68_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc68': */
#define MSK_USED_BITS_NX90_mtgy_op_tc68 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc68_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC68_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc68_val; /* data bits 2207..2176 */
} NX90_MTGY_OP_TC68_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC68_BIT_T bf;
} NX90_MTGY_OP_TC68_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc69 */
/* => MWMM TC register 69 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc69  0x00001114U
#define Adr_NX90_mtgy_mtgy_op_tc69 0xFF083114U
#define Adr_NX90_mtgy_op_tc69      0xFF083114U
#define DFLT_VAL_NX90_mtgy_op_tc69 0x00000000U

#define MSK_NX90_mtgy_op_tc69_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc69_val         0
#define DFLT_VAL_NX90_mtgy_op_tc69_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc69_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc69': */
#define MSK_USED_BITS_NX90_mtgy_op_tc69 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc69_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC69_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc69_val; /* data bits 2239..2208 */
} NX90_MTGY_OP_TC69_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC69_BIT_T bf;
} NX90_MTGY_OP_TC69_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc70 */
/* => MWMM TC register 70 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc70  0x00001118U
#define Adr_NX90_mtgy_mtgy_op_tc70 0xFF083118U
#define Adr_NX90_mtgy_op_tc70      0xFF083118U
#define DFLT_VAL_NX90_mtgy_op_tc70 0x00000000U

#define MSK_NX90_mtgy_op_tc70_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc70_val         0
#define DFLT_VAL_NX90_mtgy_op_tc70_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc70_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc70': */
#define MSK_USED_BITS_NX90_mtgy_op_tc70 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc70_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC70_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc70_val; /* data bits 2271..2240 */
} NX90_MTGY_OP_TC70_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC70_BIT_T bf;
} NX90_MTGY_OP_TC70_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc71 */
/* => MWMM TC register 71 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc71  0x0000111CU
#define Adr_NX90_mtgy_mtgy_op_tc71 0xFF08311CU
#define Adr_NX90_mtgy_op_tc71      0xFF08311CU
#define DFLT_VAL_NX90_mtgy_op_tc71 0x00000000U

#define MSK_NX90_mtgy_op_tc71_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc71_val         0
#define DFLT_VAL_NX90_mtgy_op_tc71_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc71_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc71': */
#define MSK_USED_BITS_NX90_mtgy_op_tc71 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc71_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC71_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc71_val; /* data bits 2303..2272 */
} NX90_MTGY_OP_TC71_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC71_BIT_T bf;
} NX90_MTGY_OP_TC71_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc72 */
/* => MWMM TC register 72 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc72  0x00001120U
#define Adr_NX90_mtgy_mtgy_op_tc72 0xFF083120U
#define Adr_NX90_mtgy_op_tc72      0xFF083120U
#define DFLT_VAL_NX90_mtgy_op_tc72 0x00000000U

#define MSK_NX90_mtgy_op_tc72_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc72_val         0
#define DFLT_VAL_NX90_mtgy_op_tc72_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc72_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc72': */
#define MSK_USED_BITS_NX90_mtgy_op_tc72 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc72_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC72_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc72_val; /* data bits 2335..2304 */
} NX90_MTGY_OP_TC72_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC72_BIT_T bf;
} NX90_MTGY_OP_TC72_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc73 */
/* => MWMM TC register 73 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc73  0x00001124U
#define Adr_NX90_mtgy_mtgy_op_tc73 0xFF083124U
#define Adr_NX90_mtgy_op_tc73      0xFF083124U
#define DFLT_VAL_NX90_mtgy_op_tc73 0x00000000U

#define MSK_NX90_mtgy_op_tc73_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc73_val         0
#define DFLT_VAL_NX90_mtgy_op_tc73_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc73_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc73': */
#define MSK_USED_BITS_NX90_mtgy_op_tc73 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc73_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC73_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc73_val; /* data bits 2367..2336 */
} NX90_MTGY_OP_TC73_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC73_BIT_T bf;
} NX90_MTGY_OP_TC73_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc74 */
/* => MWMM TC register 74 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc74  0x00001128U
#define Adr_NX90_mtgy_mtgy_op_tc74 0xFF083128U
#define Adr_NX90_mtgy_op_tc74      0xFF083128U
#define DFLT_VAL_NX90_mtgy_op_tc74 0x00000000U

#define MSK_NX90_mtgy_op_tc74_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc74_val         0
#define DFLT_VAL_NX90_mtgy_op_tc74_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc74_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc74': */
#define MSK_USED_BITS_NX90_mtgy_op_tc74 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc74_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC74_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc74_val; /* data bits 2399..2368 */
} NX90_MTGY_OP_TC74_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC74_BIT_T bf;
} NX90_MTGY_OP_TC74_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc75 */
/* => MWMM TC register 75 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc75  0x0000112CU
#define Adr_NX90_mtgy_mtgy_op_tc75 0xFF08312CU
#define Adr_NX90_mtgy_op_tc75      0xFF08312CU
#define DFLT_VAL_NX90_mtgy_op_tc75 0x00000000U

#define MSK_NX90_mtgy_op_tc75_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc75_val         0
#define DFLT_VAL_NX90_mtgy_op_tc75_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc75_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc75': */
#define MSK_USED_BITS_NX90_mtgy_op_tc75 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc75_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC75_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc75_val; /* data bits 2431..2400 */
} NX90_MTGY_OP_TC75_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC75_BIT_T bf;
} NX90_MTGY_OP_TC75_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc76 */
/* => MWMM TC register 76 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc76  0x00001130U
#define Adr_NX90_mtgy_mtgy_op_tc76 0xFF083130U
#define Adr_NX90_mtgy_op_tc76      0xFF083130U
#define DFLT_VAL_NX90_mtgy_op_tc76 0x00000000U

#define MSK_NX90_mtgy_op_tc76_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc76_val         0
#define DFLT_VAL_NX90_mtgy_op_tc76_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc76_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc76': */
#define MSK_USED_BITS_NX90_mtgy_op_tc76 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc76_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC76_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc76_val; /* data bits 2463..2432 */
} NX90_MTGY_OP_TC76_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC76_BIT_T bf;
} NX90_MTGY_OP_TC76_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc77 */
/* => MWMM TC register 77 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc77  0x00001134U
#define Adr_NX90_mtgy_mtgy_op_tc77 0xFF083134U
#define Adr_NX90_mtgy_op_tc77      0xFF083134U
#define DFLT_VAL_NX90_mtgy_op_tc77 0x00000000U

#define MSK_NX90_mtgy_op_tc77_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc77_val         0
#define DFLT_VAL_NX90_mtgy_op_tc77_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc77_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc77': */
#define MSK_USED_BITS_NX90_mtgy_op_tc77 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc77_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC77_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc77_val; /* data bits 2495..2464 */
} NX90_MTGY_OP_TC77_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC77_BIT_T bf;
} NX90_MTGY_OP_TC77_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc78 */
/* => MWMM TC register 78 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc78  0x00001138U
#define Adr_NX90_mtgy_mtgy_op_tc78 0xFF083138U
#define Adr_NX90_mtgy_op_tc78      0xFF083138U
#define DFLT_VAL_NX90_mtgy_op_tc78 0x00000000U

#define MSK_NX90_mtgy_op_tc78_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc78_val         0
#define DFLT_VAL_NX90_mtgy_op_tc78_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc78_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc78': */
#define MSK_USED_BITS_NX90_mtgy_op_tc78 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc78_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC78_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc78_val; /* data bits 2527..2496 */
} NX90_MTGY_OP_TC78_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC78_BIT_T bf;
} NX90_MTGY_OP_TC78_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc79 */
/* => MWMM TC register 79 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc79  0x0000113CU
#define Adr_NX90_mtgy_mtgy_op_tc79 0xFF08313CU
#define Adr_NX90_mtgy_op_tc79      0xFF08313CU
#define DFLT_VAL_NX90_mtgy_op_tc79 0x00000000U

#define MSK_NX90_mtgy_op_tc79_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc79_val         0
#define DFLT_VAL_NX90_mtgy_op_tc79_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc79_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc79': */
#define MSK_USED_BITS_NX90_mtgy_op_tc79 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc79_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC79_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc79_val; /* data bits 2559..2528 */
} NX90_MTGY_OP_TC79_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC79_BIT_T bf;
} NX90_MTGY_OP_TC79_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc80 */
/* => MWMM TC register 80 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc80  0x00001140U
#define Adr_NX90_mtgy_mtgy_op_tc80 0xFF083140U
#define Adr_NX90_mtgy_op_tc80      0xFF083140U
#define DFLT_VAL_NX90_mtgy_op_tc80 0x00000000U

#define MSK_NX90_mtgy_op_tc80_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc80_val         0
#define DFLT_VAL_NX90_mtgy_op_tc80_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc80_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc80': */
#define MSK_USED_BITS_NX90_mtgy_op_tc80 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc80_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC80_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc80_val; /* data bits 2591..2560 */
} NX90_MTGY_OP_TC80_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC80_BIT_T bf;
} NX90_MTGY_OP_TC80_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc81 */
/* => MWMM TC register 81 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc81  0x00001144U
#define Adr_NX90_mtgy_mtgy_op_tc81 0xFF083144U
#define Adr_NX90_mtgy_op_tc81      0xFF083144U
#define DFLT_VAL_NX90_mtgy_op_tc81 0x00000000U

#define MSK_NX90_mtgy_op_tc81_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc81_val         0
#define DFLT_VAL_NX90_mtgy_op_tc81_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc81_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc81': */
#define MSK_USED_BITS_NX90_mtgy_op_tc81 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc81_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC81_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc81_val; /* data bits 2623..2592 */
} NX90_MTGY_OP_TC81_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC81_BIT_T bf;
} NX90_MTGY_OP_TC81_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc82 */
/* => MWMM TC register 82 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc82  0x00001148U
#define Adr_NX90_mtgy_mtgy_op_tc82 0xFF083148U
#define Adr_NX90_mtgy_op_tc82      0xFF083148U
#define DFLT_VAL_NX90_mtgy_op_tc82 0x00000000U

#define MSK_NX90_mtgy_op_tc82_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc82_val         0
#define DFLT_VAL_NX90_mtgy_op_tc82_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc82_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc82': */
#define MSK_USED_BITS_NX90_mtgy_op_tc82 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc82_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC82_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc82_val; /* data bits 2655..2624 */
} NX90_MTGY_OP_TC82_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC82_BIT_T bf;
} NX90_MTGY_OP_TC82_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc83 */
/* => MWMM TC register 83 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc83  0x0000114CU
#define Adr_NX90_mtgy_mtgy_op_tc83 0xFF08314CU
#define Adr_NX90_mtgy_op_tc83      0xFF08314CU
#define DFLT_VAL_NX90_mtgy_op_tc83 0x00000000U

#define MSK_NX90_mtgy_op_tc83_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc83_val         0
#define DFLT_VAL_NX90_mtgy_op_tc83_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc83_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc83': */
#define MSK_USED_BITS_NX90_mtgy_op_tc83 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc83_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC83_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc83_val; /* data bits 2687..2656 */
} NX90_MTGY_OP_TC83_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC83_BIT_T bf;
} NX90_MTGY_OP_TC83_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc84 */
/* => MWMM TC register 84 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc84  0x00001150U
#define Adr_NX90_mtgy_mtgy_op_tc84 0xFF083150U
#define Adr_NX90_mtgy_op_tc84      0xFF083150U
#define DFLT_VAL_NX90_mtgy_op_tc84 0x00000000U

#define MSK_NX90_mtgy_op_tc84_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc84_val         0
#define DFLT_VAL_NX90_mtgy_op_tc84_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc84_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc84': */
#define MSK_USED_BITS_NX90_mtgy_op_tc84 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc84_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC84_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc84_val; /* data bits 2719..2688 */
} NX90_MTGY_OP_TC84_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC84_BIT_T bf;
} NX90_MTGY_OP_TC84_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc85 */
/* => MWMM TC register 85 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc85  0x00001154U
#define Adr_NX90_mtgy_mtgy_op_tc85 0xFF083154U
#define Adr_NX90_mtgy_op_tc85      0xFF083154U
#define DFLT_VAL_NX90_mtgy_op_tc85 0x00000000U

#define MSK_NX90_mtgy_op_tc85_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc85_val         0
#define DFLT_VAL_NX90_mtgy_op_tc85_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc85_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc85': */
#define MSK_USED_BITS_NX90_mtgy_op_tc85 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc85_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC85_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc85_val; /* data bits 2751..2720 */
} NX90_MTGY_OP_TC85_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC85_BIT_T bf;
} NX90_MTGY_OP_TC85_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc86 */
/* => MWMM TC register 86 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc86  0x00001158U
#define Adr_NX90_mtgy_mtgy_op_tc86 0xFF083158U
#define Adr_NX90_mtgy_op_tc86      0xFF083158U
#define DFLT_VAL_NX90_mtgy_op_tc86 0x00000000U

#define MSK_NX90_mtgy_op_tc86_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc86_val         0
#define DFLT_VAL_NX90_mtgy_op_tc86_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc86_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc86': */
#define MSK_USED_BITS_NX90_mtgy_op_tc86 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc86_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC86_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc86_val; /* data bits 2783..2752 */
} NX90_MTGY_OP_TC86_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC86_BIT_T bf;
} NX90_MTGY_OP_TC86_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc87 */
/* => MWMM TC register 87 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc87  0x0000115CU
#define Adr_NX90_mtgy_mtgy_op_tc87 0xFF08315CU
#define Adr_NX90_mtgy_op_tc87      0xFF08315CU
#define DFLT_VAL_NX90_mtgy_op_tc87 0x00000000U

#define MSK_NX90_mtgy_op_tc87_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc87_val         0
#define DFLT_VAL_NX90_mtgy_op_tc87_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc87_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc87': */
#define MSK_USED_BITS_NX90_mtgy_op_tc87 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc87_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC87_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc87_val; /* data bits 2815..2784 */
} NX90_MTGY_OP_TC87_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC87_BIT_T bf;
} NX90_MTGY_OP_TC87_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc88 */
/* => MWMM TC register 88 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc88  0x00001160U
#define Adr_NX90_mtgy_mtgy_op_tc88 0xFF083160U
#define Adr_NX90_mtgy_op_tc88      0xFF083160U
#define DFLT_VAL_NX90_mtgy_op_tc88 0x00000000U

#define MSK_NX90_mtgy_op_tc88_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc88_val         0
#define DFLT_VAL_NX90_mtgy_op_tc88_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc88_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc88': */
#define MSK_USED_BITS_NX90_mtgy_op_tc88 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc88_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC88_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc88_val; /* data bits 2847..2816 */
} NX90_MTGY_OP_TC88_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC88_BIT_T bf;
} NX90_MTGY_OP_TC88_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc89 */
/* => MWMM TC register 89 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc89  0x00001164U
#define Adr_NX90_mtgy_mtgy_op_tc89 0xFF083164U
#define Adr_NX90_mtgy_op_tc89      0xFF083164U
#define DFLT_VAL_NX90_mtgy_op_tc89 0x00000000U

#define MSK_NX90_mtgy_op_tc89_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc89_val         0
#define DFLT_VAL_NX90_mtgy_op_tc89_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc89_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc89': */
#define MSK_USED_BITS_NX90_mtgy_op_tc89 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc89_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC89_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc89_val; /* data bits 2879..2848 */
} NX90_MTGY_OP_TC89_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC89_BIT_T bf;
} NX90_MTGY_OP_TC89_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc90 */
/* => MWMM TC register 90 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc90  0x00001168U
#define Adr_NX90_mtgy_mtgy_op_tc90 0xFF083168U
#define Adr_NX90_mtgy_op_tc90      0xFF083168U
#define DFLT_VAL_NX90_mtgy_op_tc90 0x00000000U

#define MSK_NX90_mtgy_op_tc90_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc90_val         0
#define DFLT_VAL_NX90_mtgy_op_tc90_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc90_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc90': */
#define MSK_USED_BITS_NX90_mtgy_op_tc90 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc90_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC90_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc90_val; /* data bits 2911..2880 */
} NX90_MTGY_OP_TC90_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC90_BIT_T bf;
} NX90_MTGY_OP_TC90_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc91 */
/* => MWMM TC register 91 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc91  0x0000116CU
#define Adr_NX90_mtgy_mtgy_op_tc91 0xFF08316CU
#define Adr_NX90_mtgy_op_tc91      0xFF08316CU
#define DFLT_VAL_NX90_mtgy_op_tc91 0x00000000U

#define MSK_NX90_mtgy_op_tc91_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc91_val         0
#define DFLT_VAL_NX90_mtgy_op_tc91_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc91_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc91': */
#define MSK_USED_BITS_NX90_mtgy_op_tc91 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc91_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC91_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc91_val; /* data bits 2943..2912 */
} NX90_MTGY_OP_TC91_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC91_BIT_T bf;
} NX90_MTGY_OP_TC91_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc92 */
/* => MWMM TC register 92 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc92  0x00001170U
#define Adr_NX90_mtgy_mtgy_op_tc92 0xFF083170U
#define Adr_NX90_mtgy_op_tc92      0xFF083170U
#define DFLT_VAL_NX90_mtgy_op_tc92 0x00000000U

#define MSK_NX90_mtgy_op_tc92_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc92_val         0
#define DFLT_VAL_NX90_mtgy_op_tc92_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc92_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc92': */
#define MSK_USED_BITS_NX90_mtgy_op_tc92 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc92_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC92_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc92_val; /* data bits 2975..2944 */
} NX90_MTGY_OP_TC92_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC92_BIT_T bf;
} NX90_MTGY_OP_TC92_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc93 */
/* => MWMM TC register 93 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc93  0x00001174U
#define Adr_NX90_mtgy_mtgy_op_tc93 0xFF083174U
#define Adr_NX90_mtgy_op_tc93      0xFF083174U
#define DFLT_VAL_NX90_mtgy_op_tc93 0x00000000U

#define MSK_NX90_mtgy_op_tc93_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc93_val         0
#define DFLT_VAL_NX90_mtgy_op_tc93_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc93_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc93': */
#define MSK_USED_BITS_NX90_mtgy_op_tc93 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc93_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC93_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc93_val; /* data bits 3007..2976 */
} NX90_MTGY_OP_TC93_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC93_BIT_T bf;
} NX90_MTGY_OP_TC93_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc94 */
/* => MWMM TC register 94 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc94  0x00001178U
#define Adr_NX90_mtgy_mtgy_op_tc94 0xFF083178U
#define Adr_NX90_mtgy_op_tc94      0xFF083178U
#define DFLT_VAL_NX90_mtgy_op_tc94 0x00000000U

#define MSK_NX90_mtgy_op_tc94_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc94_val         0
#define DFLT_VAL_NX90_mtgy_op_tc94_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc94_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc94': */
#define MSK_USED_BITS_NX90_mtgy_op_tc94 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc94_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC94_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc94_val; /* data bits 3039..3008 */
} NX90_MTGY_OP_TC94_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC94_BIT_T bf;
} NX90_MTGY_OP_TC94_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc95 */
/* => MWMM TC register 95 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc95  0x0000117CU
#define Adr_NX90_mtgy_mtgy_op_tc95 0xFF08317CU
#define Adr_NX90_mtgy_op_tc95      0xFF08317CU
#define DFLT_VAL_NX90_mtgy_op_tc95 0x00000000U

#define MSK_NX90_mtgy_op_tc95_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc95_val         0
#define DFLT_VAL_NX90_mtgy_op_tc95_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc95_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc95': */
#define MSK_USED_BITS_NX90_mtgy_op_tc95 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc95_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC95_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc95_val; /* data bits 3071..3040 */
} NX90_MTGY_OP_TC95_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC95_BIT_T bf;
} NX90_MTGY_OP_TC95_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc96 */
/* => MWMM TC register 96 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc96  0x00001180U
#define Adr_NX90_mtgy_mtgy_op_tc96 0xFF083180U
#define Adr_NX90_mtgy_op_tc96      0xFF083180U
#define DFLT_VAL_NX90_mtgy_op_tc96 0x00000000U

#define MSK_NX90_mtgy_op_tc96_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc96_val         0
#define DFLT_VAL_NX90_mtgy_op_tc96_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc96_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc96': */
#define MSK_USED_BITS_NX90_mtgy_op_tc96 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc96_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC96_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc96_val; /* data bits 3103..3072 */
} NX90_MTGY_OP_TC96_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC96_BIT_T bf;
} NX90_MTGY_OP_TC96_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc97 */
/* => MWMM TC register 97 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc97  0x00001184U
#define Adr_NX90_mtgy_mtgy_op_tc97 0xFF083184U
#define Adr_NX90_mtgy_op_tc97      0xFF083184U
#define DFLT_VAL_NX90_mtgy_op_tc97 0x00000000U

#define MSK_NX90_mtgy_op_tc97_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc97_val         0
#define DFLT_VAL_NX90_mtgy_op_tc97_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc97_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc97': */
#define MSK_USED_BITS_NX90_mtgy_op_tc97 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc97_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC97_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc97_val; /* data bits 3135..3104 */
} NX90_MTGY_OP_TC97_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC97_BIT_T bf;
} NX90_MTGY_OP_TC97_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc98 */
/* => MWMM TC register 98 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc98  0x00001188U
#define Adr_NX90_mtgy_mtgy_op_tc98 0xFF083188U
#define Adr_NX90_mtgy_op_tc98      0xFF083188U
#define DFLT_VAL_NX90_mtgy_op_tc98 0x00000000U

#define MSK_NX90_mtgy_op_tc98_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc98_val         0
#define DFLT_VAL_NX90_mtgy_op_tc98_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc98_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc98': */
#define MSK_USED_BITS_NX90_mtgy_op_tc98 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc98_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC98_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc98_val; /* data bits 3167..3136 */
} NX90_MTGY_OP_TC98_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC98_BIT_T bf;
} NX90_MTGY_OP_TC98_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc99 */
/* => MWMM TC register 99 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc99  0x0000118CU
#define Adr_NX90_mtgy_mtgy_op_tc99 0xFF08318CU
#define Adr_NX90_mtgy_op_tc99      0xFF08318CU
#define DFLT_VAL_NX90_mtgy_op_tc99 0x00000000U

#define MSK_NX90_mtgy_op_tc99_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc99_val         0
#define DFLT_VAL_NX90_mtgy_op_tc99_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc99_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc99': */
#define MSK_USED_BITS_NX90_mtgy_op_tc99 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc99_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC99_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc99_val; /* data bits 3199..3168 */
} NX90_MTGY_OP_TC99_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TC99_BIT_T bf;
} NX90_MTGY_OP_TC99_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc100 */
/* => MWMM TC register 100 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc100  0x00001190U
#define Adr_NX90_mtgy_mtgy_op_tc100 0xFF083190U
#define Adr_NX90_mtgy_op_tc100      0xFF083190U
#define DFLT_VAL_NX90_mtgy_op_tc100 0x00000000U

#define MSK_NX90_mtgy_op_tc100_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc100_val         0
#define DFLT_VAL_NX90_mtgy_op_tc100_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc100_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc100': */
#define MSK_USED_BITS_NX90_mtgy_op_tc100 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc100_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC100_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc100_val; /* data bits 3231..3200 */
} NX90_MTGY_OP_TC100_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC100_BIT_T bf;
} NX90_MTGY_OP_TC100_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc101 */
/* => MWMM TC register 101 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc101  0x00001194U
#define Adr_NX90_mtgy_mtgy_op_tc101 0xFF083194U
#define Adr_NX90_mtgy_op_tc101      0xFF083194U
#define DFLT_VAL_NX90_mtgy_op_tc101 0x00000000U

#define MSK_NX90_mtgy_op_tc101_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc101_val         0
#define DFLT_VAL_NX90_mtgy_op_tc101_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc101_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc101': */
#define MSK_USED_BITS_NX90_mtgy_op_tc101 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc101_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC101_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc101_val; /* data bits 3263..3232 */
} NX90_MTGY_OP_TC101_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC101_BIT_T bf;
} NX90_MTGY_OP_TC101_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc102 */
/* => MWMM TC register 102 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc102  0x00001198U
#define Adr_NX90_mtgy_mtgy_op_tc102 0xFF083198U
#define Adr_NX90_mtgy_op_tc102      0xFF083198U
#define DFLT_VAL_NX90_mtgy_op_tc102 0x00000000U

#define MSK_NX90_mtgy_op_tc102_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc102_val         0
#define DFLT_VAL_NX90_mtgy_op_tc102_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc102_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc102': */
#define MSK_USED_BITS_NX90_mtgy_op_tc102 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc102_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC102_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc102_val; /* data bits 3295..3264 */
} NX90_MTGY_OP_TC102_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC102_BIT_T bf;
} NX90_MTGY_OP_TC102_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc103 */
/* => MWMM TC register 103 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc103  0x0000119CU
#define Adr_NX90_mtgy_mtgy_op_tc103 0xFF08319CU
#define Adr_NX90_mtgy_op_tc103      0xFF08319CU
#define DFLT_VAL_NX90_mtgy_op_tc103 0x00000000U

#define MSK_NX90_mtgy_op_tc103_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc103_val         0
#define DFLT_VAL_NX90_mtgy_op_tc103_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc103_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc103': */
#define MSK_USED_BITS_NX90_mtgy_op_tc103 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc103_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC103_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc103_val; /* data bits 3327..3296 */
} NX90_MTGY_OP_TC103_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC103_BIT_T bf;
} NX90_MTGY_OP_TC103_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc104 */
/* => MWMM TC register 104 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc104  0x000011A0U
#define Adr_NX90_mtgy_mtgy_op_tc104 0xFF0831A0U
#define Adr_NX90_mtgy_op_tc104      0xFF0831A0U
#define DFLT_VAL_NX90_mtgy_op_tc104 0x00000000U

#define MSK_NX90_mtgy_op_tc104_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc104_val         0
#define DFLT_VAL_NX90_mtgy_op_tc104_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc104_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc104': */
#define MSK_USED_BITS_NX90_mtgy_op_tc104 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc104_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC104_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc104_val; /* data bits 3359..3328 */
} NX90_MTGY_OP_TC104_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC104_BIT_T bf;
} NX90_MTGY_OP_TC104_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc105 */
/* => MWMM TC register 105 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc105  0x000011A4U
#define Adr_NX90_mtgy_mtgy_op_tc105 0xFF0831A4U
#define Adr_NX90_mtgy_op_tc105      0xFF0831A4U
#define DFLT_VAL_NX90_mtgy_op_tc105 0x00000000U

#define MSK_NX90_mtgy_op_tc105_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc105_val         0
#define DFLT_VAL_NX90_mtgy_op_tc105_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc105_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc105': */
#define MSK_USED_BITS_NX90_mtgy_op_tc105 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc105_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC105_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc105_val; /* data bits 3391..3360 */
} NX90_MTGY_OP_TC105_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC105_BIT_T bf;
} NX90_MTGY_OP_TC105_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc106 */
/* => MWMM TC register 106 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc106  0x000011A8U
#define Adr_NX90_mtgy_mtgy_op_tc106 0xFF0831A8U
#define Adr_NX90_mtgy_op_tc106      0xFF0831A8U
#define DFLT_VAL_NX90_mtgy_op_tc106 0x00000000U

#define MSK_NX90_mtgy_op_tc106_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc106_val         0
#define DFLT_VAL_NX90_mtgy_op_tc106_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc106_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc106': */
#define MSK_USED_BITS_NX90_mtgy_op_tc106 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc106_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC106_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc106_val; /* data bits 3423..3392 */
} NX90_MTGY_OP_TC106_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC106_BIT_T bf;
} NX90_MTGY_OP_TC106_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc107 */
/* => MWMM TC register 107 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc107  0x000011ACU
#define Adr_NX90_mtgy_mtgy_op_tc107 0xFF0831ACU
#define Adr_NX90_mtgy_op_tc107      0xFF0831ACU
#define DFLT_VAL_NX90_mtgy_op_tc107 0x00000000U

#define MSK_NX90_mtgy_op_tc107_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc107_val         0
#define DFLT_VAL_NX90_mtgy_op_tc107_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc107_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc107': */
#define MSK_USED_BITS_NX90_mtgy_op_tc107 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc107_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC107_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc107_val; /* data bits 3455..3424 */
} NX90_MTGY_OP_TC107_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC107_BIT_T bf;
} NX90_MTGY_OP_TC107_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc108 */
/* => MWMM TC register 108 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc108  0x000011B0U
#define Adr_NX90_mtgy_mtgy_op_tc108 0xFF0831B0U
#define Adr_NX90_mtgy_op_tc108      0xFF0831B0U
#define DFLT_VAL_NX90_mtgy_op_tc108 0x00000000U

#define MSK_NX90_mtgy_op_tc108_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc108_val         0
#define DFLT_VAL_NX90_mtgy_op_tc108_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc108_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc108': */
#define MSK_USED_BITS_NX90_mtgy_op_tc108 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc108_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC108_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc108_val; /* data bits 3487..3456 */
} NX90_MTGY_OP_TC108_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC108_BIT_T bf;
} NX90_MTGY_OP_TC108_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc109 */
/* => MWMM TC register 109 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc109  0x000011B4U
#define Adr_NX90_mtgy_mtgy_op_tc109 0xFF0831B4U
#define Adr_NX90_mtgy_op_tc109      0xFF0831B4U
#define DFLT_VAL_NX90_mtgy_op_tc109 0x00000000U

#define MSK_NX90_mtgy_op_tc109_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc109_val         0
#define DFLT_VAL_NX90_mtgy_op_tc109_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc109_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc109': */
#define MSK_USED_BITS_NX90_mtgy_op_tc109 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc109_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC109_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc109_val; /* data bits 3519..3488 */
} NX90_MTGY_OP_TC109_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC109_BIT_T bf;
} NX90_MTGY_OP_TC109_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc110 */
/* => MWMM TC register 110 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc110  0x000011B8U
#define Adr_NX90_mtgy_mtgy_op_tc110 0xFF0831B8U
#define Adr_NX90_mtgy_op_tc110      0xFF0831B8U
#define DFLT_VAL_NX90_mtgy_op_tc110 0x00000000U

#define MSK_NX90_mtgy_op_tc110_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc110_val         0
#define DFLT_VAL_NX90_mtgy_op_tc110_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc110_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc110': */
#define MSK_USED_BITS_NX90_mtgy_op_tc110 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc110_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC110_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc110_val; /* data bits 3551..3520 */
} NX90_MTGY_OP_TC110_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC110_BIT_T bf;
} NX90_MTGY_OP_TC110_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc111 */
/* => MWMM TC register 111 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc111  0x000011BCU
#define Adr_NX90_mtgy_mtgy_op_tc111 0xFF0831BCU
#define Adr_NX90_mtgy_op_tc111      0xFF0831BCU
#define DFLT_VAL_NX90_mtgy_op_tc111 0x00000000U

#define MSK_NX90_mtgy_op_tc111_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc111_val         0
#define DFLT_VAL_NX90_mtgy_op_tc111_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc111_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc111': */
#define MSK_USED_BITS_NX90_mtgy_op_tc111 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc111_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC111_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc111_val; /* data bits 3583..3552 */
} NX90_MTGY_OP_TC111_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC111_BIT_T bf;
} NX90_MTGY_OP_TC111_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc112 */
/* => MWMM TC register 112 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc112  0x000011C0U
#define Adr_NX90_mtgy_mtgy_op_tc112 0xFF0831C0U
#define Adr_NX90_mtgy_op_tc112      0xFF0831C0U
#define DFLT_VAL_NX90_mtgy_op_tc112 0x00000000U

#define MSK_NX90_mtgy_op_tc112_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc112_val         0
#define DFLT_VAL_NX90_mtgy_op_tc112_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc112_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc112': */
#define MSK_USED_BITS_NX90_mtgy_op_tc112 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc112_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC112_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc112_val; /* data bits 3615..3584 */
} NX90_MTGY_OP_TC112_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC112_BIT_T bf;
} NX90_MTGY_OP_TC112_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc113 */
/* => MWMM TC register 113 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc113  0x000011C4U
#define Adr_NX90_mtgy_mtgy_op_tc113 0xFF0831C4U
#define Adr_NX90_mtgy_op_tc113      0xFF0831C4U
#define DFLT_VAL_NX90_mtgy_op_tc113 0x00000000U

#define MSK_NX90_mtgy_op_tc113_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc113_val         0
#define DFLT_VAL_NX90_mtgy_op_tc113_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc113_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc113': */
#define MSK_USED_BITS_NX90_mtgy_op_tc113 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc113_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC113_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc113_val; /* data bits 3647..3616 */
} NX90_MTGY_OP_TC113_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC113_BIT_T bf;
} NX90_MTGY_OP_TC113_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc114 */
/* => MWMM TC register 114 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc114  0x000011C8U
#define Adr_NX90_mtgy_mtgy_op_tc114 0xFF0831C8U
#define Adr_NX90_mtgy_op_tc114      0xFF0831C8U
#define DFLT_VAL_NX90_mtgy_op_tc114 0x00000000U

#define MSK_NX90_mtgy_op_tc114_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc114_val         0
#define DFLT_VAL_NX90_mtgy_op_tc114_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc114_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc114': */
#define MSK_USED_BITS_NX90_mtgy_op_tc114 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc114_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC114_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc114_val; /* data bits 3679..3648 */
} NX90_MTGY_OP_TC114_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC114_BIT_T bf;
} NX90_MTGY_OP_TC114_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc115 */
/* => MWMM TC register 115 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc115  0x000011CCU
#define Adr_NX90_mtgy_mtgy_op_tc115 0xFF0831CCU
#define Adr_NX90_mtgy_op_tc115      0xFF0831CCU
#define DFLT_VAL_NX90_mtgy_op_tc115 0x00000000U

#define MSK_NX90_mtgy_op_tc115_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc115_val         0
#define DFLT_VAL_NX90_mtgy_op_tc115_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc115_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc115': */
#define MSK_USED_BITS_NX90_mtgy_op_tc115 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc115_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC115_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc115_val; /* data bits 3711..3680 */
} NX90_MTGY_OP_TC115_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC115_BIT_T bf;
} NX90_MTGY_OP_TC115_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc116 */
/* => MWMM TC register 116 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc116  0x000011D0U
#define Adr_NX90_mtgy_mtgy_op_tc116 0xFF0831D0U
#define Adr_NX90_mtgy_op_tc116      0xFF0831D0U
#define DFLT_VAL_NX90_mtgy_op_tc116 0x00000000U

#define MSK_NX90_mtgy_op_tc116_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc116_val         0
#define DFLT_VAL_NX90_mtgy_op_tc116_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc116_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc116': */
#define MSK_USED_BITS_NX90_mtgy_op_tc116 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc116_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC116_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc116_val; /* data bits 3743..3712 */
} NX90_MTGY_OP_TC116_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC116_BIT_T bf;
} NX90_MTGY_OP_TC116_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc117 */
/* => MWMM TC register 117 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc117  0x000011D4U
#define Adr_NX90_mtgy_mtgy_op_tc117 0xFF0831D4U
#define Adr_NX90_mtgy_op_tc117      0xFF0831D4U
#define DFLT_VAL_NX90_mtgy_op_tc117 0x00000000U

#define MSK_NX90_mtgy_op_tc117_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc117_val         0
#define DFLT_VAL_NX90_mtgy_op_tc117_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc117_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc117': */
#define MSK_USED_BITS_NX90_mtgy_op_tc117 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc117_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC117_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc117_val; /* data bits 3775..3744 */
} NX90_MTGY_OP_TC117_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC117_BIT_T bf;
} NX90_MTGY_OP_TC117_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc118 */
/* => MWMM TC register 118 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc118  0x000011D8U
#define Adr_NX90_mtgy_mtgy_op_tc118 0xFF0831D8U
#define Adr_NX90_mtgy_op_tc118      0xFF0831D8U
#define DFLT_VAL_NX90_mtgy_op_tc118 0x00000000U

#define MSK_NX90_mtgy_op_tc118_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc118_val         0
#define DFLT_VAL_NX90_mtgy_op_tc118_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc118_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc118': */
#define MSK_USED_BITS_NX90_mtgy_op_tc118 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc118_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC118_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc118_val; /* data bits 3807..3776 */
} NX90_MTGY_OP_TC118_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC118_BIT_T bf;
} NX90_MTGY_OP_TC118_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc119 */
/* => MWMM TC register 119 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc119  0x000011DCU
#define Adr_NX90_mtgy_mtgy_op_tc119 0xFF0831DCU
#define Adr_NX90_mtgy_op_tc119      0xFF0831DCU
#define DFLT_VAL_NX90_mtgy_op_tc119 0x00000000U

#define MSK_NX90_mtgy_op_tc119_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc119_val         0
#define DFLT_VAL_NX90_mtgy_op_tc119_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc119_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc119': */
#define MSK_USED_BITS_NX90_mtgy_op_tc119 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc119_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC119_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc119_val; /* data bits 3839..3808 */
} NX90_MTGY_OP_TC119_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC119_BIT_T bf;
} NX90_MTGY_OP_TC119_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc120 */
/* => MWMM TC register 120 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc120  0x000011E0U
#define Adr_NX90_mtgy_mtgy_op_tc120 0xFF0831E0U
#define Adr_NX90_mtgy_op_tc120      0xFF0831E0U
#define DFLT_VAL_NX90_mtgy_op_tc120 0x00000000U

#define MSK_NX90_mtgy_op_tc120_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc120_val         0
#define DFLT_VAL_NX90_mtgy_op_tc120_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc120_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc120': */
#define MSK_USED_BITS_NX90_mtgy_op_tc120 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc120_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC120_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc120_val; /* data bits 3871..3840 */
} NX90_MTGY_OP_TC120_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC120_BIT_T bf;
} NX90_MTGY_OP_TC120_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc121 */
/* => MWMM TC register 121 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc121  0x000011E4U
#define Adr_NX90_mtgy_mtgy_op_tc121 0xFF0831E4U
#define Adr_NX90_mtgy_op_tc121      0xFF0831E4U
#define DFLT_VAL_NX90_mtgy_op_tc121 0x00000000U

#define MSK_NX90_mtgy_op_tc121_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc121_val         0
#define DFLT_VAL_NX90_mtgy_op_tc121_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc121_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc121': */
#define MSK_USED_BITS_NX90_mtgy_op_tc121 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc121_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC121_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc121_val; /* data bits 3903..3872 */
} NX90_MTGY_OP_TC121_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC121_BIT_T bf;
} NX90_MTGY_OP_TC121_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc122 */
/* => MWMM TC register 122 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc122  0x000011E8U
#define Adr_NX90_mtgy_mtgy_op_tc122 0xFF0831E8U
#define Adr_NX90_mtgy_op_tc122      0xFF0831E8U
#define DFLT_VAL_NX90_mtgy_op_tc122 0x00000000U

#define MSK_NX90_mtgy_op_tc122_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc122_val         0
#define DFLT_VAL_NX90_mtgy_op_tc122_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc122_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc122': */
#define MSK_USED_BITS_NX90_mtgy_op_tc122 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc122_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC122_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc122_val; /* data bits 3935..3904 */
} NX90_MTGY_OP_TC122_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC122_BIT_T bf;
} NX90_MTGY_OP_TC122_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc123 */
/* => MWMM TC register 123 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc123  0x000011ECU
#define Adr_NX90_mtgy_mtgy_op_tc123 0xFF0831ECU
#define Adr_NX90_mtgy_op_tc123      0xFF0831ECU
#define DFLT_VAL_NX90_mtgy_op_tc123 0x00000000U

#define MSK_NX90_mtgy_op_tc123_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc123_val         0
#define DFLT_VAL_NX90_mtgy_op_tc123_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc123_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc123': */
#define MSK_USED_BITS_NX90_mtgy_op_tc123 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc123_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC123_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc123_val; /* data bits 3967..3936 */
} NX90_MTGY_OP_TC123_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC123_BIT_T bf;
} NX90_MTGY_OP_TC123_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc124 */
/* => MWMM TC register 124 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc124  0x000011F0U
#define Adr_NX90_mtgy_mtgy_op_tc124 0xFF0831F0U
#define Adr_NX90_mtgy_op_tc124      0xFF0831F0U
#define DFLT_VAL_NX90_mtgy_op_tc124 0x00000000U

#define MSK_NX90_mtgy_op_tc124_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc124_val         0
#define DFLT_VAL_NX90_mtgy_op_tc124_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc124_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc124': */
#define MSK_USED_BITS_NX90_mtgy_op_tc124 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc124_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC124_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc124_val; /* data bits 3999..3968 */
} NX90_MTGY_OP_TC124_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC124_BIT_T bf;
} NX90_MTGY_OP_TC124_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc125 */
/* => MWMM TC register 125 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc125  0x000011F4U
#define Adr_NX90_mtgy_mtgy_op_tc125 0xFF0831F4U
#define Adr_NX90_mtgy_op_tc125      0xFF0831F4U
#define DFLT_VAL_NX90_mtgy_op_tc125 0x00000000U

#define MSK_NX90_mtgy_op_tc125_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc125_val         0
#define DFLT_VAL_NX90_mtgy_op_tc125_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc125_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc125': */
#define MSK_USED_BITS_NX90_mtgy_op_tc125 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc125_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC125_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc125_val; /* data bits 4031..4000 */
} NX90_MTGY_OP_TC125_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC125_BIT_T bf;
} NX90_MTGY_OP_TC125_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc126 */
/* => MWMM TC register 126 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc126  0x000011F8U
#define Adr_NX90_mtgy_mtgy_op_tc126 0xFF0831F8U
#define Adr_NX90_mtgy_op_tc126      0xFF0831F8U
#define DFLT_VAL_NX90_mtgy_op_tc126 0x00000000U

#define MSK_NX90_mtgy_op_tc126_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc126_val         0
#define DFLT_VAL_NX90_mtgy_op_tc126_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc126_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc126': */
#define MSK_USED_BITS_NX90_mtgy_op_tc126 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc126_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC126_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc126_val; /* data bits 4063..4032 */
} NX90_MTGY_OP_TC126_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC126_BIT_T bf;
} NX90_MTGY_OP_TC126_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_tc127 */
/* => MWMM TC register 127 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_tc127  0x000011FCU
#define Adr_NX90_mtgy_mtgy_op_tc127 0xFF0831FCU
#define Adr_NX90_mtgy_op_tc127      0xFF0831FCU
#define DFLT_VAL_NX90_mtgy_op_tc127 0x00000000U

#define MSK_NX90_mtgy_op_tc127_val         0xffffffffU
#define SRT_NX90_mtgy_op_tc127_val         0
#define DFLT_VAL_NX90_mtgy_op_tc127_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_tc127_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_tc127': */
#define MSK_USED_BITS_NX90_mtgy_op_tc127 0xffffffffU

enum {
  BFW_NX90_mtgy_op_tc127_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TC127_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_tc127_val; /* data bits 4095..4064 */
} NX90_MTGY_OP_TC127_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TC127_BIT_T bf;
} NX90_MTGY_OP_TC127_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts0 */
/* => MWMM TS register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts0  0x00001200U
#define Adr_NX90_mtgy_mtgy_op_ts0 0xFF083200U
#define Adr_NX90_mtgy_op_ts0      0xFF083200U
#define DFLT_VAL_NX90_mtgy_op_ts0 0x00000000U

#define MSK_NX90_mtgy_op_ts0_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts0_val         0
#define DFLT_VAL_NX90_mtgy_op_ts0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts0_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts0': */
#define MSK_USED_BITS_NX90_mtgy_op_ts0 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts0_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS0_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts0_val; /* data bits 31..0 */
} NX90_MTGY_OP_TS0_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS0_BIT_T bf;
} NX90_MTGY_OP_TS0_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts1 */
/* => MWMM TS register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts1  0x00001204U
#define Adr_NX90_mtgy_mtgy_op_ts1 0xFF083204U
#define Adr_NX90_mtgy_op_ts1      0xFF083204U
#define DFLT_VAL_NX90_mtgy_op_ts1 0x00000000U

#define MSK_NX90_mtgy_op_ts1_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts1_val         0
#define DFLT_VAL_NX90_mtgy_op_ts1_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts1_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts1': */
#define MSK_USED_BITS_NX90_mtgy_op_ts1 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts1_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS1_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts1_val; /* data bits 63..32 */
} NX90_MTGY_OP_TS1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS1_BIT_T bf;
} NX90_MTGY_OP_TS1_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts2 */
/* => MWMM TS register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts2  0x00001208U
#define Adr_NX90_mtgy_mtgy_op_ts2 0xFF083208U
#define Adr_NX90_mtgy_op_ts2      0xFF083208U
#define DFLT_VAL_NX90_mtgy_op_ts2 0x00000000U

#define MSK_NX90_mtgy_op_ts2_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts2_val         0
#define DFLT_VAL_NX90_mtgy_op_ts2_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts2_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts2': */
#define MSK_USED_BITS_NX90_mtgy_op_ts2 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts2_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS2_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts2_val; /* data bits 95..64 */
} NX90_MTGY_OP_TS2_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS2_BIT_T bf;
} NX90_MTGY_OP_TS2_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts3 */
/* => MWMM TS register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts3  0x0000120CU
#define Adr_NX90_mtgy_mtgy_op_ts3 0xFF08320CU
#define Adr_NX90_mtgy_op_ts3      0xFF08320CU
#define DFLT_VAL_NX90_mtgy_op_ts3 0x00000000U

#define MSK_NX90_mtgy_op_ts3_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts3_val         0
#define DFLT_VAL_NX90_mtgy_op_ts3_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts3_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts3': */
#define MSK_USED_BITS_NX90_mtgy_op_ts3 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts3_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS3_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts3_val; /* data bits 127..96 */
} NX90_MTGY_OP_TS3_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS3_BIT_T bf;
} NX90_MTGY_OP_TS3_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts4 */
/* => MWMM TS register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts4  0x00001210U
#define Adr_NX90_mtgy_mtgy_op_ts4 0xFF083210U
#define Adr_NX90_mtgy_op_ts4      0xFF083210U
#define DFLT_VAL_NX90_mtgy_op_ts4 0x00000000U

#define MSK_NX90_mtgy_op_ts4_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts4_val         0
#define DFLT_VAL_NX90_mtgy_op_ts4_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts4_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts4': */
#define MSK_USED_BITS_NX90_mtgy_op_ts4 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts4_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS4_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts4_val; /* data bits 159..128 */
} NX90_MTGY_OP_TS4_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS4_BIT_T bf;
} NX90_MTGY_OP_TS4_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts5 */
/* => MWMM TS register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts5  0x00001214U
#define Adr_NX90_mtgy_mtgy_op_ts5 0xFF083214U
#define Adr_NX90_mtgy_op_ts5      0xFF083214U
#define DFLT_VAL_NX90_mtgy_op_ts5 0x00000000U

#define MSK_NX90_mtgy_op_ts5_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts5_val         0
#define DFLT_VAL_NX90_mtgy_op_ts5_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts5_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts5': */
#define MSK_USED_BITS_NX90_mtgy_op_ts5 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts5_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS5_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts5_val; /* data bits 191..160 */
} NX90_MTGY_OP_TS5_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS5_BIT_T bf;
} NX90_MTGY_OP_TS5_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts6 */
/* => MWMM TS register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts6  0x00001218U
#define Adr_NX90_mtgy_mtgy_op_ts6 0xFF083218U
#define Adr_NX90_mtgy_op_ts6      0xFF083218U
#define DFLT_VAL_NX90_mtgy_op_ts6 0x00000000U

#define MSK_NX90_mtgy_op_ts6_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts6_val         0
#define DFLT_VAL_NX90_mtgy_op_ts6_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts6_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts6': */
#define MSK_USED_BITS_NX90_mtgy_op_ts6 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts6_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS6_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts6_val; /* data bits 223..192 */
} NX90_MTGY_OP_TS6_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS6_BIT_T bf;
} NX90_MTGY_OP_TS6_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts7 */
/* => MWMM TS register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts7  0x0000121CU
#define Adr_NX90_mtgy_mtgy_op_ts7 0xFF08321CU
#define Adr_NX90_mtgy_op_ts7      0xFF08321CU
#define DFLT_VAL_NX90_mtgy_op_ts7 0x00000000U

#define MSK_NX90_mtgy_op_ts7_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts7_val         0
#define DFLT_VAL_NX90_mtgy_op_ts7_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts7_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts7': */
#define MSK_USED_BITS_NX90_mtgy_op_ts7 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts7_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS7_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts7_val; /* data bits 255..224 */
} NX90_MTGY_OP_TS7_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS7_BIT_T bf;
} NX90_MTGY_OP_TS7_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts8 */
/* => MWMM TS register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts8  0x00001220U
#define Adr_NX90_mtgy_mtgy_op_ts8 0xFF083220U
#define Adr_NX90_mtgy_op_ts8      0xFF083220U
#define DFLT_VAL_NX90_mtgy_op_ts8 0x00000000U

#define MSK_NX90_mtgy_op_ts8_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts8_val         0
#define DFLT_VAL_NX90_mtgy_op_ts8_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts8_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts8': */
#define MSK_USED_BITS_NX90_mtgy_op_ts8 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts8_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS8_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts8_val; /* data bits 287..256 */
} NX90_MTGY_OP_TS8_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS8_BIT_T bf;
} NX90_MTGY_OP_TS8_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts9 */
/* => MWMM TS register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts9  0x00001224U
#define Adr_NX90_mtgy_mtgy_op_ts9 0xFF083224U
#define Adr_NX90_mtgy_op_ts9      0xFF083224U
#define DFLT_VAL_NX90_mtgy_op_ts9 0x00000000U

#define MSK_NX90_mtgy_op_ts9_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts9_val         0
#define DFLT_VAL_NX90_mtgy_op_ts9_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts9_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts9': */
#define MSK_USED_BITS_NX90_mtgy_op_ts9 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts9_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS9_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts9_val; /* data bits 319..288 */
} NX90_MTGY_OP_TS9_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_TS9_BIT_T bf;
} NX90_MTGY_OP_TS9_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts10 */
/* => MWMM TS register 10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts10  0x00001228U
#define Adr_NX90_mtgy_mtgy_op_ts10 0xFF083228U
#define Adr_NX90_mtgy_op_ts10      0xFF083228U
#define DFLT_VAL_NX90_mtgy_op_ts10 0x00000000U

#define MSK_NX90_mtgy_op_ts10_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts10_val         0
#define DFLT_VAL_NX90_mtgy_op_ts10_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts10_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts10': */
#define MSK_USED_BITS_NX90_mtgy_op_ts10 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts10_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS10_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts10_val; /* data bits 351..320 */
} NX90_MTGY_OP_TS10_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS10_BIT_T bf;
} NX90_MTGY_OP_TS10_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts11 */
/* => MWMM TS register 11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts11  0x0000122CU
#define Adr_NX90_mtgy_mtgy_op_ts11 0xFF08322CU
#define Adr_NX90_mtgy_op_ts11      0xFF08322CU
#define DFLT_VAL_NX90_mtgy_op_ts11 0x00000000U

#define MSK_NX90_mtgy_op_ts11_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts11_val         0
#define DFLT_VAL_NX90_mtgy_op_ts11_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts11_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts11': */
#define MSK_USED_BITS_NX90_mtgy_op_ts11 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts11_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS11_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts11_val; /* data bits 383..352 */
} NX90_MTGY_OP_TS11_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS11_BIT_T bf;
} NX90_MTGY_OP_TS11_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts12 */
/* => MWMM TS register 12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts12  0x00001230U
#define Adr_NX90_mtgy_mtgy_op_ts12 0xFF083230U
#define Adr_NX90_mtgy_op_ts12      0xFF083230U
#define DFLT_VAL_NX90_mtgy_op_ts12 0x00000000U

#define MSK_NX90_mtgy_op_ts12_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts12_val         0
#define DFLT_VAL_NX90_mtgy_op_ts12_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts12_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts12': */
#define MSK_USED_BITS_NX90_mtgy_op_ts12 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts12_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS12_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts12_val; /* data bits 415..384 */
} NX90_MTGY_OP_TS12_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS12_BIT_T bf;
} NX90_MTGY_OP_TS12_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts13 */
/* => MWMM TS register 13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts13  0x00001234U
#define Adr_NX90_mtgy_mtgy_op_ts13 0xFF083234U
#define Adr_NX90_mtgy_op_ts13      0xFF083234U
#define DFLT_VAL_NX90_mtgy_op_ts13 0x00000000U

#define MSK_NX90_mtgy_op_ts13_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts13_val         0
#define DFLT_VAL_NX90_mtgy_op_ts13_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts13_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts13': */
#define MSK_USED_BITS_NX90_mtgy_op_ts13 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts13_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS13_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts13_val; /* data bits 447..416 */
} NX90_MTGY_OP_TS13_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS13_BIT_T bf;
} NX90_MTGY_OP_TS13_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts14 */
/* => MWMM TS register 14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts14  0x00001238U
#define Adr_NX90_mtgy_mtgy_op_ts14 0xFF083238U
#define Adr_NX90_mtgy_op_ts14      0xFF083238U
#define DFLT_VAL_NX90_mtgy_op_ts14 0x00000000U

#define MSK_NX90_mtgy_op_ts14_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts14_val         0
#define DFLT_VAL_NX90_mtgy_op_ts14_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts14_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts14': */
#define MSK_USED_BITS_NX90_mtgy_op_ts14 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts14_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS14_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts14_val; /* data bits 479..448 */
} NX90_MTGY_OP_TS14_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS14_BIT_T bf;
} NX90_MTGY_OP_TS14_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts15 */
/* => MWMM TS register 15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts15  0x0000123CU
#define Adr_NX90_mtgy_mtgy_op_ts15 0xFF08323CU
#define Adr_NX90_mtgy_op_ts15      0xFF08323CU
#define DFLT_VAL_NX90_mtgy_op_ts15 0x00000000U

#define MSK_NX90_mtgy_op_ts15_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts15_val         0
#define DFLT_VAL_NX90_mtgy_op_ts15_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts15_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts15': */
#define MSK_USED_BITS_NX90_mtgy_op_ts15 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts15_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS15_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts15_val; /* data bits 511..480 */
} NX90_MTGY_OP_TS15_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS15_BIT_T bf;
} NX90_MTGY_OP_TS15_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts16 */
/* => MWMM TS register 16 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts16  0x00001240U
#define Adr_NX90_mtgy_mtgy_op_ts16 0xFF083240U
#define Adr_NX90_mtgy_op_ts16      0xFF083240U
#define DFLT_VAL_NX90_mtgy_op_ts16 0x00000000U

#define MSK_NX90_mtgy_op_ts16_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts16_val         0
#define DFLT_VAL_NX90_mtgy_op_ts16_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts16_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts16': */
#define MSK_USED_BITS_NX90_mtgy_op_ts16 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts16_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS16_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts16_val; /* data bits 543..512 */
} NX90_MTGY_OP_TS16_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS16_BIT_T bf;
} NX90_MTGY_OP_TS16_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts17 */
/* => MWMM TS register 17 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts17  0x00001244U
#define Adr_NX90_mtgy_mtgy_op_ts17 0xFF083244U
#define Adr_NX90_mtgy_op_ts17      0xFF083244U
#define DFLT_VAL_NX90_mtgy_op_ts17 0x00000000U

#define MSK_NX90_mtgy_op_ts17_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts17_val         0
#define DFLT_VAL_NX90_mtgy_op_ts17_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts17_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts17': */
#define MSK_USED_BITS_NX90_mtgy_op_ts17 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts17_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS17_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts17_val; /* data bits 575..544 */
} NX90_MTGY_OP_TS17_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS17_BIT_T bf;
} NX90_MTGY_OP_TS17_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts18 */
/* => MWMM TS register 18 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts18  0x00001248U
#define Adr_NX90_mtgy_mtgy_op_ts18 0xFF083248U
#define Adr_NX90_mtgy_op_ts18      0xFF083248U
#define DFLT_VAL_NX90_mtgy_op_ts18 0x00000000U

#define MSK_NX90_mtgy_op_ts18_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts18_val         0
#define DFLT_VAL_NX90_mtgy_op_ts18_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts18_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts18': */
#define MSK_USED_BITS_NX90_mtgy_op_ts18 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts18_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS18_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts18_val; /* data bits 607..576 */
} NX90_MTGY_OP_TS18_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS18_BIT_T bf;
} NX90_MTGY_OP_TS18_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts19 */
/* => MWMM TS register 19 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts19  0x0000124CU
#define Adr_NX90_mtgy_mtgy_op_ts19 0xFF08324CU
#define Adr_NX90_mtgy_op_ts19      0xFF08324CU
#define DFLT_VAL_NX90_mtgy_op_ts19 0x00000000U

#define MSK_NX90_mtgy_op_ts19_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts19_val         0
#define DFLT_VAL_NX90_mtgy_op_ts19_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts19_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts19': */
#define MSK_USED_BITS_NX90_mtgy_op_ts19 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts19_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS19_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts19_val; /* data bits 639..608 */
} NX90_MTGY_OP_TS19_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS19_BIT_T bf;
} NX90_MTGY_OP_TS19_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts20 */
/* => MWMM TS register 20 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts20  0x00001250U
#define Adr_NX90_mtgy_mtgy_op_ts20 0xFF083250U
#define Adr_NX90_mtgy_op_ts20      0xFF083250U
#define DFLT_VAL_NX90_mtgy_op_ts20 0x00000000U

#define MSK_NX90_mtgy_op_ts20_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts20_val         0
#define DFLT_VAL_NX90_mtgy_op_ts20_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts20_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts20': */
#define MSK_USED_BITS_NX90_mtgy_op_ts20 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts20_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS20_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts20_val; /* data bits 671..640 */
} NX90_MTGY_OP_TS20_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS20_BIT_T bf;
} NX90_MTGY_OP_TS20_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts21 */
/* => MWMM TS register 21 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts21  0x00001254U
#define Adr_NX90_mtgy_mtgy_op_ts21 0xFF083254U
#define Adr_NX90_mtgy_op_ts21      0xFF083254U
#define DFLT_VAL_NX90_mtgy_op_ts21 0x00000000U

#define MSK_NX90_mtgy_op_ts21_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts21_val         0
#define DFLT_VAL_NX90_mtgy_op_ts21_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts21_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts21': */
#define MSK_USED_BITS_NX90_mtgy_op_ts21 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts21_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS21_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts21_val; /* data bits 703..672 */
} NX90_MTGY_OP_TS21_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS21_BIT_T bf;
} NX90_MTGY_OP_TS21_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts22 */
/* => MWMM TS register 22 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts22  0x00001258U
#define Adr_NX90_mtgy_mtgy_op_ts22 0xFF083258U
#define Adr_NX90_mtgy_op_ts22      0xFF083258U
#define DFLT_VAL_NX90_mtgy_op_ts22 0x00000000U

#define MSK_NX90_mtgy_op_ts22_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts22_val         0
#define DFLT_VAL_NX90_mtgy_op_ts22_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts22_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts22': */
#define MSK_USED_BITS_NX90_mtgy_op_ts22 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts22_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS22_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts22_val; /* data bits 735..704 */
} NX90_MTGY_OP_TS22_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS22_BIT_T bf;
} NX90_MTGY_OP_TS22_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts23 */
/* => MWMM TS register 23 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts23  0x0000125CU
#define Adr_NX90_mtgy_mtgy_op_ts23 0xFF08325CU
#define Adr_NX90_mtgy_op_ts23      0xFF08325CU
#define DFLT_VAL_NX90_mtgy_op_ts23 0x00000000U

#define MSK_NX90_mtgy_op_ts23_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts23_val         0
#define DFLT_VAL_NX90_mtgy_op_ts23_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts23_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts23': */
#define MSK_USED_BITS_NX90_mtgy_op_ts23 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts23_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS23_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts23_val; /* data bits 767..736 */
} NX90_MTGY_OP_TS23_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS23_BIT_T bf;
} NX90_MTGY_OP_TS23_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts24 */
/* => MWMM TS register 24 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts24  0x00001260U
#define Adr_NX90_mtgy_mtgy_op_ts24 0xFF083260U
#define Adr_NX90_mtgy_op_ts24      0xFF083260U
#define DFLT_VAL_NX90_mtgy_op_ts24 0x00000000U

#define MSK_NX90_mtgy_op_ts24_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts24_val         0
#define DFLT_VAL_NX90_mtgy_op_ts24_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts24_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts24': */
#define MSK_USED_BITS_NX90_mtgy_op_ts24 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts24_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS24_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts24_val; /* data bits 799..768 */
} NX90_MTGY_OP_TS24_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS24_BIT_T bf;
} NX90_MTGY_OP_TS24_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts25 */
/* => MWMM TS register 25 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts25  0x00001264U
#define Adr_NX90_mtgy_mtgy_op_ts25 0xFF083264U
#define Adr_NX90_mtgy_op_ts25      0xFF083264U
#define DFLT_VAL_NX90_mtgy_op_ts25 0x00000000U

#define MSK_NX90_mtgy_op_ts25_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts25_val         0
#define DFLT_VAL_NX90_mtgy_op_ts25_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts25_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts25': */
#define MSK_USED_BITS_NX90_mtgy_op_ts25 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts25_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS25_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts25_val; /* data bits 831..800 */
} NX90_MTGY_OP_TS25_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS25_BIT_T bf;
} NX90_MTGY_OP_TS25_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts26 */
/* => MWMM TS register 26 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts26  0x00001268U
#define Adr_NX90_mtgy_mtgy_op_ts26 0xFF083268U
#define Adr_NX90_mtgy_op_ts26      0xFF083268U
#define DFLT_VAL_NX90_mtgy_op_ts26 0x00000000U

#define MSK_NX90_mtgy_op_ts26_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts26_val         0
#define DFLT_VAL_NX90_mtgy_op_ts26_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts26_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts26': */
#define MSK_USED_BITS_NX90_mtgy_op_ts26 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts26_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS26_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts26_val; /* data bits 863..832 */
} NX90_MTGY_OP_TS26_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS26_BIT_T bf;
} NX90_MTGY_OP_TS26_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts27 */
/* => MWMM TS register 27 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts27  0x0000126CU
#define Adr_NX90_mtgy_mtgy_op_ts27 0xFF08326CU
#define Adr_NX90_mtgy_op_ts27      0xFF08326CU
#define DFLT_VAL_NX90_mtgy_op_ts27 0x00000000U

#define MSK_NX90_mtgy_op_ts27_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts27_val         0
#define DFLT_VAL_NX90_mtgy_op_ts27_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts27_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts27': */
#define MSK_USED_BITS_NX90_mtgy_op_ts27 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts27_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS27_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts27_val; /* data bits 895..864 */
} NX90_MTGY_OP_TS27_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS27_BIT_T bf;
} NX90_MTGY_OP_TS27_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts28 */
/* => MWMM TS register 28 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts28  0x00001270U
#define Adr_NX90_mtgy_mtgy_op_ts28 0xFF083270U
#define Adr_NX90_mtgy_op_ts28      0xFF083270U
#define DFLT_VAL_NX90_mtgy_op_ts28 0x00000000U

#define MSK_NX90_mtgy_op_ts28_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts28_val         0
#define DFLT_VAL_NX90_mtgy_op_ts28_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts28_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts28': */
#define MSK_USED_BITS_NX90_mtgy_op_ts28 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts28_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS28_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts28_val; /* data bits 927..896 */
} NX90_MTGY_OP_TS28_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS28_BIT_T bf;
} NX90_MTGY_OP_TS28_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts29 */
/* => MWMM TS register 29 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts29  0x00001274U
#define Adr_NX90_mtgy_mtgy_op_ts29 0xFF083274U
#define Adr_NX90_mtgy_op_ts29      0xFF083274U
#define DFLT_VAL_NX90_mtgy_op_ts29 0x00000000U

#define MSK_NX90_mtgy_op_ts29_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts29_val         0
#define DFLT_VAL_NX90_mtgy_op_ts29_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts29_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts29': */
#define MSK_USED_BITS_NX90_mtgy_op_ts29 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts29_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS29_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts29_val; /* data bits 959..928 */
} NX90_MTGY_OP_TS29_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS29_BIT_T bf;
} NX90_MTGY_OP_TS29_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts30 */
/* => MWMM TS register 30 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts30  0x00001278U
#define Adr_NX90_mtgy_mtgy_op_ts30 0xFF083278U
#define Adr_NX90_mtgy_op_ts30      0xFF083278U
#define DFLT_VAL_NX90_mtgy_op_ts30 0x00000000U

#define MSK_NX90_mtgy_op_ts30_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts30_val         0
#define DFLT_VAL_NX90_mtgy_op_ts30_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts30_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts30': */
#define MSK_USED_BITS_NX90_mtgy_op_ts30 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts30_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS30_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts30_val; /* data bits 991..960 */
} NX90_MTGY_OP_TS30_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS30_BIT_T bf;
} NX90_MTGY_OP_TS30_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts31 */
/* => MWMM TS register 31 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts31  0x0000127CU
#define Adr_NX90_mtgy_mtgy_op_ts31 0xFF08327CU
#define Adr_NX90_mtgy_op_ts31      0xFF08327CU
#define DFLT_VAL_NX90_mtgy_op_ts31 0x00000000U

#define MSK_NX90_mtgy_op_ts31_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts31_val         0
#define DFLT_VAL_NX90_mtgy_op_ts31_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts31_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts31': */
#define MSK_USED_BITS_NX90_mtgy_op_ts31 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts31_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS31_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts31_val; /* data bits 1023..992 */
} NX90_MTGY_OP_TS31_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS31_BIT_T bf;
} NX90_MTGY_OP_TS31_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts32 */
/* => MWMM TS register 32 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts32  0x00001280U
#define Adr_NX90_mtgy_mtgy_op_ts32 0xFF083280U
#define Adr_NX90_mtgy_op_ts32      0xFF083280U
#define DFLT_VAL_NX90_mtgy_op_ts32 0x00000000U

#define MSK_NX90_mtgy_op_ts32_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts32_val         0
#define DFLT_VAL_NX90_mtgy_op_ts32_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts32_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts32': */
#define MSK_USED_BITS_NX90_mtgy_op_ts32 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts32_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS32_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts32_val; /* data bits 1055..1024 */
} NX90_MTGY_OP_TS32_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS32_BIT_T bf;
} NX90_MTGY_OP_TS32_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts33 */
/* => MWMM TS register 33 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts33  0x00001284U
#define Adr_NX90_mtgy_mtgy_op_ts33 0xFF083284U
#define Adr_NX90_mtgy_op_ts33      0xFF083284U
#define DFLT_VAL_NX90_mtgy_op_ts33 0x00000000U

#define MSK_NX90_mtgy_op_ts33_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts33_val         0
#define DFLT_VAL_NX90_mtgy_op_ts33_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts33_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts33': */
#define MSK_USED_BITS_NX90_mtgy_op_ts33 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts33_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS33_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts33_val; /* data bits 1087..1056 */
} NX90_MTGY_OP_TS33_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS33_BIT_T bf;
} NX90_MTGY_OP_TS33_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts34 */
/* => MWMM TS register 34 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts34  0x00001288U
#define Adr_NX90_mtgy_mtgy_op_ts34 0xFF083288U
#define Adr_NX90_mtgy_op_ts34      0xFF083288U
#define DFLT_VAL_NX90_mtgy_op_ts34 0x00000000U

#define MSK_NX90_mtgy_op_ts34_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts34_val         0
#define DFLT_VAL_NX90_mtgy_op_ts34_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts34_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts34': */
#define MSK_USED_BITS_NX90_mtgy_op_ts34 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts34_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS34_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts34_val; /* data bits 1119..1088 */
} NX90_MTGY_OP_TS34_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS34_BIT_T bf;
} NX90_MTGY_OP_TS34_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts35 */
/* => MWMM TS register 35 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts35  0x0000128CU
#define Adr_NX90_mtgy_mtgy_op_ts35 0xFF08328CU
#define Adr_NX90_mtgy_op_ts35      0xFF08328CU
#define DFLT_VAL_NX90_mtgy_op_ts35 0x00000000U

#define MSK_NX90_mtgy_op_ts35_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts35_val         0
#define DFLT_VAL_NX90_mtgy_op_ts35_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts35_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts35': */
#define MSK_USED_BITS_NX90_mtgy_op_ts35 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts35_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS35_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts35_val; /* data bits 1151..1120 */
} NX90_MTGY_OP_TS35_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS35_BIT_T bf;
} NX90_MTGY_OP_TS35_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts36 */
/* => MWMM TS register 36 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts36  0x00001290U
#define Adr_NX90_mtgy_mtgy_op_ts36 0xFF083290U
#define Adr_NX90_mtgy_op_ts36      0xFF083290U
#define DFLT_VAL_NX90_mtgy_op_ts36 0x00000000U

#define MSK_NX90_mtgy_op_ts36_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts36_val         0
#define DFLT_VAL_NX90_mtgy_op_ts36_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts36_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts36': */
#define MSK_USED_BITS_NX90_mtgy_op_ts36 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts36_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS36_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts36_val; /* data bits 1183..1152 */
} NX90_MTGY_OP_TS36_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS36_BIT_T bf;
} NX90_MTGY_OP_TS36_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts37 */
/* => MWMM TS register 37 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts37  0x00001294U
#define Adr_NX90_mtgy_mtgy_op_ts37 0xFF083294U
#define Adr_NX90_mtgy_op_ts37      0xFF083294U
#define DFLT_VAL_NX90_mtgy_op_ts37 0x00000000U

#define MSK_NX90_mtgy_op_ts37_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts37_val         0
#define DFLT_VAL_NX90_mtgy_op_ts37_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts37_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts37': */
#define MSK_USED_BITS_NX90_mtgy_op_ts37 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts37_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS37_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts37_val; /* data bits 1215..1184 */
} NX90_MTGY_OP_TS37_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS37_BIT_T bf;
} NX90_MTGY_OP_TS37_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts38 */
/* => MWMM TS register 38 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts38  0x00001298U
#define Adr_NX90_mtgy_mtgy_op_ts38 0xFF083298U
#define Adr_NX90_mtgy_op_ts38      0xFF083298U
#define DFLT_VAL_NX90_mtgy_op_ts38 0x00000000U

#define MSK_NX90_mtgy_op_ts38_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts38_val         0
#define DFLT_VAL_NX90_mtgy_op_ts38_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts38_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts38': */
#define MSK_USED_BITS_NX90_mtgy_op_ts38 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts38_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS38_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts38_val; /* data bits 1247..1216 */
} NX90_MTGY_OP_TS38_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS38_BIT_T bf;
} NX90_MTGY_OP_TS38_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts39 */
/* => MWMM TS register 39 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts39  0x0000129CU
#define Adr_NX90_mtgy_mtgy_op_ts39 0xFF08329CU
#define Adr_NX90_mtgy_op_ts39      0xFF08329CU
#define DFLT_VAL_NX90_mtgy_op_ts39 0x00000000U

#define MSK_NX90_mtgy_op_ts39_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts39_val         0
#define DFLT_VAL_NX90_mtgy_op_ts39_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts39_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts39': */
#define MSK_USED_BITS_NX90_mtgy_op_ts39 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts39_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS39_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts39_val; /* data bits 1279..1248 */
} NX90_MTGY_OP_TS39_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS39_BIT_T bf;
} NX90_MTGY_OP_TS39_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts40 */
/* => MWMM TS register 40 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts40  0x000012A0U
#define Adr_NX90_mtgy_mtgy_op_ts40 0xFF0832A0U
#define Adr_NX90_mtgy_op_ts40      0xFF0832A0U
#define DFLT_VAL_NX90_mtgy_op_ts40 0x00000000U

#define MSK_NX90_mtgy_op_ts40_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts40_val         0
#define DFLT_VAL_NX90_mtgy_op_ts40_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts40_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts40': */
#define MSK_USED_BITS_NX90_mtgy_op_ts40 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts40_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS40_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts40_val; /* data bits 1311..1280 */
} NX90_MTGY_OP_TS40_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS40_BIT_T bf;
} NX90_MTGY_OP_TS40_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts41 */
/* => MWMM TS register 41 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts41  0x000012A4U
#define Adr_NX90_mtgy_mtgy_op_ts41 0xFF0832A4U
#define Adr_NX90_mtgy_op_ts41      0xFF0832A4U
#define DFLT_VAL_NX90_mtgy_op_ts41 0x00000000U

#define MSK_NX90_mtgy_op_ts41_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts41_val         0
#define DFLT_VAL_NX90_mtgy_op_ts41_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts41_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts41': */
#define MSK_USED_BITS_NX90_mtgy_op_ts41 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts41_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS41_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts41_val; /* data bits 1343..1312 */
} NX90_MTGY_OP_TS41_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS41_BIT_T bf;
} NX90_MTGY_OP_TS41_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts42 */
/* => MWMM TS register 42 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts42  0x000012A8U
#define Adr_NX90_mtgy_mtgy_op_ts42 0xFF0832A8U
#define Adr_NX90_mtgy_op_ts42      0xFF0832A8U
#define DFLT_VAL_NX90_mtgy_op_ts42 0x00000000U

#define MSK_NX90_mtgy_op_ts42_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts42_val         0
#define DFLT_VAL_NX90_mtgy_op_ts42_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts42_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts42': */
#define MSK_USED_BITS_NX90_mtgy_op_ts42 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts42_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS42_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts42_val; /* data bits 1375..1344 */
} NX90_MTGY_OP_TS42_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS42_BIT_T bf;
} NX90_MTGY_OP_TS42_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts43 */
/* => MWMM TS register 43 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts43  0x000012ACU
#define Adr_NX90_mtgy_mtgy_op_ts43 0xFF0832ACU
#define Adr_NX90_mtgy_op_ts43      0xFF0832ACU
#define DFLT_VAL_NX90_mtgy_op_ts43 0x00000000U

#define MSK_NX90_mtgy_op_ts43_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts43_val         0
#define DFLT_VAL_NX90_mtgy_op_ts43_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts43_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts43': */
#define MSK_USED_BITS_NX90_mtgy_op_ts43 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts43_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS43_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts43_val; /* data bits 1407..1376 */
} NX90_MTGY_OP_TS43_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS43_BIT_T bf;
} NX90_MTGY_OP_TS43_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts44 */
/* => MWMM TS register 44 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts44  0x000012B0U
#define Adr_NX90_mtgy_mtgy_op_ts44 0xFF0832B0U
#define Adr_NX90_mtgy_op_ts44      0xFF0832B0U
#define DFLT_VAL_NX90_mtgy_op_ts44 0x00000000U

#define MSK_NX90_mtgy_op_ts44_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts44_val         0
#define DFLT_VAL_NX90_mtgy_op_ts44_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts44_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts44': */
#define MSK_USED_BITS_NX90_mtgy_op_ts44 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts44_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS44_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts44_val; /* data bits 1439..1408 */
} NX90_MTGY_OP_TS44_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS44_BIT_T bf;
} NX90_MTGY_OP_TS44_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts45 */
/* => MWMM TS register 45 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts45  0x000012B4U
#define Adr_NX90_mtgy_mtgy_op_ts45 0xFF0832B4U
#define Adr_NX90_mtgy_op_ts45      0xFF0832B4U
#define DFLT_VAL_NX90_mtgy_op_ts45 0x00000000U

#define MSK_NX90_mtgy_op_ts45_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts45_val         0
#define DFLT_VAL_NX90_mtgy_op_ts45_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts45_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts45': */
#define MSK_USED_BITS_NX90_mtgy_op_ts45 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts45_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS45_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts45_val; /* data bits 1471..1440 */
} NX90_MTGY_OP_TS45_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS45_BIT_T bf;
} NX90_MTGY_OP_TS45_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts46 */
/* => MWMM TS register 46 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts46  0x000012B8U
#define Adr_NX90_mtgy_mtgy_op_ts46 0xFF0832B8U
#define Adr_NX90_mtgy_op_ts46      0xFF0832B8U
#define DFLT_VAL_NX90_mtgy_op_ts46 0x00000000U

#define MSK_NX90_mtgy_op_ts46_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts46_val         0
#define DFLT_VAL_NX90_mtgy_op_ts46_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts46_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts46': */
#define MSK_USED_BITS_NX90_mtgy_op_ts46 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts46_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS46_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts46_val; /* data bits 1503..1472 */
} NX90_MTGY_OP_TS46_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS46_BIT_T bf;
} NX90_MTGY_OP_TS46_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts47 */
/* => MWMM TS register 47 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts47  0x000012BCU
#define Adr_NX90_mtgy_mtgy_op_ts47 0xFF0832BCU
#define Adr_NX90_mtgy_op_ts47      0xFF0832BCU
#define DFLT_VAL_NX90_mtgy_op_ts47 0x00000000U

#define MSK_NX90_mtgy_op_ts47_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts47_val         0
#define DFLT_VAL_NX90_mtgy_op_ts47_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts47_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts47': */
#define MSK_USED_BITS_NX90_mtgy_op_ts47 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts47_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS47_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts47_val; /* data bits 1535..1504 */
} NX90_MTGY_OP_TS47_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS47_BIT_T bf;
} NX90_MTGY_OP_TS47_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts48 */
/* => MWMM TS register 48 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts48  0x000012C0U
#define Adr_NX90_mtgy_mtgy_op_ts48 0xFF0832C0U
#define Adr_NX90_mtgy_op_ts48      0xFF0832C0U
#define DFLT_VAL_NX90_mtgy_op_ts48 0x00000000U

#define MSK_NX90_mtgy_op_ts48_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts48_val         0
#define DFLT_VAL_NX90_mtgy_op_ts48_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts48_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts48': */
#define MSK_USED_BITS_NX90_mtgy_op_ts48 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts48_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS48_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts48_val; /* data bits 1567..1536 */
} NX90_MTGY_OP_TS48_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS48_BIT_T bf;
} NX90_MTGY_OP_TS48_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts49 */
/* => MWMM TS register 49 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts49  0x000012C4U
#define Adr_NX90_mtgy_mtgy_op_ts49 0xFF0832C4U
#define Adr_NX90_mtgy_op_ts49      0xFF0832C4U
#define DFLT_VAL_NX90_mtgy_op_ts49 0x00000000U

#define MSK_NX90_mtgy_op_ts49_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts49_val         0
#define DFLT_VAL_NX90_mtgy_op_ts49_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts49_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts49': */
#define MSK_USED_BITS_NX90_mtgy_op_ts49 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts49_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS49_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts49_val; /* data bits 1599..1568 */
} NX90_MTGY_OP_TS49_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS49_BIT_T bf;
} NX90_MTGY_OP_TS49_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts50 */
/* => MWMM TS register 50 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts50  0x000012C8U
#define Adr_NX90_mtgy_mtgy_op_ts50 0xFF0832C8U
#define Adr_NX90_mtgy_op_ts50      0xFF0832C8U
#define DFLT_VAL_NX90_mtgy_op_ts50 0x00000000U

#define MSK_NX90_mtgy_op_ts50_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts50_val         0
#define DFLT_VAL_NX90_mtgy_op_ts50_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts50_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts50': */
#define MSK_USED_BITS_NX90_mtgy_op_ts50 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts50_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS50_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts50_val; /* data bits 1631..1600 */
} NX90_MTGY_OP_TS50_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS50_BIT_T bf;
} NX90_MTGY_OP_TS50_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts51 */
/* => MWMM TS register 51 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts51  0x000012CCU
#define Adr_NX90_mtgy_mtgy_op_ts51 0xFF0832CCU
#define Adr_NX90_mtgy_op_ts51      0xFF0832CCU
#define DFLT_VAL_NX90_mtgy_op_ts51 0x00000000U

#define MSK_NX90_mtgy_op_ts51_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts51_val         0
#define DFLT_VAL_NX90_mtgy_op_ts51_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts51_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts51': */
#define MSK_USED_BITS_NX90_mtgy_op_ts51 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts51_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS51_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts51_val; /* data bits 1663..1632 */
} NX90_MTGY_OP_TS51_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS51_BIT_T bf;
} NX90_MTGY_OP_TS51_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts52 */
/* => MWMM TS register 52 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts52  0x000012D0U
#define Adr_NX90_mtgy_mtgy_op_ts52 0xFF0832D0U
#define Adr_NX90_mtgy_op_ts52      0xFF0832D0U
#define DFLT_VAL_NX90_mtgy_op_ts52 0x00000000U

#define MSK_NX90_mtgy_op_ts52_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts52_val         0
#define DFLT_VAL_NX90_mtgy_op_ts52_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts52_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts52': */
#define MSK_USED_BITS_NX90_mtgy_op_ts52 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts52_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS52_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts52_val; /* data bits 1695..1664 */
} NX90_MTGY_OP_TS52_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS52_BIT_T bf;
} NX90_MTGY_OP_TS52_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts53 */
/* => MWMM TS register 53 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts53  0x000012D4U
#define Adr_NX90_mtgy_mtgy_op_ts53 0xFF0832D4U
#define Adr_NX90_mtgy_op_ts53      0xFF0832D4U
#define DFLT_VAL_NX90_mtgy_op_ts53 0x00000000U

#define MSK_NX90_mtgy_op_ts53_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts53_val         0
#define DFLT_VAL_NX90_mtgy_op_ts53_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts53_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts53': */
#define MSK_USED_BITS_NX90_mtgy_op_ts53 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts53_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS53_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts53_val; /* data bits 1727..1696 */
} NX90_MTGY_OP_TS53_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS53_BIT_T bf;
} NX90_MTGY_OP_TS53_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts54 */
/* => MWMM TS register 54 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts54  0x000012D8U
#define Adr_NX90_mtgy_mtgy_op_ts54 0xFF0832D8U
#define Adr_NX90_mtgy_op_ts54      0xFF0832D8U
#define DFLT_VAL_NX90_mtgy_op_ts54 0x00000000U

#define MSK_NX90_mtgy_op_ts54_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts54_val         0
#define DFLT_VAL_NX90_mtgy_op_ts54_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts54_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts54': */
#define MSK_USED_BITS_NX90_mtgy_op_ts54 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts54_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS54_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts54_val; /* data bits 1759..1728 */
} NX90_MTGY_OP_TS54_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS54_BIT_T bf;
} NX90_MTGY_OP_TS54_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts55 */
/* => MWMM TS register 55 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts55  0x000012DCU
#define Adr_NX90_mtgy_mtgy_op_ts55 0xFF0832DCU
#define Adr_NX90_mtgy_op_ts55      0xFF0832DCU
#define DFLT_VAL_NX90_mtgy_op_ts55 0x00000000U

#define MSK_NX90_mtgy_op_ts55_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts55_val         0
#define DFLT_VAL_NX90_mtgy_op_ts55_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts55_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts55': */
#define MSK_USED_BITS_NX90_mtgy_op_ts55 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts55_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS55_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts55_val; /* data bits 1791..1760 */
} NX90_MTGY_OP_TS55_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS55_BIT_T bf;
} NX90_MTGY_OP_TS55_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts56 */
/* => MWMM TS register 56 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts56  0x000012E0U
#define Adr_NX90_mtgy_mtgy_op_ts56 0xFF0832E0U
#define Adr_NX90_mtgy_op_ts56      0xFF0832E0U
#define DFLT_VAL_NX90_mtgy_op_ts56 0x00000000U

#define MSK_NX90_mtgy_op_ts56_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts56_val         0
#define DFLT_VAL_NX90_mtgy_op_ts56_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts56_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts56': */
#define MSK_USED_BITS_NX90_mtgy_op_ts56 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts56_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS56_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts56_val; /* data bits 1823..1792 */
} NX90_MTGY_OP_TS56_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS56_BIT_T bf;
} NX90_MTGY_OP_TS56_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts57 */
/* => MWMM TS register 57 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts57  0x000012E4U
#define Adr_NX90_mtgy_mtgy_op_ts57 0xFF0832E4U
#define Adr_NX90_mtgy_op_ts57      0xFF0832E4U
#define DFLT_VAL_NX90_mtgy_op_ts57 0x00000000U

#define MSK_NX90_mtgy_op_ts57_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts57_val         0
#define DFLT_VAL_NX90_mtgy_op_ts57_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts57_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts57': */
#define MSK_USED_BITS_NX90_mtgy_op_ts57 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts57_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS57_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts57_val; /* data bits 1855..1824 */
} NX90_MTGY_OP_TS57_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS57_BIT_T bf;
} NX90_MTGY_OP_TS57_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts58 */
/* => MWMM TS register 58 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts58  0x000012E8U
#define Adr_NX90_mtgy_mtgy_op_ts58 0xFF0832E8U
#define Adr_NX90_mtgy_op_ts58      0xFF0832E8U
#define DFLT_VAL_NX90_mtgy_op_ts58 0x00000000U

#define MSK_NX90_mtgy_op_ts58_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts58_val         0
#define DFLT_VAL_NX90_mtgy_op_ts58_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts58_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts58': */
#define MSK_USED_BITS_NX90_mtgy_op_ts58 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts58_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS58_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts58_val; /* data bits 1887..1856 */
} NX90_MTGY_OP_TS58_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS58_BIT_T bf;
} NX90_MTGY_OP_TS58_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts59 */
/* => MWMM TS register 59 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts59  0x000012ECU
#define Adr_NX90_mtgy_mtgy_op_ts59 0xFF0832ECU
#define Adr_NX90_mtgy_op_ts59      0xFF0832ECU
#define DFLT_VAL_NX90_mtgy_op_ts59 0x00000000U

#define MSK_NX90_mtgy_op_ts59_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts59_val         0
#define DFLT_VAL_NX90_mtgy_op_ts59_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts59_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts59': */
#define MSK_USED_BITS_NX90_mtgy_op_ts59 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts59_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS59_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts59_val; /* data bits 1919..1888 */
} NX90_MTGY_OP_TS59_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS59_BIT_T bf;
} NX90_MTGY_OP_TS59_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts60 */
/* => MWMM TS register 60 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts60  0x000012F0U
#define Adr_NX90_mtgy_mtgy_op_ts60 0xFF0832F0U
#define Adr_NX90_mtgy_op_ts60      0xFF0832F0U
#define DFLT_VAL_NX90_mtgy_op_ts60 0x00000000U

#define MSK_NX90_mtgy_op_ts60_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts60_val         0
#define DFLT_VAL_NX90_mtgy_op_ts60_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts60_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts60': */
#define MSK_USED_BITS_NX90_mtgy_op_ts60 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts60_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS60_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts60_val; /* data bits 1951..1920 */
} NX90_MTGY_OP_TS60_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS60_BIT_T bf;
} NX90_MTGY_OP_TS60_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts61 */
/* => MWMM TS register 61 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts61  0x000012F4U
#define Adr_NX90_mtgy_mtgy_op_ts61 0xFF0832F4U
#define Adr_NX90_mtgy_op_ts61      0xFF0832F4U
#define DFLT_VAL_NX90_mtgy_op_ts61 0x00000000U

#define MSK_NX90_mtgy_op_ts61_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts61_val         0
#define DFLT_VAL_NX90_mtgy_op_ts61_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts61_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts61': */
#define MSK_USED_BITS_NX90_mtgy_op_ts61 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts61_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS61_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts61_val; /* data bits 1983..1952 */
} NX90_MTGY_OP_TS61_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS61_BIT_T bf;
} NX90_MTGY_OP_TS61_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts62 */
/* => MWMM TS register 62 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts62  0x000012F8U
#define Adr_NX90_mtgy_mtgy_op_ts62 0xFF0832F8U
#define Adr_NX90_mtgy_op_ts62      0xFF0832F8U
#define DFLT_VAL_NX90_mtgy_op_ts62 0x00000000U

#define MSK_NX90_mtgy_op_ts62_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts62_val         0
#define DFLT_VAL_NX90_mtgy_op_ts62_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts62_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts62': */
#define MSK_USED_BITS_NX90_mtgy_op_ts62 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts62_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS62_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts62_val; /* data bits 2015..1984 */
} NX90_MTGY_OP_TS62_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS62_BIT_T bf;
} NX90_MTGY_OP_TS62_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts63 */
/* => MWMM TS register 63 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts63  0x000012FCU
#define Adr_NX90_mtgy_mtgy_op_ts63 0xFF0832FCU
#define Adr_NX90_mtgy_op_ts63      0xFF0832FCU
#define DFLT_VAL_NX90_mtgy_op_ts63 0x00000000U

#define MSK_NX90_mtgy_op_ts63_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts63_val         0
#define DFLT_VAL_NX90_mtgy_op_ts63_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts63_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts63': */
#define MSK_USED_BITS_NX90_mtgy_op_ts63 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts63_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS63_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts63_val; /* data bits 2047..2016 */
} NX90_MTGY_OP_TS63_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS63_BIT_T bf;
} NX90_MTGY_OP_TS63_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts64 */
/* => MWMM TS register 64 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts64  0x00001300U
#define Adr_NX90_mtgy_mtgy_op_ts64 0xFF083300U
#define Adr_NX90_mtgy_op_ts64      0xFF083300U
#define DFLT_VAL_NX90_mtgy_op_ts64 0x00000000U

#define MSK_NX90_mtgy_op_ts64_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts64_val         0
#define DFLT_VAL_NX90_mtgy_op_ts64_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts64_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts64': */
#define MSK_USED_BITS_NX90_mtgy_op_ts64 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts64_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS64_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts64_val; /* data bits 2079..2048 */
} NX90_MTGY_OP_TS64_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS64_BIT_T bf;
} NX90_MTGY_OP_TS64_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts65 */
/* => MWMM TS register 65 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts65  0x00001304U
#define Adr_NX90_mtgy_mtgy_op_ts65 0xFF083304U
#define Adr_NX90_mtgy_op_ts65      0xFF083304U
#define DFLT_VAL_NX90_mtgy_op_ts65 0x00000000U

#define MSK_NX90_mtgy_op_ts65_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts65_val         0
#define DFLT_VAL_NX90_mtgy_op_ts65_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts65_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts65': */
#define MSK_USED_BITS_NX90_mtgy_op_ts65 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts65_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS65_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts65_val; /* data bits 2111..2080 */
} NX90_MTGY_OP_TS65_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS65_BIT_T bf;
} NX90_MTGY_OP_TS65_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts66 */
/* => MWMM TS register 66 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts66  0x00001308U
#define Adr_NX90_mtgy_mtgy_op_ts66 0xFF083308U
#define Adr_NX90_mtgy_op_ts66      0xFF083308U
#define DFLT_VAL_NX90_mtgy_op_ts66 0x00000000U

#define MSK_NX90_mtgy_op_ts66_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts66_val         0
#define DFLT_VAL_NX90_mtgy_op_ts66_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts66_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts66': */
#define MSK_USED_BITS_NX90_mtgy_op_ts66 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts66_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS66_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts66_val; /* data bits 2143..2112 */
} NX90_MTGY_OP_TS66_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS66_BIT_T bf;
} NX90_MTGY_OP_TS66_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts67 */
/* => MWMM TS register 67 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts67  0x0000130CU
#define Adr_NX90_mtgy_mtgy_op_ts67 0xFF08330CU
#define Adr_NX90_mtgy_op_ts67      0xFF08330CU
#define DFLT_VAL_NX90_mtgy_op_ts67 0x00000000U

#define MSK_NX90_mtgy_op_ts67_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts67_val         0
#define DFLT_VAL_NX90_mtgy_op_ts67_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts67_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts67': */
#define MSK_USED_BITS_NX90_mtgy_op_ts67 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts67_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS67_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts67_val; /* data bits 2175..2144 */
} NX90_MTGY_OP_TS67_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS67_BIT_T bf;
} NX90_MTGY_OP_TS67_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts68 */
/* => MWMM TS register 68 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts68  0x00001310U
#define Adr_NX90_mtgy_mtgy_op_ts68 0xFF083310U
#define Adr_NX90_mtgy_op_ts68      0xFF083310U
#define DFLT_VAL_NX90_mtgy_op_ts68 0x00000000U

#define MSK_NX90_mtgy_op_ts68_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts68_val         0
#define DFLT_VAL_NX90_mtgy_op_ts68_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts68_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts68': */
#define MSK_USED_BITS_NX90_mtgy_op_ts68 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts68_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS68_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts68_val; /* data bits 2207..2176 */
} NX90_MTGY_OP_TS68_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS68_BIT_T bf;
} NX90_MTGY_OP_TS68_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts69 */
/* => MWMM TS register 69 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts69  0x00001314U
#define Adr_NX90_mtgy_mtgy_op_ts69 0xFF083314U
#define Adr_NX90_mtgy_op_ts69      0xFF083314U
#define DFLT_VAL_NX90_mtgy_op_ts69 0x00000000U

#define MSK_NX90_mtgy_op_ts69_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts69_val         0
#define DFLT_VAL_NX90_mtgy_op_ts69_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts69_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts69': */
#define MSK_USED_BITS_NX90_mtgy_op_ts69 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts69_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS69_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts69_val; /* data bits 2239..2208 */
} NX90_MTGY_OP_TS69_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS69_BIT_T bf;
} NX90_MTGY_OP_TS69_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts70 */
/* => MWMM TS register 70 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts70  0x00001318U
#define Adr_NX90_mtgy_mtgy_op_ts70 0xFF083318U
#define Adr_NX90_mtgy_op_ts70      0xFF083318U
#define DFLT_VAL_NX90_mtgy_op_ts70 0x00000000U

#define MSK_NX90_mtgy_op_ts70_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts70_val         0
#define DFLT_VAL_NX90_mtgy_op_ts70_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts70_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts70': */
#define MSK_USED_BITS_NX90_mtgy_op_ts70 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts70_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS70_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts70_val; /* data bits 2271..2240 */
} NX90_MTGY_OP_TS70_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS70_BIT_T bf;
} NX90_MTGY_OP_TS70_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts71 */
/* => MWMM TS register 71 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts71  0x0000131CU
#define Adr_NX90_mtgy_mtgy_op_ts71 0xFF08331CU
#define Adr_NX90_mtgy_op_ts71      0xFF08331CU
#define DFLT_VAL_NX90_mtgy_op_ts71 0x00000000U

#define MSK_NX90_mtgy_op_ts71_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts71_val         0
#define DFLT_VAL_NX90_mtgy_op_ts71_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts71_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts71': */
#define MSK_USED_BITS_NX90_mtgy_op_ts71 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts71_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS71_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts71_val; /* data bits 2303..2272 */
} NX90_MTGY_OP_TS71_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS71_BIT_T bf;
} NX90_MTGY_OP_TS71_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts72 */
/* => MWMM TS register 72 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts72  0x00001320U
#define Adr_NX90_mtgy_mtgy_op_ts72 0xFF083320U
#define Adr_NX90_mtgy_op_ts72      0xFF083320U
#define DFLT_VAL_NX90_mtgy_op_ts72 0x00000000U

#define MSK_NX90_mtgy_op_ts72_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts72_val         0
#define DFLT_VAL_NX90_mtgy_op_ts72_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts72_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts72': */
#define MSK_USED_BITS_NX90_mtgy_op_ts72 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts72_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS72_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts72_val; /* data bits 2335..2304 */
} NX90_MTGY_OP_TS72_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS72_BIT_T bf;
} NX90_MTGY_OP_TS72_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts73 */
/* => MWMM TS register 73 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts73  0x00001324U
#define Adr_NX90_mtgy_mtgy_op_ts73 0xFF083324U
#define Adr_NX90_mtgy_op_ts73      0xFF083324U
#define DFLT_VAL_NX90_mtgy_op_ts73 0x00000000U

#define MSK_NX90_mtgy_op_ts73_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts73_val         0
#define DFLT_VAL_NX90_mtgy_op_ts73_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts73_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts73': */
#define MSK_USED_BITS_NX90_mtgy_op_ts73 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts73_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS73_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts73_val; /* data bits 2367..2336 */
} NX90_MTGY_OP_TS73_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS73_BIT_T bf;
} NX90_MTGY_OP_TS73_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts74 */
/* => MWMM TS register 74 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts74  0x00001328U
#define Adr_NX90_mtgy_mtgy_op_ts74 0xFF083328U
#define Adr_NX90_mtgy_op_ts74      0xFF083328U
#define DFLT_VAL_NX90_mtgy_op_ts74 0x00000000U

#define MSK_NX90_mtgy_op_ts74_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts74_val         0
#define DFLT_VAL_NX90_mtgy_op_ts74_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts74_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts74': */
#define MSK_USED_BITS_NX90_mtgy_op_ts74 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts74_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS74_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts74_val; /* data bits 2399..2368 */
} NX90_MTGY_OP_TS74_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS74_BIT_T bf;
} NX90_MTGY_OP_TS74_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts75 */
/* => MWMM TS register 75 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts75  0x0000132CU
#define Adr_NX90_mtgy_mtgy_op_ts75 0xFF08332CU
#define Adr_NX90_mtgy_op_ts75      0xFF08332CU
#define DFLT_VAL_NX90_mtgy_op_ts75 0x00000000U

#define MSK_NX90_mtgy_op_ts75_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts75_val         0
#define DFLT_VAL_NX90_mtgy_op_ts75_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts75_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts75': */
#define MSK_USED_BITS_NX90_mtgy_op_ts75 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts75_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS75_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts75_val; /* data bits 2431..2400 */
} NX90_MTGY_OP_TS75_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS75_BIT_T bf;
} NX90_MTGY_OP_TS75_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts76 */
/* => MWMM TS register 76 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts76  0x00001330U
#define Adr_NX90_mtgy_mtgy_op_ts76 0xFF083330U
#define Adr_NX90_mtgy_op_ts76      0xFF083330U
#define DFLT_VAL_NX90_mtgy_op_ts76 0x00000000U

#define MSK_NX90_mtgy_op_ts76_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts76_val         0
#define DFLT_VAL_NX90_mtgy_op_ts76_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts76_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts76': */
#define MSK_USED_BITS_NX90_mtgy_op_ts76 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts76_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS76_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts76_val; /* data bits 2463..2432 */
} NX90_MTGY_OP_TS76_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS76_BIT_T bf;
} NX90_MTGY_OP_TS76_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts77 */
/* => MWMM TS register 77 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts77  0x00001334U
#define Adr_NX90_mtgy_mtgy_op_ts77 0xFF083334U
#define Adr_NX90_mtgy_op_ts77      0xFF083334U
#define DFLT_VAL_NX90_mtgy_op_ts77 0x00000000U

#define MSK_NX90_mtgy_op_ts77_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts77_val         0
#define DFLT_VAL_NX90_mtgy_op_ts77_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts77_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts77': */
#define MSK_USED_BITS_NX90_mtgy_op_ts77 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts77_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS77_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts77_val; /* data bits 2495..2464 */
} NX90_MTGY_OP_TS77_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS77_BIT_T bf;
} NX90_MTGY_OP_TS77_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts78 */
/* => MWMM TS register 78 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts78  0x00001338U
#define Adr_NX90_mtgy_mtgy_op_ts78 0xFF083338U
#define Adr_NX90_mtgy_op_ts78      0xFF083338U
#define DFLT_VAL_NX90_mtgy_op_ts78 0x00000000U

#define MSK_NX90_mtgy_op_ts78_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts78_val         0
#define DFLT_VAL_NX90_mtgy_op_ts78_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts78_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts78': */
#define MSK_USED_BITS_NX90_mtgy_op_ts78 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts78_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS78_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts78_val; /* data bits 2527..2496 */
} NX90_MTGY_OP_TS78_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS78_BIT_T bf;
} NX90_MTGY_OP_TS78_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts79 */
/* => MWMM TS register 79 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts79  0x0000133CU
#define Adr_NX90_mtgy_mtgy_op_ts79 0xFF08333CU
#define Adr_NX90_mtgy_op_ts79      0xFF08333CU
#define DFLT_VAL_NX90_mtgy_op_ts79 0x00000000U

#define MSK_NX90_mtgy_op_ts79_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts79_val         0
#define DFLT_VAL_NX90_mtgy_op_ts79_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts79_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts79': */
#define MSK_USED_BITS_NX90_mtgy_op_ts79 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts79_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS79_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts79_val; /* data bits 2559..2528 */
} NX90_MTGY_OP_TS79_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS79_BIT_T bf;
} NX90_MTGY_OP_TS79_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts80 */
/* => MWMM TS register 80 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts80  0x00001340U
#define Adr_NX90_mtgy_mtgy_op_ts80 0xFF083340U
#define Adr_NX90_mtgy_op_ts80      0xFF083340U
#define DFLT_VAL_NX90_mtgy_op_ts80 0x00000000U

#define MSK_NX90_mtgy_op_ts80_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts80_val         0
#define DFLT_VAL_NX90_mtgy_op_ts80_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts80_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts80': */
#define MSK_USED_BITS_NX90_mtgy_op_ts80 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts80_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS80_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts80_val; /* data bits 2591..2560 */
} NX90_MTGY_OP_TS80_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS80_BIT_T bf;
} NX90_MTGY_OP_TS80_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts81 */
/* => MWMM TS register 81 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts81  0x00001344U
#define Adr_NX90_mtgy_mtgy_op_ts81 0xFF083344U
#define Adr_NX90_mtgy_op_ts81      0xFF083344U
#define DFLT_VAL_NX90_mtgy_op_ts81 0x00000000U

#define MSK_NX90_mtgy_op_ts81_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts81_val         0
#define DFLT_VAL_NX90_mtgy_op_ts81_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts81_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts81': */
#define MSK_USED_BITS_NX90_mtgy_op_ts81 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts81_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS81_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts81_val; /* data bits 2623..2592 */
} NX90_MTGY_OP_TS81_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS81_BIT_T bf;
} NX90_MTGY_OP_TS81_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts82 */
/* => MWMM TS register 82 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts82  0x00001348U
#define Adr_NX90_mtgy_mtgy_op_ts82 0xFF083348U
#define Adr_NX90_mtgy_op_ts82      0xFF083348U
#define DFLT_VAL_NX90_mtgy_op_ts82 0x00000000U

#define MSK_NX90_mtgy_op_ts82_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts82_val         0
#define DFLT_VAL_NX90_mtgy_op_ts82_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts82_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts82': */
#define MSK_USED_BITS_NX90_mtgy_op_ts82 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts82_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS82_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts82_val; /* data bits 2655..2624 */
} NX90_MTGY_OP_TS82_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS82_BIT_T bf;
} NX90_MTGY_OP_TS82_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts83 */
/* => MWMM TS register 83 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts83  0x0000134CU
#define Adr_NX90_mtgy_mtgy_op_ts83 0xFF08334CU
#define Adr_NX90_mtgy_op_ts83      0xFF08334CU
#define DFLT_VAL_NX90_mtgy_op_ts83 0x00000000U

#define MSK_NX90_mtgy_op_ts83_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts83_val         0
#define DFLT_VAL_NX90_mtgy_op_ts83_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts83_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts83': */
#define MSK_USED_BITS_NX90_mtgy_op_ts83 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts83_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS83_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts83_val; /* data bits 2687..2656 */
} NX90_MTGY_OP_TS83_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS83_BIT_T bf;
} NX90_MTGY_OP_TS83_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts84 */
/* => MWMM TS register 84 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts84  0x00001350U
#define Adr_NX90_mtgy_mtgy_op_ts84 0xFF083350U
#define Adr_NX90_mtgy_op_ts84      0xFF083350U
#define DFLT_VAL_NX90_mtgy_op_ts84 0x00000000U

#define MSK_NX90_mtgy_op_ts84_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts84_val         0
#define DFLT_VAL_NX90_mtgy_op_ts84_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts84_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts84': */
#define MSK_USED_BITS_NX90_mtgy_op_ts84 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts84_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS84_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts84_val; /* data bits 2719..2688 */
} NX90_MTGY_OP_TS84_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS84_BIT_T bf;
} NX90_MTGY_OP_TS84_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts85 */
/* => MWMM TS register 85 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts85  0x00001354U
#define Adr_NX90_mtgy_mtgy_op_ts85 0xFF083354U
#define Adr_NX90_mtgy_op_ts85      0xFF083354U
#define DFLT_VAL_NX90_mtgy_op_ts85 0x00000000U

#define MSK_NX90_mtgy_op_ts85_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts85_val         0
#define DFLT_VAL_NX90_mtgy_op_ts85_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts85_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts85': */
#define MSK_USED_BITS_NX90_mtgy_op_ts85 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts85_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS85_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts85_val; /* data bits 2751..2720 */
} NX90_MTGY_OP_TS85_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS85_BIT_T bf;
} NX90_MTGY_OP_TS85_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts86 */
/* => MWMM TS register 86 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts86  0x00001358U
#define Adr_NX90_mtgy_mtgy_op_ts86 0xFF083358U
#define Adr_NX90_mtgy_op_ts86      0xFF083358U
#define DFLT_VAL_NX90_mtgy_op_ts86 0x00000000U

#define MSK_NX90_mtgy_op_ts86_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts86_val         0
#define DFLT_VAL_NX90_mtgy_op_ts86_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts86_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts86': */
#define MSK_USED_BITS_NX90_mtgy_op_ts86 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts86_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS86_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts86_val; /* data bits 2783..2752 */
} NX90_MTGY_OP_TS86_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS86_BIT_T bf;
} NX90_MTGY_OP_TS86_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts87 */
/* => MWMM TS register 87 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts87  0x0000135CU
#define Adr_NX90_mtgy_mtgy_op_ts87 0xFF08335CU
#define Adr_NX90_mtgy_op_ts87      0xFF08335CU
#define DFLT_VAL_NX90_mtgy_op_ts87 0x00000000U

#define MSK_NX90_mtgy_op_ts87_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts87_val         0
#define DFLT_VAL_NX90_mtgy_op_ts87_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts87_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts87': */
#define MSK_USED_BITS_NX90_mtgy_op_ts87 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts87_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS87_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts87_val; /* data bits 2815..2784 */
} NX90_MTGY_OP_TS87_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS87_BIT_T bf;
} NX90_MTGY_OP_TS87_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts88 */
/* => MWMM TS register 88 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts88  0x00001360U
#define Adr_NX90_mtgy_mtgy_op_ts88 0xFF083360U
#define Adr_NX90_mtgy_op_ts88      0xFF083360U
#define DFLT_VAL_NX90_mtgy_op_ts88 0x00000000U

#define MSK_NX90_mtgy_op_ts88_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts88_val         0
#define DFLT_VAL_NX90_mtgy_op_ts88_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts88_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts88': */
#define MSK_USED_BITS_NX90_mtgy_op_ts88 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts88_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS88_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts88_val; /* data bits 2847..2816 */
} NX90_MTGY_OP_TS88_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS88_BIT_T bf;
} NX90_MTGY_OP_TS88_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts89 */
/* => MWMM TS register 89 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts89  0x00001364U
#define Adr_NX90_mtgy_mtgy_op_ts89 0xFF083364U
#define Adr_NX90_mtgy_op_ts89      0xFF083364U
#define DFLT_VAL_NX90_mtgy_op_ts89 0x00000000U

#define MSK_NX90_mtgy_op_ts89_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts89_val         0
#define DFLT_VAL_NX90_mtgy_op_ts89_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts89_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts89': */
#define MSK_USED_BITS_NX90_mtgy_op_ts89 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts89_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS89_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts89_val; /* data bits 2879..2848 */
} NX90_MTGY_OP_TS89_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS89_BIT_T bf;
} NX90_MTGY_OP_TS89_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts90 */
/* => MWMM TS register 90 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts90  0x00001368U
#define Adr_NX90_mtgy_mtgy_op_ts90 0xFF083368U
#define Adr_NX90_mtgy_op_ts90      0xFF083368U
#define DFLT_VAL_NX90_mtgy_op_ts90 0x00000000U

#define MSK_NX90_mtgy_op_ts90_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts90_val         0
#define DFLT_VAL_NX90_mtgy_op_ts90_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts90_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts90': */
#define MSK_USED_BITS_NX90_mtgy_op_ts90 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts90_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS90_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts90_val; /* data bits 2911..2880 */
} NX90_MTGY_OP_TS90_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS90_BIT_T bf;
} NX90_MTGY_OP_TS90_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts91 */
/* => MWMM TS register 91 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts91  0x0000136CU
#define Adr_NX90_mtgy_mtgy_op_ts91 0xFF08336CU
#define Adr_NX90_mtgy_op_ts91      0xFF08336CU
#define DFLT_VAL_NX90_mtgy_op_ts91 0x00000000U

#define MSK_NX90_mtgy_op_ts91_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts91_val         0
#define DFLT_VAL_NX90_mtgy_op_ts91_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts91_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts91': */
#define MSK_USED_BITS_NX90_mtgy_op_ts91 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts91_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS91_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts91_val; /* data bits 2943..2912 */
} NX90_MTGY_OP_TS91_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS91_BIT_T bf;
} NX90_MTGY_OP_TS91_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts92 */
/* => MWMM TS register 92 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts92  0x00001370U
#define Adr_NX90_mtgy_mtgy_op_ts92 0xFF083370U
#define Adr_NX90_mtgy_op_ts92      0xFF083370U
#define DFLT_VAL_NX90_mtgy_op_ts92 0x00000000U

#define MSK_NX90_mtgy_op_ts92_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts92_val         0
#define DFLT_VAL_NX90_mtgy_op_ts92_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts92_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts92': */
#define MSK_USED_BITS_NX90_mtgy_op_ts92 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts92_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS92_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts92_val; /* data bits 2975..2944 */
} NX90_MTGY_OP_TS92_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS92_BIT_T bf;
} NX90_MTGY_OP_TS92_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts93 */
/* => MWMM TS register 93 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts93  0x00001374U
#define Adr_NX90_mtgy_mtgy_op_ts93 0xFF083374U
#define Adr_NX90_mtgy_op_ts93      0xFF083374U
#define DFLT_VAL_NX90_mtgy_op_ts93 0x00000000U

#define MSK_NX90_mtgy_op_ts93_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts93_val         0
#define DFLT_VAL_NX90_mtgy_op_ts93_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts93_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts93': */
#define MSK_USED_BITS_NX90_mtgy_op_ts93 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts93_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS93_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts93_val; /* data bits 3007..2976 */
} NX90_MTGY_OP_TS93_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS93_BIT_T bf;
} NX90_MTGY_OP_TS93_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts94 */
/* => MWMM TS register 94 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts94  0x00001378U
#define Adr_NX90_mtgy_mtgy_op_ts94 0xFF083378U
#define Adr_NX90_mtgy_op_ts94      0xFF083378U
#define DFLT_VAL_NX90_mtgy_op_ts94 0x00000000U

#define MSK_NX90_mtgy_op_ts94_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts94_val         0
#define DFLT_VAL_NX90_mtgy_op_ts94_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts94_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts94': */
#define MSK_USED_BITS_NX90_mtgy_op_ts94 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts94_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS94_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts94_val; /* data bits 3039..3008 */
} NX90_MTGY_OP_TS94_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS94_BIT_T bf;
} NX90_MTGY_OP_TS94_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts95 */
/* => MWMM TS register 95 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts95  0x0000137CU
#define Adr_NX90_mtgy_mtgy_op_ts95 0xFF08337CU
#define Adr_NX90_mtgy_op_ts95      0xFF08337CU
#define DFLT_VAL_NX90_mtgy_op_ts95 0x00000000U

#define MSK_NX90_mtgy_op_ts95_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts95_val         0
#define DFLT_VAL_NX90_mtgy_op_ts95_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts95_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts95': */
#define MSK_USED_BITS_NX90_mtgy_op_ts95 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts95_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS95_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts95_val; /* data bits 3071..3040 */
} NX90_MTGY_OP_TS95_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS95_BIT_T bf;
} NX90_MTGY_OP_TS95_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts96 */
/* => MWMM TS register 96 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts96  0x00001380U
#define Adr_NX90_mtgy_mtgy_op_ts96 0xFF083380U
#define Adr_NX90_mtgy_op_ts96      0xFF083380U
#define DFLT_VAL_NX90_mtgy_op_ts96 0x00000000U

#define MSK_NX90_mtgy_op_ts96_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts96_val         0
#define DFLT_VAL_NX90_mtgy_op_ts96_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts96_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts96': */
#define MSK_USED_BITS_NX90_mtgy_op_ts96 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts96_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS96_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts96_val; /* data bits 3103..3072 */
} NX90_MTGY_OP_TS96_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS96_BIT_T bf;
} NX90_MTGY_OP_TS96_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts97 */
/* => MWMM TS register 97 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts97  0x00001384U
#define Adr_NX90_mtgy_mtgy_op_ts97 0xFF083384U
#define Adr_NX90_mtgy_op_ts97      0xFF083384U
#define DFLT_VAL_NX90_mtgy_op_ts97 0x00000000U

#define MSK_NX90_mtgy_op_ts97_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts97_val         0
#define DFLT_VAL_NX90_mtgy_op_ts97_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts97_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts97': */
#define MSK_USED_BITS_NX90_mtgy_op_ts97 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts97_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS97_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts97_val; /* data bits 3135..3104 */
} NX90_MTGY_OP_TS97_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS97_BIT_T bf;
} NX90_MTGY_OP_TS97_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts98 */
/* => MWMM TS register 98 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts98  0x00001388U
#define Adr_NX90_mtgy_mtgy_op_ts98 0xFF083388U
#define Adr_NX90_mtgy_op_ts98      0xFF083388U
#define DFLT_VAL_NX90_mtgy_op_ts98 0x00000000U

#define MSK_NX90_mtgy_op_ts98_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts98_val         0
#define DFLT_VAL_NX90_mtgy_op_ts98_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts98_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts98': */
#define MSK_USED_BITS_NX90_mtgy_op_ts98 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts98_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS98_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts98_val; /* data bits 3167..3136 */
} NX90_MTGY_OP_TS98_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS98_BIT_T bf;
} NX90_MTGY_OP_TS98_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts99 */
/* => MWMM TS register 99 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts99  0x0000138CU
#define Adr_NX90_mtgy_mtgy_op_ts99 0xFF08338CU
#define Adr_NX90_mtgy_op_ts99      0xFF08338CU
#define DFLT_VAL_NX90_mtgy_op_ts99 0x00000000U

#define MSK_NX90_mtgy_op_ts99_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts99_val         0
#define DFLT_VAL_NX90_mtgy_op_ts99_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts99_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts99': */
#define MSK_USED_BITS_NX90_mtgy_op_ts99 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts99_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS99_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts99_val; /* data bits 3199..3168 */
} NX90_MTGY_OP_TS99_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_TS99_BIT_T bf;
} NX90_MTGY_OP_TS99_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts100 */
/* => MWMM TS register 100 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts100  0x00001390U
#define Adr_NX90_mtgy_mtgy_op_ts100 0xFF083390U
#define Adr_NX90_mtgy_op_ts100      0xFF083390U
#define DFLT_VAL_NX90_mtgy_op_ts100 0x00000000U

#define MSK_NX90_mtgy_op_ts100_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts100_val         0
#define DFLT_VAL_NX90_mtgy_op_ts100_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts100_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts100': */
#define MSK_USED_BITS_NX90_mtgy_op_ts100 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts100_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS100_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts100_val; /* data bits 3231..3200 */
} NX90_MTGY_OP_TS100_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS100_BIT_T bf;
} NX90_MTGY_OP_TS100_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts101 */
/* => MWMM TS register 101 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts101  0x00001394U
#define Adr_NX90_mtgy_mtgy_op_ts101 0xFF083394U
#define Adr_NX90_mtgy_op_ts101      0xFF083394U
#define DFLT_VAL_NX90_mtgy_op_ts101 0x00000000U

#define MSK_NX90_mtgy_op_ts101_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts101_val         0
#define DFLT_VAL_NX90_mtgy_op_ts101_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts101_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts101': */
#define MSK_USED_BITS_NX90_mtgy_op_ts101 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts101_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS101_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts101_val; /* data bits 3263..3232 */
} NX90_MTGY_OP_TS101_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS101_BIT_T bf;
} NX90_MTGY_OP_TS101_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts102 */
/* => MWMM TS register 102 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts102  0x00001398U
#define Adr_NX90_mtgy_mtgy_op_ts102 0xFF083398U
#define Adr_NX90_mtgy_op_ts102      0xFF083398U
#define DFLT_VAL_NX90_mtgy_op_ts102 0x00000000U

#define MSK_NX90_mtgy_op_ts102_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts102_val         0
#define DFLT_VAL_NX90_mtgy_op_ts102_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts102_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts102': */
#define MSK_USED_BITS_NX90_mtgy_op_ts102 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts102_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS102_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts102_val; /* data bits 3295..3264 */
} NX90_MTGY_OP_TS102_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS102_BIT_T bf;
} NX90_MTGY_OP_TS102_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts103 */
/* => MWMM TS register 103 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts103  0x0000139CU
#define Adr_NX90_mtgy_mtgy_op_ts103 0xFF08339CU
#define Adr_NX90_mtgy_op_ts103      0xFF08339CU
#define DFLT_VAL_NX90_mtgy_op_ts103 0x00000000U

#define MSK_NX90_mtgy_op_ts103_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts103_val         0
#define DFLT_VAL_NX90_mtgy_op_ts103_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts103_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts103': */
#define MSK_USED_BITS_NX90_mtgy_op_ts103 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts103_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS103_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts103_val; /* data bits 3327..3296 */
} NX90_MTGY_OP_TS103_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS103_BIT_T bf;
} NX90_MTGY_OP_TS103_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts104 */
/* => MWMM TS register 104 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts104  0x000013A0U
#define Adr_NX90_mtgy_mtgy_op_ts104 0xFF0833A0U
#define Adr_NX90_mtgy_op_ts104      0xFF0833A0U
#define DFLT_VAL_NX90_mtgy_op_ts104 0x00000000U

#define MSK_NX90_mtgy_op_ts104_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts104_val         0
#define DFLT_VAL_NX90_mtgy_op_ts104_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts104_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts104': */
#define MSK_USED_BITS_NX90_mtgy_op_ts104 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts104_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS104_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts104_val; /* data bits 3359..3328 */
} NX90_MTGY_OP_TS104_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS104_BIT_T bf;
} NX90_MTGY_OP_TS104_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts105 */
/* => MWMM TS register 105 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts105  0x000013A4U
#define Adr_NX90_mtgy_mtgy_op_ts105 0xFF0833A4U
#define Adr_NX90_mtgy_op_ts105      0xFF0833A4U
#define DFLT_VAL_NX90_mtgy_op_ts105 0x00000000U

#define MSK_NX90_mtgy_op_ts105_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts105_val         0
#define DFLT_VAL_NX90_mtgy_op_ts105_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts105_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts105': */
#define MSK_USED_BITS_NX90_mtgy_op_ts105 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts105_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS105_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts105_val; /* data bits 3391..3360 */
} NX90_MTGY_OP_TS105_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS105_BIT_T bf;
} NX90_MTGY_OP_TS105_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts106 */
/* => MWMM TS register 106 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts106  0x000013A8U
#define Adr_NX90_mtgy_mtgy_op_ts106 0xFF0833A8U
#define Adr_NX90_mtgy_op_ts106      0xFF0833A8U
#define DFLT_VAL_NX90_mtgy_op_ts106 0x00000000U

#define MSK_NX90_mtgy_op_ts106_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts106_val         0
#define DFLT_VAL_NX90_mtgy_op_ts106_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts106_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts106': */
#define MSK_USED_BITS_NX90_mtgy_op_ts106 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts106_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS106_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts106_val; /* data bits 3423..3392 */
} NX90_MTGY_OP_TS106_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS106_BIT_T bf;
} NX90_MTGY_OP_TS106_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts107 */
/* => MWMM TS register 107 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts107  0x000013ACU
#define Adr_NX90_mtgy_mtgy_op_ts107 0xFF0833ACU
#define Adr_NX90_mtgy_op_ts107      0xFF0833ACU
#define DFLT_VAL_NX90_mtgy_op_ts107 0x00000000U

#define MSK_NX90_mtgy_op_ts107_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts107_val         0
#define DFLT_VAL_NX90_mtgy_op_ts107_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts107_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts107': */
#define MSK_USED_BITS_NX90_mtgy_op_ts107 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts107_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS107_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts107_val; /* data bits 3455..3424 */
} NX90_MTGY_OP_TS107_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS107_BIT_T bf;
} NX90_MTGY_OP_TS107_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts108 */
/* => MWMM TS register 108 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts108  0x000013B0U
#define Adr_NX90_mtgy_mtgy_op_ts108 0xFF0833B0U
#define Adr_NX90_mtgy_op_ts108      0xFF0833B0U
#define DFLT_VAL_NX90_mtgy_op_ts108 0x00000000U

#define MSK_NX90_mtgy_op_ts108_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts108_val         0
#define DFLT_VAL_NX90_mtgy_op_ts108_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts108_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts108': */
#define MSK_USED_BITS_NX90_mtgy_op_ts108 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts108_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS108_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts108_val; /* data bits 3487..3456 */
} NX90_MTGY_OP_TS108_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS108_BIT_T bf;
} NX90_MTGY_OP_TS108_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts109 */
/* => MWMM TS register 109 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts109  0x000013B4U
#define Adr_NX90_mtgy_mtgy_op_ts109 0xFF0833B4U
#define Adr_NX90_mtgy_op_ts109      0xFF0833B4U
#define DFLT_VAL_NX90_mtgy_op_ts109 0x00000000U

#define MSK_NX90_mtgy_op_ts109_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts109_val         0
#define DFLT_VAL_NX90_mtgy_op_ts109_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts109_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts109': */
#define MSK_USED_BITS_NX90_mtgy_op_ts109 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts109_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS109_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts109_val; /* data bits 3519..3488 */
} NX90_MTGY_OP_TS109_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS109_BIT_T bf;
} NX90_MTGY_OP_TS109_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts110 */
/* => MWMM TS register 110 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts110  0x000013B8U
#define Adr_NX90_mtgy_mtgy_op_ts110 0xFF0833B8U
#define Adr_NX90_mtgy_op_ts110      0xFF0833B8U
#define DFLT_VAL_NX90_mtgy_op_ts110 0x00000000U

#define MSK_NX90_mtgy_op_ts110_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts110_val         0
#define DFLT_VAL_NX90_mtgy_op_ts110_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts110_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts110': */
#define MSK_USED_BITS_NX90_mtgy_op_ts110 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts110_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS110_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts110_val; /* data bits 3551..3520 */
} NX90_MTGY_OP_TS110_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS110_BIT_T bf;
} NX90_MTGY_OP_TS110_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts111 */
/* => MWMM TS register 111 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts111  0x000013BCU
#define Adr_NX90_mtgy_mtgy_op_ts111 0xFF0833BCU
#define Adr_NX90_mtgy_op_ts111      0xFF0833BCU
#define DFLT_VAL_NX90_mtgy_op_ts111 0x00000000U

#define MSK_NX90_mtgy_op_ts111_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts111_val         0
#define DFLT_VAL_NX90_mtgy_op_ts111_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts111_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts111': */
#define MSK_USED_BITS_NX90_mtgy_op_ts111 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts111_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS111_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts111_val; /* data bits 3583..3552 */
} NX90_MTGY_OP_TS111_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS111_BIT_T bf;
} NX90_MTGY_OP_TS111_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts112 */
/* => MWMM TS register 112 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts112  0x000013C0U
#define Adr_NX90_mtgy_mtgy_op_ts112 0xFF0833C0U
#define Adr_NX90_mtgy_op_ts112      0xFF0833C0U
#define DFLT_VAL_NX90_mtgy_op_ts112 0x00000000U

#define MSK_NX90_mtgy_op_ts112_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts112_val         0
#define DFLT_VAL_NX90_mtgy_op_ts112_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts112_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts112': */
#define MSK_USED_BITS_NX90_mtgy_op_ts112 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts112_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS112_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts112_val; /* data bits 3615..3584 */
} NX90_MTGY_OP_TS112_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS112_BIT_T bf;
} NX90_MTGY_OP_TS112_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts113 */
/* => MWMM TS register 113 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts113  0x000013C4U
#define Adr_NX90_mtgy_mtgy_op_ts113 0xFF0833C4U
#define Adr_NX90_mtgy_op_ts113      0xFF0833C4U
#define DFLT_VAL_NX90_mtgy_op_ts113 0x00000000U

#define MSK_NX90_mtgy_op_ts113_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts113_val         0
#define DFLT_VAL_NX90_mtgy_op_ts113_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts113_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts113': */
#define MSK_USED_BITS_NX90_mtgy_op_ts113 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts113_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS113_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts113_val; /* data bits 3647..3616 */
} NX90_MTGY_OP_TS113_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS113_BIT_T bf;
} NX90_MTGY_OP_TS113_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts114 */
/* => MWMM TS register 114 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts114  0x000013C8U
#define Adr_NX90_mtgy_mtgy_op_ts114 0xFF0833C8U
#define Adr_NX90_mtgy_op_ts114      0xFF0833C8U
#define DFLT_VAL_NX90_mtgy_op_ts114 0x00000000U

#define MSK_NX90_mtgy_op_ts114_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts114_val         0
#define DFLT_VAL_NX90_mtgy_op_ts114_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts114_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts114': */
#define MSK_USED_BITS_NX90_mtgy_op_ts114 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts114_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS114_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts114_val; /* data bits 3679..3648 */
} NX90_MTGY_OP_TS114_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS114_BIT_T bf;
} NX90_MTGY_OP_TS114_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts115 */
/* => MWMM TS register 115 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts115  0x000013CCU
#define Adr_NX90_mtgy_mtgy_op_ts115 0xFF0833CCU
#define Adr_NX90_mtgy_op_ts115      0xFF0833CCU
#define DFLT_VAL_NX90_mtgy_op_ts115 0x00000000U

#define MSK_NX90_mtgy_op_ts115_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts115_val         0
#define DFLT_VAL_NX90_mtgy_op_ts115_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts115_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts115': */
#define MSK_USED_BITS_NX90_mtgy_op_ts115 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts115_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS115_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts115_val; /* data bits 3711..3680 */
} NX90_MTGY_OP_TS115_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS115_BIT_T bf;
} NX90_MTGY_OP_TS115_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts116 */
/* => MWMM TS register 116 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts116  0x000013D0U
#define Adr_NX90_mtgy_mtgy_op_ts116 0xFF0833D0U
#define Adr_NX90_mtgy_op_ts116      0xFF0833D0U
#define DFLT_VAL_NX90_mtgy_op_ts116 0x00000000U

#define MSK_NX90_mtgy_op_ts116_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts116_val         0
#define DFLT_VAL_NX90_mtgy_op_ts116_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts116_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts116': */
#define MSK_USED_BITS_NX90_mtgy_op_ts116 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts116_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS116_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts116_val; /* data bits 3743..3712 */
} NX90_MTGY_OP_TS116_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS116_BIT_T bf;
} NX90_MTGY_OP_TS116_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts117 */
/* => MWMM TS register 117 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts117  0x000013D4U
#define Adr_NX90_mtgy_mtgy_op_ts117 0xFF0833D4U
#define Adr_NX90_mtgy_op_ts117      0xFF0833D4U
#define DFLT_VAL_NX90_mtgy_op_ts117 0x00000000U

#define MSK_NX90_mtgy_op_ts117_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts117_val         0
#define DFLT_VAL_NX90_mtgy_op_ts117_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts117_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts117': */
#define MSK_USED_BITS_NX90_mtgy_op_ts117 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts117_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS117_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts117_val; /* data bits 3775..3744 */
} NX90_MTGY_OP_TS117_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS117_BIT_T bf;
} NX90_MTGY_OP_TS117_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts118 */
/* => MWMM TS register 118 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts118  0x000013D8U
#define Adr_NX90_mtgy_mtgy_op_ts118 0xFF0833D8U
#define Adr_NX90_mtgy_op_ts118      0xFF0833D8U
#define DFLT_VAL_NX90_mtgy_op_ts118 0x00000000U

#define MSK_NX90_mtgy_op_ts118_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts118_val         0
#define DFLT_VAL_NX90_mtgy_op_ts118_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts118_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts118': */
#define MSK_USED_BITS_NX90_mtgy_op_ts118 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts118_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS118_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts118_val; /* data bits 3807..3776 */
} NX90_MTGY_OP_TS118_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS118_BIT_T bf;
} NX90_MTGY_OP_TS118_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts119 */
/* => MWMM TS register 119 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts119  0x000013DCU
#define Adr_NX90_mtgy_mtgy_op_ts119 0xFF0833DCU
#define Adr_NX90_mtgy_op_ts119      0xFF0833DCU
#define DFLT_VAL_NX90_mtgy_op_ts119 0x00000000U

#define MSK_NX90_mtgy_op_ts119_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts119_val         0
#define DFLT_VAL_NX90_mtgy_op_ts119_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts119_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts119': */
#define MSK_USED_BITS_NX90_mtgy_op_ts119 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts119_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS119_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts119_val; /* data bits 3839..3808 */
} NX90_MTGY_OP_TS119_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS119_BIT_T bf;
} NX90_MTGY_OP_TS119_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts120 */
/* => MWMM TS register 120 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts120  0x000013E0U
#define Adr_NX90_mtgy_mtgy_op_ts120 0xFF0833E0U
#define Adr_NX90_mtgy_op_ts120      0xFF0833E0U
#define DFLT_VAL_NX90_mtgy_op_ts120 0x00000000U

#define MSK_NX90_mtgy_op_ts120_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts120_val         0
#define DFLT_VAL_NX90_mtgy_op_ts120_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts120_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts120': */
#define MSK_USED_BITS_NX90_mtgy_op_ts120 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts120_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS120_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts120_val; /* data bits 3871..3840 */
} NX90_MTGY_OP_TS120_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS120_BIT_T bf;
} NX90_MTGY_OP_TS120_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts121 */
/* => MWMM TS register 121 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts121  0x000013E4U
#define Adr_NX90_mtgy_mtgy_op_ts121 0xFF0833E4U
#define Adr_NX90_mtgy_op_ts121      0xFF0833E4U
#define DFLT_VAL_NX90_mtgy_op_ts121 0x00000000U

#define MSK_NX90_mtgy_op_ts121_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts121_val         0
#define DFLT_VAL_NX90_mtgy_op_ts121_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts121_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts121': */
#define MSK_USED_BITS_NX90_mtgy_op_ts121 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts121_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS121_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts121_val; /* data bits 3903..3872 */
} NX90_MTGY_OP_TS121_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS121_BIT_T bf;
} NX90_MTGY_OP_TS121_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts122 */
/* => MWMM TS register 122 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts122  0x000013E8U
#define Adr_NX90_mtgy_mtgy_op_ts122 0xFF0833E8U
#define Adr_NX90_mtgy_op_ts122      0xFF0833E8U
#define DFLT_VAL_NX90_mtgy_op_ts122 0x00000000U

#define MSK_NX90_mtgy_op_ts122_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts122_val         0
#define DFLT_VAL_NX90_mtgy_op_ts122_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts122_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts122': */
#define MSK_USED_BITS_NX90_mtgy_op_ts122 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts122_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS122_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts122_val; /* data bits 3935..3904 */
} NX90_MTGY_OP_TS122_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS122_BIT_T bf;
} NX90_MTGY_OP_TS122_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts123 */
/* => MWMM TS register 123 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts123  0x000013ECU
#define Adr_NX90_mtgy_mtgy_op_ts123 0xFF0833ECU
#define Adr_NX90_mtgy_op_ts123      0xFF0833ECU
#define DFLT_VAL_NX90_mtgy_op_ts123 0x00000000U

#define MSK_NX90_mtgy_op_ts123_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts123_val         0
#define DFLT_VAL_NX90_mtgy_op_ts123_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts123_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts123': */
#define MSK_USED_BITS_NX90_mtgy_op_ts123 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts123_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS123_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts123_val; /* data bits 3967..3936 */
} NX90_MTGY_OP_TS123_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS123_BIT_T bf;
} NX90_MTGY_OP_TS123_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts124 */
/* => MWMM TS register 124 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts124  0x000013F0U
#define Adr_NX90_mtgy_mtgy_op_ts124 0xFF0833F0U
#define Adr_NX90_mtgy_op_ts124      0xFF0833F0U
#define DFLT_VAL_NX90_mtgy_op_ts124 0x00000000U

#define MSK_NX90_mtgy_op_ts124_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts124_val         0
#define DFLT_VAL_NX90_mtgy_op_ts124_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts124_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts124': */
#define MSK_USED_BITS_NX90_mtgy_op_ts124 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts124_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS124_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts124_val; /* data bits 3999..3968 */
} NX90_MTGY_OP_TS124_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS124_BIT_T bf;
} NX90_MTGY_OP_TS124_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts125 */
/* => MWMM TS register 125 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts125  0x000013F4U
#define Adr_NX90_mtgy_mtgy_op_ts125 0xFF0833F4U
#define Adr_NX90_mtgy_op_ts125      0xFF0833F4U
#define DFLT_VAL_NX90_mtgy_op_ts125 0x00000000U

#define MSK_NX90_mtgy_op_ts125_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts125_val         0
#define DFLT_VAL_NX90_mtgy_op_ts125_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts125_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts125': */
#define MSK_USED_BITS_NX90_mtgy_op_ts125 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts125_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS125_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts125_val; /* data bits 4031..4000 */
} NX90_MTGY_OP_TS125_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS125_BIT_T bf;
} NX90_MTGY_OP_TS125_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts126 */
/* => MWMM TS register 126 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts126  0x000013F8U
#define Adr_NX90_mtgy_mtgy_op_ts126 0xFF0833F8U
#define Adr_NX90_mtgy_op_ts126      0xFF0833F8U
#define DFLT_VAL_NX90_mtgy_op_ts126 0x00000000U

#define MSK_NX90_mtgy_op_ts126_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts126_val         0
#define DFLT_VAL_NX90_mtgy_op_ts126_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts126_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts126': */
#define MSK_USED_BITS_NX90_mtgy_op_ts126 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts126_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS126_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts126_val; /* data bits 4063..4032 */
} NX90_MTGY_OP_TS126_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS126_BIT_T bf;
} NX90_MTGY_OP_TS126_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_ts127 */
/* => MWMM TS register 127 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_ts127  0x000013FCU
#define Adr_NX90_mtgy_mtgy_op_ts127 0xFF0833FCU
#define Adr_NX90_mtgy_op_ts127      0xFF0833FCU
#define DFLT_VAL_NX90_mtgy_op_ts127 0x00000000U

#define MSK_NX90_mtgy_op_ts127_val         0xffffffffU
#define SRT_NX90_mtgy_op_ts127_val         0
#define DFLT_VAL_NX90_mtgy_op_ts127_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_ts127_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_ts127': */
#define MSK_USED_BITS_NX90_mtgy_op_ts127 0xffffffffU

enum {
  BFW_NX90_mtgy_op_ts127_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_TS127_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_ts127_val; /* data bits 4095..4064 */
} NX90_MTGY_OP_TS127_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_MTGY_OP_TS127_BIT_T bf;
} NX90_MTGY_OP_TS127_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p0 */
/* => MWMM operand P register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p0  0x00001400U
#define Adr_NX90_mtgy_mtgy_op_p0 0xFF083400U
#define Adr_NX90_mtgy_op_p0      0xFF083400U
#define DFLT_VAL_NX90_mtgy_op_p0 0x00000000U

#define MSK_NX90_mtgy_op_p0_val         0xffffffffU
#define SRT_NX90_mtgy_op_p0_val         0
#define DFLT_VAL_NX90_mtgy_op_p0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p0_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p0': */
#define MSK_USED_BITS_NX90_mtgy_op_p0 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p0_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P0_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p0_val; /* data bits 31..0 */
} NX90_MTGY_OP_P0_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P0_BIT_T bf;
} NX90_MTGY_OP_P0_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p1 */
/* => MWMM operand P register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p1  0x00001404U
#define Adr_NX90_mtgy_mtgy_op_p1 0xFF083404U
#define Adr_NX90_mtgy_op_p1      0xFF083404U
#define DFLT_VAL_NX90_mtgy_op_p1 0x00000000U

#define MSK_NX90_mtgy_op_p1_val         0xffffffffU
#define SRT_NX90_mtgy_op_p1_val         0
#define DFLT_VAL_NX90_mtgy_op_p1_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p1_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p1': */
#define MSK_USED_BITS_NX90_mtgy_op_p1 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p1_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P1_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p1_val; /* data bits 63..32 */
} NX90_MTGY_OP_P1_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P1_BIT_T bf;
} NX90_MTGY_OP_P1_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p2 */
/* => MWMM operand P register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p2  0x00001408U
#define Adr_NX90_mtgy_mtgy_op_p2 0xFF083408U
#define Adr_NX90_mtgy_op_p2      0xFF083408U
#define DFLT_VAL_NX90_mtgy_op_p2 0x00000000U

#define MSK_NX90_mtgy_op_p2_val         0xffffffffU
#define SRT_NX90_mtgy_op_p2_val         0
#define DFLT_VAL_NX90_mtgy_op_p2_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p2_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p2': */
#define MSK_USED_BITS_NX90_mtgy_op_p2 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p2_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P2_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p2_val; /* data bits 95..64 */
} NX90_MTGY_OP_P2_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P2_BIT_T bf;
} NX90_MTGY_OP_P2_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p3 */
/* => MWMM operand P register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p3  0x0000140CU
#define Adr_NX90_mtgy_mtgy_op_p3 0xFF08340CU
#define Adr_NX90_mtgy_op_p3      0xFF08340CU
#define DFLT_VAL_NX90_mtgy_op_p3 0x00000000U

#define MSK_NX90_mtgy_op_p3_val         0xffffffffU
#define SRT_NX90_mtgy_op_p3_val         0
#define DFLT_VAL_NX90_mtgy_op_p3_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p3_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p3': */
#define MSK_USED_BITS_NX90_mtgy_op_p3 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p3_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P3_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p3_val; /* data bits 127..96 */
} NX90_MTGY_OP_P3_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P3_BIT_T bf;
} NX90_MTGY_OP_P3_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p4 */
/* => MWMM operand P register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p4  0x00001410U
#define Adr_NX90_mtgy_mtgy_op_p4 0xFF083410U
#define Adr_NX90_mtgy_op_p4      0xFF083410U
#define DFLT_VAL_NX90_mtgy_op_p4 0x00000000U

#define MSK_NX90_mtgy_op_p4_val         0xffffffffU
#define SRT_NX90_mtgy_op_p4_val         0
#define DFLT_VAL_NX90_mtgy_op_p4_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p4_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p4': */
#define MSK_USED_BITS_NX90_mtgy_op_p4 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p4_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P4_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p4_val; /* data bits 159..128 */
} NX90_MTGY_OP_P4_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P4_BIT_T bf;
} NX90_MTGY_OP_P4_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p5 */
/* => MWMM operand P register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p5  0x00001414U
#define Adr_NX90_mtgy_mtgy_op_p5 0xFF083414U
#define Adr_NX90_mtgy_op_p5      0xFF083414U
#define DFLT_VAL_NX90_mtgy_op_p5 0x00000000U

#define MSK_NX90_mtgy_op_p5_val         0xffffffffU
#define SRT_NX90_mtgy_op_p5_val         0
#define DFLT_VAL_NX90_mtgy_op_p5_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p5_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p5': */
#define MSK_USED_BITS_NX90_mtgy_op_p5 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p5_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P5_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p5_val; /* data bits 191..160 */
} NX90_MTGY_OP_P5_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P5_BIT_T bf;
} NX90_MTGY_OP_P5_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p6 */
/* => MWMM operand P register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p6  0x00001418U
#define Adr_NX90_mtgy_mtgy_op_p6 0xFF083418U
#define Adr_NX90_mtgy_op_p6      0xFF083418U
#define DFLT_VAL_NX90_mtgy_op_p6 0x00000000U

#define MSK_NX90_mtgy_op_p6_val         0xffffffffU
#define SRT_NX90_mtgy_op_p6_val         0
#define DFLT_VAL_NX90_mtgy_op_p6_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p6_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p6': */
#define MSK_USED_BITS_NX90_mtgy_op_p6 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p6_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P6_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p6_val; /* data bits 223..192 */
} NX90_MTGY_OP_P6_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P6_BIT_T bf;
} NX90_MTGY_OP_P6_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p7 */
/* => MWMM operand P register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p7  0x0000141CU
#define Adr_NX90_mtgy_mtgy_op_p7 0xFF08341CU
#define Adr_NX90_mtgy_op_p7      0xFF08341CU
#define DFLT_VAL_NX90_mtgy_op_p7 0x00000000U

#define MSK_NX90_mtgy_op_p7_val         0xffffffffU
#define SRT_NX90_mtgy_op_p7_val         0
#define DFLT_VAL_NX90_mtgy_op_p7_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p7_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p7': */
#define MSK_USED_BITS_NX90_mtgy_op_p7 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p7_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P7_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p7_val; /* data bits 255..224 */
} NX90_MTGY_OP_P7_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P7_BIT_T bf;
} NX90_MTGY_OP_P7_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p8 */
/* => MWMM operand P register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p8  0x00001420U
#define Adr_NX90_mtgy_mtgy_op_p8 0xFF083420U
#define Adr_NX90_mtgy_op_p8      0xFF083420U
#define DFLT_VAL_NX90_mtgy_op_p8 0x00000000U

#define MSK_NX90_mtgy_op_p8_val         0xffffffffU
#define SRT_NX90_mtgy_op_p8_val         0
#define DFLT_VAL_NX90_mtgy_op_p8_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p8_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p8': */
#define MSK_USED_BITS_NX90_mtgy_op_p8 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p8_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P8_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p8_val; /* data bits 287..256 */
} NX90_MTGY_OP_P8_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P8_BIT_T bf;
} NX90_MTGY_OP_P8_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p9 */
/* => MWMM operand P register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p9  0x00001424U
#define Adr_NX90_mtgy_mtgy_op_p9 0xFF083424U
#define Adr_NX90_mtgy_op_p9      0xFF083424U
#define DFLT_VAL_NX90_mtgy_op_p9 0x00000000U

#define MSK_NX90_mtgy_op_p9_val         0xffffffffU
#define SRT_NX90_mtgy_op_p9_val         0
#define DFLT_VAL_NX90_mtgy_op_p9_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p9_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p9': */
#define MSK_USED_BITS_NX90_mtgy_op_p9 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p9_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P9_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p9_val; /* data bits 319..288 */
} NX90_MTGY_OP_P9_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_P9_BIT_T bf;
} NX90_MTGY_OP_P9_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p10 */
/* => MWMM operand P register 10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p10  0x00001428U
#define Adr_NX90_mtgy_mtgy_op_p10 0xFF083428U
#define Adr_NX90_mtgy_op_p10      0xFF083428U
#define DFLT_VAL_NX90_mtgy_op_p10 0x00000000U

#define MSK_NX90_mtgy_op_p10_val         0xffffffffU
#define SRT_NX90_mtgy_op_p10_val         0
#define DFLT_VAL_NX90_mtgy_op_p10_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p10_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p10': */
#define MSK_USED_BITS_NX90_mtgy_op_p10 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p10_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P10_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p10_val; /* data bits 351..320 */
} NX90_MTGY_OP_P10_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P10_BIT_T bf;
} NX90_MTGY_OP_P10_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p11 */
/* => MWMM operand P register 11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p11  0x0000142CU
#define Adr_NX90_mtgy_mtgy_op_p11 0xFF08342CU
#define Adr_NX90_mtgy_op_p11      0xFF08342CU
#define DFLT_VAL_NX90_mtgy_op_p11 0x00000000U

#define MSK_NX90_mtgy_op_p11_val         0xffffffffU
#define SRT_NX90_mtgy_op_p11_val         0
#define DFLT_VAL_NX90_mtgy_op_p11_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p11_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p11': */
#define MSK_USED_BITS_NX90_mtgy_op_p11 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p11_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P11_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p11_val; /* data bits 383..352 */
} NX90_MTGY_OP_P11_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P11_BIT_T bf;
} NX90_MTGY_OP_P11_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p12 */
/* => MWMM operand P register 12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p12  0x00001430U
#define Adr_NX90_mtgy_mtgy_op_p12 0xFF083430U
#define Adr_NX90_mtgy_op_p12      0xFF083430U
#define DFLT_VAL_NX90_mtgy_op_p12 0x00000000U

#define MSK_NX90_mtgy_op_p12_val         0xffffffffU
#define SRT_NX90_mtgy_op_p12_val         0
#define DFLT_VAL_NX90_mtgy_op_p12_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p12_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p12': */
#define MSK_USED_BITS_NX90_mtgy_op_p12 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p12_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P12_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p12_val; /* data bits 415..384 */
} NX90_MTGY_OP_P12_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P12_BIT_T bf;
} NX90_MTGY_OP_P12_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p13 */
/* => MWMM operand P register 13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p13  0x00001434U
#define Adr_NX90_mtgy_mtgy_op_p13 0xFF083434U
#define Adr_NX90_mtgy_op_p13      0xFF083434U
#define DFLT_VAL_NX90_mtgy_op_p13 0x00000000U

#define MSK_NX90_mtgy_op_p13_val         0xffffffffU
#define SRT_NX90_mtgy_op_p13_val         0
#define DFLT_VAL_NX90_mtgy_op_p13_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p13_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p13': */
#define MSK_USED_BITS_NX90_mtgy_op_p13 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p13_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P13_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p13_val; /* data bits 447..416 */
} NX90_MTGY_OP_P13_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P13_BIT_T bf;
} NX90_MTGY_OP_P13_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p14 */
/* => MWMM operand P register 14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p14  0x00001438U
#define Adr_NX90_mtgy_mtgy_op_p14 0xFF083438U
#define Adr_NX90_mtgy_op_p14      0xFF083438U
#define DFLT_VAL_NX90_mtgy_op_p14 0x00000000U

#define MSK_NX90_mtgy_op_p14_val         0xffffffffU
#define SRT_NX90_mtgy_op_p14_val         0
#define DFLT_VAL_NX90_mtgy_op_p14_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p14_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p14': */
#define MSK_USED_BITS_NX90_mtgy_op_p14 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p14_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P14_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p14_val; /* data bits 479..448 */
} NX90_MTGY_OP_P14_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P14_BIT_T bf;
} NX90_MTGY_OP_P14_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p15 */
/* => MWMM operand P register 15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p15  0x0000143CU
#define Adr_NX90_mtgy_mtgy_op_p15 0xFF08343CU
#define Adr_NX90_mtgy_op_p15      0xFF08343CU
#define DFLT_VAL_NX90_mtgy_op_p15 0x00000000U

#define MSK_NX90_mtgy_op_p15_val         0xffffffffU
#define SRT_NX90_mtgy_op_p15_val         0
#define DFLT_VAL_NX90_mtgy_op_p15_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p15_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p15': */
#define MSK_USED_BITS_NX90_mtgy_op_p15 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p15_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P15_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p15_val; /* data bits 511..480 */
} NX90_MTGY_OP_P15_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P15_BIT_T bf;
} NX90_MTGY_OP_P15_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p16 */
/* => MWMM operand P register 16 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p16  0x00001440U
#define Adr_NX90_mtgy_mtgy_op_p16 0xFF083440U
#define Adr_NX90_mtgy_op_p16      0xFF083440U
#define DFLT_VAL_NX90_mtgy_op_p16 0x00000000U

#define MSK_NX90_mtgy_op_p16_val         0xffffffffU
#define SRT_NX90_mtgy_op_p16_val         0
#define DFLT_VAL_NX90_mtgy_op_p16_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p16_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p16': */
#define MSK_USED_BITS_NX90_mtgy_op_p16 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p16_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P16_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p16_val; /* data bits 543..512 */
} NX90_MTGY_OP_P16_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P16_BIT_T bf;
} NX90_MTGY_OP_P16_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p17 */
/* => MWMM operand P register 17 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p17  0x00001444U
#define Adr_NX90_mtgy_mtgy_op_p17 0xFF083444U
#define Adr_NX90_mtgy_op_p17      0xFF083444U
#define DFLT_VAL_NX90_mtgy_op_p17 0x00000000U

#define MSK_NX90_mtgy_op_p17_val         0xffffffffU
#define SRT_NX90_mtgy_op_p17_val         0
#define DFLT_VAL_NX90_mtgy_op_p17_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p17_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p17': */
#define MSK_USED_BITS_NX90_mtgy_op_p17 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p17_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P17_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p17_val; /* data bits 575..544 */
} NX90_MTGY_OP_P17_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P17_BIT_T bf;
} NX90_MTGY_OP_P17_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p18 */
/* => MWMM operand P register 18 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p18  0x00001448U
#define Adr_NX90_mtgy_mtgy_op_p18 0xFF083448U
#define Adr_NX90_mtgy_op_p18      0xFF083448U
#define DFLT_VAL_NX90_mtgy_op_p18 0x00000000U

#define MSK_NX90_mtgy_op_p18_val         0xffffffffU
#define SRT_NX90_mtgy_op_p18_val         0
#define DFLT_VAL_NX90_mtgy_op_p18_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p18_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p18': */
#define MSK_USED_BITS_NX90_mtgy_op_p18 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p18_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P18_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p18_val; /* data bits 607..576 */
} NX90_MTGY_OP_P18_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P18_BIT_T bf;
} NX90_MTGY_OP_P18_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p19 */
/* => MWMM operand P register 19 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p19  0x0000144CU
#define Adr_NX90_mtgy_mtgy_op_p19 0xFF08344CU
#define Adr_NX90_mtgy_op_p19      0xFF08344CU
#define DFLT_VAL_NX90_mtgy_op_p19 0x00000000U

#define MSK_NX90_mtgy_op_p19_val         0xffffffffU
#define SRT_NX90_mtgy_op_p19_val         0
#define DFLT_VAL_NX90_mtgy_op_p19_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p19_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p19': */
#define MSK_USED_BITS_NX90_mtgy_op_p19 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p19_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P19_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p19_val; /* data bits 639..608 */
} NX90_MTGY_OP_P19_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P19_BIT_T bf;
} NX90_MTGY_OP_P19_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p20 */
/* => MWMM operand P register 20 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p20  0x00001450U
#define Adr_NX90_mtgy_mtgy_op_p20 0xFF083450U
#define Adr_NX90_mtgy_op_p20      0xFF083450U
#define DFLT_VAL_NX90_mtgy_op_p20 0x00000000U

#define MSK_NX90_mtgy_op_p20_val         0xffffffffU
#define SRT_NX90_mtgy_op_p20_val         0
#define DFLT_VAL_NX90_mtgy_op_p20_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p20_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p20': */
#define MSK_USED_BITS_NX90_mtgy_op_p20 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p20_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P20_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p20_val; /* data bits 671..640 */
} NX90_MTGY_OP_P20_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P20_BIT_T bf;
} NX90_MTGY_OP_P20_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p21 */
/* => MWMM operand P register 21 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p21  0x00001454U
#define Adr_NX90_mtgy_mtgy_op_p21 0xFF083454U
#define Adr_NX90_mtgy_op_p21      0xFF083454U
#define DFLT_VAL_NX90_mtgy_op_p21 0x00000000U

#define MSK_NX90_mtgy_op_p21_val         0xffffffffU
#define SRT_NX90_mtgy_op_p21_val         0
#define DFLT_VAL_NX90_mtgy_op_p21_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p21_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p21': */
#define MSK_USED_BITS_NX90_mtgy_op_p21 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p21_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P21_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p21_val; /* data bits 703..672 */
} NX90_MTGY_OP_P21_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P21_BIT_T bf;
} NX90_MTGY_OP_P21_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p22 */
/* => MWMM operand P register 22 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p22  0x00001458U
#define Adr_NX90_mtgy_mtgy_op_p22 0xFF083458U
#define Adr_NX90_mtgy_op_p22      0xFF083458U
#define DFLT_VAL_NX90_mtgy_op_p22 0x00000000U

#define MSK_NX90_mtgy_op_p22_val         0xffffffffU
#define SRT_NX90_mtgy_op_p22_val         0
#define DFLT_VAL_NX90_mtgy_op_p22_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p22_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p22': */
#define MSK_USED_BITS_NX90_mtgy_op_p22 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p22_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P22_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p22_val; /* data bits 735..704 */
} NX90_MTGY_OP_P22_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P22_BIT_T bf;
} NX90_MTGY_OP_P22_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p23 */
/* => MWMM operand P register 23 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p23  0x0000145CU
#define Adr_NX90_mtgy_mtgy_op_p23 0xFF08345CU
#define Adr_NX90_mtgy_op_p23      0xFF08345CU
#define DFLT_VAL_NX90_mtgy_op_p23 0x00000000U

#define MSK_NX90_mtgy_op_p23_val         0xffffffffU
#define SRT_NX90_mtgy_op_p23_val         0
#define DFLT_VAL_NX90_mtgy_op_p23_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p23_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p23': */
#define MSK_USED_BITS_NX90_mtgy_op_p23 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p23_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P23_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p23_val; /* data bits 767..736 */
} NX90_MTGY_OP_P23_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P23_BIT_T bf;
} NX90_MTGY_OP_P23_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p24 */
/* => MWMM operand P register 24 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p24  0x00001460U
#define Adr_NX90_mtgy_mtgy_op_p24 0xFF083460U
#define Adr_NX90_mtgy_op_p24      0xFF083460U
#define DFLT_VAL_NX90_mtgy_op_p24 0x00000000U

#define MSK_NX90_mtgy_op_p24_val         0xffffffffU
#define SRT_NX90_mtgy_op_p24_val         0
#define DFLT_VAL_NX90_mtgy_op_p24_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p24_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p24': */
#define MSK_USED_BITS_NX90_mtgy_op_p24 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p24_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P24_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p24_val; /* data bits 799..768 */
} NX90_MTGY_OP_P24_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P24_BIT_T bf;
} NX90_MTGY_OP_P24_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p25 */
/* => MWMM operand P register 25 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p25  0x00001464U
#define Adr_NX90_mtgy_mtgy_op_p25 0xFF083464U
#define Adr_NX90_mtgy_op_p25      0xFF083464U
#define DFLT_VAL_NX90_mtgy_op_p25 0x00000000U

#define MSK_NX90_mtgy_op_p25_val         0xffffffffU
#define SRT_NX90_mtgy_op_p25_val         0
#define DFLT_VAL_NX90_mtgy_op_p25_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p25_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p25': */
#define MSK_USED_BITS_NX90_mtgy_op_p25 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p25_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P25_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p25_val; /* data bits 831..800 */
} NX90_MTGY_OP_P25_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P25_BIT_T bf;
} NX90_MTGY_OP_P25_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p26 */
/* => MWMM operand P register 26 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p26  0x00001468U
#define Adr_NX90_mtgy_mtgy_op_p26 0xFF083468U
#define Adr_NX90_mtgy_op_p26      0xFF083468U
#define DFLT_VAL_NX90_mtgy_op_p26 0x00000000U

#define MSK_NX90_mtgy_op_p26_val         0xffffffffU
#define SRT_NX90_mtgy_op_p26_val         0
#define DFLT_VAL_NX90_mtgy_op_p26_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p26_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p26': */
#define MSK_USED_BITS_NX90_mtgy_op_p26 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p26_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P26_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p26_val; /* data bits 863..832 */
} NX90_MTGY_OP_P26_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P26_BIT_T bf;
} NX90_MTGY_OP_P26_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p27 */
/* => MWMM operand P register 27 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p27  0x0000146CU
#define Adr_NX90_mtgy_mtgy_op_p27 0xFF08346CU
#define Adr_NX90_mtgy_op_p27      0xFF08346CU
#define DFLT_VAL_NX90_mtgy_op_p27 0x00000000U

#define MSK_NX90_mtgy_op_p27_val         0xffffffffU
#define SRT_NX90_mtgy_op_p27_val         0
#define DFLT_VAL_NX90_mtgy_op_p27_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p27_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p27': */
#define MSK_USED_BITS_NX90_mtgy_op_p27 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p27_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P27_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p27_val; /* data bits 895..864 */
} NX90_MTGY_OP_P27_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P27_BIT_T bf;
} NX90_MTGY_OP_P27_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p28 */
/* => MWMM operand P register 28 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p28  0x00001470U
#define Adr_NX90_mtgy_mtgy_op_p28 0xFF083470U
#define Adr_NX90_mtgy_op_p28      0xFF083470U
#define DFLT_VAL_NX90_mtgy_op_p28 0x00000000U

#define MSK_NX90_mtgy_op_p28_val         0xffffffffU
#define SRT_NX90_mtgy_op_p28_val         0
#define DFLT_VAL_NX90_mtgy_op_p28_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p28_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p28': */
#define MSK_USED_BITS_NX90_mtgy_op_p28 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p28_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P28_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p28_val; /* data bits 927..896 */
} NX90_MTGY_OP_P28_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P28_BIT_T bf;
} NX90_MTGY_OP_P28_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p29 */
/* => MWMM operand P register 29 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p29  0x00001474U
#define Adr_NX90_mtgy_mtgy_op_p29 0xFF083474U
#define Adr_NX90_mtgy_op_p29      0xFF083474U
#define DFLT_VAL_NX90_mtgy_op_p29 0x00000000U

#define MSK_NX90_mtgy_op_p29_val         0xffffffffU
#define SRT_NX90_mtgy_op_p29_val         0
#define DFLT_VAL_NX90_mtgy_op_p29_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p29_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p29': */
#define MSK_USED_BITS_NX90_mtgy_op_p29 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p29_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P29_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p29_val; /* data bits 959..928 */
} NX90_MTGY_OP_P29_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P29_BIT_T bf;
} NX90_MTGY_OP_P29_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p30 */
/* => MWMM operand P register 30 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p30  0x00001478U
#define Adr_NX90_mtgy_mtgy_op_p30 0xFF083478U
#define Adr_NX90_mtgy_op_p30      0xFF083478U
#define DFLT_VAL_NX90_mtgy_op_p30 0x00000000U

#define MSK_NX90_mtgy_op_p30_val         0xffffffffU
#define SRT_NX90_mtgy_op_p30_val         0
#define DFLT_VAL_NX90_mtgy_op_p30_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p30_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p30': */
#define MSK_USED_BITS_NX90_mtgy_op_p30 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p30_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P30_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p30_val; /* data bits 991..960 */
} NX90_MTGY_OP_P30_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P30_BIT_T bf;
} NX90_MTGY_OP_P30_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p31 */
/* => MWMM operand P register 31 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p31  0x0000147CU
#define Adr_NX90_mtgy_mtgy_op_p31 0xFF08347CU
#define Adr_NX90_mtgy_op_p31      0xFF08347CU
#define DFLT_VAL_NX90_mtgy_op_p31 0x00000000U

#define MSK_NX90_mtgy_op_p31_val         0xffffffffU
#define SRT_NX90_mtgy_op_p31_val         0
#define DFLT_VAL_NX90_mtgy_op_p31_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p31_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p31': */
#define MSK_USED_BITS_NX90_mtgy_op_p31 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p31_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P31_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p31_val; /* data bits 1023..992 */
} NX90_MTGY_OP_P31_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P31_BIT_T bf;
} NX90_MTGY_OP_P31_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p32 */
/* => MWMM operand P register 32 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p32  0x00001480U
#define Adr_NX90_mtgy_mtgy_op_p32 0xFF083480U
#define Adr_NX90_mtgy_op_p32      0xFF083480U
#define DFLT_VAL_NX90_mtgy_op_p32 0x00000000U

#define MSK_NX90_mtgy_op_p32_val         0xffffffffU
#define SRT_NX90_mtgy_op_p32_val         0
#define DFLT_VAL_NX90_mtgy_op_p32_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p32_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p32': */
#define MSK_USED_BITS_NX90_mtgy_op_p32 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p32_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P32_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p32_val; /* data bits 1055..1024 */
} NX90_MTGY_OP_P32_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P32_BIT_T bf;
} NX90_MTGY_OP_P32_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p33 */
/* => MWMM operand P register 33 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p33  0x00001484U
#define Adr_NX90_mtgy_mtgy_op_p33 0xFF083484U
#define Adr_NX90_mtgy_op_p33      0xFF083484U
#define DFLT_VAL_NX90_mtgy_op_p33 0x00000000U

#define MSK_NX90_mtgy_op_p33_val         0xffffffffU
#define SRT_NX90_mtgy_op_p33_val         0
#define DFLT_VAL_NX90_mtgy_op_p33_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p33_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p33': */
#define MSK_USED_BITS_NX90_mtgy_op_p33 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p33_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P33_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p33_val; /* data bits 1087..1056 */
} NX90_MTGY_OP_P33_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P33_BIT_T bf;
} NX90_MTGY_OP_P33_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p34 */
/* => MWMM operand P register 34 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p34  0x00001488U
#define Adr_NX90_mtgy_mtgy_op_p34 0xFF083488U
#define Adr_NX90_mtgy_op_p34      0xFF083488U
#define DFLT_VAL_NX90_mtgy_op_p34 0x00000000U

#define MSK_NX90_mtgy_op_p34_val         0xffffffffU
#define SRT_NX90_mtgy_op_p34_val         0
#define DFLT_VAL_NX90_mtgy_op_p34_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p34_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p34': */
#define MSK_USED_BITS_NX90_mtgy_op_p34 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p34_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P34_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p34_val; /* data bits 1119..1088 */
} NX90_MTGY_OP_P34_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P34_BIT_T bf;
} NX90_MTGY_OP_P34_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p35 */
/* => MWMM operand P register 35 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p35  0x0000148CU
#define Adr_NX90_mtgy_mtgy_op_p35 0xFF08348CU
#define Adr_NX90_mtgy_op_p35      0xFF08348CU
#define DFLT_VAL_NX90_mtgy_op_p35 0x00000000U

#define MSK_NX90_mtgy_op_p35_val         0xffffffffU
#define SRT_NX90_mtgy_op_p35_val         0
#define DFLT_VAL_NX90_mtgy_op_p35_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p35_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p35': */
#define MSK_USED_BITS_NX90_mtgy_op_p35 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p35_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P35_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p35_val; /* data bits 1151..1120 */
} NX90_MTGY_OP_P35_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P35_BIT_T bf;
} NX90_MTGY_OP_P35_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p36 */
/* => MWMM operand P register 36 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p36  0x00001490U
#define Adr_NX90_mtgy_mtgy_op_p36 0xFF083490U
#define Adr_NX90_mtgy_op_p36      0xFF083490U
#define DFLT_VAL_NX90_mtgy_op_p36 0x00000000U

#define MSK_NX90_mtgy_op_p36_val         0xffffffffU
#define SRT_NX90_mtgy_op_p36_val         0
#define DFLT_VAL_NX90_mtgy_op_p36_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p36_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p36': */
#define MSK_USED_BITS_NX90_mtgy_op_p36 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p36_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P36_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p36_val; /* data bits 1183..1152 */
} NX90_MTGY_OP_P36_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P36_BIT_T bf;
} NX90_MTGY_OP_P36_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p37 */
/* => MWMM operand P register 37 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p37  0x00001494U
#define Adr_NX90_mtgy_mtgy_op_p37 0xFF083494U
#define Adr_NX90_mtgy_op_p37      0xFF083494U
#define DFLT_VAL_NX90_mtgy_op_p37 0x00000000U

#define MSK_NX90_mtgy_op_p37_val         0xffffffffU
#define SRT_NX90_mtgy_op_p37_val         0
#define DFLT_VAL_NX90_mtgy_op_p37_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p37_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p37': */
#define MSK_USED_BITS_NX90_mtgy_op_p37 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p37_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P37_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p37_val; /* data bits 1215..1184 */
} NX90_MTGY_OP_P37_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P37_BIT_T bf;
} NX90_MTGY_OP_P37_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p38 */
/* => MWMM operand P register 38 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p38  0x00001498U
#define Adr_NX90_mtgy_mtgy_op_p38 0xFF083498U
#define Adr_NX90_mtgy_op_p38      0xFF083498U
#define DFLT_VAL_NX90_mtgy_op_p38 0x00000000U

#define MSK_NX90_mtgy_op_p38_val         0xffffffffU
#define SRT_NX90_mtgy_op_p38_val         0
#define DFLT_VAL_NX90_mtgy_op_p38_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p38_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p38': */
#define MSK_USED_BITS_NX90_mtgy_op_p38 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p38_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P38_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p38_val; /* data bits 1247..1216 */
} NX90_MTGY_OP_P38_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P38_BIT_T bf;
} NX90_MTGY_OP_P38_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p39 */
/* => MWMM operand P register 39 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p39  0x0000149CU
#define Adr_NX90_mtgy_mtgy_op_p39 0xFF08349CU
#define Adr_NX90_mtgy_op_p39      0xFF08349CU
#define DFLT_VAL_NX90_mtgy_op_p39 0x00000000U

#define MSK_NX90_mtgy_op_p39_val         0xffffffffU
#define SRT_NX90_mtgy_op_p39_val         0
#define DFLT_VAL_NX90_mtgy_op_p39_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p39_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p39': */
#define MSK_USED_BITS_NX90_mtgy_op_p39 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p39_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P39_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p39_val; /* data bits 1279..1248 */
} NX90_MTGY_OP_P39_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P39_BIT_T bf;
} NX90_MTGY_OP_P39_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p40 */
/* => MWMM operand P register 40 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p40  0x000014A0U
#define Adr_NX90_mtgy_mtgy_op_p40 0xFF0834A0U
#define Adr_NX90_mtgy_op_p40      0xFF0834A0U
#define DFLT_VAL_NX90_mtgy_op_p40 0x00000000U

#define MSK_NX90_mtgy_op_p40_val         0xffffffffU
#define SRT_NX90_mtgy_op_p40_val         0
#define DFLT_VAL_NX90_mtgy_op_p40_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p40_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p40': */
#define MSK_USED_BITS_NX90_mtgy_op_p40 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p40_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P40_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p40_val; /* data bits 1311..1280 */
} NX90_MTGY_OP_P40_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P40_BIT_T bf;
} NX90_MTGY_OP_P40_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p41 */
/* => MWMM operand P register 41 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p41  0x000014A4U
#define Adr_NX90_mtgy_mtgy_op_p41 0xFF0834A4U
#define Adr_NX90_mtgy_op_p41      0xFF0834A4U
#define DFLT_VAL_NX90_mtgy_op_p41 0x00000000U

#define MSK_NX90_mtgy_op_p41_val         0xffffffffU
#define SRT_NX90_mtgy_op_p41_val         0
#define DFLT_VAL_NX90_mtgy_op_p41_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p41_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p41': */
#define MSK_USED_BITS_NX90_mtgy_op_p41 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p41_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P41_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p41_val; /* data bits 1343..1312 */
} NX90_MTGY_OP_P41_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P41_BIT_T bf;
} NX90_MTGY_OP_P41_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p42 */
/* => MWMM operand P register 42 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p42  0x000014A8U
#define Adr_NX90_mtgy_mtgy_op_p42 0xFF0834A8U
#define Adr_NX90_mtgy_op_p42      0xFF0834A8U
#define DFLT_VAL_NX90_mtgy_op_p42 0x00000000U

#define MSK_NX90_mtgy_op_p42_val         0xffffffffU
#define SRT_NX90_mtgy_op_p42_val         0
#define DFLT_VAL_NX90_mtgy_op_p42_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p42_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p42': */
#define MSK_USED_BITS_NX90_mtgy_op_p42 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p42_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P42_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p42_val; /* data bits 1375..1344 */
} NX90_MTGY_OP_P42_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P42_BIT_T bf;
} NX90_MTGY_OP_P42_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p43 */
/* => MWMM operand P register 43 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p43  0x000014ACU
#define Adr_NX90_mtgy_mtgy_op_p43 0xFF0834ACU
#define Adr_NX90_mtgy_op_p43      0xFF0834ACU
#define DFLT_VAL_NX90_mtgy_op_p43 0x00000000U

#define MSK_NX90_mtgy_op_p43_val         0xffffffffU
#define SRT_NX90_mtgy_op_p43_val         0
#define DFLT_VAL_NX90_mtgy_op_p43_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p43_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p43': */
#define MSK_USED_BITS_NX90_mtgy_op_p43 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p43_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P43_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p43_val; /* data bits 1407..1376 */
} NX90_MTGY_OP_P43_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P43_BIT_T bf;
} NX90_MTGY_OP_P43_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p44 */
/* => MWMM operand P register 44 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p44  0x000014B0U
#define Adr_NX90_mtgy_mtgy_op_p44 0xFF0834B0U
#define Adr_NX90_mtgy_op_p44      0xFF0834B0U
#define DFLT_VAL_NX90_mtgy_op_p44 0x00000000U

#define MSK_NX90_mtgy_op_p44_val         0xffffffffU
#define SRT_NX90_mtgy_op_p44_val         0
#define DFLT_VAL_NX90_mtgy_op_p44_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p44_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p44': */
#define MSK_USED_BITS_NX90_mtgy_op_p44 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p44_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P44_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p44_val; /* data bits 1439..1408 */
} NX90_MTGY_OP_P44_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P44_BIT_T bf;
} NX90_MTGY_OP_P44_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p45 */
/* => MWMM operand P register 45 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p45  0x000014B4U
#define Adr_NX90_mtgy_mtgy_op_p45 0xFF0834B4U
#define Adr_NX90_mtgy_op_p45      0xFF0834B4U
#define DFLT_VAL_NX90_mtgy_op_p45 0x00000000U

#define MSK_NX90_mtgy_op_p45_val         0xffffffffU
#define SRT_NX90_mtgy_op_p45_val         0
#define DFLT_VAL_NX90_mtgy_op_p45_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p45_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p45': */
#define MSK_USED_BITS_NX90_mtgy_op_p45 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p45_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P45_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p45_val; /* data bits 1471..1440 */
} NX90_MTGY_OP_P45_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P45_BIT_T bf;
} NX90_MTGY_OP_P45_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p46 */
/* => MWMM operand P register 46 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p46  0x000014B8U
#define Adr_NX90_mtgy_mtgy_op_p46 0xFF0834B8U
#define Adr_NX90_mtgy_op_p46      0xFF0834B8U
#define DFLT_VAL_NX90_mtgy_op_p46 0x00000000U

#define MSK_NX90_mtgy_op_p46_val         0xffffffffU
#define SRT_NX90_mtgy_op_p46_val         0
#define DFLT_VAL_NX90_mtgy_op_p46_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p46_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p46': */
#define MSK_USED_BITS_NX90_mtgy_op_p46 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p46_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P46_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p46_val; /* data bits 1503..1472 */
} NX90_MTGY_OP_P46_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P46_BIT_T bf;
} NX90_MTGY_OP_P46_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p47 */
/* => MWMM operand P register 47 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p47  0x000014BCU
#define Adr_NX90_mtgy_mtgy_op_p47 0xFF0834BCU
#define Adr_NX90_mtgy_op_p47      0xFF0834BCU
#define DFLT_VAL_NX90_mtgy_op_p47 0x00000000U

#define MSK_NX90_mtgy_op_p47_val         0xffffffffU
#define SRT_NX90_mtgy_op_p47_val         0
#define DFLT_VAL_NX90_mtgy_op_p47_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p47_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p47': */
#define MSK_USED_BITS_NX90_mtgy_op_p47 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p47_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P47_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p47_val; /* data bits 1535..1504 */
} NX90_MTGY_OP_P47_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P47_BIT_T bf;
} NX90_MTGY_OP_P47_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p48 */
/* => MWMM operand P register 48 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p48  0x000014C0U
#define Adr_NX90_mtgy_mtgy_op_p48 0xFF0834C0U
#define Adr_NX90_mtgy_op_p48      0xFF0834C0U
#define DFLT_VAL_NX90_mtgy_op_p48 0x00000000U

#define MSK_NX90_mtgy_op_p48_val         0xffffffffU
#define SRT_NX90_mtgy_op_p48_val         0
#define DFLT_VAL_NX90_mtgy_op_p48_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p48_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p48': */
#define MSK_USED_BITS_NX90_mtgy_op_p48 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p48_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P48_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p48_val; /* data bits 1567..1536 */
} NX90_MTGY_OP_P48_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P48_BIT_T bf;
} NX90_MTGY_OP_P48_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p49 */
/* => MWMM operand P register 49 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p49  0x000014C4U
#define Adr_NX90_mtgy_mtgy_op_p49 0xFF0834C4U
#define Adr_NX90_mtgy_op_p49      0xFF0834C4U
#define DFLT_VAL_NX90_mtgy_op_p49 0x00000000U

#define MSK_NX90_mtgy_op_p49_val         0xffffffffU
#define SRT_NX90_mtgy_op_p49_val         0
#define DFLT_VAL_NX90_mtgy_op_p49_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p49_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p49': */
#define MSK_USED_BITS_NX90_mtgy_op_p49 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p49_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P49_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p49_val; /* data bits 1599..1568 */
} NX90_MTGY_OP_P49_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P49_BIT_T bf;
} NX90_MTGY_OP_P49_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p50 */
/* => MWMM operand P register 50 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p50  0x000014C8U
#define Adr_NX90_mtgy_mtgy_op_p50 0xFF0834C8U
#define Adr_NX90_mtgy_op_p50      0xFF0834C8U
#define DFLT_VAL_NX90_mtgy_op_p50 0x00000000U

#define MSK_NX90_mtgy_op_p50_val         0xffffffffU
#define SRT_NX90_mtgy_op_p50_val         0
#define DFLT_VAL_NX90_mtgy_op_p50_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p50_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p50': */
#define MSK_USED_BITS_NX90_mtgy_op_p50 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p50_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P50_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p50_val; /* data bits 1631..1600 */
} NX90_MTGY_OP_P50_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P50_BIT_T bf;
} NX90_MTGY_OP_P50_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p51 */
/* => MWMM operand P register 51 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p51  0x000014CCU
#define Adr_NX90_mtgy_mtgy_op_p51 0xFF0834CCU
#define Adr_NX90_mtgy_op_p51      0xFF0834CCU
#define DFLT_VAL_NX90_mtgy_op_p51 0x00000000U

#define MSK_NX90_mtgy_op_p51_val         0xffffffffU
#define SRT_NX90_mtgy_op_p51_val         0
#define DFLT_VAL_NX90_mtgy_op_p51_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p51_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p51': */
#define MSK_USED_BITS_NX90_mtgy_op_p51 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p51_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P51_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p51_val; /* data bits 1663..1632 */
} NX90_MTGY_OP_P51_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P51_BIT_T bf;
} NX90_MTGY_OP_P51_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p52 */
/* => MWMM operand P register 52 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p52  0x000014D0U
#define Adr_NX90_mtgy_mtgy_op_p52 0xFF0834D0U
#define Adr_NX90_mtgy_op_p52      0xFF0834D0U
#define DFLT_VAL_NX90_mtgy_op_p52 0x00000000U

#define MSK_NX90_mtgy_op_p52_val         0xffffffffU
#define SRT_NX90_mtgy_op_p52_val         0
#define DFLT_VAL_NX90_mtgy_op_p52_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p52_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p52': */
#define MSK_USED_BITS_NX90_mtgy_op_p52 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p52_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P52_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p52_val; /* data bits 1695..1664 */
} NX90_MTGY_OP_P52_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P52_BIT_T bf;
} NX90_MTGY_OP_P52_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p53 */
/* => MWMM operand P register 53 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p53  0x000014D4U
#define Adr_NX90_mtgy_mtgy_op_p53 0xFF0834D4U
#define Adr_NX90_mtgy_op_p53      0xFF0834D4U
#define DFLT_VAL_NX90_mtgy_op_p53 0x00000000U

#define MSK_NX90_mtgy_op_p53_val         0xffffffffU
#define SRT_NX90_mtgy_op_p53_val         0
#define DFLT_VAL_NX90_mtgy_op_p53_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p53_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p53': */
#define MSK_USED_BITS_NX90_mtgy_op_p53 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p53_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P53_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p53_val; /* data bits 1727..1696 */
} NX90_MTGY_OP_P53_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P53_BIT_T bf;
} NX90_MTGY_OP_P53_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p54 */
/* => MWMM operand P register 54 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p54  0x000014D8U
#define Adr_NX90_mtgy_mtgy_op_p54 0xFF0834D8U
#define Adr_NX90_mtgy_op_p54      0xFF0834D8U
#define DFLT_VAL_NX90_mtgy_op_p54 0x00000000U

#define MSK_NX90_mtgy_op_p54_val         0xffffffffU
#define SRT_NX90_mtgy_op_p54_val         0
#define DFLT_VAL_NX90_mtgy_op_p54_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p54_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p54': */
#define MSK_USED_BITS_NX90_mtgy_op_p54 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p54_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P54_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p54_val; /* data bits 1759..1728 */
} NX90_MTGY_OP_P54_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P54_BIT_T bf;
} NX90_MTGY_OP_P54_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p55 */
/* => MWMM operand P register 55 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p55  0x000014DCU
#define Adr_NX90_mtgy_mtgy_op_p55 0xFF0834DCU
#define Adr_NX90_mtgy_op_p55      0xFF0834DCU
#define DFLT_VAL_NX90_mtgy_op_p55 0x00000000U

#define MSK_NX90_mtgy_op_p55_val         0xffffffffU
#define SRT_NX90_mtgy_op_p55_val         0
#define DFLT_VAL_NX90_mtgy_op_p55_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p55_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p55': */
#define MSK_USED_BITS_NX90_mtgy_op_p55 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p55_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P55_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p55_val; /* data bits 1791..1760 */
} NX90_MTGY_OP_P55_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P55_BIT_T bf;
} NX90_MTGY_OP_P55_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p56 */
/* => MWMM operand P register 56 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p56  0x000014E0U
#define Adr_NX90_mtgy_mtgy_op_p56 0xFF0834E0U
#define Adr_NX90_mtgy_op_p56      0xFF0834E0U
#define DFLT_VAL_NX90_mtgy_op_p56 0x00000000U

#define MSK_NX90_mtgy_op_p56_val         0xffffffffU
#define SRT_NX90_mtgy_op_p56_val         0
#define DFLT_VAL_NX90_mtgy_op_p56_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p56_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p56': */
#define MSK_USED_BITS_NX90_mtgy_op_p56 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p56_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P56_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p56_val; /* data bits 1823..1792 */
} NX90_MTGY_OP_P56_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P56_BIT_T bf;
} NX90_MTGY_OP_P56_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p57 */
/* => MWMM operand P register 57 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p57  0x000014E4U
#define Adr_NX90_mtgy_mtgy_op_p57 0xFF0834E4U
#define Adr_NX90_mtgy_op_p57      0xFF0834E4U
#define DFLT_VAL_NX90_mtgy_op_p57 0x00000000U

#define MSK_NX90_mtgy_op_p57_val         0xffffffffU
#define SRT_NX90_mtgy_op_p57_val         0
#define DFLT_VAL_NX90_mtgy_op_p57_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p57_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p57': */
#define MSK_USED_BITS_NX90_mtgy_op_p57 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p57_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P57_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p57_val; /* data bits 1855..1824 */
} NX90_MTGY_OP_P57_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P57_BIT_T bf;
} NX90_MTGY_OP_P57_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p58 */
/* => MWMM operand P register 58 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p58  0x000014E8U
#define Adr_NX90_mtgy_mtgy_op_p58 0xFF0834E8U
#define Adr_NX90_mtgy_op_p58      0xFF0834E8U
#define DFLT_VAL_NX90_mtgy_op_p58 0x00000000U

#define MSK_NX90_mtgy_op_p58_val         0xffffffffU
#define SRT_NX90_mtgy_op_p58_val         0
#define DFLT_VAL_NX90_mtgy_op_p58_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p58_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p58': */
#define MSK_USED_BITS_NX90_mtgy_op_p58 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p58_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P58_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p58_val; /* data bits 1887..1856 */
} NX90_MTGY_OP_P58_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P58_BIT_T bf;
} NX90_MTGY_OP_P58_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p59 */
/* => MWMM operand P register 59 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p59  0x000014ECU
#define Adr_NX90_mtgy_mtgy_op_p59 0xFF0834ECU
#define Adr_NX90_mtgy_op_p59      0xFF0834ECU
#define DFLT_VAL_NX90_mtgy_op_p59 0x00000000U

#define MSK_NX90_mtgy_op_p59_val         0xffffffffU
#define SRT_NX90_mtgy_op_p59_val         0
#define DFLT_VAL_NX90_mtgy_op_p59_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p59_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p59': */
#define MSK_USED_BITS_NX90_mtgy_op_p59 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p59_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P59_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p59_val; /* data bits 1919..1888 */
} NX90_MTGY_OP_P59_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P59_BIT_T bf;
} NX90_MTGY_OP_P59_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p60 */
/* => MWMM operand P register 60 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p60  0x000014F0U
#define Adr_NX90_mtgy_mtgy_op_p60 0xFF0834F0U
#define Adr_NX90_mtgy_op_p60      0xFF0834F0U
#define DFLT_VAL_NX90_mtgy_op_p60 0x00000000U

#define MSK_NX90_mtgy_op_p60_val         0xffffffffU
#define SRT_NX90_mtgy_op_p60_val         0
#define DFLT_VAL_NX90_mtgy_op_p60_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p60_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p60': */
#define MSK_USED_BITS_NX90_mtgy_op_p60 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p60_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P60_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p60_val; /* data bits 1951..1920 */
} NX90_MTGY_OP_P60_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P60_BIT_T bf;
} NX90_MTGY_OP_P60_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p61 */
/* => MWMM operand P register 61 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p61  0x000014F4U
#define Adr_NX90_mtgy_mtgy_op_p61 0xFF0834F4U
#define Adr_NX90_mtgy_op_p61      0xFF0834F4U
#define DFLT_VAL_NX90_mtgy_op_p61 0x00000000U

#define MSK_NX90_mtgy_op_p61_val         0xffffffffU
#define SRT_NX90_mtgy_op_p61_val         0
#define DFLT_VAL_NX90_mtgy_op_p61_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p61_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p61': */
#define MSK_USED_BITS_NX90_mtgy_op_p61 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p61_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P61_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p61_val; /* data bits 1983..1952 */
} NX90_MTGY_OP_P61_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P61_BIT_T bf;
} NX90_MTGY_OP_P61_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p62 */
/* => MWMM operand P register 62 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p62  0x000014F8U
#define Adr_NX90_mtgy_mtgy_op_p62 0xFF0834F8U
#define Adr_NX90_mtgy_op_p62      0xFF0834F8U
#define DFLT_VAL_NX90_mtgy_op_p62 0x00000000U

#define MSK_NX90_mtgy_op_p62_val         0xffffffffU
#define SRT_NX90_mtgy_op_p62_val         0
#define DFLT_VAL_NX90_mtgy_op_p62_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p62_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p62': */
#define MSK_USED_BITS_NX90_mtgy_op_p62 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p62_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P62_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p62_val; /* data bits 2015..1984 */
} NX90_MTGY_OP_P62_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P62_BIT_T bf;
} NX90_MTGY_OP_P62_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p63 */
/* => MWMM operand P register 63 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p63  0x000014FCU
#define Adr_NX90_mtgy_mtgy_op_p63 0xFF0834FCU
#define Adr_NX90_mtgy_op_p63      0xFF0834FCU
#define DFLT_VAL_NX90_mtgy_op_p63 0x00000000U

#define MSK_NX90_mtgy_op_p63_val         0xffffffffU
#define SRT_NX90_mtgy_op_p63_val         0
#define DFLT_VAL_NX90_mtgy_op_p63_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p63_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p63': */
#define MSK_USED_BITS_NX90_mtgy_op_p63 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p63_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P63_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p63_val; /* data bits 2047..2016 */
} NX90_MTGY_OP_P63_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P63_BIT_T bf;
} NX90_MTGY_OP_P63_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p64 */
/* => MWMM operand P register 64 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p64  0x00001500U
#define Adr_NX90_mtgy_mtgy_op_p64 0xFF083500U
#define Adr_NX90_mtgy_op_p64      0xFF083500U
#define DFLT_VAL_NX90_mtgy_op_p64 0x00000000U

#define MSK_NX90_mtgy_op_p64_val         0xffffffffU
#define SRT_NX90_mtgy_op_p64_val         0
#define DFLT_VAL_NX90_mtgy_op_p64_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p64_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p64': */
#define MSK_USED_BITS_NX90_mtgy_op_p64 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p64_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P64_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p64_val; /* data bits 2079..2048 */
} NX90_MTGY_OP_P64_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P64_BIT_T bf;
} NX90_MTGY_OP_P64_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p65 */
/* => MWMM operand P register 65 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p65  0x00001504U
#define Adr_NX90_mtgy_mtgy_op_p65 0xFF083504U
#define Adr_NX90_mtgy_op_p65      0xFF083504U
#define DFLT_VAL_NX90_mtgy_op_p65 0x00000000U

#define MSK_NX90_mtgy_op_p65_val         0xffffffffU
#define SRT_NX90_mtgy_op_p65_val         0
#define DFLT_VAL_NX90_mtgy_op_p65_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p65_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p65': */
#define MSK_USED_BITS_NX90_mtgy_op_p65 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p65_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P65_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p65_val; /* data bits 2111..2080 */
} NX90_MTGY_OP_P65_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P65_BIT_T bf;
} NX90_MTGY_OP_P65_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p66 */
/* => MWMM operand P register 66 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p66  0x00001508U
#define Adr_NX90_mtgy_mtgy_op_p66 0xFF083508U
#define Adr_NX90_mtgy_op_p66      0xFF083508U
#define DFLT_VAL_NX90_mtgy_op_p66 0x00000000U

#define MSK_NX90_mtgy_op_p66_val         0xffffffffU
#define SRT_NX90_mtgy_op_p66_val         0
#define DFLT_VAL_NX90_mtgy_op_p66_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p66_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p66': */
#define MSK_USED_BITS_NX90_mtgy_op_p66 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p66_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P66_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p66_val; /* data bits 2143..2112 */
} NX90_MTGY_OP_P66_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P66_BIT_T bf;
} NX90_MTGY_OP_P66_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p67 */
/* => MWMM operand P register 67 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p67  0x0000150CU
#define Adr_NX90_mtgy_mtgy_op_p67 0xFF08350CU
#define Adr_NX90_mtgy_op_p67      0xFF08350CU
#define DFLT_VAL_NX90_mtgy_op_p67 0x00000000U

#define MSK_NX90_mtgy_op_p67_val         0xffffffffU
#define SRT_NX90_mtgy_op_p67_val         0
#define DFLT_VAL_NX90_mtgy_op_p67_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p67_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p67': */
#define MSK_USED_BITS_NX90_mtgy_op_p67 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p67_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P67_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p67_val; /* data bits 2175..2144 */
} NX90_MTGY_OP_P67_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P67_BIT_T bf;
} NX90_MTGY_OP_P67_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p68 */
/* => MWMM operand P register 68 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p68  0x00001510U
#define Adr_NX90_mtgy_mtgy_op_p68 0xFF083510U
#define Adr_NX90_mtgy_op_p68      0xFF083510U
#define DFLT_VAL_NX90_mtgy_op_p68 0x00000000U

#define MSK_NX90_mtgy_op_p68_val         0xffffffffU
#define SRT_NX90_mtgy_op_p68_val         0
#define DFLT_VAL_NX90_mtgy_op_p68_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p68_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p68': */
#define MSK_USED_BITS_NX90_mtgy_op_p68 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p68_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P68_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p68_val; /* data bits 2207..2176 */
} NX90_MTGY_OP_P68_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P68_BIT_T bf;
} NX90_MTGY_OP_P68_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p69 */
/* => MWMM operand P register 69 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p69  0x00001514U
#define Adr_NX90_mtgy_mtgy_op_p69 0xFF083514U
#define Adr_NX90_mtgy_op_p69      0xFF083514U
#define DFLT_VAL_NX90_mtgy_op_p69 0x00000000U

#define MSK_NX90_mtgy_op_p69_val         0xffffffffU
#define SRT_NX90_mtgy_op_p69_val         0
#define DFLT_VAL_NX90_mtgy_op_p69_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p69_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p69': */
#define MSK_USED_BITS_NX90_mtgy_op_p69 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p69_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P69_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p69_val; /* data bits 2239..2208 */
} NX90_MTGY_OP_P69_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P69_BIT_T bf;
} NX90_MTGY_OP_P69_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p70 */
/* => MWMM operand P register 70 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p70  0x00001518U
#define Adr_NX90_mtgy_mtgy_op_p70 0xFF083518U
#define Adr_NX90_mtgy_op_p70      0xFF083518U
#define DFLT_VAL_NX90_mtgy_op_p70 0x00000000U

#define MSK_NX90_mtgy_op_p70_val         0xffffffffU
#define SRT_NX90_mtgy_op_p70_val         0
#define DFLT_VAL_NX90_mtgy_op_p70_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p70_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p70': */
#define MSK_USED_BITS_NX90_mtgy_op_p70 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p70_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P70_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p70_val; /* data bits 2271..2240 */
} NX90_MTGY_OP_P70_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P70_BIT_T bf;
} NX90_MTGY_OP_P70_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p71 */
/* => MWMM operand P register 71 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p71  0x0000151CU
#define Adr_NX90_mtgy_mtgy_op_p71 0xFF08351CU
#define Adr_NX90_mtgy_op_p71      0xFF08351CU
#define DFLT_VAL_NX90_mtgy_op_p71 0x00000000U

#define MSK_NX90_mtgy_op_p71_val         0xffffffffU
#define SRT_NX90_mtgy_op_p71_val         0
#define DFLT_VAL_NX90_mtgy_op_p71_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p71_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p71': */
#define MSK_USED_BITS_NX90_mtgy_op_p71 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p71_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P71_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p71_val; /* data bits 2303..2272 */
} NX90_MTGY_OP_P71_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P71_BIT_T bf;
} NX90_MTGY_OP_P71_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p72 */
/* => MWMM operand P register 72 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p72  0x00001520U
#define Adr_NX90_mtgy_mtgy_op_p72 0xFF083520U
#define Adr_NX90_mtgy_op_p72      0xFF083520U
#define DFLT_VAL_NX90_mtgy_op_p72 0x00000000U

#define MSK_NX90_mtgy_op_p72_val         0xffffffffU
#define SRT_NX90_mtgy_op_p72_val         0
#define DFLT_VAL_NX90_mtgy_op_p72_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p72_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p72': */
#define MSK_USED_BITS_NX90_mtgy_op_p72 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p72_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P72_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p72_val; /* data bits 2335..2304 */
} NX90_MTGY_OP_P72_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P72_BIT_T bf;
} NX90_MTGY_OP_P72_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p73 */
/* => MWMM operand P register 73 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p73  0x00001524U
#define Adr_NX90_mtgy_mtgy_op_p73 0xFF083524U
#define Adr_NX90_mtgy_op_p73      0xFF083524U
#define DFLT_VAL_NX90_mtgy_op_p73 0x00000000U

#define MSK_NX90_mtgy_op_p73_val         0xffffffffU
#define SRT_NX90_mtgy_op_p73_val         0
#define DFLT_VAL_NX90_mtgy_op_p73_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p73_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p73': */
#define MSK_USED_BITS_NX90_mtgy_op_p73 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p73_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P73_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p73_val; /* data bits 2367..2336 */
} NX90_MTGY_OP_P73_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P73_BIT_T bf;
} NX90_MTGY_OP_P73_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p74 */
/* => MWMM operand P register 74 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p74  0x00001528U
#define Adr_NX90_mtgy_mtgy_op_p74 0xFF083528U
#define Adr_NX90_mtgy_op_p74      0xFF083528U
#define DFLT_VAL_NX90_mtgy_op_p74 0x00000000U

#define MSK_NX90_mtgy_op_p74_val         0xffffffffU
#define SRT_NX90_mtgy_op_p74_val         0
#define DFLT_VAL_NX90_mtgy_op_p74_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p74_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p74': */
#define MSK_USED_BITS_NX90_mtgy_op_p74 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p74_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P74_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p74_val; /* data bits 2399..2368 */
} NX90_MTGY_OP_P74_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P74_BIT_T bf;
} NX90_MTGY_OP_P74_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p75 */
/* => MWMM operand P register 75 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p75  0x0000152CU
#define Adr_NX90_mtgy_mtgy_op_p75 0xFF08352CU
#define Adr_NX90_mtgy_op_p75      0xFF08352CU
#define DFLT_VAL_NX90_mtgy_op_p75 0x00000000U

#define MSK_NX90_mtgy_op_p75_val         0xffffffffU
#define SRT_NX90_mtgy_op_p75_val         0
#define DFLT_VAL_NX90_mtgy_op_p75_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p75_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p75': */
#define MSK_USED_BITS_NX90_mtgy_op_p75 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p75_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P75_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p75_val; /* data bits 2431..2400 */
} NX90_MTGY_OP_P75_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P75_BIT_T bf;
} NX90_MTGY_OP_P75_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p76 */
/* => MWMM operand P register 76 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p76  0x00001530U
#define Adr_NX90_mtgy_mtgy_op_p76 0xFF083530U
#define Adr_NX90_mtgy_op_p76      0xFF083530U
#define DFLT_VAL_NX90_mtgy_op_p76 0x00000000U

#define MSK_NX90_mtgy_op_p76_val         0xffffffffU
#define SRT_NX90_mtgy_op_p76_val         0
#define DFLT_VAL_NX90_mtgy_op_p76_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p76_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p76': */
#define MSK_USED_BITS_NX90_mtgy_op_p76 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p76_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P76_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p76_val; /* data bits 2463..2432 */
} NX90_MTGY_OP_P76_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P76_BIT_T bf;
} NX90_MTGY_OP_P76_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p77 */
/* => MWMM operand P register 77 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p77  0x00001534U
#define Adr_NX90_mtgy_mtgy_op_p77 0xFF083534U
#define Adr_NX90_mtgy_op_p77      0xFF083534U
#define DFLT_VAL_NX90_mtgy_op_p77 0x00000000U

#define MSK_NX90_mtgy_op_p77_val         0xffffffffU
#define SRT_NX90_mtgy_op_p77_val         0
#define DFLT_VAL_NX90_mtgy_op_p77_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p77_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p77': */
#define MSK_USED_BITS_NX90_mtgy_op_p77 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p77_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P77_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p77_val; /* data bits 2495..2464 */
} NX90_MTGY_OP_P77_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P77_BIT_T bf;
} NX90_MTGY_OP_P77_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p78 */
/* => MWMM operand P register 78 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p78  0x00001538U
#define Adr_NX90_mtgy_mtgy_op_p78 0xFF083538U
#define Adr_NX90_mtgy_op_p78      0xFF083538U
#define DFLT_VAL_NX90_mtgy_op_p78 0x00000000U

#define MSK_NX90_mtgy_op_p78_val         0xffffffffU
#define SRT_NX90_mtgy_op_p78_val         0
#define DFLT_VAL_NX90_mtgy_op_p78_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p78_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p78': */
#define MSK_USED_BITS_NX90_mtgy_op_p78 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p78_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P78_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p78_val; /* data bits 2527..2496 */
} NX90_MTGY_OP_P78_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P78_BIT_T bf;
} NX90_MTGY_OP_P78_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p79 */
/* => MWMM operand P register 79 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p79  0x0000153CU
#define Adr_NX90_mtgy_mtgy_op_p79 0xFF08353CU
#define Adr_NX90_mtgy_op_p79      0xFF08353CU
#define DFLT_VAL_NX90_mtgy_op_p79 0x00000000U

#define MSK_NX90_mtgy_op_p79_val         0xffffffffU
#define SRT_NX90_mtgy_op_p79_val         0
#define DFLT_VAL_NX90_mtgy_op_p79_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p79_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p79': */
#define MSK_USED_BITS_NX90_mtgy_op_p79 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p79_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P79_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p79_val; /* data bits 2559..2528 */
} NX90_MTGY_OP_P79_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P79_BIT_T bf;
} NX90_MTGY_OP_P79_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p80 */
/* => MWMM operand P register 80 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p80  0x00001540U
#define Adr_NX90_mtgy_mtgy_op_p80 0xFF083540U
#define Adr_NX90_mtgy_op_p80      0xFF083540U
#define DFLT_VAL_NX90_mtgy_op_p80 0x00000000U

#define MSK_NX90_mtgy_op_p80_val         0xffffffffU
#define SRT_NX90_mtgy_op_p80_val         0
#define DFLT_VAL_NX90_mtgy_op_p80_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p80_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p80': */
#define MSK_USED_BITS_NX90_mtgy_op_p80 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p80_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P80_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p80_val; /* data bits 2591..2560 */
} NX90_MTGY_OP_P80_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P80_BIT_T bf;
} NX90_MTGY_OP_P80_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p81 */
/* => MWMM operand P register 81 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p81  0x00001544U
#define Adr_NX90_mtgy_mtgy_op_p81 0xFF083544U
#define Adr_NX90_mtgy_op_p81      0xFF083544U
#define DFLT_VAL_NX90_mtgy_op_p81 0x00000000U

#define MSK_NX90_mtgy_op_p81_val         0xffffffffU
#define SRT_NX90_mtgy_op_p81_val         0
#define DFLT_VAL_NX90_mtgy_op_p81_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p81_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p81': */
#define MSK_USED_BITS_NX90_mtgy_op_p81 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p81_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P81_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p81_val; /* data bits 2623..2592 */
} NX90_MTGY_OP_P81_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P81_BIT_T bf;
} NX90_MTGY_OP_P81_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p82 */
/* => MWMM operand P register 82 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p82  0x00001548U
#define Adr_NX90_mtgy_mtgy_op_p82 0xFF083548U
#define Adr_NX90_mtgy_op_p82      0xFF083548U
#define DFLT_VAL_NX90_mtgy_op_p82 0x00000000U

#define MSK_NX90_mtgy_op_p82_val         0xffffffffU
#define SRT_NX90_mtgy_op_p82_val         0
#define DFLT_VAL_NX90_mtgy_op_p82_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p82_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p82': */
#define MSK_USED_BITS_NX90_mtgy_op_p82 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p82_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P82_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p82_val; /* data bits 2655..2624 */
} NX90_MTGY_OP_P82_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P82_BIT_T bf;
} NX90_MTGY_OP_P82_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p83 */
/* => MWMM operand P register 83 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p83  0x0000154CU
#define Adr_NX90_mtgy_mtgy_op_p83 0xFF08354CU
#define Adr_NX90_mtgy_op_p83      0xFF08354CU
#define DFLT_VAL_NX90_mtgy_op_p83 0x00000000U

#define MSK_NX90_mtgy_op_p83_val         0xffffffffU
#define SRT_NX90_mtgy_op_p83_val         0
#define DFLT_VAL_NX90_mtgy_op_p83_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p83_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p83': */
#define MSK_USED_BITS_NX90_mtgy_op_p83 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p83_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P83_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p83_val; /* data bits 2687..2656 */
} NX90_MTGY_OP_P83_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P83_BIT_T bf;
} NX90_MTGY_OP_P83_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p84 */
/* => MWMM operand P register 84 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p84  0x00001550U
#define Adr_NX90_mtgy_mtgy_op_p84 0xFF083550U
#define Adr_NX90_mtgy_op_p84      0xFF083550U
#define DFLT_VAL_NX90_mtgy_op_p84 0x00000000U

#define MSK_NX90_mtgy_op_p84_val         0xffffffffU
#define SRT_NX90_mtgy_op_p84_val         0
#define DFLT_VAL_NX90_mtgy_op_p84_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p84_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p84': */
#define MSK_USED_BITS_NX90_mtgy_op_p84 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p84_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P84_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p84_val; /* data bits 2719..2688 */
} NX90_MTGY_OP_P84_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P84_BIT_T bf;
} NX90_MTGY_OP_P84_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p85 */
/* => MWMM operand P register 85 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p85  0x00001554U
#define Adr_NX90_mtgy_mtgy_op_p85 0xFF083554U
#define Adr_NX90_mtgy_op_p85      0xFF083554U
#define DFLT_VAL_NX90_mtgy_op_p85 0x00000000U

#define MSK_NX90_mtgy_op_p85_val         0xffffffffU
#define SRT_NX90_mtgy_op_p85_val         0
#define DFLT_VAL_NX90_mtgy_op_p85_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p85_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p85': */
#define MSK_USED_BITS_NX90_mtgy_op_p85 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p85_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P85_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p85_val; /* data bits 2751..2720 */
} NX90_MTGY_OP_P85_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P85_BIT_T bf;
} NX90_MTGY_OP_P85_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p86 */
/* => MWMM operand P register 86 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p86  0x00001558U
#define Adr_NX90_mtgy_mtgy_op_p86 0xFF083558U
#define Adr_NX90_mtgy_op_p86      0xFF083558U
#define DFLT_VAL_NX90_mtgy_op_p86 0x00000000U

#define MSK_NX90_mtgy_op_p86_val         0xffffffffU
#define SRT_NX90_mtgy_op_p86_val         0
#define DFLT_VAL_NX90_mtgy_op_p86_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p86_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p86': */
#define MSK_USED_BITS_NX90_mtgy_op_p86 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p86_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P86_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p86_val; /* data bits 2783..2752 */
} NX90_MTGY_OP_P86_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P86_BIT_T bf;
} NX90_MTGY_OP_P86_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p87 */
/* => MWMM operand P register 87 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p87  0x0000155CU
#define Adr_NX90_mtgy_mtgy_op_p87 0xFF08355CU
#define Adr_NX90_mtgy_op_p87      0xFF08355CU
#define DFLT_VAL_NX90_mtgy_op_p87 0x00000000U

#define MSK_NX90_mtgy_op_p87_val         0xffffffffU
#define SRT_NX90_mtgy_op_p87_val         0
#define DFLT_VAL_NX90_mtgy_op_p87_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p87_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p87': */
#define MSK_USED_BITS_NX90_mtgy_op_p87 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p87_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P87_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p87_val; /* data bits 2815..2784 */
} NX90_MTGY_OP_P87_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P87_BIT_T bf;
} NX90_MTGY_OP_P87_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p88 */
/* => MWMM operand P register 88 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p88  0x00001560U
#define Adr_NX90_mtgy_mtgy_op_p88 0xFF083560U
#define Adr_NX90_mtgy_op_p88      0xFF083560U
#define DFLT_VAL_NX90_mtgy_op_p88 0x00000000U

#define MSK_NX90_mtgy_op_p88_val         0xffffffffU
#define SRT_NX90_mtgy_op_p88_val         0
#define DFLT_VAL_NX90_mtgy_op_p88_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p88_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p88': */
#define MSK_USED_BITS_NX90_mtgy_op_p88 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p88_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P88_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p88_val; /* data bits 2847..2816 */
} NX90_MTGY_OP_P88_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P88_BIT_T bf;
} NX90_MTGY_OP_P88_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p89 */
/* => MWMM operand P register 89 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p89  0x00001564U
#define Adr_NX90_mtgy_mtgy_op_p89 0xFF083564U
#define Adr_NX90_mtgy_op_p89      0xFF083564U
#define DFLT_VAL_NX90_mtgy_op_p89 0x00000000U

#define MSK_NX90_mtgy_op_p89_val         0xffffffffU
#define SRT_NX90_mtgy_op_p89_val         0
#define DFLT_VAL_NX90_mtgy_op_p89_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p89_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p89': */
#define MSK_USED_BITS_NX90_mtgy_op_p89 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p89_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P89_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p89_val; /* data bits 2879..2848 */
} NX90_MTGY_OP_P89_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P89_BIT_T bf;
} NX90_MTGY_OP_P89_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p90 */
/* => MWMM operand P register 90 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p90  0x00001568U
#define Adr_NX90_mtgy_mtgy_op_p90 0xFF083568U
#define Adr_NX90_mtgy_op_p90      0xFF083568U
#define DFLT_VAL_NX90_mtgy_op_p90 0x00000000U

#define MSK_NX90_mtgy_op_p90_val         0xffffffffU
#define SRT_NX90_mtgy_op_p90_val         0
#define DFLT_VAL_NX90_mtgy_op_p90_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p90_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p90': */
#define MSK_USED_BITS_NX90_mtgy_op_p90 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p90_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P90_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p90_val; /* data bits 2911..2880 */
} NX90_MTGY_OP_P90_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P90_BIT_T bf;
} NX90_MTGY_OP_P90_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p91 */
/* => MWMM operand P register 91 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p91  0x0000156CU
#define Adr_NX90_mtgy_mtgy_op_p91 0xFF08356CU
#define Adr_NX90_mtgy_op_p91      0xFF08356CU
#define DFLT_VAL_NX90_mtgy_op_p91 0x00000000U

#define MSK_NX90_mtgy_op_p91_val         0xffffffffU
#define SRT_NX90_mtgy_op_p91_val         0
#define DFLT_VAL_NX90_mtgy_op_p91_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p91_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p91': */
#define MSK_USED_BITS_NX90_mtgy_op_p91 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p91_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P91_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p91_val; /* data bits 2943..2912 */
} NX90_MTGY_OP_P91_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P91_BIT_T bf;
} NX90_MTGY_OP_P91_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p92 */
/* => MWMM operand P register 92 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p92  0x00001570U
#define Adr_NX90_mtgy_mtgy_op_p92 0xFF083570U
#define Adr_NX90_mtgy_op_p92      0xFF083570U
#define DFLT_VAL_NX90_mtgy_op_p92 0x00000000U

#define MSK_NX90_mtgy_op_p92_val         0xffffffffU
#define SRT_NX90_mtgy_op_p92_val         0
#define DFLT_VAL_NX90_mtgy_op_p92_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p92_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p92': */
#define MSK_USED_BITS_NX90_mtgy_op_p92 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p92_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P92_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p92_val; /* data bits 2975..2944 */
} NX90_MTGY_OP_P92_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P92_BIT_T bf;
} NX90_MTGY_OP_P92_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p93 */
/* => MWMM operand P register 93 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p93  0x00001574U
#define Adr_NX90_mtgy_mtgy_op_p93 0xFF083574U
#define Adr_NX90_mtgy_op_p93      0xFF083574U
#define DFLT_VAL_NX90_mtgy_op_p93 0x00000000U

#define MSK_NX90_mtgy_op_p93_val         0xffffffffU
#define SRT_NX90_mtgy_op_p93_val         0
#define DFLT_VAL_NX90_mtgy_op_p93_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p93_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p93': */
#define MSK_USED_BITS_NX90_mtgy_op_p93 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p93_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P93_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p93_val; /* data bits 3007..2976 */
} NX90_MTGY_OP_P93_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P93_BIT_T bf;
} NX90_MTGY_OP_P93_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p94 */
/* => MWMM operand P register 94 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p94  0x00001578U
#define Adr_NX90_mtgy_mtgy_op_p94 0xFF083578U
#define Adr_NX90_mtgy_op_p94      0xFF083578U
#define DFLT_VAL_NX90_mtgy_op_p94 0x00000000U

#define MSK_NX90_mtgy_op_p94_val         0xffffffffU
#define SRT_NX90_mtgy_op_p94_val         0
#define DFLT_VAL_NX90_mtgy_op_p94_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p94_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p94': */
#define MSK_USED_BITS_NX90_mtgy_op_p94 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p94_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P94_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p94_val; /* data bits 3039..3008 */
} NX90_MTGY_OP_P94_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P94_BIT_T bf;
} NX90_MTGY_OP_P94_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p95 */
/* => MWMM operand P register 95 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p95  0x0000157CU
#define Adr_NX90_mtgy_mtgy_op_p95 0xFF08357CU
#define Adr_NX90_mtgy_op_p95      0xFF08357CU
#define DFLT_VAL_NX90_mtgy_op_p95 0x00000000U

#define MSK_NX90_mtgy_op_p95_val         0xffffffffU
#define SRT_NX90_mtgy_op_p95_val         0
#define DFLT_VAL_NX90_mtgy_op_p95_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p95_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p95': */
#define MSK_USED_BITS_NX90_mtgy_op_p95 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p95_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P95_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p95_val; /* data bits 3071..3040 */
} NX90_MTGY_OP_P95_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P95_BIT_T bf;
} NX90_MTGY_OP_P95_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p96 */
/* => MWMM operand P register 96 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p96  0x00001580U
#define Adr_NX90_mtgy_mtgy_op_p96 0xFF083580U
#define Adr_NX90_mtgy_op_p96      0xFF083580U
#define DFLT_VAL_NX90_mtgy_op_p96 0x00000000U

#define MSK_NX90_mtgy_op_p96_val         0xffffffffU
#define SRT_NX90_mtgy_op_p96_val         0
#define DFLT_VAL_NX90_mtgy_op_p96_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p96_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p96': */
#define MSK_USED_BITS_NX90_mtgy_op_p96 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p96_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P96_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p96_val; /* data bits 3103..3072 */
} NX90_MTGY_OP_P96_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P96_BIT_T bf;
} NX90_MTGY_OP_P96_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p97 */
/* => MWMM operand P register 97 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p97  0x00001584U
#define Adr_NX90_mtgy_mtgy_op_p97 0xFF083584U
#define Adr_NX90_mtgy_op_p97      0xFF083584U
#define DFLT_VAL_NX90_mtgy_op_p97 0x00000000U

#define MSK_NX90_mtgy_op_p97_val         0xffffffffU
#define SRT_NX90_mtgy_op_p97_val         0
#define DFLT_VAL_NX90_mtgy_op_p97_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p97_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p97': */
#define MSK_USED_BITS_NX90_mtgy_op_p97 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p97_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P97_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p97_val; /* data bits 3135..3104 */
} NX90_MTGY_OP_P97_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P97_BIT_T bf;
} NX90_MTGY_OP_P97_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p98 */
/* => MWMM operand P register 98 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p98  0x00001588U
#define Adr_NX90_mtgy_mtgy_op_p98 0xFF083588U
#define Adr_NX90_mtgy_op_p98      0xFF083588U
#define DFLT_VAL_NX90_mtgy_op_p98 0x00000000U

#define MSK_NX90_mtgy_op_p98_val         0xffffffffU
#define SRT_NX90_mtgy_op_p98_val         0
#define DFLT_VAL_NX90_mtgy_op_p98_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p98_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p98': */
#define MSK_USED_BITS_NX90_mtgy_op_p98 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p98_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P98_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p98_val; /* data bits 3167..3136 */
} NX90_MTGY_OP_P98_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P98_BIT_T bf;
} NX90_MTGY_OP_P98_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p99 */
/* => MWMM operand P register 99 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p99  0x0000158CU
#define Adr_NX90_mtgy_mtgy_op_p99 0xFF08358CU
#define Adr_NX90_mtgy_op_p99      0xFF08358CU
#define DFLT_VAL_NX90_mtgy_op_p99 0x00000000U

#define MSK_NX90_mtgy_op_p99_val         0xffffffffU
#define SRT_NX90_mtgy_op_p99_val         0
#define DFLT_VAL_NX90_mtgy_op_p99_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p99_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p99': */
#define MSK_USED_BITS_NX90_mtgy_op_p99 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p99_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P99_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p99_val; /* data bits 3199..3168 */
} NX90_MTGY_OP_P99_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_P99_BIT_T bf;
} NX90_MTGY_OP_P99_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p100 */
/* => MWMM operand P register 100 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p100  0x00001590U
#define Adr_NX90_mtgy_mtgy_op_p100 0xFF083590U
#define Adr_NX90_mtgy_op_p100      0xFF083590U
#define DFLT_VAL_NX90_mtgy_op_p100 0x00000000U

#define MSK_NX90_mtgy_op_p100_val         0xffffffffU
#define SRT_NX90_mtgy_op_p100_val         0
#define DFLT_VAL_NX90_mtgy_op_p100_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p100_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p100': */
#define MSK_USED_BITS_NX90_mtgy_op_p100 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p100_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P100_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p100_val; /* data bits 3231..3200 */
} NX90_MTGY_OP_P100_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P100_BIT_T bf;
} NX90_MTGY_OP_P100_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p101 */
/* => MWMM operand P register 101 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p101  0x00001594U
#define Adr_NX90_mtgy_mtgy_op_p101 0xFF083594U
#define Adr_NX90_mtgy_op_p101      0xFF083594U
#define DFLT_VAL_NX90_mtgy_op_p101 0x00000000U

#define MSK_NX90_mtgy_op_p101_val         0xffffffffU
#define SRT_NX90_mtgy_op_p101_val         0
#define DFLT_VAL_NX90_mtgy_op_p101_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p101_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p101': */
#define MSK_USED_BITS_NX90_mtgy_op_p101 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p101_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P101_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p101_val; /* data bits 3263..3232 */
} NX90_MTGY_OP_P101_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P101_BIT_T bf;
} NX90_MTGY_OP_P101_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p102 */
/* => MWMM operand P register 102 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p102  0x00001598U
#define Adr_NX90_mtgy_mtgy_op_p102 0xFF083598U
#define Adr_NX90_mtgy_op_p102      0xFF083598U
#define DFLT_VAL_NX90_mtgy_op_p102 0x00000000U

#define MSK_NX90_mtgy_op_p102_val         0xffffffffU
#define SRT_NX90_mtgy_op_p102_val         0
#define DFLT_VAL_NX90_mtgy_op_p102_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p102_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p102': */
#define MSK_USED_BITS_NX90_mtgy_op_p102 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p102_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P102_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p102_val; /* data bits 3295..3264 */
} NX90_MTGY_OP_P102_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P102_BIT_T bf;
} NX90_MTGY_OP_P102_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p103 */
/* => MWMM operand P register 103 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p103  0x0000159CU
#define Adr_NX90_mtgy_mtgy_op_p103 0xFF08359CU
#define Adr_NX90_mtgy_op_p103      0xFF08359CU
#define DFLT_VAL_NX90_mtgy_op_p103 0x00000000U

#define MSK_NX90_mtgy_op_p103_val         0xffffffffU
#define SRT_NX90_mtgy_op_p103_val         0
#define DFLT_VAL_NX90_mtgy_op_p103_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p103_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p103': */
#define MSK_USED_BITS_NX90_mtgy_op_p103 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p103_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P103_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p103_val; /* data bits 3327..3296 */
} NX90_MTGY_OP_P103_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P103_BIT_T bf;
} NX90_MTGY_OP_P103_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p104 */
/* => MWMM operand P register 104 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p104  0x000015A0U
#define Adr_NX90_mtgy_mtgy_op_p104 0xFF0835A0U
#define Adr_NX90_mtgy_op_p104      0xFF0835A0U
#define DFLT_VAL_NX90_mtgy_op_p104 0x00000000U

#define MSK_NX90_mtgy_op_p104_val         0xffffffffU
#define SRT_NX90_mtgy_op_p104_val         0
#define DFLT_VAL_NX90_mtgy_op_p104_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p104_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p104': */
#define MSK_USED_BITS_NX90_mtgy_op_p104 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p104_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P104_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p104_val; /* data bits 3359..3328 */
} NX90_MTGY_OP_P104_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P104_BIT_T bf;
} NX90_MTGY_OP_P104_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p105 */
/* => MWMM operand P register 105 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p105  0x000015A4U
#define Adr_NX90_mtgy_mtgy_op_p105 0xFF0835A4U
#define Adr_NX90_mtgy_op_p105      0xFF0835A4U
#define DFLT_VAL_NX90_mtgy_op_p105 0x00000000U

#define MSK_NX90_mtgy_op_p105_val         0xffffffffU
#define SRT_NX90_mtgy_op_p105_val         0
#define DFLT_VAL_NX90_mtgy_op_p105_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p105_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p105': */
#define MSK_USED_BITS_NX90_mtgy_op_p105 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p105_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P105_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p105_val; /* data bits 3391..3360 */
} NX90_MTGY_OP_P105_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P105_BIT_T bf;
} NX90_MTGY_OP_P105_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p106 */
/* => MWMM operand P register 106 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p106  0x000015A8U
#define Adr_NX90_mtgy_mtgy_op_p106 0xFF0835A8U
#define Adr_NX90_mtgy_op_p106      0xFF0835A8U
#define DFLT_VAL_NX90_mtgy_op_p106 0x00000000U

#define MSK_NX90_mtgy_op_p106_val         0xffffffffU
#define SRT_NX90_mtgy_op_p106_val         0
#define DFLT_VAL_NX90_mtgy_op_p106_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p106_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p106': */
#define MSK_USED_BITS_NX90_mtgy_op_p106 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p106_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P106_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p106_val; /* data bits 3423..3392 */
} NX90_MTGY_OP_P106_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P106_BIT_T bf;
} NX90_MTGY_OP_P106_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p107 */
/* => MWMM operand P register 107 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p107  0x000015ACU
#define Adr_NX90_mtgy_mtgy_op_p107 0xFF0835ACU
#define Adr_NX90_mtgy_op_p107      0xFF0835ACU
#define DFLT_VAL_NX90_mtgy_op_p107 0x00000000U

#define MSK_NX90_mtgy_op_p107_val         0xffffffffU
#define SRT_NX90_mtgy_op_p107_val         0
#define DFLT_VAL_NX90_mtgy_op_p107_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p107_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p107': */
#define MSK_USED_BITS_NX90_mtgy_op_p107 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p107_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P107_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p107_val; /* data bits 3455..3424 */
} NX90_MTGY_OP_P107_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P107_BIT_T bf;
} NX90_MTGY_OP_P107_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p108 */
/* => MWMM operand P register 108 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p108  0x000015B0U
#define Adr_NX90_mtgy_mtgy_op_p108 0xFF0835B0U
#define Adr_NX90_mtgy_op_p108      0xFF0835B0U
#define DFLT_VAL_NX90_mtgy_op_p108 0x00000000U

#define MSK_NX90_mtgy_op_p108_val         0xffffffffU
#define SRT_NX90_mtgy_op_p108_val         0
#define DFLT_VAL_NX90_mtgy_op_p108_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p108_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p108': */
#define MSK_USED_BITS_NX90_mtgy_op_p108 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p108_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P108_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p108_val; /* data bits 3487..3456 */
} NX90_MTGY_OP_P108_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P108_BIT_T bf;
} NX90_MTGY_OP_P108_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p109 */
/* => MWMM operand P register 109 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p109  0x000015B4U
#define Adr_NX90_mtgy_mtgy_op_p109 0xFF0835B4U
#define Adr_NX90_mtgy_op_p109      0xFF0835B4U
#define DFLT_VAL_NX90_mtgy_op_p109 0x00000000U

#define MSK_NX90_mtgy_op_p109_val         0xffffffffU
#define SRT_NX90_mtgy_op_p109_val         0
#define DFLT_VAL_NX90_mtgy_op_p109_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p109_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p109': */
#define MSK_USED_BITS_NX90_mtgy_op_p109 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p109_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P109_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p109_val; /* data bits 3519..3488 */
} NX90_MTGY_OP_P109_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P109_BIT_T bf;
} NX90_MTGY_OP_P109_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p110 */
/* => MWMM operand P register 110 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p110  0x000015B8U
#define Adr_NX90_mtgy_mtgy_op_p110 0xFF0835B8U
#define Adr_NX90_mtgy_op_p110      0xFF0835B8U
#define DFLT_VAL_NX90_mtgy_op_p110 0x00000000U

#define MSK_NX90_mtgy_op_p110_val         0xffffffffU
#define SRT_NX90_mtgy_op_p110_val         0
#define DFLT_VAL_NX90_mtgy_op_p110_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p110_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p110': */
#define MSK_USED_BITS_NX90_mtgy_op_p110 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p110_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P110_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p110_val; /* data bits 3551..3520 */
} NX90_MTGY_OP_P110_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P110_BIT_T bf;
} NX90_MTGY_OP_P110_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p111 */
/* => MWMM operand P register 111 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p111  0x000015BCU
#define Adr_NX90_mtgy_mtgy_op_p111 0xFF0835BCU
#define Adr_NX90_mtgy_op_p111      0xFF0835BCU
#define DFLT_VAL_NX90_mtgy_op_p111 0x00000000U

#define MSK_NX90_mtgy_op_p111_val         0xffffffffU
#define SRT_NX90_mtgy_op_p111_val         0
#define DFLT_VAL_NX90_mtgy_op_p111_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p111_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p111': */
#define MSK_USED_BITS_NX90_mtgy_op_p111 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p111_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P111_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p111_val; /* data bits 3583..3552 */
} NX90_MTGY_OP_P111_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P111_BIT_T bf;
} NX90_MTGY_OP_P111_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p112 */
/* => MWMM operand P register 112 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p112  0x000015C0U
#define Adr_NX90_mtgy_mtgy_op_p112 0xFF0835C0U
#define Adr_NX90_mtgy_op_p112      0xFF0835C0U
#define DFLT_VAL_NX90_mtgy_op_p112 0x00000000U

#define MSK_NX90_mtgy_op_p112_val         0xffffffffU
#define SRT_NX90_mtgy_op_p112_val         0
#define DFLT_VAL_NX90_mtgy_op_p112_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p112_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p112': */
#define MSK_USED_BITS_NX90_mtgy_op_p112 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p112_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P112_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p112_val; /* data bits 3615..3584 */
} NX90_MTGY_OP_P112_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P112_BIT_T bf;
} NX90_MTGY_OP_P112_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p113 */
/* => MWMM operand P register 113 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p113  0x000015C4U
#define Adr_NX90_mtgy_mtgy_op_p113 0xFF0835C4U
#define Adr_NX90_mtgy_op_p113      0xFF0835C4U
#define DFLT_VAL_NX90_mtgy_op_p113 0x00000000U

#define MSK_NX90_mtgy_op_p113_val         0xffffffffU
#define SRT_NX90_mtgy_op_p113_val         0
#define DFLT_VAL_NX90_mtgy_op_p113_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p113_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p113': */
#define MSK_USED_BITS_NX90_mtgy_op_p113 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p113_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P113_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p113_val; /* data bits 3647..3616 */
} NX90_MTGY_OP_P113_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P113_BIT_T bf;
} NX90_MTGY_OP_P113_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p114 */
/* => MWMM operand P register 114 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p114  0x000015C8U
#define Adr_NX90_mtgy_mtgy_op_p114 0xFF0835C8U
#define Adr_NX90_mtgy_op_p114      0xFF0835C8U
#define DFLT_VAL_NX90_mtgy_op_p114 0x00000000U

#define MSK_NX90_mtgy_op_p114_val         0xffffffffU
#define SRT_NX90_mtgy_op_p114_val         0
#define DFLT_VAL_NX90_mtgy_op_p114_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p114_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p114': */
#define MSK_USED_BITS_NX90_mtgy_op_p114 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p114_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P114_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p114_val; /* data bits 3679..3648 */
} NX90_MTGY_OP_P114_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P114_BIT_T bf;
} NX90_MTGY_OP_P114_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p115 */
/* => MWMM operand P register 115 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p115  0x000015CCU
#define Adr_NX90_mtgy_mtgy_op_p115 0xFF0835CCU
#define Adr_NX90_mtgy_op_p115      0xFF0835CCU
#define DFLT_VAL_NX90_mtgy_op_p115 0x00000000U

#define MSK_NX90_mtgy_op_p115_val         0xffffffffU
#define SRT_NX90_mtgy_op_p115_val         0
#define DFLT_VAL_NX90_mtgy_op_p115_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p115_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p115': */
#define MSK_USED_BITS_NX90_mtgy_op_p115 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p115_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P115_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p115_val; /* data bits 3711..3680 */
} NX90_MTGY_OP_P115_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P115_BIT_T bf;
} NX90_MTGY_OP_P115_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p116 */
/* => MWMM operand P register 116 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p116  0x000015D0U
#define Adr_NX90_mtgy_mtgy_op_p116 0xFF0835D0U
#define Adr_NX90_mtgy_op_p116      0xFF0835D0U
#define DFLT_VAL_NX90_mtgy_op_p116 0x00000000U

#define MSK_NX90_mtgy_op_p116_val         0xffffffffU
#define SRT_NX90_mtgy_op_p116_val         0
#define DFLT_VAL_NX90_mtgy_op_p116_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p116_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p116': */
#define MSK_USED_BITS_NX90_mtgy_op_p116 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p116_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P116_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p116_val; /* data bits 3743..3712 */
} NX90_MTGY_OP_P116_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P116_BIT_T bf;
} NX90_MTGY_OP_P116_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p117 */
/* => MWMM operand P register 117 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p117  0x000015D4U
#define Adr_NX90_mtgy_mtgy_op_p117 0xFF0835D4U
#define Adr_NX90_mtgy_op_p117      0xFF0835D4U
#define DFLT_VAL_NX90_mtgy_op_p117 0x00000000U

#define MSK_NX90_mtgy_op_p117_val         0xffffffffU
#define SRT_NX90_mtgy_op_p117_val         0
#define DFLT_VAL_NX90_mtgy_op_p117_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p117_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p117': */
#define MSK_USED_BITS_NX90_mtgy_op_p117 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p117_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P117_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p117_val; /* data bits 3775..3744 */
} NX90_MTGY_OP_P117_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P117_BIT_T bf;
} NX90_MTGY_OP_P117_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p118 */
/* => MWMM operand P register 118 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p118  0x000015D8U
#define Adr_NX90_mtgy_mtgy_op_p118 0xFF0835D8U
#define Adr_NX90_mtgy_op_p118      0xFF0835D8U
#define DFLT_VAL_NX90_mtgy_op_p118 0x00000000U

#define MSK_NX90_mtgy_op_p118_val         0xffffffffU
#define SRT_NX90_mtgy_op_p118_val         0
#define DFLT_VAL_NX90_mtgy_op_p118_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p118_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p118': */
#define MSK_USED_BITS_NX90_mtgy_op_p118 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p118_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P118_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p118_val; /* data bits 3807..3776 */
} NX90_MTGY_OP_P118_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P118_BIT_T bf;
} NX90_MTGY_OP_P118_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p119 */
/* => MWMM operand P register 119 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p119  0x000015DCU
#define Adr_NX90_mtgy_mtgy_op_p119 0xFF0835DCU
#define Adr_NX90_mtgy_op_p119      0xFF0835DCU
#define DFLT_VAL_NX90_mtgy_op_p119 0x00000000U

#define MSK_NX90_mtgy_op_p119_val         0xffffffffU
#define SRT_NX90_mtgy_op_p119_val         0
#define DFLT_VAL_NX90_mtgy_op_p119_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p119_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p119': */
#define MSK_USED_BITS_NX90_mtgy_op_p119 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p119_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P119_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p119_val; /* data bits 3839..3808 */
} NX90_MTGY_OP_P119_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P119_BIT_T bf;
} NX90_MTGY_OP_P119_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p120 */
/* => MWMM operand P register 120 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p120  0x000015E0U
#define Adr_NX90_mtgy_mtgy_op_p120 0xFF0835E0U
#define Adr_NX90_mtgy_op_p120      0xFF0835E0U
#define DFLT_VAL_NX90_mtgy_op_p120 0x00000000U

#define MSK_NX90_mtgy_op_p120_val         0xffffffffU
#define SRT_NX90_mtgy_op_p120_val         0
#define DFLT_VAL_NX90_mtgy_op_p120_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p120_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p120': */
#define MSK_USED_BITS_NX90_mtgy_op_p120 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p120_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P120_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p120_val; /* data bits 3871..3840 */
} NX90_MTGY_OP_P120_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P120_BIT_T bf;
} NX90_MTGY_OP_P120_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p121 */
/* => MWMM operand P register 121 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p121  0x000015E4U
#define Adr_NX90_mtgy_mtgy_op_p121 0xFF0835E4U
#define Adr_NX90_mtgy_op_p121      0xFF0835E4U
#define DFLT_VAL_NX90_mtgy_op_p121 0x00000000U

#define MSK_NX90_mtgy_op_p121_val         0xffffffffU
#define SRT_NX90_mtgy_op_p121_val         0
#define DFLT_VAL_NX90_mtgy_op_p121_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p121_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p121': */
#define MSK_USED_BITS_NX90_mtgy_op_p121 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p121_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P121_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p121_val; /* data bits 3903..3872 */
} NX90_MTGY_OP_P121_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P121_BIT_T bf;
} NX90_MTGY_OP_P121_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p122 */
/* => MWMM operand P register 122 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p122  0x000015E8U
#define Adr_NX90_mtgy_mtgy_op_p122 0xFF0835E8U
#define Adr_NX90_mtgy_op_p122      0xFF0835E8U
#define DFLT_VAL_NX90_mtgy_op_p122 0x00000000U

#define MSK_NX90_mtgy_op_p122_val         0xffffffffU
#define SRT_NX90_mtgy_op_p122_val         0
#define DFLT_VAL_NX90_mtgy_op_p122_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p122_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p122': */
#define MSK_USED_BITS_NX90_mtgy_op_p122 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p122_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P122_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p122_val; /* data bits 3935..3904 */
} NX90_MTGY_OP_P122_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P122_BIT_T bf;
} NX90_MTGY_OP_P122_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p123 */
/* => MWMM operand P register 123 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p123  0x000015ECU
#define Adr_NX90_mtgy_mtgy_op_p123 0xFF0835ECU
#define Adr_NX90_mtgy_op_p123      0xFF0835ECU
#define DFLT_VAL_NX90_mtgy_op_p123 0x00000000U

#define MSK_NX90_mtgy_op_p123_val         0xffffffffU
#define SRT_NX90_mtgy_op_p123_val         0
#define DFLT_VAL_NX90_mtgy_op_p123_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p123_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p123': */
#define MSK_USED_BITS_NX90_mtgy_op_p123 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p123_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P123_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p123_val; /* data bits 3967..3936 */
} NX90_MTGY_OP_P123_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P123_BIT_T bf;
} NX90_MTGY_OP_P123_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p124 */
/* => MWMM operand P register 124 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p124  0x000015F0U
#define Adr_NX90_mtgy_mtgy_op_p124 0xFF0835F0U
#define Adr_NX90_mtgy_op_p124      0xFF0835F0U
#define DFLT_VAL_NX90_mtgy_op_p124 0x00000000U

#define MSK_NX90_mtgy_op_p124_val         0xffffffffU
#define SRT_NX90_mtgy_op_p124_val         0
#define DFLT_VAL_NX90_mtgy_op_p124_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p124_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p124': */
#define MSK_USED_BITS_NX90_mtgy_op_p124 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p124_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P124_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p124_val; /* data bits 3999..3968 */
} NX90_MTGY_OP_P124_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P124_BIT_T bf;
} NX90_MTGY_OP_P124_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p125 */
/* => MWMM operand P register 125 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p125  0x000015F4U
#define Adr_NX90_mtgy_mtgy_op_p125 0xFF0835F4U
#define Adr_NX90_mtgy_op_p125      0xFF0835F4U
#define DFLT_VAL_NX90_mtgy_op_p125 0x00000000U

#define MSK_NX90_mtgy_op_p125_val         0xffffffffU
#define SRT_NX90_mtgy_op_p125_val         0
#define DFLT_VAL_NX90_mtgy_op_p125_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p125_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p125': */
#define MSK_USED_BITS_NX90_mtgy_op_p125 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p125_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P125_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p125_val; /* data bits 4031..4000 */
} NX90_MTGY_OP_P125_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P125_BIT_T bf;
} NX90_MTGY_OP_P125_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p126 */
/* => MWMM operand P register 126 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p126  0x000015F8U
#define Adr_NX90_mtgy_mtgy_op_p126 0xFF0835F8U
#define Adr_NX90_mtgy_op_p126      0xFF0835F8U
#define DFLT_VAL_NX90_mtgy_op_p126 0x00000000U

#define MSK_NX90_mtgy_op_p126_val         0xffffffffU
#define SRT_NX90_mtgy_op_p126_val         0
#define DFLT_VAL_NX90_mtgy_op_p126_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p126_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p126': */
#define MSK_USED_BITS_NX90_mtgy_op_p126 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p126_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P126_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p126_val; /* data bits 4063..4032 */
} NX90_MTGY_OP_P126_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P126_BIT_T bf;
} NX90_MTGY_OP_P126_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_p127 */
/* => MWMM operand P register 127 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_p127  0x000015FCU
#define Adr_NX90_mtgy_mtgy_op_p127 0xFF0835FCU
#define Adr_NX90_mtgy_op_p127      0xFF0835FCU
#define DFLT_VAL_NX90_mtgy_op_p127 0x00000000U

#define MSK_NX90_mtgy_op_p127_val         0xffffffffU
#define SRT_NX90_mtgy_op_p127_val         0
#define DFLT_VAL_NX90_mtgy_op_p127_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_p127_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_p127': */
#define MSK_USED_BITS_NX90_mtgy_op_p127 0xffffffffU

enum {
  BFW_NX90_mtgy_op_p127_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_P127_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_p127_val; /* data bits 4095..4064 */
} NX90_MTGY_OP_P127_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_P127_BIT_T bf;
} NX90_MTGY_OP_P127_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b0 */
/* => MWMM operand B register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b0  0x00001600U
#define Adr_NX90_mtgy_mtgy_op_b0 0xFF083600U
#define Adr_NX90_mtgy_op_b0      0xFF083600U
#define DFLT_VAL_NX90_mtgy_op_b0 0x00000000U

#define MSK_NX90_mtgy_op_b0_val         0xffffffffU
#define SRT_NX90_mtgy_op_b0_val         0
#define DFLT_VAL_NX90_mtgy_op_b0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b0_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b0': */
#define MSK_USED_BITS_NX90_mtgy_op_b0 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b0_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B0_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b0_val; /* data bits 31..0 */
} NX90_MTGY_OP_B0_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B0_BIT_T bf;
} NX90_MTGY_OP_B0_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b1 */
/* => MWMM operand B register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b1  0x00001604U
#define Adr_NX90_mtgy_mtgy_op_b1 0xFF083604U
#define Adr_NX90_mtgy_op_b1      0xFF083604U
#define DFLT_VAL_NX90_mtgy_op_b1 0x00000000U

#define MSK_NX90_mtgy_op_b1_val         0xffffffffU
#define SRT_NX90_mtgy_op_b1_val         0
#define DFLT_VAL_NX90_mtgy_op_b1_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b1_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b1': */
#define MSK_USED_BITS_NX90_mtgy_op_b1 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b1_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B1_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b1_val; /* data bits 63..32 */
} NX90_MTGY_OP_B1_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B1_BIT_T bf;
} NX90_MTGY_OP_B1_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b2 */
/* => MWMM operand B register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b2  0x00001608U
#define Adr_NX90_mtgy_mtgy_op_b2 0xFF083608U
#define Adr_NX90_mtgy_op_b2      0xFF083608U
#define DFLT_VAL_NX90_mtgy_op_b2 0x00000000U

#define MSK_NX90_mtgy_op_b2_val         0xffffffffU
#define SRT_NX90_mtgy_op_b2_val         0
#define DFLT_VAL_NX90_mtgy_op_b2_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b2_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b2': */
#define MSK_USED_BITS_NX90_mtgy_op_b2 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b2_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B2_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b2_val; /* data bits 95..64 */
} NX90_MTGY_OP_B2_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B2_BIT_T bf;
} NX90_MTGY_OP_B2_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b3 */
/* => MWMM operand B register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b3  0x0000160CU
#define Adr_NX90_mtgy_mtgy_op_b3 0xFF08360CU
#define Adr_NX90_mtgy_op_b3      0xFF08360CU
#define DFLT_VAL_NX90_mtgy_op_b3 0x00000000U

#define MSK_NX90_mtgy_op_b3_val         0xffffffffU
#define SRT_NX90_mtgy_op_b3_val         0
#define DFLT_VAL_NX90_mtgy_op_b3_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b3_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b3': */
#define MSK_USED_BITS_NX90_mtgy_op_b3 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b3_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B3_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b3_val; /* data bits 127..96 */
} NX90_MTGY_OP_B3_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B3_BIT_T bf;
} NX90_MTGY_OP_B3_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b4 */
/* => MWMM operand B register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b4  0x00001610U
#define Adr_NX90_mtgy_mtgy_op_b4 0xFF083610U
#define Adr_NX90_mtgy_op_b4      0xFF083610U
#define DFLT_VAL_NX90_mtgy_op_b4 0x00000000U

#define MSK_NX90_mtgy_op_b4_val         0xffffffffU
#define SRT_NX90_mtgy_op_b4_val         0
#define DFLT_VAL_NX90_mtgy_op_b4_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b4_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b4': */
#define MSK_USED_BITS_NX90_mtgy_op_b4 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b4_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B4_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b4_val; /* data bits 159..128 */
} NX90_MTGY_OP_B4_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B4_BIT_T bf;
} NX90_MTGY_OP_B4_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b5 */
/* => MWMM operand B register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b5  0x00001614U
#define Adr_NX90_mtgy_mtgy_op_b5 0xFF083614U
#define Adr_NX90_mtgy_op_b5      0xFF083614U
#define DFLT_VAL_NX90_mtgy_op_b5 0x00000000U

#define MSK_NX90_mtgy_op_b5_val         0xffffffffU
#define SRT_NX90_mtgy_op_b5_val         0
#define DFLT_VAL_NX90_mtgy_op_b5_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b5_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b5': */
#define MSK_USED_BITS_NX90_mtgy_op_b5 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b5_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B5_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b5_val; /* data bits 191..160 */
} NX90_MTGY_OP_B5_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B5_BIT_T bf;
} NX90_MTGY_OP_B5_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b6 */
/* => MWMM operand B register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b6  0x00001618U
#define Adr_NX90_mtgy_mtgy_op_b6 0xFF083618U
#define Adr_NX90_mtgy_op_b6      0xFF083618U
#define DFLT_VAL_NX90_mtgy_op_b6 0x00000000U

#define MSK_NX90_mtgy_op_b6_val         0xffffffffU
#define SRT_NX90_mtgy_op_b6_val         0
#define DFLT_VAL_NX90_mtgy_op_b6_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b6_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b6': */
#define MSK_USED_BITS_NX90_mtgy_op_b6 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b6_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B6_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b6_val; /* data bits 223..192 */
} NX90_MTGY_OP_B6_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B6_BIT_T bf;
} NX90_MTGY_OP_B6_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b7 */
/* => MWMM operand B register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b7  0x0000161CU
#define Adr_NX90_mtgy_mtgy_op_b7 0xFF08361CU
#define Adr_NX90_mtgy_op_b7      0xFF08361CU
#define DFLT_VAL_NX90_mtgy_op_b7 0x00000000U

#define MSK_NX90_mtgy_op_b7_val         0xffffffffU
#define SRT_NX90_mtgy_op_b7_val         0
#define DFLT_VAL_NX90_mtgy_op_b7_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b7_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b7': */
#define MSK_USED_BITS_NX90_mtgy_op_b7 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b7_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B7_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b7_val; /* data bits 255..224 */
} NX90_MTGY_OP_B7_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B7_BIT_T bf;
} NX90_MTGY_OP_B7_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b8 */
/* => MWMM operand B register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b8  0x00001620U
#define Adr_NX90_mtgy_mtgy_op_b8 0xFF083620U
#define Adr_NX90_mtgy_op_b8      0xFF083620U
#define DFLT_VAL_NX90_mtgy_op_b8 0x00000000U

#define MSK_NX90_mtgy_op_b8_val         0xffffffffU
#define SRT_NX90_mtgy_op_b8_val         0
#define DFLT_VAL_NX90_mtgy_op_b8_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b8_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b8': */
#define MSK_USED_BITS_NX90_mtgy_op_b8 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b8_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B8_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b8_val; /* data bits 287..256 */
} NX90_MTGY_OP_B8_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B8_BIT_T bf;
} NX90_MTGY_OP_B8_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b9 */
/* => MWMM operand B register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b9  0x00001624U
#define Adr_NX90_mtgy_mtgy_op_b9 0xFF083624U
#define Adr_NX90_mtgy_op_b9      0xFF083624U
#define DFLT_VAL_NX90_mtgy_op_b9 0x00000000U

#define MSK_NX90_mtgy_op_b9_val         0xffffffffU
#define SRT_NX90_mtgy_op_b9_val         0
#define DFLT_VAL_NX90_mtgy_op_b9_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b9_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b9': */
#define MSK_USED_BITS_NX90_mtgy_op_b9 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b9_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B9_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b9_val; /* data bits 319..288 */
} NX90_MTGY_OP_B9_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_B9_BIT_T bf;
} NX90_MTGY_OP_B9_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b10 */
/* => MWMM operand B register 10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b10  0x00001628U
#define Adr_NX90_mtgy_mtgy_op_b10 0xFF083628U
#define Adr_NX90_mtgy_op_b10      0xFF083628U
#define DFLT_VAL_NX90_mtgy_op_b10 0x00000000U

#define MSK_NX90_mtgy_op_b10_val         0xffffffffU
#define SRT_NX90_mtgy_op_b10_val         0
#define DFLT_VAL_NX90_mtgy_op_b10_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b10_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b10': */
#define MSK_USED_BITS_NX90_mtgy_op_b10 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b10_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B10_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b10_val; /* data bits 351..320 */
} NX90_MTGY_OP_B10_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B10_BIT_T bf;
} NX90_MTGY_OP_B10_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b11 */
/* => MWMM operand B register 11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b11  0x0000162CU
#define Adr_NX90_mtgy_mtgy_op_b11 0xFF08362CU
#define Adr_NX90_mtgy_op_b11      0xFF08362CU
#define DFLT_VAL_NX90_mtgy_op_b11 0x00000000U

#define MSK_NX90_mtgy_op_b11_val         0xffffffffU
#define SRT_NX90_mtgy_op_b11_val         0
#define DFLT_VAL_NX90_mtgy_op_b11_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b11_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b11': */
#define MSK_USED_BITS_NX90_mtgy_op_b11 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b11_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B11_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b11_val; /* data bits 383..352 */
} NX90_MTGY_OP_B11_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B11_BIT_T bf;
} NX90_MTGY_OP_B11_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b12 */
/* => MWMM operand B register 12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b12  0x00001630U
#define Adr_NX90_mtgy_mtgy_op_b12 0xFF083630U
#define Adr_NX90_mtgy_op_b12      0xFF083630U
#define DFLT_VAL_NX90_mtgy_op_b12 0x00000000U

#define MSK_NX90_mtgy_op_b12_val         0xffffffffU
#define SRT_NX90_mtgy_op_b12_val         0
#define DFLT_VAL_NX90_mtgy_op_b12_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b12_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b12': */
#define MSK_USED_BITS_NX90_mtgy_op_b12 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b12_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B12_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b12_val; /* data bits 415..384 */
} NX90_MTGY_OP_B12_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B12_BIT_T bf;
} NX90_MTGY_OP_B12_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b13 */
/* => MWMM operand B register 13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b13  0x00001634U
#define Adr_NX90_mtgy_mtgy_op_b13 0xFF083634U
#define Adr_NX90_mtgy_op_b13      0xFF083634U
#define DFLT_VAL_NX90_mtgy_op_b13 0x00000000U

#define MSK_NX90_mtgy_op_b13_val         0xffffffffU
#define SRT_NX90_mtgy_op_b13_val         0
#define DFLT_VAL_NX90_mtgy_op_b13_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b13_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b13': */
#define MSK_USED_BITS_NX90_mtgy_op_b13 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b13_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B13_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b13_val; /* data bits 447..416 */
} NX90_MTGY_OP_B13_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B13_BIT_T bf;
} NX90_MTGY_OP_B13_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b14 */
/* => MWMM operand B register 14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b14  0x00001638U
#define Adr_NX90_mtgy_mtgy_op_b14 0xFF083638U
#define Adr_NX90_mtgy_op_b14      0xFF083638U
#define DFLT_VAL_NX90_mtgy_op_b14 0x00000000U

#define MSK_NX90_mtgy_op_b14_val         0xffffffffU
#define SRT_NX90_mtgy_op_b14_val         0
#define DFLT_VAL_NX90_mtgy_op_b14_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b14_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b14': */
#define MSK_USED_BITS_NX90_mtgy_op_b14 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b14_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B14_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b14_val; /* data bits 479..448 */
} NX90_MTGY_OP_B14_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B14_BIT_T bf;
} NX90_MTGY_OP_B14_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b15 */
/* => MWMM operand B register 15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b15  0x0000163CU
#define Adr_NX90_mtgy_mtgy_op_b15 0xFF08363CU
#define Adr_NX90_mtgy_op_b15      0xFF08363CU
#define DFLT_VAL_NX90_mtgy_op_b15 0x00000000U

#define MSK_NX90_mtgy_op_b15_val         0xffffffffU
#define SRT_NX90_mtgy_op_b15_val         0
#define DFLT_VAL_NX90_mtgy_op_b15_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b15_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b15': */
#define MSK_USED_BITS_NX90_mtgy_op_b15 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b15_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B15_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b15_val; /* data bits 511..480 */
} NX90_MTGY_OP_B15_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B15_BIT_T bf;
} NX90_MTGY_OP_B15_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b16 */
/* => MWMM operand B register 16 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b16  0x00001640U
#define Adr_NX90_mtgy_mtgy_op_b16 0xFF083640U
#define Adr_NX90_mtgy_op_b16      0xFF083640U
#define DFLT_VAL_NX90_mtgy_op_b16 0x00000000U

#define MSK_NX90_mtgy_op_b16_val         0xffffffffU
#define SRT_NX90_mtgy_op_b16_val         0
#define DFLT_VAL_NX90_mtgy_op_b16_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b16_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b16': */
#define MSK_USED_BITS_NX90_mtgy_op_b16 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b16_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B16_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b16_val; /* data bits 543..512 */
} NX90_MTGY_OP_B16_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B16_BIT_T bf;
} NX90_MTGY_OP_B16_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b17 */
/* => MWMM operand B register 17 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b17  0x00001644U
#define Adr_NX90_mtgy_mtgy_op_b17 0xFF083644U
#define Adr_NX90_mtgy_op_b17      0xFF083644U
#define DFLT_VAL_NX90_mtgy_op_b17 0x00000000U

#define MSK_NX90_mtgy_op_b17_val         0xffffffffU
#define SRT_NX90_mtgy_op_b17_val         0
#define DFLT_VAL_NX90_mtgy_op_b17_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b17_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b17': */
#define MSK_USED_BITS_NX90_mtgy_op_b17 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b17_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B17_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b17_val; /* data bits 575..544 */
} NX90_MTGY_OP_B17_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B17_BIT_T bf;
} NX90_MTGY_OP_B17_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b18 */
/* => MWMM operand B register 18 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b18  0x00001648U
#define Adr_NX90_mtgy_mtgy_op_b18 0xFF083648U
#define Adr_NX90_mtgy_op_b18      0xFF083648U
#define DFLT_VAL_NX90_mtgy_op_b18 0x00000000U

#define MSK_NX90_mtgy_op_b18_val         0xffffffffU
#define SRT_NX90_mtgy_op_b18_val         0
#define DFLT_VAL_NX90_mtgy_op_b18_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b18_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b18': */
#define MSK_USED_BITS_NX90_mtgy_op_b18 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b18_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B18_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b18_val; /* data bits 607..576 */
} NX90_MTGY_OP_B18_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B18_BIT_T bf;
} NX90_MTGY_OP_B18_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b19 */
/* => MWMM operand B register 19 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b19  0x0000164CU
#define Adr_NX90_mtgy_mtgy_op_b19 0xFF08364CU
#define Adr_NX90_mtgy_op_b19      0xFF08364CU
#define DFLT_VAL_NX90_mtgy_op_b19 0x00000000U

#define MSK_NX90_mtgy_op_b19_val         0xffffffffU
#define SRT_NX90_mtgy_op_b19_val         0
#define DFLT_VAL_NX90_mtgy_op_b19_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b19_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b19': */
#define MSK_USED_BITS_NX90_mtgy_op_b19 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b19_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B19_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b19_val; /* data bits 639..608 */
} NX90_MTGY_OP_B19_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B19_BIT_T bf;
} NX90_MTGY_OP_B19_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b20 */
/* => MWMM operand B register 20 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b20  0x00001650U
#define Adr_NX90_mtgy_mtgy_op_b20 0xFF083650U
#define Adr_NX90_mtgy_op_b20      0xFF083650U
#define DFLT_VAL_NX90_mtgy_op_b20 0x00000000U

#define MSK_NX90_mtgy_op_b20_val         0xffffffffU
#define SRT_NX90_mtgy_op_b20_val         0
#define DFLT_VAL_NX90_mtgy_op_b20_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b20_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b20': */
#define MSK_USED_BITS_NX90_mtgy_op_b20 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b20_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B20_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b20_val; /* data bits 671..640 */
} NX90_MTGY_OP_B20_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B20_BIT_T bf;
} NX90_MTGY_OP_B20_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b21 */
/* => MWMM operand B register 21 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b21  0x00001654U
#define Adr_NX90_mtgy_mtgy_op_b21 0xFF083654U
#define Adr_NX90_mtgy_op_b21      0xFF083654U
#define DFLT_VAL_NX90_mtgy_op_b21 0x00000000U

#define MSK_NX90_mtgy_op_b21_val         0xffffffffU
#define SRT_NX90_mtgy_op_b21_val         0
#define DFLT_VAL_NX90_mtgy_op_b21_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b21_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b21': */
#define MSK_USED_BITS_NX90_mtgy_op_b21 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b21_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B21_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b21_val; /* data bits 703..672 */
} NX90_MTGY_OP_B21_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B21_BIT_T bf;
} NX90_MTGY_OP_B21_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b22 */
/* => MWMM operand B register 22 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b22  0x00001658U
#define Adr_NX90_mtgy_mtgy_op_b22 0xFF083658U
#define Adr_NX90_mtgy_op_b22      0xFF083658U
#define DFLT_VAL_NX90_mtgy_op_b22 0x00000000U

#define MSK_NX90_mtgy_op_b22_val         0xffffffffU
#define SRT_NX90_mtgy_op_b22_val         0
#define DFLT_VAL_NX90_mtgy_op_b22_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b22_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b22': */
#define MSK_USED_BITS_NX90_mtgy_op_b22 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b22_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B22_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b22_val; /* data bits 735..704 */
} NX90_MTGY_OP_B22_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B22_BIT_T bf;
} NX90_MTGY_OP_B22_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b23 */
/* => MWMM operand B register 23 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b23  0x0000165CU
#define Adr_NX90_mtgy_mtgy_op_b23 0xFF08365CU
#define Adr_NX90_mtgy_op_b23      0xFF08365CU
#define DFLT_VAL_NX90_mtgy_op_b23 0x00000000U

#define MSK_NX90_mtgy_op_b23_val         0xffffffffU
#define SRT_NX90_mtgy_op_b23_val         0
#define DFLT_VAL_NX90_mtgy_op_b23_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b23_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b23': */
#define MSK_USED_BITS_NX90_mtgy_op_b23 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b23_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B23_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b23_val; /* data bits 767..736 */
} NX90_MTGY_OP_B23_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B23_BIT_T bf;
} NX90_MTGY_OP_B23_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b24 */
/* => MWMM operand B register 24 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b24  0x00001660U
#define Adr_NX90_mtgy_mtgy_op_b24 0xFF083660U
#define Adr_NX90_mtgy_op_b24      0xFF083660U
#define DFLT_VAL_NX90_mtgy_op_b24 0x00000000U

#define MSK_NX90_mtgy_op_b24_val         0xffffffffU
#define SRT_NX90_mtgy_op_b24_val         0
#define DFLT_VAL_NX90_mtgy_op_b24_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b24_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b24': */
#define MSK_USED_BITS_NX90_mtgy_op_b24 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b24_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B24_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b24_val; /* data bits 799..768 */
} NX90_MTGY_OP_B24_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B24_BIT_T bf;
} NX90_MTGY_OP_B24_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b25 */
/* => MWMM operand B register 25 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b25  0x00001664U
#define Adr_NX90_mtgy_mtgy_op_b25 0xFF083664U
#define Adr_NX90_mtgy_op_b25      0xFF083664U
#define DFLT_VAL_NX90_mtgy_op_b25 0x00000000U

#define MSK_NX90_mtgy_op_b25_val         0xffffffffU
#define SRT_NX90_mtgy_op_b25_val         0
#define DFLT_VAL_NX90_mtgy_op_b25_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b25_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b25': */
#define MSK_USED_BITS_NX90_mtgy_op_b25 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b25_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B25_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b25_val; /* data bits 831..800 */
} NX90_MTGY_OP_B25_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B25_BIT_T bf;
} NX90_MTGY_OP_B25_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b26 */
/* => MWMM operand B register 26 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b26  0x00001668U
#define Adr_NX90_mtgy_mtgy_op_b26 0xFF083668U
#define Adr_NX90_mtgy_op_b26      0xFF083668U
#define DFLT_VAL_NX90_mtgy_op_b26 0x00000000U

#define MSK_NX90_mtgy_op_b26_val         0xffffffffU
#define SRT_NX90_mtgy_op_b26_val         0
#define DFLT_VAL_NX90_mtgy_op_b26_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b26_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b26': */
#define MSK_USED_BITS_NX90_mtgy_op_b26 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b26_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B26_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b26_val; /* data bits 863..832 */
} NX90_MTGY_OP_B26_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B26_BIT_T bf;
} NX90_MTGY_OP_B26_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b27 */
/* => MWMM operand B register 27 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b27  0x0000166CU
#define Adr_NX90_mtgy_mtgy_op_b27 0xFF08366CU
#define Adr_NX90_mtgy_op_b27      0xFF08366CU
#define DFLT_VAL_NX90_mtgy_op_b27 0x00000000U

#define MSK_NX90_mtgy_op_b27_val         0xffffffffU
#define SRT_NX90_mtgy_op_b27_val         0
#define DFLT_VAL_NX90_mtgy_op_b27_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b27_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b27': */
#define MSK_USED_BITS_NX90_mtgy_op_b27 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b27_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B27_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b27_val; /* data bits 895..864 */
} NX90_MTGY_OP_B27_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B27_BIT_T bf;
} NX90_MTGY_OP_B27_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b28 */
/* => MWMM operand B register 28 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b28  0x00001670U
#define Adr_NX90_mtgy_mtgy_op_b28 0xFF083670U
#define Adr_NX90_mtgy_op_b28      0xFF083670U
#define DFLT_VAL_NX90_mtgy_op_b28 0x00000000U

#define MSK_NX90_mtgy_op_b28_val         0xffffffffU
#define SRT_NX90_mtgy_op_b28_val         0
#define DFLT_VAL_NX90_mtgy_op_b28_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b28_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b28': */
#define MSK_USED_BITS_NX90_mtgy_op_b28 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b28_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B28_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b28_val; /* data bits 927..896 */
} NX90_MTGY_OP_B28_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B28_BIT_T bf;
} NX90_MTGY_OP_B28_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b29 */
/* => MWMM operand B register 29 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b29  0x00001674U
#define Adr_NX90_mtgy_mtgy_op_b29 0xFF083674U
#define Adr_NX90_mtgy_op_b29      0xFF083674U
#define DFLT_VAL_NX90_mtgy_op_b29 0x00000000U

#define MSK_NX90_mtgy_op_b29_val         0xffffffffU
#define SRT_NX90_mtgy_op_b29_val         0
#define DFLT_VAL_NX90_mtgy_op_b29_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b29_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b29': */
#define MSK_USED_BITS_NX90_mtgy_op_b29 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b29_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B29_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b29_val; /* data bits 959..928 */
} NX90_MTGY_OP_B29_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B29_BIT_T bf;
} NX90_MTGY_OP_B29_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b30 */
/* => MWMM operand B register 30 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b30  0x00001678U
#define Adr_NX90_mtgy_mtgy_op_b30 0xFF083678U
#define Adr_NX90_mtgy_op_b30      0xFF083678U
#define DFLT_VAL_NX90_mtgy_op_b30 0x00000000U

#define MSK_NX90_mtgy_op_b30_val         0xffffffffU
#define SRT_NX90_mtgy_op_b30_val         0
#define DFLT_VAL_NX90_mtgy_op_b30_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b30_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b30': */
#define MSK_USED_BITS_NX90_mtgy_op_b30 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b30_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B30_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b30_val; /* data bits 991..960 */
} NX90_MTGY_OP_B30_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B30_BIT_T bf;
} NX90_MTGY_OP_B30_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b31 */
/* => MWMM operand B register 31 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b31  0x0000167CU
#define Adr_NX90_mtgy_mtgy_op_b31 0xFF08367CU
#define Adr_NX90_mtgy_op_b31      0xFF08367CU
#define DFLT_VAL_NX90_mtgy_op_b31 0x00000000U

#define MSK_NX90_mtgy_op_b31_val         0xffffffffU
#define SRT_NX90_mtgy_op_b31_val         0
#define DFLT_VAL_NX90_mtgy_op_b31_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b31_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b31': */
#define MSK_USED_BITS_NX90_mtgy_op_b31 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b31_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B31_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b31_val; /* data bits 1023..992 */
} NX90_MTGY_OP_B31_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B31_BIT_T bf;
} NX90_MTGY_OP_B31_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b32 */
/* => MWMM operand B register 32 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b32  0x00001680U
#define Adr_NX90_mtgy_mtgy_op_b32 0xFF083680U
#define Adr_NX90_mtgy_op_b32      0xFF083680U
#define DFLT_VAL_NX90_mtgy_op_b32 0x00000000U

#define MSK_NX90_mtgy_op_b32_val         0xffffffffU
#define SRT_NX90_mtgy_op_b32_val         0
#define DFLT_VAL_NX90_mtgy_op_b32_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b32_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b32': */
#define MSK_USED_BITS_NX90_mtgy_op_b32 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b32_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B32_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b32_val; /* data bits 1055..1024 */
} NX90_MTGY_OP_B32_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B32_BIT_T bf;
} NX90_MTGY_OP_B32_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b33 */
/* => MWMM operand B register 33 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b33  0x00001684U
#define Adr_NX90_mtgy_mtgy_op_b33 0xFF083684U
#define Adr_NX90_mtgy_op_b33      0xFF083684U
#define DFLT_VAL_NX90_mtgy_op_b33 0x00000000U

#define MSK_NX90_mtgy_op_b33_val         0xffffffffU
#define SRT_NX90_mtgy_op_b33_val         0
#define DFLT_VAL_NX90_mtgy_op_b33_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b33_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b33': */
#define MSK_USED_BITS_NX90_mtgy_op_b33 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b33_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B33_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b33_val; /* data bits 1087..1056 */
} NX90_MTGY_OP_B33_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B33_BIT_T bf;
} NX90_MTGY_OP_B33_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b34 */
/* => MWMM operand B register 34 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b34  0x00001688U
#define Adr_NX90_mtgy_mtgy_op_b34 0xFF083688U
#define Adr_NX90_mtgy_op_b34      0xFF083688U
#define DFLT_VAL_NX90_mtgy_op_b34 0x00000000U

#define MSK_NX90_mtgy_op_b34_val         0xffffffffU
#define SRT_NX90_mtgy_op_b34_val         0
#define DFLT_VAL_NX90_mtgy_op_b34_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b34_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b34': */
#define MSK_USED_BITS_NX90_mtgy_op_b34 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b34_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B34_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b34_val; /* data bits 1119..1088 */
} NX90_MTGY_OP_B34_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B34_BIT_T bf;
} NX90_MTGY_OP_B34_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b35 */
/* => MWMM operand B register 35 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b35  0x0000168CU
#define Adr_NX90_mtgy_mtgy_op_b35 0xFF08368CU
#define Adr_NX90_mtgy_op_b35      0xFF08368CU
#define DFLT_VAL_NX90_mtgy_op_b35 0x00000000U

#define MSK_NX90_mtgy_op_b35_val         0xffffffffU
#define SRT_NX90_mtgy_op_b35_val         0
#define DFLT_VAL_NX90_mtgy_op_b35_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b35_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b35': */
#define MSK_USED_BITS_NX90_mtgy_op_b35 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b35_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B35_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b35_val; /* data bits 1151..1120 */
} NX90_MTGY_OP_B35_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B35_BIT_T bf;
} NX90_MTGY_OP_B35_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b36 */
/* => MWMM operand B register 36 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b36  0x00001690U
#define Adr_NX90_mtgy_mtgy_op_b36 0xFF083690U
#define Adr_NX90_mtgy_op_b36      0xFF083690U
#define DFLT_VAL_NX90_mtgy_op_b36 0x00000000U

#define MSK_NX90_mtgy_op_b36_val         0xffffffffU
#define SRT_NX90_mtgy_op_b36_val         0
#define DFLT_VAL_NX90_mtgy_op_b36_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b36_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b36': */
#define MSK_USED_BITS_NX90_mtgy_op_b36 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b36_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B36_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b36_val; /* data bits 1183..1152 */
} NX90_MTGY_OP_B36_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B36_BIT_T bf;
} NX90_MTGY_OP_B36_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b37 */
/* => MWMM operand B register 37 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b37  0x00001694U
#define Adr_NX90_mtgy_mtgy_op_b37 0xFF083694U
#define Adr_NX90_mtgy_op_b37      0xFF083694U
#define DFLT_VAL_NX90_mtgy_op_b37 0x00000000U

#define MSK_NX90_mtgy_op_b37_val         0xffffffffU
#define SRT_NX90_mtgy_op_b37_val         0
#define DFLT_VAL_NX90_mtgy_op_b37_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b37_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b37': */
#define MSK_USED_BITS_NX90_mtgy_op_b37 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b37_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B37_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b37_val; /* data bits 1215..1184 */
} NX90_MTGY_OP_B37_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B37_BIT_T bf;
} NX90_MTGY_OP_B37_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b38 */
/* => MWMM operand B register 38 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b38  0x00001698U
#define Adr_NX90_mtgy_mtgy_op_b38 0xFF083698U
#define Adr_NX90_mtgy_op_b38      0xFF083698U
#define DFLT_VAL_NX90_mtgy_op_b38 0x00000000U

#define MSK_NX90_mtgy_op_b38_val         0xffffffffU
#define SRT_NX90_mtgy_op_b38_val         0
#define DFLT_VAL_NX90_mtgy_op_b38_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b38_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b38': */
#define MSK_USED_BITS_NX90_mtgy_op_b38 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b38_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B38_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b38_val; /* data bits 1247..1216 */
} NX90_MTGY_OP_B38_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B38_BIT_T bf;
} NX90_MTGY_OP_B38_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b39 */
/* => MWMM operand B register 39 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b39  0x0000169CU
#define Adr_NX90_mtgy_mtgy_op_b39 0xFF08369CU
#define Adr_NX90_mtgy_op_b39      0xFF08369CU
#define DFLT_VAL_NX90_mtgy_op_b39 0x00000000U

#define MSK_NX90_mtgy_op_b39_val         0xffffffffU
#define SRT_NX90_mtgy_op_b39_val         0
#define DFLT_VAL_NX90_mtgy_op_b39_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b39_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b39': */
#define MSK_USED_BITS_NX90_mtgy_op_b39 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b39_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B39_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b39_val; /* data bits 1279..1248 */
} NX90_MTGY_OP_B39_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B39_BIT_T bf;
} NX90_MTGY_OP_B39_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b40 */
/* => MWMM operand B register 40 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b40  0x000016A0U
#define Adr_NX90_mtgy_mtgy_op_b40 0xFF0836A0U
#define Adr_NX90_mtgy_op_b40      0xFF0836A0U
#define DFLT_VAL_NX90_mtgy_op_b40 0x00000000U

#define MSK_NX90_mtgy_op_b40_val         0xffffffffU
#define SRT_NX90_mtgy_op_b40_val         0
#define DFLT_VAL_NX90_mtgy_op_b40_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b40_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b40': */
#define MSK_USED_BITS_NX90_mtgy_op_b40 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b40_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B40_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b40_val; /* data bits 1311..1280 */
} NX90_MTGY_OP_B40_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B40_BIT_T bf;
} NX90_MTGY_OP_B40_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b41 */
/* => MWMM operand B register 41 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b41  0x000016A4U
#define Adr_NX90_mtgy_mtgy_op_b41 0xFF0836A4U
#define Adr_NX90_mtgy_op_b41      0xFF0836A4U
#define DFLT_VAL_NX90_mtgy_op_b41 0x00000000U

#define MSK_NX90_mtgy_op_b41_val         0xffffffffU
#define SRT_NX90_mtgy_op_b41_val         0
#define DFLT_VAL_NX90_mtgy_op_b41_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b41_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b41': */
#define MSK_USED_BITS_NX90_mtgy_op_b41 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b41_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B41_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b41_val; /* data bits 1343..1312 */
} NX90_MTGY_OP_B41_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B41_BIT_T bf;
} NX90_MTGY_OP_B41_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b42 */
/* => MWMM operand B register 42 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b42  0x000016A8U
#define Adr_NX90_mtgy_mtgy_op_b42 0xFF0836A8U
#define Adr_NX90_mtgy_op_b42      0xFF0836A8U
#define DFLT_VAL_NX90_mtgy_op_b42 0x00000000U

#define MSK_NX90_mtgy_op_b42_val         0xffffffffU
#define SRT_NX90_mtgy_op_b42_val         0
#define DFLT_VAL_NX90_mtgy_op_b42_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b42_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b42': */
#define MSK_USED_BITS_NX90_mtgy_op_b42 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b42_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B42_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b42_val; /* data bits 1375..1344 */
} NX90_MTGY_OP_B42_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B42_BIT_T bf;
} NX90_MTGY_OP_B42_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b43 */
/* => MWMM operand B register 43 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b43  0x000016ACU
#define Adr_NX90_mtgy_mtgy_op_b43 0xFF0836ACU
#define Adr_NX90_mtgy_op_b43      0xFF0836ACU
#define DFLT_VAL_NX90_mtgy_op_b43 0x00000000U

#define MSK_NX90_mtgy_op_b43_val         0xffffffffU
#define SRT_NX90_mtgy_op_b43_val         0
#define DFLT_VAL_NX90_mtgy_op_b43_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b43_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b43': */
#define MSK_USED_BITS_NX90_mtgy_op_b43 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b43_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B43_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b43_val; /* data bits 1407..1376 */
} NX90_MTGY_OP_B43_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B43_BIT_T bf;
} NX90_MTGY_OP_B43_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b44 */
/* => MWMM operand B register 44 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b44  0x000016B0U
#define Adr_NX90_mtgy_mtgy_op_b44 0xFF0836B0U
#define Adr_NX90_mtgy_op_b44      0xFF0836B0U
#define DFLT_VAL_NX90_mtgy_op_b44 0x00000000U

#define MSK_NX90_mtgy_op_b44_val         0xffffffffU
#define SRT_NX90_mtgy_op_b44_val         0
#define DFLT_VAL_NX90_mtgy_op_b44_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b44_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b44': */
#define MSK_USED_BITS_NX90_mtgy_op_b44 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b44_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B44_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b44_val; /* data bits 1439..1408 */
} NX90_MTGY_OP_B44_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B44_BIT_T bf;
} NX90_MTGY_OP_B44_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b45 */
/* => MWMM operand B register 45 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b45  0x000016B4U
#define Adr_NX90_mtgy_mtgy_op_b45 0xFF0836B4U
#define Adr_NX90_mtgy_op_b45      0xFF0836B4U
#define DFLT_VAL_NX90_mtgy_op_b45 0x00000000U

#define MSK_NX90_mtgy_op_b45_val         0xffffffffU
#define SRT_NX90_mtgy_op_b45_val         0
#define DFLT_VAL_NX90_mtgy_op_b45_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b45_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b45': */
#define MSK_USED_BITS_NX90_mtgy_op_b45 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b45_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B45_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b45_val; /* data bits 1471..1440 */
} NX90_MTGY_OP_B45_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B45_BIT_T bf;
} NX90_MTGY_OP_B45_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b46 */
/* => MWMM operand B register 46 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b46  0x000016B8U
#define Adr_NX90_mtgy_mtgy_op_b46 0xFF0836B8U
#define Adr_NX90_mtgy_op_b46      0xFF0836B8U
#define DFLT_VAL_NX90_mtgy_op_b46 0x00000000U

#define MSK_NX90_mtgy_op_b46_val         0xffffffffU
#define SRT_NX90_mtgy_op_b46_val         0
#define DFLT_VAL_NX90_mtgy_op_b46_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b46_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b46': */
#define MSK_USED_BITS_NX90_mtgy_op_b46 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b46_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B46_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b46_val; /* data bits 1503..1472 */
} NX90_MTGY_OP_B46_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B46_BIT_T bf;
} NX90_MTGY_OP_B46_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b47 */
/* => MWMM operand B register 47 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b47  0x000016BCU
#define Adr_NX90_mtgy_mtgy_op_b47 0xFF0836BCU
#define Adr_NX90_mtgy_op_b47      0xFF0836BCU
#define DFLT_VAL_NX90_mtgy_op_b47 0x00000000U

#define MSK_NX90_mtgy_op_b47_val         0xffffffffU
#define SRT_NX90_mtgy_op_b47_val         0
#define DFLT_VAL_NX90_mtgy_op_b47_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b47_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b47': */
#define MSK_USED_BITS_NX90_mtgy_op_b47 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b47_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B47_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b47_val; /* data bits 1535..1504 */
} NX90_MTGY_OP_B47_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B47_BIT_T bf;
} NX90_MTGY_OP_B47_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b48 */
/* => MWMM operand B register 48 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b48  0x000016C0U
#define Adr_NX90_mtgy_mtgy_op_b48 0xFF0836C0U
#define Adr_NX90_mtgy_op_b48      0xFF0836C0U
#define DFLT_VAL_NX90_mtgy_op_b48 0x00000000U

#define MSK_NX90_mtgy_op_b48_val         0xffffffffU
#define SRT_NX90_mtgy_op_b48_val         0
#define DFLT_VAL_NX90_mtgy_op_b48_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b48_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b48': */
#define MSK_USED_BITS_NX90_mtgy_op_b48 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b48_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B48_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b48_val; /* data bits 1567..1536 */
} NX90_MTGY_OP_B48_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B48_BIT_T bf;
} NX90_MTGY_OP_B48_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b49 */
/* => MWMM operand B register 49 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b49  0x000016C4U
#define Adr_NX90_mtgy_mtgy_op_b49 0xFF0836C4U
#define Adr_NX90_mtgy_op_b49      0xFF0836C4U
#define DFLT_VAL_NX90_mtgy_op_b49 0x00000000U

#define MSK_NX90_mtgy_op_b49_val         0xffffffffU
#define SRT_NX90_mtgy_op_b49_val         0
#define DFLT_VAL_NX90_mtgy_op_b49_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b49_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b49': */
#define MSK_USED_BITS_NX90_mtgy_op_b49 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b49_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B49_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b49_val; /* data bits 1599..1568 */
} NX90_MTGY_OP_B49_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B49_BIT_T bf;
} NX90_MTGY_OP_B49_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b50 */
/* => MWMM operand B register 50 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b50  0x000016C8U
#define Adr_NX90_mtgy_mtgy_op_b50 0xFF0836C8U
#define Adr_NX90_mtgy_op_b50      0xFF0836C8U
#define DFLT_VAL_NX90_mtgy_op_b50 0x00000000U

#define MSK_NX90_mtgy_op_b50_val         0xffffffffU
#define SRT_NX90_mtgy_op_b50_val         0
#define DFLT_VAL_NX90_mtgy_op_b50_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b50_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b50': */
#define MSK_USED_BITS_NX90_mtgy_op_b50 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b50_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B50_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b50_val; /* data bits 1631..1600 */
} NX90_MTGY_OP_B50_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B50_BIT_T bf;
} NX90_MTGY_OP_B50_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b51 */
/* => MWMM operand B register 51 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b51  0x000016CCU
#define Adr_NX90_mtgy_mtgy_op_b51 0xFF0836CCU
#define Adr_NX90_mtgy_op_b51      0xFF0836CCU
#define DFLT_VAL_NX90_mtgy_op_b51 0x00000000U

#define MSK_NX90_mtgy_op_b51_val         0xffffffffU
#define SRT_NX90_mtgy_op_b51_val         0
#define DFLT_VAL_NX90_mtgy_op_b51_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b51_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b51': */
#define MSK_USED_BITS_NX90_mtgy_op_b51 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b51_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B51_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b51_val; /* data bits 1663..1632 */
} NX90_MTGY_OP_B51_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B51_BIT_T bf;
} NX90_MTGY_OP_B51_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b52 */
/* => MWMM operand B register 52 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b52  0x000016D0U
#define Adr_NX90_mtgy_mtgy_op_b52 0xFF0836D0U
#define Adr_NX90_mtgy_op_b52      0xFF0836D0U
#define DFLT_VAL_NX90_mtgy_op_b52 0x00000000U

#define MSK_NX90_mtgy_op_b52_val         0xffffffffU
#define SRT_NX90_mtgy_op_b52_val         0
#define DFLT_VAL_NX90_mtgy_op_b52_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b52_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b52': */
#define MSK_USED_BITS_NX90_mtgy_op_b52 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b52_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B52_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b52_val; /* data bits 1695..1664 */
} NX90_MTGY_OP_B52_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B52_BIT_T bf;
} NX90_MTGY_OP_B52_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b53 */
/* => MWMM operand B register 53 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b53  0x000016D4U
#define Adr_NX90_mtgy_mtgy_op_b53 0xFF0836D4U
#define Adr_NX90_mtgy_op_b53      0xFF0836D4U
#define DFLT_VAL_NX90_mtgy_op_b53 0x00000000U

#define MSK_NX90_mtgy_op_b53_val         0xffffffffU
#define SRT_NX90_mtgy_op_b53_val         0
#define DFLT_VAL_NX90_mtgy_op_b53_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b53_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b53': */
#define MSK_USED_BITS_NX90_mtgy_op_b53 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b53_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B53_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b53_val; /* data bits 1727..1696 */
} NX90_MTGY_OP_B53_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B53_BIT_T bf;
} NX90_MTGY_OP_B53_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b54 */
/* => MWMM operand B register 54 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b54  0x000016D8U
#define Adr_NX90_mtgy_mtgy_op_b54 0xFF0836D8U
#define Adr_NX90_mtgy_op_b54      0xFF0836D8U
#define DFLT_VAL_NX90_mtgy_op_b54 0x00000000U

#define MSK_NX90_mtgy_op_b54_val         0xffffffffU
#define SRT_NX90_mtgy_op_b54_val         0
#define DFLT_VAL_NX90_mtgy_op_b54_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b54_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b54': */
#define MSK_USED_BITS_NX90_mtgy_op_b54 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b54_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B54_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b54_val; /* data bits 1759..1728 */
} NX90_MTGY_OP_B54_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B54_BIT_T bf;
} NX90_MTGY_OP_B54_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b55 */
/* => MWMM operand B register 55 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b55  0x000016DCU
#define Adr_NX90_mtgy_mtgy_op_b55 0xFF0836DCU
#define Adr_NX90_mtgy_op_b55      0xFF0836DCU
#define DFLT_VAL_NX90_mtgy_op_b55 0x00000000U

#define MSK_NX90_mtgy_op_b55_val         0xffffffffU
#define SRT_NX90_mtgy_op_b55_val         0
#define DFLT_VAL_NX90_mtgy_op_b55_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b55_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b55': */
#define MSK_USED_BITS_NX90_mtgy_op_b55 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b55_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B55_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b55_val; /* data bits 1791..1760 */
} NX90_MTGY_OP_B55_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B55_BIT_T bf;
} NX90_MTGY_OP_B55_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b56 */
/* => MWMM operand B register 56 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b56  0x000016E0U
#define Adr_NX90_mtgy_mtgy_op_b56 0xFF0836E0U
#define Adr_NX90_mtgy_op_b56      0xFF0836E0U
#define DFLT_VAL_NX90_mtgy_op_b56 0x00000000U

#define MSK_NX90_mtgy_op_b56_val         0xffffffffU
#define SRT_NX90_mtgy_op_b56_val         0
#define DFLT_VAL_NX90_mtgy_op_b56_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b56_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b56': */
#define MSK_USED_BITS_NX90_mtgy_op_b56 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b56_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B56_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b56_val; /* data bits 1823..1792 */
} NX90_MTGY_OP_B56_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B56_BIT_T bf;
} NX90_MTGY_OP_B56_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b57 */
/* => MWMM operand B register 57 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b57  0x000016E4U
#define Adr_NX90_mtgy_mtgy_op_b57 0xFF0836E4U
#define Adr_NX90_mtgy_op_b57      0xFF0836E4U
#define DFLT_VAL_NX90_mtgy_op_b57 0x00000000U

#define MSK_NX90_mtgy_op_b57_val         0xffffffffU
#define SRT_NX90_mtgy_op_b57_val         0
#define DFLT_VAL_NX90_mtgy_op_b57_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b57_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b57': */
#define MSK_USED_BITS_NX90_mtgy_op_b57 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b57_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B57_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b57_val; /* data bits 1855..1824 */
} NX90_MTGY_OP_B57_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B57_BIT_T bf;
} NX90_MTGY_OP_B57_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b58 */
/* => MWMM operand B register 58 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b58  0x000016E8U
#define Adr_NX90_mtgy_mtgy_op_b58 0xFF0836E8U
#define Adr_NX90_mtgy_op_b58      0xFF0836E8U
#define DFLT_VAL_NX90_mtgy_op_b58 0x00000000U

#define MSK_NX90_mtgy_op_b58_val         0xffffffffU
#define SRT_NX90_mtgy_op_b58_val         0
#define DFLT_VAL_NX90_mtgy_op_b58_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b58_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b58': */
#define MSK_USED_BITS_NX90_mtgy_op_b58 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b58_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B58_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b58_val; /* data bits 1887..1856 */
} NX90_MTGY_OP_B58_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B58_BIT_T bf;
} NX90_MTGY_OP_B58_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b59 */
/* => MWMM operand B register 59 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b59  0x000016ECU
#define Adr_NX90_mtgy_mtgy_op_b59 0xFF0836ECU
#define Adr_NX90_mtgy_op_b59      0xFF0836ECU
#define DFLT_VAL_NX90_mtgy_op_b59 0x00000000U

#define MSK_NX90_mtgy_op_b59_val         0xffffffffU
#define SRT_NX90_mtgy_op_b59_val         0
#define DFLT_VAL_NX90_mtgy_op_b59_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b59_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b59': */
#define MSK_USED_BITS_NX90_mtgy_op_b59 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b59_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B59_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b59_val; /* data bits 1919..1888 */
} NX90_MTGY_OP_B59_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B59_BIT_T bf;
} NX90_MTGY_OP_B59_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b60 */
/* => MWMM operand B register 60 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b60  0x000016F0U
#define Adr_NX90_mtgy_mtgy_op_b60 0xFF0836F0U
#define Adr_NX90_mtgy_op_b60      0xFF0836F0U
#define DFLT_VAL_NX90_mtgy_op_b60 0x00000000U

#define MSK_NX90_mtgy_op_b60_val         0xffffffffU
#define SRT_NX90_mtgy_op_b60_val         0
#define DFLT_VAL_NX90_mtgy_op_b60_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b60_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b60': */
#define MSK_USED_BITS_NX90_mtgy_op_b60 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b60_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B60_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b60_val; /* data bits 1951..1920 */
} NX90_MTGY_OP_B60_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B60_BIT_T bf;
} NX90_MTGY_OP_B60_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b61 */
/* => MWMM operand B register 61 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b61  0x000016F4U
#define Adr_NX90_mtgy_mtgy_op_b61 0xFF0836F4U
#define Adr_NX90_mtgy_op_b61      0xFF0836F4U
#define DFLT_VAL_NX90_mtgy_op_b61 0x00000000U

#define MSK_NX90_mtgy_op_b61_val         0xffffffffU
#define SRT_NX90_mtgy_op_b61_val         0
#define DFLT_VAL_NX90_mtgy_op_b61_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b61_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b61': */
#define MSK_USED_BITS_NX90_mtgy_op_b61 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b61_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B61_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b61_val; /* data bits 1983..1952 */
} NX90_MTGY_OP_B61_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B61_BIT_T bf;
} NX90_MTGY_OP_B61_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b62 */
/* => MWMM operand B register 62 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b62  0x000016F8U
#define Adr_NX90_mtgy_mtgy_op_b62 0xFF0836F8U
#define Adr_NX90_mtgy_op_b62      0xFF0836F8U
#define DFLT_VAL_NX90_mtgy_op_b62 0x00000000U

#define MSK_NX90_mtgy_op_b62_val         0xffffffffU
#define SRT_NX90_mtgy_op_b62_val         0
#define DFLT_VAL_NX90_mtgy_op_b62_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b62_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b62': */
#define MSK_USED_BITS_NX90_mtgy_op_b62 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b62_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B62_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b62_val; /* data bits 2015..1984 */
} NX90_MTGY_OP_B62_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B62_BIT_T bf;
} NX90_MTGY_OP_B62_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b63 */
/* => MWMM operand B register 63 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b63  0x000016FCU
#define Adr_NX90_mtgy_mtgy_op_b63 0xFF0836FCU
#define Adr_NX90_mtgy_op_b63      0xFF0836FCU
#define DFLT_VAL_NX90_mtgy_op_b63 0x00000000U

#define MSK_NX90_mtgy_op_b63_val         0xffffffffU
#define SRT_NX90_mtgy_op_b63_val         0
#define DFLT_VAL_NX90_mtgy_op_b63_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b63_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b63': */
#define MSK_USED_BITS_NX90_mtgy_op_b63 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b63_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B63_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b63_val; /* data bits 2047..2016 */
} NX90_MTGY_OP_B63_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B63_BIT_T bf;
} NX90_MTGY_OP_B63_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b64 */
/* => MWMM operand B register 64 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b64  0x00001700U
#define Adr_NX90_mtgy_mtgy_op_b64 0xFF083700U
#define Adr_NX90_mtgy_op_b64      0xFF083700U
#define DFLT_VAL_NX90_mtgy_op_b64 0x00000000U

#define MSK_NX90_mtgy_op_b64_val         0xffffffffU
#define SRT_NX90_mtgy_op_b64_val         0
#define DFLT_VAL_NX90_mtgy_op_b64_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b64_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b64': */
#define MSK_USED_BITS_NX90_mtgy_op_b64 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b64_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B64_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b64_val; /* data bits 2079..2048 */
} NX90_MTGY_OP_B64_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B64_BIT_T bf;
} NX90_MTGY_OP_B64_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b65 */
/* => MWMM operand B register 65 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b65  0x00001704U
#define Adr_NX90_mtgy_mtgy_op_b65 0xFF083704U
#define Adr_NX90_mtgy_op_b65      0xFF083704U
#define DFLT_VAL_NX90_mtgy_op_b65 0x00000000U

#define MSK_NX90_mtgy_op_b65_val         0xffffffffU
#define SRT_NX90_mtgy_op_b65_val         0
#define DFLT_VAL_NX90_mtgy_op_b65_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b65_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b65': */
#define MSK_USED_BITS_NX90_mtgy_op_b65 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b65_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B65_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b65_val; /* data bits 2111..2080 */
} NX90_MTGY_OP_B65_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B65_BIT_T bf;
} NX90_MTGY_OP_B65_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b66 */
/* => MWMM operand B register 66 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b66  0x00001708U
#define Adr_NX90_mtgy_mtgy_op_b66 0xFF083708U
#define Adr_NX90_mtgy_op_b66      0xFF083708U
#define DFLT_VAL_NX90_mtgy_op_b66 0x00000000U

#define MSK_NX90_mtgy_op_b66_val         0xffffffffU
#define SRT_NX90_mtgy_op_b66_val         0
#define DFLT_VAL_NX90_mtgy_op_b66_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b66_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b66': */
#define MSK_USED_BITS_NX90_mtgy_op_b66 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b66_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B66_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b66_val; /* data bits 2143..2112 */
} NX90_MTGY_OP_B66_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B66_BIT_T bf;
} NX90_MTGY_OP_B66_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b67 */
/* => MWMM operand B register 67 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b67  0x0000170CU
#define Adr_NX90_mtgy_mtgy_op_b67 0xFF08370CU
#define Adr_NX90_mtgy_op_b67      0xFF08370CU
#define DFLT_VAL_NX90_mtgy_op_b67 0x00000000U

#define MSK_NX90_mtgy_op_b67_val         0xffffffffU
#define SRT_NX90_mtgy_op_b67_val         0
#define DFLT_VAL_NX90_mtgy_op_b67_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b67_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b67': */
#define MSK_USED_BITS_NX90_mtgy_op_b67 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b67_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B67_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b67_val; /* data bits 2175..2144 */
} NX90_MTGY_OP_B67_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B67_BIT_T bf;
} NX90_MTGY_OP_B67_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b68 */
/* => MWMM operand B register 68 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b68  0x00001710U
#define Adr_NX90_mtgy_mtgy_op_b68 0xFF083710U
#define Adr_NX90_mtgy_op_b68      0xFF083710U
#define DFLT_VAL_NX90_mtgy_op_b68 0x00000000U

#define MSK_NX90_mtgy_op_b68_val         0xffffffffU
#define SRT_NX90_mtgy_op_b68_val         0
#define DFLT_VAL_NX90_mtgy_op_b68_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b68_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b68': */
#define MSK_USED_BITS_NX90_mtgy_op_b68 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b68_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B68_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b68_val; /* data bits 2207..2176 */
} NX90_MTGY_OP_B68_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B68_BIT_T bf;
} NX90_MTGY_OP_B68_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b69 */
/* => MWMM operand B register 69 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b69  0x00001714U
#define Adr_NX90_mtgy_mtgy_op_b69 0xFF083714U
#define Adr_NX90_mtgy_op_b69      0xFF083714U
#define DFLT_VAL_NX90_mtgy_op_b69 0x00000000U

#define MSK_NX90_mtgy_op_b69_val         0xffffffffU
#define SRT_NX90_mtgy_op_b69_val         0
#define DFLT_VAL_NX90_mtgy_op_b69_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b69_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b69': */
#define MSK_USED_BITS_NX90_mtgy_op_b69 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b69_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B69_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b69_val; /* data bits 2239..2208 */
} NX90_MTGY_OP_B69_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B69_BIT_T bf;
} NX90_MTGY_OP_B69_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b70 */
/* => MWMM operand B register 70 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b70  0x00001718U
#define Adr_NX90_mtgy_mtgy_op_b70 0xFF083718U
#define Adr_NX90_mtgy_op_b70      0xFF083718U
#define DFLT_VAL_NX90_mtgy_op_b70 0x00000000U

#define MSK_NX90_mtgy_op_b70_val         0xffffffffU
#define SRT_NX90_mtgy_op_b70_val         0
#define DFLT_VAL_NX90_mtgy_op_b70_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b70_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b70': */
#define MSK_USED_BITS_NX90_mtgy_op_b70 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b70_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B70_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b70_val; /* data bits 2271..2240 */
} NX90_MTGY_OP_B70_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B70_BIT_T bf;
} NX90_MTGY_OP_B70_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b71 */
/* => MWMM operand B register 71 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b71  0x0000171CU
#define Adr_NX90_mtgy_mtgy_op_b71 0xFF08371CU
#define Adr_NX90_mtgy_op_b71      0xFF08371CU
#define DFLT_VAL_NX90_mtgy_op_b71 0x00000000U

#define MSK_NX90_mtgy_op_b71_val         0xffffffffU
#define SRT_NX90_mtgy_op_b71_val         0
#define DFLT_VAL_NX90_mtgy_op_b71_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b71_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b71': */
#define MSK_USED_BITS_NX90_mtgy_op_b71 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b71_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B71_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b71_val; /* data bits 2303..2272 */
} NX90_MTGY_OP_B71_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B71_BIT_T bf;
} NX90_MTGY_OP_B71_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b72 */
/* => MWMM operand B register 72 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b72  0x00001720U
#define Adr_NX90_mtgy_mtgy_op_b72 0xFF083720U
#define Adr_NX90_mtgy_op_b72      0xFF083720U
#define DFLT_VAL_NX90_mtgy_op_b72 0x00000000U

#define MSK_NX90_mtgy_op_b72_val         0xffffffffU
#define SRT_NX90_mtgy_op_b72_val         0
#define DFLT_VAL_NX90_mtgy_op_b72_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b72_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b72': */
#define MSK_USED_BITS_NX90_mtgy_op_b72 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b72_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B72_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b72_val; /* data bits 2335..2304 */
} NX90_MTGY_OP_B72_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B72_BIT_T bf;
} NX90_MTGY_OP_B72_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b73 */
/* => MWMM operand B register 73 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b73  0x00001724U
#define Adr_NX90_mtgy_mtgy_op_b73 0xFF083724U
#define Adr_NX90_mtgy_op_b73      0xFF083724U
#define DFLT_VAL_NX90_mtgy_op_b73 0x00000000U

#define MSK_NX90_mtgy_op_b73_val         0xffffffffU
#define SRT_NX90_mtgy_op_b73_val         0
#define DFLT_VAL_NX90_mtgy_op_b73_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b73_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b73': */
#define MSK_USED_BITS_NX90_mtgy_op_b73 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b73_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B73_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b73_val; /* data bits 2367..2336 */
} NX90_MTGY_OP_B73_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B73_BIT_T bf;
} NX90_MTGY_OP_B73_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b74 */
/* => MWMM operand B register 74 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b74  0x00001728U
#define Adr_NX90_mtgy_mtgy_op_b74 0xFF083728U
#define Adr_NX90_mtgy_op_b74      0xFF083728U
#define DFLT_VAL_NX90_mtgy_op_b74 0x00000000U

#define MSK_NX90_mtgy_op_b74_val         0xffffffffU
#define SRT_NX90_mtgy_op_b74_val         0
#define DFLT_VAL_NX90_mtgy_op_b74_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b74_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b74': */
#define MSK_USED_BITS_NX90_mtgy_op_b74 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b74_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B74_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b74_val; /* data bits 2399..2368 */
} NX90_MTGY_OP_B74_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B74_BIT_T bf;
} NX90_MTGY_OP_B74_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b75 */
/* => MWMM operand B register 75 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b75  0x0000172CU
#define Adr_NX90_mtgy_mtgy_op_b75 0xFF08372CU
#define Adr_NX90_mtgy_op_b75      0xFF08372CU
#define DFLT_VAL_NX90_mtgy_op_b75 0x00000000U

#define MSK_NX90_mtgy_op_b75_val         0xffffffffU
#define SRT_NX90_mtgy_op_b75_val         0
#define DFLT_VAL_NX90_mtgy_op_b75_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b75_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b75': */
#define MSK_USED_BITS_NX90_mtgy_op_b75 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b75_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B75_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b75_val; /* data bits 2431..2400 */
} NX90_MTGY_OP_B75_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B75_BIT_T bf;
} NX90_MTGY_OP_B75_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b76 */
/* => MWMM operand B register 76 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b76  0x00001730U
#define Adr_NX90_mtgy_mtgy_op_b76 0xFF083730U
#define Adr_NX90_mtgy_op_b76      0xFF083730U
#define DFLT_VAL_NX90_mtgy_op_b76 0x00000000U

#define MSK_NX90_mtgy_op_b76_val         0xffffffffU
#define SRT_NX90_mtgy_op_b76_val         0
#define DFLT_VAL_NX90_mtgy_op_b76_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b76_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b76': */
#define MSK_USED_BITS_NX90_mtgy_op_b76 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b76_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B76_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b76_val; /* data bits 2463..2432 */
} NX90_MTGY_OP_B76_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B76_BIT_T bf;
} NX90_MTGY_OP_B76_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b77 */
/* => MWMM operand B register 77 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b77  0x00001734U
#define Adr_NX90_mtgy_mtgy_op_b77 0xFF083734U
#define Adr_NX90_mtgy_op_b77      0xFF083734U
#define DFLT_VAL_NX90_mtgy_op_b77 0x00000000U

#define MSK_NX90_mtgy_op_b77_val         0xffffffffU
#define SRT_NX90_mtgy_op_b77_val         0
#define DFLT_VAL_NX90_mtgy_op_b77_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b77_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b77': */
#define MSK_USED_BITS_NX90_mtgy_op_b77 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b77_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B77_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b77_val; /* data bits 2495..2464 */
} NX90_MTGY_OP_B77_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B77_BIT_T bf;
} NX90_MTGY_OP_B77_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b78 */
/* => MWMM operand B register 78 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b78  0x00001738U
#define Adr_NX90_mtgy_mtgy_op_b78 0xFF083738U
#define Adr_NX90_mtgy_op_b78      0xFF083738U
#define DFLT_VAL_NX90_mtgy_op_b78 0x00000000U

#define MSK_NX90_mtgy_op_b78_val         0xffffffffU
#define SRT_NX90_mtgy_op_b78_val         0
#define DFLT_VAL_NX90_mtgy_op_b78_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b78_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b78': */
#define MSK_USED_BITS_NX90_mtgy_op_b78 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b78_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B78_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b78_val; /* data bits 2527..2496 */
} NX90_MTGY_OP_B78_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B78_BIT_T bf;
} NX90_MTGY_OP_B78_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b79 */
/* => MWMM operand B register 79 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b79  0x0000173CU
#define Adr_NX90_mtgy_mtgy_op_b79 0xFF08373CU
#define Adr_NX90_mtgy_op_b79      0xFF08373CU
#define DFLT_VAL_NX90_mtgy_op_b79 0x00000000U

#define MSK_NX90_mtgy_op_b79_val         0xffffffffU
#define SRT_NX90_mtgy_op_b79_val         0
#define DFLT_VAL_NX90_mtgy_op_b79_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b79_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b79': */
#define MSK_USED_BITS_NX90_mtgy_op_b79 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b79_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B79_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b79_val; /* data bits 2559..2528 */
} NX90_MTGY_OP_B79_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B79_BIT_T bf;
} NX90_MTGY_OP_B79_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b80 */
/* => MWMM operand B register 80 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b80  0x00001740U
#define Adr_NX90_mtgy_mtgy_op_b80 0xFF083740U
#define Adr_NX90_mtgy_op_b80      0xFF083740U
#define DFLT_VAL_NX90_mtgy_op_b80 0x00000000U

#define MSK_NX90_mtgy_op_b80_val         0xffffffffU
#define SRT_NX90_mtgy_op_b80_val         0
#define DFLT_VAL_NX90_mtgy_op_b80_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b80_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b80': */
#define MSK_USED_BITS_NX90_mtgy_op_b80 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b80_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B80_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b80_val; /* data bits 2591..2560 */
} NX90_MTGY_OP_B80_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B80_BIT_T bf;
} NX90_MTGY_OP_B80_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b81 */
/* => MWMM operand B register 81 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b81  0x00001744U
#define Adr_NX90_mtgy_mtgy_op_b81 0xFF083744U
#define Adr_NX90_mtgy_op_b81      0xFF083744U
#define DFLT_VAL_NX90_mtgy_op_b81 0x00000000U

#define MSK_NX90_mtgy_op_b81_val         0xffffffffU
#define SRT_NX90_mtgy_op_b81_val         0
#define DFLT_VAL_NX90_mtgy_op_b81_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b81_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b81': */
#define MSK_USED_BITS_NX90_mtgy_op_b81 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b81_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B81_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b81_val; /* data bits 2623..2592 */
} NX90_MTGY_OP_B81_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B81_BIT_T bf;
} NX90_MTGY_OP_B81_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b82 */
/* => MWMM operand B register 82 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b82  0x00001748U
#define Adr_NX90_mtgy_mtgy_op_b82 0xFF083748U
#define Adr_NX90_mtgy_op_b82      0xFF083748U
#define DFLT_VAL_NX90_mtgy_op_b82 0x00000000U

#define MSK_NX90_mtgy_op_b82_val         0xffffffffU
#define SRT_NX90_mtgy_op_b82_val         0
#define DFLT_VAL_NX90_mtgy_op_b82_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b82_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b82': */
#define MSK_USED_BITS_NX90_mtgy_op_b82 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b82_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B82_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b82_val; /* data bits 2655..2624 */
} NX90_MTGY_OP_B82_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B82_BIT_T bf;
} NX90_MTGY_OP_B82_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b83 */
/* => MWMM operand B register 83 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b83  0x0000174CU
#define Adr_NX90_mtgy_mtgy_op_b83 0xFF08374CU
#define Adr_NX90_mtgy_op_b83      0xFF08374CU
#define DFLT_VAL_NX90_mtgy_op_b83 0x00000000U

#define MSK_NX90_mtgy_op_b83_val         0xffffffffU
#define SRT_NX90_mtgy_op_b83_val         0
#define DFLT_VAL_NX90_mtgy_op_b83_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b83_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b83': */
#define MSK_USED_BITS_NX90_mtgy_op_b83 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b83_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B83_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b83_val; /* data bits 2687..2656 */
} NX90_MTGY_OP_B83_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B83_BIT_T bf;
} NX90_MTGY_OP_B83_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b84 */
/* => MWMM operand B register 84 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b84  0x00001750U
#define Adr_NX90_mtgy_mtgy_op_b84 0xFF083750U
#define Adr_NX90_mtgy_op_b84      0xFF083750U
#define DFLT_VAL_NX90_mtgy_op_b84 0x00000000U

#define MSK_NX90_mtgy_op_b84_val         0xffffffffU
#define SRT_NX90_mtgy_op_b84_val         0
#define DFLT_VAL_NX90_mtgy_op_b84_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b84_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b84': */
#define MSK_USED_BITS_NX90_mtgy_op_b84 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b84_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B84_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b84_val; /* data bits 2719..2688 */
} NX90_MTGY_OP_B84_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B84_BIT_T bf;
} NX90_MTGY_OP_B84_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b85 */
/* => MWMM operand B register 85 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b85  0x00001754U
#define Adr_NX90_mtgy_mtgy_op_b85 0xFF083754U
#define Adr_NX90_mtgy_op_b85      0xFF083754U
#define DFLT_VAL_NX90_mtgy_op_b85 0x00000000U

#define MSK_NX90_mtgy_op_b85_val         0xffffffffU
#define SRT_NX90_mtgy_op_b85_val         0
#define DFLT_VAL_NX90_mtgy_op_b85_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b85_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b85': */
#define MSK_USED_BITS_NX90_mtgy_op_b85 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b85_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B85_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b85_val; /* data bits 2751..2720 */
} NX90_MTGY_OP_B85_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B85_BIT_T bf;
} NX90_MTGY_OP_B85_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b86 */
/* => MWMM operand B register 86 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b86  0x00001758U
#define Adr_NX90_mtgy_mtgy_op_b86 0xFF083758U
#define Adr_NX90_mtgy_op_b86      0xFF083758U
#define DFLT_VAL_NX90_mtgy_op_b86 0x00000000U

#define MSK_NX90_mtgy_op_b86_val         0xffffffffU
#define SRT_NX90_mtgy_op_b86_val         0
#define DFLT_VAL_NX90_mtgy_op_b86_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b86_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b86': */
#define MSK_USED_BITS_NX90_mtgy_op_b86 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b86_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B86_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b86_val; /* data bits 2783..2752 */
} NX90_MTGY_OP_B86_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B86_BIT_T bf;
} NX90_MTGY_OP_B86_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b87 */
/* => MWMM operand B register 87 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b87  0x0000175CU
#define Adr_NX90_mtgy_mtgy_op_b87 0xFF08375CU
#define Adr_NX90_mtgy_op_b87      0xFF08375CU
#define DFLT_VAL_NX90_mtgy_op_b87 0x00000000U

#define MSK_NX90_mtgy_op_b87_val         0xffffffffU
#define SRT_NX90_mtgy_op_b87_val         0
#define DFLT_VAL_NX90_mtgy_op_b87_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b87_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b87': */
#define MSK_USED_BITS_NX90_mtgy_op_b87 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b87_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B87_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b87_val; /* data bits 2815..2784 */
} NX90_MTGY_OP_B87_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B87_BIT_T bf;
} NX90_MTGY_OP_B87_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b88 */
/* => MWMM operand B register 88 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b88  0x00001760U
#define Adr_NX90_mtgy_mtgy_op_b88 0xFF083760U
#define Adr_NX90_mtgy_op_b88      0xFF083760U
#define DFLT_VAL_NX90_mtgy_op_b88 0x00000000U

#define MSK_NX90_mtgy_op_b88_val         0xffffffffU
#define SRT_NX90_mtgy_op_b88_val         0
#define DFLT_VAL_NX90_mtgy_op_b88_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b88_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b88': */
#define MSK_USED_BITS_NX90_mtgy_op_b88 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b88_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B88_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b88_val; /* data bits 2847..2816 */
} NX90_MTGY_OP_B88_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B88_BIT_T bf;
} NX90_MTGY_OP_B88_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b89 */
/* => MWMM operand B register 89 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b89  0x00001764U
#define Adr_NX90_mtgy_mtgy_op_b89 0xFF083764U
#define Adr_NX90_mtgy_op_b89      0xFF083764U
#define DFLT_VAL_NX90_mtgy_op_b89 0x00000000U

#define MSK_NX90_mtgy_op_b89_val         0xffffffffU
#define SRT_NX90_mtgy_op_b89_val         0
#define DFLT_VAL_NX90_mtgy_op_b89_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b89_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b89': */
#define MSK_USED_BITS_NX90_mtgy_op_b89 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b89_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B89_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b89_val; /* data bits 2879..2848 */
} NX90_MTGY_OP_B89_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B89_BIT_T bf;
} NX90_MTGY_OP_B89_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b90 */
/* => MWMM operand B register 90 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b90  0x00001768U
#define Adr_NX90_mtgy_mtgy_op_b90 0xFF083768U
#define Adr_NX90_mtgy_op_b90      0xFF083768U
#define DFLT_VAL_NX90_mtgy_op_b90 0x00000000U

#define MSK_NX90_mtgy_op_b90_val         0xffffffffU
#define SRT_NX90_mtgy_op_b90_val         0
#define DFLT_VAL_NX90_mtgy_op_b90_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b90_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b90': */
#define MSK_USED_BITS_NX90_mtgy_op_b90 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b90_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B90_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b90_val; /* data bits 2911..2880 */
} NX90_MTGY_OP_B90_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B90_BIT_T bf;
} NX90_MTGY_OP_B90_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b91 */
/* => MWMM operand B register 91 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b91  0x0000176CU
#define Adr_NX90_mtgy_mtgy_op_b91 0xFF08376CU
#define Adr_NX90_mtgy_op_b91      0xFF08376CU
#define DFLT_VAL_NX90_mtgy_op_b91 0x00000000U

#define MSK_NX90_mtgy_op_b91_val         0xffffffffU
#define SRT_NX90_mtgy_op_b91_val         0
#define DFLT_VAL_NX90_mtgy_op_b91_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b91_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b91': */
#define MSK_USED_BITS_NX90_mtgy_op_b91 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b91_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B91_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b91_val; /* data bits 2943..2912 */
} NX90_MTGY_OP_B91_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B91_BIT_T bf;
} NX90_MTGY_OP_B91_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b92 */
/* => MWMM operand B register 92 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b92  0x00001770U
#define Adr_NX90_mtgy_mtgy_op_b92 0xFF083770U
#define Adr_NX90_mtgy_op_b92      0xFF083770U
#define DFLT_VAL_NX90_mtgy_op_b92 0x00000000U

#define MSK_NX90_mtgy_op_b92_val         0xffffffffU
#define SRT_NX90_mtgy_op_b92_val         0
#define DFLT_VAL_NX90_mtgy_op_b92_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b92_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b92': */
#define MSK_USED_BITS_NX90_mtgy_op_b92 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b92_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B92_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b92_val; /* data bits 2975..2944 */
} NX90_MTGY_OP_B92_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B92_BIT_T bf;
} NX90_MTGY_OP_B92_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b93 */
/* => MWMM operand B register 93 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b93  0x00001774U
#define Adr_NX90_mtgy_mtgy_op_b93 0xFF083774U
#define Adr_NX90_mtgy_op_b93      0xFF083774U
#define DFLT_VAL_NX90_mtgy_op_b93 0x00000000U

#define MSK_NX90_mtgy_op_b93_val         0xffffffffU
#define SRT_NX90_mtgy_op_b93_val         0
#define DFLT_VAL_NX90_mtgy_op_b93_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b93_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b93': */
#define MSK_USED_BITS_NX90_mtgy_op_b93 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b93_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B93_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b93_val; /* data bits 3007..2976 */
} NX90_MTGY_OP_B93_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B93_BIT_T bf;
} NX90_MTGY_OP_B93_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b94 */
/* => MWMM operand B register 94 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b94  0x00001778U
#define Adr_NX90_mtgy_mtgy_op_b94 0xFF083778U
#define Adr_NX90_mtgy_op_b94      0xFF083778U
#define DFLT_VAL_NX90_mtgy_op_b94 0x00000000U

#define MSK_NX90_mtgy_op_b94_val         0xffffffffU
#define SRT_NX90_mtgy_op_b94_val         0
#define DFLT_VAL_NX90_mtgy_op_b94_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b94_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b94': */
#define MSK_USED_BITS_NX90_mtgy_op_b94 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b94_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B94_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b94_val; /* data bits 3039..3008 */
} NX90_MTGY_OP_B94_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B94_BIT_T bf;
} NX90_MTGY_OP_B94_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b95 */
/* => MWMM operand B register 95 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b95  0x0000177CU
#define Adr_NX90_mtgy_mtgy_op_b95 0xFF08377CU
#define Adr_NX90_mtgy_op_b95      0xFF08377CU
#define DFLT_VAL_NX90_mtgy_op_b95 0x00000000U

#define MSK_NX90_mtgy_op_b95_val         0xffffffffU
#define SRT_NX90_mtgy_op_b95_val         0
#define DFLT_VAL_NX90_mtgy_op_b95_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b95_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b95': */
#define MSK_USED_BITS_NX90_mtgy_op_b95 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b95_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B95_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b95_val; /* data bits 3071..3040 */
} NX90_MTGY_OP_B95_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B95_BIT_T bf;
} NX90_MTGY_OP_B95_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b96 */
/* => MWMM operand B register 96 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b96  0x00001780U
#define Adr_NX90_mtgy_mtgy_op_b96 0xFF083780U
#define Adr_NX90_mtgy_op_b96      0xFF083780U
#define DFLT_VAL_NX90_mtgy_op_b96 0x00000000U

#define MSK_NX90_mtgy_op_b96_val         0xffffffffU
#define SRT_NX90_mtgy_op_b96_val         0
#define DFLT_VAL_NX90_mtgy_op_b96_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b96_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b96': */
#define MSK_USED_BITS_NX90_mtgy_op_b96 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b96_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B96_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b96_val; /* data bits 3103..3072 */
} NX90_MTGY_OP_B96_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B96_BIT_T bf;
} NX90_MTGY_OP_B96_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b97 */
/* => MWMM operand B register 97 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b97  0x00001784U
#define Adr_NX90_mtgy_mtgy_op_b97 0xFF083784U
#define Adr_NX90_mtgy_op_b97      0xFF083784U
#define DFLT_VAL_NX90_mtgy_op_b97 0x00000000U

#define MSK_NX90_mtgy_op_b97_val         0xffffffffU
#define SRT_NX90_mtgy_op_b97_val         0
#define DFLT_VAL_NX90_mtgy_op_b97_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b97_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b97': */
#define MSK_USED_BITS_NX90_mtgy_op_b97 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b97_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B97_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b97_val; /* data bits 3135..3104 */
} NX90_MTGY_OP_B97_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B97_BIT_T bf;
} NX90_MTGY_OP_B97_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b98 */
/* => MWMM operand B register 98 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b98  0x00001788U
#define Adr_NX90_mtgy_mtgy_op_b98 0xFF083788U
#define Adr_NX90_mtgy_op_b98      0xFF083788U
#define DFLT_VAL_NX90_mtgy_op_b98 0x00000000U

#define MSK_NX90_mtgy_op_b98_val         0xffffffffU
#define SRT_NX90_mtgy_op_b98_val         0
#define DFLT_VAL_NX90_mtgy_op_b98_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b98_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b98': */
#define MSK_USED_BITS_NX90_mtgy_op_b98 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b98_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B98_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b98_val; /* data bits 3167..3136 */
} NX90_MTGY_OP_B98_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B98_BIT_T bf;
} NX90_MTGY_OP_B98_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b99 */
/* => MWMM operand B register 99 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b99  0x0000178CU
#define Adr_NX90_mtgy_mtgy_op_b99 0xFF08378CU
#define Adr_NX90_mtgy_op_b99      0xFF08378CU
#define DFLT_VAL_NX90_mtgy_op_b99 0x00000000U

#define MSK_NX90_mtgy_op_b99_val         0xffffffffU
#define SRT_NX90_mtgy_op_b99_val         0
#define DFLT_VAL_NX90_mtgy_op_b99_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b99_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b99': */
#define MSK_USED_BITS_NX90_mtgy_op_b99 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b99_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B99_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b99_val; /* data bits 3199..3168 */
} NX90_MTGY_OP_B99_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_B99_BIT_T bf;
} NX90_MTGY_OP_B99_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b100 */
/* => MWMM operand B register 100 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b100  0x00001790U
#define Adr_NX90_mtgy_mtgy_op_b100 0xFF083790U
#define Adr_NX90_mtgy_op_b100      0xFF083790U
#define DFLT_VAL_NX90_mtgy_op_b100 0x00000000U

#define MSK_NX90_mtgy_op_b100_val         0xffffffffU
#define SRT_NX90_mtgy_op_b100_val         0
#define DFLT_VAL_NX90_mtgy_op_b100_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b100_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b100': */
#define MSK_USED_BITS_NX90_mtgy_op_b100 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b100_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B100_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b100_val; /* data bits 3231..3200 */
} NX90_MTGY_OP_B100_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B100_BIT_T bf;
} NX90_MTGY_OP_B100_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b101 */
/* => MWMM operand B register 101 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b101  0x00001794U
#define Adr_NX90_mtgy_mtgy_op_b101 0xFF083794U
#define Adr_NX90_mtgy_op_b101      0xFF083794U
#define DFLT_VAL_NX90_mtgy_op_b101 0x00000000U

#define MSK_NX90_mtgy_op_b101_val         0xffffffffU
#define SRT_NX90_mtgy_op_b101_val         0
#define DFLT_VAL_NX90_mtgy_op_b101_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b101_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b101': */
#define MSK_USED_BITS_NX90_mtgy_op_b101 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b101_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B101_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b101_val; /* data bits 3263..3232 */
} NX90_MTGY_OP_B101_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B101_BIT_T bf;
} NX90_MTGY_OP_B101_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b102 */
/* => MWMM operand B register 102 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b102  0x00001798U
#define Adr_NX90_mtgy_mtgy_op_b102 0xFF083798U
#define Adr_NX90_mtgy_op_b102      0xFF083798U
#define DFLT_VAL_NX90_mtgy_op_b102 0x00000000U

#define MSK_NX90_mtgy_op_b102_val         0xffffffffU
#define SRT_NX90_mtgy_op_b102_val         0
#define DFLT_VAL_NX90_mtgy_op_b102_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b102_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b102': */
#define MSK_USED_BITS_NX90_mtgy_op_b102 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b102_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B102_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b102_val; /* data bits 3295..3264 */
} NX90_MTGY_OP_B102_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B102_BIT_T bf;
} NX90_MTGY_OP_B102_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b103 */
/* => MWMM operand B register 103 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b103  0x0000179CU
#define Adr_NX90_mtgy_mtgy_op_b103 0xFF08379CU
#define Adr_NX90_mtgy_op_b103      0xFF08379CU
#define DFLT_VAL_NX90_mtgy_op_b103 0x00000000U

#define MSK_NX90_mtgy_op_b103_val         0xffffffffU
#define SRT_NX90_mtgy_op_b103_val         0
#define DFLT_VAL_NX90_mtgy_op_b103_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b103_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b103': */
#define MSK_USED_BITS_NX90_mtgy_op_b103 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b103_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B103_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b103_val; /* data bits 3327..3296 */
} NX90_MTGY_OP_B103_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B103_BIT_T bf;
} NX90_MTGY_OP_B103_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b104 */
/* => MWMM operand B register 104 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b104  0x000017A0U
#define Adr_NX90_mtgy_mtgy_op_b104 0xFF0837A0U
#define Adr_NX90_mtgy_op_b104      0xFF0837A0U
#define DFLT_VAL_NX90_mtgy_op_b104 0x00000000U

#define MSK_NX90_mtgy_op_b104_val         0xffffffffU
#define SRT_NX90_mtgy_op_b104_val         0
#define DFLT_VAL_NX90_mtgy_op_b104_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b104_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b104': */
#define MSK_USED_BITS_NX90_mtgy_op_b104 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b104_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B104_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b104_val; /* data bits 3359..3328 */
} NX90_MTGY_OP_B104_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B104_BIT_T bf;
} NX90_MTGY_OP_B104_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b105 */
/* => MWMM operand B register 105 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b105  0x000017A4U
#define Adr_NX90_mtgy_mtgy_op_b105 0xFF0837A4U
#define Adr_NX90_mtgy_op_b105      0xFF0837A4U
#define DFLT_VAL_NX90_mtgy_op_b105 0x00000000U

#define MSK_NX90_mtgy_op_b105_val         0xffffffffU
#define SRT_NX90_mtgy_op_b105_val         0
#define DFLT_VAL_NX90_mtgy_op_b105_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b105_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b105': */
#define MSK_USED_BITS_NX90_mtgy_op_b105 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b105_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B105_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b105_val; /* data bits 3391..3360 */
} NX90_MTGY_OP_B105_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B105_BIT_T bf;
} NX90_MTGY_OP_B105_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b106 */
/* => MWMM operand B register 106 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b106  0x000017A8U
#define Adr_NX90_mtgy_mtgy_op_b106 0xFF0837A8U
#define Adr_NX90_mtgy_op_b106      0xFF0837A8U
#define DFLT_VAL_NX90_mtgy_op_b106 0x00000000U

#define MSK_NX90_mtgy_op_b106_val         0xffffffffU
#define SRT_NX90_mtgy_op_b106_val         0
#define DFLT_VAL_NX90_mtgy_op_b106_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b106_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b106': */
#define MSK_USED_BITS_NX90_mtgy_op_b106 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b106_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B106_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b106_val; /* data bits 3423..3392 */
} NX90_MTGY_OP_B106_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B106_BIT_T bf;
} NX90_MTGY_OP_B106_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b107 */
/* => MWMM operand B register 107 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b107  0x000017ACU
#define Adr_NX90_mtgy_mtgy_op_b107 0xFF0837ACU
#define Adr_NX90_mtgy_op_b107      0xFF0837ACU
#define DFLT_VAL_NX90_mtgy_op_b107 0x00000000U

#define MSK_NX90_mtgy_op_b107_val         0xffffffffU
#define SRT_NX90_mtgy_op_b107_val         0
#define DFLT_VAL_NX90_mtgy_op_b107_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b107_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b107': */
#define MSK_USED_BITS_NX90_mtgy_op_b107 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b107_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B107_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b107_val; /* data bits 3455..3424 */
} NX90_MTGY_OP_B107_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B107_BIT_T bf;
} NX90_MTGY_OP_B107_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b108 */
/* => MWMM operand B register 108 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b108  0x000017B0U
#define Adr_NX90_mtgy_mtgy_op_b108 0xFF0837B0U
#define Adr_NX90_mtgy_op_b108      0xFF0837B0U
#define DFLT_VAL_NX90_mtgy_op_b108 0x00000000U

#define MSK_NX90_mtgy_op_b108_val         0xffffffffU
#define SRT_NX90_mtgy_op_b108_val         0
#define DFLT_VAL_NX90_mtgy_op_b108_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b108_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b108': */
#define MSK_USED_BITS_NX90_mtgy_op_b108 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b108_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B108_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b108_val; /* data bits 3487..3456 */
} NX90_MTGY_OP_B108_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B108_BIT_T bf;
} NX90_MTGY_OP_B108_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b109 */
/* => MWMM operand B register 109 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b109  0x000017B4U
#define Adr_NX90_mtgy_mtgy_op_b109 0xFF0837B4U
#define Adr_NX90_mtgy_op_b109      0xFF0837B4U
#define DFLT_VAL_NX90_mtgy_op_b109 0x00000000U

#define MSK_NX90_mtgy_op_b109_val         0xffffffffU
#define SRT_NX90_mtgy_op_b109_val         0
#define DFLT_VAL_NX90_mtgy_op_b109_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b109_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b109': */
#define MSK_USED_BITS_NX90_mtgy_op_b109 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b109_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B109_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b109_val; /* data bits 3519..3488 */
} NX90_MTGY_OP_B109_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B109_BIT_T bf;
} NX90_MTGY_OP_B109_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b110 */
/* => MWMM operand B register 110 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b110  0x000017B8U
#define Adr_NX90_mtgy_mtgy_op_b110 0xFF0837B8U
#define Adr_NX90_mtgy_op_b110      0xFF0837B8U
#define DFLT_VAL_NX90_mtgy_op_b110 0x00000000U

#define MSK_NX90_mtgy_op_b110_val         0xffffffffU
#define SRT_NX90_mtgy_op_b110_val         0
#define DFLT_VAL_NX90_mtgy_op_b110_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b110_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b110': */
#define MSK_USED_BITS_NX90_mtgy_op_b110 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b110_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B110_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b110_val; /* data bits 3551..3520 */
} NX90_MTGY_OP_B110_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B110_BIT_T bf;
} NX90_MTGY_OP_B110_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b111 */
/* => MWMM operand B register 111 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b111  0x000017BCU
#define Adr_NX90_mtgy_mtgy_op_b111 0xFF0837BCU
#define Adr_NX90_mtgy_op_b111      0xFF0837BCU
#define DFLT_VAL_NX90_mtgy_op_b111 0x00000000U

#define MSK_NX90_mtgy_op_b111_val         0xffffffffU
#define SRT_NX90_mtgy_op_b111_val         0
#define DFLT_VAL_NX90_mtgy_op_b111_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b111_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b111': */
#define MSK_USED_BITS_NX90_mtgy_op_b111 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b111_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B111_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b111_val; /* data bits 3583..3552 */
} NX90_MTGY_OP_B111_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B111_BIT_T bf;
} NX90_MTGY_OP_B111_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b112 */
/* => MWMM operand B register 112 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b112  0x000017C0U
#define Adr_NX90_mtgy_mtgy_op_b112 0xFF0837C0U
#define Adr_NX90_mtgy_op_b112      0xFF0837C0U
#define DFLT_VAL_NX90_mtgy_op_b112 0x00000000U

#define MSK_NX90_mtgy_op_b112_val         0xffffffffU
#define SRT_NX90_mtgy_op_b112_val         0
#define DFLT_VAL_NX90_mtgy_op_b112_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b112_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b112': */
#define MSK_USED_BITS_NX90_mtgy_op_b112 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b112_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B112_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b112_val; /* data bits 3615..3584 */
} NX90_MTGY_OP_B112_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B112_BIT_T bf;
} NX90_MTGY_OP_B112_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b113 */
/* => MWMM operand B register 113 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b113  0x000017C4U
#define Adr_NX90_mtgy_mtgy_op_b113 0xFF0837C4U
#define Adr_NX90_mtgy_op_b113      0xFF0837C4U
#define DFLT_VAL_NX90_mtgy_op_b113 0x00000000U

#define MSK_NX90_mtgy_op_b113_val         0xffffffffU
#define SRT_NX90_mtgy_op_b113_val         0
#define DFLT_VAL_NX90_mtgy_op_b113_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b113_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b113': */
#define MSK_USED_BITS_NX90_mtgy_op_b113 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b113_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B113_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b113_val; /* data bits 3647..3616 */
} NX90_MTGY_OP_B113_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B113_BIT_T bf;
} NX90_MTGY_OP_B113_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b114 */
/* => MWMM operand B register 114 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b114  0x000017C8U
#define Adr_NX90_mtgy_mtgy_op_b114 0xFF0837C8U
#define Adr_NX90_mtgy_op_b114      0xFF0837C8U
#define DFLT_VAL_NX90_mtgy_op_b114 0x00000000U

#define MSK_NX90_mtgy_op_b114_val         0xffffffffU
#define SRT_NX90_mtgy_op_b114_val         0
#define DFLT_VAL_NX90_mtgy_op_b114_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b114_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b114': */
#define MSK_USED_BITS_NX90_mtgy_op_b114 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b114_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B114_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b114_val; /* data bits 3679..3648 */
} NX90_MTGY_OP_B114_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B114_BIT_T bf;
} NX90_MTGY_OP_B114_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b115 */
/* => MWMM operand B register 115 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b115  0x000017CCU
#define Adr_NX90_mtgy_mtgy_op_b115 0xFF0837CCU
#define Adr_NX90_mtgy_op_b115      0xFF0837CCU
#define DFLT_VAL_NX90_mtgy_op_b115 0x00000000U

#define MSK_NX90_mtgy_op_b115_val         0xffffffffU
#define SRT_NX90_mtgy_op_b115_val         0
#define DFLT_VAL_NX90_mtgy_op_b115_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b115_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b115': */
#define MSK_USED_BITS_NX90_mtgy_op_b115 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b115_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B115_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b115_val; /* data bits 3711..3680 */
} NX90_MTGY_OP_B115_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B115_BIT_T bf;
} NX90_MTGY_OP_B115_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b116 */
/* => MWMM operand B register 116 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b116  0x000017D0U
#define Adr_NX90_mtgy_mtgy_op_b116 0xFF0837D0U
#define Adr_NX90_mtgy_op_b116      0xFF0837D0U
#define DFLT_VAL_NX90_mtgy_op_b116 0x00000000U

#define MSK_NX90_mtgy_op_b116_val         0xffffffffU
#define SRT_NX90_mtgy_op_b116_val         0
#define DFLT_VAL_NX90_mtgy_op_b116_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b116_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b116': */
#define MSK_USED_BITS_NX90_mtgy_op_b116 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b116_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B116_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b116_val; /* data bits 3743..3712 */
} NX90_MTGY_OP_B116_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B116_BIT_T bf;
} NX90_MTGY_OP_B116_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b117 */
/* => MWMM operand B register 117 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b117  0x000017D4U
#define Adr_NX90_mtgy_mtgy_op_b117 0xFF0837D4U
#define Adr_NX90_mtgy_op_b117      0xFF0837D4U
#define DFLT_VAL_NX90_mtgy_op_b117 0x00000000U

#define MSK_NX90_mtgy_op_b117_val         0xffffffffU
#define SRT_NX90_mtgy_op_b117_val         0
#define DFLT_VAL_NX90_mtgy_op_b117_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b117_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b117': */
#define MSK_USED_BITS_NX90_mtgy_op_b117 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b117_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B117_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b117_val; /* data bits 3775..3744 */
} NX90_MTGY_OP_B117_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B117_BIT_T bf;
} NX90_MTGY_OP_B117_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b118 */
/* => MWMM operand B register 118 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b118  0x000017D8U
#define Adr_NX90_mtgy_mtgy_op_b118 0xFF0837D8U
#define Adr_NX90_mtgy_op_b118      0xFF0837D8U
#define DFLT_VAL_NX90_mtgy_op_b118 0x00000000U

#define MSK_NX90_mtgy_op_b118_val         0xffffffffU
#define SRT_NX90_mtgy_op_b118_val         0
#define DFLT_VAL_NX90_mtgy_op_b118_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b118_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b118': */
#define MSK_USED_BITS_NX90_mtgy_op_b118 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b118_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B118_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b118_val; /* data bits 3807..3776 */
} NX90_MTGY_OP_B118_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B118_BIT_T bf;
} NX90_MTGY_OP_B118_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b119 */
/* => MWMM operand B register 119 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b119  0x000017DCU
#define Adr_NX90_mtgy_mtgy_op_b119 0xFF0837DCU
#define Adr_NX90_mtgy_op_b119      0xFF0837DCU
#define DFLT_VAL_NX90_mtgy_op_b119 0x00000000U

#define MSK_NX90_mtgy_op_b119_val         0xffffffffU
#define SRT_NX90_mtgy_op_b119_val         0
#define DFLT_VAL_NX90_mtgy_op_b119_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b119_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b119': */
#define MSK_USED_BITS_NX90_mtgy_op_b119 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b119_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B119_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b119_val; /* data bits 3839..3808 */
} NX90_MTGY_OP_B119_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B119_BIT_T bf;
} NX90_MTGY_OP_B119_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b120 */
/* => MWMM operand B register 120 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b120  0x000017E0U
#define Adr_NX90_mtgy_mtgy_op_b120 0xFF0837E0U
#define Adr_NX90_mtgy_op_b120      0xFF0837E0U
#define DFLT_VAL_NX90_mtgy_op_b120 0x00000000U

#define MSK_NX90_mtgy_op_b120_val         0xffffffffU
#define SRT_NX90_mtgy_op_b120_val         0
#define DFLT_VAL_NX90_mtgy_op_b120_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b120_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b120': */
#define MSK_USED_BITS_NX90_mtgy_op_b120 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b120_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B120_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b120_val; /* data bits 3871..3840 */
} NX90_MTGY_OP_B120_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B120_BIT_T bf;
} NX90_MTGY_OP_B120_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b121 */
/* => MWMM operand B register 121 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b121  0x000017E4U
#define Adr_NX90_mtgy_mtgy_op_b121 0xFF0837E4U
#define Adr_NX90_mtgy_op_b121      0xFF0837E4U
#define DFLT_VAL_NX90_mtgy_op_b121 0x00000000U

#define MSK_NX90_mtgy_op_b121_val         0xffffffffU
#define SRT_NX90_mtgy_op_b121_val         0
#define DFLT_VAL_NX90_mtgy_op_b121_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b121_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b121': */
#define MSK_USED_BITS_NX90_mtgy_op_b121 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b121_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B121_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b121_val; /* data bits 3903..3872 */
} NX90_MTGY_OP_B121_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B121_BIT_T bf;
} NX90_MTGY_OP_B121_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b122 */
/* => MWMM operand B register 122 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b122  0x000017E8U
#define Adr_NX90_mtgy_mtgy_op_b122 0xFF0837E8U
#define Adr_NX90_mtgy_op_b122      0xFF0837E8U
#define DFLT_VAL_NX90_mtgy_op_b122 0x00000000U

#define MSK_NX90_mtgy_op_b122_val         0xffffffffU
#define SRT_NX90_mtgy_op_b122_val         0
#define DFLT_VAL_NX90_mtgy_op_b122_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b122_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b122': */
#define MSK_USED_BITS_NX90_mtgy_op_b122 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b122_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B122_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b122_val; /* data bits 3935..3904 */
} NX90_MTGY_OP_B122_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B122_BIT_T bf;
} NX90_MTGY_OP_B122_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b123 */
/* => MWMM operand B register 123 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b123  0x000017ECU
#define Adr_NX90_mtgy_mtgy_op_b123 0xFF0837ECU
#define Adr_NX90_mtgy_op_b123      0xFF0837ECU
#define DFLT_VAL_NX90_mtgy_op_b123 0x00000000U

#define MSK_NX90_mtgy_op_b123_val         0xffffffffU
#define SRT_NX90_mtgy_op_b123_val         0
#define DFLT_VAL_NX90_mtgy_op_b123_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b123_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b123': */
#define MSK_USED_BITS_NX90_mtgy_op_b123 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b123_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B123_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b123_val; /* data bits 3967..3936 */
} NX90_MTGY_OP_B123_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B123_BIT_T bf;
} NX90_MTGY_OP_B123_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b124 */
/* => MWMM operand B register 124 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b124  0x000017F0U
#define Adr_NX90_mtgy_mtgy_op_b124 0xFF0837F0U
#define Adr_NX90_mtgy_op_b124      0xFF0837F0U
#define DFLT_VAL_NX90_mtgy_op_b124 0x00000000U

#define MSK_NX90_mtgy_op_b124_val         0xffffffffU
#define SRT_NX90_mtgy_op_b124_val         0
#define DFLT_VAL_NX90_mtgy_op_b124_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b124_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b124': */
#define MSK_USED_BITS_NX90_mtgy_op_b124 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b124_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B124_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b124_val; /* data bits 3999..3968 */
} NX90_MTGY_OP_B124_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B124_BIT_T bf;
} NX90_MTGY_OP_B124_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b125 */
/* => MWMM operand B register 125 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b125  0x000017F4U
#define Adr_NX90_mtgy_mtgy_op_b125 0xFF0837F4U
#define Adr_NX90_mtgy_op_b125      0xFF0837F4U
#define DFLT_VAL_NX90_mtgy_op_b125 0x00000000U

#define MSK_NX90_mtgy_op_b125_val         0xffffffffU
#define SRT_NX90_mtgy_op_b125_val         0
#define DFLT_VAL_NX90_mtgy_op_b125_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b125_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b125': */
#define MSK_USED_BITS_NX90_mtgy_op_b125 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b125_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B125_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b125_val; /* data bits 4031..4000 */
} NX90_MTGY_OP_B125_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B125_BIT_T bf;
} NX90_MTGY_OP_B125_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b126 */
/* => MWMM operand B register 126 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b126  0x000017F8U
#define Adr_NX90_mtgy_mtgy_op_b126 0xFF0837F8U
#define Adr_NX90_mtgy_op_b126      0xFF0837F8U
#define DFLT_VAL_NX90_mtgy_op_b126 0x00000000U

#define MSK_NX90_mtgy_op_b126_val         0xffffffffU
#define SRT_NX90_mtgy_op_b126_val         0
#define DFLT_VAL_NX90_mtgy_op_b126_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b126_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b126': */
#define MSK_USED_BITS_NX90_mtgy_op_b126 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b126_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B126_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b126_val; /* data bits 4063..4032 */
} NX90_MTGY_OP_B126_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B126_BIT_T bf;
} NX90_MTGY_OP_B126_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_b127 */
/* => MWMM operand B register 127 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_b127  0x000017FCU
#define Adr_NX90_mtgy_mtgy_op_b127 0xFF0837FCU
#define Adr_NX90_mtgy_op_b127      0xFF0837FCU
#define DFLT_VAL_NX90_mtgy_op_b127 0x00000000U

#define MSK_NX90_mtgy_op_b127_val         0xffffffffU
#define SRT_NX90_mtgy_op_b127_val         0
#define DFLT_VAL_NX90_mtgy_op_b127_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_b127_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_b127': */
#define MSK_USED_BITS_NX90_mtgy_op_b127 0xffffffffU

enum {
  BFW_NX90_mtgy_op_b127_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_B127_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_b127_val; /* data bits 4095..4064 */
} NX90_MTGY_OP_B127_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_B127_BIT_T bf;
} NX90_MTGY_OP_B127_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a0 */
/* => MWMM operand A register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a0  0x00001800U
#define Adr_NX90_mtgy_mtgy_op_a0 0xFF083800U
#define Adr_NX90_mtgy_op_a0      0xFF083800U
#define DFLT_VAL_NX90_mtgy_op_a0 0x00000000U

#define MSK_NX90_mtgy_op_a0_val         0xffffffffU
#define SRT_NX90_mtgy_op_a0_val         0
#define DFLT_VAL_NX90_mtgy_op_a0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a0_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a0': */
#define MSK_USED_BITS_NX90_mtgy_op_a0 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a0_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A0_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a0_val; /* data bits 31..0 */
} NX90_MTGY_OP_A0_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A0_BIT_T bf;
} NX90_MTGY_OP_A0_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a1 */
/* => MWMM operand A register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a1  0x00001804U
#define Adr_NX90_mtgy_mtgy_op_a1 0xFF083804U
#define Adr_NX90_mtgy_op_a1      0xFF083804U
#define DFLT_VAL_NX90_mtgy_op_a1 0x00000000U

#define MSK_NX90_mtgy_op_a1_val         0xffffffffU
#define SRT_NX90_mtgy_op_a1_val         0
#define DFLT_VAL_NX90_mtgy_op_a1_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a1_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a1': */
#define MSK_USED_BITS_NX90_mtgy_op_a1 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a1_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A1_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a1_val; /* data bits 63..32 */
} NX90_MTGY_OP_A1_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A1_BIT_T bf;
} NX90_MTGY_OP_A1_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a2 */
/* => MWMM operand A register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a2  0x00001808U
#define Adr_NX90_mtgy_mtgy_op_a2 0xFF083808U
#define Adr_NX90_mtgy_op_a2      0xFF083808U
#define DFLT_VAL_NX90_mtgy_op_a2 0x00000000U

#define MSK_NX90_mtgy_op_a2_val         0xffffffffU
#define SRT_NX90_mtgy_op_a2_val         0
#define DFLT_VAL_NX90_mtgy_op_a2_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a2_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a2': */
#define MSK_USED_BITS_NX90_mtgy_op_a2 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a2_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A2_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a2_val; /* data bits 95..64 */
} NX90_MTGY_OP_A2_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A2_BIT_T bf;
} NX90_MTGY_OP_A2_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a3 */
/* => MWMM operand A register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a3  0x0000180CU
#define Adr_NX90_mtgy_mtgy_op_a3 0xFF08380CU
#define Adr_NX90_mtgy_op_a3      0xFF08380CU
#define DFLT_VAL_NX90_mtgy_op_a3 0x00000000U

#define MSK_NX90_mtgy_op_a3_val         0xffffffffU
#define SRT_NX90_mtgy_op_a3_val         0
#define DFLT_VAL_NX90_mtgy_op_a3_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a3_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a3': */
#define MSK_USED_BITS_NX90_mtgy_op_a3 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a3_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A3_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a3_val; /* data bits 127..96 */
} NX90_MTGY_OP_A3_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A3_BIT_T bf;
} NX90_MTGY_OP_A3_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a4 */
/* => MWMM operand A register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a4  0x00001810U
#define Adr_NX90_mtgy_mtgy_op_a4 0xFF083810U
#define Adr_NX90_mtgy_op_a4      0xFF083810U
#define DFLT_VAL_NX90_mtgy_op_a4 0x00000000U

#define MSK_NX90_mtgy_op_a4_val         0xffffffffU
#define SRT_NX90_mtgy_op_a4_val         0
#define DFLT_VAL_NX90_mtgy_op_a4_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a4_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a4': */
#define MSK_USED_BITS_NX90_mtgy_op_a4 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a4_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A4_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a4_val; /* data bits 159..128 */
} NX90_MTGY_OP_A4_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A4_BIT_T bf;
} NX90_MTGY_OP_A4_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a5 */
/* => MWMM operand A register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a5  0x00001814U
#define Adr_NX90_mtgy_mtgy_op_a5 0xFF083814U
#define Adr_NX90_mtgy_op_a5      0xFF083814U
#define DFLT_VAL_NX90_mtgy_op_a5 0x00000000U

#define MSK_NX90_mtgy_op_a5_val         0xffffffffU
#define SRT_NX90_mtgy_op_a5_val         0
#define DFLT_VAL_NX90_mtgy_op_a5_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a5_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a5': */
#define MSK_USED_BITS_NX90_mtgy_op_a5 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a5_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A5_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a5_val; /* data bits 191..160 */
} NX90_MTGY_OP_A5_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A5_BIT_T bf;
} NX90_MTGY_OP_A5_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a6 */
/* => MWMM operand A register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a6  0x00001818U
#define Adr_NX90_mtgy_mtgy_op_a6 0xFF083818U
#define Adr_NX90_mtgy_op_a6      0xFF083818U
#define DFLT_VAL_NX90_mtgy_op_a6 0x00000000U

#define MSK_NX90_mtgy_op_a6_val         0xffffffffU
#define SRT_NX90_mtgy_op_a6_val         0
#define DFLT_VAL_NX90_mtgy_op_a6_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a6_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a6': */
#define MSK_USED_BITS_NX90_mtgy_op_a6 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a6_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A6_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a6_val; /* data bits 223..192 */
} NX90_MTGY_OP_A6_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A6_BIT_T bf;
} NX90_MTGY_OP_A6_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a7 */
/* => MWMM operand A register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a7  0x0000181CU
#define Adr_NX90_mtgy_mtgy_op_a7 0xFF08381CU
#define Adr_NX90_mtgy_op_a7      0xFF08381CU
#define DFLT_VAL_NX90_mtgy_op_a7 0x00000000U

#define MSK_NX90_mtgy_op_a7_val         0xffffffffU
#define SRT_NX90_mtgy_op_a7_val         0
#define DFLT_VAL_NX90_mtgy_op_a7_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a7_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a7': */
#define MSK_USED_BITS_NX90_mtgy_op_a7 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a7_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A7_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a7_val; /* data bits 255..224 */
} NX90_MTGY_OP_A7_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A7_BIT_T bf;
} NX90_MTGY_OP_A7_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a8 */
/* => MWMM operand A register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a8  0x00001820U
#define Adr_NX90_mtgy_mtgy_op_a8 0xFF083820U
#define Adr_NX90_mtgy_op_a8      0xFF083820U
#define DFLT_VAL_NX90_mtgy_op_a8 0x00000000U

#define MSK_NX90_mtgy_op_a8_val         0xffffffffU
#define SRT_NX90_mtgy_op_a8_val         0
#define DFLT_VAL_NX90_mtgy_op_a8_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a8_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a8': */
#define MSK_USED_BITS_NX90_mtgy_op_a8 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a8_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A8_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a8_val; /* data bits 287..256 */
} NX90_MTGY_OP_A8_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A8_BIT_T bf;
} NX90_MTGY_OP_A8_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a9 */
/* => MWMM operand A register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a9  0x00001824U
#define Adr_NX90_mtgy_mtgy_op_a9 0xFF083824U
#define Adr_NX90_mtgy_op_a9      0xFF083824U
#define DFLT_VAL_NX90_mtgy_op_a9 0x00000000U

#define MSK_NX90_mtgy_op_a9_val         0xffffffffU
#define SRT_NX90_mtgy_op_a9_val         0
#define DFLT_VAL_NX90_mtgy_op_a9_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a9_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a9': */
#define MSK_USED_BITS_NX90_mtgy_op_a9 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a9_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A9_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a9_val; /* data bits 319..288 */
} NX90_MTGY_OP_A9_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_A9_BIT_T bf;
} NX90_MTGY_OP_A9_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a10 */
/* => MWMM operand A register 10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a10  0x00001828U
#define Adr_NX90_mtgy_mtgy_op_a10 0xFF083828U
#define Adr_NX90_mtgy_op_a10      0xFF083828U
#define DFLT_VAL_NX90_mtgy_op_a10 0x00000000U

#define MSK_NX90_mtgy_op_a10_val         0xffffffffU
#define SRT_NX90_mtgy_op_a10_val         0
#define DFLT_VAL_NX90_mtgy_op_a10_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a10_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a10': */
#define MSK_USED_BITS_NX90_mtgy_op_a10 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a10_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A10_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a10_val; /* data bits 351..320 */
} NX90_MTGY_OP_A10_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A10_BIT_T bf;
} NX90_MTGY_OP_A10_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a11 */
/* => MWMM operand A register 11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a11  0x0000182CU
#define Adr_NX90_mtgy_mtgy_op_a11 0xFF08382CU
#define Adr_NX90_mtgy_op_a11      0xFF08382CU
#define DFLT_VAL_NX90_mtgy_op_a11 0x00000000U

#define MSK_NX90_mtgy_op_a11_val         0xffffffffU
#define SRT_NX90_mtgy_op_a11_val         0
#define DFLT_VAL_NX90_mtgy_op_a11_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a11_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a11': */
#define MSK_USED_BITS_NX90_mtgy_op_a11 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a11_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A11_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a11_val; /* data bits 383..352 */
} NX90_MTGY_OP_A11_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A11_BIT_T bf;
} NX90_MTGY_OP_A11_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a12 */
/* => MWMM operand A register 12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a12  0x00001830U
#define Adr_NX90_mtgy_mtgy_op_a12 0xFF083830U
#define Adr_NX90_mtgy_op_a12      0xFF083830U
#define DFLT_VAL_NX90_mtgy_op_a12 0x00000000U

#define MSK_NX90_mtgy_op_a12_val         0xffffffffU
#define SRT_NX90_mtgy_op_a12_val         0
#define DFLT_VAL_NX90_mtgy_op_a12_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a12_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a12': */
#define MSK_USED_BITS_NX90_mtgy_op_a12 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a12_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A12_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a12_val; /* data bits 415..384 */
} NX90_MTGY_OP_A12_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A12_BIT_T bf;
} NX90_MTGY_OP_A12_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a13 */
/* => MWMM operand A register 13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a13  0x00001834U
#define Adr_NX90_mtgy_mtgy_op_a13 0xFF083834U
#define Adr_NX90_mtgy_op_a13      0xFF083834U
#define DFLT_VAL_NX90_mtgy_op_a13 0x00000000U

#define MSK_NX90_mtgy_op_a13_val         0xffffffffU
#define SRT_NX90_mtgy_op_a13_val         0
#define DFLT_VAL_NX90_mtgy_op_a13_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a13_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a13': */
#define MSK_USED_BITS_NX90_mtgy_op_a13 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a13_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A13_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a13_val; /* data bits 447..416 */
} NX90_MTGY_OP_A13_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A13_BIT_T bf;
} NX90_MTGY_OP_A13_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a14 */
/* => MWMM operand A register 14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a14  0x00001838U
#define Adr_NX90_mtgy_mtgy_op_a14 0xFF083838U
#define Adr_NX90_mtgy_op_a14      0xFF083838U
#define DFLT_VAL_NX90_mtgy_op_a14 0x00000000U

#define MSK_NX90_mtgy_op_a14_val         0xffffffffU
#define SRT_NX90_mtgy_op_a14_val         0
#define DFLT_VAL_NX90_mtgy_op_a14_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a14_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a14': */
#define MSK_USED_BITS_NX90_mtgy_op_a14 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a14_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A14_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a14_val; /* data bits 479..448 */
} NX90_MTGY_OP_A14_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A14_BIT_T bf;
} NX90_MTGY_OP_A14_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a15 */
/* => MWMM operand A register 15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a15  0x0000183CU
#define Adr_NX90_mtgy_mtgy_op_a15 0xFF08383CU
#define Adr_NX90_mtgy_op_a15      0xFF08383CU
#define DFLT_VAL_NX90_mtgy_op_a15 0x00000000U

#define MSK_NX90_mtgy_op_a15_val         0xffffffffU
#define SRT_NX90_mtgy_op_a15_val         0
#define DFLT_VAL_NX90_mtgy_op_a15_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a15_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a15': */
#define MSK_USED_BITS_NX90_mtgy_op_a15 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a15_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A15_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a15_val; /* data bits 511..480 */
} NX90_MTGY_OP_A15_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A15_BIT_T bf;
} NX90_MTGY_OP_A15_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a16 */
/* => MWMM operand A register 16 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a16  0x00001840U
#define Adr_NX90_mtgy_mtgy_op_a16 0xFF083840U
#define Adr_NX90_mtgy_op_a16      0xFF083840U
#define DFLT_VAL_NX90_mtgy_op_a16 0x00000000U

#define MSK_NX90_mtgy_op_a16_val         0xffffffffU
#define SRT_NX90_mtgy_op_a16_val         0
#define DFLT_VAL_NX90_mtgy_op_a16_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a16_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a16': */
#define MSK_USED_BITS_NX90_mtgy_op_a16 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a16_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A16_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a16_val; /* data bits 543..512 */
} NX90_MTGY_OP_A16_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A16_BIT_T bf;
} NX90_MTGY_OP_A16_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a17 */
/* => MWMM operand A register 17 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a17  0x00001844U
#define Adr_NX90_mtgy_mtgy_op_a17 0xFF083844U
#define Adr_NX90_mtgy_op_a17      0xFF083844U
#define DFLT_VAL_NX90_mtgy_op_a17 0x00000000U

#define MSK_NX90_mtgy_op_a17_val         0xffffffffU
#define SRT_NX90_mtgy_op_a17_val         0
#define DFLT_VAL_NX90_mtgy_op_a17_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a17_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a17': */
#define MSK_USED_BITS_NX90_mtgy_op_a17 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a17_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A17_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a17_val; /* data bits 575..544 */
} NX90_MTGY_OP_A17_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A17_BIT_T bf;
} NX90_MTGY_OP_A17_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a18 */
/* => MWMM operand A register 18 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a18  0x00001848U
#define Adr_NX90_mtgy_mtgy_op_a18 0xFF083848U
#define Adr_NX90_mtgy_op_a18      0xFF083848U
#define DFLT_VAL_NX90_mtgy_op_a18 0x00000000U

#define MSK_NX90_mtgy_op_a18_val         0xffffffffU
#define SRT_NX90_mtgy_op_a18_val         0
#define DFLT_VAL_NX90_mtgy_op_a18_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a18_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a18': */
#define MSK_USED_BITS_NX90_mtgy_op_a18 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a18_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A18_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a18_val; /* data bits 607..576 */
} NX90_MTGY_OP_A18_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A18_BIT_T bf;
} NX90_MTGY_OP_A18_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a19 */
/* => MWMM operand A register 19 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a19  0x0000184CU
#define Adr_NX90_mtgy_mtgy_op_a19 0xFF08384CU
#define Adr_NX90_mtgy_op_a19      0xFF08384CU
#define DFLT_VAL_NX90_mtgy_op_a19 0x00000000U

#define MSK_NX90_mtgy_op_a19_val         0xffffffffU
#define SRT_NX90_mtgy_op_a19_val         0
#define DFLT_VAL_NX90_mtgy_op_a19_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a19_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a19': */
#define MSK_USED_BITS_NX90_mtgy_op_a19 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a19_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A19_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a19_val; /* data bits 639..608 */
} NX90_MTGY_OP_A19_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A19_BIT_T bf;
} NX90_MTGY_OP_A19_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a20 */
/* => MWMM operand A register 20 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a20  0x00001850U
#define Adr_NX90_mtgy_mtgy_op_a20 0xFF083850U
#define Adr_NX90_mtgy_op_a20      0xFF083850U
#define DFLT_VAL_NX90_mtgy_op_a20 0x00000000U

#define MSK_NX90_mtgy_op_a20_val         0xffffffffU
#define SRT_NX90_mtgy_op_a20_val         0
#define DFLT_VAL_NX90_mtgy_op_a20_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a20_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a20': */
#define MSK_USED_BITS_NX90_mtgy_op_a20 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a20_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A20_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a20_val; /* data bits 671..640 */
} NX90_MTGY_OP_A20_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A20_BIT_T bf;
} NX90_MTGY_OP_A20_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a21 */
/* => MWMM operand A register 21 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a21  0x00001854U
#define Adr_NX90_mtgy_mtgy_op_a21 0xFF083854U
#define Adr_NX90_mtgy_op_a21      0xFF083854U
#define DFLT_VAL_NX90_mtgy_op_a21 0x00000000U

#define MSK_NX90_mtgy_op_a21_val         0xffffffffU
#define SRT_NX90_mtgy_op_a21_val         0
#define DFLT_VAL_NX90_mtgy_op_a21_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a21_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a21': */
#define MSK_USED_BITS_NX90_mtgy_op_a21 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a21_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A21_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a21_val; /* data bits 703..672 */
} NX90_MTGY_OP_A21_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A21_BIT_T bf;
} NX90_MTGY_OP_A21_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a22 */
/* => MWMM operand A register 22 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a22  0x00001858U
#define Adr_NX90_mtgy_mtgy_op_a22 0xFF083858U
#define Adr_NX90_mtgy_op_a22      0xFF083858U
#define DFLT_VAL_NX90_mtgy_op_a22 0x00000000U

#define MSK_NX90_mtgy_op_a22_val         0xffffffffU
#define SRT_NX90_mtgy_op_a22_val         0
#define DFLT_VAL_NX90_mtgy_op_a22_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a22_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a22': */
#define MSK_USED_BITS_NX90_mtgy_op_a22 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a22_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A22_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a22_val; /* data bits 735..704 */
} NX90_MTGY_OP_A22_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A22_BIT_T bf;
} NX90_MTGY_OP_A22_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a23 */
/* => MWMM operand A register 23 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a23  0x0000185CU
#define Adr_NX90_mtgy_mtgy_op_a23 0xFF08385CU
#define Adr_NX90_mtgy_op_a23      0xFF08385CU
#define DFLT_VAL_NX90_mtgy_op_a23 0x00000000U

#define MSK_NX90_mtgy_op_a23_val         0xffffffffU
#define SRT_NX90_mtgy_op_a23_val         0
#define DFLT_VAL_NX90_mtgy_op_a23_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a23_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a23': */
#define MSK_USED_BITS_NX90_mtgy_op_a23 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a23_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A23_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a23_val; /* data bits 767..736 */
} NX90_MTGY_OP_A23_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A23_BIT_T bf;
} NX90_MTGY_OP_A23_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a24 */
/* => MWMM operand A register 24 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a24  0x00001860U
#define Adr_NX90_mtgy_mtgy_op_a24 0xFF083860U
#define Adr_NX90_mtgy_op_a24      0xFF083860U
#define DFLT_VAL_NX90_mtgy_op_a24 0x00000000U

#define MSK_NX90_mtgy_op_a24_val         0xffffffffU
#define SRT_NX90_mtgy_op_a24_val         0
#define DFLT_VAL_NX90_mtgy_op_a24_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a24_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a24': */
#define MSK_USED_BITS_NX90_mtgy_op_a24 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a24_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A24_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a24_val; /* data bits 799..768 */
} NX90_MTGY_OP_A24_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A24_BIT_T bf;
} NX90_MTGY_OP_A24_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a25 */
/* => MWMM operand A register 25 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a25  0x00001864U
#define Adr_NX90_mtgy_mtgy_op_a25 0xFF083864U
#define Adr_NX90_mtgy_op_a25      0xFF083864U
#define DFLT_VAL_NX90_mtgy_op_a25 0x00000000U

#define MSK_NX90_mtgy_op_a25_val         0xffffffffU
#define SRT_NX90_mtgy_op_a25_val         0
#define DFLT_VAL_NX90_mtgy_op_a25_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a25_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a25': */
#define MSK_USED_BITS_NX90_mtgy_op_a25 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a25_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A25_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a25_val; /* data bits 831..800 */
} NX90_MTGY_OP_A25_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A25_BIT_T bf;
} NX90_MTGY_OP_A25_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a26 */
/* => MWMM operand A register 26 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a26  0x00001868U
#define Adr_NX90_mtgy_mtgy_op_a26 0xFF083868U
#define Adr_NX90_mtgy_op_a26      0xFF083868U
#define DFLT_VAL_NX90_mtgy_op_a26 0x00000000U

#define MSK_NX90_mtgy_op_a26_val         0xffffffffU
#define SRT_NX90_mtgy_op_a26_val         0
#define DFLT_VAL_NX90_mtgy_op_a26_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a26_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a26': */
#define MSK_USED_BITS_NX90_mtgy_op_a26 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a26_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A26_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a26_val; /* data bits 863..832 */
} NX90_MTGY_OP_A26_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A26_BIT_T bf;
} NX90_MTGY_OP_A26_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a27 */
/* => MWMM operand A register 27 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a27  0x0000186CU
#define Adr_NX90_mtgy_mtgy_op_a27 0xFF08386CU
#define Adr_NX90_mtgy_op_a27      0xFF08386CU
#define DFLT_VAL_NX90_mtgy_op_a27 0x00000000U

#define MSK_NX90_mtgy_op_a27_val         0xffffffffU
#define SRT_NX90_mtgy_op_a27_val         0
#define DFLT_VAL_NX90_mtgy_op_a27_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a27_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a27': */
#define MSK_USED_BITS_NX90_mtgy_op_a27 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a27_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A27_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a27_val; /* data bits 895..864 */
} NX90_MTGY_OP_A27_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A27_BIT_T bf;
} NX90_MTGY_OP_A27_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a28 */
/* => MWMM operand A register 28 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a28  0x00001870U
#define Adr_NX90_mtgy_mtgy_op_a28 0xFF083870U
#define Adr_NX90_mtgy_op_a28      0xFF083870U
#define DFLT_VAL_NX90_mtgy_op_a28 0x00000000U

#define MSK_NX90_mtgy_op_a28_val         0xffffffffU
#define SRT_NX90_mtgy_op_a28_val         0
#define DFLT_VAL_NX90_mtgy_op_a28_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a28_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a28': */
#define MSK_USED_BITS_NX90_mtgy_op_a28 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a28_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A28_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a28_val; /* data bits 927..896 */
} NX90_MTGY_OP_A28_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A28_BIT_T bf;
} NX90_MTGY_OP_A28_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a29 */
/* => MWMM operand A register 29 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a29  0x00001874U
#define Adr_NX90_mtgy_mtgy_op_a29 0xFF083874U
#define Adr_NX90_mtgy_op_a29      0xFF083874U
#define DFLT_VAL_NX90_mtgy_op_a29 0x00000000U

#define MSK_NX90_mtgy_op_a29_val         0xffffffffU
#define SRT_NX90_mtgy_op_a29_val         0
#define DFLT_VAL_NX90_mtgy_op_a29_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a29_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a29': */
#define MSK_USED_BITS_NX90_mtgy_op_a29 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a29_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A29_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a29_val; /* data bits 959..928 */
} NX90_MTGY_OP_A29_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A29_BIT_T bf;
} NX90_MTGY_OP_A29_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a30 */
/* => MWMM operand A register 30 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a30  0x00001878U
#define Adr_NX90_mtgy_mtgy_op_a30 0xFF083878U
#define Adr_NX90_mtgy_op_a30      0xFF083878U
#define DFLT_VAL_NX90_mtgy_op_a30 0x00000000U

#define MSK_NX90_mtgy_op_a30_val         0xffffffffU
#define SRT_NX90_mtgy_op_a30_val         0
#define DFLT_VAL_NX90_mtgy_op_a30_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a30_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a30': */
#define MSK_USED_BITS_NX90_mtgy_op_a30 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a30_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A30_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a30_val; /* data bits 991..960 */
} NX90_MTGY_OP_A30_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A30_BIT_T bf;
} NX90_MTGY_OP_A30_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a31 */
/* => MWMM operand A register 31 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a31  0x0000187CU
#define Adr_NX90_mtgy_mtgy_op_a31 0xFF08387CU
#define Adr_NX90_mtgy_op_a31      0xFF08387CU
#define DFLT_VAL_NX90_mtgy_op_a31 0x00000000U

#define MSK_NX90_mtgy_op_a31_val         0xffffffffU
#define SRT_NX90_mtgy_op_a31_val         0
#define DFLT_VAL_NX90_mtgy_op_a31_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a31_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a31': */
#define MSK_USED_BITS_NX90_mtgy_op_a31 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a31_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A31_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a31_val; /* data bits 1023..992 */
} NX90_MTGY_OP_A31_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A31_BIT_T bf;
} NX90_MTGY_OP_A31_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a32 */
/* => MWMM operand A register 32 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a32  0x00001880U
#define Adr_NX90_mtgy_mtgy_op_a32 0xFF083880U
#define Adr_NX90_mtgy_op_a32      0xFF083880U
#define DFLT_VAL_NX90_mtgy_op_a32 0x00000000U

#define MSK_NX90_mtgy_op_a32_val         0xffffffffU
#define SRT_NX90_mtgy_op_a32_val         0
#define DFLT_VAL_NX90_mtgy_op_a32_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a32_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a32': */
#define MSK_USED_BITS_NX90_mtgy_op_a32 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a32_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A32_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a32_val; /* data bits 1055..1024 */
} NX90_MTGY_OP_A32_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A32_BIT_T bf;
} NX90_MTGY_OP_A32_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a33 */
/* => MWMM operand A register 33 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a33  0x00001884U
#define Adr_NX90_mtgy_mtgy_op_a33 0xFF083884U
#define Adr_NX90_mtgy_op_a33      0xFF083884U
#define DFLT_VAL_NX90_mtgy_op_a33 0x00000000U

#define MSK_NX90_mtgy_op_a33_val         0xffffffffU
#define SRT_NX90_mtgy_op_a33_val         0
#define DFLT_VAL_NX90_mtgy_op_a33_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a33_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a33': */
#define MSK_USED_BITS_NX90_mtgy_op_a33 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a33_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A33_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a33_val; /* data bits 1087..1056 */
} NX90_MTGY_OP_A33_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A33_BIT_T bf;
} NX90_MTGY_OP_A33_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a34 */
/* => MWMM operand A register 34 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a34  0x00001888U
#define Adr_NX90_mtgy_mtgy_op_a34 0xFF083888U
#define Adr_NX90_mtgy_op_a34      0xFF083888U
#define DFLT_VAL_NX90_mtgy_op_a34 0x00000000U

#define MSK_NX90_mtgy_op_a34_val         0xffffffffU
#define SRT_NX90_mtgy_op_a34_val         0
#define DFLT_VAL_NX90_mtgy_op_a34_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a34_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a34': */
#define MSK_USED_BITS_NX90_mtgy_op_a34 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a34_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A34_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a34_val; /* data bits 1119..1088 */
} NX90_MTGY_OP_A34_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A34_BIT_T bf;
} NX90_MTGY_OP_A34_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a35 */
/* => MWMM operand A register 35 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a35  0x0000188CU
#define Adr_NX90_mtgy_mtgy_op_a35 0xFF08388CU
#define Adr_NX90_mtgy_op_a35      0xFF08388CU
#define DFLT_VAL_NX90_mtgy_op_a35 0x00000000U

#define MSK_NX90_mtgy_op_a35_val         0xffffffffU
#define SRT_NX90_mtgy_op_a35_val         0
#define DFLT_VAL_NX90_mtgy_op_a35_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a35_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a35': */
#define MSK_USED_BITS_NX90_mtgy_op_a35 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a35_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A35_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a35_val; /* data bits 1151..1120 */
} NX90_MTGY_OP_A35_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A35_BIT_T bf;
} NX90_MTGY_OP_A35_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a36 */
/* => MWMM operand A register 36 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a36  0x00001890U
#define Adr_NX90_mtgy_mtgy_op_a36 0xFF083890U
#define Adr_NX90_mtgy_op_a36      0xFF083890U
#define DFLT_VAL_NX90_mtgy_op_a36 0x00000000U

#define MSK_NX90_mtgy_op_a36_val         0xffffffffU
#define SRT_NX90_mtgy_op_a36_val         0
#define DFLT_VAL_NX90_mtgy_op_a36_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a36_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a36': */
#define MSK_USED_BITS_NX90_mtgy_op_a36 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a36_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A36_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a36_val; /* data bits 1183..1152 */
} NX90_MTGY_OP_A36_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A36_BIT_T bf;
} NX90_MTGY_OP_A36_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a37 */
/* => MWMM operand A register 37 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a37  0x00001894U
#define Adr_NX90_mtgy_mtgy_op_a37 0xFF083894U
#define Adr_NX90_mtgy_op_a37      0xFF083894U
#define DFLT_VAL_NX90_mtgy_op_a37 0x00000000U

#define MSK_NX90_mtgy_op_a37_val         0xffffffffU
#define SRT_NX90_mtgy_op_a37_val         0
#define DFLT_VAL_NX90_mtgy_op_a37_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a37_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a37': */
#define MSK_USED_BITS_NX90_mtgy_op_a37 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a37_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A37_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a37_val; /* data bits 1215..1184 */
} NX90_MTGY_OP_A37_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A37_BIT_T bf;
} NX90_MTGY_OP_A37_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a38 */
/* => MWMM operand A register 38 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a38  0x00001898U
#define Adr_NX90_mtgy_mtgy_op_a38 0xFF083898U
#define Adr_NX90_mtgy_op_a38      0xFF083898U
#define DFLT_VAL_NX90_mtgy_op_a38 0x00000000U

#define MSK_NX90_mtgy_op_a38_val         0xffffffffU
#define SRT_NX90_mtgy_op_a38_val         0
#define DFLT_VAL_NX90_mtgy_op_a38_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a38_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a38': */
#define MSK_USED_BITS_NX90_mtgy_op_a38 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a38_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A38_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a38_val; /* data bits 1247..1216 */
} NX90_MTGY_OP_A38_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A38_BIT_T bf;
} NX90_MTGY_OP_A38_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a39 */
/* => MWMM operand A register 39 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a39  0x0000189CU
#define Adr_NX90_mtgy_mtgy_op_a39 0xFF08389CU
#define Adr_NX90_mtgy_op_a39      0xFF08389CU
#define DFLT_VAL_NX90_mtgy_op_a39 0x00000000U

#define MSK_NX90_mtgy_op_a39_val         0xffffffffU
#define SRT_NX90_mtgy_op_a39_val         0
#define DFLT_VAL_NX90_mtgy_op_a39_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a39_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a39': */
#define MSK_USED_BITS_NX90_mtgy_op_a39 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a39_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A39_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a39_val; /* data bits 1279..1248 */
} NX90_MTGY_OP_A39_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A39_BIT_T bf;
} NX90_MTGY_OP_A39_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a40 */
/* => MWMM operand A register 40 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a40  0x000018A0U
#define Adr_NX90_mtgy_mtgy_op_a40 0xFF0838A0U
#define Adr_NX90_mtgy_op_a40      0xFF0838A0U
#define DFLT_VAL_NX90_mtgy_op_a40 0x00000000U

#define MSK_NX90_mtgy_op_a40_val         0xffffffffU
#define SRT_NX90_mtgy_op_a40_val         0
#define DFLT_VAL_NX90_mtgy_op_a40_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a40_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a40': */
#define MSK_USED_BITS_NX90_mtgy_op_a40 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a40_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A40_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a40_val; /* data bits 1311..1280 */
} NX90_MTGY_OP_A40_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A40_BIT_T bf;
} NX90_MTGY_OP_A40_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a41 */
/* => MWMM operand A register 41 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a41  0x000018A4U
#define Adr_NX90_mtgy_mtgy_op_a41 0xFF0838A4U
#define Adr_NX90_mtgy_op_a41      0xFF0838A4U
#define DFLT_VAL_NX90_mtgy_op_a41 0x00000000U

#define MSK_NX90_mtgy_op_a41_val         0xffffffffU
#define SRT_NX90_mtgy_op_a41_val         0
#define DFLT_VAL_NX90_mtgy_op_a41_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a41_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a41': */
#define MSK_USED_BITS_NX90_mtgy_op_a41 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a41_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A41_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a41_val; /* data bits 1343..1312 */
} NX90_MTGY_OP_A41_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A41_BIT_T bf;
} NX90_MTGY_OP_A41_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a42 */
/* => MWMM operand A register 42 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a42  0x000018A8U
#define Adr_NX90_mtgy_mtgy_op_a42 0xFF0838A8U
#define Adr_NX90_mtgy_op_a42      0xFF0838A8U
#define DFLT_VAL_NX90_mtgy_op_a42 0x00000000U

#define MSK_NX90_mtgy_op_a42_val         0xffffffffU
#define SRT_NX90_mtgy_op_a42_val         0
#define DFLT_VAL_NX90_mtgy_op_a42_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a42_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a42': */
#define MSK_USED_BITS_NX90_mtgy_op_a42 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a42_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A42_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a42_val; /* data bits 1375..1344 */
} NX90_MTGY_OP_A42_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A42_BIT_T bf;
} NX90_MTGY_OP_A42_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a43 */
/* => MWMM operand A register 43 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a43  0x000018ACU
#define Adr_NX90_mtgy_mtgy_op_a43 0xFF0838ACU
#define Adr_NX90_mtgy_op_a43      0xFF0838ACU
#define DFLT_VAL_NX90_mtgy_op_a43 0x00000000U

#define MSK_NX90_mtgy_op_a43_val         0xffffffffU
#define SRT_NX90_mtgy_op_a43_val         0
#define DFLT_VAL_NX90_mtgy_op_a43_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a43_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a43': */
#define MSK_USED_BITS_NX90_mtgy_op_a43 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a43_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A43_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a43_val; /* data bits 1407..1376 */
} NX90_MTGY_OP_A43_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A43_BIT_T bf;
} NX90_MTGY_OP_A43_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a44 */
/* => MWMM operand A register 44 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a44  0x000018B0U
#define Adr_NX90_mtgy_mtgy_op_a44 0xFF0838B0U
#define Adr_NX90_mtgy_op_a44      0xFF0838B0U
#define DFLT_VAL_NX90_mtgy_op_a44 0x00000000U

#define MSK_NX90_mtgy_op_a44_val         0xffffffffU
#define SRT_NX90_mtgy_op_a44_val         0
#define DFLT_VAL_NX90_mtgy_op_a44_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a44_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a44': */
#define MSK_USED_BITS_NX90_mtgy_op_a44 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a44_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A44_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a44_val; /* data bits 1439..1408 */
} NX90_MTGY_OP_A44_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A44_BIT_T bf;
} NX90_MTGY_OP_A44_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a45 */
/* => MWMM operand A register 45 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a45  0x000018B4U
#define Adr_NX90_mtgy_mtgy_op_a45 0xFF0838B4U
#define Adr_NX90_mtgy_op_a45      0xFF0838B4U
#define DFLT_VAL_NX90_mtgy_op_a45 0x00000000U

#define MSK_NX90_mtgy_op_a45_val         0xffffffffU
#define SRT_NX90_mtgy_op_a45_val         0
#define DFLT_VAL_NX90_mtgy_op_a45_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a45_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a45': */
#define MSK_USED_BITS_NX90_mtgy_op_a45 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a45_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A45_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a45_val; /* data bits 1471..1440 */
} NX90_MTGY_OP_A45_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A45_BIT_T bf;
} NX90_MTGY_OP_A45_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a46 */
/* => MWMM operand A register 46 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a46  0x000018B8U
#define Adr_NX90_mtgy_mtgy_op_a46 0xFF0838B8U
#define Adr_NX90_mtgy_op_a46      0xFF0838B8U
#define DFLT_VAL_NX90_mtgy_op_a46 0x00000000U

#define MSK_NX90_mtgy_op_a46_val         0xffffffffU
#define SRT_NX90_mtgy_op_a46_val         0
#define DFLT_VAL_NX90_mtgy_op_a46_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a46_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a46': */
#define MSK_USED_BITS_NX90_mtgy_op_a46 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a46_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A46_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a46_val; /* data bits 1503..1472 */
} NX90_MTGY_OP_A46_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A46_BIT_T bf;
} NX90_MTGY_OP_A46_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a47 */
/* => MWMM operand A register 47 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a47  0x000018BCU
#define Adr_NX90_mtgy_mtgy_op_a47 0xFF0838BCU
#define Adr_NX90_mtgy_op_a47      0xFF0838BCU
#define DFLT_VAL_NX90_mtgy_op_a47 0x00000000U

#define MSK_NX90_mtgy_op_a47_val         0xffffffffU
#define SRT_NX90_mtgy_op_a47_val         0
#define DFLT_VAL_NX90_mtgy_op_a47_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a47_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a47': */
#define MSK_USED_BITS_NX90_mtgy_op_a47 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a47_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A47_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a47_val; /* data bits 1535..1504 */
} NX90_MTGY_OP_A47_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A47_BIT_T bf;
} NX90_MTGY_OP_A47_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a48 */
/* => MWMM operand A register 48 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a48  0x000018C0U
#define Adr_NX90_mtgy_mtgy_op_a48 0xFF0838C0U
#define Adr_NX90_mtgy_op_a48      0xFF0838C0U
#define DFLT_VAL_NX90_mtgy_op_a48 0x00000000U

#define MSK_NX90_mtgy_op_a48_val         0xffffffffU
#define SRT_NX90_mtgy_op_a48_val         0
#define DFLT_VAL_NX90_mtgy_op_a48_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a48_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a48': */
#define MSK_USED_BITS_NX90_mtgy_op_a48 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a48_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A48_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a48_val; /* data bits 1567..1536 */
} NX90_MTGY_OP_A48_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A48_BIT_T bf;
} NX90_MTGY_OP_A48_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a49 */
/* => MWMM operand A register 49 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a49  0x000018C4U
#define Adr_NX90_mtgy_mtgy_op_a49 0xFF0838C4U
#define Adr_NX90_mtgy_op_a49      0xFF0838C4U
#define DFLT_VAL_NX90_mtgy_op_a49 0x00000000U

#define MSK_NX90_mtgy_op_a49_val         0xffffffffU
#define SRT_NX90_mtgy_op_a49_val         0
#define DFLT_VAL_NX90_mtgy_op_a49_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a49_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a49': */
#define MSK_USED_BITS_NX90_mtgy_op_a49 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a49_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A49_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a49_val; /* data bits 1599..1568 */
} NX90_MTGY_OP_A49_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A49_BIT_T bf;
} NX90_MTGY_OP_A49_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a50 */
/* => MWMM operand A register 50 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a50  0x000018C8U
#define Adr_NX90_mtgy_mtgy_op_a50 0xFF0838C8U
#define Adr_NX90_mtgy_op_a50      0xFF0838C8U
#define DFLT_VAL_NX90_mtgy_op_a50 0x00000000U

#define MSK_NX90_mtgy_op_a50_val         0xffffffffU
#define SRT_NX90_mtgy_op_a50_val         0
#define DFLT_VAL_NX90_mtgy_op_a50_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a50_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a50': */
#define MSK_USED_BITS_NX90_mtgy_op_a50 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a50_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A50_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a50_val; /* data bits 1631..1600 */
} NX90_MTGY_OP_A50_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A50_BIT_T bf;
} NX90_MTGY_OP_A50_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a51 */
/* => MWMM operand A register 51 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a51  0x000018CCU
#define Adr_NX90_mtgy_mtgy_op_a51 0xFF0838CCU
#define Adr_NX90_mtgy_op_a51      0xFF0838CCU
#define DFLT_VAL_NX90_mtgy_op_a51 0x00000000U

#define MSK_NX90_mtgy_op_a51_val         0xffffffffU
#define SRT_NX90_mtgy_op_a51_val         0
#define DFLT_VAL_NX90_mtgy_op_a51_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a51_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a51': */
#define MSK_USED_BITS_NX90_mtgy_op_a51 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a51_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A51_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a51_val; /* data bits 1663..1632 */
} NX90_MTGY_OP_A51_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A51_BIT_T bf;
} NX90_MTGY_OP_A51_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a52 */
/* => MWMM operand A register 52 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a52  0x000018D0U
#define Adr_NX90_mtgy_mtgy_op_a52 0xFF0838D0U
#define Adr_NX90_mtgy_op_a52      0xFF0838D0U
#define DFLT_VAL_NX90_mtgy_op_a52 0x00000000U

#define MSK_NX90_mtgy_op_a52_val         0xffffffffU
#define SRT_NX90_mtgy_op_a52_val         0
#define DFLT_VAL_NX90_mtgy_op_a52_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a52_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a52': */
#define MSK_USED_BITS_NX90_mtgy_op_a52 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a52_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A52_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a52_val; /* data bits 1695..1664 */
} NX90_MTGY_OP_A52_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A52_BIT_T bf;
} NX90_MTGY_OP_A52_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a53 */
/* => MWMM operand A register 53 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a53  0x000018D4U
#define Adr_NX90_mtgy_mtgy_op_a53 0xFF0838D4U
#define Adr_NX90_mtgy_op_a53      0xFF0838D4U
#define DFLT_VAL_NX90_mtgy_op_a53 0x00000000U

#define MSK_NX90_mtgy_op_a53_val         0xffffffffU
#define SRT_NX90_mtgy_op_a53_val         0
#define DFLT_VAL_NX90_mtgy_op_a53_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a53_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a53': */
#define MSK_USED_BITS_NX90_mtgy_op_a53 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a53_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A53_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a53_val; /* data bits 1727..1696 */
} NX90_MTGY_OP_A53_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A53_BIT_T bf;
} NX90_MTGY_OP_A53_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a54 */
/* => MWMM operand A register 54 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a54  0x000018D8U
#define Adr_NX90_mtgy_mtgy_op_a54 0xFF0838D8U
#define Adr_NX90_mtgy_op_a54      0xFF0838D8U
#define DFLT_VAL_NX90_mtgy_op_a54 0x00000000U

#define MSK_NX90_mtgy_op_a54_val         0xffffffffU
#define SRT_NX90_mtgy_op_a54_val         0
#define DFLT_VAL_NX90_mtgy_op_a54_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a54_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a54': */
#define MSK_USED_BITS_NX90_mtgy_op_a54 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a54_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A54_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a54_val; /* data bits 1759..1728 */
} NX90_MTGY_OP_A54_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A54_BIT_T bf;
} NX90_MTGY_OP_A54_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a55 */
/* => MWMM operand A register 55 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a55  0x000018DCU
#define Adr_NX90_mtgy_mtgy_op_a55 0xFF0838DCU
#define Adr_NX90_mtgy_op_a55      0xFF0838DCU
#define DFLT_VAL_NX90_mtgy_op_a55 0x00000000U

#define MSK_NX90_mtgy_op_a55_val         0xffffffffU
#define SRT_NX90_mtgy_op_a55_val         0
#define DFLT_VAL_NX90_mtgy_op_a55_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a55_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a55': */
#define MSK_USED_BITS_NX90_mtgy_op_a55 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a55_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A55_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a55_val; /* data bits 1791..1760 */
} NX90_MTGY_OP_A55_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A55_BIT_T bf;
} NX90_MTGY_OP_A55_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a56 */
/* => MWMM operand A register 56 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a56  0x000018E0U
#define Adr_NX90_mtgy_mtgy_op_a56 0xFF0838E0U
#define Adr_NX90_mtgy_op_a56      0xFF0838E0U
#define DFLT_VAL_NX90_mtgy_op_a56 0x00000000U

#define MSK_NX90_mtgy_op_a56_val         0xffffffffU
#define SRT_NX90_mtgy_op_a56_val         0
#define DFLT_VAL_NX90_mtgy_op_a56_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a56_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a56': */
#define MSK_USED_BITS_NX90_mtgy_op_a56 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a56_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A56_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a56_val; /* data bits 1823..1792 */
} NX90_MTGY_OP_A56_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A56_BIT_T bf;
} NX90_MTGY_OP_A56_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a57 */
/* => MWMM operand A register 57 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a57  0x000018E4U
#define Adr_NX90_mtgy_mtgy_op_a57 0xFF0838E4U
#define Adr_NX90_mtgy_op_a57      0xFF0838E4U
#define DFLT_VAL_NX90_mtgy_op_a57 0x00000000U

#define MSK_NX90_mtgy_op_a57_val         0xffffffffU
#define SRT_NX90_mtgy_op_a57_val         0
#define DFLT_VAL_NX90_mtgy_op_a57_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a57_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a57': */
#define MSK_USED_BITS_NX90_mtgy_op_a57 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a57_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A57_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a57_val; /* data bits 1855..1824 */
} NX90_MTGY_OP_A57_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A57_BIT_T bf;
} NX90_MTGY_OP_A57_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a58 */
/* => MWMM operand A register 58 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a58  0x000018E8U
#define Adr_NX90_mtgy_mtgy_op_a58 0xFF0838E8U
#define Adr_NX90_mtgy_op_a58      0xFF0838E8U
#define DFLT_VAL_NX90_mtgy_op_a58 0x00000000U

#define MSK_NX90_mtgy_op_a58_val         0xffffffffU
#define SRT_NX90_mtgy_op_a58_val         0
#define DFLT_VAL_NX90_mtgy_op_a58_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a58_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a58': */
#define MSK_USED_BITS_NX90_mtgy_op_a58 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a58_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A58_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a58_val; /* data bits 1887..1856 */
} NX90_MTGY_OP_A58_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A58_BIT_T bf;
} NX90_MTGY_OP_A58_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a59 */
/* => MWMM operand A register 59 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a59  0x000018ECU
#define Adr_NX90_mtgy_mtgy_op_a59 0xFF0838ECU
#define Adr_NX90_mtgy_op_a59      0xFF0838ECU
#define DFLT_VAL_NX90_mtgy_op_a59 0x00000000U

#define MSK_NX90_mtgy_op_a59_val         0xffffffffU
#define SRT_NX90_mtgy_op_a59_val         0
#define DFLT_VAL_NX90_mtgy_op_a59_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a59_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a59': */
#define MSK_USED_BITS_NX90_mtgy_op_a59 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a59_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A59_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a59_val; /* data bits 1919..1888 */
} NX90_MTGY_OP_A59_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A59_BIT_T bf;
} NX90_MTGY_OP_A59_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a60 */
/* => MWMM operand A register 60 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a60  0x000018F0U
#define Adr_NX90_mtgy_mtgy_op_a60 0xFF0838F0U
#define Adr_NX90_mtgy_op_a60      0xFF0838F0U
#define DFLT_VAL_NX90_mtgy_op_a60 0x00000000U

#define MSK_NX90_mtgy_op_a60_val         0xffffffffU
#define SRT_NX90_mtgy_op_a60_val         0
#define DFLT_VAL_NX90_mtgy_op_a60_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a60_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a60': */
#define MSK_USED_BITS_NX90_mtgy_op_a60 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a60_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A60_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a60_val; /* data bits 1951..1920 */
} NX90_MTGY_OP_A60_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A60_BIT_T bf;
} NX90_MTGY_OP_A60_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a61 */
/* => MWMM operand A register 61 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a61  0x000018F4U
#define Adr_NX90_mtgy_mtgy_op_a61 0xFF0838F4U
#define Adr_NX90_mtgy_op_a61      0xFF0838F4U
#define DFLT_VAL_NX90_mtgy_op_a61 0x00000000U

#define MSK_NX90_mtgy_op_a61_val         0xffffffffU
#define SRT_NX90_mtgy_op_a61_val         0
#define DFLT_VAL_NX90_mtgy_op_a61_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a61_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a61': */
#define MSK_USED_BITS_NX90_mtgy_op_a61 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a61_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A61_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a61_val; /* data bits 1983..1952 */
} NX90_MTGY_OP_A61_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A61_BIT_T bf;
} NX90_MTGY_OP_A61_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a62 */
/* => MWMM operand A register 62 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a62  0x000018F8U
#define Adr_NX90_mtgy_mtgy_op_a62 0xFF0838F8U
#define Adr_NX90_mtgy_op_a62      0xFF0838F8U
#define DFLT_VAL_NX90_mtgy_op_a62 0x00000000U

#define MSK_NX90_mtgy_op_a62_val         0xffffffffU
#define SRT_NX90_mtgy_op_a62_val         0
#define DFLT_VAL_NX90_mtgy_op_a62_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a62_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a62': */
#define MSK_USED_BITS_NX90_mtgy_op_a62 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a62_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A62_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a62_val; /* data bits 2015..1984 */
} NX90_MTGY_OP_A62_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A62_BIT_T bf;
} NX90_MTGY_OP_A62_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a63 */
/* => MWMM operand A register 63 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a63  0x000018FCU
#define Adr_NX90_mtgy_mtgy_op_a63 0xFF0838FCU
#define Adr_NX90_mtgy_op_a63      0xFF0838FCU
#define DFLT_VAL_NX90_mtgy_op_a63 0x00000000U

#define MSK_NX90_mtgy_op_a63_val         0xffffffffU
#define SRT_NX90_mtgy_op_a63_val         0
#define DFLT_VAL_NX90_mtgy_op_a63_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a63_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a63': */
#define MSK_USED_BITS_NX90_mtgy_op_a63 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a63_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A63_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a63_val; /* data bits 2047..2016 */
} NX90_MTGY_OP_A63_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A63_BIT_T bf;
} NX90_MTGY_OP_A63_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a64 */
/* => MWMM operand A register 64 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a64  0x00001900U
#define Adr_NX90_mtgy_mtgy_op_a64 0xFF083900U
#define Adr_NX90_mtgy_op_a64      0xFF083900U
#define DFLT_VAL_NX90_mtgy_op_a64 0x00000000U

#define MSK_NX90_mtgy_op_a64_val         0xffffffffU
#define SRT_NX90_mtgy_op_a64_val         0
#define DFLT_VAL_NX90_mtgy_op_a64_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a64_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a64': */
#define MSK_USED_BITS_NX90_mtgy_op_a64 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a64_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A64_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a64_val; /* data bits 2079..2048 */
} NX90_MTGY_OP_A64_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A64_BIT_T bf;
} NX90_MTGY_OP_A64_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a65 */
/* => MWMM operand A register 65 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a65  0x00001904U
#define Adr_NX90_mtgy_mtgy_op_a65 0xFF083904U
#define Adr_NX90_mtgy_op_a65      0xFF083904U
#define DFLT_VAL_NX90_mtgy_op_a65 0x00000000U

#define MSK_NX90_mtgy_op_a65_val         0xffffffffU
#define SRT_NX90_mtgy_op_a65_val         0
#define DFLT_VAL_NX90_mtgy_op_a65_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a65_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a65': */
#define MSK_USED_BITS_NX90_mtgy_op_a65 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a65_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A65_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a65_val; /* data bits 2111..2080 */
} NX90_MTGY_OP_A65_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A65_BIT_T bf;
} NX90_MTGY_OP_A65_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a66 */
/* => MWMM operand A register 66 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a66  0x00001908U
#define Adr_NX90_mtgy_mtgy_op_a66 0xFF083908U
#define Adr_NX90_mtgy_op_a66      0xFF083908U
#define DFLT_VAL_NX90_mtgy_op_a66 0x00000000U

#define MSK_NX90_mtgy_op_a66_val         0xffffffffU
#define SRT_NX90_mtgy_op_a66_val         0
#define DFLT_VAL_NX90_mtgy_op_a66_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a66_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a66': */
#define MSK_USED_BITS_NX90_mtgy_op_a66 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a66_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A66_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a66_val; /* data bits 2143..2112 */
} NX90_MTGY_OP_A66_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A66_BIT_T bf;
} NX90_MTGY_OP_A66_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a67 */
/* => MWMM operand A register 67 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a67  0x0000190CU
#define Adr_NX90_mtgy_mtgy_op_a67 0xFF08390CU
#define Adr_NX90_mtgy_op_a67      0xFF08390CU
#define DFLT_VAL_NX90_mtgy_op_a67 0x00000000U

#define MSK_NX90_mtgy_op_a67_val         0xffffffffU
#define SRT_NX90_mtgy_op_a67_val         0
#define DFLT_VAL_NX90_mtgy_op_a67_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a67_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a67': */
#define MSK_USED_BITS_NX90_mtgy_op_a67 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a67_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A67_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a67_val; /* data bits 2175..2144 */
} NX90_MTGY_OP_A67_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A67_BIT_T bf;
} NX90_MTGY_OP_A67_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a68 */
/* => MWMM operand A register 68 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a68  0x00001910U
#define Adr_NX90_mtgy_mtgy_op_a68 0xFF083910U
#define Adr_NX90_mtgy_op_a68      0xFF083910U
#define DFLT_VAL_NX90_mtgy_op_a68 0x00000000U

#define MSK_NX90_mtgy_op_a68_val         0xffffffffU
#define SRT_NX90_mtgy_op_a68_val         0
#define DFLT_VAL_NX90_mtgy_op_a68_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a68_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a68': */
#define MSK_USED_BITS_NX90_mtgy_op_a68 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a68_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A68_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a68_val; /* data bits 2207..2176 */
} NX90_MTGY_OP_A68_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A68_BIT_T bf;
} NX90_MTGY_OP_A68_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a69 */
/* => MWMM operand A register 69 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a69  0x00001914U
#define Adr_NX90_mtgy_mtgy_op_a69 0xFF083914U
#define Adr_NX90_mtgy_op_a69      0xFF083914U
#define DFLT_VAL_NX90_mtgy_op_a69 0x00000000U

#define MSK_NX90_mtgy_op_a69_val         0xffffffffU
#define SRT_NX90_mtgy_op_a69_val         0
#define DFLT_VAL_NX90_mtgy_op_a69_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a69_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a69': */
#define MSK_USED_BITS_NX90_mtgy_op_a69 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a69_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A69_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a69_val; /* data bits 2239..2208 */
} NX90_MTGY_OP_A69_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A69_BIT_T bf;
} NX90_MTGY_OP_A69_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a70 */
/* => MWMM operand A register 70 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a70  0x00001918U
#define Adr_NX90_mtgy_mtgy_op_a70 0xFF083918U
#define Adr_NX90_mtgy_op_a70      0xFF083918U
#define DFLT_VAL_NX90_mtgy_op_a70 0x00000000U

#define MSK_NX90_mtgy_op_a70_val         0xffffffffU
#define SRT_NX90_mtgy_op_a70_val         0
#define DFLT_VAL_NX90_mtgy_op_a70_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a70_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a70': */
#define MSK_USED_BITS_NX90_mtgy_op_a70 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a70_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A70_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a70_val; /* data bits 2271..2240 */
} NX90_MTGY_OP_A70_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A70_BIT_T bf;
} NX90_MTGY_OP_A70_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a71 */
/* => MWMM operand A register 71 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a71  0x0000191CU
#define Adr_NX90_mtgy_mtgy_op_a71 0xFF08391CU
#define Adr_NX90_mtgy_op_a71      0xFF08391CU
#define DFLT_VAL_NX90_mtgy_op_a71 0x00000000U

#define MSK_NX90_mtgy_op_a71_val         0xffffffffU
#define SRT_NX90_mtgy_op_a71_val         0
#define DFLT_VAL_NX90_mtgy_op_a71_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a71_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a71': */
#define MSK_USED_BITS_NX90_mtgy_op_a71 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a71_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A71_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a71_val; /* data bits 2303..2272 */
} NX90_MTGY_OP_A71_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A71_BIT_T bf;
} NX90_MTGY_OP_A71_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a72 */
/* => MWMM operand A register 72 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a72  0x00001920U
#define Adr_NX90_mtgy_mtgy_op_a72 0xFF083920U
#define Adr_NX90_mtgy_op_a72      0xFF083920U
#define DFLT_VAL_NX90_mtgy_op_a72 0x00000000U

#define MSK_NX90_mtgy_op_a72_val         0xffffffffU
#define SRT_NX90_mtgy_op_a72_val         0
#define DFLT_VAL_NX90_mtgy_op_a72_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a72_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a72': */
#define MSK_USED_BITS_NX90_mtgy_op_a72 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a72_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A72_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a72_val; /* data bits 2335..2304 */
} NX90_MTGY_OP_A72_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A72_BIT_T bf;
} NX90_MTGY_OP_A72_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a73 */
/* => MWMM operand A register 73 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a73  0x00001924U
#define Adr_NX90_mtgy_mtgy_op_a73 0xFF083924U
#define Adr_NX90_mtgy_op_a73      0xFF083924U
#define DFLT_VAL_NX90_mtgy_op_a73 0x00000000U

#define MSK_NX90_mtgy_op_a73_val         0xffffffffU
#define SRT_NX90_mtgy_op_a73_val         0
#define DFLT_VAL_NX90_mtgy_op_a73_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a73_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a73': */
#define MSK_USED_BITS_NX90_mtgy_op_a73 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a73_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A73_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a73_val; /* data bits 2367..2336 */
} NX90_MTGY_OP_A73_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A73_BIT_T bf;
} NX90_MTGY_OP_A73_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a74 */
/* => MWMM operand A register 74 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a74  0x00001928U
#define Adr_NX90_mtgy_mtgy_op_a74 0xFF083928U
#define Adr_NX90_mtgy_op_a74      0xFF083928U
#define DFLT_VAL_NX90_mtgy_op_a74 0x00000000U

#define MSK_NX90_mtgy_op_a74_val         0xffffffffU
#define SRT_NX90_mtgy_op_a74_val         0
#define DFLT_VAL_NX90_mtgy_op_a74_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a74_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a74': */
#define MSK_USED_BITS_NX90_mtgy_op_a74 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a74_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A74_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a74_val; /* data bits 2399..2368 */
} NX90_MTGY_OP_A74_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A74_BIT_T bf;
} NX90_MTGY_OP_A74_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a75 */
/* => MWMM operand A register 75 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a75  0x0000192CU
#define Adr_NX90_mtgy_mtgy_op_a75 0xFF08392CU
#define Adr_NX90_mtgy_op_a75      0xFF08392CU
#define DFLT_VAL_NX90_mtgy_op_a75 0x00000000U

#define MSK_NX90_mtgy_op_a75_val         0xffffffffU
#define SRT_NX90_mtgy_op_a75_val         0
#define DFLT_VAL_NX90_mtgy_op_a75_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a75_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a75': */
#define MSK_USED_BITS_NX90_mtgy_op_a75 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a75_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A75_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a75_val; /* data bits 2431..2400 */
} NX90_MTGY_OP_A75_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A75_BIT_T bf;
} NX90_MTGY_OP_A75_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a76 */
/* => MWMM operand A register 76 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a76  0x00001930U
#define Adr_NX90_mtgy_mtgy_op_a76 0xFF083930U
#define Adr_NX90_mtgy_op_a76      0xFF083930U
#define DFLT_VAL_NX90_mtgy_op_a76 0x00000000U

#define MSK_NX90_mtgy_op_a76_val         0xffffffffU
#define SRT_NX90_mtgy_op_a76_val         0
#define DFLT_VAL_NX90_mtgy_op_a76_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a76_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a76': */
#define MSK_USED_BITS_NX90_mtgy_op_a76 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a76_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A76_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a76_val; /* data bits 2463..2432 */
} NX90_MTGY_OP_A76_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A76_BIT_T bf;
} NX90_MTGY_OP_A76_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a77 */
/* => MWMM operand A register 77 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a77  0x00001934U
#define Adr_NX90_mtgy_mtgy_op_a77 0xFF083934U
#define Adr_NX90_mtgy_op_a77      0xFF083934U
#define DFLT_VAL_NX90_mtgy_op_a77 0x00000000U

#define MSK_NX90_mtgy_op_a77_val         0xffffffffU
#define SRT_NX90_mtgy_op_a77_val         0
#define DFLT_VAL_NX90_mtgy_op_a77_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a77_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a77': */
#define MSK_USED_BITS_NX90_mtgy_op_a77 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a77_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A77_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a77_val; /* data bits 2495..2464 */
} NX90_MTGY_OP_A77_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A77_BIT_T bf;
} NX90_MTGY_OP_A77_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a78 */
/* => MWMM operand A register 78 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a78  0x00001938U
#define Adr_NX90_mtgy_mtgy_op_a78 0xFF083938U
#define Adr_NX90_mtgy_op_a78      0xFF083938U
#define DFLT_VAL_NX90_mtgy_op_a78 0x00000000U

#define MSK_NX90_mtgy_op_a78_val         0xffffffffU
#define SRT_NX90_mtgy_op_a78_val         0
#define DFLT_VAL_NX90_mtgy_op_a78_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a78_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a78': */
#define MSK_USED_BITS_NX90_mtgy_op_a78 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a78_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A78_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a78_val; /* data bits 2527..2496 */
} NX90_MTGY_OP_A78_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A78_BIT_T bf;
} NX90_MTGY_OP_A78_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a79 */
/* => MWMM operand A register 79 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a79  0x0000193CU
#define Adr_NX90_mtgy_mtgy_op_a79 0xFF08393CU
#define Adr_NX90_mtgy_op_a79      0xFF08393CU
#define DFLT_VAL_NX90_mtgy_op_a79 0x00000000U

#define MSK_NX90_mtgy_op_a79_val         0xffffffffU
#define SRT_NX90_mtgy_op_a79_val         0
#define DFLT_VAL_NX90_mtgy_op_a79_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a79_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a79': */
#define MSK_USED_BITS_NX90_mtgy_op_a79 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a79_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A79_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a79_val; /* data bits 2559..2528 */
} NX90_MTGY_OP_A79_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A79_BIT_T bf;
} NX90_MTGY_OP_A79_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a80 */
/* => MWMM operand A register 80 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a80  0x00001940U
#define Adr_NX90_mtgy_mtgy_op_a80 0xFF083940U
#define Adr_NX90_mtgy_op_a80      0xFF083940U
#define DFLT_VAL_NX90_mtgy_op_a80 0x00000000U

#define MSK_NX90_mtgy_op_a80_val         0xffffffffU
#define SRT_NX90_mtgy_op_a80_val         0
#define DFLT_VAL_NX90_mtgy_op_a80_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a80_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a80': */
#define MSK_USED_BITS_NX90_mtgy_op_a80 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a80_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A80_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a80_val; /* data bits 2591..2560 */
} NX90_MTGY_OP_A80_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A80_BIT_T bf;
} NX90_MTGY_OP_A80_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a81 */
/* => MWMM operand A register 81 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a81  0x00001944U
#define Adr_NX90_mtgy_mtgy_op_a81 0xFF083944U
#define Adr_NX90_mtgy_op_a81      0xFF083944U
#define DFLT_VAL_NX90_mtgy_op_a81 0x00000000U

#define MSK_NX90_mtgy_op_a81_val         0xffffffffU
#define SRT_NX90_mtgy_op_a81_val         0
#define DFLT_VAL_NX90_mtgy_op_a81_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a81_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a81': */
#define MSK_USED_BITS_NX90_mtgy_op_a81 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a81_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A81_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a81_val; /* data bits 2623..2592 */
} NX90_MTGY_OP_A81_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A81_BIT_T bf;
} NX90_MTGY_OP_A81_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a82 */
/* => MWMM operand A register 82 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a82  0x00001948U
#define Adr_NX90_mtgy_mtgy_op_a82 0xFF083948U
#define Adr_NX90_mtgy_op_a82      0xFF083948U
#define DFLT_VAL_NX90_mtgy_op_a82 0x00000000U

#define MSK_NX90_mtgy_op_a82_val         0xffffffffU
#define SRT_NX90_mtgy_op_a82_val         0
#define DFLT_VAL_NX90_mtgy_op_a82_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a82_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a82': */
#define MSK_USED_BITS_NX90_mtgy_op_a82 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a82_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A82_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a82_val; /* data bits 2655..2624 */
} NX90_MTGY_OP_A82_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A82_BIT_T bf;
} NX90_MTGY_OP_A82_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a83 */
/* => MWMM operand A register 83 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a83  0x0000194CU
#define Adr_NX90_mtgy_mtgy_op_a83 0xFF08394CU
#define Adr_NX90_mtgy_op_a83      0xFF08394CU
#define DFLT_VAL_NX90_mtgy_op_a83 0x00000000U

#define MSK_NX90_mtgy_op_a83_val         0xffffffffU
#define SRT_NX90_mtgy_op_a83_val         0
#define DFLT_VAL_NX90_mtgy_op_a83_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a83_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a83': */
#define MSK_USED_BITS_NX90_mtgy_op_a83 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a83_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A83_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a83_val; /* data bits 2687..2656 */
} NX90_MTGY_OP_A83_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A83_BIT_T bf;
} NX90_MTGY_OP_A83_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a84 */
/* => MWMM operand A register 84 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a84  0x00001950U
#define Adr_NX90_mtgy_mtgy_op_a84 0xFF083950U
#define Adr_NX90_mtgy_op_a84      0xFF083950U
#define DFLT_VAL_NX90_mtgy_op_a84 0x00000000U

#define MSK_NX90_mtgy_op_a84_val         0xffffffffU
#define SRT_NX90_mtgy_op_a84_val         0
#define DFLT_VAL_NX90_mtgy_op_a84_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a84_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a84': */
#define MSK_USED_BITS_NX90_mtgy_op_a84 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a84_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A84_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a84_val; /* data bits 2719..2688 */
} NX90_MTGY_OP_A84_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A84_BIT_T bf;
} NX90_MTGY_OP_A84_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a85 */
/* => MWMM operand A register 85 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a85  0x00001954U
#define Adr_NX90_mtgy_mtgy_op_a85 0xFF083954U
#define Adr_NX90_mtgy_op_a85      0xFF083954U
#define DFLT_VAL_NX90_mtgy_op_a85 0x00000000U

#define MSK_NX90_mtgy_op_a85_val         0xffffffffU
#define SRT_NX90_mtgy_op_a85_val         0
#define DFLT_VAL_NX90_mtgy_op_a85_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a85_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a85': */
#define MSK_USED_BITS_NX90_mtgy_op_a85 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a85_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A85_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a85_val; /* data bits 2751..2720 */
} NX90_MTGY_OP_A85_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A85_BIT_T bf;
} NX90_MTGY_OP_A85_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a86 */
/* => MWMM operand A register 86 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a86  0x00001958U
#define Adr_NX90_mtgy_mtgy_op_a86 0xFF083958U
#define Adr_NX90_mtgy_op_a86      0xFF083958U
#define DFLT_VAL_NX90_mtgy_op_a86 0x00000000U

#define MSK_NX90_mtgy_op_a86_val         0xffffffffU
#define SRT_NX90_mtgy_op_a86_val         0
#define DFLT_VAL_NX90_mtgy_op_a86_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a86_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a86': */
#define MSK_USED_BITS_NX90_mtgy_op_a86 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a86_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A86_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a86_val; /* data bits 2783..2752 */
} NX90_MTGY_OP_A86_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A86_BIT_T bf;
} NX90_MTGY_OP_A86_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a87 */
/* => MWMM operand A register 87 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a87  0x0000195CU
#define Adr_NX90_mtgy_mtgy_op_a87 0xFF08395CU
#define Adr_NX90_mtgy_op_a87      0xFF08395CU
#define DFLT_VAL_NX90_mtgy_op_a87 0x00000000U

#define MSK_NX90_mtgy_op_a87_val         0xffffffffU
#define SRT_NX90_mtgy_op_a87_val         0
#define DFLT_VAL_NX90_mtgy_op_a87_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a87_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a87': */
#define MSK_USED_BITS_NX90_mtgy_op_a87 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a87_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A87_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a87_val; /* data bits 2815..2784 */
} NX90_MTGY_OP_A87_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A87_BIT_T bf;
} NX90_MTGY_OP_A87_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a88 */
/* => MWMM operand A register 88 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a88  0x00001960U
#define Adr_NX90_mtgy_mtgy_op_a88 0xFF083960U
#define Adr_NX90_mtgy_op_a88      0xFF083960U
#define DFLT_VAL_NX90_mtgy_op_a88 0x00000000U

#define MSK_NX90_mtgy_op_a88_val         0xffffffffU
#define SRT_NX90_mtgy_op_a88_val         0
#define DFLT_VAL_NX90_mtgy_op_a88_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a88_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a88': */
#define MSK_USED_BITS_NX90_mtgy_op_a88 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a88_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A88_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a88_val; /* data bits 2847..2816 */
} NX90_MTGY_OP_A88_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A88_BIT_T bf;
} NX90_MTGY_OP_A88_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a89 */
/* => MWMM operand A register 89 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a89  0x00001964U
#define Adr_NX90_mtgy_mtgy_op_a89 0xFF083964U
#define Adr_NX90_mtgy_op_a89      0xFF083964U
#define DFLT_VAL_NX90_mtgy_op_a89 0x00000000U

#define MSK_NX90_mtgy_op_a89_val         0xffffffffU
#define SRT_NX90_mtgy_op_a89_val         0
#define DFLT_VAL_NX90_mtgy_op_a89_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a89_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a89': */
#define MSK_USED_BITS_NX90_mtgy_op_a89 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a89_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A89_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a89_val; /* data bits 2879..2848 */
} NX90_MTGY_OP_A89_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A89_BIT_T bf;
} NX90_MTGY_OP_A89_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a90 */
/* => MWMM operand A register 90 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a90  0x00001968U
#define Adr_NX90_mtgy_mtgy_op_a90 0xFF083968U
#define Adr_NX90_mtgy_op_a90      0xFF083968U
#define DFLT_VAL_NX90_mtgy_op_a90 0x00000000U

#define MSK_NX90_mtgy_op_a90_val         0xffffffffU
#define SRT_NX90_mtgy_op_a90_val         0
#define DFLT_VAL_NX90_mtgy_op_a90_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a90_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a90': */
#define MSK_USED_BITS_NX90_mtgy_op_a90 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a90_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A90_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a90_val; /* data bits 2911..2880 */
} NX90_MTGY_OP_A90_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A90_BIT_T bf;
} NX90_MTGY_OP_A90_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a91 */
/* => MWMM operand A register 91 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a91  0x0000196CU
#define Adr_NX90_mtgy_mtgy_op_a91 0xFF08396CU
#define Adr_NX90_mtgy_op_a91      0xFF08396CU
#define DFLT_VAL_NX90_mtgy_op_a91 0x00000000U

#define MSK_NX90_mtgy_op_a91_val         0xffffffffU
#define SRT_NX90_mtgy_op_a91_val         0
#define DFLT_VAL_NX90_mtgy_op_a91_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a91_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a91': */
#define MSK_USED_BITS_NX90_mtgy_op_a91 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a91_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A91_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a91_val; /* data bits 2943..2912 */
} NX90_MTGY_OP_A91_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A91_BIT_T bf;
} NX90_MTGY_OP_A91_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a92 */
/* => MWMM operand A register 92 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a92  0x00001970U
#define Adr_NX90_mtgy_mtgy_op_a92 0xFF083970U
#define Adr_NX90_mtgy_op_a92      0xFF083970U
#define DFLT_VAL_NX90_mtgy_op_a92 0x00000000U

#define MSK_NX90_mtgy_op_a92_val         0xffffffffU
#define SRT_NX90_mtgy_op_a92_val         0
#define DFLT_VAL_NX90_mtgy_op_a92_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a92_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a92': */
#define MSK_USED_BITS_NX90_mtgy_op_a92 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a92_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A92_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a92_val; /* data bits 2975..2944 */
} NX90_MTGY_OP_A92_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A92_BIT_T bf;
} NX90_MTGY_OP_A92_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a93 */
/* => MWMM operand A register 93 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a93  0x00001974U
#define Adr_NX90_mtgy_mtgy_op_a93 0xFF083974U
#define Adr_NX90_mtgy_op_a93      0xFF083974U
#define DFLT_VAL_NX90_mtgy_op_a93 0x00000000U

#define MSK_NX90_mtgy_op_a93_val         0xffffffffU
#define SRT_NX90_mtgy_op_a93_val         0
#define DFLT_VAL_NX90_mtgy_op_a93_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a93_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a93': */
#define MSK_USED_BITS_NX90_mtgy_op_a93 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a93_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A93_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a93_val; /* data bits 3007..2976 */
} NX90_MTGY_OP_A93_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A93_BIT_T bf;
} NX90_MTGY_OP_A93_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a94 */
/* => MWMM operand A register 94 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a94  0x00001978U
#define Adr_NX90_mtgy_mtgy_op_a94 0xFF083978U
#define Adr_NX90_mtgy_op_a94      0xFF083978U
#define DFLT_VAL_NX90_mtgy_op_a94 0x00000000U

#define MSK_NX90_mtgy_op_a94_val         0xffffffffU
#define SRT_NX90_mtgy_op_a94_val         0
#define DFLT_VAL_NX90_mtgy_op_a94_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a94_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a94': */
#define MSK_USED_BITS_NX90_mtgy_op_a94 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a94_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A94_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a94_val; /* data bits 3039..3008 */
} NX90_MTGY_OP_A94_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A94_BIT_T bf;
} NX90_MTGY_OP_A94_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a95 */
/* => MWMM operand A register 95 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a95  0x0000197CU
#define Adr_NX90_mtgy_mtgy_op_a95 0xFF08397CU
#define Adr_NX90_mtgy_op_a95      0xFF08397CU
#define DFLT_VAL_NX90_mtgy_op_a95 0x00000000U

#define MSK_NX90_mtgy_op_a95_val         0xffffffffU
#define SRT_NX90_mtgy_op_a95_val         0
#define DFLT_VAL_NX90_mtgy_op_a95_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a95_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a95': */
#define MSK_USED_BITS_NX90_mtgy_op_a95 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a95_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A95_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a95_val; /* data bits 3071..3040 */
} NX90_MTGY_OP_A95_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A95_BIT_T bf;
} NX90_MTGY_OP_A95_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a96 */
/* => MWMM operand A register 96 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a96  0x00001980U
#define Adr_NX90_mtgy_mtgy_op_a96 0xFF083980U
#define Adr_NX90_mtgy_op_a96      0xFF083980U
#define DFLT_VAL_NX90_mtgy_op_a96 0x00000000U

#define MSK_NX90_mtgy_op_a96_val         0xffffffffU
#define SRT_NX90_mtgy_op_a96_val         0
#define DFLT_VAL_NX90_mtgy_op_a96_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a96_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a96': */
#define MSK_USED_BITS_NX90_mtgy_op_a96 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a96_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A96_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a96_val; /* data bits 3103..3072 */
} NX90_MTGY_OP_A96_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A96_BIT_T bf;
} NX90_MTGY_OP_A96_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a97 */
/* => MWMM operand A register 97 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a97  0x00001984U
#define Adr_NX90_mtgy_mtgy_op_a97 0xFF083984U
#define Adr_NX90_mtgy_op_a97      0xFF083984U
#define DFLT_VAL_NX90_mtgy_op_a97 0x00000000U

#define MSK_NX90_mtgy_op_a97_val         0xffffffffU
#define SRT_NX90_mtgy_op_a97_val         0
#define DFLT_VAL_NX90_mtgy_op_a97_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a97_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a97': */
#define MSK_USED_BITS_NX90_mtgy_op_a97 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a97_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A97_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a97_val; /* data bits 3135..3104 */
} NX90_MTGY_OP_A97_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A97_BIT_T bf;
} NX90_MTGY_OP_A97_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a98 */
/* => MWMM operand A register 98 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a98  0x00001988U
#define Adr_NX90_mtgy_mtgy_op_a98 0xFF083988U
#define Adr_NX90_mtgy_op_a98      0xFF083988U
#define DFLT_VAL_NX90_mtgy_op_a98 0x00000000U

#define MSK_NX90_mtgy_op_a98_val         0xffffffffU
#define SRT_NX90_mtgy_op_a98_val         0
#define DFLT_VAL_NX90_mtgy_op_a98_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a98_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a98': */
#define MSK_USED_BITS_NX90_mtgy_op_a98 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a98_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A98_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a98_val; /* data bits 3167..3136 */
} NX90_MTGY_OP_A98_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A98_BIT_T bf;
} NX90_MTGY_OP_A98_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a99 */
/* => MWMM operand A register 99 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a99  0x0000198CU
#define Adr_NX90_mtgy_mtgy_op_a99 0xFF08398CU
#define Adr_NX90_mtgy_op_a99      0xFF08398CU
#define DFLT_VAL_NX90_mtgy_op_a99 0x00000000U

#define MSK_NX90_mtgy_op_a99_val         0xffffffffU
#define SRT_NX90_mtgy_op_a99_val         0
#define DFLT_VAL_NX90_mtgy_op_a99_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a99_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a99': */
#define MSK_USED_BITS_NX90_mtgy_op_a99 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a99_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A99_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a99_val; /* data bits 3199..3168 */
} NX90_MTGY_OP_A99_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_A99_BIT_T bf;
} NX90_MTGY_OP_A99_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a100 */
/* => MWMM operand A register 100 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a100  0x00001990U
#define Adr_NX90_mtgy_mtgy_op_a100 0xFF083990U
#define Adr_NX90_mtgy_op_a100      0xFF083990U
#define DFLT_VAL_NX90_mtgy_op_a100 0x00000000U

#define MSK_NX90_mtgy_op_a100_val         0xffffffffU
#define SRT_NX90_mtgy_op_a100_val         0
#define DFLT_VAL_NX90_mtgy_op_a100_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a100_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a100': */
#define MSK_USED_BITS_NX90_mtgy_op_a100 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a100_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A100_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a100_val; /* data bits 3231..3200 */
} NX90_MTGY_OP_A100_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A100_BIT_T bf;
} NX90_MTGY_OP_A100_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a101 */
/* => MWMM operand A register 101 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a101  0x00001994U
#define Adr_NX90_mtgy_mtgy_op_a101 0xFF083994U
#define Adr_NX90_mtgy_op_a101      0xFF083994U
#define DFLT_VAL_NX90_mtgy_op_a101 0x00000000U

#define MSK_NX90_mtgy_op_a101_val         0xffffffffU
#define SRT_NX90_mtgy_op_a101_val         0
#define DFLT_VAL_NX90_mtgy_op_a101_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a101_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a101': */
#define MSK_USED_BITS_NX90_mtgy_op_a101 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a101_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A101_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a101_val; /* data bits 3263..3232 */
} NX90_MTGY_OP_A101_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A101_BIT_T bf;
} NX90_MTGY_OP_A101_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a102 */
/* => MWMM operand A register 102 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a102  0x00001998U
#define Adr_NX90_mtgy_mtgy_op_a102 0xFF083998U
#define Adr_NX90_mtgy_op_a102      0xFF083998U
#define DFLT_VAL_NX90_mtgy_op_a102 0x00000000U

#define MSK_NX90_mtgy_op_a102_val         0xffffffffU
#define SRT_NX90_mtgy_op_a102_val         0
#define DFLT_VAL_NX90_mtgy_op_a102_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a102_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a102': */
#define MSK_USED_BITS_NX90_mtgy_op_a102 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a102_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A102_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a102_val; /* data bits 3295..3264 */
} NX90_MTGY_OP_A102_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A102_BIT_T bf;
} NX90_MTGY_OP_A102_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a103 */
/* => MWMM operand A register 103 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a103  0x0000199CU
#define Adr_NX90_mtgy_mtgy_op_a103 0xFF08399CU
#define Adr_NX90_mtgy_op_a103      0xFF08399CU
#define DFLT_VAL_NX90_mtgy_op_a103 0x00000000U

#define MSK_NX90_mtgy_op_a103_val         0xffffffffU
#define SRT_NX90_mtgy_op_a103_val         0
#define DFLT_VAL_NX90_mtgy_op_a103_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a103_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a103': */
#define MSK_USED_BITS_NX90_mtgy_op_a103 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a103_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A103_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a103_val; /* data bits 3327..3296 */
} NX90_MTGY_OP_A103_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A103_BIT_T bf;
} NX90_MTGY_OP_A103_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a104 */
/* => MWMM operand A register 104 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a104  0x000019A0U
#define Adr_NX90_mtgy_mtgy_op_a104 0xFF0839A0U
#define Adr_NX90_mtgy_op_a104      0xFF0839A0U
#define DFLT_VAL_NX90_mtgy_op_a104 0x00000000U

#define MSK_NX90_mtgy_op_a104_val         0xffffffffU
#define SRT_NX90_mtgy_op_a104_val         0
#define DFLT_VAL_NX90_mtgy_op_a104_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a104_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a104': */
#define MSK_USED_BITS_NX90_mtgy_op_a104 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a104_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A104_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a104_val; /* data bits 3359..3328 */
} NX90_MTGY_OP_A104_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A104_BIT_T bf;
} NX90_MTGY_OP_A104_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a105 */
/* => MWMM operand A register 105 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a105  0x000019A4U
#define Adr_NX90_mtgy_mtgy_op_a105 0xFF0839A4U
#define Adr_NX90_mtgy_op_a105      0xFF0839A4U
#define DFLT_VAL_NX90_mtgy_op_a105 0x00000000U

#define MSK_NX90_mtgy_op_a105_val         0xffffffffU
#define SRT_NX90_mtgy_op_a105_val         0
#define DFLT_VAL_NX90_mtgy_op_a105_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a105_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a105': */
#define MSK_USED_BITS_NX90_mtgy_op_a105 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a105_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A105_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a105_val; /* data bits 3391..3360 */
} NX90_MTGY_OP_A105_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A105_BIT_T bf;
} NX90_MTGY_OP_A105_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a106 */
/* => MWMM operand A register 106 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a106  0x000019A8U
#define Adr_NX90_mtgy_mtgy_op_a106 0xFF0839A8U
#define Adr_NX90_mtgy_op_a106      0xFF0839A8U
#define DFLT_VAL_NX90_mtgy_op_a106 0x00000000U

#define MSK_NX90_mtgy_op_a106_val         0xffffffffU
#define SRT_NX90_mtgy_op_a106_val         0
#define DFLT_VAL_NX90_mtgy_op_a106_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a106_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a106': */
#define MSK_USED_BITS_NX90_mtgy_op_a106 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a106_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A106_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a106_val; /* data bits 3423..3392 */
} NX90_MTGY_OP_A106_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A106_BIT_T bf;
} NX90_MTGY_OP_A106_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a107 */
/* => MWMM operand A register 107 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a107  0x000019ACU
#define Adr_NX90_mtgy_mtgy_op_a107 0xFF0839ACU
#define Adr_NX90_mtgy_op_a107      0xFF0839ACU
#define DFLT_VAL_NX90_mtgy_op_a107 0x00000000U

#define MSK_NX90_mtgy_op_a107_val         0xffffffffU
#define SRT_NX90_mtgy_op_a107_val         0
#define DFLT_VAL_NX90_mtgy_op_a107_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a107_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a107': */
#define MSK_USED_BITS_NX90_mtgy_op_a107 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a107_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A107_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a107_val; /* data bits 3455..3424 */
} NX90_MTGY_OP_A107_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A107_BIT_T bf;
} NX90_MTGY_OP_A107_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a108 */
/* => MWMM operand A register 108 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a108  0x000019B0U
#define Adr_NX90_mtgy_mtgy_op_a108 0xFF0839B0U
#define Adr_NX90_mtgy_op_a108      0xFF0839B0U
#define DFLT_VAL_NX90_mtgy_op_a108 0x00000000U

#define MSK_NX90_mtgy_op_a108_val         0xffffffffU
#define SRT_NX90_mtgy_op_a108_val         0
#define DFLT_VAL_NX90_mtgy_op_a108_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a108_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a108': */
#define MSK_USED_BITS_NX90_mtgy_op_a108 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a108_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A108_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a108_val; /* data bits 3487..3456 */
} NX90_MTGY_OP_A108_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A108_BIT_T bf;
} NX90_MTGY_OP_A108_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a109 */
/* => MWMM operand A register 109 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a109  0x000019B4U
#define Adr_NX90_mtgy_mtgy_op_a109 0xFF0839B4U
#define Adr_NX90_mtgy_op_a109      0xFF0839B4U
#define DFLT_VAL_NX90_mtgy_op_a109 0x00000000U

#define MSK_NX90_mtgy_op_a109_val         0xffffffffU
#define SRT_NX90_mtgy_op_a109_val         0
#define DFLT_VAL_NX90_mtgy_op_a109_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a109_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a109': */
#define MSK_USED_BITS_NX90_mtgy_op_a109 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a109_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A109_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a109_val; /* data bits 3519..3488 */
} NX90_MTGY_OP_A109_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A109_BIT_T bf;
} NX90_MTGY_OP_A109_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a110 */
/* => MWMM operand A register 110 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a110  0x000019B8U
#define Adr_NX90_mtgy_mtgy_op_a110 0xFF0839B8U
#define Adr_NX90_mtgy_op_a110      0xFF0839B8U
#define DFLT_VAL_NX90_mtgy_op_a110 0x00000000U

#define MSK_NX90_mtgy_op_a110_val         0xffffffffU
#define SRT_NX90_mtgy_op_a110_val         0
#define DFLT_VAL_NX90_mtgy_op_a110_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a110_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a110': */
#define MSK_USED_BITS_NX90_mtgy_op_a110 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a110_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A110_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a110_val; /* data bits 3551..3520 */
} NX90_MTGY_OP_A110_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A110_BIT_T bf;
} NX90_MTGY_OP_A110_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a111 */
/* => MWMM operand A register 111 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a111  0x000019BCU
#define Adr_NX90_mtgy_mtgy_op_a111 0xFF0839BCU
#define Adr_NX90_mtgy_op_a111      0xFF0839BCU
#define DFLT_VAL_NX90_mtgy_op_a111 0x00000000U

#define MSK_NX90_mtgy_op_a111_val         0xffffffffU
#define SRT_NX90_mtgy_op_a111_val         0
#define DFLT_VAL_NX90_mtgy_op_a111_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a111_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a111': */
#define MSK_USED_BITS_NX90_mtgy_op_a111 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a111_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A111_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a111_val; /* data bits 3583..3552 */
} NX90_MTGY_OP_A111_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A111_BIT_T bf;
} NX90_MTGY_OP_A111_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a112 */
/* => MWMM operand A register 112 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a112  0x000019C0U
#define Adr_NX90_mtgy_mtgy_op_a112 0xFF0839C0U
#define Adr_NX90_mtgy_op_a112      0xFF0839C0U
#define DFLT_VAL_NX90_mtgy_op_a112 0x00000000U

#define MSK_NX90_mtgy_op_a112_val         0xffffffffU
#define SRT_NX90_mtgy_op_a112_val         0
#define DFLT_VAL_NX90_mtgy_op_a112_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a112_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a112': */
#define MSK_USED_BITS_NX90_mtgy_op_a112 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a112_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A112_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a112_val; /* data bits 3615..3584 */
} NX90_MTGY_OP_A112_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A112_BIT_T bf;
} NX90_MTGY_OP_A112_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a113 */
/* => MWMM operand A register 113 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a113  0x000019C4U
#define Adr_NX90_mtgy_mtgy_op_a113 0xFF0839C4U
#define Adr_NX90_mtgy_op_a113      0xFF0839C4U
#define DFLT_VAL_NX90_mtgy_op_a113 0x00000000U

#define MSK_NX90_mtgy_op_a113_val         0xffffffffU
#define SRT_NX90_mtgy_op_a113_val         0
#define DFLT_VAL_NX90_mtgy_op_a113_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a113_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a113': */
#define MSK_USED_BITS_NX90_mtgy_op_a113 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a113_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A113_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a113_val; /* data bits 3647..3616 */
} NX90_MTGY_OP_A113_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A113_BIT_T bf;
} NX90_MTGY_OP_A113_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a114 */
/* => MWMM operand A register 114 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a114  0x000019C8U
#define Adr_NX90_mtgy_mtgy_op_a114 0xFF0839C8U
#define Adr_NX90_mtgy_op_a114      0xFF0839C8U
#define DFLT_VAL_NX90_mtgy_op_a114 0x00000000U

#define MSK_NX90_mtgy_op_a114_val         0xffffffffU
#define SRT_NX90_mtgy_op_a114_val         0
#define DFLT_VAL_NX90_mtgy_op_a114_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a114_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a114': */
#define MSK_USED_BITS_NX90_mtgy_op_a114 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a114_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A114_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a114_val; /* data bits 3679..3648 */
} NX90_MTGY_OP_A114_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A114_BIT_T bf;
} NX90_MTGY_OP_A114_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a115 */
/* => MWMM operand A register 115 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a115  0x000019CCU
#define Adr_NX90_mtgy_mtgy_op_a115 0xFF0839CCU
#define Adr_NX90_mtgy_op_a115      0xFF0839CCU
#define DFLT_VAL_NX90_mtgy_op_a115 0x00000000U

#define MSK_NX90_mtgy_op_a115_val         0xffffffffU
#define SRT_NX90_mtgy_op_a115_val         0
#define DFLT_VAL_NX90_mtgy_op_a115_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a115_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a115': */
#define MSK_USED_BITS_NX90_mtgy_op_a115 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a115_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A115_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a115_val; /* data bits 3711..3680 */
} NX90_MTGY_OP_A115_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A115_BIT_T bf;
} NX90_MTGY_OP_A115_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a116 */
/* => MWMM operand A register 116 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a116  0x000019D0U
#define Adr_NX90_mtgy_mtgy_op_a116 0xFF0839D0U
#define Adr_NX90_mtgy_op_a116      0xFF0839D0U
#define DFLT_VAL_NX90_mtgy_op_a116 0x00000000U

#define MSK_NX90_mtgy_op_a116_val         0xffffffffU
#define SRT_NX90_mtgy_op_a116_val         0
#define DFLT_VAL_NX90_mtgy_op_a116_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a116_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a116': */
#define MSK_USED_BITS_NX90_mtgy_op_a116 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a116_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A116_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a116_val; /* data bits 3743..3712 */
} NX90_MTGY_OP_A116_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A116_BIT_T bf;
} NX90_MTGY_OP_A116_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a117 */
/* => MWMM operand A register 117 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a117  0x000019D4U
#define Adr_NX90_mtgy_mtgy_op_a117 0xFF0839D4U
#define Adr_NX90_mtgy_op_a117      0xFF0839D4U
#define DFLT_VAL_NX90_mtgy_op_a117 0x00000000U

#define MSK_NX90_mtgy_op_a117_val         0xffffffffU
#define SRT_NX90_mtgy_op_a117_val         0
#define DFLT_VAL_NX90_mtgy_op_a117_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a117_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a117': */
#define MSK_USED_BITS_NX90_mtgy_op_a117 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a117_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A117_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a117_val; /* data bits 3775..3744 */
} NX90_MTGY_OP_A117_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A117_BIT_T bf;
} NX90_MTGY_OP_A117_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a118 */
/* => MWMM operand A register 118 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a118  0x000019D8U
#define Adr_NX90_mtgy_mtgy_op_a118 0xFF0839D8U
#define Adr_NX90_mtgy_op_a118      0xFF0839D8U
#define DFLT_VAL_NX90_mtgy_op_a118 0x00000000U

#define MSK_NX90_mtgy_op_a118_val         0xffffffffU
#define SRT_NX90_mtgy_op_a118_val         0
#define DFLT_VAL_NX90_mtgy_op_a118_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a118_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a118': */
#define MSK_USED_BITS_NX90_mtgy_op_a118 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a118_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A118_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a118_val; /* data bits 3807..3776 */
} NX90_MTGY_OP_A118_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A118_BIT_T bf;
} NX90_MTGY_OP_A118_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a119 */
/* => MWMM operand A register 119 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a119  0x000019DCU
#define Adr_NX90_mtgy_mtgy_op_a119 0xFF0839DCU
#define Adr_NX90_mtgy_op_a119      0xFF0839DCU
#define DFLT_VAL_NX90_mtgy_op_a119 0x00000000U

#define MSK_NX90_mtgy_op_a119_val         0xffffffffU
#define SRT_NX90_mtgy_op_a119_val         0
#define DFLT_VAL_NX90_mtgy_op_a119_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a119_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a119': */
#define MSK_USED_BITS_NX90_mtgy_op_a119 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a119_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A119_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a119_val; /* data bits 3839..3808 */
} NX90_MTGY_OP_A119_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A119_BIT_T bf;
} NX90_MTGY_OP_A119_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a120 */
/* => MWMM operand A register 120 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a120  0x000019E0U
#define Adr_NX90_mtgy_mtgy_op_a120 0xFF0839E0U
#define Adr_NX90_mtgy_op_a120      0xFF0839E0U
#define DFLT_VAL_NX90_mtgy_op_a120 0x00000000U

#define MSK_NX90_mtgy_op_a120_val         0xffffffffU
#define SRT_NX90_mtgy_op_a120_val         0
#define DFLT_VAL_NX90_mtgy_op_a120_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a120_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a120': */
#define MSK_USED_BITS_NX90_mtgy_op_a120 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a120_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A120_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a120_val; /* data bits 3871..3840 */
} NX90_MTGY_OP_A120_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A120_BIT_T bf;
} NX90_MTGY_OP_A120_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a121 */
/* => MWMM operand A register 121 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a121  0x000019E4U
#define Adr_NX90_mtgy_mtgy_op_a121 0xFF0839E4U
#define Adr_NX90_mtgy_op_a121      0xFF0839E4U
#define DFLT_VAL_NX90_mtgy_op_a121 0x00000000U

#define MSK_NX90_mtgy_op_a121_val         0xffffffffU
#define SRT_NX90_mtgy_op_a121_val         0
#define DFLT_VAL_NX90_mtgy_op_a121_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a121_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a121': */
#define MSK_USED_BITS_NX90_mtgy_op_a121 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a121_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A121_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a121_val; /* data bits 3903..3872 */
} NX90_MTGY_OP_A121_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A121_BIT_T bf;
} NX90_MTGY_OP_A121_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a122 */
/* => MWMM operand A register 122 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a122  0x000019E8U
#define Adr_NX90_mtgy_mtgy_op_a122 0xFF0839E8U
#define Adr_NX90_mtgy_op_a122      0xFF0839E8U
#define DFLT_VAL_NX90_mtgy_op_a122 0x00000000U

#define MSK_NX90_mtgy_op_a122_val         0xffffffffU
#define SRT_NX90_mtgy_op_a122_val         0
#define DFLT_VAL_NX90_mtgy_op_a122_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a122_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a122': */
#define MSK_USED_BITS_NX90_mtgy_op_a122 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a122_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A122_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a122_val; /* data bits 3935..3904 */
} NX90_MTGY_OP_A122_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A122_BIT_T bf;
} NX90_MTGY_OP_A122_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a123 */
/* => MWMM operand A register 123 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a123  0x000019ECU
#define Adr_NX90_mtgy_mtgy_op_a123 0xFF0839ECU
#define Adr_NX90_mtgy_op_a123      0xFF0839ECU
#define DFLT_VAL_NX90_mtgy_op_a123 0x00000000U

#define MSK_NX90_mtgy_op_a123_val         0xffffffffU
#define SRT_NX90_mtgy_op_a123_val         0
#define DFLT_VAL_NX90_mtgy_op_a123_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a123_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a123': */
#define MSK_USED_BITS_NX90_mtgy_op_a123 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a123_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A123_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a123_val; /* data bits 3967..3936 */
} NX90_MTGY_OP_A123_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A123_BIT_T bf;
} NX90_MTGY_OP_A123_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a124 */
/* => MWMM operand A register 124 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a124  0x000019F0U
#define Adr_NX90_mtgy_mtgy_op_a124 0xFF0839F0U
#define Adr_NX90_mtgy_op_a124      0xFF0839F0U
#define DFLT_VAL_NX90_mtgy_op_a124 0x00000000U

#define MSK_NX90_mtgy_op_a124_val         0xffffffffU
#define SRT_NX90_mtgy_op_a124_val         0
#define DFLT_VAL_NX90_mtgy_op_a124_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a124_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a124': */
#define MSK_USED_BITS_NX90_mtgy_op_a124 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a124_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A124_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a124_val; /* data bits 3999..3968 */
} NX90_MTGY_OP_A124_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A124_BIT_T bf;
} NX90_MTGY_OP_A124_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a125 */
/* => MWMM operand A register 125 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a125  0x000019F4U
#define Adr_NX90_mtgy_mtgy_op_a125 0xFF0839F4U
#define Adr_NX90_mtgy_op_a125      0xFF0839F4U
#define DFLT_VAL_NX90_mtgy_op_a125 0x00000000U

#define MSK_NX90_mtgy_op_a125_val         0xffffffffU
#define SRT_NX90_mtgy_op_a125_val         0
#define DFLT_VAL_NX90_mtgy_op_a125_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a125_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a125': */
#define MSK_USED_BITS_NX90_mtgy_op_a125 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a125_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A125_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a125_val; /* data bits 4031..4000 */
} NX90_MTGY_OP_A125_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A125_BIT_T bf;
} NX90_MTGY_OP_A125_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a126 */
/* => MWMM operand A register 126 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a126  0x000019F8U
#define Adr_NX90_mtgy_mtgy_op_a126 0xFF0839F8U
#define Adr_NX90_mtgy_op_a126      0xFF0839F8U
#define DFLT_VAL_NX90_mtgy_op_a126 0x00000000U

#define MSK_NX90_mtgy_op_a126_val         0xffffffffU
#define SRT_NX90_mtgy_op_a126_val         0
#define DFLT_VAL_NX90_mtgy_op_a126_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a126_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a126': */
#define MSK_USED_BITS_NX90_mtgy_op_a126 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a126_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A126_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a126_val; /* data bits 4063..4032 */
} NX90_MTGY_OP_A126_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A126_BIT_T bf;
} NX90_MTGY_OP_A126_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_a127 */
/* => MWMM operand A register 127 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_a127  0x000019FCU
#define Adr_NX90_mtgy_mtgy_op_a127 0xFF0839FCU
#define Adr_NX90_mtgy_op_a127      0xFF0839FCU
#define DFLT_VAL_NX90_mtgy_op_a127 0x00000000U

#define MSK_NX90_mtgy_op_a127_val         0xffffffffU
#define SRT_NX90_mtgy_op_a127_val         0
#define DFLT_VAL_NX90_mtgy_op_a127_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_a127_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_a127': */
#define MSK_USED_BITS_NX90_mtgy_op_a127 0xffffffffU

enum {
  BFW_NX90_mtgy_op_a127_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_A127_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_a127_val; /* data bits 4095..4064 */
} NX90_MTGY_OP_A127_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_A127_BIT_T bf;
} NX90_MTGY_OP_A127_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e0 */
/* => MWMM operand E register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e0  0x00001A00U
#define Adr_NX90_mtgy_mtgy_op_e0 0xFF083A00U
#define Adr_NX90_mtgy_op_e0      0xFF083A00U
#define DFLT_VAL_NX90_mtgy_op_e0 0x00000000U

#define MSK_NX90_mtgy_op_e0_val         0xffffffffU
#define SRT_NX90_mtgy_op_e0_val         0
#define DFLT_VAL_NX90_mtgy_op_e0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e0_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e0': */
#define MSK_USED_BITS_NX90_mtgy_op_e0 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e0_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E0_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e0_val; /* data bits 31..0 */
} NX90_MTGY_OP_E0_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E0_BIT_T bf;
} NX90_MTGY_OP_E0_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e1 */
/* => MWMM operand E register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e1  0x00001A04U
#define Adr_NX90_mtgy_mtgy_op_e1 0xFF083A04U
#define Adr_NX90_mtgy_op_e1      0xFF083A04U
#define DFLT_VAL_NX90_mtgy_op_e1 0x00000000U

#define MSK_NX90_mtgy_op_e1_val         0xffffffffU
#define SRT_NX90_mtgy_op_e1_val         0
#define DFLT_VAL_NX90_mtgy_op_e1_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e1_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e1': */
#define MSK_USED_BITS_NX90_mtgy_op_e1 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e1_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E1_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e1_val; /* data bits 63..32 */
} NX90_MTGY_OP_E1_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E1_BIT_T bf;
} NX90_MTGY_OP_E1_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e2 */
/* => MWMM operand E register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e2  0x00001A08U
#define Adr_NX90_mtgy_mtgy_op_e2 0xFF083A08U
#define Adr_NX90_mtgy_op_e2      0xFF083A08U
#define DFLT_VAL_NX90_mtgy_op_e2 0x00000000U

#define MSK_NX90_mtgy_op_e2_val         0xffffffffU
#define SRT_NX90_mtgy_op_e2_val         0
#define DFLT_VAL_NX90_mtgy_op_e2_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e2_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e2': */
#define MSK_USED_BITS_NX90_mtgy_op_e2 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e2_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E2_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e2_val; /* data bits 95..64 */
} NX90_MTGY_OP_E2_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E2_BIT_T bf;
} NX90_MTGY_OP_E2_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e3 */
/* => MWMM operand E register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e3  0x00001A0CU
#define Adr_NX90_mtgy_mtgy_op_e3 0xFF083A0CU
#define Adr_NX90_mtgy_op_e3      0xFF083A0CU
#define DFLT_VAL_NX90_mtgy_op_e3 0x00000000U

#define MSK_NX90_mtgy_op_e3_val         0xffffffffU
#define SRT_NX90_mtgy_op_e3_val         0
#define DFLT_VAL_NX90_mtgy_op_e3_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e3_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e3': */
#define MSK_USED_BITS_NX90_mtgy_op_e3 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e3_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E3_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e3_val; /* data bits 127..96 */
} NX90_MTGY_OP_E3_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E3_BIT_T bf;
} NX90_MTGY_OP_E3_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e4 */
/* => MWMM operand E register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e4  0x00001A10U
#define Adr_NX90_mtgy_mtgy_op_e4 0xFF083A10U
#define Adr_NX90_mtgy_op_e4      0xFF083A10U
#define DFLT_VAL_NX90_mtgy_op_e4 0x00000000U

#define MSK_NX90_mtgy_op_e4_val         0xffffffffU
#define SRT_NX90_mtgy_op_e4_val         0
#define DFLT_VAL_NX90_mtgy_op_e4_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e4_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e4': */
#define MSK_USED_BITS_NX90_mtgy_op_e4 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e4_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E4_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e4_val; /* data bits 159..128 */
} NX90_MTGY_OP_E4_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E4_BIT_T bf;
} NX90_MTGY_OP_E4_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e5 */
/* => MWMM operand E register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e5  0x00001A14U
#define Adr_NX90_mtgy_mtgy_op_e5 0xFF083A14U
#define Adr_NX90_mtgy_op_e5      0xFF083A14U
#define DFLT_VAL_NX90_mtgy_op_e5 0x00000000U

#define MSK_NX90_mtgy_op_e5_val         0xffffffffU
#define SRT_NX90_mtgy_op_e5_val         0
#define DFLT_VAL_NX90_mtgy_op_e5_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e5_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e5': */
#define MSK_USED_BITS_NX90_mtgy_op_e5 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e5_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E5_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e5_val; /* data bits 191..160 */
} NX90_MTGY_OP_E5_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E5_BIT_T bf;
} NX90_MTGY_OP_E5_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e6 */
/* => MWMM operand E register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e6  0x00001A18U
#define Adr_NX90_mtgy_mtgy_op_e6 0xFF083A18U
#define Adr_NX90_mtgy_op_e6      0xFF083A18U
#define DFLT_VAL_NX90_mtgy_op_e6 0x00000000U

#define MSK_NX90_mtgy_op_e6_val         0xffffffffU
#define SRT_NX90_mtgy_op_e6_val         0
#define DFLT_VAL_NX90_mtgy_op_e6_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e6_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e6': */
#define MSK_USED_BITS_NX90_mtgy_op_e6 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e6_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E6_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e6_val; /* data bits 223..192 */
} NX90_MTGY_OP_E6_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E6_BIT_T bf;
} NX90_MTGY_OP_E6_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e7 */
/* => MWMM operand E register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e7  0x00001A1CU
#define Adr_NX90_mtgy_mtgy_op_e7 0xFF083A1CU
#define Adr_NX90_mtgy_op_e7      0xFF083A1CU
#define DFLT_VAL_NX90_mtgy_op_e7 0x00000000U

#define MSK_NX90_mtgy_op_e7_val         0xffffffffU
#define SRT_NX90_mtgy_op_e7_val         0
#define DFLT_VAL_NX90_mtgy_op_e7_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e7_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e7': */
#define MSK_USED_BITS_NX90_mtgy_op_e7 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e7_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E7_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e7_val; /* data bits 255..224 */
} NX90_MTGY_OP_E7_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E7_BIT_T bf;
} NX90_MTGY_OP_E7_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e8 */
/* => MWMM operand E register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e8  0x00001A20U
#define Adr_NX90_mtgy_mtgy_op_e8 0xFF083A20U
#define Adr_NX90_mtgy_op_e8      0xFF083A20U
#define DFLT_VAL_NX90_mtgy_op_e8 0x00000000U

#define MSK_NX90_mtgy_op_e8_val         0xffffffffU
#define SRT_NX90_mtgy_op_e8_val         0
#define DFLT_VAL_NX90_mtgy_op_e8_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e8_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e8': */
#define MSK_USED_BITS_NX90_mtgy_op_e8 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e8_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E8_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e8_val; /* data bits 287..256 */
} NX90_MTGY_OP_E8_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E8_BIT_T bf;
} NX90_MTGY_OP_E8_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e9 */
/* => MWMM operand E register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e9  0x00001A24U
#define Adr_NX90_mtgy_mtgy_op_e9 0xFF083A24U
#define Adr_NX90_mtgy_op_e9      0xFF083A24U
#define DFLT_VAL_NX90_mtgy_op_e9 0x00000000U

#define MSK_NX90_mtgy_op_e9_val         0xffffffffU
#define SRT_NX90_mtgy_op_e9_val         0
#define DFLT_VAL_NX90_mtgy_op_e9_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e9_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e9': */
#define MSK_USED_BITS_NX90_mtgy_op_e9 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e9_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E9_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e9_val; /* data bits 319..288 */
} NX90_MTGY_OP_E9_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_E9_BIT_T bf;
} NX90_MTGY_OP_E9_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e10 */
/* => MWMM operand E register 10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e10  0x00001A28U
#define Adr_NX90_mtgy_mtgy_op_e10 0xFF083A28U
#define Adr_NX90_mtgy_op_e10      0xFF083A28U
#define DFLT_VAL_NX90_mtgy_op_e10 0x00000000U

#define MSK_NX90_mtgy_op_e10_val         0xffffffffU
#define SRT_NX90_mtgy_op_e10_val         0
#define DFLT_VAL_NX90_mtgy_op_e10_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e10_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e10': */
#define MSK_USED_BITS_NX90_mtgy_op_e10 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e10_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E10_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e10_val; /* data bits 351..320 */
} NX90_MTGY_OP_E10_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E10_BIT_T bf;
} NX90_MTGY_OP_E10_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e11 */
/* => MWMM operand E register 11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e11  0x00001A2CU
#define Adr_NX90_mtgy_mtgy_op_e11 0xFF083A2CU
#define Adr_NX90_mtgy_op_e11      0xFF083A2CU
#define DFLT_VAL_NX90_mtgy_op_e11 0x00000000U

#define MSK_NX90_mtgy_op_e11_val         0xffffffffU
#define SRT_NX90_mtgy_op_e11_val         0
#define DFLT_VAL_NX90_mtgy_op_e11_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e11_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e11': */
#define MSK_USED_BITS_NX90_mtgy_op_e11 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e11_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E11_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e11_val; /* data bits 383..352 */
} NX90_MTGY_OP_E11_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E11_BIT_T bf;
} NX90_MTGY_OP_E11_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e12 */
/* => MWMM operand E register 12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e12  0x00001A30U
#define Adr_NX90_mtgy_mtgy_op_e12 0xFF083A30U
#define Adr_NX90_mtgy_op_e12      0xFF083A30U
#define DFLT_VAL_NX90_mtgy_op_e12 0x00000000U

#define MSK_NX90_mtgy_op_e12_val         0xffffffffU
#define SRT_NX90_mtgy_op_e12_val         0
#define DFLT_VAL_NX90_mtgy_op_e12_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e12_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e12': */
#define MSK_USED_BITS_NX90_mtgy_op_e12 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e12_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E12_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e12_val; /* data bits 415..384 */
} NX90_MTGY_OP_E12_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E12_BIT_T bf;
} NX90_MTGY_OP_E12_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e13 */
/* => MWMM operand E register 13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e13  0x00001A34U
#define Adr_NX90_mtgy_mtgy_op_e13 0xFF083A34U
#define Adr_NX90_mtgy_op_e13      0xFF083A34U
#define DFLT_VAL_NX90_mtgy_op_e13 0x00000000U

#define MSK_NX90_mtgy_op_e13_val         0xffffffffU
#define SRT_NX90_mtgy_op_e13_val         0
#define DFLT_VAL_NX90_mtgy_op_e13_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e13_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e13': */
#define MSK_USED_BITS_NX90_mtgy_op_e13 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e13_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E13_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e13_val; /* data bits 447..416 */
} NX90_MTGY_OP_E13_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E13_BIT_T bf;
} NX90_MTGY_OP_E13_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e14 */
/* => MWMM operand E register 14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e14  0x00001A38U
#define Adr_NX90_mtgy_mtgy_op_e14 0xFF083A38U
#define Adr_NX90_mtgy_op_e14      0xFF083A38U
#define DFLT_VAL_NX90_mtgy_op_e14 0x00000000U

#define MSK_NX90_mtgy_op_e14_val         0xffffffffU
#define SRT_NX90_mtgy_op_e14_val         0
#define DFLT_VAL_NX90_mtgy_op_e14_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e14_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e14': */
#define MSK_USED_BITS_NX90_mtgy_op_e14 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e14_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E14_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e14_val; /* data bits 479..448 */
} NX90_MTGY_OP_E14_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E14_BIT_T bf;
} NX90_MTGY_OP_E14_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e15 */
/* => MWMM operand E register 15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e15  0x00001A3CU
#define Adr_NX90_mtgy_mtgy_op_e15 0xFF083A3CU
#define Adr_NX90_mtgy_op_e15      0xFF083A3CU
#define DFLT_VAL_NX90_mtgy_op_e15 0x00000000U

#define MSK_NX90_mtgy_op_e15_val         0xffffffffU
#define SRT_NX90_mtgy_op_e15_val         0
#define DFLT_VAL_NX90_mtgy_op_e15_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e15_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e15': */
#define MSK_USED_BITS_NX90_mtgy_op_e15 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e15_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E15_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e15_val; /* data bits 511..480 */
} NX90_MTGY_OP_E15_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E15_BIT_T bf;
} NX90_MTGY_OP_E15_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e16 */
/* => MWMM operand E register 16 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e16  0x00001A40U
#define Adr_NX90_mtgy_mtgy_op_e16 0xFF083A40U
#define Adr_NX90_mtgy_op_e16      0xFF083A40U
#define DFLT_VAL_NX90_mtgy_op_e16 0x00000000U

#define MSK_NX90_mtgy_op_e16_val         0xffffffffU
#define SRT_NX90_mtgy_op_e16_val         0
#define DFLT_VAL_NX90_mtgy_op_e16_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e16_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e16': */
#define MSK_USED_BITS_NX90_mtgy_op_e16 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e16_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E16_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e16_val; /* data bits 543..512 */
} NX90_MTGY_OP_E16_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E16_BIT_T bf;
} NX90_MTGY_OP_E16_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e17 */
/* => MWMM operand E register 17 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e17  0x00001A44U
#define Adr_NX90_mtgy_mtgy_op_e17 0xFF083A44U
#define Adr_NX90_mtgy_op_e17      0xFF083A44U
#define DFLT_VAL_NX90_mtgy_op_e17 0x00000000U

#define MSK_NX90_mtgy_op_e17_val         0xffffffffU
#define SRT_NX90_mtgy_op_e17_val         0
#define DFLT_VAL_NX90_mtgy_op_e17_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e17_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e17': */
#define MSK_USED_BITS_NX90_mtgy_op_e17 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e17_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E17_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e17_val; /* data bits 575..544 */
} NX90_MTGY_OP_E17_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E17_BIT_T bf;
} NX90_MTGY_OP_E17_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e18 */
/* => MWMM operand E register 18 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e18  0x00001A48U
#define Adr_NX90_mtgy_mtgy_op_e18 0xFF083A48U
#define Adr_NX90_mtgy_op_e18      0xFF083A48U
#define DFLT_VAL_NX90_mtgy_op_e18 0x00000000U

#define MSK_NX90_mtgy_op_e18_val         0xffffffffU
#define SRT_NX90_mtgy_op_e18_val         0
#define DFLT_VAL_NX90_mtgy_op_e18_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e18_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e18': */
#define MSK_USED_BITS_NX90_mtgy_op_e18 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e18_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E18_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e18_val; /* data bits 607..576 */
} NX90_MTGY_OP_E18_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E18_BIT_T bf;
} NX90_MTGY_OP_E18_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e19 */
/* => MWMM operand E register 19 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e19  0x00001A4CU
#define Adr_NX90_mtgy_mtgy_op_e19 0xFF083A4CU
#define Adr_NX90_mtgy_op_e19      0xFF083A4CU
#define DFLT_VAL_NX90_mtgy_op_e19 0x00000000U

#define MSK_NX90_mtgy_op_e19_val         0xffffffffU
#define SRT_NX90_mtgy_op_e19_val         0
#define DFLT_VAL_NX90_mtgy_op_e19_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e19_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e19': */
#define MSK_USED_BITS_NX90_mtgy_op_e19 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e19_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E19_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e19_val; /* data bits 639..608 */
} NX90_MTGY_OP_E19_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E19_BIT_T bf;
} NX90_MTGY_OP_E19_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e20 */
/* => MWMM operand E register 20 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e20  0x00001A50U
#define Adr_NX90_mtgy_mtgy_op_e20 0xFF083A50U
#define Adr_NX90_mtgy_op_e20      0xFF083A50U
#define DFLT_VAL_NX90_mtgy_op_e20 0x00000000U

#define MSK_NX90_mtgy_op_e20_val         0xffffffffU
#define SRT_NX90_mtgy_op_e20_val         0
#define DFLT_VAL_NX90_mtgy_op_e20_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e20_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e20': */
#define MSK_USED_BITS_NX90_mtgy_op_e20 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e20_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E20_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e20_val; /* data bits 671..640 */
} NX90_MTGY_OP_E20_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E20_BIT_T bf;
} NX90_MTGY_OP_E20_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e21 */
/* => MWMM operand E register 21 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e21  0x00001A54U
#define Adr_NX90_mtgy_mtgy_op_e21 0xFF083A54U
#define Adr_NX90_mtgy_op_e21      0xFF083A54U
#define DFLT_VAL_NX90_mtgy_op_e21 0x00000000U

#define MSK_NX90_mtgy_op_e21_val         0xffffffffU
#define SRT_NX90_mtgy_op_e21_val         0
#define DFLT_VAL_NX90_mtgy_op_e21_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e21_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e21': */
#define MSK_USED_BITS_NX90_mtgy_op_e21 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e21_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E21_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e21_val; /* data bits 703..672 */
} NX90_MTGY_OP_E21_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E21_BIT_T bf;
} NX90_MTGY_OP_E21_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e22 */
/* => MWMM operand E register 22 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e22  0x00001A58U
#define Adr_NX90_mtgy_mtgy_op_e22 0xFF083A58U
#define Adr_NX90_mtgy_op_e22      0xFF083A58U
#define DFLT_VAL_NX90_mtgy_op_e22 0x00000000U

#define MSK_NX90_mtgy_op_e22_val         0xffffffffU
#define SRT_NX90_mtgy_op_e22_val         0
#define DFLT_VAL_NX90_mtgy_op_e22_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e22_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e22': */
#define MSK_USED_BITS_NX90_mtgy_op_e22 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e22_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E22_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e22_val; /* data bits 735..704 */
} NX90_MTGY_OP_E22_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E22_BIT_T bf;
} NX90_MTGY_OP_E22_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e23 */
/* => MWMM operand E register 23 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e23  0x00001A5CU
#define Adr_NX90_mtgy_mtgy_op_e23 0xFF083A5CU
#define Adr_NX90_mtgy_op_e23      0xFF083A5CU
#define DFLT_VAL_NX90_mtgy_op_e23 0x00000000U

#define MSK_NX90_mtgy_op_e23_val         0xffffffffU
#define SRT_NX90_mtgy_op_e23_val         0
#define DFLT_VAL_NX90_mtgy_op_e23_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e23_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e23': */
#define MSK_USED_BITS_NX90_mtgy_op_e23 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e23_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E23_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e23_val; /* data bits 767..736 */
} NX90_MTGY_OP_E23_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E23_BIT_T bf;
} NX90_MTGY_OP_E23_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e24 */
/* => MWMM operand E register 24 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e24  0x00001A60U
#define Adr_NX90_mtgy_mtgy_op_e24 0xFF083A60U
#define Adr_NX90_mtgy_op_e24      0xFF083A60U
#define DFLT_VAL_NX90_mtgy_op_e24 0x00000000U

#define MSK_NX90_mtgy_op_e24_val         0xffffffffU
#define SRT_NX90_mtgy_op_e24_val         0
#define DFLT_VAL_NX90_mtgy_op_e24_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e24_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e24': */
#define MSK_USED_BITS_NX90_mtgy_op_e24 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e24_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E24_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e24_val; /* data bits 799..768 */
} NX90_MTGY_OP_E24_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E24_BIT_T bf;
} NX90_MTGY_OP_E24_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e25 */
/* => MWMM operand E register 25 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e25  0x00001A64U
#define Adr_NX90_mtgy_mtgy_op_e25 0xFF083A64U
#define Adr_NX90_mtgy_op_e25      0xFF083A64U
#define DFLT_VAL_NX90_mtgy_op_e25 0x00000000U

#define MSK_NX90_mtgy_op_e25_val         0xffffffffU
#define SRT_NX90_mtgy_op_e25_val         0
#define DFLT_VAL_NX90_mtgy_op_e25_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e25_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e25': */
#define MSK_USED_BITS_NX90_mtgy_op_e25 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e25_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E25_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e25_val; /* data bits 831..800 */
} NX90_MTGY_OP_E25_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E25_BIT_T bf;
} NX90_MTGY_OP_E25_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e26 */
/* => MWMM operand E register 26 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e26  0x00001A68U
#define Adr_NX90_mtgy_mtgy_op_e26 0xFF083A68U
#define Adr_NX90_mtgy_op_e26      0xFF083A68U
#define DFLT_VAL_NX90_mtgy_op_e26 0x00000000U

#define MSK_NX90_mtgy_op_e26_val         0xffffffffU
#define SRT_NX90_mtgy_op_e26_val         0
#define DFLT_VAL_NX90_mtgy_op_e26_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e26_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e26': */
#define MSK_USED_BITS_NX90_mtgy_op_e26 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e26_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E26_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e26_val; /* data bits 863..832 */
} NX90_MTGY_OP_E26_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E26_BIT_T bf;
} NX90_MTGY_OP_E26_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e27 */
/* => MWMM operand E register 27 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e27  0x00001A6CU
#define Adr_NX90_mtgy_mtgy_op_e27 0xFF083A6CU
#define Adr_NX90_mtgy_op_e27      0xFF083A6CU
#define DFLT_VAL_NX90_mtgy_op_e27 0x00000000U

#define MSK_NX90_mtgy_op_e27_val         0xffffffffU
#define SRT_NX90_mtgy_op_e27_val         0
#define DFLT_VAL_NX90_mtgy_op_e27_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e27_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e27': */
#define MSK_USED_BITS_NX90_mtgy_op_e27 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e27_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E27_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e27_val; /* data bits 895..864 */
} NX90_MTGY_OP_E27_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E27_BIT_T bf;
} NX90_MTGY_OP_E27_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e28 */
/* => MWMM operand E register 28 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e28  0x00001A70U
#define Adr_NX90_mtgy_mtgy_op_e28 0xFF083A70U
#define Adr_NX90_mtgy_op_e28      0xFF083A70U
#define DFLT_VAL_NX90_mtgy_op_e28 0x00000000U

#define MSK_NX90_mtgy_op_e28_val         0xffffffffU
#define SRT_NX90_mtgy_op_e28_val         0
#define DFLT_VAL_NX90_mtgy_op_e28_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e28_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e28': */
#define MSK_USED_BITS_NX90_mtgy_op_e28 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e28_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E28_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e28_val; /* data bits 927..896 */
} NX90_MTGY_OP_E28_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E28_BIT_T bf;
} NX90_MTGY_OP_E28_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e29 */
/* => MWMM operand E register 29 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e29  0x00001A74U
#define Adr_NX90_mtgy_mtgy_op_e29 0xFF083A74U
#define Adr_NX90_mtgy_op_e29      0xFF083A74U
#define DFLT_VAL_NX90_mtgy_op_e29 0x00000000U

#define MSK_NX90_mtgy_op_e29_val         0xffffffffU
#define SRT_NX90_mtgy_op_e29_val         0
#define DFLT_VAL_NX90_mtgy_op_e29_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e29_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e29': */
#define MSK_USED_BITS_NX90_mtgy_op_e29 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e29_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E29_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e29_val; /* data bits 959..928 */
} NX90_MTGY_OP_E29_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E29_BIT_T bf;
} NX90_MTGY_OP_E29_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e30 */
/* => MWMM operand E register 30 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e30  0x00001A78U
#define Adr_NX90_mtgy_mtgy_op_e30 0xFF083A78U
#define Adr_NX90_mtgy_op_e30      0xFF083A78U
#define DFLT_VAL_NX90_mtgy_op_e30 0x00000000U

#define MSK_NX90_mtgy_op_e30_val         0xffffffffU
#define SRT_NX90_mtgy_op_e30_val         0
#define DFLT_VAL_NX90_mtgy_op_e30_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e30_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e30': */
#define MSK_USED_BITS_NX90_mtgy_op_e30 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e30_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E30_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e30_val; /* data bits 991..960 */
} NX90_MTGY_OP_E30_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E30_BIT_T bf;
} NX90_MTGY_OP_E30_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e31 */
/* => MWMM operand E register 31 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e31  0x00001A7CU
#define Adr_NX90_mtgy_mtgy_op_e31 0xFF083A7CU
#define Adr_NX90_mtgy_op_e31      0xFF083A7CU
#define DFLT_VAL_NX90_mtgy_op_e31 0x00000000U

#define MSK_NX90_mtgy_op_e31_val         0xffffffffU
#define SRT_NX90_mtgy_op_e31_val         0
#define DFLT_VAL_NX90_mtgy_op_e31_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e31_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e31': */
#define MSK_USED_BITS_NX90_mtgy_op_e31 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e31_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E31_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e31_val; /* data bits 1023..992 */
} NX90_MTGY_OP_E31_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E31_BIT_T bf;
} NX90_MTGY_OP_E31_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e32 */
/* => MWMM operand E register 32 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e32  0x00001A80U
#define Adr_NX90_mtgy_mtgy_op_e32 0xFF083A80U
#define Adr_NX90_mtgy_op_e32      0xFF083A80U
#define DFLT_VAL_NX90_mtgy_op_e32 0x00000000U

#define MSK_NX90_mtgy_op_e32_val         0xffffffffU
#define SRT_NX90_mtgy_op_e32_val         0
#define DFLT_VAL_NX90_mtgy_op_e32_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e32_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e32': */
#define MSK_USED_BITS_NX90_mtgy_op_e32 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e32_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E32_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e32_val; /* data bits 1055..1024 */
} NX90_MTGY_OP_E32_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E32_BIT_T bf;
} NX90_MTGY_OP_E32_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e33 */
/* => MWMM operand E register 33 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e33  0x00001A84U
#define Adr_NX90_mtgy_mtgy_op_e33 0xFF083A84U
#define Adr_NX90_mtgy_op_e33      0xFF083A84U
#define DFLT_VAL_NX90_mtgy_op_e33 0x00000000U

#define MSK_NX90_mtgy_op_e33_val         0xffffffffU
#define SRT_NX90_mtgy_op_e33_val         0
#define DFLT_VAL_NX90_mtgy_op_e33_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e33_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e33': */
#define MSK_USED_BITS_NX90_mtgy_op_e33 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e33_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E33_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e33_val; /* data bits 1087..1056 */
} NX90_MTGY_OP_E33_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E33_BIT_T bf;
} NX90_MTGY_OP_E33_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e34 */
/* => MWMM operand E register 34 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e34  0x00001A88U
#define Adr_NX90_mtgy_mtgy_op_e34 0xFF083A88U
#define Adr_NX90_mtgy_op_e34      0xFF083A88U
#define DFLT_VAL_NX90_mtgy_op_e34 0x00000000U

#define MSK_NX90_mtgy_op_e34_val         0xffffffffU
#define SRT_NX90_mtgy_op_e34_val         0
#define DFLT_VAL_NX90_mtgy_op_e34_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e34_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e34': */
#define MSK_USED_BITS_NX90_mtgy_op_e34 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e34_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E34_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e34_val; /* data bits 1119..1088 */
} NX90_MTGY_OP_E34_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E34_BIT_T bf;
} NX90_MTGY_OP_E34_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e35 */
/* => MWMM operand E register 35 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e35  0x00001A8CU
#define Adr_NX90_mtgy_mtgy_op_e35 0xFF083A8CU
#define Adr_NX90_mtgy_op_e35      0xFF083A8CU
#define DFLT_VAL_NX90_mtgy_op_e35 0x00000000U

#define MSK_NX90_mtgy_op_e35_val         0xffffffffU
#define SRT_NX90_mtgy_op_e35_val         0
#define DFLT_VAL_NX90_mtgy_op_e35_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e35_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e35': */
#define MSK_USED_BITS_NX90_mtgy_op_e35 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e35_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E35_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e35_val; /* data bits 1151..1120 */
} NX90_MTGY_OP_E35_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E35_BIT_T bf;
} NX90_MTGY_OP_E35_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e36 */
/* => MWMM operand E register 36 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e36  0x00001A90U
#define Adr_NX90_mtgy_mtgy_op_e36 0xFF083A90U
#define Adr_NX90_mtgy_op_e36      0xFF083A90U
#define DFLT_VAL_NX90_mtgy_op_e36 0x00000000U

#define MSK_NX90_mtgy_op_e36_val         0xffffffffU
#define SRT_NX90_mtgy_op_e36_val         0
#define DFLT_VAL_NX90_mtgy_op_e36_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e36_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e36': */
#define MSK_USED_BITS_NX90_mtgy_op_e36 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e36_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E36_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e36_val; /* data bits 1183..1152 */
} NX90_MTGY_OP_E36_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E36_BIT_T bf;
} NX90_MTGY_OP_E36_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e37 */
/* => MWMM operand E register 37 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e37  0x00001A94U
#define Adr_NX90_mtgy_mtgy_op_e37 0xFF083A94U
#define Adr_NX90_mtgy_op_e37      0xFF083A94U
#define DFLT_VAL_NX90_mtgy_op_e37 0x00000000U

#define MSK_NX90_mtgy_op_e37_val         0xffffffffU
#define SRT_NX90_mtgy_op_e37_val         0
#define DFLT_VAL_NX90_mtgy_op_e37_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e37_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e37': */
#define MSK_USED_BITS_NX90_mtgy_op_e37 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e37_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E37_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e37_val; /* data bits 1215..1184 */
} NX90_MTGY_OP_E37_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E37_BIT_T bf;
} NX90_MTGY_OP_E37_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e38 */
/* => MWMM operand E register 38 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e38  0x00001A98U
#define Adr_NX90_mtgy_mtgy_op_e38 0xFF083A98U
#define Adr_NX90_mtgy_op_e38      0xFF083A98U
#define DFLT_VAL_NX90_mtgy_op_e38 0x00000000U

#define MSK_NX90_mtgy_op_e38_val         0xffffffffU
#define SRT_NX90_mtgy_op_e38_val         0
#define DFLT_VAL_NX90_mtgy_op_e38_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e38_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e38': */
#define MSK_USED_BITS_NX90_mtgy_op_e38 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e38_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E38_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e38_val; /* data bits 1247..1216 */
} NX90_MTGY_OP_E38_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E38_BIT_T bf;
} NX90_MTGY_OP_E38_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e39 */
/* => MWMM operand E register 39 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e39  0x00001A9CU
#define Adr_NX90_mtgy_mtgy_op_e39 0xFF083A9CU
#define Adr_NX90_mtgy_op_e39      0xFF083A9CU
#define DFLT_VAL_NX90_mtgy_op_e39 0x00000000U

#define MSK_NX90_mtgy_op_e39_val         0xffffffffU
#define SRT_NX90_mtgy_op_e39_val         0
#define DFLT_VAL_NX90_mtgy_op_e39_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e39_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e39': */
#define MSK_USED_BITS_NX90_mtgy_op_e39 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e39_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E39_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e39_val; /* data bits 1279..1248 */
} NX90_MTGY_OP_E39_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E39_BIT_T bf;
} NX90_MTGY_OP_E39_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e40 */
/* => MWMM operand E register 40 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e40  0x00001AA0U
#define Adr_NX90_mtgy_mtgy_op_e40 0xFF083AA0U
#define Adr_NX90_mtgy_op_e40      0xFF083AA0U
#define DFLT_VAL_NX90_mtgy_op_e40 0x00000000U

#define MSK_NX90_mtgy_op_e40_val         0xffffffffU
#define SRT_NX90_mtgy_op_e40_val         0
#define DFLT_VAL_NX90_mtgy_op_e40_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e40_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e40': */
#define MSK_USED_BITS_NX90_mtgy_op_e40 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e40_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E40_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e40_val; /* data bits 1311..1280 */
} NX90_MTGY_OP_E40_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E40_BIT_T bf;
} NX90_MTGY_OP_E40_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e41 */
/* => MWMM operand E register 41 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e41  0x00001AA4U
#define Adr_NX90_mtgy_mtgy_op_e41 0xFF083AA4U
#define Adr_NX90_mtgy_op_e41      0xFF083AA4U
#define DFLT_VAL_NX90_mtgy_op_e41 0x00000000U

#define MSK_NX90_mtgy_op_e41_val         0xffffffffU
#define SRT_NX90_mtgy_op_e41_val         0
#define DFLT_VAL_NX90_mtgy_op_e41_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e41_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e41': */
#define MSK_USED_BITS_NX90_mtgy_op_e41 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e41_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E41_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e41_val; /* data bits 1343..1312 */
} NX90_MTGY_OP_E41_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E41_BIT_T bf;
} NX90_MTGY_OP_E41_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e42 */
/* => MWMM operand E register 42 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e42  0x00001AA8U
#define Adr_NX90_mtgy_mtgy_op_e42 0xFF083AA8U
#define Adr_NX90_mtgy_op_e42      0xFF083AA8U
#define DFLT_VAL_NX90_mtgy_op_e42 0x00000000U

#define MSK_NX90_mtgy_op_e42_val         0xffffffffU
#define SRT_NX90_mtgy_op_e42_val         0
#define DFLT_VAL_NX90_mtgy_op_e42_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e42_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e42': */
#define MSK_USED_BITS_NX90_mtgy_op_e42 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e42_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E42_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e42_val; /* data bits 1375..1344 */
} NX90_MTGY_OP_E42_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E42_BIT_T bf;
} NX90_MTGY_OP_E42_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e43 */
/* => MWMM operand E register 43 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e43  0x00001AACU
#define Adr_NX90_mtgy_mtgy_op_e43 0xFF083AACU
#define Adr_NX90_mtgy_op_e43      0xFF083AACU
#define DFLT_VAL_NX90_mtgy_op_e43 0x00000000U

#define MSK_NX90_mtgy_op_e43_val         0xffffffffU
#define SRT_NX90_mtgy_op_e43_val         0
#define DFLT_VAL_NX90_mtgy_op_e43_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e43_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e43': */
#define MSK_USED_BITS_NX90_mtgy_op_e43 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e43_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E43_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e43_val; /* data bits 1407..1376 */
} NX90_MTGY_OP_E43_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E43_BIT_T bf;
} NX90_MTGY_OP_E43_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e44 */
/* => MWMM operand E register 44 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e44  0x00001AB0U
#define Adr_NX90_mtgy_mtgy_op_e44 0xFF083AB0U
#define Adr_NX90_mtgy_op_e44      0xFF083AB0U
#define DFLT_VAL_NX90_mtgy_op_e44 0x00000000U

#define MSK_NX90_mtgy_op_e44_val         0xffffffffU
#define SRT_NX90_mtgy_op_e44_val         0
#define DFLT_VAL_NX90_mtgy_op_e44_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e44_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e44': */
#define MSK_USED_BITS_NX90_mtgy_op_e44 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e44_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E44_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e44_val; /* data bits 1439..1408 */
} NX90_MTGY_OP_E44_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E44_BIT_T bf;
} NX90_MTGY_OP_E44_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e45 */
/* => MWMM operand E register 45 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e45  0x00001AB4U
#define Adr_NX90_mtgy_mtgy_op_e45 0xFF083AB4U
#define Adr_NX90_mtgy_op_e45      0xFF083AB4U
#define DFLT_VAL_NX90_mtgy_op_e45 0x00000000U

#define MSK_NX90_mtgy_op_e45_val         0xffffffffU
#define SRT_NX90_mtgy_op_e45_val         0
#define DFLT_VAL_NX90_mtgy_op_e45_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e45_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e45': */
#define MSK_USED_BITS_NX90_mtgy_op_e45 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e45_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E45_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e45_val; /* data bits 1471..1440 */
} NX90_MTGY_OP_E45_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E45_BIT_T bf;
} NX90_MTGY_OP_E45_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e46 */
/* => MWMM operand E register 46 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e46  0x00001AB8U
#define Adr_NX90_mtgy_mtgy_op_e46 0xFF083AB8U
#define Adr_NX90_mtgy_op_e46      0xFF083AB8U
#define DFLT_VAL_NX90_mtgy_op_e46 0x00000000U

#define MSK_NX90_mtgy_op_e46_val         0xffffffffU
#define SRT_NX90_mtgy_op_e46_val         0
#define DFLT_VAL_NX90_mtgy_op_e46_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e46_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e46': */
#define MSK_USED_BITS_NX90_mtgy_op_e46 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e46_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E46_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e46_val; /* data bits 1503..1472 */
} NX90_MTGY_OP_E46_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E46_BIT_T bf;
} NX90_MTGY_OP_E46_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e47 */
/* => MWMM operand E register 47 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e47  0x00001ABCU
#define Adr_NX90_mtgy_mtgy_op_e47 0xFF083ABCU
#define Adr_NX90_mtgy_op_e47      0xFF083ABCU
#define DFLT_VAL_NX90_mtgy_op_e47 0x00000000U

#define MSK_NX90_mtgy_op_e47_val         0xffffffffU
#define SRT_NX90_mtgy_op_e47_val         0
#define DFLT_VAL_NX90_mtgy_op_e47_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e47_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e47': */
#define MSK_USED_BITS_NX90_mtgy_op_e47 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e47_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E47_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e47_val; /* data bits 1535..1504 */
} NX90_MTGY_OP_E47_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E47_BIT_T bf;
} NX90_MTGY_OP_E47_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e48 */
/* => MWMM operand E register 48 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e48  0x00001AC0U
#define Adr_NX90_mtgy_mtgy_op_e48 0xFF083AC0U
#define Adr_NX90_mtgy_op_e48      0xFF083AC0U
#define DFLT_VAL_NX90_mtgy_op_e48 0x00000000U

#define MSK_NX90_mtgy_op_e48_val         0xffffffffU
#define SRT_NX90_mtgy_op_e48_val         0
#define DFLT_VAL_NX90_mtgy_op_e48_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e48_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e48': */
#define MSK_USED_BITS_NX90_mtgy_op_e48 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e48_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E48_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e48_val; /* data bits 1567..1536 */
} NX90_MTGY_OP_E48_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E48_BIT_T bf;
} NX90_MTGY_OP_E48_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e49 */
/* => MWMM operand E register 49 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e49  0x00001AC4U
#define Adr_NX90_mtgy_mtgy_op_e49 0xFF083AC4U
#define Adr_NX90_mtgy_op_e49      0xFF083AC4U
#define DFLT_VAL_NX90_mtgy_op_e49 0x00000000U

#define MSK_NX90_mtgy_op_e49_val         0xffffffffU
#define SRT_NX90_mtgy_op_e49_val         0
#define DFLT_VAL_NX90_mtgy_op_e49_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e49_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e49': */
#define MSK_USED_BITS_NX90_mtgy_op_e49 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e49_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E49_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e49_val; /* data bits 1599..1568 */
} NX90_MTGY_OP_E49_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E49_BIT_T bf;
} NX90_MTGY_OP_E49_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e50 */
/* => MWMM operand E register 50 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e50  0x00001AC8U
#define Adr_NX90_mtgy_mtgy_op_e50 0xFF083AC8U
#define Adr_NX90_mtgy_op_e50      0xFF083AC8U
#define DFLT_VAL_NX90_mtgy_op_e50 0x00000000U

#define MSK_NX90_mtgy_op_e50_val         0xffffffffU
#define SRT_NX90_mtgy_op_e50_val         0
#define DFLT_VAL_NX90_mtgy_op_e50_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e50_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e50': */
#define MSK_USED_BITS_NX90_mtgy_op_e50 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e50_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E50_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e50_val; /* data bits 1631..1600 */
} NX90_MTGY_OP_E50_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E50_BIT_T bf;
} NX90_MTGY_OP_E50_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e51 */
/* => MWMM operand E register 51 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e51  0x00001ACCU
#define Adr_NX90_mtgy_mtgy_op_e51 0xFF083ACCU
#define Adr_NX90_mtgy_op_e51      0xFF083ACCU
#define DFLT_VAL_NX90_mtgy_op_e51 0x00000000U

#define MSK_NX90_mtgy_op_e51_val         0xffffffffU
#define SRT_NX90_mtgy_op_e51_val         0
#define DFLT_VAL_NX90_mtgy_op_e51_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e51_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e51': */
#define MSK_USED_BITS_NX90_mtgy_op_e51 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e51_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E51_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e51_val; /* data bits 1663..1632 */
} NX90_MTGY_OP_E51_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E51_BIT_T bf;
} NX90_MTGY_OP_E51_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e52 */
/* => MWMM operand E register 52 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e52  0x00001AD0U
#define Adr_NX90_mtgy_mtgy_op_e52 0xFF083AD0U
#define Adr_NX90_mtgy_op_e52      0xFF083AD0U
#define DFLT_VAL_NX90_mtgy_op_e52 0x00000000U

#define MSK_NX90_mtgy_op_e52_val         0xffffffffU
#define SRT_NX90_mtgy_op_e52_val         0
#define DFLT_VAL_NX90_mtgy_op_e52_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e52_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e52': */
#define MSK_USED_BITS_NX90_mtgy_op_e52 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e52_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E52_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e52_val; /* data bits 1695..1664 */
} NX90_MTGY_OP_E52_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E52_BIT_T bf;
} NX90_MTGY_OP_E52_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e53 */
/* => MWMM operand E register 53 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e53  0x00001AD4U
#define Adr_NX90_mtgy_mtgy_op_e53 0xFF083AD4U
#define Adr_NX90_mtgy_op_e53      0xFF083AD4U
#define DFLT_VAL_NX90_mtgy_op_e53 0x00000000U

#define MSK_NX90_mtgy_op_e53_val         0xffffffffU
#define SRT_NX90_mtgy_op_e53_val         0
#define DFLT_VAL_NX90_mtgy_op_e53_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e53_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e53': */
#define MSK_USED_BITS_NX90_mtgy_op_e53 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e53_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E53_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e53_val; /* data bits 1727..1696 */
} NX90_MTGY_OP_E53_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E53_BIT_T bf;
} NX90_MTGY_OP_E53_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e54 */
/* => MWMM operand E register 54 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e54  0x00001AD8U
#define Adr_NX90_mtgy_mtgy_op_e54 0xFF083AD8U
#define Adr_NX90_mtgy_op_e54      0xFF083AD8U
#define DFLT_VAL_NX90_mtgy_op_e54 0x00000000U

#define MSK_NX90_mtgy_op_e54_val         0xffffffffU
#define SRT_NX90_mtgy_op_e54_val         0
#define DFLT_VAL_NX90_mtgy_op_e54_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e54_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e54': */
#define MSK_USED_BITS_NX90_mtgy_op_e54 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e54_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E54_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e54_val; /* data bits 1759..1728 */
} NX90_MTGY_OP_E54_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E54_BIT_T bf;
} NX90_MTGY_OP_E54_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e55 */
/* => MWMM operand E register 55 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e55  0x00001ADCU
#define Adr_NX90_mtgy_mtgy_op_e55 0xFF083ADCU
#define Adr_NX90_mtgy_op_e55      0xFF083ADCU
#define DFLT_VAL_NX90_mtgy_op_e55 0x00000000U

#define MSK_NX90_mtgy_op_e55_val         0xffffffffU
#define SRT_NX90_mtgy_op_e55_val         0
#define DFLT_VAL_NX90_mtgy_op_e55_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e55_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e55': */
#define MSK_USED_BITS_NX90_mtgy_op_e55 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e55_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E55_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e55_val; /* data bits 1791..1760 */
} NX90_MTGY_OP_E55_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E55_BIT_T bf;
} NX90_MTGY_OP_E55_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e56 */
/* => MWMM operand E register 56 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e56  0x00001AE0U
#define Adr_NX90_mtgy_mtgy_op_e56 0xFF083AE0U
#define Adr_NX90_mtgy_op_e56      0xFF083AE0U
#define DFLT_VAL_NX90_mtgy_op_e56 0x00000000U

#define MSK_NX90_mtgy_op_e56_val         0xffffffffU
#define SRT_NX90_mtgy_op_e56_val         0
#define DFLT_VAL_NX90_mtgy_op_e56_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e56_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e56': */
#define MSK_USED_BITS_NX90_mtgy_op_e56 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e56_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E56_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e56_val; /* data bits 1823..1792 */
} NX90_MTGY_OP_E56_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E56_BIT_T bf;
} NX90_MTGY_OP_E56_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e57 */
/* => MWMM operand E register 57 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e57  0x00001AE4U
#define Adr_NX90_mtgy_mtgy_op_e57 0xFF083AE4U
#define Adr_NX90_mtgy_op_e57      0xFF083AE4U
#define DFLT_VAL_NX90_mtgy_op_e57 0x00000000U

#define MSK_NX90_mtgy_op_e57_val         0xffffffffU
#define SRT_NX90_mtgy_op_e57_val         0
#define DFLT_VAL_NX90_mtgy_op_e57_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e57_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e57': */
#define MSK_USED_BITS_NX90_mtgy_op_e57 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e57_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E57_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e57_val; /* data bits 1855..1824 */
} NX90_MTGY_OP_E57_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E57_BIT_T bf;
} NX90_MTGY_OP_E57_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e58 */
/* => MWMM operand E register 58 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e58  0x00001AE8U
#define Adr_NX90_mtgy_mtgy_op_e58 0xFF083AE8U
#define Adr_NX90_mtgy_op_e58      0xFF083AE8U
#define DFLT_VAL_NX90_mtgy_op_e58 0x00000000U

#define MSK_NX90_mtgy_op_e58_val         0xffffffffU
#define SRT_NX90_mtgy_op_e58_val         0
#define DFLT_VAL_NX90_mtgy_op_e58_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e58_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e58': */
#define MSK_USED_BITS_NX90_mtgy_op_e58 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e58_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E58_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e58_val; /* data bits 1887..1856 */
} NX90_MTGY_OP_E58_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E58_BIT_T bf;
} NX90_MTGY_OP_E58_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e59 */
/* => MWMM operand E register 59 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e59  0x00001AECU
#define Adr_NX90_mtgy_mtgy_op_e59 0xFF083AECU
#define Adr_NX90_mtgy_op_e59      0xFF083AECU
#define DFLT_VAL_NX90_mtgy_op_e59 0x00000000U

#define MSK_NX90_mtgy_op_e59_val         0xffffffffU
#define SRT_NX90_mtgy_op_e59_val         0
#define DFLT_VAL_NX90_mtgy_op_e59_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e59_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e59': */
#define MSK_USED_BITS_NX90_mtgy_op_e59 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e59_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E59_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e59_val; /* data bits 1919..1888 */
} NX90_MTGY_OP_E59_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E59_BIT_T bf;
} NX90_MTGY_OP_E59_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e60 */
/* => MWMM operand E register 60 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e60  0x00001AF0U
#define Adr_NX90_mtgy_mtgy_op_e60 0xFF083AF0U
#define Adr_NX90_mtgy_op_e60      0xFF083AF0U
#define DFLT_VAL_NX90_mtgy_op_e60 0x00000000U

#define MSK_NX90_mtgy_op_e60_val         0xffffffffU
#define SRT_NX90_mtgy_op_e60_val         0
#define DFLT_VAL_NX90_mtgy_op_e60_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e60_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e60': */
#define MSK_USED_BITS_NX90_mtgy_op_e60 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e60_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E60_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e60_val; /* data bits 1951..1920 */
} NX90_MTGY_OP_E60_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E60_BIT_T bf;
} NX90_MTGY_OP_E60_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e61 */
/* => MWMM operand E register 61 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e61  0x00001AF4U
#define Adr_NX90_mtgy_mtgy_op_e61 0xFF083AF4U
#define Adr_NX90_mtgy_op_e61      0xFF083AF4U
#define DFLT_VAL_NX90_mtgy_op_e61 0x00000000U

#define MSK_NX90_mtgy_op_e61_val         0xffffffffU
#define SRT_NX90_mtgy_op_e61_val         0
#define DFLT_VAL_NX90_mtgy_op_e61_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e61_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e61': */
#define MSK_USED_BITS_NX90_mtgy_op_e61 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e61_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E61_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e61_val; /* data bits 1983..1952 */
} NX90_MTGY_OP_E61_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E61_BIT_T bf;
} NX90_MTGY_OP_E61_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e62 */
/* => MWMM operand E register 62 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e62  0x00001AF8U
#define Adr_NX90_mtgy_mtgy_op_e62 0xFF083AF8U
#define Adr_NX90_mtgy_op_e62      0xFF083AF8U
#define DFLT_VAL_NX90_mtgy_op_e62 0x00000000U

#define MSK_NX90_mtgy_op_e62_val         0xffffffffU
#define SRT_NX90_mtgy_op_e62_val         0
#define DFLT_VAL_NX90_mtgy_op_e62_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e62_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e62': */
#define MSK_USED_BITS_NX90_mtgy_op_e62 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e62_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E62_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e62_val; /* data bits 2015..1984 */
} NX90_MTGY_OP_E62_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E62_BIT_T bf;
} NX90_MTGY_OP_E62_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e63 */
/* => MWMM operand E register 63 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e63  0x00001AFCU
#define Adr_NX90_mtgy_mtgy_op_e63 0xFF083AFCU
#define Adr_NX90_mtgy_op_e63      0xFF083AFCU
#define DFLT_VAL_NX90_mtgy_op_e63 0x00000000U

#define MSK_NX90_mtgy_op_e63_val         0xffffffffU
#define SRT_NX90_mtgy_op_e63_val         0
#define DFLT_VAL_NX90_mtgy_op_e63_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e63_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e63': */
#define MSK_USED_BITS_NX90_mtgy_op_e63 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e63_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E63_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e63_val; /* data bits 2047..2016 */
} NX90_MTGY_OP_E63_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E63_BIT_T bf;
} NX90_MTGY_OP_E63_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e64 */
/* => MWMM operand E register 64 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e64  0x00001B00U
#define Adr_NX90_mtgy_mtgy_op_e64 0xFF083B00U
#define Adr_NX90_mtgy_op_e64      0xFF083B00U
#define DFLT_VAL_NX90_mtgy_op_e64 0x00000000U

#define MSK_NX90_mtgy_op_e64_val         0xffffffffU
#define SRT_NX90_mtgy_op_e64_val         0
#define DFLT_VAL_NX90_mtgy_op_e64_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e64_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e64': */
#define MSK_USED_BITS_NX90_mtgy_op_e64 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e64_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E64_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e64_val; /* data bits 2079..2048 */
} NX90_MTGY_OP_E64_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E64_BIT_T bf;
} NX90_MTGY_OP_E64_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e65 */
/* => MWMM operand E register 65 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e65  0x00001B04U
#define Adr_NX90_mtgy_mtgy_op_e65 0xFF083B04U
#define Adr_NX90_mtgy_op_e65      0xFF083B04U
#define DFLT_VAL_NX90_mtgy_op_e65 0x00000000U

#define MSK_NX90_mtgy_op_e65_val         0xffffffffU
#define SRT_NX90_mtgy_op_e65_val         0
#define DFLT_VAL_NX90_mtgy_op_e65_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e65_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e65': */
#define MSK_USED_BITS_NX90_mtgy_op_e65 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e65_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E65_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e65_val; /* data bits 2111..2080 */
} NX90_MTGY_OP_E65_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E65_BIT_T bf;
} NX90_MTGY_OP_E65_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e66 */
/* => MWMM operand E register 66 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e66  0x00001B08U
#define Adr_NX90_mtgy_mtgy_op_e66 0xFF083B08U
#define Adr_NX90_mtgy_op_e66      0xFF083B08U
#define DFLT_VAL_NX90_mtgy_op_e66 0x00000000U

#define MSK_NX90_mtgy_op_e66_val         0xffffffffU
#define SRT_NX90_mtgy_op_e66_val         0
#define DFLT_VAL_NX90_mtgy_op_e66_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e66_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e66': */
#define MSK_USED_BITS_NX90_mtgy_op_e66 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e66_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E66_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e66_val; /* data bits 2143..2112 */
} NX90_MTGY_OP_E66_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E66_BIT_T bf;
} NX90_MTGY_OP_E66_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e67 */
/* => MWMM operand E register 67 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e67  0x00001B0CU
#define Adr_NX90_mtgy_mtgy_op_e67 0xFF083B0CU
#define Adr_NX90_mtgy_op_e67      0xFF083B0CU
#define DFLT_VAL_NX90_mtgy_op_e67 0x00000000U

#define MSK_NX90_mtgy_op_e67_val         0xffffffffU
#define SRT_NX90_mtgy_op_e67_val         0
#define DFLT_VAL_NX90_mtgy_op_e67_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e67_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e67': */
#define MSK_USED_BITS_NX90_mtgy_op_e67 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e67_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E67_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e67_val; /* data bits 2175..2144 */
} NX90_MTGY_OP_E67_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E67_BIT_T bf;
} NX90_MTGY_OP_E67_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e68 */
/* => MWMM operand E register 68 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e68  0x00001B10U
#define Adr_NX90_mtgy_mtgy_op_e68 0xFF083B10U
#define Adr_NX90_mtgy_op_e68      0xFF083B10U
#define DFLT_VAL_NX90_mtgy_op_e68 0x00000000U

#define MSK_NX90_mtgy_op_e68_val         0xffffffffU
#define SRT_NX90_mtgy_op_e68_val         0
#define DFLT_VAL_NX90_mtgy_op_e68_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e68_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e68': */
#define MSK_USED_BITS_NX90_mtgy_op_e68 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e68_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E68_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e68_val; /* data bits 2207..2176 */
} NX90_MTGY_OP_E68_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E68_BIT_T bf;
} NX90_MTGY_OP_E68_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e69 */
/* => MWMM operand E register 69 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e69  0x00001B14U
#define Adr_NX90_mtgy_mtgy_op_e69 0xFF083B14U
#define Adr_NX90_mtgy_op_e69      0xFF083B14U
#define DFLT_VAL_NX90_mtgy_op_e69 0x00000000U

#define MSK_NX90_mtgy_op_e69_val         0xffffffffU
#define SRT_NX90_mtgy_op_e69_val         0
#define DFLT_VAL_NX90_mtgy_op_e69_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e69_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e69': */
#define MSK_USED_BITS_NX90_mtgy_op_e69 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e69_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E69_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e69_val; /* data bits 2239..2208 */
} NX90_MTGY_OP_E69_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E69_BIT_T bf;
} NX90_MTGY_OP_E69_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e70 */
/* => MWMM operand E register 70 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e70  0x00001B18U
#define Adr_NX90_mtgy_mtgy_op_e70 0xFF083B18U
#define Adr_NX90_mtgy_op_e70      0xFF083B18U
#define DFLT_VAL_NX90_mtgy_op_e70 0x00000000U

#define MSK_NX90_mtgy_op_e70_val         0xffffffffU
#define SRT_NX90_mtgy_op_e70_val         0
#define DFLT_VAL_NX90_mtgy_op_e70_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e70_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e70': */
#define MSK_USED_BITS_NX90_mtgy_op_e70 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e70_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E70_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e70_val; /* data bits 2271..2240 */
} NX90_MTGY_OP_E70_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E70_BIT_T bf;
} NX90_MTGY_OP_E70_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e71 */
/* => MWMM operand E register 71 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e71  0x00001B1CU
#define Adr_NX90_mtgy_mtgy_op_e71 0xFF083B1CU
#define Adr_NX90_mtgy_op_e71      0xFF083B1CU
#define DFLT_VAL_NX90_mtgy_op_e71 0x00000000U

#define MSK_NX90_mtgy_op_e71_val         0xffffffffU
#define SRT_NX90_mtgy_op_e71_val         0
#define DFLT_VAL_NX90_mtgy_op_e71_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e71_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e71': */
#define MSK_USED_BITS_NX90_mtgy_op_e71 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e71_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E71_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e71_val; /* data bits 2303..2272 */
} NX90_MTGY_OP_E71_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E71_BIT_T bf;
} NX90_MTGY_OP_E71_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e72 */
/* => MWMM operand E register 72 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e72  0x00001B20U
#define Adr_NX90_mtgy_mtgy_op_e72 0xFF083B20U
#define Adr_NX90_mtgy_op_e72      0xFF083B20U
#define DFLT_VAL_NX90_mtgy_op_e72 0x00000000U

#define MSK_NX90_mtgy_op_e72_val         0xffffffffU
#define SRT_NX90_mtgy_op_e72_val         0
#define DFLT_VAL_NX90_mtgy_op_e72_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e72_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e72': */
#define MSK_USED_BITS_NX90_mtgy_op_e72 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e72_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E72_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e72_val; /* data bits 2335..2304 */
} NX90_MTGY_OP_E72_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E72_BIT_T bf;
} NX90_MTGY_OP_E72_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e73 */
/* => MWMM operand E register 73 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e73  0x00001B24U
#define Adr_NX90_mtgy_mtgy_op_e73 0xFF083B24U
#define Adr_NX90_mtgy_op_e73      0xFF083B24U
#define DFLT_VAL_NX90_mtgy_op_e73 0x00000000U

#define MSK_NX90_mtgy_op_e73_val         0xffffffffU
#define SRT_NX90_mtgy_op_e73_val         0
#define DFLT_VAL_NX90_mtgy_op_e73_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e73_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e73': */
#define MSK_USED_BITS_NX90_mtgy_op_e73 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e73_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E73_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e73_val; /* data bits 2367..2336 */
} NX90_MTGY_OP_E73_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E73_BIT_T bf;
} NX90_MTGY_OP_E73_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e74 */
/* => MWMM operand E register 74 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e74  0x00001B28U
#define Adr_NX90_mtgy_mtgy_op_e74 0xFF083B28U
#define Adr_NX90_mtgy_op_e74      0xFF083B28U
#define DFLT_VAL_NX90_mtgy_op_e74 0x00000000U

#define MSK_NX90_mtgy_op_e74_val         0xffffffffU
#define SRT_NX90_mtgy_op_e74_val         0
#define DFLT_VAL_NX90_mtgy_op_e74_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e74_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e74': */
#define MSK_USED_BITS_NX90_mtgy_op_e74 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e74_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E74_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e74_val; /* data bits 2399..2368 */
} NX90_MTGY_OP_E74_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E74_BIT_T bf;
} NX90_MTGY_OP_E74_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e75 */
/* => MWMM operand E register 75 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e75  0x00001B2CU
#define Adr_NX90_mtgy_mtgy_op_e75 0xFF083B2CU
#define Adr_NX90_mtgy_op_e75      0xFF083B2CU
#define DFLT_VAL_NX90_mtgy_op_e75 0x00000000U

#define MSK_NX90_mtgy_op_e75_val         0xffffffffU
#define SRT_NX90_mtgy_op_e75_val         0
#define DFLT_VAL_NX90_mtgy_op_e75_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e75_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e75': */
#define MSK_USED_BITS_NX90_mtgy_op_e75 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e75_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E75_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e75_val; /* data bits 2431..2400 */
} NX90_MTGY_OP_E75_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E75_BIT_T bf;
} NX90_MTGY_OP_E75_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e76 */
/* => MWMM operand E register 76 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e76  0x00001B30U
#define Adr_NX90_mtgy_mtgy_op_e76 0xFF083B30U
#define Adr_NX90_mtgy_op_e76      0xFF083B30U
#define DFLT_VAL_NX90_mtgy_op_e76 0x00000000U

#define MSK_NX90_mtgy_op_e76_val         0xffffffffU
#define SRT_NX90_mtgy_op_e76_val         0
#define DFLT_VAL_NX90_mtgy_op_e76_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e76_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e76': */
#define MSK_USED_BITS_NX90_mtgy_op_e76 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e76_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E76_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e76_val; /* data bits 2463..2432 */
} NX90_MTGY_OP_E76_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E76_BIT_T bf;
} NX90_MTGY_OP_E76_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e77 */
/* => MWMM operand E register 77 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e77  0x00001B34U
#define Adr_NX90_mtgy_mtgy_op_e77 0xFF083B34U
#define Adr_NX90_mtgy_op_e77      0xFF083B34U
#define DFLT_VAL_NX90_mtgy_op_e77 0x00000000U

#define MSK_NX90_mtgy_op_e77_val         0xffffffffU
#define SRT_NX90_mtgy_op_e77_val         0
#define DFLT_VAL_NX90_mtgy_op_e77_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e77_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e77': */
#define MSK_USED_BITS_NX90_mtgy_op_e77 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e77_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E77_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e77_val; /* data bits 2495..2464 */
} NX90_MTGY_OP_E77_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E77_BIT_T bf;
} NX90_MTGY_OP_E77_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e78 */
/* => MWMM operand E register 78 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e78  0x00001B38U
#define Adr_NX90_mtgy_mtgy_op_e78 0xFF083B38U
#define Adr_NX90_mtgy_op_e78      0xFF083B38U
#define DFLT_VAL_NX90_mtgy_op_e78 0x00000000U

#define MSK_NX90_mtgy_op_e78_val         0xffffffffU
#define SRT_NX90_mtgy_op_e78_val         0
#define DFLT_VAL_NX90_mtgy_op_e78_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e78_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e78': */
#define MSK_USED_BITS_NX90_mtgy_op_e78 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e78_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E78_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e78_val; /* data bits 2527..2496 */
} NX90_MTGY_OP_E78_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E78_BIT_T bf;
} NX90_MTGY_OP_E78_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e79 */
/* => MWMM operand E register 79 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e79  0x00001B3CU
#define Adr_NX90_mtgy_mtgy_op_e79 0xFF083B3CU
#define Adr_NX90_mtgy_op_e79      0xFF083B3CU
#define DFLT_VAL_NX90_mtgy_op_e79 0x00000000U

#define MSK_NX90_mtgy_op_e79_val         0xffffffffU
#define SRT_NX90_mtgy_op_e79_val         0
#define DFLT_VAL_NX90_mtgy_op_e79_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e79_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e79': */
#define MSK_USED_BITS_NX90_mtgy_op_e79 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e79_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E79_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e79_val; /* data bits 2559..2528 */
} NX90_MTGY_OP_E79_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E79_BIT_T bf;
} NX90_MTGY_OP_E79_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e80 */
/* => MWMM operand E register 80 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e80  0x00001B40U
#define Adr_NX90_mtgy_mtgy_op_e80 0xFF083B40U
#define Adr_NX90_mtgy_op_e80      0xFF083B40U
#define DFLT_VAL_NX90_mtgy_op_e80 0x00000000U

#define MSK_NX90_mtgy_op_e80_val         0xffffffffU
#define SRT_NX90_mtgy_op_e80_val         0
#define DFLT_VAL_NX90_mtgy_op_e80_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e80_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e80': */
#define MSK_USED_BITS_NX90_mtgy_op_e80 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e80_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E80_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e80_val; /* data bits 2591..2560 */
} NX90_MTGY_OP_E80_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E80_BIT_T bf;
} NX90_MTGY_OP_E80_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e81 */
/* => MWMM operand E register 81 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e81  0x00001B44U
#define Adr_NX90_mtgy_mtgy_op_e81 0xFF083B44U
#define Adr_NX90_mtgy_op_e81      0xFF083B44U
#define DFLT_VAL_NX90_mtgy_op_e81 0x00000000U

#define MSK_NX90_mtgy_op_e81_val         0xffffffffU
#define SRT_NX90_mtgy_op_e81_val         0
#define DFLT_VAL_NX90_mtgy_op_e81_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e81_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e81': */
#define MSK_USED_BITS_NX90_mtgy_op_e81 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e81_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E81_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e81_val; /* data bits 2623..2592 */
} NX90_MTGY_OP_E81_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E81_BIT_T bf;
} NX90_MTGY_OP_E81_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e82 */
/* => MWMM operand E register 82 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e82  0x00001B48U
#define Adr_NX90_mtgy_mtgy_op_e82 0xFF083B48U
#define Adr_NX90_mtgy_op_e82      0xFF083B48U
#define DFLT_VAL_NX90_mtgy_op_e82 0x00000000U

#define MSK_NX90_mtgy_op_e82_val         0xffffffffU
#define SRT_NX90_mtgy_op_e82_val         0
#define DFLT_VAL_NX90_mtgy_op_e82_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e82_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e82': */
#define MSK_USED_BITS_NX90_mtgy_op_e82 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e82_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E82_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e82_val; /* data bits 2655..2624 */
} NX90_MTGY_OP_E82_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E82_BIT_T bf;
} NX90_MTGY_OP_E82_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e83 */
/* => MWMM operand E register 83 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e83  0x00001B4CU
#define Adr_NX90_mtgy_mtgy_op_e83 0xFF083B4CU
#define Adr_NX90_mtgy_op_e83      0xFF083B4CU
#define DFLT_VAL_NX90_mtgy_op_e83 0x00000000U

#define MSK_NX90_mtgy_op_e83_val         0xffffffffU
#define SRT_NX90_mtgy_op_e83_val         0
#define DFLT_VAL_NX90_mtgy_op_e83_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e83_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e83': */
#define MSK_USED_BITS_NX90_mtgy_op_e83 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e83_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E83_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e83_val; /* data bits 2687..2656 */
} NX90_MTGY_OP_E83_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E83_BIT_T bf;
} NX90_MTGY_OP_E83_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e84 */
/* => MWMM operand E register 84 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e84  0x00001B50U
#define Adr_NX90_mtgy_mtgy_op_e84 0xFF083B50U
#define Adr_NX90_mtgy_op_e84      0xFF083B50U
#define DFLT_VAL_NX90_mtgy_op_e84 0x00000000U

#define MSK_NX90_mtgy_op_e84_val         0xffffffffU
#define SRT_NX90_mtgy_op_e84_val         0
#define DFLT_VAL_NX90_mtgy_op_e84_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e84_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e84': */
#define MSK_USED_BITS_NX90_mtgy_op_e84 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e84_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E84_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e84_val; /* data bits 2719..2688 */
} NX90_MTGY_OP_E84_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E84_BIT_T bf;
} NX90_MTGY_OP_E84_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e85 */
/* => MWMM operand E register 85 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e85  0x00001B54U
#define Adr_NX90_mtgy_mtgy_op_e85 0xFF083B54U
#define Adr_NX90_mtgy_op_e85      0xFF083B54U
#define DFLT_VAL_NX90_mtgy_op_e85 0x00000000U

#define MSK_NX90_mtgy_op_e85_val         0xffffffffU
#define SRT_NX90_mtgy_op_e85_val         0
#define DFLT_VAL_NX90_mtgy_op_e85_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e85_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e85': */
#define MSK_USED_BITS_NX90_mtgy_op_e85 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e85_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E85_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e85_val; /* data bits 2751..2720 */
} NX90_MTGY_OP_E85_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E85_BIT_T bf;
} NX90_MTGY_OP_E85_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e86 */
/* => MWMM operand E register 86 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e86  0x00001B58U
#define Adr_NX90_mtgy_mtgy_op_e86 0xFF083B58U
#define Adr_NX90_mtgy_op_e86      0xFF083B58U
#define DFLT_VAL_NX90_mtgy_op_e86 0x00000000U

#define MSK_NX90_mtgy_op_e86_val         0xffffffffU
#define SRT_NX90_mtgy_op_e86_val         0
#define DFLT_VAL_NX90_mtgy_op_e86_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e86_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e86': */
#define MSK_USED_BITS_NX90_mtgy_op_e86 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e86_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E86_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e86_val; /* data bits 2783..2752 */
} NX90_MTGY_OP_E86_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E86_BIT_T bf;
} NX90_MTGY_OP_E86_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e87 */
/* => MWMM operand E register 87 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e87  0x00001B5CU
#define Adr_NX90_mtgy_mtgy_op_e87 0xFF083B5CU
#define Adr_NX90_mtgy_op_e87      0xFF083B5CU
#define DFLT_VAL_NX90_mtgy_op_e87 0x00000000U

#define MSK_NX90_mtgy_op_e87_val         0xffffffffU
#define SRT_NX90_mtgy_op_e87_val         0
#define DFLT_VAL_NX90_mtgy_op_e87_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e87_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e87': */
#define MSK_USED_BITS_NX90_mtgy_op_e87 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e87_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E87_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e87_val; /* data bits 2815..2784 */
} NX90_MTGY_OP_E87_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E87_BIT_T bf;
} NX90_MTGY_OP_E87_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e88 */
/* => MWMM operand E register 88 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e88  0x00001B60U
#define Adr_NX90_mtgy_mtgy_op_e88 0xFF083B60U
#define Adr_NX90_mtgy_op_e88      0xFF083B60U
#define DFLT_VAL_NX90_mtgy_op_e88 0x00000000U

#define MSK_NX90_mtgy_op_e88_val         0xffffffffU
#define SRT_NX90_mtgy_op_e88_val         0
#define DFLT_VAL_NX90_mtgy_op_e88_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e88_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e88': */
#define MSK_USED_BITS_NX90_mtgy_op_e88 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e88_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E88_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e88_val; /* data bits 2847..2816 */
} NX90_MTGY_OP_E88_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E88_BIT_T bf;
} NX90_MTGY_OP_E88_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e89 */
/* => MWMM operand E register 89 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e89  0x00001B64U
#define Adr_NX90_mtgy_mtgy_op_e89 0xFF083B64U
#define Adr_NX90_mtgy_op_e89      0xFF083B64U
#define DFLT_VAL_NX90_mtgy_op_e89 0x00000000U

#define MSK_NX90_mtgy_op_e89_val         0xffffffffU
#define SRT_NX90_mtgy_op_e89_val         0
#define DFLT_VAL_NX90_mtgy_op_e89_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e89_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e89': */
#define MSK_USED_BITS_NX90_mtgy_op_e89 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e89_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E89_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e89_val; /* data bits 2879..2848 */
} NX90_MTGY_OP_E89_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E89_BIT_T bf;
} NX90_MTGY_OP_E89_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e90 */
/* => MWMM operand E register 90 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e90  0x00001B68U
#define Adr_NX90_mtgy_mtgy_op_e90 0xFF083B68U
#define Adr_NX90_mtgy_op_e90      0xFF083B68U
#define DFLT_VAL_NX90_mtgy_op_e90 0x00000000U

#define MSK_NX90_mtgy_op_e90_val         0xffffffffU
#define SRT_NX90_mtgy_op_e90_val         0
#define DFLT_VAL_NX90_mtgy_op_e90_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e90_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e90': */
#define MSK_USED_BITS_NX90_mtgy_op_e90 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e90_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E90_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e90_val; /* data bits 2911..2880 */
} NX90_MTGY_OP_E90_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E90_BIT_T bf;
} NX90_MTGY_OP_E90_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e91 */
/* => MWMM operand E register 91 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e91  0x00001B6CU
#define Adr_NX90_mtgy_mtgy_op_e91 0xFF083B6CU
#define Adr_NX90_mtgy_op_e91      0xFF083B6CU
#define DFLT_VAL_NX90_mtgy_op_e91 0x00000000U

#define MSK_NX90_mtgy_op_e91_val         0xffffffffU
#define SRT_NX90_mtgy_op_e91_val         0
#define DFLT_VAL_NX90_mtgy_op_e91_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e91_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e91': */
#define MSK_USED_BITS_NX90_mtgy_op_e91 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e91_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E91_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e91_val; /* data bits 2943..2912 */
} NX90_MTGY_OP_E91_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E91_BIT_T bf;
} NX90_MTGY_OP_E91_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e92 */
/* => MWMM operand E register 92 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e92  0x00001B70U
#define Adr_NX90_mtgy_mtgy_op_e92 0xFF083B70U
#define Adr_NX90_mtgy_op_e92      0xFF083B70U
#define DFLT_VAL_NX90_mtgy_op_e92 0x00000000U

#define MSK_NX90_mtgy_op_e92_val         0xffffffffU
#define SRT_NX90_mtgy_op_e92_val         0
#define DFLT_VAL_NX90_mtgy_op_e92_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e92_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e92': */
#define MSK_USED_BITS_NX90_mtgy_op_e92 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e92_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E92_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e92_val; /* data bits 2975..2944 */
} NX90_MTGY_OP_E92_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E92_BIT_T bf;
} NX90_MTGY_OP_E92_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e93 */
/* => MWMM operand E register 93 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e93  0x00001B74U
#define Adr_NX90_mtgy_mtgy_op_e93 0xFF083B74U
#define Adr_NX90_mtgy_op_e93      0xFF083B74U
#define DFLT_VAL_NX90_mtgy_op_e93 0x00000000U

#define MSK_NX90_mtgy_op_e93_val         0xffffffffU
#define SRT_NX90_mtgy_op_e93_val         0
#define DFLT_VAL_NX90_mtgy_op_e93_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e93_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e93': */
#define MSK_USED_BITS_NX90_mtgy_op_e93 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e93_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E93_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e93_val; /* data bits 3007..2976 */
} NX90_MTGY_OP_E93_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E93_BIT_T bf;
} NX90_MTGY_OP_E93_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e94 */
/* => MWMM operand E register 94 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e94  0x00001B78U
#define Adr_NX90_mtgy_mtgy_op_e94 0xFF083B78U
#define Adr_NX90_mtgy_op_e94      0xFF083B78U
#define DFLT_VAL_NX90_mtgy_op_e94 0x00000000U

#define MSK_NX90_mtgy_op_e94_val         0xffffffffU
#define SRT_NX90_mtgy_op_e94_val         0
#define DFLT_VAL_NX90_mtgy_op_e94_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e94_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e94': */
#define MSK_USED_BITS_NX90_mtgy_op_e94 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e94_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E94_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e94_val; /* data bits 3039..3008 */
} NX90_MTGY_OP_E94_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E94_BIT_T bf;
} NX90_MTGY_OP_E94_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e95 */
/* => MWMM operand E register 95 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e95  0x00001B7CU
#define Adr_NX90_mtgy_mtgy_op_e95 0xFF083B7CU
#define Adr_NX90_mtgy_op_e95      0xFF083B7CU
#define DFLT_VAL_NX90_mtgy_op_e95 0x00000000U

#define MSK_NX90_mtgy_op_e95_val         0xffffffffU
#define SRT_NX90_mtgy_op_e95_val         0
#define DFLT_VAL_NX90_mtgy_op_e95_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e95_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e95': */
#define MSK_USED_BITS_NX90_mtgy_op_e95 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e95_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E95_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e95_val; /* data bits 3071..3040 */
} NX90_MTGY_OP_E95_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E95_BIT_T bf;
} NX90_MTGY_OP_E95_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e96 */
/* => MWMM operand E register 96 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e96  0x00001B80U
#define Adr_NX90_mtgy_mtgy_op_e96 0xFF083B80U
#define Adr_NX90_mtgy_op_e96      0xFF083B80U
#define DFLT_VAL_NX90_mtgy_op_e96 0x00000000U

#define MSK_NX90_mtgy_op_e96_val         0xffffffffU
#define SRT_NX90_mtgy_op_e96_val         0
#define DFLT_VAL_NX90_mtgy_op_e96_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e96_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e96': */
#define MSK_USED_BITS_NX90_mtgy_op_e96 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e96_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E96_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e96_val; /* data bits 3103..3072 */
} NX90_MTGY_OP_E96_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E96_BIT_T bf;
} NX90_MTGY_OP_E96_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e97 */
/* => MWMM operand E register 97 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e97  0x00001B84U
#define Adr_NX90_mtgy_mtgy_op_e97 0xFF083B84U
#define Adr_NX90_mtgy_op_e97      0xFF083B84U
#define DFLT_VAL_NX90_mtgy_op_e97 0x00000000U

#define MSK_NX90_mtgy_op_e97_val         0xffffffffU
#define SRT_NX90_mtgy_op_e97_val         0
#define DFLT_VAL_NX90_mtgy_op_e97_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e97_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e97': */
#define MSK_USED_BITS_NX90_mtgy_op_e97 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e97_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E97_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e97_val; /* data bits 3135..3104 */
} NX90_MTGY_OP_E97_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E97_BIT_T bf;
} NX90_MTGY_OP_E97_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e98 */
/* => MWMM operand E register 98 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e98  0x00001B88U
#define Adr_NX90_mtgy_mtgy_op_e98 0xFF083B88U
#define Adr_NX90_mtgy_op_e98      0xFF083B88U
#define DFLT_VAL_NX90_mtgy_op_e98 0x00000000U

#define MSK_NX90_mtgy_op_e98_val         0xffffffffU
#define SRT_NX90_mtgy_op_e98_val         0
#define DFLT_VAL_NX90_mtgy_op_e98_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e98_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e98': */
#define MSK_USED_BITS_NX90_mtgy_op_e98 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e98_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E98_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e98_val; /* data bits 3167..3136 */
} NX90_MTGY_OP_E98_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E98_BIT_T bf;
} NX90_MTGY_OP_E98_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e99 */
/* => MWMM operand E register 99 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e99  0x00001B8CU
#define Adr_NX90_mtgy_mtgy_op_e99 0xFF083B8CU
#define Adr_NX90_mtgy_op_e99      0xFF083B8CU
#define DFLT_VAL_NX90_mtgy_op_e99 0x00000000U

#define MSK_NX90_mtgy_op_e99_val         0xffffffffU
#define SRT_NX90_mtgy_op_e99_val         0
#define DFLT_VAL_NX90_mtgy_op_e99_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e99_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e99': */
#define MSK_USED_BITS_NX90_mtgy_op_e99 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e99_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E99_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e99_val; /* data bits 3199..3168 */
} NX90_MTGY_OP_E99_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_E99_BIT_T bf;
} NX90_MTGY_OP_E99_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e100 */
/* => MWMM operand E register 100 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e100  0x00001B90U
#define Adr_NX90_mtgy_mtgy_op_e100 0xFF083B90U
#define Adr_NX90_mtgy_op_e100      0xFF083B90U
#define DFLT_VAL_NX90_mtgy_op_e100 0x00000000U

#define MSK_NX90_mtgy_op_e100_val         0xffffffffU
#define SRT_NX90_mtgy_op_e100_val         0
#define DFLT_VAL_NX90_mtgy_op_e100_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e100_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e100': */
#define MSK_USED_BITS_NX90_mtgy_op_e100 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e100_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E100_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e100_val; /* data bits 3231..3200 */
} NX90_MTGY_OP_E100_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E100_BIT_T bf;
} NX90_MTGY_OP_E100_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e101 */
/* => MWMM operand E register 101 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e101  0x00001B94U
#define Adr_NX90_mtgy_mtgy_op_e101 0xFF083B94U
#define Adr_NX90_mtgy_op_e101      0xFF083B94U
#define DFLT_VAL_NX90_mtgy_op_e101 0x00000000U

#define MSK_NX90_mtgy_op_e101_val         0xffffffffU
#define SRT_NX90_mtgy_op_e101_val         0
#define DFLT_VAL_NX90_mtgy_op_e101_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e101_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e101': */
#define MSK_USED_BITS_NX90_mtgy_op_e101 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e101_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E101_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e101_val; /* data bits 3263..3232 */
} NX90_MTGY_OP_E101_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E101_BIT_T bf;
} NX90_MTGY_OP_E101_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e102 */
/* => MWMM operand E register 102 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e102  0x00001B98U
#define Adr_NX90_mtgy_mtgy_op_e102 0xFF083B98U
#define Adr_NX90_mtgy_op_e102      0xFF083B98U
#define DFLT_VAL_NX90_mtgy_op_e102 0x00000000U

#define MSK_NX90_mtgy_op_e102_val         0xffffffffU
#define SRT_NX90_mtgy_op_e102_val         0
#define DFLT_VAL_NX90_mtgy_op_e102_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e102_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e102': */
#define MSK_USED_BITS_NX90_mtgy_op_e102 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e102_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E102_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e102_val; /* data bits 3295..3264 */
} NX90_MTGY_OP_E102_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E102_BIT_T bf;
} NX90_MTGY_OP_E102_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e103 */
/* => MWMM operand E register 103 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e103  0x00001B9CU
#define Adr_NX90_mtgy_mtgy_op_e103 0xFF083B9CU
#define Adr_NX90_mtgy_op_e103      0xFF083B9CU
#define DFLT_VAL_NX90_mtgy_op_e103 0x00000000U

#define MSK_NX90_mtgy_op_e103_val         0xffffffffU
#define SRT_NX90_mtgy_op_e103_val         0
#define DFLT_VAL_NX90_mtgy_op_e103_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e103_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e103': */
#define MSK_USED_BITS_NX90_mtgy_op_e103 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e103_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E103_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e103_val; /* data bits 3327..3296 */
} NX90_MTGY_OP_E103_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E103_BIT_T bf;
} NX90_MTGY_OP_E103_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e104 */
/* => MWMM operand E register 104 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e104  0x00001BA0U
#define Adr_NX90_mtgy_mtgy_op_e104 0xFF083BA0U
#define Adr_NX90_mtgy_op_e104      0xFF083BA0U
#define DFLT_VAL_NX90_mtgy_op_e104 0x00000000U

#define MSK_NX90_mtgy_op_e104_val         0xffffffffU
#define SRT_NX90_mtgy_op_e104_val         0
#define DFLT_VAL_NX90_mtgy_op_e104_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e104_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e104': */
#define MSK_USED_BITS_NX90_mtgy_op_e104 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e104_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E104_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e104_val; /* data bits 3359..3328 */
} NX90_MTGY_OP_E104_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E104_BIT_T bf;
} NX90_MTGY_OP_E104_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e105 */
/* => MWMM operand E register 105 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e105  0x00001BA4U
#define Adr_NX90_mtgy_mtgy_op_e105 0xFF083BA4U
#define Adr_NX90_mtgy_op_e105      0xFF083BA4U
#define DFLT_VAL_NX90_mtgy_op_e105 0x00000000U

#define MSK_NX90_mtgy_op_e105_val         0xffffffffU
#define SRT_NX90_mtgy_op_e105_val         0
#define DFLT_VAL_NX90_mtgy_op_e105_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e105_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e105': */
#define MSK_USED_BITS_NX90_mtgy_op_e105 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e105_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E105_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e105_val; /* data bits 3391..3360 */
} NX90_MTGY_OP_E105_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E105_BIT_T bf;
} NX90_MTGY_OP_E105_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e106 */
/* => MWMM operand E register 106 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e106  0x00001BA8U
#define Adr_NX90_mtgy_mtgy_op_e106 0xFF083BA8U
#define Adr_NX90_mtgy_op_e106      0xFF083BA8U
#define DFLT_VAL_NX90_mtgy_op_e106 0x00000000U

#define MSK_NX90_mtgy_op_e106_val         0xffffffffU
#define SRT_NX90_mtgy_op_e106_val         0
#define DFLT_VAL_NX90_mtgy_op_e106_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e106_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e106': */
#define MSK_USED_BITS_NX90_mtgy_op_e106 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e106_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E106_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e106_val; /* data bits 3423..3392 */
} NX90_MTGY_OP_E106_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E106_BIT_T bf;
} NX90_MTGY_OP_E106_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e107 */
/* => MWMM operand E register 107 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e107  0x00001BACU
#define Adr_NX90_mtgy_mtgy_op_e107 0xFF083BACU
#define Adr_NX90_mtgy_op_e107      0xFF083BACU
#define DFLT_VAL_NX90_mtgy_op_e107 0x00000000U

#define MSK_NX90_mtgy_op_e107_val         0xffffffffU
#define SRT_NX90_mtgy_op_e107_val         0
#define DFLT_VAL_NX90_mtgy_op_e107_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e107_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e107': */
#define MSK_USED_BITS_NX90_mtgy_op_e107 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e107_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E107_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e107_val; /* data bits 3455..3424 */
} NX90_MTGY_OP_E107_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E107_BIT_T bf;
} NX90_MTGY_OP_E107_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e108 */
/* => MWMM operand E register 108 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e108  0x00001BB0U
#define Adr_NX90_mtgy_mtgy_op_e108 0xFF083BB0U
#define Adr_NX90_mtgy_op_e108      0xFF083BB0U
#define DFLT_VAL_NX90_mtgy_op_e108 0x00000000U

#define MSK_NX90_mtgy_op_e108_val         0xffffffffU
#define SRT_NX90_mtgy_op_e108_val         0
#define DFLT_VAL_NX90_mtgy_op_e108_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e108_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e108': */
#define MSK_USED_BITS_NX90_mtgy_op_e108 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e108_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E108_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e108_val; /* data bits 3487..3456 */
} NX90_MTGY_OP_E108_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E108_BIT_T bf;
} NX90_MTGY_OP_E108_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e109 */
/* => MWMM operand E register 109 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e109  0x00001BB4U
#define Adr_NX90_mtgy_mtgy_op_e109 0xFF083BB4U
#define Adr_NX90_mtgy_op_e109      0xFF083BB4U
#define DFLT_VAL_NX90_mtgy_op_e109 0x00000000U

#define MSK_NX90_mtgy_op_e109_val         0xffffffffU
#define SRT_NX90_mtgy_op_e109_val         0
#define DFLT_VAL_NX90_mtgy_op_e109_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e109_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e109': */
#define MSK_USED_BITS_NX90_mtgy_op_e109 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e109_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E109_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e109_val; /* data bits 3519..3488 */
} NX90_MTGY_OP_E109_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E109_BIT_T bf;
} NX90_MTGY_OP_E109_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e110 */
/* => MWMM operand E register 110 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e110  0x00001BB8U
#define Adr_NX90_mtgy_mtgy_op_e110 0xFF083BB8U
#define Adr_NX90_mtgy_op_e110      0xFF083BB8U
#define DFLT_VAL_NX90_mtgy_op_e110 0x00000000U

#define MSK_NX90_mtgy_op_e110_val         0xffffffffU
#define SRT_NX90_mtgy_op_e110_val         0
#define DFLT_VAL_NX90_mtgy_op_e110_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e110_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e110': */
#define MSK_USED_BITS_NX90_mtgy_op_e110 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e110_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E110_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e110_val; /* data bits 3551..3520 */
} NX90_MTGY_OP_E110_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E110_BIT_T bf;
} NX90_MTGY_OP_E110_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e111 */
/* => MWMM operand E register 111 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e111  0x00001BBCU
#define Adr_NX90_mtgy_mtgy_op_e111 0xFF083BBCU
#define Adr_NX90_mtgy_op_e111      0xFF083BBCU
#define DFLT_VAL_NX90_mtgy_op_e111 0x00000000U

#define MSK_NX90_mtgy_op_e111_val         0xffffffffU
#define SRT_NX90_mtgy_op_e111_val         0
#define DFLT_VAL_NX90_mtgy_op_e111_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e111_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e111': */
#define MSK_USED_BITS_NX90_mtgy_op_e111 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e111_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E111_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e111_val; /* data bits 3583..3552 */
} NX90_MTGY_OP_E111_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E111_BIT_T bf;
} NX90_MTGY_OP_E111_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e112 */
/* => MWMM operand E register 112 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e112  0x00001BC0U
#define Adr_NX90_mtgy_mtgy_op_e112 0xFF083BC0U
#define Adr_NX90_mtgy_op_e112      0xFF083BC0U
#define DFLT_VAL_NX90_mtgy_op_e112 0x00000000U

#define MSK_NX90_mtgy_op_e112_val         0xffffffffU
#define SRT_NX90_mtgy_op_e112_val         0
#define DFLT_VAL_NX90_mtgy_op_e112_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e112_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e112': */
#define MSK_USED_BITS_NX90_mtgy_op_e112 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e112_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E112_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e112_val; /* data bits 3615..3584 */
} NX90_MTGY_OP_E112_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E112_BIT_T bf;
} NX90_MTGY_OP_E112_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e113 */
/* => MWMM operand E register 113 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e113  0x00001BC4U
#define Adr_NX90_mtgy_mtgy_op_e113 0xFF083BC4U
#define Adr_NX90_mtgy_op_e113      0xFF083BC4U
#define DFLT_VAL_NX90_mtgy_op_e113 0x00000000U

#define MSK_NX90_mtgy_op_e113_val         0xffffffffU
#define SRT_NX90_mtgy_op_e113_val         0
#define DFLT_VAL_NX90_mtgy_op_e113_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e113_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e113': */
#define MSK_USED_BITS_NX90_mtgy_op_e113 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e113_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E113_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e113_val; /* data bits 3647..3616 */
} NX90_MTGY_OP_E113_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E113_BIT_T bf;
} NX90_MTGY_OP_E113_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e114 */
/* => MWMM operand E register 114 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e114  0x00001BC8U
#define Adr_NX90_mtgy_mtgy_op_e114 0xFF083BC8U
#define Adr_NX90_mtgy_op_e114      0xFF083BC8U
#define DFLT_VAL_NX90_mtgy_op_e114 0x00000000U

#define MSK_NX90_mtgy_op_e114_val         0xffffffffU
#define SRT_NX90_mtgy_op_e114_val         0
#define DFLT_VAL_NX90_mtgy_op_e114_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e114_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e114': */
#define MSK_USED_BITS_NX90_mtgy_op_e114 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e114_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E114_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e114_val; /* data bits 3679..3648 */
} NX90_MTGY_OP_E114_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E114_BIT_T bf;
} NX90_MTGY_OP_E114_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e115 */
/* => MWMM operand E register 115 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e115  0x00001BCCU
#define Adr_NX90_mtgy_mtgy_op_e115 0xFF083BCCU
#define Adr_NX90_mtgy_op_e115      0xFF083BCCU
#define DFLT_VAL_NX90_mtgy_op_e115 0x00000000U

#define MSK_NX90_mtgy_op_e115_val         0xffffffffU
#define SRT_NX90_mtgy_op_e115_val         0
#define DFLT_VAL_NX90_mtgy_op_e115_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e115_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e115': */
#define MSK_USED_BITS_NX90_mtgy_op_e115 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e115_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E115_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e115_val; /* data bits 3711..3680 */
} NX90_MTGY_OP_E115_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E115_BIT_T bf;
} NX90_MTGY_OP_E115_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e116 */
/* => MWMM operand E register 116 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e116  0x00001BD0U
#define Adr_NX90_mtgy_mtgy_op_e116 0xFF083BD0U
#define Adr_NX90_mtgy_op_e116      0xFF083BD0U
#define DFLT_VAL_NX90_mtgy_op_e116 0x00000000U

#define MSK_NX90_mtgy_op_e116_val         0xffffffffU
#define SRT_NX90_mtgy_op_e116_val         0
#define DFLT_VAL_NX90_mtgy_op_e116_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e116_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e116': */
#define MSK_USED_BITS_NX90_mtgy_op_e116 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e116_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E116_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e116_val; /* data bits 3743..3712 */
} NX90_MTGY_OP_E116_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E116_BIT_T bf;
} NX90_MTGY_OP_E116_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e117 */
/* => MWMM operand E register 117 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e117  0x00001BD4U
#define Adr_NX90_mtgy_mtgy_op_e117 0xFF083BD4U
#define Adr_NX90_mtgy_op_e117      0xFF083BD4U
#define DFLT_VAL_NX90_mtgy_op_e117 0x00000000U

#define MSK_NX90_mtgy_op_e117_val         0xffffffffU
#define SRT_NX90_mtgy_op_e117_val         0
#define DFLT_VAL_NX90_mtgy_op_e117_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e117_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e117': */
#define MSK_USED_BITS_NX90_mtgy_op_e117 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e117_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E117_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e117_val; /* data bits 3775..3744 */
} NX90_MTGY_OP_E117_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E117_BIT_T bf;
} NX90_MTGY_OP_E117_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e118 */
/* => MWMM operand E register 118 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e118  0x00001BD8U
#define Adr_NX90_mtgy_mtgy_op_e118 0xFF083BD8U
#define Adr_NX90_mtgy_op_e118      0xFF083BD8U
#define DFLT_VAL_NX90_mtgy_op_e118 0x00000000U

#define MSK_NX90_mtgy_op_e118_val         0xffffffffU
#define SRT_NX90_mtgy_op_e118_val         0
#define DFLT_VAL_NX90_mtgy_op_e118_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e118_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e118': */
#define MSK_USED_BITS_NX90_mtgy_op_e118 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e118_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E118_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e118_val; /* data bits 3807..3776 */
} NX90_MTGY_OP_E118_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E118_BIT_T bf;
} NX90_MTGY_OP_E118_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e119 */
/* => MWMM operand E register 119 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e119  0x00001BDCU
#define Adr_NX90_mtgy_mtgy_op_e119 0xFF083BDCU
#define Adr_NX90_mtgy_op_e119      0xFF083BDCU
#define DFLT_VAL_NX90_mtgy_op_e119 0x00000000U

#define MSK_NX90_mtgy_op_e119_val         0xffffffffU
#define SRT_NX90_mtgy_op_e119_val         0
#define DFLT_VAL_NX90_mtgy_op_e119_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e119_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e119': */
#define MSK_USED_BITS_NX90_mtgy_op_e119 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e119_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E119_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e119_val; /* data bits 3839..3808 */
} NX90_MTGY_OP_E119_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E119_BIT_T bf;
} NX90_MTGY_OP_E119_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e120 */
/* => MWMM operand E register 120 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e120  0x00001BE0U
#define Adr_NX90_mtgy_mtgy_op_e120 0xFF083BE0U
#define Adr_NX90_mtgy_op_e120      0xFF083BE0U
#define DFLT_VAL_NX90_mtgy_op_e120 0x00000000U

#define MSK_NX90_mtgy_op_e120_val         0xffffffffU
#define SRT_NX90_mtgy_op_e120_val         0
#define DFLT_VAL_NX90_mtgy_op_e120_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e120_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e120': */
#define MSK_USED_BITS_NX90_mtgy_op_e120 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e120_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E120_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e120_val; /* data bits 3871..3840 */
} NX90_MTGY_OP_E120_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E120_BIT_T bf;
} NX90_MTGY_OP_E120_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e121 */
/* => MWMM operand E register 121 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e121  0x00001BE4U
#define Adr_NX90_mtgy_mtgy_op_e121 0xFF083BE4U
#define Adr_NX90_mtgy_op_e121      0xFF083BE4U
#define DFLT_VAL_NX90_mtgy_op_e121 0x00000000U

#define MSK_NX90_mtgy_op_e121_val         0xffffffffU
#define SRT_NX90_mtgy_op_e121_val         0
#define DFLT_VAL_NX90_mtgy_op_e121_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e121_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e121': */
#define MSK_USED_BITS_NX90_mtgy_op_e121 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e121_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E121_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e121_val; /* data bits 3903..3872 */
} NX90_MTGY_OP_E121_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E121_BIT_T bf;
} NX90_MTGY_OP_E121_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e122 */
/* => MWMM operand E register 122 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e122  0x00001BE8U
#define Adr_NX90_mtgy_mtgy_op_e122 0xFF083BE8U
#define Adr_NX90_mtgy_op_e122      0xFF083BE8U
#define DFLT_VAL_NX90_mtgy_op_e122 0x00000000U

#define MSK_NX90_mtgy_op_e122_val         0xffffffffU
#define SRT_NX90_mtgy_op_e122_val         0
#define DFLT_VAL_NX90_mtgy_op_e122_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e122_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e122': */
#define MSK_USED_BITS_NX90_mtgy_op_e122 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e122_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E122_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e122_val; /* data bits 3935..3904 */
} NX90_MTGY_OP_E122_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E122_BIT_T bf;
} NX90_MTGY_OP_E122_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e123 */
/* => MWMM operand E register 123 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e123  0x00001BECU
#define Adr_NX90_mtgy_mtgy_op_e123 0xFF083BECU
#define Adr_NX90_mtgy_op_e123      0xFF083BECU
#define DFLT_VAL_NX90_mtgy_op_e123 0x00000000U

#define MSK_NX90_mtgy_op_e123_val         0xffffffffU
#define SRT_NX90_mtgy_op_e123_val         0
#define DFLT_VAL_NX90_mtgy_op_e123_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e123_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e123': */
#define MSK_USED_BITS_NX90_mtgy_op_e123 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e123_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E123_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e123_val; /* data bits 3967..3936 */
} NX90_MTGY_OP_E123_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E123_BIT_T bf;
} NX90_MTGY_OP_E123_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e124 */
/* => MWMM operand E register 124 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e124  0x00001BF0U
#define Adr_NX90_mtgy_mtgy_op_e124 0xFF083BF0U
#define Adr_NX90_mtgy_op_e124      0xFF083BF0U
#define DFLT_VAL_NX90_mtgy_op_e124 0x00000000U

#define MSK_NX90_mtgy_op_e124_val         0xffffffffU
#define SRT_NX90_mtgy_op_e124_val         0
#define DFLT_VAL_NX90_mtgy_op_e124_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e124_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e124': */
#define MSK_USED_BITS_NX90_mtgy_op_e124 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e124_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E124_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e124_val; /* data bits 3999..3968 */
} NX90_MTGY_OP_E124_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E124_BIT_T bf;
} NX90_MTGY_OP_E124_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e125 */
/* => MWMM operand E register 125 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e125  0x00001BF4U
#define Adr_NX90_mtgy_mtgy_op_e125 0xFF083BF4U
#define Adr_NX90_mtgy_op_e125      0xFF083BF4U
#define DFLT_VAL_NX90_mtgy_op_e125 0x00000000U

#define MSK_NX90_mtgy_op_e125_val         0xffffffffU
#define SRT_NX90_mtgy_op_e125_val         0
#define DFLT_VAL_NX90_mtgy_op_e125_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e125_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e125': */
#define MSK_USED_BITS_NX90_mtgy_op_e125 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e125_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E125_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e125_val; /* data bits 4031..4000 */
} NX90_MTGY_OP_E125_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E125_BIT_T bf;
} NX90_MTGY_OP_E125_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e126 */
/* => MWMM operand E register 126 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e126  0x00001BF8U
#define Adr_NX90_mtgy_mtgy_op_e126 0xFF083BF8U
#define Adr_NX90_mtgy_op_e126      0xFF083BF8U
#define DFLT_VAL_NX90_mtgy_op_e126 0x00000000U

#define MSK_NX90_mtgy_op_e126_val         0xffffffffU
#define SRT_NX90_mtgy_op_e126_val         0
#define DFLT_VAL_NX90_mtgy_op_e126_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e126_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e126': */
#define MSK_USED_BITS_NX90_mtgy_op_e126 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e126_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E126_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e126_val; /* data bits 4063..4032 */
} NX90_MTGY_OP_E126_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E126_BIT_T bf;
} NX90_MTGY_OP_E126_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_e127 */
/* => MWMM operand E register 127 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_e127  0x00001BFCU
#define Adr_NX90_mtgy_mtgy_op_e127 0xFF083BFCU
#define Adr_NX90_mtgy_op_e127      0xFF083BFCU
#define DFLT_VAL_NX90_mtgy_op_e127 0x00000000U

#define MSK_NX90_mtgy_op_e127_val         0xffffffffU
#define SRT_NX90_mtgy_op_e127_val         0
#define DFLT_VAL_NX90_mtgy_op_e127_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_e127_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_e127': */
#define MSK_USED_BITS_NX90_mtgy_op_e127 0xffffffffU

enum {
  BFW_NX90_mtgy_op_e127_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_E127_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_e127_val; /* data bits 4095..4064 */
} NX90_MTGY_OP_E127_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_E127_BIT_T bf;
} NX90_MTGY_OP_E127_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x0 */
/* => MWMM operand X register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x0  0x00001C00U
#define Adr_NX90_mtgy_mtgy_op_x0 0xFF083C00U
#define Adr_NX90_mtgy_op_x0      0xFF083C00U
#define DFLT_VAL_NX90_mtgy_op_x0 0x00000000U

#define MSK_NX90_mtgy_op_x0_val         0xffffffffU
#define SRT_NX90_mtgy_op_x0_val         0
#define DFLT_VAL_NX90_mtgy_op_x0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x0_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x0': */
#define MSK_USED_BITS_NX90_mtgy_op_x0 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x0_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X0_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x0_val; /* data bits 31..0 */
} NX90_MTGY_OP_X0_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X0_BIT_T bf;
} NX90_MTGY_OP_X0_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x1 */
/* => MWMM operand X register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x1  0x00001C04U
#define Adr_NX90_mtgy_mtgy_op_x1 0xFF083C04U
#define Adr_NX90_mtgy_op_x1      0xFF083C04U
#define DFLT_VAL_NX90_mtgy_op_x1 0x00000000U

#define MSK_NX90_mtgy_op_x1_val         0xffffffffU
#define SRT_NX90_mtgy_op_x1_val         0
#define DFLT_VAL_NX90_mtgy_op_x1_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x1_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x1': */
#define MSK_USED_BITS_NX90_mtgy_op_x1 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x1_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X1_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x1_val; /* data bits 63..32 */
} NX90_MTGY_OP_X1_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X1_BIT_T bf;
} NX90_MTGY_OP_X1_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x2 */
/* => MWMM operand X register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x2  0x00001C08U
#define Adr_NX90_mtgy_mtgy_op_x2 0xFF083C08U
#define Adr_NX90_mtgy_op_x2      0xFF083C08U
#define DFLT_VAL_NX90_mtgy_op_x2 0x00000000U

#define MSK_NX90_mtgy_op_x2_val         0xffffffffU
#define SRT_NX90_mtgy_op_x2_val         0
#define DFLT_VAL_NX90_mtgy_op_x2_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x2_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x2': */
#define MSK_USED_BITS_NX90_mtgy_op_x2 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x2_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X2_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x2_val; /* data bits 95..64 */
} NX90_MTGY_OP_X2_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X2_BIT_T bf;
} NX90_MTGY_OP_X2_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x3 */
/* => MWMM operand X register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x3  0x00001C0CU
#define Adr_NX90_mtgy_mtgy_op_x3 0xFF083C0CU
#define Adr_NX90_mtgy_op_x3      0xFF083C0CU
#define DFLT_VAL_NX90_mtgy_op_x3 0x00000000U

#define MSK_NX90_mtgy_op_x3_val         0xffffffffU
#define SRT_NX90_mtgy_op_x3_val         0
#define DFLT_VAL_NX90_mtgy_op_x3_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x3_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x3': */
#define MSK_USED_BITS_NX90_mtgy_op_x3 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x3_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X3_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x3_val; /* data bits 127..96 */
} NX90_MTGY_OP_X3_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X3_BIT_T bf;
} NX90_MTGY_OP_X3_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x4 */
/* => MWMM operand X register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x4  0x00001C10U
#define Adr_NX90_mtgy_mtgy_op_x4 0xFF083C10U
#define Adr_NX90_mtgy_op_x4      0xFF083C10U
#define DFLT_VAL_NX90_mtgy_op_x4 0x00000000U

#define MSK_NX90_mtgy_op_x4_val         0xffffffffU
#define SRT_NX90_mtgy_op_x4_val         0
#define DFLT_VAL_NX90_mtgy_op_x4_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x4_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x4': */
#define MSK_USED_BITS_NX90_mtgy_op_x4 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x4_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X4_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x4_val; /* data bits 159..128 */
} NX90_MTGY_OP_X4_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X4_BIT_T bf;
} NX90_MTGY_OP_X4_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x5 */
/* => MWMM operand X register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x5  0x00001C14U
#define Adr_NX90_mtgy_mtgy_op_x5 0xFF083C14U
#define Adr_NX90_mtgy_op_x5      0xFF083C14U
#define DFLT_VAL_NX90_mtgy_op_x5 0x00000000U

#define MSK_NX90_mtgy_op_x5_val         0xffffffffU
#define SRT_NX90_mtgy_op_x5_val         0
#define DFLT_VAL_NX90_mtgy_op_x5_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x5_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x5': */
#define MSK_USED_BITS_NX90_mtgy_op_x5 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x5_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X5_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x5_val; /* data bits 191..160 */
} NX90_MTGY_OP_X5_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X5_BIT_T bf;
} NX90_MTGY_OP_X5_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x6 */
/* => MWMM operand X register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x6  0x00001C18U
#define Adr_NX90_mtgy_mtgy_op_x6 0xFF083C18U
#define Adr_NX90_mtgy_op_x6      0xFF083C18U
#define DFLT_VAL_NX90_mtgy_op_x6 0x00000000U

#define MSK_NX90_mtgy_op_x6_val         0xffffffffU
#define SRT_NX90_mtgy_op_x6_val         0
#define DFLT_VAL_NX90_mtgy_op_x6_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x6_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x6': */
#define MSK_USED_BITS_NX90_mtgy_op_x6 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x6_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X6_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x6_val; /* data bits 223..192 */
} NX90_MTGY_OP_X6_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X6_BIT_T bf;
} NX90_MTGY_OP_X6_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x7 */
/* => MWMM operand X register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x7  0x00001C1CU
#define Adr_NX90_mtgy_mtgy_op_x7 0xFF083C1CU
#define Adr_NX90_mtgy_op_x7      0xFF083C1CU
#define DFLT_VAL_NX90_mtgy_op_x7 0x00000000U

#define MSK_NX90_mtgy_op_x7_val         0xffffffffU
#define SRT_NX90_mtgy_op_x7_val         0
#define DFLT_VAL_NX90_mtgy_op_x7_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x7_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x7': */
#define MSK_USED_BITS_NX90_mtgy_op_x7 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x7_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X7_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x7_val; /* data bits 255..224 */
} NX90_MTGY_OP_X7_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X7_BIT_T bf;
} NX90_MTGY_OP_X7_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x8 */
/* => MWMM operand X register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x8  0x00001C20U
#define Adr_NX90_mtgy_mtgy_op_x8 0xFF083C20U
#define Adr_NX90_mtgy_op_x8      0xFF083C20U
#define DFLT_VAL_NX90_mtgy_op_x8 0x00000000U

#define MSK_NX90_mtgy_op_x8_val         0xffffffffU
#define SRT_NX90_mtgy_op_x8_val         0
#define DFLT_VAL_NX90_mtgy_op_x8_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x8_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x8': */
#define MSK_USED_BITS_NX90_mtgy_op_x8 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x8_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X8_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x8_val; /* data bits 287..256 */
} NX90_MTGY_OP_X8_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X8_BIT_T bf;
} NX90_MTGY_OP_X8_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x9 */
/* => MWMM operand X register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x9  0x00001C24U
#define Adr_NX90_mtgy_mtgy_op_x9 0xFF083C24U
#define Adr_NX90_mtgy_op_x9      0xFF083C24U
#define DFLT_VAL_NX90_mtgy_op_x9 0x00000000U

#define MSK_NX90_mtgy_op_x9_val         0xffffffffU
#define SRT_NX90_mtgy_op_x9_val         0
#define DFLT_VAL_NX90_mtgy_op_x9_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x9_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x9': */
#define MSK_USED_BITS_NX90_mtgy_op_x9 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x9_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X9_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x9_val; /* data bits 319..288 */
} NX90_MTGY_OP_X9_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MTGY_OP_X9_BIT_T bf;
} NX90_MTGY_OP_X9_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x10 */
/* => MWMM operand X register 10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x10  0x00001C28U
#define Adr_NX90_mtgy_mtgy_op_x10 0xFF083C28U
#define Adr_NX90_mtgy_op_x10      0xFF083C28U
#define DFLT_VAL_NX90_mtgy_op_x10 0x00000000U

#define MSK_NX90_mtgy_op_x10_val         0xffffffffU
#define SRT_NX90_mtgy_op_x10_val         0
#define DFLT_VAL_NX90_mtgy_op_x10_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x10_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x10': */
#define MSK_USED_BITS_NX90_mtgy_op_x10 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x10_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X10_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x10_val; /* data bits 351..320 */
} NX90_MTGY_OP_X10_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X10_BIT_T bf;
} NX90_MTGY_OP_X10_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x11 */
/* => MWMM operand X register 11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x11  0x00001C2CU
#define Adr_NX90_mtgy_mtgy_op_x11 0xFF083C2CU
#define Adr_NX90_mtgy_op_x11      0xFF083C2CU
#define DFLT_VAL_NX90_mtgy_op_x11 0x00000000U

#define MSK_NX90_mtgy_op_x11_val         0xffffffffU
#define SRT_NX90_mtgy_op_x11_val         0
#define DFLT_VAL_NX90_mtgy_op_x11_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x11_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x11': */
#define MSK_USED_BITS_NX90_mtgy_op_x11 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x11_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X11_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x11_val; /* data bits 383..352 */
} NX90_MTGY_OP_X11_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X11_BIT_T bf;
} NX90_MTGY_OP_X11_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x12 */
/* => MWMM operand X register 12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x12  0x00001C30U
#define Adr_NX90_mtgy_mtgy_op_x12 0xFF083C30U
#define Adr_NX90_mtgy_op_x12      0xFF083C30U
#define DFLT_VAL_NX90_mtgy_op_x12 0x00000000U

#define MSK_NX90_mtgy_op_x12_val         0xffffffffU
#define SRT_NX90_mtgy_op_x12_val         0
#define DFLT_VAL_NX90_mtgy_op_x12_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x12_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x12': */
#define MSK_USED_BITS_NX90_mtgy_op_x12 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x12_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X12_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x12_val; /* data bits 415..384 */
} NX90_MTGY_OP_X12_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X12_BIT_T bf;
} NX90_MTGY_OP_X12_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x13 */
/* => MWMM operand X register 13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x13  0x00001C34U
#define Adr_NX90_mtgy_mtgy_op_x13 0xFF083C34U
#define Adr_NX90_mtgy_op_x13      0xFF083C34U
#define DFLT_VAL_NX90_mtgy_op_x13 0x00000000U

#define MSK_NX90_mtgy_op_x13_val         0xffffffffU
#define SRT_NX90_mtgy_op_x13_val         0
#define DFLT_VAL_NX90_mtgy_op_x13_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x13_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x13': */
#define MSK_USED_BITS_NX90_mtgy_op_x13 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x13_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X13_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x13_val; /* data bits 447..416 */
} NX90_MTGY_OP_X13_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X13_BIT_T bf;
} NX90_MTGY_OP_X13_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x14 */
/* => MWMM operand X register 14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x14  0x00001C38U
#define Adr_NX90_mtgy_mtgy_op_x14 0xFF083C38U
#define Adr_NX90_mtgy_op_x14      0xFF083C38U
#define DFLT_VAL_NX90_mtgy_op_x14 0x00000000U

#define MSK_NX90_mtgy_op_x14_val         0xffffffffU
#define SRT_NX90_mtgy_op_x14_val         0
#define DFLT_VAL_NX90_mtgy_op_x14_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x14_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x14': */
#define MSK_USED_BITS_NX90_mtgy_op_x14 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x14_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X14_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x14_val; /* data bits 479..448 */
} NX90_MTGY_OP_X14_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X14_BIT_T bf;
} NX90_MTGY_OP_X14_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x15 */
/* => MWMM operand X register 15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x15  0x00001C3CU
#define Adr_NX90_mtgy_mtgy_op_x15 0xFF083C3CU
#define Adr_NX90_mtgy_op_x15      0xFF083C3CU
#define DFLT_VAL_NX90_mtgy_op_x15 0x00000000U

#define MSK_NX90_mtgy_op_x15_val         0xffffffffU
#define SRT_NX90_mtgy_op_x15_val         0
#define DFLT_VAL_NX90_mtgy_op_x15_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x15_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x15': */
#define MSK_USED_BITS_NX90_mtgy_op_x15 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x15_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X15_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x15_val; /* data bits 511..480 */
} NX90_MTGY_OP_X15_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X15_BIT_T bf;
} NX90_MTGY_OP_X15_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x16 */
/* => MWMM operand X register 16 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x16  0x00001C40U
#define Adr_NX90_mtgy_mtgy_op_x16 0xFF083C40U
#define Adr_NX90_mtgy_op_x16      0xFF083C40U
#define DFLT_VAL_NX90_mtgy_op_x16 0x00000000U

#define MSK_NX90_mtgy_op_x16_val         0xffffffffU
#define SRT_NX90_mtgy_op_x16_val         0
#define DFLT_VAL_NX90_mtgy_op_x16_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x16_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x16': */
#define MSK_USED_BITS_NX90_mtgy_op_x16 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x16_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X16_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x16_val; /* data bits 543..512 */
} NX90_MTGY_OP_X16_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X16_BIT_T bf;
} NX90_MTGY_OP_X16_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x17 */
/* => MWMM operand X register 17 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x17  0x00001C44U
#define Adr_NX90_mtgy_mtgy_op_x17 0xFF083C44U
#define Adr_NX90_mtgy_op_x17      0xFF083C44U
#define DFLT_VAL_NX90_mtgy_op_x17 0x00000000U

#define MSK_NX90_mtgy_op_x17_val         0xffffffffU
#define SRT_NX90_mtgy_op_x17_val         0
#define DFLT_VAL_NX90_mtgy_op_x17_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x17_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x17': */
#define MSK_USED_BITS_NX90_mtgy_op_x17 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x17_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X17_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x17_val; /* data bits 575..544 */
} NX90_MTGY_OP_X17_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X17_BIT_T bf;
} NX90_MTGY_OP_X17_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x18 */
/* => MWMM operand X register 18 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x18  0x00001C48U
#define Adr_NX90_mtgy_mtgy_op_x18 0xFF083C48U
#define Adr_NX90_mtgy_op_x18      0xFF083C48U
#define DFLT_VAL_NX90_mtgy_op_x18 0x00000000U

#define MSK_NX90_mtgy_op_x18_val         0xffffffffU
#define SRT_NX90_mtgy_op_x18_val         0
#define DFLT_VAL_NX90_mtgy_op_x18_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x18_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x18': */
#define MSK_USED_BITS_NX90_mtgy_op_x18 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x18_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X18_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x18_val; /* data bits 607..576 */
} NX90_MTGY_OP_X18_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X18_BIT_T bf;
} NX90_MTGY_OP_X18_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x19 */
/* => MWMM operand X register 19 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x19  0x00001C4CU
#define Adr_NX90_mtgy_mtgy_op_x19 0xFF083C4CU
#define Adr_NX90_mtgy_op_x19      0xFF083C4CU
#define DFLT_VAL_NX90_mtgy_op_x19 0x00000000U

#define MSK_NX90_mtgy_op_x19_val         0xffffffffU
#define SRT_NX90_mtgy_op_x19_val         0
#define DFLT_VAL_NX90_mtgy_op_x19_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x19_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x19': */
#define MSK_USED_BITS_NX90_mtgy_op_x19 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x19_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X19_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x19_val; /* data bits 639..608 */
} NX90_MTGY_OP_X19_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X19_BIT_T bf;
} NX90_MTGY_OP_X19_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x20 */
/* => MWMM operand X register 20 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x20  0x00001C50U
#define Adr_NX90_mtgy_mtgy_op_x20 0xFF083C50U
#define Adr_NX90_mtgy_op_x20      0xFF083C50U
#define DFLT_VAL_NX90_mtgy_op_x20 0x00000000U

#define MSK_NX90_mtgy_op_x20_val         0xffffffffU
#define SRT_NX90_mtgy_op_x20_val         0
#define DFLT_VAL_NX90_mtgy_op_x20_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x20_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x20': */
#define MSK_USED_BITS_NX90_mtgy_op_x20 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x20_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X20_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x20_val; /* data bits 671..640 */
} NX90_MTGY_OP_X20_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X20_BIT_T bf;
} NX90_MTGY_OP_X20_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x21 */
/* => MWMM operand X register 21 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x21  0x00001C54U
#define Adr_NX90_mtgy_mtgy_op_x21 0xFF083C54U
#define Adr_NX90_mtgy_op_x21      0xFF083C54U
#define DFLT_VAL_NX90_mtgy_op_x21 0x00000000U

#define MSK_NX90_mtgy_op_x21_val         0xffffffffU
#define SRT_NX90_mtgy_op_x21_val         0
#define DFLT_VAL_NX90_mtgy_op_x21_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x21_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x21': */
#define MSK_USED_BITS_NX90_mtgy_op_x21 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x21_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X21_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x21_val; /* data bits 703..672 */
} NX90_MTGY_OP_X21_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X21_BIT_T bf;
} NX90_MTGY_OP_X21_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x22 */
/* => MWMM operand X register 22 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x22  0x00001C58U
#define Adr_NX90_mtgy_mtgy_op_x22 0xFF083C58U
#define Adr_NX90_mtgy_op_x22      0xFF083C58U
#define DFLT_VAL_NX90_mtgy_op_x22 0x00000000U

#define MSK_NX90_mtgy_op_x22_val         0xffffffffU
#define SRT_NX90_mtgy_op_x22_val         0
#define DFLT_VAL_NX90_mtgy_op_x22_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x22_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x22': */
#define MSK_USED_BITS_NX90_mtgy_op_x22 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x22_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X22_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x22_val; /* data bits 735..704 */
} NX90_MTGY_OP_X22_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X22_BIT_T bf;
} NX90_MTGY_OP_X22_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x23 */
/* => MWMM operand X register 23 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x23  0x00001C5CU
#define Adr_NX90_mtgy_mtgy_op_x23 0xFF083C5CU
#define Adr_NX90_mtgy_op_x23      0xFF083C5CU
#define DFLT_VAL_NX90_mtgy_op_x23 0x00000000U

#define MSK_NX90_mtgy_op_x23_val         0xffffffffU
#define SRT_NX90_mtgy_op_x23_val         0
#define DFLT_VAL_NX90_mtgy_op_x23_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x23_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x23': */
#define MSK_USED_BITS_NX90_mtgy_op_x23 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x23_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X23_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x23_val; /* data bits 767..736 */
} NX90_MTGY_OP_X23_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X23_BIT_T bf;
} NX90_MTGY_OP_X23_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x24 */
/* => MWMM operand X register 24 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x24  0x00001C60U
#define Adr_NX90_mtgy_mtgy_op_x24 0xFF083C60U
#define Adr_NX90_mtgy_op_x24      0xFF083C60U
#define DFLT_VAL_NX90_mtgy_op_x24 0x00000000U

#define MSK_NX90_mtgy_op_x24_val         0xffffffffU
#define SRT_NX90_mtgy_op_x24_val         0
#define DFLT_VAL_NX90_mtgy_op_x24_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x24_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x24': */
#define MSK_USED_BITS_NX90_mtgy_op_x24 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x24_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X24_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x24_val; /* data bits 799..768 */
} NX90_MTGY_OP_X24_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X24_BIT_T bf;
} NX90_MTGY_OP_X24_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x25 */
/* => MWMM operand X register 25 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x25  0x00001C64U
#define Adr_NX90_mtgy_mtgy_op_x25 0xFF083C64U
#define Adr_NX90_mtgy_op_x25      0xFF083C64U
#define DFLT_VAL_NX90_mtgy_op_x25 0x00000000U

#define MSK_NX90_mtgy_op_x25_val         0xffffffffU
#define SRT_NX90_mtgy_op_x25_val         0
#define DFLT_VAL_NX90_mtgy_op_x25_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x25_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x25': */
#define MSK_USED_BITS_NX90_mtgy_op_x25 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x25_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X25_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x25_val; /* data bits 831..800 */
} NX90_MTGY_OP_X25_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X25_BIT_T bf;
} NX90_MTGY_OP_X25_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x26 */
/* => MWMM operand X register 26 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x26  0x00001C68U
#define Adr_NX90_mtgy_mtgy_op_x26 0xFF083C68U
#define Adr_NX90_mtgy_op_x26      0xFF083C68U
#define DFLT_VAL_NX90_mtgy_op_x26 0x00000000U

#define MSK_NX90_mtgy_op_x26_val         0xffffffffU
#define SRT_NX90_mtgy_op_x26_val         0
#define DFLT_VAL_NX90_mtgy_op_x26_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x26_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x26': */
#define MSK_USED_BITS_NX90_mtgy_op_x26 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x26_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X26_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x26_val; /* data bits 863..832 */
} NX90_MTGY_OP_X26_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X26_BIT_T bf;
} NX90_MTGY_OP_X26_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x27 */
/* => MWMM operand X register 27 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x27  0x00001C6CU
#define Adr_NX90_mtgy_mtgy_op_x27 0xFF083C6CU
#define Adr_NX90_mtgy_op_x27      0xFF083C6CU
#define DFLT_VAL_NX90_mtgy_op_x27 0x00000000U

#define MSK_NX90_mtgy_op_x27_val         0xffffffffU
#define SRT_NX90_mtgy_op_x27_val         0
#define DFLT_VAL_NX90_mtgy_op_x27_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x27_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x27': */
#define MSK_USED_BITS_NX90_mtgy_op_x27 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x27_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X27_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x27_val; /* data bits 895..864 */
} NX90_MTGY_OP_X27_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X27_BIT_T bf;
} NX90_MTGY_OP_X27_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x28 */
/* => MWMM operand X register 28 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x28  0x00001C70U
#define Adr_NX90_mtgy_mtgy_op_x28 0xFF083C70U
#define Adr_NX90_mtgy_op_x28      0xFF083C70U
#define DFLT_VAL_NX90_mtgy_op_x28 0x00000000U

#define MSK_NX90_mtgy_op_x28_val         0xffffffffU
#define SRT_NX90_mtgy_op_x28_val         0
#define DFLT_VAL_NX90_mtgy_op_x28_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x28_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x28': */
#define MSK_USED_BITS_NX90_mtgy_op_x28 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x28_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X28_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x28_val; /* data bits 927..896 */
} NX90_MTGY_OP_X28_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X28_BIT_T bf;
} NX90_MTGY_OP_X28_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x29 */
/* => MWMM operand X register 29 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x29  0x00001C74U
#define Adr_NX90_mtgy_mtgy_op_x29 0xFF083C74U
#define Adr_NX90_mtgy_op_x29      0xFF083C74U
#define DFLT_VAL_NX90_mtgy_op_x29 0x00000000U

#define MSK_NX90_mtgy_op_x29_val         0xffffffffU
#define SRT_NX90_mtgy_op_x29_val         0
#define DFLT_VAL_NX90_mtgy_op_x29_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x29_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x29': */
#define MSK_USED_BITS_NX90_mtgy_op_x29 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x29_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X29_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x29_val; /* data bits 959..928 */
} NX90_MTGY_OP_X29_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X29_BIT_T bf;
} NX90_MTGY_OP_X29_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x30 */
/* => MWMM operand X register 30 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x30  0x00001C78U
#define Adr_NX90_mtgy_mtgy_op_x30 0xFF083C78U
#define Adr_NX90_mtgy_op_x30      0xFF083C78U
#define DFLT_VAL_NX90_mtgy_op_x30 0x00000000U

#define MSK_NX90_mtgy_op_x30_val         0xffffffffU
#define SRT_NX90_mtgy_op_x30_val         0
#define DFLT_VAL_NX90_mtgy_op_x30_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x30_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x30': */
#define MSK_USED_BITS_NX90_mtgy_op_x30 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x30_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X30_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x30_val; /* data bits 991..960 */
} NX90_MTGY_OP_X30_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X30_BIT_T bf;
} NX90_MTGY_OP_X30_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x31 */
/* => MWMM operand X register 31 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x31  0x00001C7CU
#define Adr_NX90_mtgy_mtgy_op_x31 0xFF083C7CU
#define Adr_NX90_mtgy_op_x31      0xFF083C7CU
#define DFLT_VAL_NX90_mtgy_op_x31 0x00000000U

#define MSK_NX90_mtgy_op_x31_val         0xffffffffU
#define SRT_NX90_mtgy_op_x31_val         0
#define DFLT_VAL_NX90_mtgy_op_x31_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x31_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x31': */
#define MSK_USED_BITS_NX90_mtgy_op_x31 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x31_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X31_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x31_val; /* data bits 1023..992 */
} NX90_MTGY_OP_X31_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X31_BIT_T bf;
} NX90_MTGY_OP_X31_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x32 */
/* => MWMM operand X register 32 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x32  0x00001C80U
#define Adr_NX90_mtgy_mtgy_op_x32 0xFF083C80U
#define Adr_NX90_mtgy_op_x32      0xFF083C80U
#define DFLT_VAL_NX90_mtgy_op_x32 0x00000000U

#define MSK_NX90_mtgy_op_x32_val         0xffffffffU
#define SRT_NX90_mtgy_op_x32_val         0
#define DFLT_VAL_NX90_mtgy_op_x32_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x32_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x32': */
#define MSK_USED_BITS_NX90_mtgy_op_x32 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x32_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X32_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x32_val; /* data bits 1055..1024 */
} NX90_MTGY_OP_X32_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X32_BIT_T bf;
} NX90_MTGY_OP_X32_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x33 */
/* => MWMM operand X register 33 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x33  0x00001C84U
#define Adr_NX90_mtgy_mtgy_op_x33 0xFF083C84U
#define Adr_NX90_mtgy_op_x33      0xFF083C84U
#define DFLT_VAL_NX90_mtgy_op_x33 0x00000000U

#define MSK_NX90_mtgy_op_x33_val         0xffffffffU
#define SRT_NX90_mtgy_op_x33_val         0
#define DFLT_VAL_NX90_mtgy_op_x33_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x33_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x33': */
#define MSK_USED_BITS_NX90_mtgy_op_x33 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x33_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X33_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x33_val; /* data bits 1087..1056 */
} NX90_MTGY_OP_X33_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X33_BIT_T bf;
} NX90_MTGY_OP_X33_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x34 */
/* => MWMM operand X register 34 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x34  0x00001C88U
#define Adr_NX90_mtgy_mtgy_op_x34 0xFF083C88U
#define Adr_NX90_mtgy_op_x34      0xFF083C88U
#define DFLT_VAL_NX90_mtgy_op_x34 0x00000000U

#define MSK_NX90_mtgy_op_x34_val         0xffffffffU
#define SRT_NX90_mtgy_op_x34_val         0
#define DFLT_VAL_NX90_mtgy_op_x34_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x34_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x34': */
#define MSK_USED_BITS_NX90_mtgy_op_x34 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x34_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X34_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x34_val; /* data bits 1119..1088 */
} NX90_MTGY_OP_X34_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X34_BIT_T bf;
} NX90_MTGY_OP_X34_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x35 */
/* => MWMM operand X register 35 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x35  0x00001C8CU
#define Adr_NX90_mtgy_mtgy_op_x35 0xFF083C8CU
#define Adr_NX90_mtgy_op_x35      0xFF083C8CU
#define DFLT_VAL_NX90_mtgy_op_x35 0x00000000U

#define MSK_NX90_mtgy_op_x35_val         0xffffffffU
#define SRT_NX90_mtgy_op_x35_val         0
#define DFLT_VAL_NX90_mtgy_op_x35_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x35_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x35': */
#define MSK_USED_BITS_NX90_mtgy_op_x35 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x35_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X35_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x35_val; /* data bits 1151..1120 */
} NX90_MTGY_OP_X35_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X35_BIT_T bf;
} NX90_MTGY_OP_X35_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x36 */
/* => MWMM operand X register 36 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x36  0x00001C90U
#define Adr_NX90_mtgy_mtgy_op_x36 0xFF083C90U
#define Adr_NX90_mtgy_op_x36      0xFF083C90U
#define DFLT_VAL_NX90_mtgy_op_x36 0x00000000U

#define MSK_NX90_mtgy_op_x36_val         0xffffffffU
#define SRT_NX90_mtgy_op_x36_val         0
#define DFLT_VAL_NX90_mtgy_op_x36_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x36_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x36': */
#define MSK_USED_BITS_NX90_mtgy_op_x36 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x36_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X36_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x36_val; /* data bits 1183..1152 */
} NX90_MTGY_OP_X36_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X36_BIT_T bf;
} NX90_MTGY_OP_X36_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x37 */
/* => MWMM operand X register 37 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x37  0x00001C94U
#define Adr_NX90_mtgy_mtgy_op_x37 0xFF083C94U
#define Adr_NX90_mtgy_op_x37      0xFF083C94U
#define DFLT_VAL_NX90_mtgy_op_x37 0x00000000U

#define MSK_NX90_mtgy_op_x37_val         0xffffffffU
#define SRT_NX90_mtgy_op_x37_val         0
#define DFLT_VAL_NX90_mtgy_op_x37_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x37_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x37': */
#define MSK_USED_BITS_NX90_mtgy_op_x37 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x37_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X37_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x37_val; /* data bits 1215..1184 */
} NX90_MTGY_OP_X37_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X37_BIT_T bf;
} NX90_MTGY_OP_X37_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x38 */
/* => MWMM operand X register 38 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x38  0x00001C98U
#define Adr_NX90_mtgy_mtgy_op_x38 0xFF083C98U
#define Adr_NX90_mtgy_op_x38      0xFF083C98U
#define DFLT_VAL_NX90_mtgy_op_x38 0x00000000U

#define MSK_NX90_mtgy_op_x38_val         0xffffffffU
#define SRT_NX90_mtgy_op_x38_val         0
#define DFLT_VAL_NX90_mtgy_op_x38_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x38_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x38': */
#define MSK_USED_BITS_NX90_mtgy_op_x38 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x38_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X38_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x38_val; /* data bits 1247..1216 */
} NX90_MTGY_OP_X38_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X38_BIT_T bf;
} NX90_MTGY_OP_X38_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x39 */
/* => MWMM operand X register 39 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x39  0x00001C9CU
#define Adr_NX90_mtgy_mtgy_op_x39 0xFF083C9CU
#define Adr_NX90_mtgy_op_x39      0xFF083C9CU
#define DFLT_VAL_NX90_mtgy_op_x39 0x00000000U

#define MSK_NX90_mtgy_op_x39_val         0xffffffffU
#define SRT_NX90_mtgy_op_x39_val         0
#define DFLT_VAL_NX90_mtgy_op_x39_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x39_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x39': */
#define MSK_USED_BITS_NX90_mtgy_op_x39 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x39_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X39_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x39_val; /* data bits 1279..1248 */
} NX90_MTGY_OP_X39_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X39_BIT_T bf;
} NX90_MTGY_OP_X39_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x40 */
/* => MWMM operand X register 40 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x40  0x00001CA0U
#define Adr_NX90_mtgy_mtgy_op_x40 0xFF083CA0U
#define Adr_NX90_mtgy_op_x40      0xFF083CA0U
#define DFLT_VAL_NX90_mtgy_op_x40 0x00000000U

#define MSK_NX90_mtgy_op_x40_val         0xffffffffU
#define SRT_NX90_mtgy_op_x40_val         0
#define DFLT_VAL_NX90_mtgy_op_x40_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x40_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x40': */
#define MSK_USED_BITS_NX90_mtgy_op_x40 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x40_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X40_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x40_val; /* data bits 1311..1280 */
} NX90_MTGY_OP_X40_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X40_BIT_T bf;
} NX90_MTGY_OP_X40_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x41 */
/* => MWMM operand X register 41 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x41  0x00001CA4U
#define Adr_NX90_mtgy_mtgy_op_x41 0xFF083CA4U
#define Adr_NX90_mtgy_op_x41      0xFF083CA4U
#define DFLT_VAL_NX90_mtgy_op_x41 0x00000000U

#define MSK_NX90_mtgy_op_x41_val         0xffffffffU
#define SRT_NX90_mtgy_op_x41_val         0
#define DFLT_VAL_NX90_mtgy_op_x41_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x41_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x41': */
#define MSK_USED_BITS_NX90_mtgy_op_x41 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x41_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X41_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x41_val; /* data bits 1343..1312 */
} NX90_MTGY_OP_X41_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X41_BIT_T bf;
} NX90_MTGY_OP_X41_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x42 */
/* => MWMM operand X register 42 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x42  0x00001CA8U
#define Adr_NX90_mtgy_mtgy_op_x42 0xFF083CA8U
#define Adr_NX90_mtgy_op_x42      0xFF083CA8U
#define DFLT_VAL_NX90_mtgy_op_x42 0x00000000U

#define MSK_NX90_mtgy_op_x42_val         0xffffffffU
#define SRT_NX90_mtgy_op_x42_val         0
#define DFLT_VAL_NX90_mtgy_op_x42_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x42_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x42': */
#define MSK_USED_BITS_NX90_mtgy_op_x42 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x42_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X42_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x42_val; /* data bits 1375..1344 */
} NX90_MTGY_OP_X42_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X42_BIT_T bf;
} NX90_MTGY_OP_X42_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x43 */
/* => MWMM operand X register 43 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x43  0x00001CACU
#define Adr_NX90_mtgy_mtgy_op_x43 0xFF083CACU
#define Adr_NX90_mtgy_op_x43      0xFF083CACU
#define DFLT_VAL_NX90_mtgy_op_x43 0x00000000U

#define MSK_NX90_mtgy_op_x43_val         0xffffffffU
#define SRT_NX90_mtgy_op_x43_val         0
#define DFLT_VAL_NX90_mtgy_op_x43_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x43_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x43': */
#define MSK_USED_BITS_NX90_mtgy_op_x43 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x43_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X43_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x43_val; /* data bits 1407..1376 */
} NX90_MTGY_OP_X43_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X43_BIT_T bf;
} NX90_MTGY_OP_X43_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x44 */
/* => MWMM operand X register 44 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x44  0x00001CB0U
#define Adr_NX90_mtgy_mtgy_op_x44 0xFF083CB0U
#define Adr_NX90_mtgy_op_x44      0xFF083CB0U
#define DFLT_VAL_NX90_mtgy_op_x44 0x00000000U

#define MSK_NX90_mtgy_op_x44_val         0xffffffffU
#define SRT_NX90_mtgy_op_x44_val         0
#define DFLT_VAL_NX90_mtgy_op_x44_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x44_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x44': */
#define MSK_USED_BITS_NX90_mtgy_op_x44 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x44_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X44_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x44_val; /* data bits 1439..1408 */
} NX90_MTGY_OP_X44_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X44_BIT_T bf;
} NX90_MTGY_OP_X44_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x45 */
/* => MWMM operand X register 45 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x45  0x00001CB4U
#define Adr_NX90_mtgy_mtgy_op_x45 0xFF083CB4U
#define Adr_NX90_mtgy_op_x45      0xFF083CB4U
#define DFLT_VAL_NX90_mtgy_op_x45 0x00000000U

#define MSK_NX90_mtgy_op_x45_val         0xffffffffU
#define SRT_NX90_mtgy_op_x45_val         0
#define DFLT_VAL_NX90_mtgy_op_x45_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x45_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x45': */
#define MSK_USED_BITS_NX90_mtgy_op_x45 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x45_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X45_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x45_val; /* data bits 1471..1440 */
} NX90_MTGY_OP_X45_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X45_BIT_T bf;
} NX90_MTGY_OP_X45_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x46 */
/* => MWMM operand X register 46 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x46  0x00001CB8U
#define Adr_NX90_mtgy_mtgy_op_x46 0xFF083CB8U
#define Adr_NX90_mtgy_op_x46      0xFF083CB8U
#define DFLT_VAL_NX90_mtgy_op_x46 0x00000000U

#define MSK_NX90_mtgy_op_x46_val         0xffffffffU
#define SRT_NX90_mtgy_op_x46_val         0
#define DFLT_VAL_NX90_mtgy_op_x46_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x46_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x46': */
#define MSK_USED_BITS_NX90_mtgy_op_x46 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x46_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X46_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x46_val; /* data bits 1503..1472 */
} NX90_MTGY_OP_X46_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X46_BIT_T bf;
} NX90_MTGY_OP_X46_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x47 */
/* => MWMM operand X register 47 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x47  0x00001CBCU
#define Adr_NX90_mtgy_mtgy_op_x47 0xFF083CBCU
#define Adr_NX90_mtgy_op_x47      0xFF083CBCU
#define DFLT_VAL_NX90_mtgy_op_x47 0x00000000U

#define MSK_NX90_mtgy_op_x47_val         0xffffffffU
#define SRT_NX90_mtgy_op_x47_val         0
#define DFLT_VAL_NX90_mtgy_op_x47_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x47_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x47': */
#define MSK_USED_BITS_NX90_mtgy_op_x47 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x47_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X47_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x47_val; /* data bits 1535..1504 */
} NX90_MTGY_OP_X47_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X47_BIT_T bf;
} NX90_MTGY_OP_X47_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x48 */
/* => MWMM operand X register 48 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x48  0x00001CC0U
#define Adr_NX90_mtgy_mtgy_op_x48 0xFF083CC0U
#define Adr_NX90_mtgy_op_x48      0xFF083CC0U
#define DFLT_VAL_NX90_mtgy_op_x48 0x00000000U

#define MSK_NX90_mtgy_op_x48_val         0xffffffffU
#define SRT_NX90_mtgy_op_x48_val         0
#define DFLT_VAL_NX90_mtgy_op_x48_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x48_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x48': */
#define MSK_USED_BITS_NX90_mtgy_op_x48 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x48_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X48_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x48_val; /* data bits 1567..1536 */
} NX90_MTGY_OP_X48_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X48_BIT_T bf;
} NX90_MTGY_OP_X48_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x49 */
/* => MWMM operand X register 49 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x49  0x00001CC4U
#define Adr_NX90_mtgy_mtgy_op_x49 0xFF083CC4U
#define Adr_NX90_mtgy_op_x49      0xFF083CC4U
#define DFLT_VAL_NX90_mtgy_op_x49 0x00000000U

#define MSK_NX90_mtgy_op_x49_val         0xffffffffU
#define SRT_NX90_mtgy_op_x49_val         0
#define DFLT_VAL_NX90_mtgy_op_x49_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x49_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x49': */
#define MSK_USED_BITS_NX90_mtgy_op_x49 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x49_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X49_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x49_val; /* data bits 1599..1568 */
} NX90_MTGY_OP_X49_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X49_BIT_T bf;
} NX90_MTGY_OP_X49_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x50 */
/* => MWMM operand X register 50 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x50  0x00001CC8U
#define Adr_NX90_mtgy_mtgy_op_x50 0xFF083CC8U
#define Adr_NX90_mtgy_op_x50      0xFF083CC8U
#define DFLT_VAL_NX90_mtgy_op_x50 0x00000000U

#define MSK_NX90_mtgy_op_x50_val         0xffffffffU
#define SRT_NX90_mtgy_op_x50_val         0
#define DFLT_VAL_NX90_mtgy_op_x50_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x50_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x50': */
#define MSK_USED_BITS_NX90_mtgy_op_x50 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x50_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X50_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x50_val; /* data bits 1631..1600 */
} NX90_MTGY_OP_X50_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X50_BIT_T bf;
} NX90_MTGY_OP_X50_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x51 */
/* => MWMM operand X register 51 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x51  0x00001CCCU
#define Adr_NX90_mtgy_mtgy_op_x51 0xFF083CCCU
#define Adr_NX90_mtgy_op_x51      0xFF083CCCU
#define DFLT_VAL_NX90_mtgy_op_x51 0x00000000U

#define MSK_NX90_mtgy_op_x51_val         0xffffffffU
#define SRT_NX90_mtgy_op_x51_val         0
#define DFLT_VAL_NX90_mtgy_op_x51_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x51_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x51': */
#define MSK_USED_BITS_NX90_mtgy_op_x51 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x51_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X51_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x51_val; /* data bits 1663..1632 */
} NX90_MTGY_OP_X51_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X51_BIT_T bf;
} NX90_MTGY_OP_X51_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x52 */
/* => MWMM operand X register 52 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x52  0x00001CD0U
#define Adr_NX90_mtgy_mtgy_op_x52 0xFF083CD0U
#define Adr_NX90_mtgy_op_x52      0xFF083CD0U
#define DFLT_VAL_NX90_mtgy_op_x52 0x00000000U

#define MSK_NX90_mtgy_op_x52_val         0xffffffffU
#define SRT_NX90_mtgy_op_x52_val         0
#define DFLT_VAL_NX90_mtgy_op_x52_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x52_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x52': */
#define MSK_USED_BITS_NX90_mtgy_op_x52 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x52_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X52_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x52_val; /* data bits 1695..1664 */
} NX90_MTGY_OP_X52_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X52_BIT_T bf;
} NX90_MTGY_OP_X52_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x53 */
/* => MWMM operand X register 53 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x53  0x00001CD4U
#define Adr_NX90_mtgy_mtgy_op_x53 0xFF083CD4U
#define Adr_NX90_mtgy_op_x53      0xFF083CD4U
#define DFLT_VAL_NX90_mtgy_op_x53 0x00000000U

#define MSK_NX90_mtgy_op_x53_val         0xffffffffU
#define SRT_NX90_mtgy_op_x53_val         0
#define DFLT_VAL_NX90_mtgy_op_x53_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x53_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x53': */
#define MSK_USED_BITS_NX90_mtgy_op_x53 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x53_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X53_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x53_val; /* data bits 1727..1696 */
} NX90_MTGY_OP_X53_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X53_BIT_T bf;
} NX90_MTGY_OP_X53_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x54 */
/* => MWMM operand X register 54 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x54  0x00001CD8U
#define Adr_NX90_mtgy_mtgy_op_x54 0xFF083CD8U
#define Adr_NX90_mtgy_op_x54      0xFF083CD8U
#define DFLT_VAL_NX90_mtgy_op_x54 0x00000000U

#define MSK_NX90_mtgy_op_x54_val         0xffffffffU
#define SRT_NX90_mtgy_op_x54_val         0
#define DFLT_VAL_NX90_mtgy_op_x54_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x54_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x54': */
#define MSK_USED_BITS_NX90_mtgy_op_x54 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x54_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X54_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x54_val; /* data bits 1759..1728 */
} NX90_MTGY_OP_X54_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X54_BIT_T bf;
} NX90_MTGY_OP_X54_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x55 */
/* => MWMM operand X register 55 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x55  0x00001CDCU
#define Adr_NX90_mtgy_mtgy_op_x55 0xFF083CDCU
#define Adr_NX90_mtgy_op_x55      0xFF083CDCU
#define DFLT_VAL_NX90_mtgy_op_x55 0x00000000U

#define MSK_NX90_mtgy_op_x55_val         0xffffffffU
#define SRT_NX90_mtgy_op_x55_val         0
#define DFLT_VAL_NX90_mtgy_op_x55_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x55_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x55': */
#define MSK_USED_BITS_NX90_mtgy_op_x55 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x55_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X55_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x55_val; /* data bits 1791..1760 */
} NX90_MTGY_OP_X55_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X55_BIT_T bf;
} NX90_MTGY_OP_X55_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x56 */
/* => MWMM operand X register 56 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x56  0x00001CE0U
#define Adr_NX90_mtgy_mtgy_op_x56 0xFF083CE0U
#define Adr_NX90_mtgy_op_x56      0xFF083CE0U
#define DFLT_VAL_NX90_mtgy_op_x56 0x00000000U

#define MSK_NX90_mtgy_op_x56_val         0xffffffffU
#define SRT_NX90_mtgy_op_x56_val         0
#define DFLT_VAL_NX90_mtgy_op_x56_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x56_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x56': */
#define MSK_USED_BITS_NX90_mtgy_op_x56 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x56_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X56_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x56_val; /* data bits 1823..1792 */
} NX90_MTGY_OP_X56_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X56_BIT_T bf;
} NX90_MTGY_OP_X56_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x57 */
/* => MWMM operand X register 57 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x57  0x00001CE4U
#define Adr_NX90_mtgy_mtgy_op_x57 0xFF083CE4U
#define Adr_NX90_mtgy_op_x57      0xFF083CE4U
#define DFLT_VAL_NX90_mtgy_op_x57 0x00000000U

#define MSK_NX90_mtgy_op_x57_val         0xffffffffU
#define SRT_NX90_mtgy_op_x57_val         0
#define DFLT_VAL_NX90_mtgy_op_x57_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x57_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x57': */
#define MSK_USED_BITS_NX90_mtgy_op_x57 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x57_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X57_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x57_val; /* data bits 1855..1824 */
} NX90_MTGY_OP_X57_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X57_BIT_T bf;
} NX90_MTGY_OP_X57_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x58 */
/* => MWMM operand X register 58 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x58  0x00001CE8U
#define Adr_NX90_mtgy_mtgy_op_x58 0xFF083CE8U
#define Adr_NX90_mtgy_op_x58      0xFF083CE8U
#define DFLT_VAL_NX90_mtgy_op_x58 0x00000000U

#define MSK_NX90_mtgy_op_x58_val         0xffffffffU
#define SRT_NX90_mtgy_op_x58_val         0
#define DFLT_VAL_NX90_mtgy_op_x58_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x58_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x58': */
#define MSK_USED_BITS_NX90_mtgy_op_x58 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x58_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X58_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x58_val; /* data bits 1887..1856 */
} NX90_MTGY_OP_X58_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X58_BIT_T bf;
} NX90_MTGY_OP_X58_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x59 */
/* => MWMM operand X register 59 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x59  0x00001CECU
#define Adr_NX90_mtgy_mtgy_op_x59 0xFF083CECU
#define Adr_NX90_mtgy_op_x59      0xFF083CECU
#define DFLT_VAL_NX90_mtgy_op_x59 0x00000000U

#define MSK_NX90_mtgy_op_x59_val         0xffffffffU
#define SRT_NX90_mtgy_op_x59_val         0
#define DFLT_VAL_NX90_mtgy_op_x59_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x59_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x59': */
#define MSK_USED_BITS_NX90_mtgy_op_x59 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x59_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X59_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x59_val; /* data bits 1919..1888 */
} NX90_MTGY_OP_X59_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X59_BIT_T bf;
} NX90_MTGY_OP_X59_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x60 */
/* => MWMM operand X register 60 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x60  0x00001CF0U
#define Adr_NX90_mtgy_mtgy_op_x60 0xFF083CF0U
#define Adr_NX90_mtgy_op_x60      0xFF083CF0U
#define DFLT_VAL_NX90_mtgy_op_x60 0x00000000U

#define MSK_NX90_mtgy_op_x60_val         0xffffffffU
#define SRT_NX90_mtgy_op_x60_val         0
#define DFLT_VAL_NX90_mtgy_op_x60_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x60_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x60': */
#define MSK_USED_BITS_NX90_mtgy_op_x60 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x60_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X60_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x60_val; /* data bits 1951..1920 */
} NX90_MTGY_OP_X60_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X60_BIT_T bf;
} NX90_MTGY_OP_X60_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x61 */
/* => MWMM operand X register 61 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x61  0x00001CF4U
#define Adr_NX90_mtgy_mtgy_op_x61 0xFF083CF4U
#define Adr_NX90_mtgy_op_x61      0xFF083CF4U
#define DFLT_VAL_NX90_mtgy_op_x61 0x00000000U

#define MSK_NX90_mtgy_op_x61_val         0xffffffffU
#define SRT_NX90_mtgy_op_x61_val         0
#define DFLT_VAL_NX90_mtgy_op_x61_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x61_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x61': */
#define MSK_USED_BITS_NX90_mtgy_op_x61 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x61_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X61_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x61_val; /* data bits 1983..1952 */
} NX90_MTGY_OP_X61_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X61_BIT_T bf;
} NX90_MTGY_OP_X61_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x62 */
/* => MWMM operand X register 62 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x62  0x00001CF8U
#define Adr_NX90_mtgy_mtgy_op_x62 0xFF083CF8U
#define Adr_NX90_mtgy_op_x62      0xFF083CF8U
#define DFLT_VAL_NX90_mtgy_op_x62 0x00000000U

#define MSK_NX90_mtgy_op_x62_val         0xffffffffU
#define SRT_NX90_mtgy_op_x62_val         0
#define DFLT_VAL_NX90_mtgy_op_x62_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x62_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x62': */
#define MSK_USED_BITS_NX90_mtgy_op_x62 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x62_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X62_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x62_val; /* data bits 2015..1984 */
} NX90_MTGY_OP_X62_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X62_BIT_T bf;
} NX90_MTGY_OP_X62_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x63 */
/* => MWMM operand X register 63 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x63  0x00001CFCU
#define Adr_NX90_mtgy_mtgy_op_x63 0xFF083CFCU
#define Adr_NX90_mtgy_op_x63      0xFF083CFCU
#define DFLT_VAL_NX90_mtgy_op_x63 0x00000000U

#define MSK_NX90_mtgy_op_x63_val         0xffffffffU
#define SRT_NX90_mtgy_op_x63_val         0
#define DFLT_VAL_NX90_mtgy_op_x63_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x63_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x63': */
#define MSK_USED_BITS_NX90_mtgy_op_x63 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x63_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X63_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x63_val; /* data bits 2047..2016 */
} NX90_MTGY_OP_X63_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X63_BIT_T bf;
} NX90_MTGY_OP_X63_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x64 */
/* => MWMM operand X register 64 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x64  0x00001D00U
#define Adr_NX90_mtgy_mtgy_op_x64 0xFF083D00U
#define Adr_NX90_mtgy_op_x64      0xFF083D00U
#define DFLT_VAL_NX90_mtgy_op_x64 0x00000000U

#define MSK_NX90_mtgy_op_x64_val         0xffffffffU
#define SRT_NX90_mtgy_op_x64_val         0
#define DFLT_VAL_NX90_mtgy_op_x64_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x64_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x64': */
#define MSK_USED_BITS_NX90_mtgy_op_x64 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x64_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X64_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x64_val; /* data bits 2079..2048 */
} NX90_MTGY_OP_X64_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X64_BIT_T bf;
} NX90_MTGY_OP_X64_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x65 */
/* => MWMM operand X register 65 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x65  0x00001D04U
#define Adr_NX90_mtgy_mtgy_op_x65 0xFF083D04U
#define Adr_NX90_mtgy_op_x65      0xFF083D04U
#define DFLT_VAL_NX90_mtgy_op_x65 0x00000000U

#define MSK_NX90_mtgy_op_x65_val         0xffffffffU
#define SRT_NX90_mtgy_op_x65_val         0
#define DFLT_VAL_NX90_mtgy_op_x65_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x65_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x65': */
#define MSK_USED_BITS_NX90_mtgy_op_x65 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x65_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X65_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x65_val; /* data bits 2111..2080 */
} NX90_MTGY_OP_X65_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X65_BIT_T bf;
} NX90_MTGY_OP_X65_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x66 */
/* => MWMM operand X register 66 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x66  0x00001D08U
#define Adr_NX90_mtgy_mtgy_op_x66 0xFF083D08U
#define Adr_NX90_mtgy_op_x66      0xFF083D08U
#define DFLT_VAL_NX90_mtgy_op_x66 0x00000000U

#define MSK_NX90_mtgy_op_x66_val         0xffffffffU
#define SRT_NX90_mtgy_op_x66_val         0
#define DFLT_VAL_NX90_mtgy_op_x66_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x66_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x66': */
#define MSK_USED_BITS_NX90_mtgy_op_x66 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x66_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X66_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x66_val; /* data bits 2143..2112 */
} NX90_MTGY_OP_X66_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X66_BIT_T bf;
} NX90_MTGY_OP_X66_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x67 */
/* => MWMM operand X register 67 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x67  0x00001D0CU
#define Adr_NX90_mtgy_mtgy_op_x67 0xFF083D0CU
#define Adr_NX90_mtgy_op_x67      0xFF083D0CU
#define DFLT_VAL_NX90_mtgy_op_x67 0x00000000U

#define MSK_NX90_mtgy_op_x67_val         0xffffffffU
#define SRT_NX90_mtgy_op_x67_val         0
#define DFLT_VAL_NX90_mtgy_op_x67_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x67_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x67': */
#define MSK_USED_BITS_NX90_mtgy_op_x67 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x67_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X67_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x67_val; /* data bits 2175..2144 */
} NX90_MTGY_OP_X67_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X67_BIT_T bf;
} NX90_MTGY_OP_X67_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x68 */
/* => MWMM operand X register 68 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x68  0x00001D10U
#define Adr_NX90_mtgy_mtgy_op_x68 0xFF083D10U
#define Adr_NX90_mtgy_op_x68      0xFF083D10U
#define DFLT_VAL_NX90_mtgy_op_x68 0x00000000U

#define MSK_NX90_mtgy_op_x68_val         0xffffffffU
#define SRT_NX90_mtgy_op_x68_val         0
#define DFLT_VAL_NX90_mtgy_op_x68_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x68_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x68': */
#define MSK_USED_BITS_NX90_mtgy_op_x68 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x68_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X68_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x68_val; /* data bits 2207..2176 */
} NX90_MTGY_OP_X68_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X68_BIT_T bf;
} NX90_MTGY_OP_X68_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x69 */
/* => MWMM operand X register 69 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x69  0x00001D14U
#define Adr_NX90_mtgy_mtgy_op_x69 0xFF083D14U
#define Adr_NX90_mtgy_op_x69      0xFF083D14U
#define DFLT_VAL_NX90_mtgy_op_x69 0x00000000U

#define MSK_NX90_mtgy_op_x69_val         0xffffffffU
#define SRT_NX90_mtgy_op_x69_val         0
#define DFLT_VAL_NX90_mtgy_op_x69_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x69_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x69': */
#define MSK_USED_BITS_NX90_mtgy_op_x69 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x69_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X69_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x69_val; /* data bits 2239..2208 */
} NX90_MTGY_OP_X69_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X69_BIT_T bf;
} NX90_MTGY_OP_X69_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x70 */
/* => MWMM operand X register 70 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x70  0x00001D18U
#define Adr_NX90_mtgy_mtgy_op_x70 0xFF083D18U
#define Adr_NX90_mtgy_op_x70      0xFF083D18U
#define DFLT_VAL_NX90_mtgy_op_x70 0x00000000U

#define MSK_NX90_mtgy_op_x70_val         0xffffffffU
#define SRT_NX90_mtgy_op_x70_val         0
#define DFLT_VAL_NX90_mtgy_op_x70_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x70_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x70': */
#define MSK_USED_BITS_NX90_mtgy_op_x70 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x70_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X70_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x70_val; /* data bits 2271..2240 */
} NX90_MTGY_OP_X70_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X70_BIT_T bf;
} NX90_MTGY_OP_X70_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x71 */
/* => MWMM operand X register 71 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x71  0x00001D1CU
#define Adr_NX90_mtgy_mtgy_op_x71 0xFF083D1CU
#define Adr_NX90_mtgy_op_x71      0xFF083D1CU
#define DFLT_VAL_NX90_mtgy_op_x71 0x00000000U

#define MSK_NX90_mtgy_op_x71_val         0xffffffffU
#define SRT_NX90_mtgy_op_x71_val         0
#define DFLT_VAL_NX90_mtgy_op_x71_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x71_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x71': */
#define MSK_USED_BITS_NX90_mtgy_op_x71 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x71_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X71_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x71_val; /* data bits 2303..2272 */
} NX90_MTGY_OP_X71_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X71_BIT_T bf;
} NX90_MTGY_OP_X71_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x72 */
/* => MWMM operand X register 72 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x72  0x00001D20U
#define Adr_NX90_mtgy_mtgy_op_x72 0xFF083D20U
#define Adr_NX90_mtgy_op_x72      0xFF083D20U
#define DFLT_VAL_NX90_mtgy_op_x72 0x00000000U

#define MSK_NX90_mtgy_op_x72_val         0xffffffffU
#define SRT_NX90_mtgy_op_x72_val         0
#define DFLT_VAL_NX90_mtgy_op_x72_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x72_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x72': */
#define MSK_USED_BITS_NX90_mtgy_op_x72 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x72_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X72_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x72_val; /* data bits 2335..2304 */
} NX90_MTGY_OP_X72_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X72_BIT_T bf;
} NX90_MTGY_OP_X72_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x73 */
/* => MWMM operand X register 73 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x73  0x00001D24U
#define Adr_NX90_mtgy_mtgy_op_x73 0xFF083D24U
#define Adr_NX90_mtgy_op_x73      0xFF083D24U
#define DFLT_VAL_NX90_mtgy_op_x73 0x00000000U

#define MSK_NX90_mtgy_op_x73_val         0xffffffffU
#define SRT_NX90_mtgy_op_x73_val         0
#define DFLT_VAL_NX90_mtgy_op_x73_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x73_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x73': */
#define MSK_USED_BITS_NX90_mtgy_op_x73 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x73_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X73_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x73_val; /* data bits 2367..2336 */
} NX90_MTGY_OP_X73_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X73_BIT_T bf;
} NX90_MTGY_OP_X73_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x74 */
/* => MWMM operand X register 74 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x74  0x00001D28U
#define Adr_NX90_mtgy_mtgy_op_x74 0xFF083D28U
#define Adr_NX90_mtgy_op_x74      0xFF083D28U
#define DFLT_VAL_NX90_mtgy_op_x74 0x00000000U

#define MSK_NX90_mtgy_op_x74_val         0xffffffffU
#define SRT_NX90_mtgy_op_x74_val         0
#define DFLT_VAL_NX90_mtgy_op_x74_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x74_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x74': */
#define MSK_USED_BITS_NX90_mtgy_op_x74 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x74_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X74_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x74_val; /* data bits 2399..2368 */
} NX90_MTGY_OP_X74_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X74_BIT_T bf;
} NX90_MTGY_OP_X74_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x75 */
/* => MWMM operand X register 75 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x75  0x00001D2CU
#define Adr_NX90_mtgy_mtgy_op_x75 0xFF083D2CU
#define Adr_NX90_mtgy_op_x75      0xFF083D2CU
#define DFLT_VAL_NX90_mtgy_op_x75 0x00000000U

#define MSK_NX90_mtgy_op_x75_val         0xffffffffU
#define SRT_NX90_mtgy_op_x75_val         0
#define DFLT_VAL_NX90_mtgy_op_x75_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x75_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x75': */
#define MSK_USED_BITS_NX90_mtgy_op_x75 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x75_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X75_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x75_val; /* data bits 2431..2400 */
} NX90_MTGY_OP_X75_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X75_BIT_T bf;
} NX90_MTGY_OP_X75_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x76 */
/* => MWMM operand X register 76 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x76  0x00001D30U
#define Adr_NX90_mtgy_mtgy_op_x76 0xFF083D30U
#define Adr_NX90_mtgy_op_x76      0xFF083D30U
#define DFLT_VAL_NX90_mtgy_op_x76 0x00000000U

#define MSK_NX90_mtgy_op_x76_val         0xffffffffU
#define SRT_NX90_mtgy_op_x76_val         0
#define DFLT_VAL_NX90_mtgy_op_x76_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x76_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x76': */
#define MSK_USED_BITS_NX90_mtgy_op_x76 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x76_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X76_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x76_val; /* data bits 2463..2432 */
} NX90_MTGY_OP_X76_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X76_BIT_T bf;
} NX90_MTGY_OP_X76_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x77 */
/* => MWMM operand X register 77 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x77  0x00001D34U
#define Adr_NX90_mtgy_mtgy_op_x77 0xFF083D34U
#define Adr_NX90_mtgy_op_x77      0xFF083D34U
#define DFLT_VAL_NX90_mtgy_op_x77 0x00000000U

#define MSK_NX90_mtgy_op_x77_val         0xffffffffU
#define SRT_NX90_mtgy_op_x77_val         0
#define DFLT_VAL_NX90_mtgy_op_x77_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x77_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x77': */
#define MSK_USED_BITS_NX90_mtgy_op_x77 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x77_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X77_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x77_val; /* data bits 2495..2464 */
} NX90_MTGY_OP_X77_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X77_BIT_T bf;
} NX90_MTGY_OP_X77_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x78 */
/* => MWMM operand X register 78 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x78  0x00001D38U
#define Adr_NX90_mtgy_mtgy_op_x78 0xFF083D38U
#define Adr_NX90_mtgy_op_x78      0xFF083D38U
#define DFLT_VAL_NX90_mtgy_op_x78 0x00000000U

#define MSK_NX90_mtgy_op_x78_val         0xffffffffU
#define SRT_NX90_mtgy_op_x78_val         0
#define DFLT_VAL_NX90_mtgy_op_x78_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x78_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x78': */
#define MSK_USED_BITS_NX90_mtgy_op_x78 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x78_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X78_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x78_val; /* data bits 2527..2496 */
} NX90_MTGY_OP_X78_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X78_BIT_T bf;
} NX90_MTGY_OP_X78_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x79 */
/* => MWMM operand X register 79 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x79  0x00001D3CU
#define Adr_NX90_mtgy_mtgy_op_x79 0xFF083D3CU
#define Adr_NX90_mtgy_op_x79      0xFF083D3CU
#define DFLT_VAL_NX90_mtgy_op_x79 0x00000000U

#define MSK_NX90_mtgy_op_x79_val         0xffffffffU
#define SRT_NX90_mtgy_op_x79_val         0
#define DFLT_VAL_NX90_mtgy_op_x79_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x79_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x79': */
#define MSK_USED_BITS_NX90_mtgy_op_x79 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x79_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X79_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x79_val; /* data bits 2559..2528 */
} NX90_MTGY_OP_X79_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X79_BIT_T bf;
} NX90_MTGY_OP_X79_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x80 */
/* => MWMM operand X register 80 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x80  0x00001D40U
#define Adr_NX90_mtgy_mtgy_op_x80 0xFF083D40U
#define Adr_NX90_mtgy_op_x80      0xFF083D40U
#define DFLT_VAL_NX90_mtgy_op_x80 0x00000000U

#define MSK_NX90_mtgy_op_x80_val         0xffffffffU
#define SRT_NX90_mtgy_op_x80_val         0
#define DFLT_VAL_NX90_mtgy_op_x80_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x80_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x80': */
#define MSK_USED_BITS_NX90_mtgy_op_x80 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x80_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X80_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x80_val; /* data bits 2591..2560 */
} NX90_MTGY_OP_X80_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X80_BIT_T bf;
} NX90_MTGY_OP_X80_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x81 */
/* => MWMM operand X register 81 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x81  0x00001D44U
#define Adr_NX90_mtgy_mtgy_op_x81 0xFF083D44U
#define Adr_NX90_mtgy_op_x81      0xFF083D44U
#define DFLT_VAL_NX90_mtgy_op_x81 0x00000000U

#define MSK_NX90_mtgy_op_x81_val         0xffffffffU
#define SRT_NX90_mtgy_op_x81_val         0
#define DFLT_VAL_NX90_mtgy_op_x81_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x81_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x81': */
#define MSK_USED_BITS_NX90_mtgy_op_x81 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x81_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X81_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x81_val; /* data bits 2623..2592 */
} NX90_MTGY_OP_X81_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X81_BIT_T bf;
} NX90_MTGY_OP_X81_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x82 */
/* => MWMM operand X register 82 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x82  0x00001D48U
#define Adr_NX90_mtgy_mtgy_op_x82 0xFF083D48U
#define Adr_NX90_mtgy_op_x82      0xFF083D48U
#define DFLT_VAL_NX90_mtgy_op_x82 0x00000000U

#define MSK_NX90_mtgy_op_x82_val         0xffffffffU
#define SRT_NX90_mtgy_op_x82_val         0
#define DFLT_VAL_NX90_mtgy_op_x82_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x82_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x82': */
#define MSK_USED_BITS_NX90_mtgy_op_x82 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x82_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X82_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x82_val; /* data bits 2655..2624 */
} NX90_MTGY_OP_X82_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X82_BIT_T bf;
} NX90_MTGY_OP_X82_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x83 */
/* => MWMM operand X register 83 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x83  0x00001D4CU
#define Adr_NX90_mtgy_mtgy_op_x83 0xFF083D4CU
#define Adr_NX90_mtgy_op_x83      0xFF083D4CU
#define DFLT_VAL_NX90_mtgy_op_x83 0x00000000U

#define MSK_NX90_mtgy_op_x83_val         0xffffffffU
#define SRT_NX90_mtgy_op_x83_val         0
#define DFLT_VAL_NX90_mtgy_op_x83_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x83_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x83': */
#define MSK_USED_BITS_NX90_mtgy_op_x83 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x83_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X83_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x83_val; /* data bits 2687..2656 */
} NX90_MTGY_OP_X83_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X83_BIT_T bf;
} NX90_MTGY_OP_X83_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x84 */
/* => MWMM operand X register 84 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x84  0x00001D50U
#define Adr_NX90_mtgy_mtgy_op_x84 0xFF083D50U
#define Adr_NX90_mtgy_op_x84      0xFF083D50U
#define DFLT_VAL_NX90_mtgy_op_x84 0x00000000U

#define MSK_NX90_mtgy_op_x84_val         0xffffffffU
#define SRT_NX90_mtgy_op_x84_val         0
#define DFLT_VAL_NX90_mtgy_op_x84_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x84_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x84': */
#define MSK_USED_BITS_NX90_mtgy_op_x84 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x84_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X84_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x84_val; /* data bits 2719..2688 */
} NX90_MTGY_OP_X84_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X84_BIT_T bf;
} NX90_MTGY_OP_X84_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x85 */
/* => MWMM operand X register 85 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x85  0x00001D54U
#define Adr_NX90_mtgy_mtgy_op_x85 0xFF083D54U
#define Adr_NX90_mtgy_op_x85      0xFF083D54U
#define DFLT_VAL_NX90_mtgy_op_x85 0x00000000U

#define MSK_NX90_mtgy_op_x85_val         0xffffffffU
#define SRT_NX90_mtgy_op_x85_val         0
#define DFLT_VAL_NX90_mtgy_op_x85_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x85_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x85': */
#define MSK_USED_BITS_NX90_mtgy_op_x85 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x85_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X85_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x85_val; /* data bits 2751..2720 */
} NX90_MTGY_OP_X85_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X85_BIT_T bf;
} NX90_MTGY_OP_X85_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x86 */
/* => MWMM operand X register 86 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x86  0x00001D58U
#define Adr_NX90_mtgy_mtgy_op_x86 0xFF083D58U
#define Adr_NX90_mtgy_op_x86      0xFF083D58U
#define DFLT_VAL_NX90_mtgy_op_x86 0x00000000U

#define MSK_NX90_mtgy_op_x86_val         0xffffffffU
#define SRT_NX90_mtgy_op_x86_val         0
#define DFLT_VAL_NX90_mtgy_op_x86_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x86_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x86': */
#define MSK_USED_BITS_NX90_mtgy_op_x86 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x86_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X86_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x86_val; /* data bits 2783..2752 */
} NX90_MTGY_OP_X86_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X86_BIT_T bf;
} NX90_MTGY_OP_X86_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x87 */
/* => MWMM operand X register 87 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x87  0x00001D5CU
#define Adr_NX90_mtgy_mtgy_op_x87 0xFF083D5CU
#define Adr_NX90_mtgy_op_x87      0xFF083D5CU
#define DFLT_VAL_NX90_mtgy_op_x87 0x00000000U

#define MSK_NX90_mtgy_op_x87_val         0xffffffffU
#define SRT_NX90_mtgy_op_x87_val         0
#define DFLT_VAL_NX90_mtgy_op_x87_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x87_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x87': */
#define MSK_USED_BITS_NX90_mtgy_op_x87 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x87_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X87_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x87_val; /* data bits 2815..2784 */
} NX90_MTGY_OP_X87_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X87_BIT_T bf;
} NX90_MTGY_OP_X87_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x88 */
/* => MWMM operand X register 88 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x88  0x00001D60U
#define Adr_NX90_mtgy_mtgy_op_x88 0xFF083D60U
#define Adr_NX90_mtgy_op_x88      0xFF083D60U
#define DFLT_VAL_NX90_mtgy_op_x88 0x00000000U

#define MSK_NX90_mtgy_op_x88_val         0xffffffffU
#define SRT_NX90_mtgy_op_x88_val         0
#define DFLT_VAL_NX90_mtgy_op_x88_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x88_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x88': */
#define MSK_USED_BITS_NX90_mtgy_op_x88 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x88_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X88_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x88_val; /* data bits 2847..2816 */
} NX90_MTGY_OP_X88_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X88_BIT_T bf;
} NX90_MTGY_OP_X88_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x89 */
/* => MWMM operand X register 89 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x89  0x00001D64U
#define Adr_NX90_mtgy_mtgy_op_x89 0xFF083D64U
#define Adr_NX90_mtgy_op_x89      0xFF083D64U
#define DFLT_VAL_NX90_mtgy_op_x89 0x00000000U

#define MSK_NX90_mtgy_op_x89_val         0xffffffffU
#define SRT_NX90_mtgy_op_x89_val         0
#define DFLT_VAL_NX90_mtgy_op_x89_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x89_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x89': */
#define MSK_USED_BITS_NX90_mtgy_op_x89 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x89_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X89_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x89_val; /* data bits 2879..2848 */
} NX90_MTGY_OP_X89_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X89_BIT_T bf;
} NX90_MTGY_OP_X89_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x90 */
/* => MWMM operand X register 90 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x90  0x00001D68U
#define Adr_NX90_mtgy_mtgy_op_x90 0xFF083D68U
#define Adr_NX90_mtgy_op_x90      0xFF083D68U
#define DFLT_VAL_NX90_mtgy_op_x90 0x00000000U

#define MSK_NX90_mtgy_op_x90_val         0xffffffffU
#define SRT_NX90_mtgy_op_x90_val         0
#define DFLT_VAL_NX90_mtgy_op_x90_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x90_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x90': */
#define MSK_USED_BITS_NX90_mtgy_op_x90 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x90_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X90_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x90_val; /* data bits 2911..2880 */
} NX90_MTGY_OP_X90_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X90_BIT_T bf;
} NX90_MTGY_OP_X90_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x91 */
/* => MWMM operand X register 91 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x91  0x00001D6CU
#define Adr_NX90_mtgy_mtgy_op_x91 0xFF083D6CU
#define Adr_NX90_mtgy_op_x91      0xFF083D6CU
#define DFLT_VAL_NX90_mtgy_op_x91 0x00000000U

#define MSK_NX90_mtgy_op_x91_val         0xffffffffU
#define SRT_NX90_mtgy_op_x91_val         0
#define DFLT_VAL_NX90_mtgy_op_x91_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x91_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x91': */
#define MSK_USED_BITS_NX90_mtgy_op_x91 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x91_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X91_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x91_val; /* data bits 2943..2912 */
} NX90_MTGY_OP_X91_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X91_BIT_T bf;
} NX90_MTGY_OP_X91_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x92 */
/* => MWMM operand X register 92 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x92  0x00001D70U
#define Adr_NX90_mtgy_mtgy_op_x92 0xFF083D70U
#define Adr_NX90_mtgy_op_x92      0xFF083D70U
#define DFLT_VAL_NX90_mtgy_op_x92 0x00000000U

#define MSK_NX90_mtgy_op_x92_val         0xffffffffU
#define SRT_NX90_mtgy_op_x92_val         0
#define DFLT_VAL_NX90_mtgy_op_x92_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x92_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x92': */
#define MSK_USED_BITS_NX90_mtgy_op_x92 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x92_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X92_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x92_val; /* data bits 2975..2944 */
} NX90_MTGY_OP_X92_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X92_BIT_T bf;
} NX90_MTGY_OP_X92_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x93 */
/* => MWMM operand X register 93 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x93  0x00001D74U
#define Adr_NX90_mtgy_mtgy_op_x93 0xFF083D74U
#define Adr_NX90_mtgy_op_x93      0xFF083D74U
#define DFLT_VAL_NX90_mtgy_op_x93 0x00000000U

#define MSK_NX90_mtgy_op_x93_val         0xffffffffU
#define SRT_NX90_mtgy_op_x93_val         0
#define DFLT_VAL_NX90_mtgy_op_x93_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x93_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x93': */
#define MSK_USED_BITS_NX90_mtgy_op_x93 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x93_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X93_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x93_val; /* data bits 3007..2976 */
} NX90_MTGY_OP_X93_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X93_BIT_T bf;
} NX90_MTGY_OP_X93_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x94 */
/* => MWMM operand X register 94 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x94  0x00001D78U
#define Adr_NX90_mtgy_mtgy_op_x94 0xFF083D78U
#define Adr_NX90_mtgy_op_x94      0xFF083D78U
#define DFLT_VAL_NX90_mtgy_op_x94 0x00000000U

#define MSK_NX90_mtgy_op_x94_val         0xffffffffU
#define SRT_NX90_mtgy_op_x94_val         0
#define DFLT_VAL_NX90_mtgy_op_x94_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x94_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x94': */
#define MSK_USED_BITS_NX90_mtgy_op_x94 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x94_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X94_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x94_val; /* data bits 3039..3008 */
} NX90_MTGY_OP_X94_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X94_BIT_T bf;
} NX90_MTGY_OP_X94_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x95 */
/* => MWMM operand X register 95 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x95  0x00001D7CU
#define Adr_NX90_mtgy_mtgy_op_x95 0xFF083D7CU
#define Adr_NX90_mtgy_op_x95      0xFF083D7CU
#define DFLT_VAL_NX90_mtgy_op_x95 0x00000000U

#define MSK_NX90_mtgy_op_x95_val         0xffffffffU
#define SRT_NX90_mtgy_op_x95_val         0
#define DFLT_VAL_NX90_mtgy_op_x95_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x95_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x95': */
#define MSK_USED_BITS_NX90_mtgy_op_x95 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x95_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X95_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x95_val; /* data bits 3071..3040 */
} NX90_MTGY_OP_X95_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X95_BIT_T bf;
} NX90_MTGY_OP_X95_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x96 */
/* => MWMM operand X register 96 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x96  0x00001D80U
#define Adr_NX90_mtgy_mtgy_op_x96 0xFF083D80U
#define Adr_NX90_mtgy_op_x96      0xFF083D80U
#define DFLT_VAL_NX90_mtgy_op_x96 0x00000000U

#define MSK_NX90_mtgy_op_x96_val         0xffffffffU
#define SRT_NX90_mtgy_op_x96_val         0
#define DFLT_VAL_NX90_mtgy_op_x96_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x96_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x96': */
#define MSK_USED_BITS_NX90_mtgy_op_x96 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x96_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X96_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x96_val; /* data bits 3103..3072 */
} NX90_MTGY_OP_X96_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X96_BIT_T bf;
} NX90_MTGY_OP_X96_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x97 */
/* => MWMM operand X register 97 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x97  0x00001D84U
#define Adr_NX90_mtgy_mtgy_op_x97 0xFF083D84U
#define Adr_NX90_mtgy_op_x97      0xFF083D84U
#define DFLT_VAL_NX90_mtgy_op_x97 0x00000000U

#define MSK_NX90_mtgy_op_x97_val         0xffffffffU
#define SRT_NX90_mtgy_op_x97_val         0
#define DFLT_VAL_NX90_mtgy_op_x97_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x97_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x97': */
#define MSK_USED_BITS_NX90_mtgy_op_x97 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x97_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X97_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x97_val; /* data bits 3135..3104 */
} NX90_MTGY_OP_X97_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X97_BIT_T bf;
} NX90_MTGY_OP_X97_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x98 */
/* => MWMM operand X register 98 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x98  0x00001D88U
#define Adr_NX90_mtgy_mtgy_op_x98 0xFF083D88U
#define Adr_NX90_mtgy_op_x98      0xFF083D88U
#define DFLT_VAL_NX90_mtgy_op_x98 0x00000000U

#define MSK_NX90_mtgy_op_x98_val         0xffffffffU
#define SRT_NX90_mtgy_op_x98_val         0
#define DFLT_VAL_NX90_mtgy_op_x98_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x98_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x98': */
#define MSK_USED_BITS_NX90_mtgy_op_x98 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x98_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X98_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x98_val; /* data bits 3167..3136 */
} NX90_MTGY_OP_X98_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X98_BIT_T bf;
} NX90_MTGY_OP_X98_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x99 */
/* => MWMM operand X register 99 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x99  0x00001D8CU
#define Adr_NX90_mtgy_mtgy_op_x99 0xFF083D8CU
#define Adr_NX90_mtgy_op_x99      0xFF083D8CU
#define DFLT_VAL_NX90_mtgy_op_x99 0x00000000U

#define MSK_NX90_mtgy_op_x99_val         0xffffffffU
#define SRT_NX90_mtgy_op_x99_val         0
#define DFLT_VAL_NX90_mtgy_op_x99_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x99_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x99': */
#define MSK_USED_BITS_NX90_mtgy_op_x99 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x99_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X99_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x99_val; /* data bits 3199..3168 */
} NX90_MTGY_OP_X99_BIT_T;

typedef union {
  uint32_t               val;
  NX90_MTGY_OP_X99_BIT_T bf;
} NX90_MTGY_OP_X99_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x100 */
/* => MWMM operand X register 100 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x100  0x00001D90U
#define Adr_NX90_mtgy_mtgy_op_x100 0xFF083D90U
#define Adr_NX90_mtgy_op_x100      0xFF083D90U
#define DFLT_VAL_NX90_mtgy_op_x100 0x00000000U

#define MSK_NX90_mtgy_op_x100_val         0xffffffffU
#define SRT_NX90_mtgy_op_x100_val         0
#define DFLT_VAL_NX90_mtgy_op_x100_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x100_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x100': */
#define MSK_USED_BITS_NX90_mtgy_op_x100 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x100_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X100_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x100_val; /* data bits 3231..3200 */
} NX90_MTGY_OP_X100_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X100_BIT_T bf;
} NX90_MTGY_OP_X100_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x101 */
/* => MWMM operand X register 101 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x101  0x00001D94U
#define Adr_NX90_mtgy_mtgy_op_x101 0xFF083D94U
#define Adr_NX90_mtgy_op_x101      0xFF083D94U
#define DFLT_VAL_NX90_mtgy_op_x101 0x00000000U

#define MSK_NX90_mtgy_op_x101_val         0xffffffffU
#define SRT_NX90_mtgy_op_x101_val         0
#define DFLT_VAL_NX90_mtgy_op_x101_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x101_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x101': */
#define MSK_USED_BITS_NX90_mtgy_op_x101 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x101_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X101_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x101_val; /* data bits 3263..3232 */
} NX90_MTGY_OP_X101_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X101_BIT_T bf;
} NX90_MTGY_OP_X101_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x102 */
/* => MWMM operand X register 102 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x102  0x00001D98U
#define Adr_NX90_mtgy_mtgy_op_x102 0xFF083D98U
#define Adr_NX90_mtgy_op_x102      0xFF083D98U
#define DFLT_VAL_NX90_mtgy_op_x102 0x00000000U

#define MSK_NX90_mtgy_op_x102_val         0xffffffffU
#define SRT_NX90_mtgy_op_x102_val         0
#define DFLT_VAL_NX90_mtgy_op_x102_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x102_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x102': */
#define MSK_USED_BITS_NX90_mtgy_op_x102 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x102_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X102_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x102_val; /* data bits 3295..3264 */
} NX90_MTGY_OP_X102_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X102_BIT_T bf;
} NX90_MTGY_OP_X102_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x103 */
/* => MWMM operand X register 103 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x103  0x00001D9CU
#define Adr_NX90_mtgy_mtgy_op_x103 0xFF083D9CU
#define Adr_NX90_mtgy_op_x103      0xFF083D9CU
#define DFLT_VAL_NX90_mtgy_op_x103 0x00000000U

#define MSK_NX90_mtgy_op_x103_val         0xffffffffU
#define SRT_NX90_mtgy_op_x103_val         0
#define DFLT_VAL_NX90_mtgy_op_x103_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x103_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x103': */
#define MSK_USED_BITS_NX90_mtgy_op_x103 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x103_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X103_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x103_val; /* data bits 3327..3296 */
} NX90_MTGY_OP_X103_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X103_BIT_T bf;
} NX90_MTGY_OP_X103_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x104 */
/* => MWMM operand X register 104 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x104  0x00001DA0U
#define Adr_NX90_mtgy_mtgy_op_x104 0xFF083DA0U
#define Adr_NX90_mtgy_op_x104      0xFF083DA0U
#define DFLT_VAL_NX90_mtgy_op_x104 0x00000000U

#define MSK_NX90_mtgy_op_x104_val         0xffffffffU
#define SRT_NX90_mtgy_op_x104_val         0
#define DFLT_VAL_NX90_mtgy_op_x104_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x104_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x104': */
#define MSK_USED_BITS_NX90_mtgy_op_x104 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x104_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X104_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x104_val; /* data bits 3359..3328 */
} NX90_MTGY_OP_X104_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X104_BIT_T bf;
} NX90_MTGY_OP_X104_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x105 */
/* => MWMM operand X register 105 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x105  0x00001DA4U
#define Adr_NX90_mtgy_mtgy_op_x105 0xFF083DA4U
#define Adr_NX90_mtgy_op_x105      0xFF083DA4U
#define DFLT_VAL_NX90_mtgy_op_x105 0x00000000U

#define MSK_NX90_mtgy_op_x105_val         0xffffffffU
#define SRT_NX90_mtgy_op_x105_val         0
#define DFLT_VAL_NX90_mtgy_op_x105_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x105_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x105': */
#define MSK_USED_BITS_NX90_mtgy_op_x105 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x105_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X105_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x105_val; /* data bits 3391..3360 */
} NX90_MTGY_OP_X105_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X105_BIT_T bf;
} NX90_MTGY_OP_X105_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x106 */
/* => MWMM operand X register 106 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x106  0x00001DA8U
#define Adr_NX90_mtgy_mtgy_op_x106 0xFF083DA8U
#define Adr_NX90_mtgy_op_x106      0xFF083DA8U
#define DFLT_VAL_NX90_mtgy_op_x106 0x00000000U

#define MSK_NX90_mtgy_op_x106_val         0xffffffffU
#define SRT_NX90_mtgy_op_x106_val         0
#define DFLT_VAL_NX90_mtgy_op_x106_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x106_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x106': */
#define MSK_USED_BITS_NX90_mtgy_op_x106 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x106_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X106_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x106_val; /* data bits 3423..3392 */
} NX90_MTGY_OP_X106_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X106_BIT_T bf;
} NX90_MTGY_OP_X106_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x107 */
/* => MWMM operand X register 107 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x107  0x00001DACU
#define Adr_NX90_mtgy_mtgy_op_x107 0xFF083DACU
#define Adr_NX90_mtgy_op_x107      0xFF083DACU
#define DFLT_VAL_NX90_mtgy_op_x107 0x00000000U

#define MSK_NX90_mtgy_op_x107_val         0xffffffffU
#define SRT_NX90_mtgy_op_x107_val         0
#define DFLT_VAL_NX90_mtgy_op_x107_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x107_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x107': */
#define MSK_USED_BITS_NX90_mtgy_op_x107 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x107_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X107_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x107_val; /* data bits 3455..3424 */
} NX90_MTGY_OP_X107_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X107_BIT_T bf;
} NX90_MTGY_OP_X107_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x108 */
/* => MWMM operand X register 108 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x108  0x00001DB0U
#define Adr_NX90_mtgy_mtgy_op_x108 0xFF083DB0U
#define Adr_NX90_mtgy_op_x108      0xFF083DB0U
#define DFLT_VAL_NX90_mtgy_op_x108 0x00000000U

#define MSK_NX90_mtgy_op_x108_val         0xffffffffU
#define SRT_NX90_mtgy_op_x108_val         0
#define DFLT_VAL_NX90_mtgy_op_x108_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x108_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x108': */
#define MSK_USED_BITS_NX90_mtgy_op_x108 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x108_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X108_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x108_val; /* data bits 3487..3456 */
} NX90_MTGY_OP_X108_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X108_BIT_T bf;
} NX90_MTGY_OP_X108_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x109 */
/* => MWMM operand X register 109 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x109  0x00001DB4U
#define Adr_NX90_mtgy_mtgy_op_x109 0xFF083DB4U
#define Adr_NX90_mtgy_op_x109      0xFF083DB4U
#define DFLT_VAL_NX90_mtgy_op_x109 0x00000000U

#define MSK_NX90_mtgy_op_x109_val         0xffffffffU
#define SRT_NX90_mtgy_op_x109_val         0
#define DFLT_VAL_NX90_mtgy_op_x109_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x109_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x109': */
#define MSK_USED_BITS_NX90_mtgy_op_x109 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x109_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X109_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x109_val; /* data bits 3519..3488 */
} NX90_MTGY_OP_X109_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X109_BIT_T bf;
} NX90_MTGY_OP_X109_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x110 */
/* => MWMM operand X register 110 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x110  0x00001DB8U
#define Adr_NX90_mtgy_mtgy_op_x110 0xFF083DB8U
#define Adr_NX90_mtgy_op_x110      0xFF083DB8U
#define DFLT_VAL_NX90_mtgy_op_x110 0x00000000U

#define MSK_NX90_mtgy_op_x110_val         0xffffffffU
#define SRT_NX90_mtgy_op_x110_val         0
#define DFLT_VAL_NX90_mtgy_op_x110_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x110_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x110': */
#define MSK_USED_BITS_NX90_mtgy_op_x110 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x110_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X110_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x110_val; /* data bits 3551..3520 */
} NX90_MTGY_OP_X110_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X110_BIT_T bf;
} NX90_MTGY_OP_X110_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x111 */
/* => MWMM operand X register 111 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x111  0x00001DBCU
#define Adr_NX90_mtgy_mtgy_op_x111 0xFF083DBCU
#define Adr_NX90_mtgy_op_x111      0xFF083DBCU
#define DFLT_VAL_NX90_mtgy_op_x111 0x00000000U

#define MSK_NX90_mtgy_op_x111_val         0xffffffffU
#define SRT_NX90_mtgy_op_x111_val         0
#define DFLT_VAL_NX90_mtgy_op_x111_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x111_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x111': */
#define MSK_USED_BITS_NX90_mtgy_op_x111 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x111_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X111_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x111_val; /* data bits 3583..3552 */
} NX90_MTGY_OP_X111_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X111_BIT_T bf;
} NX90_MTGY_OP_X111_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x112 */
/* => MWMM operand X register 112 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x112  0x00001DC0U
#define Adr_NX90_mtgy_mtgy_op_x112 0xFF083DC0U
#define Adr_NX90_mtgy_op_x112      0xFF083DC0U
#define DFLT_VAL_NX90_mtgy_op_x112 0x00000000U

#define MSK_NX90_mtgy_op_x112_val         0xffffffffU
#define SRT_NX90_mtgy_op_x112_val         0
#define DFLT_VAL_NX90_mtgy_op_x112_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x112_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x112': */
#define MSK_USED_BITS_NX90_mtgy_op_x112 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x112_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X112_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x112_val; /* data bits 3615..3584 */
} NX90_MTGY_OP_X112_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X112_BIT_T bf;
} NX90_MTGY_OP_X112_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x113 */
/* => MWMM operand X register 113 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x113  0x00001DC4U
#define Adr_NX90_mtgy_mtgy_op_x113 0xFF083DC4U
#define Adr_NX90_mtgy_op_x113      0xFF083DC4U
#define DFLT_VAL_NX90_mtgy_op_x113 0x00000000U

#define MSK_NX90_mtgy_op_x113_val         0xffffffffU
#define SRT_NX90_mtgy_op_x113_val         0
#define DFLT_VAL_NX90_mtgy_op_x113_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x113_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x113': */
#define MSK_USED_BITS_NX90_mtgy_op_x113 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x113_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X113_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x113_val; /* data bits 3647..3616 */
} NX90_MTGY_OP_X113_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X113_BIT_T bf;
} NX90_MTGY_OP_X113_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x114 */
/* => MWMM operand X register 114 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x114  0x00001DC8U
#define Adr_NX90_mtgy_mtgy_op_x114 0xFF083DC8U
#define Adr_NX90_mtgy_op_x114      0xFF083DC8U
#define DFLT_VAL_NX90_mtgy_op_x114 0x00000000U

#define MSK_NX90_mtgy_op_x114_val         0xffffffffU
#define SRT_NX90_mtgy_op_x114_val         0
#define DFLT_VAL_NX90_mtgy_op_x114_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x114_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x114': */
#define MSK_USED_BITS_NX90_mtgy_op_x114 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x114_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X114_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x114_val; /* data bits 3679..3648 */
} NX90_MTGY_OP_X114_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X114_BIT_T bf;
} NX90_MTGY_OP_X114_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x115 */
/* => MWMM operand X register 115 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x115  0x00001DCCU
#define Adr_NX90_mtgy_mtgy_op_x115 0xFF083DCCU
#define Adr_NX90_mtgy_op_x115      0xFF083DCCU
#define DFLT_VAL_NX90_mtgy_op_x115 0x00000000U

#define MSK_NX90_mtgy_op_x115_val         0xffffffffU
#define SRT_NX90_mtgy_op_x115_val         0
#define DFLT_VAL_NX90_mtgy_op_x115_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x115_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x115': */
#define MSK_USED_BITS_NX90_mtgy_op_x115 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x115_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X115_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x115_val; /* data bits 3711..3680 */
} NX90_MTGY_OP_X115_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X115_BIT_T bf;
} NX90_MTGY_OP_X115_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x116 */
/* => MWMM operand X register 116 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x116  0x00001DD0U
#define Adr_NX90_mtgy_mtgy_op_x116 0xFF083DD0U
#define Adr_NX90_mtgy_op_x116      0xFF083DD0U
#define DFLT_VAL_NX90_mtgy_op_x116 0x00000000U

#define MSK_NX90_mtgy_op_x116_val         0xffffffffU
#define SRT_NX90_mtgy_op_x116_val         0
#define DFLT_VAL_NX90_mtgy_op_x116_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x116_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x116': */
#define MSK_USED_BITS_NX90_mtgy_op_x116 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x116_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X116_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x116_val; /* data bits 3743..3712 */
} NX90_MTGY_OP_X116_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X116_BIT_T bf;
} NX90_MTGY_OP_X116_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x117 */
/* => MWMM operand X register 117 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x117  0x00001DD4U
#define Adr_NX90_mtgy_mtgy_op_x117 0xFF083DD4U
#define Adr_NX90_mtgy_op_x117      0xFF083DD4U
#define DFLT_VAL_NX90_mtgy_op_x117 0x00000000U

#define MSK_NX90_mtgy_op_x117_val         0xffffffffU
#define SRT_NX90_mtgy_op_x117_val         0
#define DFLT_VAL_NX90_mtgy_op_x117_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x117_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x117': */
#define MSK_USED_BITS_NX90_mtgy_op_x117 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x117_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X117_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x117_val; /* data bits 3775..3744 */
} NX90_MTGY_OP_X117_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X117_BIT_T bf;
} NX90_MTGY_OP_X117_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x118 */
/* => MWMM operand X register 118 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x118  0x00001DD8U
#define Adr_NX90_mtgy_mtgy_op_x118 0xFF083DD8U
#define Adr_NX90_mtgy_op_x118      0xFF083DD8U
#define DFLT_VAL_NX90_mtgy_op_x118 0x00000000U

#define MSK_NX90_mtgy_op_x118_val         0xffffffffU
#define SRT_NX90_mtgy_op_x118_val         0
#define DFLT_VAL_NX90_mtgy_op_x118_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x118_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x118': */
#define MSK_USED_BITS_NX90_mtgy_op_x118 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x118_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X118_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x118_val; /* data bits 3807..3776 */
} NX90_MTGY_OP_X118_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X118_BIT_T bf;
} NX90_MTGY_OP_X118_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x119 */
/* => MWMM operand X register 119 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x119  0x00001DDCU
#define Adr_NX90_mtgy_mtgy_op_x119 0xFF083DDCU
#define Adr_NX90_mtgy_op_x119      0xFF083DDCU
#define DFLT_VAL_NX90_mtgy_op_x119 0x00000000U

#define MSK_NX90_mtgy_op_x119_val         0xffffffffU
#define SRT_NX90_mtgy_op_x119_val         0
#define DFLT_VAL_NX90_mtgy_op_x119_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x119_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x119': */
#define MSK_USED_BITS_NX90_mtgy_op_x119 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x119_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X119_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x119_val; /* data bits 3839..3808 */
} NX90_MTGY_OP_X119_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X119_BIT_T bf;
} NX90_MTGY_OP_X119_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x120 */
/* => MWMM operand X register 120 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x120  0x00001DE0U
#define Adr_NX90_mtgy_mtgy_op_x120 0xFF083DE0U
#define Adr_NX90_mtgy_op_x120      0xFF083DE0U
#define DFLT_VAL_NX90_mtgy_op_x120 0x00000000U

#define MSK_NX90_mtgy_op_x120_val         0xffffffffU
#define SRT_NX90_mtgy_op_x120_val         0
#define DFLT_VAL_NX90_mtgy_op_x120_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x120_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x120': */
#define MSK_USED_BITS_NX90_mtgy_op_x120 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x120_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X120_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x120_val; /* data bits 3871..3840 */
} NX90_MTGY_OP_X120_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X120_BIT_T bf;
} NX90_MTGY_OP_X120_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x121 */
/* => MWMM operand X register 121 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x121  0x00001DE4U
#define Adr_NX90_mtgy_mtgy_op_x121 0xFF083DE4U
#define Adr_NX90_mtgy_op_x121      0xFF083DE4U
#define DFLT_VAL_NX90_mtgy_op_x121 0x00000000U

#define MSK_NX90_mtgy_op_x121_val         0xffffffffU
#define SRT_NX90_mtgy_op_x121_val         0
#define DFLT_VAL_NX90_mtgy_op_x121_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x121_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x121': */
#define MSK_USED_BITS_NX90_mtgy_op_x121 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x121_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X121_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x121_val; /* data bits 3903..3872 */
} NX90_MTGY_OP_X121_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X121_BIT_T bf;
} NX90_MTGY_OP_X121_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x122 */
/* => MWMM operand X register 122 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x122  0x00001DE8U
#define Adr_NX90_mtgy_mtgy_op_x122 0xFF083DE8U
#define Adr_NX90_mtgy_op_x122      0xFF083DE8U
#define DFLT_VAL_NX90_mtgy_op_x122 0x00000000U

#define MSK_NX90_mtgy_op_x122_val         0xffffffffU
#define SRT_NX90_mtgy_op_x122_val         0
#define DFLT_VAL_NX90_mtgy_op_x122_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x122_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x122': */
#define MSK_USED_BITS_NX90_mtgy_op_x122 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x122_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X122_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x122_val; /* data bits 3935..3904 */
} NX90_MTGY_OP_X122_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X122_BIT_T bf;
} NX90_MTGY_OP_X122_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x123 */
/* => MWMM operand X register 123 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x123  0x00001DECU
#define Adr_NX90_mtgy_mtgy_op_x123 0xFF083DECU
#define Adr_NX90_mtgy_op_x123      0xFF083DECU
#define DFLT_VAL_NX90_mtgy_op_x123 0x00000000U

#define MSK_NX90_mtgy_op_x123_val         0xffffffffU
#define SRT_NX90_mtgy_op_x123_val         0
#define DFLT_VAL_NX90_mtgy_op_x123_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x123_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x123': */
#define MSK_USED_BITS_NX90_mtgy_op_x123 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x123_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X123_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x123_val; /* data bits 3967..3936 */
} NX90_MTGY_OP_X123_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X123_BIT_T bf;
} NX90_MTGY_OP_X123_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x124 */
/* => MWMM operand X register 124 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x124  0x00001DF0U
#define Adr_NX90_mtgy_mtgy_op_x124 0xFF083DF0U
#define Adr_NX90_mtgy_op_x124      0xFF083DF0U
#define DFLT_VAL_NX90_mtgy_op_x124 0x00000000U

#define MSK_NX90_mtgy_op_x124_val         0xffffffffU
#define SRT_NX90_mtgy_op_x124_val         0
#define DFLT_VAL_NX90_mtgy_op_x124_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x124_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x124': */
#define MSK_USED_BITS_NX90_mtgy_op_x124 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x124_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X124_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x124_val; /* data bits 3999..3968 */
} NX90_MTGY_OP_X124_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X124_BIT_T bf;
} NX90_MTGY_OP_X124_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x125 */
/* => MWMM operand X register 125 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x125  0x00001DF4U
#define Adr_NX90_mtgy_mtgy_op_x125 0xFF083DF4U
#define Adr_NX90_mtgy_op_x125      0xFF083DF4U
#define DFLT_VAL_NX90_mtgy_op_x125 0x00000000U

#define MSK_NX90_mtgy_op_x125_val         0xffffffffU
#define SRT_NX90_mtgy_op_x125_val         0
#define DFLT_VAL_NX90_mtgy_op_x125_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x125_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x125': */
#define MSK_USED_BITS_NX90_mtgy_op_x125 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x125_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X125_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x125_val; /* data bits 4031..4000 */
} NX90_MTGY_OP_X125_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X125_BIT_T bf;
} NX90_MTGY_OP_X125_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x126 */
/* => MWMM operand X register 126 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x126  0x00001DF8U
#define Adr_NX90_mtgy_mtgy_op_x126 0xFF083DF8U
#define Adr_NX90_mtgy_op_x126      0xFF083DF8U
#define DFLT_VAL_NX90_mtgy_op_x126 0x00000000U

#define MSK_NX90_mtgy_op_x126_val         0xffffffffU
#define SRT_NX90_mtgy_op_x126_val         0
#define DFLT_VAL_NX90_mtgy_op_x126_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x126_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x126': */
#define MSK_USED_BITS_NX90_mtgy_op_x126 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x126_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X126_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x126_val; /* data bits 4063..4032 */
} NX90_MTGY_OP_X126_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X126_BIT_T bf;
} NX90_MTGY_OP_X126_T;

/* --------------------------------------------------------------------- */
/* Register mtgy_op_x127 */
/* => MWMM operand X register 127 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mtgy_op_x127  0x00001DFCU
#define Adr_NX90_mtgy_mtgy_op_x127 0xFF083DFCU
#define Adr_NX90_mtgy_op_x127      0xFF083DFCU
#define DFLT_VAL_NX90_mtgy_op_x127 0x00000000U

#define MSK_NX90_mtgy_op_x127_val         0xffffffffU
#define SRT_NX90_mtgy_op_x127_val         0
#define DFLT_VAL_NX90_mtgy_op_x127_val    0x00000000U
#define DFLT_BF_VAL_NX90_mtgy_op_x127_val 0x00000000U

/* all used bits of 'NX90_mtgy_op_x127': */
#define MSK_USED_BITS_NX90_mtgy_op_x127 0xffffffffU

enum {
  BFW_NX90_mtgy_op_x127_val = 32  /* [31:0] */
};

typedef struct NX90_MTGY_OP_X127_BIT_Ttag {
  unsigned int val : BFW_NX90_mtgy_op_x127_val; /* data bits 4095..4064 */
} NX90_MTGY_OP_X127_BIT_T;

typedef union {
  uint32_t                val;
  NX90_MTGY_OP_X127_BIT_T bf;
} NX90_MTGY_OP_X127_T;


/* ===================================================================== */

/* Area of intlogic_shd */

/* ===================================================================== */

#define Addr_NX90_intlogic_shd 0xFF400000U

/* ===================================================================== */

/* Area of nfifo */

/* ===================================================================== */

#define Addr_NX90_nfifo 0xFF400000U

/* --------------------------------------------------------------------- */
/* Register nfifo_config */
/* => NFIFO config register */
/*    'base_config' is a pointer to start of NFIFO configuration area in memory. */
/*    The configuration area must be setup by software, before using a FIFO. */
/*    Each FIFO-configuration entry consists of 3 DW and contains the following: */
/*    {       | */
/*    mem-DW0: base(31:2),mas(1:0) */
/*    mem-DW1: watm(28:16),bottom(12:0) */
/*    mem-DW2: undr(31),emw(30),empty(29),write(28:16),ovfl(15),fmw(14),full(13),fill(12:0) } */
/*    This allows FIFOs of up to 8k entries each. */
/*    The first DWords mem-DW0 and mem-DW1 are only read by NFIFO controller. */
/*    To reset a FIFO, reinit the configuration entries mem-DW0..2. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_config   0x00000000U
#define Adr_NX90_nfifo_nfifo_config 0xFF400000U
#define Adr_NX90_nfifo_config       0xFF400000U
#define DFLT_VAL_NX90_nfifo_config  0x00000000U

#define MSK_NX90_nfifo_config_base_config         0xfffffffcU
#define SRT_NX90_nfifo_config_base_config         2
#define DFLT_VAL_NX90_nfifo_config_base_config    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_config_base_config 0x00000000U

/* all used bits of 'NX90_nfifo_config': */
#define MSK_USED_BITS_NX90_nfifo_config 0xfffffffcU

enum {
  BFW_NX90_nfifo_config_reserved1   = 2,  /* [1:0] */
  BFW_NX90_nfifo_config_base_config = 30  /* [31:2] */
};

typedef struct NX90_NFIFO_CONFIG_BIT_Ttag {
  unsigned int reserved1   : BFW_NX90_nfifo_config_reserved1;   /* reserved               */
  unsigned int base_config : BFW_NX90_nfifo_config_base_config; /* Pointer to base_config */
} NX90_NFIFO_CONFIG_BIT_T;

typedef union {
  uint32_t                val;
  NX90_NFIFO_CONFIG_BIT_T bf;
} NX90_NFIFO_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_raw */
/* => Raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_raw   0x0000000CU
#define Adr_NX90_nfifo_nfifo_irq_raw 0xFF40000CU
#define Adr_NX90_nfifo_irq_raw       0xFF40000CU
#define DFLT_VAL_NX90_nfifo_irq_raw  0x00000000U

#define MSK_NX90_nfifo_irq_raw_ahbl_error          0x00000001U
#define SRT_NX90_nfifo_irq_raw_ahbl_error          0
#define DFLT_VAL_NX90_nfifo_irq_raw_ahbl_error     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_ahbl_error  0x00000000U
#define MSK_NX90_nfifo_irq_raw_read                0x00000002U
#define SRT_NX90_nfifo_irq_raw_read                1
#define DFLT_VAL_NX90_nfifo_irq_raw_read           0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_read        0x00000000U
#define MSK_NX90_nfifo_irq_raw_write               0x00000004U
#define SRT_NX90_nfifo_irq_raw_write               2
#define DFLT_VAL_NX90_nfifo_irq_raw_write          0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_write       0x00000000U
#define MSK_NX90_nfifo_irq_raw_fifo_active         0x00000008U
#define SRT_NX90_nfifo_irq_raw_fifo_active         3
#define DFLT_VAL_NX90_nfifo_irq_raw_fifo_active    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_fifo_active 0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe0            0x00000010U
#define SRT_NX90_nfifo_irq_raw_observe0            4
#define DFLT_VAL_NX90_nfifo_irq_raw_observe0       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe0    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe1            0x00000020U
#define SRT_NX90_nfifo_irq_raw_observe1            5
#define DFLT_VAL_NX90_nfifo_irq_raw_observe1       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe1    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe2            0x00000040U
#define SRT_NX90_nfifo_irq_raw_observe2            6
#define DFLT_VAL_NX90_nfifo_irq_raw_observe2       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe2    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe3            0x00000080U
#define SRT_NX90_nfifo_irq_raw_observe3            7
#define DFLT_VAL_NX90_nfifo_irq_raw_observe3       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe3    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe4            0x00000100U
#define SRT_NX90_nfifo_irq_raw_observe4            8
#define DFLT_VAL_NX90_nfifo_irq_raw_observe4       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe4    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe5            0x00000200U
#define SRT_NX90_nfifo_irq_raw_observe5            9
#define DFLT_VAL_NX90_nfifo_irq_raw_observe5       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe5    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe6            0x00000400U
#define SRT_NX90_nfifo_irq_raw_observe6            10
#define DFLT_VAL_NX90_nfifo_irq_raw_observe6       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe6    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe7            0x00000800U
#define SRT_NX90_nfifo_irq_raw_observe7            11
#define DFLT_VAL_NX90_nfifo_irq_raw_observe7       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe7    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe8            0x00001000U
#define SRT_NX90_nfifo_irq_raw_observe8            12
#define DFLT_VAL_NX90_nfifo_irq_raw_observe8       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe8    0x00000000U
#define MSK_NX90_nfifo_irq_raw_observe9            0x00002000U
#define SRT_NX90_nfifo_irq_raw_observe9            13
#define DFLT_VAL_NX90_nfifo_irq_raw_observe9       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_raw_observe9    0x00000000U

/* all used bits of 'NX90_nfifo_irq_raw': */
#define MSK_USED_BITS_NX90_nfifo_irq_raw 0x00003fffU

enum {
  BFW_NX90_nfifo_irq_raw_ahbl_error  = 1,  /* [0] */
  BFW_NX90_nfifo_irq_raw_read        = 1,  /* [1] */
  BFW_NX90_nfifo_irq_raw_write       = 1,  /* [2] */
  BFW_NX90_nfifo_irq_raw_fifo_active = 1,  /* [3] */
  BFW_NX90_nfifo_irq_raw_observe0    = 1,  /* [4] */
  BFW_NX90_nfifo_irq_raw_observe1    = 1,  /* [5] */
  BFW_NX90_nfifo_irq_raw_observe2    = 1,  /* [6] */
  BFW_NX90_nfifo_irq_raw_observe3    = 1,  /* [7] */
  BFW_NX90_nfifo_irq_raw_observe4    = 1,  /* [8] */
  BFW_NX90_nfifo_irq_raw_observe5    = 1,  /* [9] */
  BFW_NX90_nfifo_irq_raw_observe6    = 1,  /* [10] */
  BFW_NX90_nfifo_irq_raw_observe7    = 1,  /* [11] */
  BFW_NX90_nfifo_irq_raw_observe8    = 1,  /* [12] */
  BFW_NX90_nfifo_irq_raw_observe9    = 1,  /* [13] */
  BFW_NX90_nfifo_irq_raw_reserved1   = 18  /* [31:14] */
};

typedef struct NX90_NFIFO_IRQ_RAW_BIT_Ttag {
  unsigned int ahbl_error  : BFW_NX90_nfifo_irq_raw_ahbl_error;  /* AHBL returned HRESP=1 (abort)                                                       */
  unsigned int read        : BFW_NX90_nfifo_irq_raw_read;        /* any read access happened to any FIFO                                                */
  unsigned int write       : BFW_NX90_nfifo_irq_raw_write;       /* any write access happened to any FIFO                                               */
  unsigned int fifo_active : BFW_NX90_nfifo_irq_raw_fifo_active; /* any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) */
  unsigned int observe0    : BFW_NX90_nfifo_irq_raw_observe0;    /* access to FIFO as defined in observe0                                               */
  unsigned int observe1    : BFW_NX90_nfifo_irq_raw_observe1;    /* access to FIFO as defined in observe1                                               */
  unsigned int observe2    : BFW_NX90_nfifo_irq_raw_observe2;    /* access to FIFO as defined in observe2                                               */
  unsigned int observe3    : BFW_NX90_nfifo_irq_raw_observe3;    /* access to FIFO as defined in observe3                                               */
  unsigned int observe4    : BFW_NX90_nfifo_irq_raw_observe4;    /* access to FIFO as defined in observe4                                               */
  unsigned int observe5    : BFW_NX90_nfifo_irq_raw_observe5;    /* access to FIFO as defined in observe5                                               */
  unsigned int observe6    : BFW_NX90_nfifo_irq_raw_observe6;    /* access to FIFO as defined in observe6                                               */
  unsigned int observe7    : BFW_NX90_nfifo_irq_raw_observe7;    /* access to FIFO as defined in observe7                                               */
  unsigned int observe8    : BFW_NX90_nfifo_irq_raw_observe8;    /* access to FIFO as defined in observe8                                               */
  unsigned int observe9    : BFW_NX90_nfifo_irq_raw_observe9;    /* access to FIFO as defined in observe9                                               */
  unsigned int reserved1   : BFW_NX90_nfifo_irq_raw_reserved1;   /* reserved                                                                            */
} NX90_NFIFO_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_NFIFO_IRQ_RAW_BIT_T bf;
} NX90_NFIFO_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_arm_app_masked */
/* => Masked IRQ of ARM_APP: */
/*    Shows status of masked IRQs as connected to application ARM Cortex M4. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_arm_app_masked   0x00000010U
#define Adr_NX90_nfifo_nfifo_irq_arm_app_masked 0xFF400010U
#define Adr_NX90_nfifo_irq_arm_app_masked       0xFF400010U

#define MSK_NX90_nfifo_irq_arm_app_masked_ahbl_error  0x00000001U
#define SRT_NX90_nfifo_irq_arm_app_masked_ahbl_error  0
#define MSK_NX90_nfifo_irq_arm_app_masked_read        0x00000002U
#define SRT_NX90_nfifo_irq_arm_app_masked_read        1
#define MSK_NX90_nfifo_irq_arm_app_masked_write       0x00000004U
#define SRT_NX90_nfifo_irq_arm_app_masked_write       2
#define MSK_NX90_nfifo_irq_arm_app_masked_fifo_active 0x00000008U
#define SRT_NX90_nfifo_irq_arm_app_masked_fifo_active 3
#define MSK_NX90_nfifo_irq_arm_app_masked_observe0    0x00000010U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe0    4
#define MSK_NX90_nfifo_irq_arm_app_masked_observe1    0x00000020U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe1    5
#define MSK_NX90_nfifo_irq_arm_app_masked_observe2    0x00000040U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe2    6
#define MSK_NX90_nfifo_irq_arm_app_masked_observe3    0x00000080U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe3    7
#define MSK_NX90_nfifo_irq_arm_app_masked_observe4    0x00000100U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe4    8
#define MSK_NX90_nfifo_irq_arm_app_masked_observe5    0x00000200U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe5    9
#define MSK_NX90_nfifo_irq_arm_app_masked_observe6    0x00000400U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe6    10
#define MSK_NX90_nfifo_irq_arm_app_masked_observe7    0x00000800U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe7    11
#define MSK_NX90_nfifo_irq_arm_app_masked_observe8    0x00001000U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe8    12
#define MSK_NX90_nfifo_irq_arm_app_masked_observe9    0x00002000U
#define SRT_NX90_nfifo_irq_arm_app_masked_observe9    13

/* all used bits of 'NX90_nfifo_irq_arm_app_masked': */
#define MSK_USED_BITS_NX90_nfifo_irq_arm_app_masked 0x00003fffU

enum {
  BFW_NX90_nfifo_irq_arm_app_masked_ahbl_error  = 1,  /* [0] */
  BFW_NX90_nfifo_irq_arm_app_masked_read        = 1,  /* [1] */
  BFW_NX90_nfifo_irq_arm_app_masked_write       = 1,  /* [2] */
  BFW_NX90_nfifo_irq_arm_app_masked_fifo_active = 1,  /* [3] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe0    = 1,  /* [4] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe1    = 1,  /* [5] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe2    = 1,  /* [6] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe3    = 1,  /* [7] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe4    = 1,  /* [8] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe5    = 1,  /* [9] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe6    = 1,  /* [10] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe7    = 1,  /* [11] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe8    = 1,  /* [12] */
  BFW_NX90_nfifo_irq_arm_app_masked_observe9    = 1,  /* [13] */
  BFW_NX90_nfifo_irq_arm_app_masked_reserved1   = 18  /* [31:14] */
};

typedef struct NX90_NFIFO_IRQ_ARM_APP_MASKED_BIT_Ttag {
  unsigned int ahbl_error  : BFW_NX90_nfifo_irq_arm_app_masked_ahbl_error;  /* AHBL returned HRESP=1 (abort)                                                       */
  unsigned int read        : BFW_NX90_nfifo_irq_arm_app_masked_read;        /* any read access happened to any FIFO                                                */
  unsigned int write       : BFW_NX90_nfifo_irq_arm_app_masked_write;       /* any write access happened to any FIFO                                               */
  unsigned int fifo_active : BFW_NX90_nfifo_irq_arm_app_masked_fifo_active; /* any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) */
  unsigned int observe0    : BFW_NX90_nfifo_irq_arm_app_masked_observe0;    /* access to FIFO as defined in observe0                                               */
  unsigned int observe1    : BFW_NX90_nfifo_irq_arm_app_masked_observe1;    /* access to FIFO as defined in observe1                                               */
  unsigned int observe2    : BFW_NX90_nfifo_irq_arm_app_masked_observe2;    /* access to FIFO as defined in observe2                                               */
  unsigned int observe3    : BFW_NX90_nfifo_irq_arm_app_masked_observe3;    /* access to FIFO as defined in observe3                                               */
  unsigned int observe4    : BFW_NX90_nfifo_irq_arm_app_masked_observe4;    /* access to FIFO as defined in observe4                                               */
  unsigned int observe5    : BFW_NX90_nfifo_irq_arm_app_masked_observe5;    /* access to FIFO as defined in observe5                                               */
  unsigned int observe6    : BFW_NX90_nfifo_irq_arm_app_masked_observe6;    /* access to FIFO as defined in observe6                                               */
  unsigned int observe7    : BFW_NX90_nfifo_irq_arm_app_masked_observe7;    /* access to FIFO as defined in observe7                                               */
  unsigned int observe8    : BFW_NX90_nfifo_irq_arm_app_masked_observe8;    /* access to FIFO as defined in observe8                                               */
  unsigned int observe9    : BFW_NX90_nfifo_irq_arm_app_masked_observe9;    /* access to FIFO as defined in observe9                                               */
  unsigned int reserved1   : BFW_NX90_nfifo_irq_arm_app_masked_reserved1;   /* reserved                                                                            */
} NX90_NFIFO_IRQ_ARM_APP_MASKED_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_NFIFO_IRQ_ARM_APP_MASKED_BIT_T bf;
} NX90_NFIFO_IRQ_ARM_APP_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_arm_app_msk_set */
/* => ARM_APP Cortex M4 IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources to the ARM_APP processor. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_nfifo_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_arm_app_msk_set   0x00000014U
#define Adr_NX90_nfifo_nfifo_irq_arm_app_msk_set 0xFF400014U
#define Adr_NX90_nfifo_irq_arm_app_msk_set       0xFF400014U
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set  0x00000000U

#define MSK_NX90_nfifo_irq_arm_app_msk_set_ahbl_error          0x00000001U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_ahbl_error          0
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_ahbl_error     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_ahbl_error  0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_read                0x00000002U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_read                1
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_read           0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_read        0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_write               0x00000004U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_write               2
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_write          0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_write       0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_fifo_active         0x00000008U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_fifo_active         3
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_fifo_active    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_fifo_active 0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe0            0x00000010U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe0            4
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe0       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe0    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe1            0x00000020U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe1            5
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe1       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe1    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe2            0x00000040U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe2            6
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe2       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe2    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe3            0x00000080U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe3            7
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe3       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe3    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe4            0x00000100U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe4            8
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe4       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe4    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe5            0x00000200U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe5            9
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe5       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe5    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe6            0x00000400U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe6            10
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe6       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe6    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe7            0x00000800U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe7            11
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe7       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe7    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe8            0x00001000U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe8            12
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe8       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe8    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_set_observe9            0x00002000U
#define SRT_NX90_nfifo_irq_arm_app_msk_set_observe9            13
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_set_observe9       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_set_observe9    0x00000000U

/* all used bits of 'NX90_nfifo_irq_arm_app_msk_set': */
#define MSK_USED_BITS_NX90_nfifo_irq_arm_app_msk_set 0x00003fffU

enum {
  BFW_NX90_nfifo_irq_arm_app_msk_set_ahbl_error  = 1,  /* [0] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_read        = 1,  /* [1] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_write       = 1,  /* [2] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_fifo_active = 1,  /* [3] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe0    = 1,  /* [4] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe1    = 1,  /* [5] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe2    = 1,  /* [6] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe3    = 1,  /* [7] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe4    = 1,  /* [8] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe5    = 1,  /* [9] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe6    = 1,  /* [10] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe7    = 1,  /* [11] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe8    = 1,  /* [12] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_observe9    = 1,  /* [13] */
  BFW_NX90_nfifo_irq_arm_app_msk_set_reserved1   = 18  /* [31:14] */
};

typedef struct NX90_NFIFO_IRQ_ARM_APP_MSK_SET_BIT_Ttag {
  unsigned int ahbl_error  : BFW_NX90_nfifo_irq_arm_app_msk_set_ahbl_error;  /* AHBL returned HRESP=1 (abort)                                                       */
  unsigned int read        : BFW_NX90_nfifo_irq_arm_app_msk_set_read;        /* any read access happened to any FIFO                                                */
  unsigned int write       : BFW_NX90_nfifo_irq_arm_app_msk_set_write;       /* any write access happened to any FIFO                                               */
  unsigned int fifo_active : BFW_NX90_nfifo_irq_arm_app_msk_set_fifo_active; /* any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) */
  unsigned int observe0    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe0;    /* access to FIFO as defined in observe0                                               */
  unsigned int observe1    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe1;    /* access to FIFO as defined in observe1                                               */
  unsigned int observe2    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe2;    /* access to FIFO as defined in observe2                                               */
  unsigned int observe3    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe3;    /* access to FIFO as defined in observe3                                               */
  unsigned int observe4    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe4;    /* access to FIFO as defined in observe4                                               */
  unsigned int observe5    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe5;    /* access to FIFO as defined in observe5                                               */
  unsigned int observe6    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe6;    /* access to FIFO as defined in observe6                                               */
  unsigned int observe7    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe7;    /* access to FIFO as defined in observe7                                               */
  unsigned int observe8    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe8;    /* access to FIFO as defined in observe8                                               */
  unsigned int observe9    : BFW_NX90_nfifo_irq_arm_app_msk_set_observe9;    /* access to FIFO as defined in observe9                                               */
  unsigned int reserved1   : BFW_NX90_nfifo_irq_arm_app_msk_set_reserved1;   /* reserved                                                                            */
} NX90_NFIFO_IRQ_ARM_APP_MSK_SET_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_NFIFO_IRQ_ARM_APP_MSK_SET_BIT_T bf;
} NX90_NFIFO_IRQ_ARM_APP_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_arm_app_msk_reset */
/* => ARM_APP Cortex M4 IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_arm_app_msk_reset   0x00000018U
#define Adr_NX90_nfifo_nfifo_irq_arm_app_msk_reset 0xFF400018U
#define Adr_NX90_nfifo_irq_arm_app_msk_reset       0xFF400018U
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset  0x00000000U

#define MSK_NX90_nfifo_irq_arm_app_msk_reset_ahbl_error          0x00000001U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_ahbl_error          0
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_ahbl_error     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_ahbl_error  0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_read                0x00000002U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_read                1
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_read           0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_read        0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_write               0x00000004U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_write               2
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_write          0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_write       0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_fifo_active         0x00000008U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_fifo_active         3
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_fifo_active    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_fifo_active 0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe0            0x00000010U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe0            4
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe0       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe0    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe1            0x00000020U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe1            5
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe1       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe1    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe2            0x00000040U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe2            6
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe2       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe2    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe3            0x00000080U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe3            7
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe3       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe3    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe4            0x00000100U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe4            8
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe4       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe4    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe5            0x00000200U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe5            9
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe5       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe5    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe6            0x00000400U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe6            10
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe6       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe6    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe7            0x00000800U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe7            11
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe7       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe7    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe8            0x00001000U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe8            12
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe8       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe8    0x00000000U
#define MSK_NX90_nfifo_irq_arm_app_msk_reset_observe9            0x00002000U
#define SRT_NX90_nfifo_irq_arm_app_msk_reset_observe9            13
#define DFLT_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe9       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_arm_app_msk_reset_observe9    0x00000000U

/* all used bits of 'NX90_nfifo_irq_arm_app_msk_reset': */
#define MSK_USED_BITS_NX90_nfifo_irq_arm_app_msk_reset 0x00003fffU

enum {
  BFW_NX90_nfifo_irq_arm_app_msk_reset_ahbl_error  = 1,  /* [0] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_read        = 1,  /* [1] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_write       = 1,  /* [2] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_fifo_active = 1,  /* [3] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe0    = 1,  /* [4] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe1    = 1,  /* [5] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe2    = 1,  /* [6] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe3    = 1,  /* [7] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe4    = 1,  /* [8] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe5    = 1,  /* [9] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe6    = 1,  /* [10] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe7    = 1,  /* [11] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe8    = 1,  /* [12] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_observe9    = 1,  /* [13] */
  BFW_NX90_nfifo_irq_arm_app_msk_reset_reserved1   = 18  /* [31:14] */
};

typedef struct NX90_NFIFO_IRQ_ARM_APP_MSK_RESET_BIT_Ttag {
  unsigned int ahbl_error  : BFW_NX90_nfifo_irq_arm_app_msk_reset_ahbl_error;  /* AHBL returned HRESP=1 (abort)                                                       */
  unsigned int read        : BFW_NX90_nfifo_irq_arm_app_msk_reset_read;        /* any read access happened to any FIFO                                                */
  unsigned int write       : BFW_NX90_nfifo_irq_arm_app_msk_reset_write;       /* any write access happened to any FIFO                                               */
  unsigned int fifo_active : BFW_NX90_nfifo_irq_arm_app_msk_reset_fifo_active; /* any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) */
  unsigned int observe0    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe0;    /* access to FIFO as defined in observe0                                               */
  unsigned int observe1    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe1;    /* access to FIFO as defined in observe1                                               */
  unsigned int observe2    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe2;    /* access to FIFO as defined in observe2                                               */
  unsigned int observe3    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe3;    /* access to FIFO as defined in observe3                                               */
  unsigned int observe4    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe4;    /* access to FIFO as defined in observe4                                               */
  unsigned int observe5    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe5;    /* access to FIFO as defined in observe5                                               */
  unsigned int observe6    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe6;    /* access to FIFO as defined in observe6                                               */
  unsigned int observe7    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe7;    /* access to FIFO as defined in observe7                                               */
  unsigned int observe8    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe8;    /* access to FIFO as defined in observe8                                               */
  unsigned int observe9    : BFW_NX90_nfifo_irq_arm_app_msk_reset_observe9;    /* access to FIFO as defined in observe9                                               */
  unsigned int reserved1   : BFW_NX90_nfifo_irq_arm_app_msk_reset_reserved1;   /* reserved                                                                            */
} NX90_NFIFO_IRQ_ARM_APP_MSK_RESET_BIT_T;

typedef union {
  uint32_t                               val;
  NX90_NFIFO_IRQ_ARM_APP_MSK_RESET_BIT_T bf;
} NX90_NFIFO_IRQ_ARM_APP_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_xpic_app_masked */
/* => Masked IRQ of xPIC_APP: */
/*    Shows status of masked IRQs as connected to xPIC_APP. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_xpic_app_masked   0x00000028U
#define Adr_NX90_nfifo_nfifo_irq_xpic_app_masked 0xFF400028U
#define Adr_NX90_nfifo_irq_xpic_app_masked       0xFF400028U

#define MSK_NX90_nfifo_irq_xpic_app_masked_ahbl_error  0x00000001U
#define SRT_NX90_nfifo_irq_xpic_app_masked_ahbl_error  0
#define MSK_NX90_nfifo_irq_xpic_app_masked_read        0x00000002U
#define SRT_NX90_nfifo_irq_xpic_app_masked_read        1
#define MSK_NX90_nfifo_irq_xpic_app_masked_write       0x00000004U
#define SRT_NX90_nfifo_irq_xpic_app_masked_write       2
#define MSK_NX90_nfifo_irq_xpic_app_masked_fifo_active 0x00000008U
#define SRT_NX90_nfifo_irq_xpic_app_masked_fifo_active 3
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe0    0x00000010U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe0    4
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe1    0x00000020U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe1    5
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe2    0x00000040U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe2    6
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe3    0x00000080U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe3    7
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe4    0x00000100U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe4    8
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe5    0x00000200U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe5    9
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe6    0x00000400U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe6    10
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe7    0x00000800U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe7    11
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe8    0x00001000U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe8    12
#define MSK_NX90_nfifo_irq_xpic_app_masked_observe9    0x00002000U
#define SRT_NX90_nfifo_irq_xpic_app_masked_observe9    13

/* all used bits of 'NX90_nfifo_irq_xpic_app_masked': */
#define MSK_USED_BITS_NX90_nfifo_irq_xpic_app_masked 0x00003fffU

enum {
  BFW_NX90_nfifo_irq_xpic_app_masked_ahbl_error  = 1,  /* [0] */
  BFW_NX90_nfifo_irq_xpic_app_masked_read        = 1,  /* [1] */
  BFW_NX90_nfifo_irq_xpic_app_masked_write       = 1,  /* [2] */
  BFW_NX90_nfifo_irq_xpic_app_masked_fifo_active = 1,  /* [3] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe0    = 1,  /* [4] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe1    = 1,  /* [5] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe2    = 1,  /* [6] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe3    = 1,  /* [7] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe4    = 1,  /* [8] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe5    = 1,  /* [9] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe6    = 1,  /* [10] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe7    = 1,  /* [11] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe8    = 1,  /* [12] */
  BFW_NX90_nfifo_irq_xpic_app_masked_observe9    = 1,  /* [13] */
  BFW_NX90_nfifo_irq_xpic_app_masked_reserved1   = 18  /* [31:14] */
};

typedef struct NX90_NFIFO_IRQ_XPIC_APP_MASKED_BIT_Ttag {
  unsigned int ahbl_error  : BFW_NX90_nfifo_irq_xpic_app_masked_ahbl_error;  /* AHBL returned HRESP=1 (abort)                                                       */
  unsigned int read        : BFW_NX90_nfifo_irq_xpic_app_masked_read;        /* any read access happened to any FIFO                                                */
  unsigned int write       : BFW_NX90_nfifo_irq_xpic_app_masked_write;       /* any write access happened to any FIFO                                               */
  unsigned int fifo_active : BFW_NX90_nfifo_irq_xpic_app_masked_fifo_active; /* any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) */
  unsigned int observe0    : BFW_NX90_nfifo_irq_xpic_app_masked_observe0;    /* access to FIFO as defined in observe0                                               */
  unsigned int observe1    : BFW_NX90_nfifo_irq_xpic_app_masked_observe1;    /* access to FIFO as defined in observe1                                               */
  unsigned int observe2    : BFW_NX90_nfifo_irq_xpic_app_masked_observe2;    /* access to FIFO as defined in observe2                                               */
  unsigned int observe3    : BFW_NX90_nfifo_irq_xpic_app_masked_observe3;    /* access to FIFO as defined in observe3                                               */
  unsigned int observe4    : BFW_NX90_nfifo_irq_xpic_app_masked_observe4;    /* access to FIFO as defined in observe4                                               */
  unsigned int observe5    : BFW_NX90_nfifo_irq_xpic_app_masked_observe5;    /* access to FIFO as defined in observe5                                               */
  unsigned int observe6    : BFW_NX90_nfifo_irq_xpic_app_masked_observe6;    /* access to FIFO as defined in observe6                                               */
  unsigned int observe7    : BFW_NX90_nfifo_irq_xpic_app_masked_observe7;    /* access to FIFO as defined in observe7                                               */
  unsigned int observe8    : BFW_NX90_nfifo_irq_xpic_app_masked_observe8;    /* access to FIFO as defined in observe8                                               */
  unsigned int observe9    : BFW_NX90_nfifo_irq_xpic_app_masked_observe9;    /* access to FIFO as defined in observe9                                               */
  unsigned int reserved1   : BFW_NX90_nfifo_irq_xpic_app_masked_reserved1;   /* reserved                                                                            */
} NX90_NFIFO_IRQ_XPIC_APP_MASKED_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_NFIFO_IRQ_XPIC_APP_MASKED_BIT_T bf;
} NX90_NFIFO_IRQ_XPIC_APP_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_xpic_app_msk_set */
/* => xPIC_APP IRQ mask set: */
/*    The xPIC_APP IRQ mask enables interrupt requests for corresponding interrupt sources to the xPIC_APP processor. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_nfifo_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_xpic_app_msk_set   0x0000002CU
#define Adr_NX90_nfifo_nfifo_irq_xpic_app_msk_set 0xFF40002CU
#define Adr_NX90_nfifo_irq_xpic_app_msk_set       0xFF40002CU
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set  0x00000000U

#define MSK_NX90_nfifo_irq_xpic_app_msk_set_ahbl_error          0x00000001U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_ahbl_error          0
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_ahbl_error     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_ahbl_error  0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_read                0x00000002U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_read                1
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_read           0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_read        0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_write               0x00000004U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_write               2
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_write          0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_write       0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_fifo_active         0x00000008U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_fifo_active         3
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_fifo_active    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_fifo_active 0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe0            0x00000010U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe0            4
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe0       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe0    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe1            0x00000020U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe1            5
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe1       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe1    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe2            0x00000040U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe2            6
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe2       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe2    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe3            0x00000080U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe3            7
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe3       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe3    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe4            0x00000100U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe4            8
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe4       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe4    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe5            0x00000200U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe5            9
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe5       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe5    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe6            0x00000400U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe6            10
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe6       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe6    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe7            0x00000800U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe7            11
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe7       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe7    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe8            0x00001000U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe8            12
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe8       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe8    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_set_observe9            0x00002000U
#define SRT_NX90_nfifo_irq_xpic_app_msk_set_observe9            13
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe9       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_set_observe9    0x00000000U

/* all used bits of 'NX90_nfifo_irq_xpic_app_msk_set': */
#define MSK_USED_BITS_NX90_nfifo_irq_xpic_app_msk_set 0x00003fffU

enum {
  BFW_NX90_nfifo_irq_xpic_app_msk_set_ahbl_error  = 1,  /* [0] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_read        = 1,  /* [1] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_write       = 1,  /* [2] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_fifo_active = 1,  /* [3] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe0    = 1,  /* [4] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe1    = 1,  /* [5] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe2    = 1,  /* [6] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe3    = 1,  /* [7] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe4    = 1,  /* [8] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe5    = 1,  /* [9] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe6    = 1,  /* [10] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe7    = 1,  /* [11] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe8    = 1,  /* [12] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_observe9    = 1,  /* [13] */
  BFW_NX90_nfifo_irq_xpic_app_msk_set_reserved1   = 18  /* [31:14] */
};

typedef struct NX90_NFIFO_IRQ_XPIC_APP_MSK_SET_BIT_Ttag {
  unsigned int ahbl_error  : BFW_NX90_nfifo_irq_xpic_app_msk_set_ahbl_error;  /* AHBL returned HRESP=1 (abort)                                                       */
  unsigned int read        : BFW_NX90_nfifo_irq_xpic_app_msk_set_read;        /* any read access happened to any FIFO                                                */
  unsigned int write       : BFW_NX90_nfifo_irq_xpic_app_msk_set_write;       /* any write access happened to any FIFO                                               */
  unsigned int fifo_active : BFW_NX90_nfifo_irq_xpic_app_msk_set_fifo_active; /* any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) */
  unsigned int observe0    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe0;    /* access to FIFO as defined in observe0                                               */
  unsigned int observe1    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe1;    /* access to FIFO as defined in observe1                                               */
  unsigned int observe2    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe2;    /* access to FIFO as defined in observe2                                               */
  unsigned int observe3    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe3;    /* access to FIFO as defined in observe3                                               */
  unsigned int observe4    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe4;    /* access to FIFO as defined in observe4                                               */
  unsigned int observe5    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe5;    /* access to FIFO as defined in observe5                                               */
  unsigned int observe6    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe6;    /* access to FIFO as defined in observe6                                               */
  unsigned int observe7    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe7;    /* access to FIFO as defined in observe7                                               */
  unsigned int observe8    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe8;    /* access to FIFO as defined in observe8                                               */
  unsigned int observe9    : BFW_NX90_nfifo_irq_xpic_app_msk_set_observe9;    /* access to FIFO as defined in observe9                                               */
  unsigned int reserved1   : BFW_NX90_nfifo_irq_xpic_app_msk_set_reserved1;   /* reserved                                                                            */
} NX90_NFIFO_IRQ_XPIC_APP_MSK_SET_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_NFIFO_IRQ_XPIC_APP_MSK_SET_BIT_T bf;
} NX90_NFIFO_IRQ_XPIC_APP_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_xpic_app_msk_reset */
/* => xPIC_APP IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_xpic_app_msk_reset   0x00000030U
#define Adr_NX90_nfifo_nfifo_irq_xpic_app_msk_reset 0xFF400030U
#define Adr_NX90_nfifo_irq_xpic_app_msk_reset       0xFF400030U
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset  0x00000000U

#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_ahbl_error          0x00000001U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_ahbl_error          0
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_ahbl_error     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_ahbl_error  0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_read                0x00000002U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_read                1
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_read           0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_read        0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_write               0x00000004U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_write               2
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_write          0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_write       0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_fifo_active         0x00000008U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_fifo_active         3
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_fifo_active    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_fifo_active 0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe0            0x00000010U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe0            4
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe0       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe0    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe1            0x00000020U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe1            5
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe1       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe1    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe2            0x00000040U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe2            6
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe2       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe2    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe3            0x00000080U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe3            7
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe3       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe3    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe4            0x00000100U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe4            8
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe4       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe4    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe5            0x00000200U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe5            9
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe5       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe5    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe6            0x00000400U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe6            10
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe6       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe6    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe7            0x00000800U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe7            11
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe7       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe7    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe8            0x00001000U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe8            12
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe8       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe8    0x00000000U
#define MSK_NX90_nfifo_irq_xpic_app_msk_reset_observe9            0x00002000U
#define SRT_NX90_nfifo_irq_xpic_app_msk_reset_observe9            13
#define DFLT_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe9       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_xpic_app_msk_reset_observe9    0x00000000U

/* all used bits of 'NX90_nfifo_irq_xpic_app_msk_reset': */
#define MSK_USED_BITS_NX90_nfifo_irq_xpic_app_msk_reset 0x00003fffU

enum {
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_ahbl_error  = 1,  /* [0] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_read        = 1,  /* [1] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_write       = 1,  /* [2] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_fifo_active = 1,  /* [3] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe0    = 1,  /* [4] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe1    = 1,  /* [5] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe2    = 1,  /* [6] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe3    = 1,  /* [7] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe4    = 1,  /* [8] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe5    = 1,  /* [9] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe6    = 1,  /* [10] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe7    = 1,  /* [11] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe8    = 1,  /* [12] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe9    = 1,  /* [13] */
  BFW_NX90_nfifo_irq_xpic_app_msk_reset_reserved1   = 18  /* [31:14] */
};

typedef struct NX90_NFIFO_IRQ_XPIC_APP_MSK_RESET_BIT_Ttag {
  unsigned int ahbl_error  : BFW_NX90_nfifo_irq_xpic_app_msk_reset_ahbl_error;  /* AHBL returned HRESP=1 (abort)                                                       */
  unsigned int read        : BFW_NX90_nfifo_irq_xpic_app_msk_reset_read;        /* any read access happened to any FIFO                                                */
  unsigned int write       : BFW_NX90_nfifo_irq_xpic_app_msk_reset_write;       /* any write access happened to any FIFO                                               */
  unsigned int fifo_active : BFW_NX90_nfifo_irq_xpic_app_msk_reset_fifo_active; /* any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) */
  unsigned int observe0    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe0;    /* access to FIFO as defined in observe0                                               */
  unsigned int observe1    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe1;    /* access to FIFO as defined in observe1                                               */
  unsigned int observe2    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe2;    /* access to FIFO as defined in observe2                                               */
  unsigned int observe3    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe3;    /* access to FIFO as defined in observe3                                               */
  unsigned int observe4    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe4;    /* access to FIFO as defined in observe4                                               */
  unsigned int observe5    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe5;    /* access to FIFO as defined in observe5                                               */
  unsigned int observe6    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe6;    /* access to FIFO as defined in observe6                                               */
  unsigned int observe7    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe7;    /* access to FIFO as defined in observe7                                               */
  unsigned int observe8    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe8;    /* access to FIFO as defined in observe8                                               */
  unsigned int observe9    : BFW_NX90_nfifo_irq_xpic_app_msk_reset_observe9;    /* access to FIFO as defined in observe9                                               */
  unsigned int reserved1   : BFW_NX90_nfifo_irq_xpic_app_msk_reset_reserved1;   /* reserved                                                                            */
} NX90_NFIFO_IRQ_XPIC_APP_MSK_RESET_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_NFIFO_IRQ_XPIC_APP_MSK_RESET_BIT_T bf;
} NX90_NFIFO_IRQ_XPIC_APP_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe0 */
/* => FIFO OBSERVE0: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe0   0x00000058U
#define Adr_NX90_nfifo_nfifo_irq_observe0 0xFF400058U
#define Adr_NX90_nfifo_irq_observe0       0xFF400058U
#define DFLT_VAL_NX90_nfifo_irq_observe0  0x00000000U

#define MSK_NX90_nfifo_irq_observe0_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe0_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe0_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe0_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe0_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe0_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe0_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe0_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe0_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe0_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe0_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe0_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe0_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe0_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe0_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe0_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe0_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe0_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe0_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe0_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe0_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe0_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe0_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe0_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe0_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe0_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe0_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe0_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe0': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe0 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe0_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe0_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe0_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe0_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe0_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe0_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe0_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe0_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe0_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe0_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe0_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE0_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe0_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe0_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe0_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe0_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe0_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe0_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe0_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe0_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe0_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe0_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe0_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE0_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE0_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe1 */
/* => FIFO OBSERVE1: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe1   0x0000005CU
#define Adr_NX90_nfifo_nfifo_irq_observe1 0xFF40005CU
#define Adr_NX90_nfifo_irq_observe1       0xFF40005CU
#define DFLT_VAL_NX90_nfifo_irq_observe1  0x00000000U

#define MSK_NX90_nfifo_irq_observe1_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe1_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe1_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe1_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe1_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe1_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe1_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe1_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe1_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe1_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe1_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe1_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe1_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe1_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe1_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe1_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe1_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe1_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe1_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe1_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe1_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe1_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe1_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe1_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe1_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe1_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe1_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe1_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe1': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe1 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe1_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe1_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe1_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe1_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe1_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe1_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe1_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe1_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe1_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe1_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe1_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE1_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe1_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe1_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe1_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe1_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe1_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe1_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe1_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe1_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe1_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe1_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe1_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE1_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE1_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe2 */
/* => FIFO OBSERVE2: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe2   0x00000060U
#define Adr_NX90_nfifo_nfifo_irq_observe2 0xFF400060U
#define Adr_NX90_nfifo_irq_observe2       0xFF400060U
#define DFLT_VAL_NX90_nfifo_irq_observe2  0x00000000U

#define MSK_NX90_nfifo_irq_observe2_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe2_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe2_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe2_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe2_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe2_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe2_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe2_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe2_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe2_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe2_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe2_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe2_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe2_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe2_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe2_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe2_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe2_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe2_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe2_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe2_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe2_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe2_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe2_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe2_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe2_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe2_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe2_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe2': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe2 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe2_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe2_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe2_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe2_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe2_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe2_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe2_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe2_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe2_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe2_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe2_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE2_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe2_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe2_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe2_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe2_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe2_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe2_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe2_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe2_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe2_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe2_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe2_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE2_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE2_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe3 */
/* => FIFO OBSERVE3: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe3   0x00000064U
#define Adr_NX90_nfifo_nfifo_irq_observe3 0xFF400064U
#define Adr_NX90_nfifo_irq_observe3       0xFF400064U
#define DFLT_VAL_NX90_nfifo_irq_observe3  0x00000000U

#define MSK_NX90_nfifo_irq_observe3_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe3_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe3_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe3_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe3_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe3_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe3_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe3_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe3_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe3_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe3_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe3_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe3_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe3_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe3_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe3_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe3_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe3_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe3_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe3_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe3_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe3_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe3_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe3_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe3_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe3_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe3_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe3_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe3': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe3 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe3_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe3_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe3_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe3_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe3_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe3_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe3_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe3_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe3_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe3_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe3_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE3_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe3_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe3_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe3_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe3_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe3_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe3_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe3_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe3_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe3_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe3_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe3_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE3_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE3_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE3_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe4 */
/* => FIFO OBSERVE4: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe4   0x00000068U
#define Adr_NX90_nfifo_nfifo_irq_observe4 0xFF400068U
#define Adr_NX90_nfifo_irq_observe4       0xFF400068U
#define DFLT_VAL_NX90_nfifo_irq_observe4  0x00000000U

#define MSK_NX90_nfifo_irq_observe4_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe4_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe4_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe4_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe4_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe4_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe4_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe4_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe4_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe4_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe4_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe4_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe4_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe4_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe4_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe4_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe4_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe4_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe4_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe4_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe4_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe4_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe4_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe4_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe4_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe4_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe4_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe4_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe4': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe4 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe4_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe4_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe4_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe4_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe4_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe4_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe4_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe4_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe4_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe4_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe4_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE4_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe4_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe4_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe4_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe4_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe4_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe4_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe4_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe4_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe4_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe4_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe4_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE4_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE4_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE4_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe5 */
/* => FIFO OBSERVE5: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe5   0x0000006CU
#define Adr_NX90_nfifo_nfifo_irq_observe5 0xFF40006CU
#define Adr_NX90_nfifo_irq_observe5       0xFF40006CU
#define DFLT_VAL_NX90_nfifo_irq_observe5  0x00000000U

#define MSK_NX90_nfifo_irq_observe5_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe5_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe5_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe5_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe5_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe5_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe5_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe5_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe5_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe5_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe5_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe5_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe5_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe5_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe5_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe5_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe5_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe5_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe5_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe5_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe5_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe5_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe5_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe5_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe5_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe5_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe5_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe5_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe5': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe5 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe5_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe5_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe5_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe5_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe5_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe5_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe5_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe5_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe5_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe5_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe5_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE5_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe5_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe5_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe5_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe5_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe5_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe5_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe5_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe5_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe5_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe5_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe5_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE5_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE5_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE5_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe6 */
/* => FIFO OBSERVE6: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe6   0x00000070U
#define Adr_NX90_nfifo_nfifo_irq_observe6 0xFF400070U
#define Adr_NX90_nfifo_irq_observe6       0xFF400070U
#define DFLT_VAL_NX90_nfifo_irq_observe6  0x00000000U

#define MSK_NX90_nfifo_irq_observe6_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe6_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe6_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe6_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe6_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe6_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe6_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe6_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe6_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe6_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe6_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe6_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe6_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe6_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe6_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe6_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe6_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe6_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe6_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe6_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe6_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe6_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe6_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe6_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe6_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe6_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe6_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe6_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe6': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe6 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe6_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe6_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe6_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe6_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe6_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe6_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe6_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe6_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe6_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe6_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe6_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE6_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe6_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe6_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe6_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe6_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe6_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe6_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe6_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe6_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe6_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe6_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe6_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE6_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE6_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE6_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe7 */
/* => FIFO OBSERVE7: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe7   0x00000074U
#define Adr_NX90_nfifo_nfifo_irq_observe7 0xFF400074U
#define Adr_NX90_nfifo_irq_observe7       0xFF400074U
#define DFLT_VAL_NX90_nfifo_irq_observe7  0x00000000U

#define MSK_NX90_nfifo_irq_observe7_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe7_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe7_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe7_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe7_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe7_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe7_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe7_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe7_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe7_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe7_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe7_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe7_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe7_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe7_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe7_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe7_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe7_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe7_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe7_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe7_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe7_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe7_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe7_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe7_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe7_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe7_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe7_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe7': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe7 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe7_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe7_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe7_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe7_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe7_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe7_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe7_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe7_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe7_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe7_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe7_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE7_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe7_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe7_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe7_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe7_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe7_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe7_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe7_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe7_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe7_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe7_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe7_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE7_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE7_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE7_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe8 */
/* => FIFO OBSERVE8: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe8   0x00000078U
#define Adr_NX90_nfifo_nfifo_irq_observe8 0xFF400078U
#define Adr_NX90_nfifo_irq_observe8       0xFF400078U
#define DFLT_VAL_NX90_nfifo_irq_observe8  0x00000000U

#define MSK_NX90_nfifo_irq_observe8_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe8_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe8_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe8_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe8_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe8_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe8_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe8_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe8_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe8_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe8_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe8_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe8_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe8_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe8_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe8_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe8_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe8_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe8_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe8_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe8_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe8_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe8_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe8_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe8_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe8_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe8_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe8_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe8': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe8 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe8_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe8_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe8_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe8_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe8_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe8_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe8_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe8_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe8_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe8_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe8_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE8_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe8_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe8_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe8_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe8_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe8_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe8_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe8_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe8_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe8_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe8_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe8_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE8_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE8_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE8_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_observe9 */
/* => FIFO OBSERVE9: */
/*    This register configures the observation unit that allows to observe one FIFO for special events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_irq_observe9   0x0000007CU
#define Adr_NX90_nfifo_nfifo_irq_observe9 0xFF40007CU
#define Adr_NX90_nfifo_irq_observe9       0xFF40007CU
#define DFLT_VAL_NX90_nfifo_irq_observe9  0x00000000U

#define MSK_NX90_nfifo_irq_observe9_fifonr         0x000003ffU
#define SRT_NX90_nfifo_irq_observe9_fifonr         0
#define DFLT_VAL_NX90_nfifo_irq_observe9_fifonr    0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_fifonr 0x00000000U
#define MSK_NX90_nfifo_irq_observe9_read           0x00008000U
#define SRT_NX90_nfifo_irq_observe9_read           15
#define DFLT_VAL_NX90_nfifo_irq_observe9_read      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_read   0x00000000U
#define MSK_NX90_nfifo_irq_observe9_undr           0x00010000U
#define SRT_NX90_nfifo_irq_observe9_undr           16
#define DFLT_VAL_NX90_nfifo_irq_observe9_undr      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_undr   0x00000000U
#define MSK_NX90_nfifo_irq_observe9_emw            0x00020000U
#define SRT_NX90_nfifo_irq_observe9_emw            17
#define DFLT_VAL_NX90_nfifo_irq_observe9_emw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_emw    0x00000000U
#define MSK_NX90_nfifo_irq_observe9_empty          0x00040000U
#define SRT_NX90_nfifo_irq_observe9_empty          18
#define DFLT_VAL_NX90_nfifo_irq_observe9_empty     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_empty  0x00000000U
#define MSK_NX90_nfifo_irq_observe9_write          0x00080000U
#define SRT_NX90_nfifo_irq_observe9_write          19
#define DFLT_VAL_NX90_nfifo_irq_observe9_write     0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_write  0x00000000U
#define MSK_NX90_nfifo_irq_observe9_ovfl           0x00100000U
#define SRT_NX90_nfifo_irq_observe9_ovfl           20
#define DFLT_VAL_NX90_nfifo_irq_observe9_ovfl      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_ovfl   0x00000000U
#define MSK_NX90_nfifo_irq_observe9_fmw            0x00200000U
#define SRT_NX90_nfifo_irq_observe9_fmw            21
#define DFLT_VAL_NX90_nfifo_irq_observe9_fmw       0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_fmw    0x00000000U
#define MSK_NX90_nfifo_irq_observe9_full           0x00400000U
#define SRT_NX90_nfifo_irq_observe9_full           22
#define DFLT_VAL_NX90_nfifo_irq_observe9_full      0x00000000U
#define DFLT_BF_VAL_NX90_nfifo_irq_observe9_full   0x00000000U

/* all used bits of 'NX90_nfifo_irq_observe9': */
#define MSK_USED_BITS_NX90_nfifo_irq_observe9 0x007f83ffU

enum {
  BFW_NX90_nfifo_irq_observe9_fifonr    = 10, /* [9:0] */
  BFW_NX90_nfifo_irq_observe9_reserved1 = 5,  /* [14:10] */
  BFW_NX90_nfifo_irq_observe9_read      = 1,  /* [15] */
  BFW_NX90_nfifo_irq_observe9_undr      = 1,  /* [16] */
  BFW_NX90_nfifo_irq_observe9_emw       = 1,  /* [17] */
  BFW_NX90_nfifo_irq_observe9_empty     = 1,  /* [18] */
  BFW_NX90_nfifo_irq_observe9_write     = 1,  /* [19] */
  BFW_NX90_nfifo_irq_observe9_ovfl      = 1,  /* [20] */
  BFW_NX90_nfifo_irq_observe9_fmw       = 1,  /* [21] */
  BFW_NX90_nfifo_irq_observe9_full      = 1,  /* [22] */
  BFW_NX90_nfifo_irq_observe9_reserved2 = 9   /* [31:23] */
};

typedef struct NX90_NFIFO_IRQ_OBSERVE9_BIT_Ttag {
  unsigned int fifonr    : BFW_NX90_nfifo_irq_observe9_fifonr;    /* Number of FIFO to be observed                        */
  unsigned int reserved1 : BFW_NX90_nfifo_irq_observe9_reserved1; /* reserved                                             */
  unsigned int read      : BFW_NX90_nfifo_irq_observe9_read;      /* Activate IRQ in case of any read access              */
  unsigned int undr      : BFW_NX90_nfifo_irq_observe9_undr;      /* Activate IRQ in case of FIFO underrun                */
  unsigned int emw       : BFW_NX90_nfifo_irq_observe9_emw;       /* Activate IRQ in case of Empty-Minus-Watermark is set */
  unsigned int empty     : BFW_NX90_nfifo_irq_observe9_empty;     /* Activate IRQ in case of FIFO gets empty              */
  unsigned int write     : BFW_NX90_nfifo_irq_observe9_write;     /* Activate IRQ in case of any write access             */
  unsigned int ovfl      : BFW_NX90_nfifo_irq_observe9_ovfl;      /* Activate IRQ in case of FIFO overflow                */
  unsigned int fmw       : BFW_NX90_nfifo_irq_observe9_fmw;       /* Activate IRQ in case of Full-Minus-Watermark is set  */
  unsigned int full      : BFW_NX90_nfifo_irq_observe9_full;      /* Activate IRQ in case of FIFO gets full               */
  unsigned int reserved2 : BFW_NX90_nfifo_irq_observe9_reserved2; /* reserved                                             */
} NX90_NFIFO_IRQ_OBSERVE9_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_NFIFO_IRQ_OBSERVE9_BIT_T bf;
} NX90_NFIFO_IRQ_OBSERVE9_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_fifo_start */
/* => Start of NFIFO FIFO access addresses: */
/*    The following DW-addresses are associated with FIFOs: */
/*    Read accesses to an address in this area are reading from the appropriate FIFO, */
/*    write accesses to an address in this area are writing to the appropriate FIFO. */
/*    The number of FIFOs is limited by this address area to 991. */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_fifo_start   0x00000080U
#define Adr_NX90_nfifo_nfifo_fifo_start 0xFF400080U
#define Adr_NX90_nfifo_fifo_start       0xFF400080U

/* --------------------------------------------------------------------- */
/* Register nfifo_fifo_end */
/* => End of NFIFO FIFO access addresses */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_nfifo_fifo_end   0x00000FFCU
#define Adr_NX90_nfifo_nfifo_fifo_end 0xFF400FFCU
#define Adr_NX90_nfifo_fifo_end       0xFF400FFCU


/* ===================================================================== */

/* Area of pad_ctrl */

/* ===================================================================== */

#define Addr_NX90_pad_ctrl 0xFF401000U

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_rdy_n */
/* => Pad configuration register of port RDY_N (asic_ctrl_access_key protected). */
/*    Pad type: PRUW0408SCDG_33 */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    Programable pad functions are: */
/*       ds:   Driving strength: 0: low driving strength (default), 1: high driving strength. */
/*       pe:   Pull enable: 0: No resistor is applied, 1: resistor is enabled. */
/*             The pull-direction (up or down) is determined by the pad-type. */
/*       ie:   Input enable: 0: Digital pad input function disabled, 1: input is enabled. */
/*    Note: */
/*       Not all functions are available for all pads, it depends on the pad type. */
/*       Functions not found as programmable bit in the register of a pad are not supported by the pad. */
/*    Note: */
/*       The default states are alreday applied during reset. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_rdy_n      0x00000000U
#define Adr_NX90_pad_ctrl_pad_ctrl_rdy_n 0xFF401000U
#define Adr_NX90_pad_ctrl_rdy_n          0xFF401000U
#define DFLT_VAL_NX90_pad_ctrl_rdy_n     0x00000050U

#define MSK_NX90_pad_ctrl_rdy_n_ds         0x00000001U
#define SRT_NX90_pad_ctrl_rdy_n_ds         0
#define DFLT_VAL_NX90_pad_ctrl_rdy_n_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_rdy_n_ds 0x00000000U
#define MSK_NX90_pad_ctrl_rdy_n_pe         0x00000010U
#define SRT_NX90_pad_ctrl_rdy_n_pe         4
#define DFLT_VAL_NX90_pad_ctrl_rdy_n_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_rdy_n_pe 0x00000001U
#define MSK_NX90_pad_ctrl_rdy_n_ie         0x00000040U
#define SRT_NX90_pad_ctrl_rdy_n_ie         6
#define DFLT_VAL_NX90_pad_ctrl_rdy_n_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_rdy_n_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_rdy_n': */
#define MSK_USED_BITS_NX90_pad_ctrl_rdy_n 0x00000051U

enum {
  BFW_NX90_pad_ctrl_rdy_n_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_rdy_n_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_rdy_n_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_rdy_n_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_rdy_n_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_rdy_n_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_RDY_N_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_rdy_n_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_rdy_n_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_rdy_n_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_rdy_n_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_rdy_n_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_rdy_n_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_RDY_N_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_RDY_N_BIT_T bf;
} NX90_PAD_CTRL_RDY_N_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_run_n */
/* => Pad configuration register of port RUN_N (asic_ctrl_access_key protected). */
/*    Pad type: PRUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_run_n      0x00000004U
#define Adr_NX90_pad_ctrl_pad_ctrl_run_n 0xFF401004U
#define Adr_NX90_pad_ctrl_run_n          0xFF401004U
#define DFLT_VAL_NX90_pad_ctrl_run_n     0x00000050U

#define MSK_NX90_pad_ctrl_run_n_ds         0x00000001U
#define SRT_NX90_pad_ctrl_run_n_ds         0
#define DFLT_VAL_NX90_pad_ctrl_run_n_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_run_n_ds 0x00000000U
#define MSK_NX90_pad_ctrl_run_n_pe         0x00000010U
#define SRT_NX90_pad_ctrl_run_n_pe         4
#define DFLT_VAL_NX90_pad_ctrl_run_n_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_run_n_pe 0x00000001U
#define MSK_NX90_pad_ctrl_run_n_ie         0x00000040U
#define SRT_NX90_pad_ctrl_run_n_ie         6
#define DFLT_VAL_NX90_pad_ctrl_run_n_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_run_n_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_run_n': */
#define MSK_USED_BITS_NX90_pad_ctrl_run_n 0x00000051U

enum {
  BFW_NX90_pad_ctrl_run_n_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_run_n_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_run_n_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_run_n_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_run_n_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_run_n_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_RUN_N_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_run_n_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_run_n_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_run_n_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_run_n_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_run_n_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_run_n_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_RUN_N_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_RUN_N_BIT_T bf;
} NX90_PAD_CTRL_RUN_N_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mled0 */
/* => Pad configuration register of port MLED0 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408CDG_33(o) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mled0      0x00000008U
#define Adr_NX90_pad_ctrl_pad_ctrl_mled0 0xFF401008U
#define Adr_NX90_pad_ctrl_mled0          0xFF401008U
#define DFLT_VAL_NX90_pad_ctrl_mled0     0x00000000U

#define MSK_NX90_pad_ctrl_mled0_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mled0_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mled0_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled0_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mled0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mled0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mled0_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled0_pe 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mled0': */
#define MSK_USED_BITS_NX90_pad_ctrl_mled0 0x00000011U

enum {
  BFW_NX90_pad_ctrl_mled0_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mled0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mled0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mled0_reserved2 = 27  /* [31:5] */
};

typedef struct NX90_PAD_CTRL_MLED0_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mled0_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mled0_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mled0_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mled0_reserved2; /* reserved                                         */
} NX90_PAD_CTRL_MLED0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MLED0_BIT_T bf;
} NX90_PAD_CTRL_MLED0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mled1 */
/* => Pad configuration register of port MLED1 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408CDG_33(o) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mled1      0x0000000CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mled1 0xFF40100CU
#define Adr_NX90_pad_ctrl_mled1          0xFF40100CU
#define DFLT_VAL_NX90_pad_ctrl_mled1     0x00000000U

#define MSK_NX90_pad_ctrl_mled1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mled1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mled1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mled1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mled1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mled1_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled1_pe 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mled1': */
#define MSK_USED_BITS_NX90_pad_ctrl_mled1 0x00000011U

enum {
  BFW_NX90_pad_ctrl_mled1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mled1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mled1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mled1_reserved2 = 27  /* [31:5] */
};

typedef struct NX90_PAD_CTRL_MLED1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mled1_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mled1_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mled1_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mled1_reserved2; /* reserved                                         */
} NX90_PAD_CTRL_MLED1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MLED1_BIT_T bf;
} NX90_PAD_CTRL_MLED1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mled2 */
/* => Pad configuration register of port MLED2 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408CDG_33(o) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mled2      0x00000010U
#define Adr_NX90_pad_ctrl_pad_ctrl_mled2 0xFF401010U
#define Adr_NX90_pad_ctrl_mled2          0xFF401010U
#define DFLT_VAL_NX90_pad_ctrl_mled2     0x00000000U

#define MSK_NX90_pad_ctrl_mled2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mled2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mled2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mled2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mled2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mled2_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled2_pe 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mled2': */
#define MSK_USED_BITS_NX90_pad_ctrl_mled2 0x00000011U

enum {
  BFW_NX90_pad_ctrl_mled2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mled2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mled2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mled2_reserved2 = 27  /* [31:5] */
};

typedef struct NX90_PAD_CTRL_MLED2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mled2_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mled2_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mled2_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mled2_reserved2; /* reserved                                         */
} NX90_PAD_CTRL_MLED2_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MLED2_BIT_T bf;
} NX90_PAD_CTRL_MLED2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mled3 */
/* => Pad configuration register of port MLED3 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408CDG_33(o) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mled3      0x00000014U
#define Adr_NX90_pad_ctrl_pad_ctrl_mled3 0xFF401014U
#define Adr_NX90_pad_ctrl_mled3          0xFF401014U
#define DFLT_VAL_NX90_pad_ctrl_mled3     0x00000000U

#define MSK_NX90_pad_ctrl_mled3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mled3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mled3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mled3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mled3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mled3_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mled3_pe 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mled3': */
#define MSK_USED_BITS_NX90_pad_ctrl_mled3 0x00000011U

enum {
  BFW_NX90_pad_ctrl_mled3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mled3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mled3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mled3_reserved2 = 27  /* [31:5] */
};

typedef struct NX90_PAD_CTRL_MLED3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mled3_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mled3_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mled3_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mled3_reserved2; /* reserved                                         */
} NX90_PAD_CTRL_MLED3_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MLED3_BIT_T bf;
} NX90_PAD_CTRL_MLED3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_com_io0 */
/* => Pad configuration register of port COM_IO0 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_com_io0      0x00000018U
#define Adr_NX90_pad_ctrl_pad_ctrl_com_io0 0xFF401018U
#define Adr_NX90_pad_ctrl_com_io0          0xFF401018U
#define DFLT_VAL_NX90_pad_ctrl_com_io0     0x00000050U

#define MSK_NX90_pad_ctrl_com_io0_ds         0x00000001U
#define SRT_NX90_pad_ctrl_com_io0_ds         0
#define DFLT_VAL_NX90_pad_ctrl_com_io0_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io0_ds 0x00000000U
#define MSK_NX90_pad_ctrl_com_io0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_com_io0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_com_io0_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io0_pe 0x00000001U
#define MSK_NX90_pad_ctrl_com_io0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_com_io0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_com_io0_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io0_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_com_io0': */
#define MSK_USED_BITS_NX90_pad_ctrl_com_io0 0x00000051U

enum {
  BFW_NX90_pad_ctrl_com_io0_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_com_io0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_com_io0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_com_io0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_com_io0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_com_io0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_COM_IO0_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_com_io0_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_com_io0_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_com_io0_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_com_io0_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_com_io0_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_com_io0_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_COM_IO0_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_COM_IO0_BIT_T bf;
} NX90_PAD_CTRL_COM_IO0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_com_io1 */
/* => Pad configuration register of port COM_IO1 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_com_io1      0x0000001CU
#define Adr_NX90_pad_ctrl_pad_ctrl_com_io1 0xFF40101CU
#define Adr_NX90_pad_ctrl_com_io1          0xFF40101CU
#define DFLT_VAL_NX90_pad_ctrl_com_io1     0x00000050U

#define MSK_NX90_pad_ctrl_com_io1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_com_io1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_com_io1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_com_io1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_com_io1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_com_io1_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io1_pe 0x00000001U
#define MSK_NX90_pad_ctrl_com_io1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_com_io1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_com_io1_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io1_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_com_io1': */
#define MSK_USED_BITS_NX90_pad_ctrl_com_io1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_com_io1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_com_io1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_com_io1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_com_io1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_com_io1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_com_io1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_COM_IO1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_com_io1_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_com_io1_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_com_io1_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_com_io1_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_com_io1_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_com_io1_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_COM_IO1_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_COM_IO1_BIT_T bf;
} NX90_PAD_CTRL_COM_IO1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_com_io2 */
/* => Pad configuration register of port COM_IO2 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_com_io2      0x00000020U
#define Adr_NX90_pad_ctrl_pad_ctrl_com_io2 0xFF401020U
#define Adr_NX90_pad_ctrl_com_io2          0xFF401020U
#define DFLT_VAL_NX90_pad_ctrl_com_io2     0x00000050U

#define MSK_NX90_pad_ctrl_com_io2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_com_io2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_com_io2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_com_io2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_com_io2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_com_io2_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io2_pe 0x00000001U
#define MSK_NX90_pad_ctrl_com_io2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_com_io2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_com_io2_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io2_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_com_io2': */
#define MSK_USED_BITS_NX90_pad_ctrl_com_io2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_com_io2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_com_io2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_com_io2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_com_io2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_com_io2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_com_io2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_COM_IO2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_com_io2_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_com_io2_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_com_io2_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_com_io2_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_com_io2_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_com_io2_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_COM_IO2_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_COM_IO2_BIT_T bf;
} NX90_PAD_CTRL_COM_IO2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_com_io3 */
/* => Pad configuration register of port COM_IO3 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_com_io3      0x00000024U
#define Adr_NX90_pad_ctrl_pad_ctrl_com_io3 0xFF401024U
#define Adr_NX90_pad_ctrl_com_io3          0xFF401024U
#define DFLT_VAL_NX90_pad_ctrl_com_io3     0x00000050U

#define MSK_NX90_pad_ctrl_com_io3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_com_io3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_com_io3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_com_io3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_com_io3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_com_io3_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io3_pe 0x00000001U
#define MSK_NX90_pad_ctrl_com_io3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_com_io3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_com_io3_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_com_io3_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_com_io3': */
#define MSK_USED_BITS_NX90_pad_ctrl_com_io3 0x00000051U

enum {
  BFW_NX90_pad_ctrl_com_io3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_com_io3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_com_io3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_com_io3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_com_io3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_com_io3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_COM_IO3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_com_io3_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_com_io3_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_com_io3_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_com_io3_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_com_io3_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_com_io3_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_COM_IO3_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_COM_IO3_BIT_T bf;
} NX90_PAD_CTRL_COM_IO3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_rxclk */
/* => Pad configuration register of port MII0_RXCLK (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_rxclk      0x00000028U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_rxclk 0xFF401028U
#define Adr_NX90_pad_ctrl_mii0_rxclk          0xFF401028U
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxclk     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_rxclk_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_rxclk_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxclk_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxclk_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_rxclk_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_rxclk_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxclk_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxclk_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_rxclk_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_rxclk_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxclk_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxclk_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_rxclk': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_rxclk 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_rxclk_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_rxclk_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_rxclk_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_rxclk_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_rxclk_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_rxclk_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_RXCLK_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_rxclk_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_rxclk_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_rxclk_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_rxclk_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_rxclk_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_rxclk_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_RXCLK_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_PAD_CTRL_MII0_RXCLK_BIT_T bf;
} NX90_PAD_CTRL_MII0_RXCLK_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_rxd0 */
/* => Pad configuration register of port MII0_RXD0 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_rxd0      0x0000002CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_rxd0 0xFF40102CU
#define Adr_NX90_pad_ctrl_mii0_rxd0          0xFF40102CU
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd0     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_rxd0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_rxd0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd0_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd0_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_rxd0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_rxd0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd0_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd0_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_rxd0': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_rxd0 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii0_rxd0_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii0_rxd0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_rxd0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_rxd0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_rxd0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_RXD0_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_rxd0_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_rxd0_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_rxd0_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_rxd0_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_rxd0_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_RXD0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_RXD0_BIT_T bf;
} NX90_PAD_CTRL_MII0_RXD0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_rxd1 */
/* => Pad configuration register of port MII0_RXD1 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_rxd1      0x00000030U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_rxd1 0xFF401030U
#define Adr_NX90_pad_ctrl_mii0_rxd1          0xFF401030U
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd1     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_rxd1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_rxd1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_rxd1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_rxd1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd1_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd1_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_rxd1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_rxd1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd1_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd1_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_rxd1': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_rxd1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_rxd1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_rxd1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_rxd1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_rxd1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_rxd1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_rxd1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_RXD1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_rxd1_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_rxd1_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_rxd1_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_rxd1_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_rxd1_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_rxd1_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_RXD1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_RXD1_BIT_T bf;
} NX90_PAD_CTRL_MII0_RXD1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_rxd2 */
/* => Pad configuration register of port MII0_RXD2 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_rxd2      0x00000034U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_rxd2 0xFF401034U
#define Adr_NX90_pad_ctrl_mii0_rxd2          0xFF401034U
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd2     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_rxd2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_rxd2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_rxd2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_rxd2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd2_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd2_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_rxd2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_rxd2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd2_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd2_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_rxd2': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_rxd2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_rxd2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_rxd2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_rxd2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_rxd2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_rxd2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_rxd2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_RXD2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_rxd2_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_rxd2_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_rxd2_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_rxd2_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_rxd2_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_rxd2_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_RXD2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_RXD2_BIT_T bf;
} NX90_PAD_CTRL_MII0_RXD2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_rxd3 */
/* => Pad configuration register of port MII0_RXD3 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_rxd3      0x00000038U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_rxd3 0xFF401038U
#define Adr_NX90_pad_ctrl_mii0_rxd3          0xFF401038U
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd3     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_rxd3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_rxd3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd3_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd3_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_rxd3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_rxd3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxd3_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxd3_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_rxd3': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_rxd3 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii0_rxd3_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii0_rxd3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_rxd3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_rxd3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_rxd3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_RXD3_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_rxd3_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_rxd3_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_rxd3_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_rxd3_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_rxd3_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_RXD3_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_RXD3_BIT_T bf;
} NX90_PAD_CTRL_MII0_RXD3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_rxdv */
/* => Pad configuration register of port MII0_RXDV (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_rxdv      0x0000003CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_rxdv 0xFF40103CU
#define Adr_NX90_pad_ctrl_mii0_rxdv          0xFF40103CU
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxdv     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_rxdv_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_rxdv_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxdv_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxdv_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_rxdv_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_rxdv_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxdv_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxdv_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_rxdv': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_rxdv 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii0_rxdv_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii0_rxdv_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_rxdv_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_rxdv_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_rxdv_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_RXDV_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_rxdv_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_rxdv_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_rxdv_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_rxdv_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_rxdv_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_RXDV_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_RXDV_BIT_T bf;
} NX90_PAD_CTRL_MII0_RXDV_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_rxer */
/* => Pad configuration register of port MII0_RXER (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_rxer      0x00000040U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_rxer 0xFF401040U
#define Adr_NX90_pad_ctrl_mii0_rxer          0xFF401040U
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxer     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_rxer_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_rxer_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxer_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxer_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_rxer_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_rxer_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_rxer_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_rxer_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_rxer': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_rxer 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii0_rxer_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii0_rxer_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_rxer_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_rxer_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_rxer_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_RXER_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_rxer_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_rxer_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_rxer_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_rxer_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_rxer_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_RXER_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_RXER_BIT_T bf;
} NX90_PAD_CTRL_MII0_RXER_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_txclk */
/* => Pad configuration register of port MII0_TXCLK (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_txclk      0x00000044U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_txclk 0xFF401044U
#define Adr_NX90_pad_ctrl_mii0_txclk          0xFF401044U
#define DFLT_VAL_NX90_pad_ctrl_mii0_txclk     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_txclk_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_txclk_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_txclk_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txclk_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_txclk_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_txclk_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_txclk_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txclk_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_txclk_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_txclk_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_txclk_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txclk_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_txclk': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_txclk 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_txclk_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_txclk_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_txclk_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_txclk_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_txclk_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_txclk_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_TXCLK_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_txclk_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_txclk_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_txclk_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_txclk_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_txclk_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_txclk_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_TXCLK_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_PAD_CTRL_MII0_TXCLK_BIT_T bf;
} NX90_PAD_CTRL_MII0_TXCLK_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_txd0 */
/* => Pad configuration register of port MII0_TXD0 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_txd0      0x00000048U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_txd0 0xFF401048U
#define Adr_NX90_pad_ctrl_mii0_txd0          0xFF401048U
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd0     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_txd0_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_txd0_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd0_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd0_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_txd0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_txd0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd0_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd0_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_txd0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_txd0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd0_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd0_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_txd0': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_txd0 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_txd0_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_txd0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_txd0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_txd0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_txd0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_txd0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_TXD0_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_txd0_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_txd0_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_txd0_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_txd0_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_txd0_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_txd0_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_TXD0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_TXD0_BIT_T bf;
} NX90_PAD_CTRL_MII0_TXD0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_txd1 */
/* => Pad configuration register of port MII0_TXD1 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_txd1      0x0000004CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_txd1 0xFF40104CU
#define Adr_NX90_pad_ctrl_mii0_txd1          0xFF40104CU
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd1     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_txd1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_txd1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_txd1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_txd1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd1_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd1_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_txd1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_txd1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd1_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd1_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_txd1': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_txd1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_txd1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_txd1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_txd1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_txd1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_txd1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_txd1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_TXD1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_txd1_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_txd1_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_txd1_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_txd1_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_txd1_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_txd1_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_TXD1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_TXD1_BIT_T bf;
} NX90_PAD_CTRL_MII0_TXD1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_txd2 */
/* => Pad configuration register of port MII0_TXD2 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_txd2      0x00000050U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_txd2 0xFF401050U
#define Adr_NX90_pad_ctrl_mii0_txd2          0xFF401050U
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd2     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_txd2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_txd2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_txd2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_txd2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd2_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd2_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_txd2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_txd2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd2_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd2_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_txd2': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_txd2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_txd2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_txd2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_txd2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_txd2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_txd2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_txd2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_TXD2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_txd2_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_txd2_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_txd2_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_txd2_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_txd2_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_txd2_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_TXD2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_TXD2_BIT_T bf;
} NX90_PAD_CTRL_MII0_TXD2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_txd3 */
/* => Pad configuration register of port MII0_TXD3 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_txd3      0x00000054U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_txd3 0xFF401054U
#define Adr_NX90_pad_ctrl_mii0_txd3          0xFF401054U
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd3     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_txd3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_txd3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_txd3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_txd3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd3_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd3_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_txd3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_txd3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_txd3_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txd3_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_txd3': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_txd3 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_txd3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_txd3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_txd3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_txd3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_txd3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_txd3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_TXD3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_txd3_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_txd3_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_txd3_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_txd3_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_txd3_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_txd3_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_TXD3_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_TXD3_BIT_T bf;
} NX90_PAD_CTRL_MII0_TXD3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_txen */
/* => Pad configuration register of port MII0_TXEN (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_txen      0x00000058U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_txen 0xFF401058U
#define Adr_NX90_pad_ctrl_mii0_txen          0xFF401058U
#define DFLT_VAL_NX90_pad_ctrl_mii0_txen     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_txen_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_txen_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_txen_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txen_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_txen_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_txen_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_txen_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txen_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_txen_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_txen_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_txen_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_txen_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_txen': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_txen 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_txen_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_txen_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_txen_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_txen_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_txen_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_txen_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_TXEN_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_txen_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_txen_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_txen_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_txen_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_txen_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_txen_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_TXEN_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII0_TXEN_BIT_T bf;
} NX90_PAD_CTRL_MII0_TXEN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_col */
/* => Pad configuration register of port MII0_COL (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_col      0x0000005CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_col 0xFF40105CU
#define Adr_NX90_pad_ctrl_mii0_col          0xFF40105CU
#define DFLT_VAL_NX90_pad_ctrl_mii0_col     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_col_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_col_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_col_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_col_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_col_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_col_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_col_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_col_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_col_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_col_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_col_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_col_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_col': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_col 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_col_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_col_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_col_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_col_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_col_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_col_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_COL_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_col_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_col_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_col_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_col_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_col_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_col_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_COL_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_MII0_COL_BIT_T bf;
} NX90_PAD_CTRL_MII0_COL_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii0_crs */
/* => Pad configuration register of port MII0_CRS (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii0_crs      0x00000060U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii0_crs 0xFF401060U
#define Adr_NX90_pad_ctrl_mii0_crs          0xFF401060U
#define DFLT_VAL_NX90_pad_ctrl_mii0_crs     0x00000050U

#define MSK_NX90_pad_ctrl_mii0_crs_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii0_crs_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii0_crs_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_crs_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii0_crs_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii0_crs_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii0_crs_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_crs_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii0_crs_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii0_crs_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii0_crs_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii0_crs_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii0_crs': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii0_crs 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii0_crs_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii0_crs_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii0_crs_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii0_crs_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii0_crs_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii0_crs_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII0_CRS_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii0_crs_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii0_crs_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii0_crs_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii0_crs_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii0_crs_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii0_crs_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII0_CRS_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_MII0_CRS_BIT_T bf;
} NX90_PAD_CTRL_MII0_CRS_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_phy0_led_link_in */
/* => Pad configuration register of port PHY0_LED_LINK_IN (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_phy0_led_link_in      0x00000064U
#define Adr_NX90_pad_ctrl_pad_ctrl_phy0_led_link_in 0xFF401064U
#define Adr_NX90_pad_ctrl_phy0_led_link_in          0xFF401064U
#define DFLT_VAL_NX90_pad_ctrl_phy0_led_link_in     0x00000050U

#define MSK_NX90_pad_ctrl_phy0_led_link_in_pe         0x00000010U
#define SRT_NX90_pad_ctrl_phy0_led_link_in_pe         4
#define DFLT_VAL_NX90_pad_ctrl_phy0_led_link_in_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_phy0_led_link_in_pe 0x00000001U
#define MSK_NX90_pad_ctrl_phy0_led_link_in_ie         0x00000040U
#define SRT_NX90_pad_ctrl_phy0_led_link_in_ie         6
#define DFLT_VAL_NX90_pad_ctrl_phy0_led_link_in_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_phy0_led_link_in_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_phy0_led_link_in': */
#define MSK_USED_BITS_NX90_pad_ctrl_phy0_led_link_in 0x00000050U

enum {
  BFW_NX90_pad_ctrl_phy0_led_link_in_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_phy0_led_link_in_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_phy0_led_link_in_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_phy0_led_link_in_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_phy0_led_link_in_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_PHY0_LED_LINK_IN_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_phy0_led_link_in_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_phy0_led_link_in_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_phy0_led_link_in_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_phy0_led_link_in_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_phy0_led_link_in_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_PHY0_LED_LINK_IN_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_PAD_CTRL_PHY0_LED_LINK_IN_BIT_T bf;
} NX90_PAD_CTRL_PHY0_LED_LINK_IN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_rxclk */
/* => Pad configuration register of port MII1_RXCLK (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_rxclk      0x00000068U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_rxclk 0xFF401068U
#define Adr_NX90_pad_ctrl_mii1_rxclk          0xFF401068U
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxclk     0x00000050U

#define MSK_NX90_pad_ctrl_mii1_rxclk_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_rxclk_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxclk_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxclk_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_rxclk_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_rxclk_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxclk_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxclk_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii1_rxclk_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_rxclk_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxclk_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxclk_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii1_rxclk': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_rxclk 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_rxclk_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_rxclk_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_rxclk_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_rxclk_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_rxclk_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_rxclk_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_RXCLK_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_rxclk_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_rxclk_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_rxclk_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_rxclk_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_rxclk_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_rxclk_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII1_RXCLK_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_PAD_CTRL_MII1_RXCLK_BIT_T bf;
} NX90_PAD_CTRL_MII1_RXCLK_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_rxd0 */
/* => Pad configuration register of port MII1_RXD0 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i_double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_rxd0      0x0000006CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_rxd0 0xFF40106CU
#define Adr_NX90_pad_ctrl_mii1_rxd0          0xFF40106CU
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd0     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_rxd0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_rxd0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd0_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd0_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_rxd0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_rxd0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd0_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd0_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_rxd0': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_rxd0 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii1_rxd0_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii1_rxd0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_rxd0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_rxd0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_rxd0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_RXD0_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_rxd0_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_rxd0_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_rxd0_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_rxd0_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_rxd0_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_RXD0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_RXD0_BIT_T bf;
} NX90_PAD_CTRL_MII1_RXD0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_rxd1 */
/* => Pad configuration register of port MII1_RXD1 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0408SCDG_33(double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_rxd1      0x00000070U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_rxd1 0xFF401070U
#define Adr_NX90_pad_ctrl_mii1_rxd1          0xFF401070U
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd1     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_rxd1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_rxd1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_rxd1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_rxd1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd1_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd1_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_rxd1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_rxd1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd1_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd1_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_rxd1': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_rxd1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_rxd1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_rxd1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_rxd1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_rxd1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_rxd1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_rxd1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_RXD1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_rxd1_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_rxd1_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_rxd1_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_rxd1_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_rxd1_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_rxd1_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_RXD1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_RXD1_BIT_T bf;
} NX90_PAD_CTRL_MII1_RXD1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_rxd2 */
/* => Pad configuration register of port MII1_RXD2 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0408SCDG_33(double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_rxd2      0x00000074U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_rxd2 0xFF401074U
#define Adr_NX90_pad_ctrl_mii1_rxd2          0xFF401074U
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd2     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_rxd2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_rxd2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_rxd2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_rxd2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd2_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd2_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_rxd2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_rxd2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd2_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd2_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_rxd2': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_rxd2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_rxd2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_rxd2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_rxd2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_rxd2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_rxd2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_rxd2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_RXD2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_rxd2_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_rxd2_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_rxd2_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_rxd2_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_rxd2_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_rxd2_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_RXD2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_RXD2_BIT_T bf;
} NX90_PAD_CTRL_MII1_RXD2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_rxd3 */
/* => Pad configuration register of port MII1_RXD3 (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i_double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_rxd3      0x00000078U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_rxd3 0xFF401078U
#define Adr_NX90_pad_ctrl_mii1_rxd3          0xFF401078U
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd3     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_rxd3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_rxd3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd3_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd3_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_rxd3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_rxd3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxd3_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxd3_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_rxd3': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_rxd3 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii1_rxd3_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii1_rxd3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_rxd3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_rxd3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_rxd3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_RXD3_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_rxd3_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_rxd3_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_rxd3_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_rxd3_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_rxd3_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_RXD3_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_RXD3_BIT_T bf;
} NX90_PAD_CTRL_MII1_RXD3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_rxdv */
/* => Pad configuration register of port MII1_RXDV (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_rxdv      0x0000007CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_rxdv 0xFF40107CU
#define Adr_NX90_pad_ctrl_mii1_rxdv          0xFF40107CU
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxdv     0x00000050U

#define MSK_NX90_pad_ctrl_mii1_rxdv_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_rxdv_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxdv_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxdv_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii1_rxdv_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_rxdv_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxdv_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxdv_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii1_rxdv': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_rxdv 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii1_rxdv_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii1_rxdv_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_rxdv_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_rxdv_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_rxdv_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_RXDV_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_rxdv_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_rxdv_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_rxdv_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_rxdv_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_rxdv_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII1_RXDV_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_RXDV_BIT_T bf;
} NX90_PAD_CTRL_MII1_RXDV_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_rxer */
/* => Pad configuration register of port MII1_RXER (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_rxer      0x00000080U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_rxer 0xFF401080U
#define Adr_NX90_pad_ctrl_mii1_rxer          0xFF401080U
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxer     0x00000050U

#define MSK_NX90_pad_ctrl_mii1_rxer_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_rxer_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxer_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxer_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii1_rxer_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_rxer_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_rxer_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_rxer_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii1_rxer': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_rxer 0x00000050U

enum {
  BFW_NX90_pad_ctrl_mii1_rxer_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_mii1_rxer_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_rxer_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_rxer_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_rxer_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_RXER_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_rxer_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_rxer_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_rxer_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_rxer_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_rxer_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII1_RXER_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_RXER_BIT_T bf;
} NX90_PAD_CTRL_MII1_RXER_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_txclk */
/* => Pad configuration register of port MII1_TXCLK (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_txclk      0x00000084U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_txclk 0xFF401084U
#define Adr_NX90_pad_ctrl_mii1_txclk          0xFF401084U
#define DFLT_VAL_NX90_pad_ctrl_mii1_txclk     0x00000050U

#define MSK_NX90_pad_ctrl_mii1_txclk_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_txclk_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_txclk_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txclk_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txclk_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_txclk_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_txclk_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txclk_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii1_txclk_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_txclk_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_txclk_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txclk_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii1_txclk': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_txclk 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_txclk_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_txclk_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_txclk_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_txclk_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_txclk_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_txclk_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_TXCLK_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_txclk_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_txclk_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_txclk_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_txclk_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_txclk_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_txclk_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII1_TXCLK_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_PAD_CTRL_MII1_TXCLK_BIT_T bf;
} NX90_PAD_CTRL_MII1_TXCLK_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_txd0 */
/* => Pad configuration register of port MII1_TXD0 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33(double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_txd0      0x00000088U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_txd0 0xFF401088U
#define Adr_NX90_pad_ctrl_mii1_txd0          0xFF401088U
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd0     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_txd0_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_txd0_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd0_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd0_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_txd0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd0_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd0_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_txd0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd0_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd0_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_txd0': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_txd0 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_txd0_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_txd0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_txd0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_txd0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_txd0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_txd0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_TXD0_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_txd0_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_txd0_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_txd0_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_txd0_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_txd0_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_txd0_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_TXD0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_TXD0_BIT_T bf;
} NX90_PAD_CTRL_MII1_TXD0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_txd1 */
/* => Pad configuration register of port MII1_TXD1 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33(double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_txd1      0x0000008CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_txd1 0xFF40108CU
#define Adr_NX90_pad_ctrl_mii1_txd1          0xFF40108CU
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd1     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_txd1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_txd1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_txd1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd1_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd1_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_txd1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd1_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd1_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_txd1': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_txd1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_txd1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_txd1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_txd1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_txd1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_txd1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_txd1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_TXD1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_txd1_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_txd1_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_txd1_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_txd1_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_txd1_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_txd1_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_TXD1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_TXD1_BIT_T bf;
} NX90_PAD_CTRL_MII1_TXD1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_txd2 */
/* => Pad configuration register of port MII1_TXD2 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33(double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_txd2      0x00000090U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_txd2 0xFF401090U
#define Adr_NX90_pad_ctrl_mii1_txd2          0xFF401090U
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd2     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_txd2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_txd2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_txd2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd2_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd2_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_txd2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd2_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd2_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_txd2': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_txd2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_txd2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_txd2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_txd2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_txd2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_txd2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_txd2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_TXD2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_txd2_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_txd2_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_txd2_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_txd2_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_txd2_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_txd2_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_TXD2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_TXD2_BIT_T bf;
} NX90_PAD_CTRL_MII1_TXD2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_txd3 */
/* => Pad configuration register of port MII1_TXD3 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33(double_bond) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_txd3      0x00000094U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_txd3 0xFF401094U
#define Adr_NX90_pad_ctrl_mii1_txd3          0xFF401094U
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd3     0x00000000U

#define MSK_NX90_pad_ctrl_mii1_txd3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_txd3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_txd3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd3_pe    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd3_pe 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txd3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_txd3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_txd3_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txd3_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mii1_txd3': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_txd3 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_txd3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_txd3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_txd3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_txd3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_txd3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_txd3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_TXD3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_txd3_ds;        /* driving strength (low by default)                */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_txd3_reserved1; /* reserved                                         */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_txd3_pe;        /* pull enable (pull-down pad, disabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_txd3_reserved2; /* reserved                                         */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_txd3_ie;        /* input enable (disabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_txd3_reserved3; /* reserved                                         */
} NX90_PAD_CTRL_MII1_TXD3_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_TXD3_BIT_T bf;
} NX90_PAD_CTRL_MII1_TXD3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_txen */
/* => Pad configuration register of port MII1_TXEN (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_txen      0x00000098U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_txen 0xFF401098U
#define Adr_NX90_pad_ctrl_mii1_txen          0xFF401098U
#define DFLT_VAL_NX90_pad_ctrl_mii1_txen     0x00000050U

#define MSK_NX90_pad_ctrl_mii1_txen_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_txen_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_txen_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txen_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_txen_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_txen_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_txen_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txen_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii1_txen_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_txen_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_txen_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_txen_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii1_txen': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_txen 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_txen_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_txen_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_txen_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_txen_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_txen_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_txen_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_TXEN_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_txen_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_txen_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_txen_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_txen_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_txen_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_txen_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII1_TXEN_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_MII1_TXEN_BIT_T bf;
} NX90_PAD_CTRL_MII1_TXEN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_col */
/* => Pad configuration register of port MII1_COL (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_col      0x0000009CU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_col 0xFF40109CU
#define Adr_NX90_pad_ctrl_mii1_col          0xFF40109CU
#define DFLT_VAL_NX90_pad_ctrl_mii1_col     0x00000050U

#define MSK_NX90_pad_ctrl_mii1_col_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_col_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_col_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_col_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_col_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_col_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_col_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_col_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii1_col_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_col_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_col_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_col_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii1_col': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_col 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_col_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_col_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_col_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_col_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_col_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_col_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_COL_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_col_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_col_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_col_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_col_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_col_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_col_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII1_COL_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_MII1_COL_BIT_T bf;
} NX90_PAD_CTRL_MII1_COL_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii1_crs */
/* => Pad configuration register of port MII1_CRS (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii1_crs      0x000000A0U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii1_crs 0xFF4010A0U
#define Adr_NX90_pad_ctrl_mii1_crs          0xFF4010A0U
#define DFLT_VAL_NX90_pad_ctrl_mii1_crs     0x00000050U

#define MSK_NX90_pad_ctrl_mii1_crs_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii1_crs_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii1_crs_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_crs_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii1_crs_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii1_crs_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii1_crs_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_crs_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii1_crs_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii1_crs_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii1_crs_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii1_crs_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii1_crs': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii1_crs 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii1_crs_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii1_crs_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii1_crs_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii1_crs_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii1_crs_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii1_crs_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII1_CRS_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii1_crs_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii1_crs_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii1_crs_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii1_crs_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii1_crs_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii1_crs_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII1_CRS_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_MII1_CRS_BIT_T bf;
} NX90_PAD_CTRL_MII1_CRS_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_phy1_led_link_in */
/* => Pad configuration register of port PHY1_LED_LINK_IN (asic_ctrl_access_key protected). */
/*    Pad type: PDDW0204SCDG_33(i) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_phy1_led_link_in      0x000000A4U
#define Adr_NX90_pad_ctrl_pad_ctrl_phy1_led_link_in 0xFF4010A4U
#define Adr_NX90_pad_ctrl_phy1_led_link_in          0xFF4010A4U
#define DFLT_VAL_NX90_pad_ctrl_phy1_led_link_in     0x00000050U

#define MSK_NX90_pad_ctrl_phy1_led_link_in_pe         0x00000010U
#define SRT_NX90_pad_ctrl_phy1_led_link_in_pe         4
#define DFLT_VAL_NX90_pad_ctrl_phy1_led_link_in_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_phy1_led_link_in_pe 0x00000001U
#define MSK_NX90_pad_ctrl_phy1_led_link_in_ie         0x00000040U
#define SRT_NX90_pad_ctrl_phy1_led_link_in_ie         6
#define DFLT_VAL_NX90_pad_ctrl_phy1_led_link_in_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_phy1_led_link_in_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_phy1_led_link_in': */
#define MSK_USED_BITS_NX90_pad_ctrl_phy1_led_link_in 0x00000050U

enum {
  BFW_NX90_pad_ctrl_phy1_led_link_in_reserved1 = 4,  /* [3:0] */
  BFW_NX90_pad_ctrl_phy1_led_link_in_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_phy1_led_link_in_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_phy1_led_link_in_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_phy1_led_link_in_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_PHY1_LED_LINK_IN_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_pad_ctrl_phy1_led_link_in_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_phy1_led_link_in_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_phy1_led_link_in_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_phy1_led_link_in_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_phy1_led_link_in_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_PHY1_LED_LINK_IN_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_PAD_CTRL_PHY1_LED_LINK_IN_BIT_T bf;
} NX90_PAD_CTRL_PHY1_LED_LINK_IN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii_mdc */
/* => Pad configuration register of port MII_MDC (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii_mdc      0x000000A8U
#define Adr_NX90_pad_ctrl_pad_ctrl_mii_mdc 0xFF4010A8U
#define Adr_NX90_pad_ctrl_mii_mdc          0xFF4010A8U
#define DFLT_VAL_NX90_pad_ctrl_mii_mdc     0x00000050U

#define MSK_NX90_pad_ctrl_mii_mdc_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii_mdc_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii_mdc_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii_mdc_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii_mdc_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii_mdc_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii_mdc_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii_mdc_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii_mdc_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii_mdc_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii_mdc_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii_mdc_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii_mdc': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii_mdc 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii_mdc_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii_mdc_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii_mdc_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii_mdc_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii_mdc_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii_mdc_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII_MDC_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii_mdc_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii_mdc_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii_mdc_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii_mdc_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii_mdc_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii_mdc_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII_MDC_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_MII_MDC_BIT_T bf;
} NX90_PAD_CTRL_MII_MDC_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mii_mdio */
/* => Pad configuration register of port MII_MDIO (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mii_mdio      0x000000ACU
#define Adr_NX90_pad_ctrl_pad_ctrl_mii_mdio 0xFF4010ACU
#define Adr_NX90_pad_ctrl_mii_mdio          0xFF4010ACU
#define DFLT_VAL_NX90_pad_ctrl_mii_mdio     0x00000050U

#define MSK_NX90_pad_ctrl_mii_mdio_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mii_mdio_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mii_mdio_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii_mdio_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mii_mdio_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mii_mdio_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mii_mdio_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii_mdio_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mii_mdio_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mii_mdio_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mii_mdio_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mii_mdio_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mii_mdio': */
#define MSK_USED_BITS_NX90_pad_ctrl_mii_mdio 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mii_mdio_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mii_mdio_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mii_mdio_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mii_mdio_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mii_mdio_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mii_mdio_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MII_MDIO_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mii_mdio_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mii_mdio_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mii_mdio_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mii_mdio_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mii_mdio_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mii_mdio_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MII_MDIO_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_MII_MDIO_BIT_T bf;
} NX90_PAD_CTRL_MII_MDIO_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_rst_out_n */
/* => Pad configuration register of port RST_OUT_N (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_rst_out_n      0x000000B0U
#define Adr_NX90_pad_ctrl_pad_ctrl_rst_out_n 0xFF4010B0U
#define Adr_NX90_pad_ctrl_rst_out_n          0xFF4010B0U
#define DFLT_VAL_NX90_pad_ctrl_rst_out_n     0x00000050U

#define MSK_NX90_pad_ctrl_rst_out_n_ds         0x00000001U
#define SRT_NX90_pad_ctrl_rst_out_n_ds         0
#define DFLT_VAL_NX90_pad_ctrl_rst_out_n_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_rst_out_n_ds 0x00000000U
#define MSK_NX90_pad_ctrl_rst_out_n_pe         0x00000010U
#define SRT_NX90_pad_ctrl_rst_out_n_pe         4
#define DFLT_VAL_NX90_pad_ctrl_rst_out_n_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_rst_out_n_pe 0x00000001U
#define MSK_NX90_pad_ctrl_rst_out_n_ie         0x00000040U
#define SRT_NX90_pad_ctrl_rst_out_n_ie         6
#define DFLT_VAL_NX90_pad_ctrl_rst_out_n_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_rst_out_n_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_rst_out_n': */
#define MSK_USED_BITS_NX90_pad_ctrl_rst_out_n 0x00000051U

enum {
  BFW_NX90_pad_ctrl_rst_out_n_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_rst_out_n_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_rst_out_n_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_rst_out_n_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_rst_out_n_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_rst_out_n_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_RST_OUT_N_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_rst_out_n_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_rst_out_n_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_rst_out_n_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_rst_out_n_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_rst_out_n_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_rst_out_n_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_RST_OUT_N_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_RST_OUT_N_BIT_T bf;
} NX90_PAD_CTRL_RST_OUT_N_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_clk25out */
/* => Pad configuration register of port CLK25OUT (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408CDG_33(o) */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_clk25out      0x000000B4U
#define Adr_NX90_pad_ctrl_pad_ctrl_clk25out 0xFF4010B4U
#define Adr_NX90_pad_ctrl_clk25out          0xFF4010B4U
#define DFLT_VAL_NX90_pad_ctrl_clk25out     0x00000010U

#define MSK_NX90_pad_ctrl_clk25out_ds         0x00000001U
#define SRT_NX90_pad_ctrl_clk25out_ds         0
#define DFLT_VAL_NX90_pad_ctrl_clk25out_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_clk25out_ds 0x00000000U
#define MSK_NX90_pad_ctrl_clk25out_pe         0x00000010U
#define SRT_NX90_pad_ctrl_clk25out_pe         4
#define DFLT_VAL_NX90_pad_ctrl_clk25out_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_clk25out_pe 0x00000001U

/* all used bits of 'NX90_pad_ctrl_clk25out': */
#define MSK_USED_BITS_NX90_pad_ctrl_clk25out 0x00000011U

enum {
  BFW_NX90_pad_ctrl_clk25out_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_clk25out_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_clk25out_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_clk25out_reserved2 = 27  /* [31:5] */
};

typedef struct NX90_PAD_CTRL_CLK25OUT_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_clk25out_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_clk25out_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_clk25out_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_clk25out_reserved2; /* reserved                                        */
} NX90_PAD_CTRL_CLK25OUT_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_CLK25OUT_BIT_T bf;
} NX90_PAD_CTRL_CLK25OUT_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio0 */
/* => Pad configuration register of port MMIO0 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio0      0x000000B8U
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio0 0xFF4010B8U
#define Adr_NX90_pad_ctrl_mmio0          0xFF4010B8U
#define DFLT_VAL_NX90_pad_ctrl_mmio0     0x00000050U

#define MSK_NX90_pad_ctrl_mmio0_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio0_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio0_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio0_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio0_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio0_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio0_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio0_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mmio0': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio0 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio0_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO0_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio0_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio0_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio0_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio0_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio0_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio0_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MMIO0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO0_BIT_T bf;
} NX90_PAD_CTRL_MMIO0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio1 */
/* => Pad configuration register of port MMIO1 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio1      0x000000BCU
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio1 0xFF4010BCU
#define Adr_NX90_pad_ctrl_mmio1          0xFF4010BCU
#define DFLT_VAL_NX90_pad_ctrl_mmio1     0x00000050U

#define MSK_NX90_pad_ctrl_mmio1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio1_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio1_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio1_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio1_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mmio1': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio1_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio1_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio1_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio1_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio1_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio1_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MMIO1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO1_BIT_T bf;
} NX90_PAD_CTRL_MMIO1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio2 */
/* => Pad configuration register of port MMIO2 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio2      0x000000C0U
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio2 0xFF4010C0U
#define Adr_NX90_pad_ctrl_mmio2          0xFF4010C0U
#define DFLT_VAL_NX90_pad_ctrl_mmio2     0x00000050U

#define MSK_NX90_pad_ctrl_mmio2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio2_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio2_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio2_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio2_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mmio2': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio2_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio2_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio2_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio2_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio2_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio2_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MMIO2_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO2_BIT_T bf;
} NX90_PAD_CTRL_MMIO2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio3 */
/* => Pad configuration register of port MMIO3 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio3      0x000000C4U
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio3 0xFF4010C4U
#define Adr_NX90_pad_ctrl_mmio3          0xFF4010C4U
#define DFLT_VAL_NX90_pad_ctrl_mmio3     0x00000050U

#define MSK_NX90_pad_ctrl_mmio3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio3_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio3_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio3_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio3_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_mmio3': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio3 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio3_ds;        /* driving strength (low by default)               */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio3_reserved1; /* reserved                                        */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio3_pe;        /* pull enable (pull-down pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio3_reserved2; /* reserved                                        */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio3_ie;        /* input enable (enabled by default)               */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio3_reserved3; /* reserved                                        */
} NX90_PAD_CTRL_MMIO3_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO3_BIT_T bf;
} NX90_PAD_CTRL_MMIO3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio4 */
/* => Pad configuration register of port MMIO4 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_ANA_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio4      0x000000C8U
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio4 0xFF4010C8U
#define Adr_NX90_pad_ctrl_mmio4          0xFF4010C8U
#define DFLT_VAL_NX90_pad_ctrl_mmio4     0x00000010U

#define MSK_NX90_pad_ctrl_mmio4_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio4_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio4_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio4_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio4_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio4_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio4_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio4_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio4_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio4_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio4_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio4_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mmio4': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio4 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio4_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio4_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio4_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio4_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio4_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio4_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO4_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio4_ds;        /* driving strength (low by default)                          */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio4_reserved1; /* reserved                                                   */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio4_pe;        /* pull enable (pull-down pad, enabled by default)            */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio4_reserved2; /* reserved                                                   */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio4_ie;        /* input enable (shared analog function, disabled by default) */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio4_reserved3; /* reserved                                                   */
} NX90_PAD_CTRL_MMIO4_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO4_BIT_T bf;
} NX90_PAD_CTRL_MMIO4_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio5 */
/* => Pad configuration register of port MMIO5 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_ANA_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio5      0x000000CCU
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio5 0xFF4010CCU
#define Adr_NX90_pad_ctrl_mmio5          0xFF4010CCU
#define DFLT_VAL_NX90_pad_ctrl_mmio5     0x00000010U

#define MSK_NX90_pad_ctrl_mmio5_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio5_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio5_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio5_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio5_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio5_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio5_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio5_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio5_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio5_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio5_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio5_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mmio5': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio5 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio5_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio5_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio5_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio5_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio5_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio5_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO5_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio5_ds;        /* driving strength (low by default)                          */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio5_reserved1; /* reserved                                                   */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio5_pe;        /* pull enable (pull-down pad, enabled by default)            */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio5_reserved2; /* reserved                                                   */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio5_ie;        /* input enable (shared analog function, disabled by default) */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio5_reserved3; /* reserved                                                   */
} NX90_PAD_CTRL_MMIO5_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO5_BIT_T bf;
} NX90_PAD_CTRL_MMIO5_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio6 */
/* => Pad configuration register of port MMIO6 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_ANA_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio6      0x000000D0U
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio6 0xFF4010D0U
#define Adr_NX90_pad_ctrl_mmio6          0xFF4010D0U
#define DFLT_VAL_NX90_pad_ctrl_mmio6     0x00000010U

#define MSK_NX90_pad_ctrl_mmio6_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio6_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio6_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio6_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio6_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio6_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio6_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio6_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio6_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio6_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio6_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio6_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mmio6': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio6 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio6_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio6_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio6_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio6_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio6_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio6_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO6_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio6_ds;        /* driving strength (low by default)                          */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio6_reserved1; /* reserved                                                   */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio6_pe;        /* pull enable (pull-down pad, enabled by default)            */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio6_reserved2; /* reserved                                                   */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio6_ie;        /* input enable (shared analog function, disabled by default) */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio6_reserved3; /* reserved                                                   */
} NX90_PAD_CTRL_MMIO6_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO6_BIT_T bf;
} NX90_PAD_CTRL_MMIO6_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_mmio7 */
/* => Pad configuration register of port MMIO7 (asic_ctrl_access_key protected). */
/*    Pad type: PRDW0408SCDG_ANA_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_mmio7      0x000000D4U
#define Adr_NX90_pad_ctrl_pad_ctrl_mmio7 0xFF4010D4U
#define Adr_NX90_pad_ctrl_mmio7          0xFF4010D4U
#define DFLT_VAL_NX90_pad_ctrl_mmio7     0x00000010U

#define MSK_NX90_pad_ctrl_mmio7_ds         0x00000001U
#define SRT_NX90_pad_ctrl_mmio7_ds         0
#define DFLT_VAL_NX90_pad_ctrl_mmio7_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio7_ds 0x00000000U
#define MSK_NX90_pad_ctrl_mmio7_pe         0x00000010U
#define SRT_NX90_pad_ctrl_mmio7_pe         4
#define DFLT_VAL_NX90_pad_ctrl_mmio7_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio7_pe 0x00000001U
#define MSK_NX90_pad_ctrl_mmio7_ie         0x00000040U
#define SRT_NX90_pad_ctrl_mmio7_ie         6
#define DFLT_VAL_NX90_pad_ctrl_mmio7_ie    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_mmio7_ie 0x00000000U

/* all used bits of 'NX90_pad_ctrl_mmio7': */
#define MSK_USED_BITS_NX90_pad_ctrl_mmio7 0x00000051U

enum {
  BFW_NX90_pad_ctrl_mmio7_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_mmio7_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_mmio7_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_mmio7_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_mmio7_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_mmio7_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_MMIO7_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_mmio7_ds;        /* driving strength (low by default)                          */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_mmio7_reserved1; /* reserved                                                   */
  unsigned int pe        : BFW_NX90_pad_ctrl_mmio7_pe;        /* pull enable (pull-down pad, enabled by default)            */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_mmio7_reserved2; /* reserved                                                   */
  unsigned int ie        : BFW_NX90_pad_ctrl_mmio7_ie;        /* input enable (shared analog function, disabled by default) */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_mmio7_reserved3; /* reserved                                                   */
} NX90_PAD_CTRL_MMIO7_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_PAD_CTRL_MMIO7_BIT_T bf;
} NX90_PAD_CTRL_MMIO7_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_sqi_clk */
/* => Pad configuration register of port SQI_CLK (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_sqi_clk      0x000000D8U
#define Adr_NX90_pad_ctrl_pad_ctrl_sqi_clk 0xFF4010D8U
#define Adr_NX90_pad_ctrl_sqi_clk          0xFF4010D8U
#define DFLT_VAL_NX90_pad_ctrl_sqi_clk     0x00000050U

#define MSK_NX90_pad_ctrl_sqi_clk_ds         0x00000001U
#define SRT_NX90_pad_ctrl_sqi_clk_ds         0
#define DFLT_VAL_NX90_pad_ctrl_sqi_clk_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_clk_ds 0x00000000U
#define MSK_NX90_pad_ctrl_sqi_clk_pe         0x00000010U
#define SRT_NX90_pad_ctrl_sqi_clk_pe         4
#define DFLT_VAL_NX90_pad_ctrl_sqi_clk_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_clk_pe 0x00000001U
#define MSK_NX90_pad_ctrl_sqi_clk_ie         0x00000040U
#define SRT_NX90_pad_ctrl_sqi_clk_ie         6
#define DFLT_VAL_NX90_pad_ctrl_sqi_clk_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_clk_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_sqi_clk': */
#define MSK_USED_BITS_NX90_pad_ctrl_sqi_clk 0x00000051U

enum {
  BFW_NX90_pad_ctrl_sqi_clk_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_sqi_clk_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_sqi_clk_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_sqi_clk_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_sqi_clk_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_sqi_clk_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_SQI_CLK_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_sqi_clk_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_sqi_clk_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_sqi_clk_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_sqi_clk_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_sqi_clk_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_sqi_clk_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_SQI_CLK_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_SQI_CLK_BIT_T bf;
} NX90_PAD_CTRL_SQI_CLK_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_sqi_cs0n */
/* => Pad configuration register of port SQI_CS0N (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_sqi_cs0n      0x000000DCU
#define Adr_NX90_pad_ctrl_pad_ctrl_sqi_cs0n 0xFF4010DCU
#define Adr_NX90_pad_ctrl_sqi_cs0n          0xFF4010DCU
#define DFLT_VAL_NX90_pad_ctrl_sqi_cs0n     0x00000050U

#define MSK_NX90_pad_ctrl_sqi_cs0n_ds         0x00000001U
#define SRT_NX90_pad_ctrl_sqi_cs0n_ds         0
#define DFLT_VAL_NX90_pad_ctrl_sqi_cs0n_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_cs0n_ds 0x00000000U
#define MSK_NX90_pad_ctrl_sqi_cs0n_pe         0x00000010U
#define SRT_NX90_pad_ctrl_sqi_cs0n_pe         4
#define DFLT_VAL_NX90_pad_ctrl_sqi_cs0n_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_cs0n_pe 0x00000001U
#define MSK_NX90_pad_ctrl_sqi_cs0n_ie         0x00000040U
#define SRT_NX90_pad_ctrl_sqi_cs0n_ie         6
#define DFLT_VAL_NX90_pad_ctrl_sqi_cs0n_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_cs0n_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_sqi_cs0n': */
#define MSK_USED_BITS_NX90_pad_ctrl_sqi_cs0n 0x00000051U

enum {
  BFW_NX90_pad_ctrl_sqi_cs0n_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_sqi_cs0n_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_sqi_cs0n_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_sqi_cs0n_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_sqi_cs0n_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_sqi_cs0n_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_SQI_CS0N_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_sqi_cs0n_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_sqi_cs0n_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_sqi_cs0n_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_sqi_cs0n_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_sqi_cs0n_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_sqi_cs0n_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_SQI_CS0N_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_SQI_CS0N_BIT_T bf;
} NX90_PAD_CTRL_SQI_CS0N_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_sqi_mosi */
/* => Pad configuration register of port SQI_MOSI (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_sqi_mosi      0x000000E0U
#define Adr_NX90_pad_ctrl_pad_ctrl_sqi_mosi 0xFF4010E0U
#define Adr_NX90_pad_ctrl_sqi_mosi          0xFF4010E0U
#define DFLT_VAL_NX90_pad_ctrl_sqi_mosi     0x00000050U

#define MSK_NX90_pad_ctrl_sqi_mosi_ds         0x00000001U
#define SRT_NX90_pad_ctrl_sqi_mosi_ds         0
#define DFLT_VAL_NX90_pad_ctrl_sqi_mosi_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_mosi_ds 0x00000000U
#define MSK_NX90_pad_ctrl_sqi_mosi_pe         0x00000010U
#define SRT_NX90_pad_ctrl_sqi_mosi_pe         4
#define DFLT_VAL_NX90_pad_ctrl_sqi_mosi_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_mosi_pe 0x00000001U
#define MSK_NX90_pad_ctrl_sqi_mosi_ie         0x00000040U
#define SRT_NX90_pad_ctrl_sqi_mosi_ie         6
#define DFLT_VAL_NX90_pad_ctrl_sqi_mosi_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_mosi_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_sqi_mosi': */
#define MSK_USED_BITS_NX90_pad_ctrl_sqi_mosi 0x00000051U

enum {
  BFW_NX90_pad_ctrl_sqi_mosi_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_sqi_mosi_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_sqi_mosi_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_sqi_mosi_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_sqi_mosi_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_sqi_mosi_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_SQI_MOSI_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_sqi_mosi_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_sqi_mosi_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_sqi_mosi_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_sqi_mosi_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_sqi_mosi_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_sqi_mosi_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_SQI_MOSI_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_SQI_MOSI_BIT_T bf;
} NX90_PAD_CTRL_SQI_MOSI_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_sqi_miso */
/* => Pad configuration register of port SQI_MISO (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_sqi_miso      0x000000E4U
#define Adr_NX90_pad_ctrl_pad_ctrl_sqi_miso 0xFF4010E4U
#define Adr_NX90_pad_ctrl_sqi_miso          0xFF4010E4U
#define DFLT_VAL_NX90_pad_ctrl_sqi_miso     0x00000050U

#define MSK_NX90_pad_ctrl_sqi_miso_ds         0x00000001U
#define SRT_NX90_pad_ctrl_sqi_miso_ds         0
#define DFLT_VAL_NX90_pad_ctrl_sqi_miso_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_miso_ds 0x00000000U
#define MSK_NX90_pad_ctrl_sqi_miso_pe         0x00000010U
#define SRT_NX90_pad_ctrl_sqi_miso_pe         4
#define DFLT_VAL_NX90_pad_ctrl_sqi_miso_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_miso_pe 0x00000001U
#define MSK_NX90_pad_ctrl_sqi_miso_ie         0x00000040U
#define SRT_NX90_pad_ctrl_sqi_miso_ie         6
#define DFLT_VAL_NX90_pad_ctrl_sqi_miso_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_miso_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_sqi_miso': */
#define MSK_USED_BITS_NX90_pad_ctrl_sqi_miso 0x00000051U

enum {
  BFW_NX90_pad_ctrl_sqi_miso_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_sqi_miso_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_sqi_miso_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_sqi_miso_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_sqi_miso_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_sqi_miso_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_SQI_MISO_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_sqi_miso_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_sqi_miso_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_sqi_miso_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_sqi_miso_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_sqi_miso_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_sqi_miso_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_SQI_MISO_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_SQI_MISO_BIT_T bf;
} NX90_PAD_CTRL_SQI_MISO_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_sqi_sio2 */
/* => Pad configuration register of port SQI_SIO2 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_sqi_sio2      0x000000E8U
#define Adr_NX90_pad_ctrl_pad_ctrl_sqi_sio2 0xFF4010E8U
#define Adr_NX90_pad_ctrl_sqi_sio2          0xFF4010E8U
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio2     0x00000050U

#define MSK_NX90_pad_ctrl_sqi_sio2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_sqi_sio2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_sio2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_sqi_sio2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_sqi_sio2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio2_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_sio2_pe 0x00000001U
#define MSK_NX90_pad_ctrl_sqi_sio2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_sqi_sio2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio2_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_sio2_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_sqi_sio2': */
#define MSK_USED_BITS_NX90_pad_ctrl_sqi_sio2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_sqi_sio2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_sqi_sio2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_sqi_sio2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_sqi_sio2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_sqi_sio2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_sqi_sio2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_SQI_SIO2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_sqi_sio2_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_sqi_sio2_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_sqi_sio2_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_sqi_sio2_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_sqi_sio2_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_sqi_sio2_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_SQI_SIO2_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_SQI_SIO2_BIT_T bf;
} NX90_PAD_CTRL_SQI_SIO2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_sqi_sio3 */
/* => Pad configuration register of port SQI_SIO3 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_sqi_sio3      0x000000ECU
#define Adr_NX90_pad_ctrl_pad_ctrl_sqi_sio3 0xFF4010ECU
#define Adr_NX90_pad_ctrl_sqi_sio3          0xFF4010ECU
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio3     0x00000050U

#define MSK_NX90_pad_ctrl_sqi_sio3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_sqi_sio3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_sio3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_sqi_sio3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_sqi_sio3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio3_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_sio3_pe 0x00000001U
#define MSK_NX90_pad_ctrl_sqi_sio3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_sqi_sio3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_sqi_sio3_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_sqi_sio3_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_sqi_sio3': */
#define MSK_USED_BITS_NX90_pad_ctrl_sqi_sio3 0x00000051U

enum {
  BFW_NX90_pad_ctrl_sqi_sio3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_sqi_sio3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_sqi_sio3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_sqi_sio3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_sqi_sio3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_sqi_sio3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_SQI_SIO3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_sqi_sio3_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_sqi_sio3_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_sqi_sio3_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_sqi_sio3_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_sqi_sio3_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_sqi_sio3_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_SQI_SIO3_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_SQI_SIO3_BIT_T bf;
} NX90_PAD_CTRL_SQI_SIO3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a0 */
/* => Pad configuration register of port HIF_A0 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a0      0x000000F0U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a0 0xFF4010F0U
#define Adr_NX90_pad_ctrl_hif_a0          0xFF4010F0U
#define DFLT_VAL_NX90_pad_ctrl_hif_a0     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a0_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a0_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a0_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a0_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a0_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a0_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a0_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a0_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a0': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a0 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a0_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A0_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a0_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a0_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a0_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a0_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a0_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a0_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A0_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A0_BIT_T bf;
} NX90_PAD_CTRL_HIF_A0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a1 */
/* => Pad configuration register of port HIF_A1 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a1      0x000000F4U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a1 0xFF4010F4U
#define Adr_NX90_pad_ctrl_hif_a1          0xFF4010F4U
#define DFLT_VAL_NX90_pad_ctrl_hif_a1     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a1_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a1_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a1_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a1_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a1': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a1_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a1_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a1_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a1_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a1_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a1_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A1_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A1_BIT_T bf;
} NX90_PAD_CTRL_HIF_A1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a2 */
/* => Pad configuration register of port HIF_A2 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a2      0x000000F8U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a2 0xFF4010F8U
#define Adr_NX90_pad_ctrl_hif_a2          0xFF4010F8U
#define DFLT_VAL_NX90_pad_ctrl_hif_a2     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a2_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a2_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a2_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a2_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a2': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a2_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a2_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a2_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a2_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a2_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a2_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A2_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A2_BIT_T bf;
} NX90_PAD_CTRL_HIF_A2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a3 */
/* => Pad configuration register of port HIF_A3 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a3      0x000000FCU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a3 0xFF4010FCU
#define Adr_NX90_pad_ctrl_hif_a3          0xFF4010FCU
#define DFLT_VAL_NX90_pad_ctrl_hif_a3     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a3_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a3_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a3_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a3_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a3': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a3 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a3_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a3_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a3_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a3_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a3_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a3_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A3_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A3_BIT_T bf;
} NX90_PAD_CTRL_HIF_A3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a4 */
/* => Pad configuration register of port HIF_A4 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a4      0x00000100U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a4 0xFF401100U
#define Adr_NX90_pad_ctrl_hif_a4          0xFF401100U
#define DFLT_VAL_NX90_pad_ctrl_hif_a4     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a4_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a4_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a4_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a4_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a4_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a4_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a4_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a4_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a4_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a4_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a4_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a4_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a4': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a4 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a4_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a4_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a4_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a4_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a4_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a4_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A4_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a4_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a4_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a4_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a4_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a4_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a4_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A4_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A4_BIT_T bf;
} NX90_PAD_CTRL_HIF_A4_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a5 */
/* => Pad configuration register of port HIF_A5 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a5      0x00000104U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a5 0xFF401104U
#define Adr_NX90_pad_ctrl_hif_a5          0xFF401104U
#define DFLT_VAL_NX90_pad_ctrl_hif_a5     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a5_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a5_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a5_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a5_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a5_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a5_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a5_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a5_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a5_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a5_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a5_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a5_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a5': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a5 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a5_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a5_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a5_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a5_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a5_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a5_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A5_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a5_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a5_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a5_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a5_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a5_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a5_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A5_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A5_BIT_T bf;
} NX90_PAD_CTRL_HIF_A5_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a6 */
/* => Pad configuration register of port HIF_A6 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a6      0x00000108U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a6 0xFF401108U
#define Adr_NX90_pad_ctrl_hif_a6          0xFF401108U
#define DFLT_VAL_NX90_pad_ctrl_hif_a6     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a6_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a6_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a6_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a6_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a6_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a6_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a6_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a6_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a6_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a6_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a6_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a6_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a6': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a6 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a6_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a6_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a6_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a6_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a6_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a6_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A6_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a6_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a6_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a6_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a6_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a6_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a6_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A6_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A6_BIT_T bf;
} NX90_PAD_CTRL_HIF_A6_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a7 */
/* => Pad configuration register of port HIF_A7 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a7      0x0000010CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a7 0xFF40110CU
#define Adr_NX90_pad_ctrl_hif_a7          0xFF40110CU
#define DFLT_VAL_NX90_pad_ctrl_hif_a7     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a7_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a7_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a7_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a7_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a7_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a7_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a7_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a7_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a7_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a7_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a7_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a7_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a7': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a7 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a7_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a7_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a7_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a7_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a7_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a7_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A7_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a7_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a7_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a7_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a7_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a7_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a7_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A7_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A7_BIT_T bf;
} NX90_PAD_CTRL_HIF_A7_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a8 */
/* => Pad configuration register of port HIF_A8 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a8      0x00000110U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a8 0xFF401110U
#define Adr_NX90_pad_ctrl_hif_a8          0xFF401110U
#define DFLT_VAL_NX90_pad_ctrl_hif_a8     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a8_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a8_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a8_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a8_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a8_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a8_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a8_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a8_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a8_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a8_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a8_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a8_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a8': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a8 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a8_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a8_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a8_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a8_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a8_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a8_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A8_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a8_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a8_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a8_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a8_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a8_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a8_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A8_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A8_BIT_T bf;
} NX90_PAD_CTRL_HIF_A8_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a9 */
/* => Pad configuration register of port HIF_A9 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a9      0x00000114U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a9 0xFF401114U
#define Adr_NX90_pad_ctrl_hif_a9          0xFF401114U
#define DFLT_VAL_NX90_pad_ctrl_hif_a9     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a9_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a9_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a9_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a9_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a9_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a9_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a9_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a9_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a9_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a9_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a9_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a9_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a9': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a9 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a9_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a9_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a9_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a9_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a9_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a9_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A9_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a9_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a9_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a9_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a9_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a9_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a9_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A9_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_A9_BIT_T bf;
} NX90_PAD_CTRL_HIF_A9_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a10 */
/* => Pad configuration register of port HIF_A10 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a10      0x00000118U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a10 0xFF401118U
#define Adr_NX90_pad_ctrl_hif_a10          0xFF401118U
#define DFLT_VAL_NX90_pad_ctrl_hif_a10     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a10_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a10_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a10_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a10_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a10_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a10_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a10_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a10_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a10_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a10_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a10_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a10_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a10': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a10 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a10_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a10_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a10_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a10_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a10_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a10_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A10_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a10_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a10_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a10_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a10_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a10_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a10_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A10_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A10_BIT_T bf;
} NX90_PAD_CTRL_HIF_A10_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a11 */
/* => Pad configuration register of port HIF_A11 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a11      0x0000011CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a11 0xFF40111CU
#define Adr_NX90_pad_ctrl_hif_a11          0xFF40111CU
#define DFLT_VAL_NX90_pad_ctrl_hif_a11     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a11_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a11_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a11_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a11_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a11_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a11_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a11_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a11_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a11_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a11_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a11_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a11_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a11': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a11 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a11_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a11_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a11_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a11_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a11_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a11_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A11_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a11_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a11_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a11_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a11_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a11_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a11_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A11_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A11_BIT_T bf;
} NX90_PAD_CTRL_HIF_A11_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a12 */
/* => Pad configuration register of port HIF_A12 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a12      0x00000120U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a12 0xFF401120U
#define Adr_NX90_pad_ctrl_hif_a12          0xFF401120U
#define DFLT_VAL_NX90_pad_ctrl_hif_a12     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a12_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a12_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a12_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a12_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a12_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a12_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a12_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a12_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a12_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a12_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a12_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a12_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a12': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a12 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a12_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a12_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a12_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a12_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a12_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a12_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A12_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a12_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a12_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a12_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a12_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a12_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a12_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A12_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A12_BIT_T bf;
} NX90_PAD_CTRL_HIF_A12_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a13 */
/* => Pad configuration register of port HIF_A13 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a13      0x00000124U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a13 0xFF401124U
#define Adr_NX90_pad_ctrl_hif_a13          0xFF401124U
#define DFLT_VAL_NX90_pad_ctrl_hif_a13     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a13_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a13_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a13_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a13_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a13_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a13_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a13_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a13_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a13_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a13_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a13_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a13_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a13': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a13 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a13_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a13_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a13_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a13_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a13_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a13_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A13_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a13_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a13_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a13_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a13_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a13_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a13_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A13_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A13_BIT_T bf;
} NX90_PAD_CTRL_HIF_A13_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a14 */
/* => Pad configuration register of port HIF_A14 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a14      0x00000128U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a14 0xFF401128U
#define Adr_NX90_pad_ctrl_hif_a14          0xFF401128U
#define DFLT_VAL_NX90_pad_ctrl_hif_a14     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a14_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a14_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a14_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a14_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a14_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a14_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a14_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a14_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a14_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a14_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a14_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a14_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a14': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a14 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a14_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a14_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a14_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a14_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a14_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a14_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A14_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a14_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a14_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a14_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a14_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a14_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a14_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A14_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A14_BIT_T bf;
} NX90_PAD_CTRL_HIF_A14_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a15 */
/* => Pad configuration register of port HIF_A15 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a15      0x0000012CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a15 0xFF40112CU
#define Adr_NX90_pad_ctrl_hif_a15          0xFF40112CU
#define DFLT_VAL_NX90_pad_ctrl_hif_a15     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a15_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a15_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a15_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a15_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a15_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a15_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a15_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a15_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a15_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a15_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a15_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a15_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a15': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a15 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a15_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a15_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a15_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a15_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a15_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a15_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A15_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a15_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a15_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a15_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a15_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a15_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a15_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A15_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A15_BIT_T bf;
} NX90_PAD_CTRL_HIF_A15_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a16 */
/* => Pad configuration register of port HIF_A16 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a16      0x00000130U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a16 0xFF401130U
#define Adr_NX90_pad_ctrl_hif_a16          0xFF401130U
#define DFLT_VAL_NX90_pad_ctrl_hif_a16     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a16_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a16_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a16_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a16_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a16_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a16_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a16_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a16_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a16_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a16_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a16_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a16_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a16': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a16 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a16_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a16_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a16_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a16_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a16_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a16_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A16_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a16_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a16_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a16_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a16_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a16_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a16_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A16_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A16_BIT_T bf;
} NX90_PAD_CTRL_HIF_A16_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_a17 */
/* => Pad configuration register of port HIF_A17 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_a17      0x00000134U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_a17 0xFF401134U
#define Adr_NX90_pad_ctrl_hif_a17          0xFF401134U
#define DFLT_VAL_NX90_pad_ctrl_hif_a17     0x00000050U

#define MSK_NX90_pad_ctrl_hif_a17_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_a17_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_a17_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a17_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_a17_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_a17_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_a17_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a17_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_a17_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_a17_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_a17_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_a17_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_a17': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_a17 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_a17_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_a17_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_a17_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_a17_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_a17_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_a17_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_A17_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_a17_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_a17_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_a17_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_a17_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_a17_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_a17_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_A17_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_A17_BIT_T bf;
} NX90_PAD_CTRL_HIF_A17_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d0 */
/* => Pad configuration register of port HIF_D0 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d0      0x00000138U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d0 0xFF401138U
#define Adr_NX90_pad_ctrl_hif_d0          0xFF401138U
#define DFLT_VAL_NX90_pad_ctrl_hif_d0     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d0_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d0_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d0_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d0_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d0_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d0_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d0_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d0_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d0_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d0_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d0_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d0_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d0': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d0 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d0_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d0_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d0_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d0_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d0_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d0_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D0_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d0_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d0_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d0_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d0_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d0_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d0_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D0_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D0_BIT_T bf;
} NX90_PAD_CTRL_HIF_D0_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d1 */
/* => Pad configuration register of port HIF_D1 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d1      0x0000013CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d1 0xFF40113CU
#define Adr_NX90_pad_ctrl_hif_d1          0xFF40113CU
#define DFLT_VAL_NX90_pad_ctrl_hif_d1     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d1_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d1_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d1_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d1_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d1_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d1_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d1_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d1_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d1_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d1_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d1_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d1_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d1': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d1 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d1_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d1_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d1_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d1_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d1_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d1_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D1_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d1_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d1_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d1_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d1_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d1_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d1_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D1_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D1_BIT_T bf;
} NX90_PAD_CTRL_HIF_D1_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d2 */
/* => Pad configuration register of port HIF_D2 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d2      0x00000140U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d2 0xFF401140U
#define Adr_NX90_pad_ctrl_hif_d2          0xFF401140U
#define DFLT_VAL_NX90_pad_ctrl_hif_d2     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d2_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d2_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d2_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d2_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d2_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d2_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d2_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d2_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d2_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d2_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d2_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d2_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d2': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d2 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d2_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d2_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d2_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d2_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d2_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d2_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D2_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d2_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d2_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d2_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d2_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d2_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d2_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D2_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D2_BIT_T bf;
} NX90_PAD_CTRL_HIF_D2_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d3 */
/* => Pad configuration register of port HIF_D3 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d3      0x00000144U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d3 0xFF401144U
#define Adr_NX90_pad_ctrl_hif_d3          0xFF401144U
#define DFLT_VAL_NX90_pad_ctrl_hif_d3     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d3_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d3_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d3_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d3_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d3_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d3_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d3_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d3_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d3_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d3_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d3_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d3_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d3': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d3 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d3_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d3_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d3_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d3_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d3_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d3_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D3_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d3_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d3_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d3_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d3_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d3_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d3_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D3_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D3_BIT_T bf;
} NX90_PAD_CTRL_HIF_D3_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d4 */
/* => Pad configuration register of port HIF_D4 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d4      0x00000148U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d4 0xFF401148U
#define Adr_NX90_pad_ctrl_hif_d4          0xFF401148U
#define DFLT_VAL_NX90_pad_ctrl_hif_d4     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d4_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d4_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d4_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d4_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d4_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d4_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d4_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d4_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d4_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d4_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d4_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d4_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d4': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d4 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d4_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d4_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d4_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d4_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d4_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d4_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D4_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d4_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d4_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d4_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d4_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d4_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d4_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D4_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D4_BIT_T bf;
} NX90_PAD_CTRL_HIF_D4_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d5 */
/* => Pad configuration register of port HIF_D5 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d5      0x0000014CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d5 0xFF40114CU
#define Adr_NX90_pad_ctrl_hif_d5          0xFF40114CU
#define DFLT_VAL_NX90_pad_ctrl_hif_d5     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d5_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d5_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d5_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d5_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d5_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d5_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d5_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d5_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d5_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d5_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d5_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d5_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d5': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d5 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d5_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d5_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d5_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d5_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d5_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d5_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D5_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d5_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d5_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d5_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d5_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d5_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d5_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D5_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D5_BIT_T bf;
} NX90_PAD_CTRL_HIF_D5_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d6 */
/* => Pad configuration register of port HIF_D6 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d6      0x00000150U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d6 0xFF401150U
#define Adr_NX90_pad_ctrl_hif_d6          0xFF401150U
#define DFLT_VAL_NX90_pad_ctrl_hif_d6     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d6_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d6_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d6_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d6_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d6_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d6_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d6_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d6_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d6_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d6_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d6_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d6_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d6': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d6 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d6_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d6_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d6_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d6_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d6_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d6_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D6_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d6_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d6_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d6_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d6_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d6_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d6_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D6_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D6_BIT_T bf;
} NX90_PAD_CTRL_HIF_D6_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d7 */
/* => Pad configuration register of port HIF_D7 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d7      0x00000154U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d7 0xFF401154U
#define Adr_NX90_pad_ctrl_hif_d7          0xFF401154U
#define DFLT_VAL_NX90_pad_ctrl_hif_d7     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d7_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d7_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d7_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d7_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d7_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d7_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d7_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d7_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d7_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d7_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d7_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d7_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d7': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d7 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d7_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d7_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d7_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d7_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d7_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d7_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D7_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d7_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d7_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d7_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d7_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d7_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d7_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D7_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D7_BIT_T bf;
} NX90_PAD_CTRL_HIF_D7_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d8 */
/* => Pad configuration register of port HIF_D8 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d8      0x00000158U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d8 0xFF401158U
#define Adr_NX90_pad_ctrl_hif_d8          0xFF401158U
#define DFLT_VAL_NX90_pad_ctrl_hif_d8     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d8_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d8_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d8_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d8_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d8_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d8_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d8_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d8_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d8_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d8_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d8_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d8_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d8': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d8 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d8_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d8_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d8_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d8_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d8_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d8_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D8_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d8_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d8_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d8_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d8_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d8_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d8_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D8_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D8_BIT_T bf;
} NX90_PAD_CTRL_HIF_D8_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d9 */
/* => Pad configuration register of port HIF_D9 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d9      0x0000015CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d9 0xFF40115CU
#define Adr_NX90_pad_ctrl_hif_d9          0xFF40115CU
#define DFLT_VAL_NX90_pad_ctrl_hif_d9     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d9_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d9_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d9_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d9_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d9_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d9_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d9_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d9_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d9_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d9_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d9_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d9_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d9': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d9 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d9_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d9_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d9_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d9_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d9_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d9_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D9_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d9_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d9_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d9_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d9_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d9_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d9_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D9_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_PAD_CTRL_HIF_D9_BIT_T bf;
} NX90_PAD_CTRL_HIF_D9_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d10 */
/* => Pad configuration register of port HIF_D10 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d10      0x00000160U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d10 0xFF401160U
#define Adr_NX90_pad_ctrl_hif_d10          0xFF401160U
#define DFLT_VAL_NX90_pad_ctrl_hif_d10     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d10_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d10_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d10_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d10_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d10_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d10_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d10_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d10_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d10_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d10_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d10_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d10_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d10': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d10 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d10_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d10_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d10_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d10_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d10_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d10_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D10_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d10_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d10_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d10_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d10_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d10_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d10_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D10_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_D10_BIT_T bf;
} NX90_PAD_CTRL_HIF_D10_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d11 */
/* => Pad configuration register of port HIF_D11 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d11      0x00000164U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d11 0xFF401164U
#define Adr_NX90_pad_ctrl_hif_d11          0xFF401164U
#define DFLT_VAL_NX90_pad_ctrl_hif_d11     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d11_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d11_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d11_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d11_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d11_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d11_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d11_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d11_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d11_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d11_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d11_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d11_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d11': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d11 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d11_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d11_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d11_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d11_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d11_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d11_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D11_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d11_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d11_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d11_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d11_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d11_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d11_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D11_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_D11_BIT_T bf;
} NX90_PAD_CTRL_HIF_D11_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d12 */
/* => Pad configuration register of port HIF_D12 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d12      0x00000168U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d12 0xFF401168U
#define Adr_NX90_pad_ctrl_hif_d12          0xFF401168U
#define DFLT_VAL_NX90_pad_ctrl_hif_d12     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d12_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d12_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d12_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d12_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d12_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d12_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d12_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d12_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d12_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d12_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d12_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d12_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d12': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d12 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d12_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d12_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d12_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d12_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d12_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d12_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D12_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d12_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d12_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d12_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d12_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d12_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d12_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D12_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_D12_BIT_T bf;
} NX90_PAD_CTRL_HIF_D12_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d13 */
/* => Pad configuration register of port HIF_D13 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d13      0x0000016CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d13 0xFF40116CU
#define Adr_NX90_pad_ctrl_hif_d13          0xFF40116CU
#define DFLT_VAL_NX90_pad_ctrl_hif_d13     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d13_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d13_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d13_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d13_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d13_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d13_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d13_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d13_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d13_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d13_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d13_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d13_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d13': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d13 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d13_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d13_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d13_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d13_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d13_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d13_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D13_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d13_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d13_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d13_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d13_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d13_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d13_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D13_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_D13_BIT_T bf;
} NX90_PAD_CTRL_HIF_D13_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d14 */
/* => Pad configuration register of port HIF_D14 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d14      0x00000170U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d14 0xFF401170U
#define Adr_NX90_pad_ctrl_hif_d14          0xFF401170U
#define DFLT_VAL_NX90_pad_ctrl_hif_d14     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d14_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d14_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d14_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d14_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d14_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d14_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d14_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d14_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d14_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d14_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d14_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d14_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d14': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d14 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d14_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d14_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d14_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d14_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d14_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d14_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D14_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d14_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d14_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d14_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d14_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d14_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d14_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D14_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_D14_BIT_T bf;
} NX90_PAD_CTRL_HIF_D14_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_d15 */
/* => Pad configuration register of port HIF_D15 (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_d15      0x00000174U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_d15 0xFF401174U
#define Adr_NX90_pad_ctrl_hif_d15          0xFF401174U
#define DFLT_VAL_NX90_pad_ctrl_hif_d15     0x00000050U

#define MSK_NX90_pad_ctrl_hif_d15_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_d15_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_d15_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d15_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_d15_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_d15_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_d15_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d15_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_d15_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_d15_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_d15_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_d15_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_d15': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_d15 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_d15_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_d15_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_d15_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_d15_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_d15_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_d15_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_D15_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_d15_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_d15_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_d15_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_d15_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_d15_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_d15_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_D15_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_D15_BIT_T bf;
} NX90_PAD_CTRL_HIF_D15_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_bhen */
/* => Pad configuration register of port HIF_BHEN (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_bhen      0x00000178U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_bhen 0xFF401178U
#define Adr_NX90_pad_ctrl_hif_bhen          0xFF401178U
#define DFLT_VAL_NX90_pad_ctrl_hif_bhen     0x00000050U

#define MSK_NX90_pad_ctrl_hif_bhen_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_bhen_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_bhen_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_bhen_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_bhen_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_bhen_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_bhen_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_bhen_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_bhen_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_bhen_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_bhen_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_bhen_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_bhen': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_bhen 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_bhen_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_bhen_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_bhen_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_bhen_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_bhen_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_bhen_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_BHEN_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_bhen_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_bhen_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_bhen_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_bhen_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_bhen_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_bhen_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_BHEN_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_HIF_BHEN_BIT_T bf;
} NX90_PAD_CTRL_HIF_BHEN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_csn */
/* => Pad configuration register of port HIF_CSN (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_csn      0x0000017CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_csn 0xFF40117CU
#define Adr_NX90_pad_ctrl_hif_csn          0xFF40117CU
#define DFLT_VAL_NX90_pad_ctrl_hif_csn     0x00000050U

#define MSK_NX90_pad_ctrl_hif_csn_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_csn_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_csn_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_csn_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_csn_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_csn_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_csn_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_csn_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_csn_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_csn_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_csn_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_csn_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_csn': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_csn 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_csn_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_csn_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_csn_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_csn_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_csn_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_csn_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_CSN_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_csn_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_csn_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_csn_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_csn_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_csn_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_csn_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_CSN_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_CSN_BIT_T bf;
} NX90_PAD_CTRL_HIF_CSN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_rdn */
/* => Pad configuration register of port HIF_RDN (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_rdn      0x00000180U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_rdn 0xFF401180U
#define Adr_NX90_pad_ctrl_hif_rdn          0xFF401180U
#define DFLT_VAL_NX90_pad_ctrl_hif_rdn     0x00000050U

#define MSK_NX90_pad_ctrl_hif_rdn_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_rdn_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_rdn_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_rdn_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_rdn_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_rdn_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_rdn_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_rdn_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_rdn_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_rdn_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_rdn_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_rdn_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_rdn': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_rdn 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_rdn_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_rdn_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_rdn_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_rdn_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_rdn_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_rdn_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_RDN_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_rdn_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_rdn_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_rdn_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_rdn_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_rdn_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_rdn_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_RDN_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_RDN_BIT_T bf;
} NX90_PAD_CTRL_HIF_RDN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_wrn */
/* => Pad configuration register of port HIF_WRN (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_wrn      0x00000184U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_wrn 0xFF401184U
#define Adr_NX90_pad_ctrl_hif_wrn          0xFF401184U
#define DFLT_VAL_NX90_pad_ctrl_hif_wrn     0x00000050U

#define MSK_NX90_pad_ctrl_hif_wrn_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_wrn_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_wrn_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_wrn_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_wrn_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_wrn_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_wrn_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_wrn_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_wrn_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_wrn_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_wrn_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_wrn_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_wrn': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_wrn 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_wrn_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_wrn_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_wrn_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_wrn_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_wrn_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_wrn_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_WRN_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_wrn_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_wrn_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_wrn_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_wrn_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_wrn_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_wrn_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_WRN_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_WRN_BIT_T bf;
} NX90_PAD_CTRL_HIF_WRN_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_rdy */
/* => Pad configuration register of port HIF_RDY (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_rdy      0x00000188U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_rdy 0xFF401188U
#define Adr_NX90_pad_ctrl_hif_rdy          0xFF401188U
#define DFLT_VAL_NX90_pad_ctrl_hif_rdy     0x00000050U

#define MSK_NX90_pad_ctrl_hif_rdy_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_rdy_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_rdy_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_rdy_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_rdy_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_rdy_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_rdy_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_rdy_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_rdy_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_rdy_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_rdy_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_rdy_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_rdy': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_rdy 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_rdy_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_rdy_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_rdy_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_rdy_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_rdy_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_rdy_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_RDY_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_rdy_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_rdy_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_rdy_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_rdy_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_rdy_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_rdy_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_RDY_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_PAD_CTRL_HIF_RDY_BIT_T bf;
} NX90_PAD_CTRL_HIF_RDY_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_dirq */
/* => Pad configuration register of port HIF_DIRQ (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_dirq      0x0000018CU
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_dirq 0xFF40118CU
#define Adr_NX90_pad_ctrl_hif_dirq          0xFF40118CU
#define DFLT_VAL_NX90_pad_ctrl_hif_dirq     0x00000050U

#define MSK_NX90_pad_ctrl_hif_dirq_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_dirq_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_dirq_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_dirq_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_dirq_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_dirq_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_dirq_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_dirq_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_dirq_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_dirq_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_dirq_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_dirq_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_dirq': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_dirq 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_dirq_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_dirq_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_dirq_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_dirq_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_dirq_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_dirq_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_DIRQ_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_dirq_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_dirq_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_dirq_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_dirq_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_dirq_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_dirq_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_DIRQ_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_PAD_CTRL_HIF_DIRQ_BIT_T bf;
} NX90_PAD_CTRL_HIF_DIRQ_T;

/* --------------------------------------------------------------------- */
/* Register pad_ctrl_hif_sdclk */
/* => Pad configuration register of port HIF_SDCLK (asic_ctrl_access_key protected). */
/*    Pad type: PDUW0408SCDG_33 */
/*    For details refer to description of register pad_ctrl_rdy_n. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pad_ctrl_hif_sdclk      0x00000190U
#define Adr_NX90_pad_ctrl_pad_ctrl_hif_sdclk 0xFF401190U
#define Adr_NX90_pad_ctrl_hif_sdclk          0xFF401190U
#define DFLT_VAL_NX90_pad_ctrl_hif_sdclk     0x00000050U

#define MSK_NX90_pad_ctrl_hif_sdclk_ds         0x00000001U
#define SRT_NX90_pad_ctrl_hif_sdclk_ds         0
#define DFLT_VAL_NX90_pad_ctrl_hif_sdclk_ds    0x00000000U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_sdclk_ds 0x00000000U
#define MSK_NX90_pad_ctrl_hif_sdclk_pe         0x00000010U
#define SRT_NX90_pad_ctrl_hif_sdclk_pe         4
#define DFLT_VAL_NX90_pad_ctrl_hif_sdclk_pe    0x00000010U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_sdclk_pe 0x00000001U
#define MSK_NX90_pad_ctrl_hif_sdclk_ie         0x00000040U
#define SRT_NX90_pad_ctrl_hif_sdclk_ie         6
#define DFLT_VAL_NX90_pad_ctrl_hif_sdclk_ie    0x00000040U
#define DFLT_BF_VAL_NX90_pad_ctrl_hif_sdclk_ie 0x00000001U

/* all used bits of 'NX90_pad_ctrl_hif_sdclk': */
#define MSK_USED_BITS_NX90_pad_ctrl_hif_sdclk 0x00000051U

enum {
  BFW_NX90_pad_ctrl_hif_sdclk_ds        = 1,  /* [0] */
  BFW_NX90_pad_ctrl_hif_sdclk_reserved1 = 3,  /* [3:1] */
  BFW_NX90_pad_ctrl_hif_sdclk_pe        = 1,  /* [4] */
  BFW_NX90_pad_ctrl_hif_sdclk_reserved2 = 1,  /* [5] */
  BFW_NX90_pad_ctrl_hif_sdclk_ie        = 1,  /* [6] */
  BFW_NX90_pad_ctrl_hif_sdclk_reserved3 = 25  /* [31:7] */
};

typedef struct NX90_PAD_CTRL_HIF_SDCLK_BIT_Ttag {
  unsigned int ds        : BFW_NX90_pad_ctrl_hif_sdclk_ds;        /* driving strength (low by default)             */
  unsigned int reserved1 : BFW_NX90_pad_ctrl_hif_sdclk_reserved1; /* reserved                                      */
  unsigned int pe        : BFW_NX90_pad_ctrl_hif_sdclk_pe;        /* pull enable (pull-up pad, enabled by default) */
  unsigned int reserved2 : BFW_NX90_pad_ctrl_hif_sdclk_reserved2; /* reserved                                      */
  unsigned int ie        : BFW_NX90_pad_ctrl_hif_sdclk_ie;        /* input enable (enabled by default)             */
  unsigned int reserved3 : BFW_NX90_pad_ctrl_hif_sdclk_reserved3; /* reserved                                      */
} NX90_PAD_CTRL_HIF_SDCLK_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_PAD_CTRL_HIF_SDCLK_BIT_T bf;
} NX90_PAD_CTRL_HIF_SDCLK_T;


/* ===================================================================== */

/* Area of asic_ctrl */

/* ===================================================================== */

#define Addr_NX90_asic_ctrl 0xFF401200U

/* --------------------------------------------------------------------- */
/* Register io_config0 */
/* => IO Config0 Register: */
/*    reserved for COM side */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config0       0x00000000U
#define Adr_NX90_asic_ctrl_io_config0 0xFF401200U
#define Adr_NX90_io_config0           0xFF401200U

#define MSK_NX90_io_config0_val 0xffffffffU
#define SRT_NX90_io_config0_val 0

/* all used bits of 'NX90_io_config0': */
#define MSK_USED_BITS_NX90_io_config0 0xffffffffU

enum {
  BFW_NX90_io_config0_val = 32  /* [31:0] */
};

typedef struct NX90_IO_CONFIG0_BIT_Ttag {
  unsigned int val : BFW_NX90_io_config0_val; /* reserved */
} NX90_IO_CONFIG0_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG0_BIT_T bf;
} NX90_IO_CONFIG0_T;

/* --------------------------------------------------------------------- */
/* Register io_config0_mask */
/* => IO Config0 Mask Register: */
/*    reserved for COM side */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config0_mask       0x00000004U
#define Adr_NX90_asic_ctrl_io_config0_mask 0xFF401204U
#define Adr_NX90_io_config0_mask           0xFF401204U

#define MSK_NX90_io_config0_mask_val 0xffffffffU
#define SRT_NX90_io_config0_mask_val 0

/* all used bits of 'NX90_io_config0_mask': */
#define MSK_USED_BITS_NX90_io_config0_mask 0xffffffffU

enum {
  BFW_NX90_io_config0_mask_val = 32  /* [31:0] */
};

typedef struct NX90_IO_CONFIG0_MASK_BIT_Ttag {
  unsigned int val : BFW_NX90_io_config0_mask_val; /* reserved */
} NX90_IO_CONFIG0_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG0_MASK_BIT_T bf;
} NX90_IO_CONFIG0_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config1 */
/* => IO Config1 Register: */
/*    reserved for COM side */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config1       0x00000008U
#define Adr_NX90_asic_ctrl_io_config1 0xFF401208U
#define Adr_NX90_io_config1           0xFF401208U

#define MSK_NX90_io_config1_val 0xffffffffU
#define SRT_NX90_io_config1_val 0

/* all used bits of 'NX90_io_config1': */
#define MSK_USED_BITS_NX90_io_config1 0xffffffffU

enum {
  BFW_NX90_io_config1_val = 32  /* [31:0] */
};

typedef struct NX90_IO_CONFIG1_BIT_Ttag {
  unsigned int val : BFW_NX90_io_config1_val; /* reserved */
} NX90_IO_CONFIG1_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG1_BIT_T bf;
} NX90_IO_CONFIG1_T;

/* --------------------------------------------------------------------- */
/* Register io_config1_mask */
/* => IO Config1 Mask Register: */
/*    reserved for COM side */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config1_mask       0x0000000CU
#define Adr_NX90_asic_ctrl_io_config1_mask 0xFF40120CU
#define Adr_NX90_io_config1_mask           0xFF40120CU

#define MSK_NX90_io_config1_mask_val 0xffffffffU
#define SRT_NX90_io_config1_mask_val 0

/* all used bits of 'NX90_io_config1_mask': */
#define MSK_USED_BITS_NX90_io_config1_mask 0xffffffffU

enum {
  BFW_NX90_io_config1_mask_val = 32  /* [31:0] */
};

typedef struct NX90_IO_CONFIG1_MASK_BIT_Ttag {
  unsigned int val : BFW_NX90_io_config1_mask_val; /* reserved */
} NX90_IO_CONFIG1_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG1_MASK_BIT_T bf;
} NX90_IO_CONFIG1_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config2 */
/* => IO Config2 Register: */
/*    reserved for COM side */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config2       0x00000010U
#define Adr_NX90_asic_ctrl_io_config2 0xFF401210U
#define Adr_NX90_io_config2           0xFF401210U

#define MSK_NX90_io_config2_val 0xffffffffU
#define SRT_NX90_io_config2_val 0

/* all used bits of 'NX90_io_config2': */
#define MSK_USED_BITS_NX90_io_config2 0xffffffffU

enum {
  BFW_NX90_io_config2_val = 32  /* [31:0] */
};

typedef struct NX90_IO_CONFIG2_BIT_Ttag {
  unsigned int val : BFW_NX90_io_config2_val; /* reserved */
} NX90_IO_CONFIG2_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG2_BIT_T bf;
} NX90_IO_CONFIG2_T;

/* --------------------------------------------------------------------- */
/* Register io_config2_mask */
/* => IO Config2 Mask Register: */
/*    reserved for COM side */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config2_mask       0x00000014U
#define Adr_NX90_asic_ctrl_io_config2_mask 0xFF401214U
#define Adr_NX90_io_config2_mask           0xFF401214U

#define MSK_NX90_io_config2_mask_val 0xffffffffU
#define SRT_NX90_io_config2_mask_val 0

/* all used bits of 'NX90_io_config2_mask': */
#define MSK_USED_BITS_NX90_io_config2_mask 0xffffffffU

enum {
  BFW_NX90_io_config2_mask_val = 32  /* [31:0] */
};

typedef struct NX90_IO_CONFIG2_MASK_BIT_Ttag {
  unsigned int val : BFW_NX90_io_config2_mask_val; /* reserved */
} NX90_IO_CONFIG2_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG2_MASK_BIT_T bf;
} NX90_IO_CONFIG2_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config3 */
/* => IO Config3 Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Changes will only have effect if according bit in io_config3_mask-register is set. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config3       0x00000018U
#define Adr_NX90_asic_ctrl_io_config3 0xFF401218U
#define Adr_NX90_io_config3           0xFF401218U
#define DFLT_VAL_NX90_io_config3      0x00000000U

#define MSK_NX90_io_config3_sel_gpio0                0x00000001U
#define SRT_NX90_io_config3_sel_gpio0                0
#define DFLT_VAL_NX90_io_config3_sel_gpio0           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio0        0x00000000U
#define MSK_NX90_io_config3_sel_gpio1                0x00000002U
#define SRT_NX90_io_config3_sel_gpio1                1
#define DFLT_VAL_NX90_io_config3_sel_gpio1           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio1        0x00000000U
#define MSK_NX90_io_config3_sel_gpio2                0x00000004U
#define SRT_NX90_io_config3_sel_gpio2                2
#define DFLT_VAL_NX90_io_config3_sel_gpio2           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio2        0x00000000U
#define MSK_NX90_io_config3_sel_gpio3                0x00000008U
#define SRT_NX90_io_config3_sel_gpio3                3
#define DFLT_VAL_NX90_io_config3_sel_gpio3           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio3        0x00000000U
#define MSK_NX90_io_config3_sel_gpio4                0x00000010U
#define SRT_NX90_io_config3_sel_gpio4                4
#define DFLT_VAL_NX90_io_config3_sel_gpio4           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio4        0x00000000U
#define MSK_NX90_io_config3_sel_gpio5                0x00000020U
#define SRT_NX90_io_config3_sel_gpio5                5
#define DFLT_VAL_NX90_io_config3_sel_gpio5           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio5        0x00000000U
#define MSK_NX90_io_config3_sel_gpio6                0x00000040U
#define SRT_NX90_io_config3_sel_gpio6                6
#define DFLT_VAL_NX90_io_config3_sel_gpio6           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio6        0x00000000U
#define MSK_NX90_io_config3_sel_gpio7                0x00000080U
#define SRT_NX90_io_config3_sel_gpio7                7
#define DFLT_VAL_NX90_io_config3_sel_gpio7           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_gpio7        0x00000000U
#define MSK_NX90_io_config3_sel_endat0               0x00000100U
#define SRT_NX90_io_config3_sel_endat0               8
#define DFLT_VAL_NX90_io_config3_sel_endat0          0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_endat0       0x00000000U
#define MSK_NX90_io_config3_sel_endat0_devel         0x00000200U
#define SRT_NX90_io_config3_sel_endat0_devel         9
#define DFLT_VAL_NX90_io_config3_sel_endat0_devel    0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_endat0_devel 0x00000000U
#define MSK_NX90_io_config3_sel_endat1               0x00000400U
#define SRT_NX90_io_config3_sel_endat1               10
#define DFLT_VAL_NX90_io_config3_sel_endat1          0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_endat1       0x00000000U
#define MSK_NX90_io_config3_sel_endat1_devel         0x00000800U
#define SRT_NX90_io_config3_sel_endat1_devel         11
#define DFLT_VAL_NX90_io_config3_sel_endat1_devel    0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_endat1_devel 0x00000000U
#define MSK_NX90_io_config3_sel_biss0                0x00001000U
#define SRT_NX90_io_config3_sel_biss0                12
#define DFLT_VAL_NX90_io_config3_sel_biss0           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_biss0        0x00000000U
#define MSK_NX90_io_config3_sel_biss0_mo             0x00002000U
#define SRT_NX90_io_config3_sel_biss0_mo             13
#define DFLT_VAL_NX90_io_config3_sel_biss0_mo        0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_biss0_mo     0x00000000U
#define MSK_NX90_io_config3_sel_biss1                0x00004000U
#define SRT_NX90_io_config3_sel_biss1                14
#define DFLT_VAL_NX90_io_config3_sel_biss1           0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_biss1        0x00000000U
#define MSK_NX90_io_config3_sel_biss1_mo             0x00008000U
#define SRT_NX90_io_config3_sel_biss1_mo             15
#define DFLT_VAL_NX90_io_config3_sel_biss1_mo        0x00000000U
#define DFLT_BF_VAL_NX90_io_config3_sel_biss1_mo     0x00000000U

/* all used bits of 'NX90_io_config3': */
#define MSK_USED_BITS_NX90_io_config3 0x0000ffffU

enum {
  BFW_NX90_io_config3_sel_gpio0        = 1,  /* [0] */
  BFW_NX90_io_config3_sel_gpio1        = 1,  /* [1] */
  BFW_NX90_io_config3_sel_gpio2        = 1,  /* [2] */
  BFW_NX90_io_config3_sel_gpio3        = 1,  /* [3] */
  BFW_NX90_io_config3_sel_gpio4        = 1,  /* [4] */
  BFW_NX90_io_config3_sel_gpio5        = 1,  /* [5] */
  BFW_NX90_io_config3_sel_gpio6        = 1,  /* [6] */
  BFW_NX90_io_config3_sel_gpio7        = 1,  /* [7] */
  BFW_NX90_io_config3_sel_endat0       = 1,  /* [8] */
  BFW_NX90_io_config3_sel_endat0_devel = 1,  /* [9] */
  BFW_NX90_io_config3_sel_endat1       = 1,  /* [10] */
  BFW_NX90_io_config3_sel_endat1_devel = 1,  /* [11] */
  BFW_NX90_io_config3_sel_biss0        = 1,  /* [12] */
  BFW_NX90_io_config3_sel_biss0_mo     = 1,  /* [13] */
  BFW_NX90_io_config3_sel_biss1        = 1,  /* [14] */
  BFW_NX90_io_config3_sel_biss1_mo     = 1,  /* [15] */
  BFW_NX90_io_config3_reserved1        = 16  /* [31:16] */
};

typedef struct NX90_IO_CONFIG3_BIT_Ttag {
  unsigned int sel_gpio0        : BFW_NX90_io_config3_sel_gpio0;        /* select pad for gpio0  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio1        : BFW_NX90_io_config3_sel_gpio1;        /* select pad for gpio1  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio2        : BFW_NX90_io_config3_sel_gpio2;        /* select pad for gpio2  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio3        : BFW_NX90_io_config3_sel_gpio3;        /* select pad for gpio3  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio4        : BFW_NX90_io_config3_sel_gpio4;        /* select pad for gpio4  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio5        : BFW_NX90_io_config3_sel_gpio5;        /* select pad for gpio5  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio6        : BFW_NX90_io_config3_sel_gpio6;        /* select pad for gpio6  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio7        : BFW_NX90_io_config3_sel_gpio7;        /* select pad for gpio7  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_endat0       : BFW_NX90_io_config3_sel_endat0;       /* select pads EnDAT ch 0 (s. pinning table)                                       */
  unsigned int sel_endat0_devel : BFW_NX90_io_config3_sel_endat0_devel; /* select pads EnDAT ch 0 development function (s. pinning table)                  */
                                                                        /* Note: EnDAT development function outputs are delayed by one sys-clk.            */
  unsigned int sel_endat1       : BFW_NX90_io_config3_sel_endat1;       /* select pads EnDAT ch 1 (s. pinning table)                                       */
  unsigned int sel_endat1_devel : BFW_NX90_io_config3_sel_endat1_devel; /* select pads EnDAT ch 1 development function (s. pinning table)                  */
                                                                        /* Note: EnDAT development function outputs are delayed by one sys-clk.            */
  unsigned int sel_biss0        : BFW_NX90_io_config3_sel_biss0;        /* select pads BISS ch 0 (s. pinning table)                                        */
  unsigned int sel_biss0_mo     : BFW_NX90_io_config3_sel_biss0_mo;     /* select pad BISS ch 0 MO (s. pinning table)                                      */
  unsigned int sel_biss1        : BFW_NX90_io_config3_sel_biss1;        /* select pads BISS ch 1 (s. pinning table)                                        */
  unsigned int sel_biss1_mo     : BFW_NX90_io_config3_sel_biss1_mo;     /* select pad BISS ch 1 MO (s. pinning table)                                      */
  unsigned int reserved1        : BFW_NX90_io_config3_reserved1;        /* reserved                                                                        */
} NX90_IO_CONFIG3_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG3_BIT_T bf;
} NX90_IO_CONFIG3_T;

/* --------------------------------------------------------------------- */
/* Register io_config3_mask */
/* => IO Config3 Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config3 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config3_mask       0x0000001CU
#define Adr_NX90_asic_ctrl_io_config3_mask 0xFF40121CU
#define Adr_NX90_io_config3_mask           0xFF40121CU
#define DFLT_VAL_NX90_io_config3_mask      0x0000ffffU

#define MSK_NX90_io_config3_mask_sel_gpio0                0x00000001U
#define SRT_NX90_io_config3_mask_sel_gpio0                0
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio0           0x00000001U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio0        0x00000001U
#define MSK_NX90_io_config3_mask_sel_gpio1                0x00000002U
#define SRT_NX90_io_config3_mask_sel_gpio1                1
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio1           0x00000002U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio1        0x00000001U
#define MSK_NX90_io_config3_mask_sel_gpio2                0x00000004U
#define SRT_NX90_io_config3_mask_sel_gpio2                2
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio2           0x00000004U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio2        0x00000001U
#define MSK_NX90_io_config3_mask_sel_gpio3                0x00000008U
#define SRT_NX90_io_config3_mask_sel_gpio3                3
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio3           0x00000008U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio3        0x00000001U
#define MSK_NX90_io_config3_mask_sel_gpio4                0x00000010U
#define SRT_NX90_io_config3_mask_sel_gpio4                4
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio4           0x00000010U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio4        0x00000001U
#define MSK_NX90_io_config3_mask_sel_gpio5                0x00000020U
#define SRT_NX90_io_config3_mask_sel_gpio5                5
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio5           0x00000020U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio5        0x00000001U
#define MSK_NX90_io_config3_mask_sel_gpio6                0x00000040U
#define SRT_NX90_io_config3_mask_sel_gpio6                6
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio6           0x00000040U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio6        0x00000001U
#define MSK_NX90_io_config3_mask_sel_gpio7                0x00000080U
#define SRT_NX90_io_config3_mask_sel_gpio7                7
#define DFLT_VAL_NX90_io_config3_mask_sel_gpio7           0x00000080U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_gpio7        0x00000001U
#define MSK_NX90_io_config3_mask_sel_endat0               0x00000100U
#define SRT_NX90_io_config3_mask_sel_endat0               8
#define DFLT_VAL_NX90_io_config3_mask_sel_endat0          0x00000100U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_endat0       0x00000001U
#define MSK_NX90_io_config3_mask_sel_endat0_devel         0x00000200U
#define SRT_NX90_io_config3_mask_sel_endat0_devel         9
#define DFLT_VAL_NX90_io_config3_mask_sel_endat0_devel    0x00000200U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_endat0_devel 0x00000001U
#define MSK_NX90_io_config3_mask_sel_endat1               0x00000400U
#define SRT_NX90_io_config3_mask_sel_endat1               10
#define DFLT_VAL_NX90_io_config3_mask_sel_endat1          0x00000400U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_endat1       0x00000001U
#define MSK_NX90_io_config3_mask_sel_endat1_devel         0x00000800U
#define SRT_NX90_io_config3_mask_sel_endat1_devel         11
#define DFLT_VAL_NX90_io_config3_mask_sel_endat1_devel    0x00000800U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_endat1_devel 0x00000001U
#define MSK_NX90_io_config3_mask_sel_biss0                0x00001000U
#define SRT_NX90_io_config3_mask_sel_biss0                12
#define DFLT_VAL_NX90_io_config3_mask_sel_biss0           0x00001000U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_biss0        0x00000001U
#define MSK_NX90_io_config3_mask_sel_biss0_mo             0x00002000U
#define SRT_NX90_io_config3_mask_sel_biss0_mo             13
#define DFLT_VAL_NX90_io_config3_mask_sel_biss0_mo        0x00002000U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_biss0_mo     0x00000001U
#define MSK_NX90_io_config3_mask_sel_biss1                0x00004000U
#define SRT_NX90_io_config3_mask_sel_biss1                14
#define DFLT_VAL_NX90_io_config3_mask_sel_biss1           0x00004000U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_biss1        0x00000001U
#define MSK_NX90_io_config3_mask_sel_biss1_mo             0x00008000U
#define SRT_NX90_io_config3_mask_sel_biss1_mo             15
#define DFLT_VAL_NX90_io_config3_mask_sel_biss1_mo        0x00008000U
#define DFLT_BF_VAL_NX90_io_config3_mask_sel_biss1_mo     0x00000001U

/* all used bits of 'NX90_io_config3_mask': */
#define MSK_USED_BITS_NX90_io_config3_mask 0x0000ffffU

enum {
  BFW_NX90_io_config3_mask_sel_gpio0        = 1,  /* [0] */
  BFW_NX90_io_config3_mask_sel_gpio1        = 1,  /* [1] */
  BFW_NX90_io_config3_mask_sel_gpio2        = 1,  /* [2] */
  BFW_NX90_io_config3_mask_sel_gpio3        = 1,  /* [3] */
  BFW_NX90_io_config3_mask_sel_gpio4        = 1,  /* [4] */
  BFW_NX90_io_config3_mask_sel_gpio5        = 1,  /* [5] */
  BFW_NX90_io_config3_mask_sel_gpio6        = 1,  /* [6] */
  BFW_NX90_io_config3_mask_sel_gpio7        = 1,  /* [7] */
  BFW_NX90_io_config3_mask_sel_endat0       = 1,  /* [8] */
  BFW_NX90_io_config3_mask_sel_endat0_devel = 1,  /* [9] */
  BFW_NX90_io_config3_mask_sel_endat1       = 1,  /* [10] */
  BFW_NX90_io_config3_mask_sel_endat1_devel = 1,  /* [11] */
  BFW_NX90_io_config3_mask_sel_biss0        = 1,  /* [12] */
  BFW_NX90_io_config3_mask_sel_biss0_mo     = 1,  /* [13] */
  BFW_NX90_io_config3_mask_sel_biss1        = 1,  /* [14] */
  BFW_NX90_io_config3_mask_sel_biss1_mo     = 1,  /* [15] */
  BFW_NX90_io_config3_mask_reserved1        = 16  /* [31:16] */
};

typedef struct NX90_IO_CONFIG3_MASK_BIT_Ttag {
  unsigned int sel_gpio0        : BFW_NX90_io_config3_mask_sel_gpio0;        /* select pad for gpio0  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio1        : BFW_NX90_io_config3_mask_sel_gpio1;        /* select pad for gpio1  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio2        : BFW_NX90_io_config3_mask_sel_gpio2;        /* select pad for gpio2  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio3        : BFW_NX90_io_config3_mask_sel_gpio3;        /* select pad for gpio3  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio4        : BFW_NX90_io_config3_mask_sel_gpio4;        /* select pad for gpio4  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio5        : BFW_NX90_io_config3_mask_sel_gpio5;        /* select pad for gpio5  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio6        : BFW_NX90_io_config3_mask_sel_gpio6;        /* select pad for gpio6  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_gpio7        : BFW_NX90_io_config3_mask_sel_gpio7;        /* select pad for gpio7  (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_endat0       : BFW_NX90_io_config3_mask_sel_endat0;       /* select pads EnDAT ch 0 (s. pinning table)                                       */
  unsigned int sel_endat0_devel : BFW_NX90_io_config3_mask_sel_endat0_devel; /* select pads EnDAT ch 0 development function (s. pinning table)                  */
  unsigned int sel_endat1       : BFW_NX90_io_config3_mask_sel_endat1;       /* select pads EnDAT ch 1 (s. pinning table)                                       */
  unsigned int sel_endat1_devel : BFW_NX90_io_config3_mask_sel_endat1_devel; /* select pads EnDAT ch 1 development function (s. pinning table)                  */
  unsigned int sel_biss0        : BFW_NX90_io_config3_mask_sel_biss0;        /* select pads BISS ch 0 (s. pinning table)                                        */
  unsigned int sel_biss0_mo     : BFW_NX90_io_config3_mask_sel_biss0_mo;     /* select pad BISS ch 0 MO (s. pinning table)                                      */
  unsigned int sel_biss1        : BFW_NX90_io_config3_mask_sel_biss1;        /* select pads BISS ch 1 (s. pinning table)                                        */
  unsigned int sel_biss1_mo     : BFW_NX90_io_config3_mask_sel_biss1_mo;     /* select pad BISS ch 1 MO (s. pinning table)                                      */
  unsigned int reserved1        : BFW_NX90_io_config3_mask_reserved1;        /* reserved                                                                        */
} NX90_IO_CONFIG3_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG3_MASK_BIT_T bf;
} NX90_IO_CONFIG3_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config4 */
/* => IO Config4 Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Changes will only have effect if according bit in io_config4_mask-register is set. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config4       0x00000020U
#define Adr_NX90_asic_ctrl_io_config4 0xFF401220U
#define Adr_NX90_io_config4           0xFF401220U
#define DFLT_VAL_NX90_io_config4      0x00000000U

#define MSK_NX90_io_config4_sel_i2c_app                     0x00000001U
#define SRT_NX90_io_config4_sel_i2c_app                     0
#define DFLT_VAL_NX90_io_config4_sel_i2c_app                0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_i2c_app             0x00000000U
#define MSK_NX90_io_config4_sel_uart_app                    0x00000002U
#define SRT_NX90_io_config4_sel_uart_app                    1
#define DFLT_VAL_NX90_io_config4_sel_uart_app               0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_uart_app            0x00000000U
#define MSK_NX90_io_config4_sel_uart_app_rctsn              0x00000004U
#define SRT_NX90_io_config4_sel_uart_app_rctsn              2
#define DFLT_VAL_NX90_io_config4_sel_uart_app_rctsn         0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_uart_app_rctsn      0x00000000U
#define MSK_NX90_io_config4_sel_uart_xpic_app               0x00000008U
#define SRT_NX90_io_config4_sel_uart_xpic_app               3
#define DFLT_VAL_NX90_io_config4_sel_uart_xpic_app          0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_uart_xpic_app       0x00000000U
#define MSK_NX90_io_config4_sel_uart_xpic_app_rctsn         0x00000010U
#define SRT_NX90_io_config4_sel_uart_xpic_app_rctsn         4
#define DFLT_VAL_NX90_io_config4_sel_uart_xpic_app_rctsn    0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_uart_xpic_app_rctsn 0x00000000U
#define MSK_NX90_io_config4_sel_spi0_app                    0x00000020U
#define SRT_NX90_io_config4_sel_spi0_app                    5
#define DFLT_VAL_NX90_io_config4_sel_spi0_app               0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_spi0_app            0x00000000U
#define MSK_NX90_io_config4_sel_spi0_app_cs1                0x00000040U
#define SRT_NX90_io_config4_sel_spi0_app_cs1                6
#define DFLT_VAL_NX90_io_config4_sel_spi0_app_cs1           0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_spi0_app_cs1        0x00000000U
#define MSK_NX90_io_config4_sel_spi2_app                    0x00000080U
#define SRT_NX90_io_config4_sel_spi2_app                    7
#define DFLT_VAL_NX90_io_config4_sel_spi2_app               0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_spi2_app            0x00000000U
#define MSK_NX90_io_config4_sel_spi2_app_cs1                0x00000100U
#define SRT_NX90_io_config4_sel_spi2_app_cs1                8
#define DFLT_VAL_NX90_io_config4_sel_spi2_app_cs1           0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_spi2_app_cs1        0x00000000U
#define MSK_NX90_io_config4_sel_spi2_app_cs2                0x00000200U
#define SRT_NX90_io_config4_sel_spi2_app_cs2                9
#define DFLT_VAL_NX90_io_config4_sel_spi2_app_cs2           0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_spi2_app_cs2        0x00000000U
#define MSK_NX90_io_config4_sel_can0_app                    0x00000400U
#define SRT_NX90_io_config4_sel_can0_app                    10
#define DFLT_VAL_NX90_io_config4_sel_can0_app               0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_can0_app            0x00000000U
#define MSK_NX90_io_config4_sel_can1_app                    0x00000800U
#define SRT_NX90_io_config4_sel_can1_app                    11
#define DFLT_VAL_NX90_io_config4_sel_can1_app               0x00000000U
#define DFLT_BF_VAL_NX90_io_config4_sel_can1_app            0x00000000U

/* all used bits of 'NX90_io_config4': */
#define MSK_USED_BITS_NX90_io_config4 0x00000fffU

enum {
  BFW_NX90_io_config4_sel_i2c_app             = 1,  /* [0] */
  BFW_NX90_io_config4_sel_uart_app            = 1,  /* [1] */
  BFW_NX90_io_config4_sel_uart_app_rctsn      = 1,  /* [2] */
  BFW_NX90_io_config4_sel_uart_xpic_app       = 1,  /* [3] */
  BFW_NX90_io_config4_sel_uart_xpic_app_rctsn = 1,  /* [4] */
  BFW_NX90_io_config4_sel_spi0_app            = 1,  /* [5] */
  BFW_NX90_io_config4_sel_spi0_app_cs1        = 1,  /* [6] */
  BFW_NX90_io_config4_sel_spi2_app            = 1,  /* [7] */
  BFW_NX90_io_config4_sel_spi2_app_cs1        = 1,  /* [8] */
  BFW_NX90_io_config4_sel_spi2_app_cs2        = 1,  /* [9] */
  BFW_NX90_io_config4_sel_can0_app            = 1,  /* [10] */
  BFW_NX90_io_config4_sel_can1_app            = 1,  /* [11] */
  BFW_NX90_io_config4_reserved1               = 20  /* [31:12] */
};

typedef struct NX90_IO_CONFIG4_BIT_Ttag {
  unsigned int sel_i2c_app             : BFW_NX90_io_config4_sel_i2c_app;             /* select pads for i2c_app (s. pinning table) and deactivate this function via MMIOs                       */
  unsigned int sel_uart_app            : BFW_NX90_io_config4_sel_uart_app;            /* select pads for uart_app (s. pinning table) and deactivate this function via MMIOs                      */
  unsigned int sel_uart_app_rctsn      : BFW_NX90_io_config4_sel_uart_app_rctsn;      /* select pads for uart_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs      */
  unsigned int sel_uart_xpic_app       : BFW_NX90_io_config4_sel_uart_xpic_app;       /* select pads for uart_xpic_app (s. pinning table) and deactivate this function via MMIOs                 */
  unsigned int sel_uart_xpic_app_rctsn : BFW_NX90_io_config4_sel_uart_xpic_app_rctsn; /* select pads for uart_xpic_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_spi0_app            : BFW_NX90_io_config4_sel_spi0_app;            /* select pads for spi0_app (s. pinning table) and deactivate this function via MMIOs                      */
  unsigned int sel_spi0_app_cs1        : BFW_NX90_io_config4_sel_spi0_app_cs1;        /* select pad for 2nd chip select of spi0_app (s. pinning table)                                           */
  unsigned int sel_spi2_app            : BFW_NX90_io_config4_sel_spi2_app;            /* select pads for spi2_app (s. pinning table) and deactivate this function via MMIOs                      */
  unsigned int sel_spi2_app_cs1        : BFW_NX90_io_config4_sel_spi2_app_cs1;        /* select pad for 2nd chip select of spi2_app (s. pinning table)                                           */
  unsigned int sel_spi2_app_cs2        : BFW_NX90_io_config4_sel_spi2_app_cs2;        /* select pad for 3rd chip select of spi2_app (s. pinning table)                                           */
  unsigned int sel_can0_app            : BFW_NX90_io_config4_sel_can0_app;            /* select pad for can0_app (s. pinning table) and deactivate this function via MMIOs                       */
  unsigned int sel_can1_app            : BFW_NX90_io_config4_sel_can1_app;            /* select pad for can1_app (s. pinning table) and deactivate this function via MMIOs                       */
  unsigned int reserved1               : BFW_NX90_io_config4_reserved1;               /* reserved                                                                                                */
} NX90_IO_CONFIG4_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG4_BIT_T bf;
} NX90_IO_CONFIG4_T;

/* --------------------------------------------------------------------- */
/* Register io_config4_mask */
/* => IO Config4 Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config4 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config4_mask       0x00000024U
#define Adr_NX90_asic_ctrl_io_config4_mask 0xFF401224U
#define Adr_NX90_io_config4_mask           0xFF401224U
#define DFLT_VAL_NX90_io_config4_mask      0x00000fffU

#define MSK_NX90_io_config4_mask_sel_i2c_app                     0x00000001U
#define SRT_NX90_io_config4_mask_sel_i2c_app                     0
#define DFLT_VAL_NX90_io_config4_mask_sel_i2c_app                0x00000001U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_i2c_app             0x00000001U
#define MSK_NX90_io_config4_mask_sel_uart_app                    0x00000002U
#define SRT_NX90_io_config4_mask_sel_uart_app                    1
#define DFLT_VAL_NX90_io_config4_mask_sel_uart_app               0x00000002U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_uart_app            0x00000001U
#define MSK_NX90_io_config4_mask_sel_uart_app_rctsn              0x00000004U
#define SRT_NX90_io_config4_mask_sel_uart_app_rctsn              2
#define DFLT_VAL_NX90_io_config4_mask_sel_uart_app_rctsn         0x00000004U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_uart_app_rctsn      0x00000001U
#define MSK_NX90_io_config4_mask_sel_uart_xpic_app               0x00000008U
#define SRT_NX90_io_config4_mask_sel_uart_xpic_app               3
#define DFLT_VAL_NX90_io_config4_mask_sel_uart_xpic_app          0x00000008U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_uart_xpic_app       0x00000001U
#define MSK_NX90_io_config4_mask_sel_uart_xpic_app_rctsn         0x00000010U
#define SRT_NX90_io_config4_mask_sel_uart_xpic_app_rctsn         4
#define DFLT_VAL_NX90_io_config4_mask_sel_uart_xpic_app_rctsn    0x00000010U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_uart_xpic_app_rctsn 0x00000001U
#define MSK_NX90_io_config4_mask_sel_spi0_app                    0x00000020U
#define SRT_NX90_io_config4_mask_sel_spi0_app                    5
#define DFLT_VAL_NX90_io_config4_mask_sel_spi0_app               0x00000020U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_spi0_app            0x00000001U
#define MSK_NX90_io_config4_mask_sel_spi0_app_cs1                0x00000040U
#define SRT_NX90_io_config4_mask_sel_spi0_app_cs1                6
#define DFLT_VAL_NX90_io_config4_mask_sel_spi0_app_cs1           0x00000040U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_spi0_app_cs1        0x00000001U
#define MSK_NX90_io_config4_mask_sel_spi2_app                    0x00000080U
#define SRT_NX90_io_config4_mask_sel_spi2_app                    7
#define DFLT_VAL_NX90_io_config4_mask_sel_spi2_app               0x00000080U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_spi2_app            0x00000001U
#define MSK_NX90_io_config4_mask_sel_spi2_app_cs1                0x00000100U
#define SRT_NX90_io_config4_mask_sel_spi2_app_cs1                8
#define DFLT_VAL_NX90_io_config4_mask_sel_spi2_app_cs1           0x00000100U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_spi2_app_cs1        0x00000001U
#define MSK_NX90_io_config4_mask_sel_spi2_app_cs2                0x00000200U
#define SRT_NX90_io_config4_mask_sel_spi2_app_cs2                9
#define DFLT_VAL_NX90_io_config4_mask_sel_spi2_app_cs2           0x00000200U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_spi2_app_cs2        0x00000001U
#define MSK_NX90_io_config4_mask_sel_can0_app                    0x00000400U
#define SRT_NX90_io_config4_mask_sel_can0_app                    10
#define DFLT_VAL_NX90_io_config4_mask_sel_can0_app               0x00000400U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_can0_app            0x00000001U
#define MSK_NX90_io_config4_mask_sel_can1_app                    0x00000800U
#define SRT_NX90_io_config4_mask_sel_can1_app                    11
#define DFLT_VAL_NX90_io_config4_mask_sel_can1_app               0x00000800U
#define DFLT_BF_VAL_NX90_io_config4_mask_sel_can1_app            0x00000001U

/* all used bits of 'NX90_io_config4_mask': */
#define MSK_USED_BITS_NX90_io_config4_mask 0x00000fffU

enum {
  BFW_NX90_io_config4_mask_sel_i2c_app             = 1,  /* [0] */
  BFW_NX90_io_config4_mask_sel_uart_app            = 1,  /* [1] */
  BFW_NX90_io_config4_mask_sel_uart_app_rctsn      = 1,  /* [2] */
  BFW_NX90_io_config4_mask_sel_uart_xpic_app       = 1,  /* [3] */
  BFW_NX90_io_config4_mask_sel_uart_xpic_app_rctsn = 1,  /* [4] */
  BFW_NX90_io_config4_mask_sel_spi0_app            = 1,  /* [5] */
  BFW_NX90_io_config4_mask_sel_spi0_app_cs1        = 1,  /* [6] */
  BFW_NX90_io_config4_mask_sel_spi2_app            = 1,  /* [7] */
  BFW_NX90_io_config4_mask_sel_spi2_app_cs1        = 1,  /* [8] */
  BFW_NX90_io_config4_mask_sel_spi2_app_cs2        = 1,  /* [9] */
  BFW_NX90_io_config4_mask_sel_can0_app            = 1,  /* [10] */
  BFW_NX90_io_config4_mask_sel_can1_app            = 1,  /* [11] */
  BFW_NX90_io_config4_mask_reserved1               = 20  /* [31:12] */
};

typedef struct NX90_IO_CONFIG4_MASK_BIT_Ttag {
  unsigned int sel_i2c_app             : BFW_NX90_io_config4_mask_sel_i2c_app;             /* select pads for i2c_app (s. pinning table) and deactivate this function via MMIOs                       */
  unsigned int sel_uart_app            : BFW_NX90_io_config4_mask_sel_uart_app;            /* select pads for uart_app (s. pinning table) and deactivate this function via MMIOs                      */
  unsigned int sel_uart_app_rctsn      : BFW_NX90_io_config4_mask_sel_uart_app_rctsn;      /* select pads for uart_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs      */
  unsigned int sel_uart_xpic_app       : BFW_NX90_io_config4_mask_sel_uart_xpic_app;       /* select pads for uart_xpic_app (s. pinning table) and deactivate this function via MMIOs                 */
  unsigned int sel_uart_xpic_app_rctsn : BFW_NX90_io_config4_mask_sel_uart_xpic_app_rctsn; /* select pads for uart_xpic_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs */
  unsigned int sel_spi0_app            : BFW_NX90_io_config4_mask_sel_spi0_app;            /* select pads for spi0_app (s. pinning table) and deactivate this function via MMIOs                      */
  unsigned int sel_spi0_app_cs1        : BFW_NX90_io_config4_mask_sel_spi0_app_cs1;        /* select pad for 2nd chip select of spi0_app (s. pinning table)                                           */
  unsigned int sel_spi2_app            : BFW_NX90_io_config4_mask_sel_spi2_app;            /* select pads for spi2_app (s. pinning table) and deactivate this function via MMIOs                      */
  unsigned int sel_spi2_app_cs1        : BFW_NX90_io_config4_mask_sel_spi2_app_cs1;        /* select pad for 2nd chip select of spi2_app (s. pinning table)                                           */
  unsigned int sel_spi2_app_cs2        : BFW_NX90_io_config4_mask_sel_spi2_app_cs2;        /* select pad for 3rd chip select of spi2_app (s. pinning table)                                           */
  unsigned int sel_can0_app            : BFW_NX90_io_config4_mask_sel_can0_app;            /* select pad for can0_app (s. pinning table) and deactivate this function via MMIOs                       */
  unsigned int sel_can1_app            : BFW_NX90_io_config4_mask_sel_can1_app;            /* select pad for can1_app (s. pinning table) and deactivate this function via MMIOs                       */
  unsigned int reserved1               : BFW_NX90_io_config4_mask_reserved1;               /* reserved                                                                                                */
} NX90_IO_CONFIG4_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG4_MASK_BIT_T bf;
} NX90_IO_CONFIG4_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config5 */
/* => IO Config5 Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Changes will only have effect if according bit in io_config5_mask-register is set. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config5       0x00000028U
#define Adr_NX90_asic_ctrl_io_config5 0xFF401228U
#define Adr_NX90_io_config5           0xFF401228U
#define DFLT_VAL_NX90_io_config5      0x00000000U

#define MSK_NX90_io_config5_sel_pio_app         0x000000ffU
#define SRT_NX90_io_config5_sel_pio_app         0
#define DFLT_VAL_NX90_io_config5_sel_pio_app    0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_pio_app 0x00000000U
#define MSK_NX90_io_config5_sel_mled4           0x00000100U
#define SRT_NX90_io_config5_sel_mled4           8
#define DFLT_VAL_NX90_io_config5_sel_mled4      0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled4   0x00000000U
#define MSK_NX90_io_config5_sel_mled5           0x00000200U
#define SRT_NX90_io_config5_sel_mled5           9
#define DFLT_VAL_NX90_io_config5_sel_mled5      0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled5   0x00000000U
#define MSK_NX90_io_config5_sel_mled6           0x00000400U
#define SRT_NX90_io_config5_sel_mled6           10
#define DFLT_VAL_NX90_io_config5_sel_mled6      0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled6   0x00000000U
#define MSK_NX90_io_config5_sel_mled7           0x00000800U
#define SRT_NX90_io_config5_sel_mled7           11
#define DFLT_VAL_NX90_io_config5_sel_mled7      0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled7   0x00000000U
#define MSK_NX90_io_config5_sel_mled8           0x00001000U
#define SRT_NX90_io_config5_sel_mled8           12
#define DFLT_VAL_NX90_io_config5_sel_mled8      0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled8   0x00000000U
#define MSK_NX90_io_config5_sel_mled9           0x00002000U
#define SRT_NX90_io_config5_sel_mled9           13
#define DFLT_VAL_NX90_io_config5_sel_mled9      0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled9   0x00000000U
#define MSK_NX90_io_config5_sel_mled10          0x00004000U
#define SRT_NX90_io_config5_sel_mled10          14
#define DFLT_VAL_NX90_io_config5_sel_mled10     0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled10  0x00000000U
#define MSK_NX90_io_config5_sel_mled11          0x00008000U
#define SRT_NX90_io_config5_sel_mled11          15
#define DFLT_VAL_NX90_io_config5_sel_mled11     0x00000000U
#define DFLT_BF_VAL_NX90_io_config5_sel_mled11  0x00000000U

/* all used bits of 'NX90_io_config5': */
#define MSK_USED_BITS_NX90_io_config5 0x0000ffffU

enum {
  BFW_NX90_io_config5_sel_pio_app = 8,  /* [7:0] */
  BFW_NX90_io_config5_sel_mled4   = 1,  /* [8] */
  BFW_NX90_io_config5_sel_mled5   = 1,  /* [9] */
  BFW_NX90_io_config5_sel_mled6   = 1,  /* [10] */
  BFW_NX90_io_config5_sel_mled7   = 1,  /* [11] */
  BFW_NX90_io_config5_sel_mled8   = 1,  /* [12] */
  BFW_NX90_io_config5_sel_mled9   = 1,  /* [13] */
  BFW_NX90_io_config5_sel_mled10  = 1,  /* [14] */
  BFW_NX90_io_config5_sel_mled11  = 1,  /* [15] */
  BFW_NX90_io_config5_reserved1   = 16  /* [31:16] */
};

typedef struct NX90_IO_CONFIG5_BIT_Ttag {
  unsigned int sel_pio_app : BFW_NX90_io_config5_sel_pio_app; /* select pads for pio_app (s. pinning table) */
  unsigned int sel_mled4   : BFW_NX90_io_config5_sel_mled4;   /* select pad for mled4 (s. pinning table)    */
  unsigned int sel_mled5   : BFW_NX90_io_config5_sel_mled5;   /* select pad for mled5 (s. pinning table)    */
  unsigned int sel_mled6   : BFW_NX90_io_config5_sel_mled6;   /* select pad for mled6 (s. pinning table)    */
  unsigned int sel_mled7   : BFW_NX90_io_config5_sel_mled7;   /* select pad for mled7 (s. pinning table)    */
  unsigned int sel_mled8   : BFW_NX90_io_config5_sel_mled8;   /* select pad for mled8 (s. pinning table)    */
  unsigned int sel_mled9   : BFW_NX90_io_config5_sel_mled9;   /* select pad for mled9 (s. pinning table)    */
  unsigned int sel_mled10  : BFW_NX90_io_config5_sel_mled10;  /* select pad for mled10 (s. pinning table)   */
  unsigned int sel_mled11  : BFW_NX90_io_config5_sel_mled11;  /* select pad for mled11 (s. pinning table)   */
  unsigned int reserved1   : BFW_NX90_io_config5_reserved1;   /* reserved                                   */
} NX90_IO_CONFIG5_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG5_BIT_T bf;
} NX90_IO_CONFIG5_T;

/* --------------------------------------------------------------------- */
/* Register io_config5_mask */
/* => IO Config5 Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config5 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config5_mask       0x0000002CU
#define Adr_NX90_asic_ctrl_io_config5_mask 0xFF40122CU
#define Adr_NX90_io_config5_mask           0xFF40122CU
#define DFLT_VAL_NX90_io_config5_mask      0x0000ffffU

#define MSK_NX90_io_config5_mask_sel_pio_app         0x000000ffU
#define SRT_NX90_io_config5_mask_sel_pio_app         0
#define DFLT_VAL_NX90_io_config5_mask_sel_pio_app    0x000000ffU
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_pio_app 0x000000ffU
#define MSK_NX90_io_config5_mask_sel_mled4           0x00000100U
#define SRT_NX90_io_config5_mask_sel_mled4           8
#define DFLT_VAL_NX90_io_config5_mask_sel_mled4      0x00000100U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled4   0x00000001U
#define MSK_NX90_io_config5_mask_sel_mled5           0x00000200U
#define SRT_NX90_io_config5_mask_sel_mled5           9
#define DFLT_VAL_NX90_io_config5_mask_sel_mled5      0x00000200U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled5   0x00000001U
#define MSK_NX90_io_config5_mask_sel_mled6           0x00000400U
#define SRT_NX90_io_config5_mask_sel_mled6           10
#define DFLT_VAL_NX90_io_config5_mask_sel_mled6      0x00000400U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled6   0x00000001U
#define MSK_NX90_io_config5_mask_sel_mled7           0x00000800U
#define SRT_NX90_io_config5_mask_sel_mled7           11
#define DFLT_VAL_NX90_io_config5_mask_sel_mled7      0x00000800U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled7   0x00000001U
#define MSK_NX90_io_config5_mask_sel_mled8           0x00001000U
#define SRT_NX90_io_config5_mask_sel_mled8           12
#define DFLT_VAL_NX90_io_config5_mask_sel_mled8      0x00001000U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled8   0x00000001U
#define MSK_NX90_io_config5_mask_sel_mled9           0x00002000U
#define SRT_NX90_io_config5_mask_sel_mled9           13
#define DFLT_VAL_NX90_io_config5_mask_sel_mled9      0x00002000U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled9   0x00000001U
#define MSK_NX90_io_config5_mask_sel_mled10          0x00004000U
#define SRT_NX90_io_config5_mask_sel_mled10          14
#define DFLT_VAL_NX90_io_config5_mask_sel_mled10     0x00004000U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled10  0x00000001U
#define MSK_NX90_io_config5_mask_sel_mled11          0x00008000U
#define SRT_NX90_io_config5_mask_sel_mled11          15
#define DFLT_VAL_NX90_io_config5_mask_sel_mled11     0x00008000U
#define DFLT_BF_VAL_NX90_io_config5_mask_sel_mled11  0x00000001U

/* all used bits of 'NX90_io_config5_mask': */
#define MSK_USED_BITS_NX90_io_config5_mask 0x0000ffffU

enum {
  BFW_NX90_io_config5_mask_sel_pio_app = 8,  /* [7:0] */
  BFW_NX90_io_config5_mask_sel_mled4   = 1,  /* [8] */
  BFW_NX90_io_config5_mask_sel_mled5   = 1,  /* [9] */
  BFW_NX90_io_config5_mask_sel_mled6   = 1,  /* [10] */
  BFW_NX90_io_config5_mask_sel_mled7   = 1,  /* [11] */
  BFW_NX90_io_config5_mask_sel_mled8   = 1,  /* [12] */
  BFW_NX90_io_config5_mask_sel_mled9   = 1,  /* [13] */
  BFW_NX90_io_config5_mask_sel_mled10  = 1,  /* [14] */
  BFW_NX90_io_config5_mask_sel_mled11  = 1,  /* [15] */
  BFW_NX90_io_config5_mask_reserved1   = 16  /* [31:16] */
};

typedef struct NX90_IO_CONFIG5_MASK_BIT_Ttag {
  unsigned int sel_pio_app : BFW_NX90_io_config5_mask_sel_pio_app; /* select pads for pio_app (s. pinning table) */
  unsigned int sel_mled4   : BFW_NX90_io_config5_mask_sel_mled4;   /* select pad for mled4 (s. pinning table)    */
  unsigned int sel_mled5   : BFW_NX90_io_config5_mask_sel_mled5;   /* select pad for mled5 (s. pinning table)    */
  unsigned int sel_mled6   : BFW_NX90_io_config5_mask_sel_mled6;   /* select pad for mled6 (s. pinning table)    */
  unsigned int sel_mled7   : BFW_NX90_io_config5_mask_sel_mled7;   /* select pad for mled7 (s. pinning table)    */
  unsigned int sel_mled8   : BFW_NX90_io_config5_mask_sel_mled8;   /* select pad for mled8 (s. pinning table)    */
  unsigned int sel_mled9   : BFW_NX90_io_config5_mask_sel_mled9;   /* select pad for mled9 (s. pinning table)    */
  unsigned int sel_mled10  : BFW_NX90_io_config5_mask_sel_mled10;  /* select pad for mled10 (s. pinning table)   */
  unsigned int sel_mled11  : BFW_NX90_io_config5_mask_sel_mled11;  /* select pad for mled11 (s. pinning table)   */
  unsigned int reserved1   : BFW_NX90_io_config5_mask_reserved1;   /* reserved                                   */
} NX90_IO_CONFIG5_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG5_MASK_BIT_T bf;
} NX90_IO_CONFIG5_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config6 */
/* => IO Config6 Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Changes will only have effect if according bit in io_config6_mask-register is set. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config6       0x00000030U
#define Adr_NX90_asic_ctrl_io_config6 0xFF401230U
#define Adr_NX90_io_config6           0xFF401230U
#define DFLT_VAL_NX90_io_config6      0x00000000U

#define MSK_NX90_io_config6_sel_io_link0          0x00000001U
#define SRT_NX90_io_config6_sel_io_link0          0
#define DFLT_VAL_NX90_io_config6_sel_io_link0     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link0  0x00000000U
#define MSK_NX90_io_config6_sel_io_link0b         0x00000002U
#define SRT_NX90_io_config6_sel_io_link0b         1
#define DFLT_VAL_NX90_io_config6_sel_io_link0b    0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link0b 0x00000000U
#define MSK_NX90_io_config6_sel_io_link1          0x00000004U
#define SRT_NX90_io_config6_sel_io_link1          2
#define DFLT_VAL_NX90_io_config6_sel_io_link1     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link1  0x00000000U
#define MSK_NX90_io_config6_sel_io_link1b         0x00000008U
#define SRT_NX90_io_config6_sel_io_link1b         3
#define DFLT_VAL_NX90_io_config6_sel_io_link1b    0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link1b 0x00000000U
#define MSK_NX90_io_config6_sel_io_link2          0x00000010U
#define SRT_NX90_io_config6_sel_io_link2          4
#define DFLT_VAL_NX90_io_config6_sel_io_link2     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link2  0x00000000U
#define MSK_NX90_io_config6_sel_io_link3          0x00000020U
#define SRT_NX90_io_config6_sel_io_link3          5
#define DFLT_VAL_NX90_io_config6_sel_io_link3     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link3  0x00000000U
#define MSK_NX90_io_config6_sel_io_link4          0x00000040U
#define SRT_NX90_io_config6_sel_io_link4          6
#define DFLT_VAL_NX90_io_config6_sel_io_link4     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link4  0x00000000U
#define MSK_NX90_io_config6_sel_io_link5          0x00000080U
#define SRT_NX90_io_config6_sel_io_link5          7
#define DFLT_VAL_NX90_io_config6_sel_io_link5     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link5  0x00000000U
#define MSK_NX90_io_config6_sel_io_link6          0x00000100U
#define SRT_NX90_io_config6_sel_io_link6          8
#define DFLT_VAL_NX90_io_config6_sel_io_link6     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link6  0x00000000U
#define MSK_NX90_io_config6_sel_io_link7          0x00000200U
#define SRT_NX90_io_config6_sel_io_link7          9
#define DFLT_VAL_NX90_io_config6_sel_io_link7     0x00000000U
#define DFLT_BF_VAL_NX90_io_config6_sel_io_link7  0x00000000U

/* all used bits of 'NX90_io_config6': */
#define MSK_USED_BITS_NX90_io_config6 0x000003ffU

enum {
  BFW_NX90_io_config6_sel_io_link0  = 1,  /* [0] */
  BFW_NX90_io_config6_sel_io_link0b = 1,  /* [1] */
  BFW_NX90_io_config6_sel_io_link1  = 1,  /* [2] */
  BFW_NX90_io_config6_sel_io_link1b = 1,  /* [3] */
  BFW_NX90_io_config6_sel_io_link2  = 1,  /* [4] */
  BFW_NX90_io_config6_sel_io_link3  = 1,  /* [5] */
  BFW_NX90_io_config6_sel_io_link4  = 1,  /* [6] */
  BFW_NX90_io_config6_sel_io_link5  = 1,  /* [7] */
  BFW_NX90_io_config6_sel_io_link6  = 1,  /* [8] */
  BFW_NX90_io_config6_sel_io_link7  = 1,  /* [9] */
  BFW_NX90_io_config6_reserved1     = 22  /* [31:10] */
};

typedef struct NX90_IO_CONFIG6_BIT_Ttag {
  unsigned int sel_io_link0  : BFW_NX90_io_config6_sel_io_link0;  /* select pads for IO-Link0 (s. pinning table)               */
  unsigned int sel_io_link0b : BFW_NX90_io_config6_sel_io_link0b; /* select pads for IO-Link0 at position B (s. pinning table) */
  unsigned int sel_io_link1  : BFW_NX90_io_config6_sel_io_link1;  /* select pads for IO-Link1 (s. pinning table)               */
  unsigned int sel_io_link1b : BFW_NX90_io_config6_sel_io_link1b; /* select pads for IO-Link1 at position B (s. pinning table) */
  unsigned int sel_io_link2  : BFW_NX90_io_config6_sel_io_link2;  /* select pads for IO-Link2 (s. pinning table)               */
  unsigned int sel_io_link3  : BFW_NX90_io_config6_sel_io_link3;  /* select pads for IO-Link3 (s. pinning table)               */
  unsigned int sel_io_link4  : BFW_NX90_io_config6_sel_io_link4;  /* select pads for IO-Link4 (s. pinning table)               */
  unsigned int sel_io_link5  : BFW_NX90_io_config6_sel_io_link5;  /* select pads for IO-Link5 (s. pinning table)               */
  unsigned int sel_io_link6  : BFW_NX90_io_config6_sel_io_link6;  /* select pads for IO-Link6 (s. pinning table)               */
  unsigned int sel_io_link7  : BFW_NX90_io_config6_sel_io_link7;  /* select pads for IO-Link7 (s. pinning table)               */
  unsigned int reserved1     : BFW_NX90_io_config6_reserved1;     /* reserved                                                  */
} NX90_IO_CONFIG6_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG6_BIT_T bf;
} NX90_IO_CONFIG6_T;

/* --------------------------------------------------------------------- */
/* Register io_config6_mask */
/* => IO Config6 Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config6 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config6_mask       0x00000034U
#define Adr_NX90_asic_ctrl_io_config6_mask 0xFF401234U
#define Adr_NX90_io_config6_mask           0xFF401234U
#define DFLT_VAL_NX90_io_config6_mask      0x000003ffU

#define MSK_NX90_io_config6_mask_sel_io_link0          0x00000001U
#define SRT_NX90_io_config6_mask_sel_io_link0          0
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link0     0x00000001U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link0  0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link0b         0x00000002U
#define SRT_NX90_io_config6_mask_sel_io_link0b         1
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link0b    0x00000002U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link0b 0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link1          0x00000004U
#define SRT_NX90_io_config6_mask_sel_io_link1          2
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link1     0x00000004U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link1  0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link1b         0x00000008U
#define SRT_NX90_io_config6_mask_sel_io_link1b         3
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link1b    0x00000008U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link1b 0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link2          0x00000010U
#define SRT_NX90_io_config6_mask_sel_io_link2          4
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link2     0x00000010U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link2  0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link3          0x00000020U
#define SRT_NX90_io_config6_mask_sel_io_link3          5
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link3     0x00000020U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link3  0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link4          0x00000040U
#define SRT_NX90_io_config6_mask_sel_io_link4          6
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link4     0x00000040U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link4  0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link5          0x00000080U
#define SRT_NX90_io_config6_mask_sel_io_link5          7
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link5     0x00000080U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link5  0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link6          0x00000100U
#define SRT_NX90_io_config6_mask_sel_io_link6          8
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link6     0x00000100U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link6  0x00000001U
#define MSK_NX90_io_config6_mask_sel_io_link7          0x00000200U
#define SRT_NX90_io_config6_mask_sel_io_link7          9
#define DFLT_VAL_NX90_io_config6_mask_sel_io_link7     0x00000200U
#define DFLT_BF_VAL_NX90_io_config6_mask_sel_io_link7  0x00000001U

/* all used bits of 'NX90_io_config6_mask': */
#define MSK_USED_BITS_NX90_io_config6_mask 0x000003ffU

enum {
  BFW_NX90_io_config6_mask_sel_io_link0  = 1,  /* [0] */
  BFW_NX90_io_config6_mask_sel_io_link0b = 1,  /* [1] */
  BFW_NX90_io_config6_mask_sel_io_link1  = 1,  /* [2] */
  BFW_NX90_io_config6_mask_sel_io_link1b = 1,  /* [3] */
  BFW_NX90_io_config6_mask_sel_io_link2  = 1,  /* [4] */
  BFW_NX90_io_config6_mask_sel_io_link3  = 1,  /* [5] */
  BFW_NX90_io_config6_mask_sel_io_link4  = 1,  /* [6] */
  BFW_NX90_io_config6_mask_sel_io_link5  = 1,  /* [7] */
  BFW_NX90_io_config6_mask_sel_io_link6  = 1,  /* [8] */
  BFW_NX90_io_config6_mask_sel_io_link7  = 1,  /* [9] */
  BFW_NX90_io_config6_mask_reserved1     = 22  /* [31:10] */
};

typedef struct NX90_IO_CONFIG6_MASK_BIT_Ttag {
  unsigned int sel_io_link0  : BFW_NX90_io_config6_mask_sel_io_link0;  /* select pads for IO-Link0 (s. pinning table)               */
  unsigned int sel_io_link0b : BFW_NX90_io_config6_mask_sel_io_link0b; /* select pads for IO-Link0 at position B (s. pinning table) */
  unsigned int sel_io_link1  : BFW_NX90_io_config6_mask_sel_io_link1;  /* select pads for IO-Link1 (s. pinning table)               */
  unsigned int sel_io_link1b : BFW_NX90_io_config6_mask_sel_io_link1b; /* select pads for IO-Link1 at position B (s. pinning table) */
  unsigned int sel_io_link2  : BFW_NX90_io_config6_mask_sel_io_link2;  /* select pads for IO-Link2 (s. pinning table)               */
  unsigned int sel_io_link3  : BFW_NX90_io_config6_mask_sel_io_link3;  /* select pads for IO-Link3 (s. pinning table)               */
  unsigned int sel_io_link4  : BFW_NX90_io_config6_mask_sel_io_link4;  /* select pads for IO-Link4 (s. pinning table)               */
  unsigned int sel_io_link5  : BFW_NX90_io_config6_mask_sel_io_link5;  /* select pads for IO-Link5 (s. pinning table)               */
  unsigned int sel_io_link6  : BFW_NX90_io_config6_mask_sel_io_link6;  /* select pads for IO-Link6 (s. pinning table)               */
  unsigned int sel_io_link7  : BFW_NX90_io_config6_mask_sel_io_link7;  /* select pads for IO-Link7 (s. pinning table)               */
  unsigned int reserved1     : BFW_NX90_io_config6_mask_reserved1;     /* reserved                                                  */
} NX90_IO_CONFIG6_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG6_MASK_BIT_T bf;
} NX90_IO_CONFIG6_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config7 */
/* => IO Config7 Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Changes will only have effect if according bit in io_config7_mask-register is set. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config7       0x00000038U
#define Adr_NX90_asic_ctrl_io_config7 0xFF401238U
#define Adr_NX90_io_config7           0xFF401238U
#define DFLT_VAL_NX90_io_config7      0x00000000U

#define MSK_NX90_io_config7_sel_eth_cfg          0x0000001fU
#define SRT_NX90_io_config7_sel_eth_cfg          0
#define DFLT_VAL_NX90_io_config7_sel_eth_cfg     0x00000000U
#define DFLT_BF_VAL_NX90_io_config7_sel_eth_cfg  0x00000000U
#define MSK_NX90_io_config7_sel_eth_mdio         0x00000060U
#define SRT_NX90_io_config7_sel_eth_mdio         5
#define DFLT_VAL_NX90_io_config7_sel_eth_mdio    0x00000000U
#define DFLT_BF_VAL_NX90_io_config7_sel_eth_mdio 0x00000000U
#define MSK_NX90_io_config7_sel_sqi_cs1          0x00000080U
#define SRT_NX90_io_config7_sel_sqi_cs1          7
#define DFLT_VAL_NX90_io_config7_sel_sqi_cs1     0x00000000U
#define DFLT_BF_VAL_NX90_io_config7_sel_sqi_cs1  0x00000000U
#define MSK_NX90_io_config7_sel_sqi_cs2          0x00000100U
#define SRT_NX90_io_config7_sel_sqi_cs2          8
#define DFLT_VAL_NX90_io_config7_sel_sqi_cs2     0x00000000U
#define DFLT_BF_VAL_NX90_io_config7_sel_sqi_cs2  0x00000000U

/* all used bits of 'NX90_io_config7': */
#define MSK_USED_BITS_NX90_io_config7 0x000001ffU

enum {
  BFW_NX90_io_config7_sel_eth_cfg  = 5,  /* [4:0] */
  BFW_NX90_io_config7_sel_eth_mdio = 2,  /* [6:5] */
  BFW_NX90_io_config7_sel_sqi_cs1  = 1,  /* [7] */
  BFW_NX90_io_config7_sel_sqi_cs2  = 1,  /* [8] */
  BFW_NX90_io_config7_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_IO_CONFIG7_BIT_Ttag {
  unsigned int sel_eth_cfg  : BFW_NX90_io_config7_sel_eth_cfg;  /* select connection of ETH MII pins:                                                                                                                 */
                                                                /*  0: no select                                                                                                                                      */
                                                                /*  1: select pads for ETH RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen) (s. pinning table: sel_eth_5,2,1 will be active)                             */
                                                                /*  2: select pads for ETH RX only mode (rxclk, rxd[3:0],rxdv,rxer) (s. pinning table: sel_eth_5,3,2,0 will be active)                                */
                                                                /*  3: select pads for ETH minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) (s. pinning table: sel_eth_4:1 will be active)                 */
                                                                /*  4: select also pads for ETH rxclk pin for mac mode (rxclk) (s. pinning table: sel_eth_4:0 will be active)                                         */
                                                                /*  5: select also pads for ETH RX error signal (rxer) (s. pinning table: sel_eth_5:0 will be active)                                                 */
                                                                /*  6: select also pads for ETH collision and carrier sense (col,crs) (s. pinning table: sel_eth_6:0 will be active)                                  */
                                                                /*  7: select also pads for ETH TX error signal (txer) (s. pinning table: sel_eth_7:0 will be active)                                                 */
                                                                /*  8: ETH position B: select pads for ETH RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen) (s. pinning table: sel_eth_5,2,1 will be active)             */
                                                                /*  9: ETH position B: select pads for ETH RX only mode (rxclk, rxd[3:0],rxdv,rxer) (s. pinning table: sel_eth_5,3,2,0 will be active)                */
                                                                /* 10: ETH position B: select pads for ETH minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) (s. pinning table: sel_eth_4:1 will be active) */
                                                                /* 11: ETH position B: select also pads for ETH rxclk pin for mac mode (rxclk) (s. pinning table: sel_eth_4:0 will be active)                         */
                                                                /* 12: ETH position B: select also pads for ETH RX error signal (rxer) (s. pinning table: sel_eth_5:0 will be active)                                 */
                                                                /* 13: ETH position B: select also pads for ETH collision and carrier sense (col,crs) (s. pinning table: sel_eth_6:0 will be active)                  */
                                                                /* 14: ETH position B: select also pads for ETH TX error signal (txer) (s. pinning table: sel_eth_7:0 will be active)                                 */
                                                                /* 15: connect to internal PHY0, if PHY0 not used by XMAC0 (no selects for external MII)                                                              */
                                                                /* 16: connect to internal PHY1, if PHY1 not used by XMAC1 (no selects for external MII)                                                              */
                                                                /* 17: connect to internal LVDS0, if LVDS0 not used by XMAC0 (no selects for external MII)                                                            */
                                                                /* 18: connect to internal LVDS1, if LVDS1 not used by XMAC1 (no selects for external MII)                                                            */
                                                                /* The maximum MII interface consists of 16 signals, but usually not all MII signals are necessary.                                                   */
                                                                /* Values 1..6 define combinations of reduced MII that might be use cases, while 7 is the full MII.                                                   */
                                                                /* To realize this, MII signals are combined to the following groups with appropriate select signals in pinning table:                                */
                                                                /* {      |                                                                                                                                           */
                                                                /*  0      rxclk                                                                                                                                      */
                                                                /*  1      txclk, txen, txd0, txd1                                                                                                                    */
                                                                /*  2      rxdv, rxd0, rxd1                                                                                                                           */
                                                                /*  3      rxd2, rxd3                                                                                                                                 */
                                                                /*  4      txd2, txd3                                                                                                                                 */
                                                                /*  5      rxer                                                                                                                                       */
                                                                /*  6      col, crs                                                                                                                                   */
                                                                /*  7      txer                   }                                                                                                                   */
  unsigned int sel_eth_mdio : BFW_NX90_io_config7_sel_eth_mdio; /* select connection for MIIMU MDIO interface used by ETH                                                                                             */
                                                                /* 00: connect to multiplexmatrix                                                                                                                     */
                                                                /* 01: connect to external eth_mdio position A (s pinning table sel_eth_a_mdio)                                                                       */
                                                                /* 10: connect to external MII_MDIO/MDC pins (s pinning table)                                                                                        */
                                                                /* 11: connect to internal PHY                                                                                                                        */
  unsigned int sel_sqi_cs1  : BFW_NX90_io_config7_sel_sqi_cs1;  /* select pad for 2nd chip select of sqi (s. pinning table)                                                                                           */
  unsigned int sel_sqi_cs2  : BFW_NX90_io_config7_sel_sqi_cs2;  /* select pad for 3rd chip select of sqi (s. pinning table)                                                                                           */
  unsigned int reserved1    : BFW_NX90_io_config7_reserved1;    /* reserved                                                                                                                                           */
} NX90_IO_CONFIG7_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG7_BIT_T bf;
} NX90_IO_CONFIG7_T;

/* --------------------------------------------------------------------- */
/* Register io_config7_mask */
/* => IO Config7 Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config7 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config7_mask       0x0000003CU
#define Adr_NX90_asic_ctrl_io_config7_mask 0xFF40123CU
#define Adr_NX90_io_config7_mask           0xFF40123CU
#define DFLT_VAL_NX90_io_config7_mask      0x000001ffU

#define MSK_NX90_io_config7_mask_sel_eth_cfg          0x0000001fU
#define SRT_NX90_io_config7_mask_sel_eth_cfg          0
#define DFLT_VAL_NX90_io_config7_mask_sel_eth_cfg     0x0000001fU
#define DFLT_BF_VAL_NX90_io_config7_mask_sel_eth_cfg  0x0000001fU
#define MSK_NX90_io_config7_mask_sel_eth_mdio         0x00000060U
#define SRT_NX90_io_config7_mask_sel_eth_mdio         5
#define DFLT_VAL_NX90_io_config7_mask_sel_eth_mdio    0x00000060U
#define DFLT_BF_VAL_NX90_io_config7_mask_sel_eth_mdio 0x00000003U
#define MSK_NX90_io_config7_mask_sel_sqi_cs1          0x00000080U
#define SRT_NX90_io_config7_mask_sel_sqi_cs1          7
#define DFLT_VAL_NX90_io_config7_mask_sel_sqi_cs1     0x00000080U
#define DFLT_BF_VAL_NX90_io_config7_mask_sel_sqi_cs1  0x00000001U
#define MSK_NX90_io_config7_mask_sel_sqi_cs2          0x00000100U
#define SRT_NX90_io_config7_mask_sel_sqi_cs2          8
#define DFLT_VAL_NX90_io_config7_mask_sel_sqi_cs2     0x00000100U
#define DFLT_BF_VAL_NX90_io_config7_mask_sel_sqi_cs2  0x00000001U

/* all used bits of 'NX90_io_config7_mask': */
#define MSK_USED_BITS_NX90_io_config7_mask 0x000001ffU

enum {
  BFW_NX90_io_config7_mask_sel_eth_cfg  = 5,  /* [4:0] */
  BFW_NX90_io_config7_mask_sel_eth_mdio = 2,  /* [6:5] */
  BFW_NX90_io_config7_mask_sel_sqi_cs1  = 1,  /* [7] */
  BFW_NX90_io_config7_mask_sel_sqi_cs2  = 1,  /* [8] */
  BFW_NX90_io_config7_mask_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_IO_CONFIG7_MASK_BIT_Ttag {
  unsigned int sel_eth_cfg  : BFW_NX90_io_config7_mask_sel_eth_cfg;  /* select connection of ETH MII pins:                       */
  unsigned int sel_eth_mdio : BFW_NX90_io_config7_mask_sel_eth_mdio; /* select connection for MIIMU MDIO interface used by ETH   */
  unsigned int sel_sqi_cs1  : BFW_NX90_io_config7_mask_sel_sqi_cs1;  /* select pad for 2nd chip select of sqi (s. pinning table) */
  unsigned int sel_sqi_cs2  : BFW_NX90_io_config7_mask_sel_sqi_cs2;  /* select pad for 3rd chip select of sqi (s. pinning table) */
  unsigned int reserved1    : BFW_NX90_io_config7_mask_reserved1;    /* reserved                                                 */
} NX90_IO_CONFIG7_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG7_MASK_BIT_T bf;
} NX90_IO_CONFIG7_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config8 */
/* => IO Config8 Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Changes will only have effect if according bit in io_config8_mask-register is set. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config8       0x00000040U
#define Adr_NX90_asic_ctrl_io_config8 0xFF401240U
#define Adr_NX90_io_config8           0xFF401240U
#define DFLT_VAL_NX90_io_config8      0x00000000U

#define MSK_NX90_io_config8_sel_arm_trace_cfg         0x00000003U
#define SRT_NX90_io_config8_sel_arm_trace_cfg         0
#define DFLT_VAL_NX90_io_config8_sel_arm_trace_cfg    0x00000000U
#define DFLT_BF_VAL_NX90_io_config8_sel_arm_trace_cfg 0x00000000U

/* all used bits of 'NX90_io_config8': */
#define MSK_USED_BITS_NX90_io_config8 0x00000003U

enum {
  BFW_NX90_io_config8_sel_arm_trace_cfg = 2,  /* [1:0] */
  BFW_NX90_io_config8_reserved1         = 30  /* [31:2] */
};

typedef struct NX90_IO_CONFIG8_BIT_Ttag {
  unsigned int sel_arm_trace_cfg : BFW_NX90_io_config8_sel_arm_trace_cfg; /* select pins for CoreSight Tracing                                   */
                                                                          /* 00: Disable Trace:           sel_trace = 0, sel_trace_d[3:0] = 0000 */
                                                                          /* 01: Trace with 1 data line:  sel_trace = 1, sel_trace_d[3:0] = 0001 */
                                                                          /* 10: Trace with 2 data lines: sel_trace = 1, sel_trace_d[3:0] = 0011 */
                                                                          /* 11: Trace with 4 data lines: sel_trace = 1, sel_trace_d[3:0] = 1111 */
  unsigned int reserved1         : BFW_NX90_io_config8_reserved1;         /* reserved                                                            */
} NX90_IO_CONFIG8_BIT_T;

typedef union {
  uint32_t              val;
  NX90_IO_CONFIG8_BIT_T bf;
} NX90_IO_CONFIG8_T;

/* --------------------------------------------------------------------- */
/* Register io_config8_mask */
/* => IO Config8 Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config8 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_config8_mask       0x00000044U
#define Adr_NX90_asic_ctrl_io_config8_mask 0xFF401244U
#define Adr_NX90_io_config8_mask           0xFF401244U
#define DFLT_VAL_NX90_io_config8_mask      0x00000003U

#define MSK_NX90_io_config8_mask_sel_arm_trace_cfg         0x00000003U
#define SRT_NX90_io_config8_mask_sel_arm_trace_cfg         0
#define DFLT_VAL_NX90_io_config8_mask_sel_arm_trace_cfg    0x00000003U
#define DFLT_BF_VAL_NX90_io_config8_mask_sel_arm_trace_cfg 0x00000003U

/* all used bits of 'NX90_io_config8_mask': */
#define MSK_USED_BITS_NX90_io_config8_mask 0x00000003U

enum {
  BFW_NX90_io_config8_mask_sel_arm_trace_cfg = 2,  /* [1:0] */
  BFW_NX90_io_config8_mask_reserved1         = 30  /* [31:2] */
};

typedef struct NX90_IO_CONFIG8_MASK_BIT_Ttag {
  unsigned int sel_arm_trace_cfg : BFW_NX90_io_config8_mask_sel_arm_trace_cfg; /* select pins for CoreSight Tracing */
  unsigned int reserved1         : BFW_NX90_io_config8_mask_reserved1;         /* reserved                          */
} NX90_IO_CONFIG8_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_CONFIG8_MASK_BIT_T bf;
} NX90_IO_CONFIG8_MASK_T;

/* --------------------------------------------------------------------- */
/* Register clock_enable0 */
/* => Global Clock Enable Register: */
/*    Use this registers to disable modules completely for power saving purposes. */
/*    Changes will only have effect if according bit in clock_enable_mask-register is set. */
/*    Note: For low power consumption at power on, all switchable clocks are disabled after reset and must be enabled before module usage. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_clock_enable0       0x00000050U
#define Adr_NX90_asic_ctrl_clock_enable0 0xFF401250U
#define Adr_NX90_clock_enable0           0xFF401250U
#define DFLT_VAL_NX90_clock_enable0      0x00001000U

#define MSK_NX90_clock_enable0_rpec0           0x00000001U
#define SRT_NX90_clock_enable0_rpec0           0
#define DFLT_VAL_NX90_clock_enable0_rpec0      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_rpec0   0x00000000U
#define MSK_NX90_clock_enable0_rpec1           0x00000002U
#define SRT_NX90_clock_enable0_rpec1           1
#define DFLT_VAL_NX90_clock_enable0_rpec1      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_rpec1   0x00000000U
#define MSK_NX90_clock_enable0_tpec0           0x00000004U
#define SRT_NX90_clock_enable0_tpec0           2
#define DFLT_VAL_NX90_clock_enable0_tpec0      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_tpec0   0x00000000U
#define MSK_NX90_clock_enable0_tpec1           0x00000008U
#define SRT_NX90_clock_enable0_tpec1           3
#define DFLT_VAL_NX90_clock_enable0_tpec1      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_tpec1   0x00000000U
#define MSK_NX90_clock_enable0_xmac0           0x00000010U
#define SRT_NX90_clock_enable0_xmac0           4
#define DFLT_VAL_NX90_clock_enable0_xmac0      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_xmac0   0x00000000U
#define MSK_NX90_clock_enable0_xmac1           0x00000020U
#define SRT_NX90_clock_enable0_xmac1           5
#define DFLT_VAL_NX90_clock_enable0_xmac1      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_xmac1   0x00000000U
#define MSK_NX90_clock_enable0_fb0             0x00000040U
#define SRT_NX90_clock_enable0_fb0             6
#define DFLT_VAL_NX90_clock_enable0_fb0        0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_fb0     0x00000000U
#define MSK_NX90_clock_enable0_fb1             0x00000080U
#define SRT_NX90_clock_enable0_fb1             7
#define DFLT_VAL_NX90_clock_enable0_fb1        0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_fb1     0x00000000U
#define MSK_NX90_clock_enable0_xc_misc         0x00000100U
#define SRT_NX90_clock_enable0_xc_misc         8
#define DFLT_VAL_NX90_clock_enable0_xc_misc    0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_xc_misc 0x00000000U
#define MSK_NX90_clock_enable0_xpic0           0x00000200U
#define SRT_NX90_clock_enable0_xpic0           9
#define DFLT_VAL_NX90_clock_enable0_xpic0      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_xpic0   0x00000000U
#define MSK_NX90_clock_enable0_dma_com         0x00000400U
#define SRT_NX90_clock_enable0_dma_com         10
#define DFLT_VAL_NX90_clock_enable0_dma_com    0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_dma_com 0x00000000U
#define MSK_NX90_clock_enable0_arm_app         0x00000800U
#define SRT_NX90_clock_enable0_arm_app         11
#define DFLT_VAL_NX90_clock_enable0_arm_app    0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_arm_app 0x00000000U
#define MSK_NX90_clock_enable0_debug           0x00001000U
#define SRT_NX90_clock_enable0_debug           12
#define DFLT_VAL_NX90_clock_enable0_debug      0x00001000U
#define DFLT_BF_VAL_NX90_clock_enable0_debug   0x00000001U
#define MSK_NX90_clock_enable0_dpm             0x00002000U
#define SRT_NX90_clock_enable0_dpm             13
#define DFLT_VAL_NX90_clock_enable0_dpm        0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable0_dpm     0x00000000U

/* all used bits of 'NX90_clock_enable0': */
#define MSK_USED_BITS_NX90_clock_enable0 0x00003fffU

enum {
  BFW_NX90_clock_enable0_rpec0     = 1,  /* [0] */
  BFW_NX90_clock_enable0_rpec1     = 1,  /* [1] */
  BFW_NX90_clock_enable0_tpec0     = 1,  /* [2] */
  BFW_NX90_clock_enable0_tpec1     = 1,  /* [3] */
  BFW_NX90_clock_enable0_xmac0     = 1,  /* [4] */
  BFW_NX90_clock_enable0_xmac1     = 1,  /* [5] */
  BFW_NX90_clock_enable0_fb0       = 1,  /* [6] */
  BFW_NX90_clock_enable0_fb1       = 1,  /* [7] */
  BFW_NX90_clock_enable0_xc_misc   = 1,  /* [8] */
  BFW_NX90_clock_enable0_xpic0     = 1,  /* [9] */
  BFW_NX90_clock_enable0_dma_com   = 1,  /* [10] */
  BFW_NX90_clock_enable0_arm_app   = 1,  /* [11] */
  BFW_NX90_clock_enable0_debug     = 1,  /* [12] */
  BFW_NX90_clock_enable0_dpm       = 1,  /* [13] */
  BFW_NX90_clock_enable0_reserved1 = 18  /* [31:14] */
};

typedef struct NX90_CLOCK_ENABLE0_BIT_Ttag {
  unsigned int rpec0     : BFW_NX90_clock_enable0_rpec0;     /* enables clock for rPEC0                                      */
  unsigned int rpec1     : BFW_NX90_clock_enable0_rpec1;     /* enables clock for rPEC1                                      */
  unsigned int tpec0     : BFW_NX90_clock_enable0_tpec0;     /* enables clock for tPEC0                                      */
  unsigned int tpec1     : BFW_NX90_clock_enable0_tpec1;     /* enables clock for tPEC1                                      */
  unsigned int xmac0     : BFW_NX90_clock_enable0_xmac0;     /* enables clock for xMAC0                                      */
  unsigned int xmac1     : BFW_NX90_clock_enable0_xmac1;     /* enables clock for xMAC1                                      */
  unsigned int fb0       : BFW_NX90_clock_enable0_fb0;       /* enables clock for fieldbus0                                  */
                                                             /* 1: use internally generated fb0clk to resample xMAC0 outputs */
                                                             /* 0: use external xm0_eclk to resample xMAC outputs            */
  unsigned int fb1       : BFW_NX90_clock_enable0_fb1;       /* enables clock for fieldbus1                                  */
                                                             /* 1: use internally generated fb1clk to resample xMAC1 outputs */
                                                             /* 0: use external xm1_eclk to resample xMAC outputs            */
  unsigned int xc_misc   : BFW_NX90_clock_enable0_xc_misc;   /* enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN  */
  unsigned int xpic0     : BFW_NX90_clock_enable0_xpic0;     /* enables clock for XPIC0                                      */
  unsigned int dma_com   : BFW_NX90_clock_enable0_dma_com;   /* enables clock for COM DMA-Ctrl                               */
  unsigned int arm_app   : BFW_NX90_clock_enable0_arm_app;   /* enables clock for ARM-APP                                    */
  unsigned int debug     : BFW_NX90_clock_enable0_debug;     /* enables clock for Coresight Debugging                        */
  unsigned int dpm       : BFW_NX90_clock_enable0_dpm;       /* enables clock for DPM                                        */
  unsigned int reserved1 : BFW_NX90_clock_enable0_reserved1; /* reserved                                                     */
} NX90_CLOCK_ENABLE0_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CLOCK_ENABLE0_BIT_T bf;
} NX90_CLOCK_ENABLE0_T;

/* --------------------------------------------------------------------- */
/* Register clock_enable0_mask */
/* => Global Clock Enable Mask Register: */
/*    This register might be used to lock clock_enable0 register. \ */
/*    Any bit of the clock_enable0 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_clock_enable0_mask       0x00000054U
#define Adr_NX90_asic_ctrl_clock_enable0_mask 0xFF401254U
#define Adr_NX90_clock_enable0_mask           0xFF401254U
#define DFLT_VAL_NX90_clock_enable0_mask      0x00003fffU

#define MSK_NX90_clock_enable0_mask_rpec0           0x00000001U
#define SRT_NX90_clock_enable0_mask_rpec0           0
#define DFLT_VAL_NX90_clock_enable0_mask_rpec0      0x00000001U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_rpec0   0x00000001U
#define MSK_NX90_clock_enable0_mask_rpec1           0x00000002U
#define SRT_NX90_clock_enable0_mask_rpec1           1
#define DFLT_VAL_NX90_clock_enable0_mask_rpec1      0x00000002U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_rpec1   0x00000001U
#define MSK_NX90_clock_enable0_mask_tpec0           0x00000004U
#define SRT_NX90_clock_enable0_mask_tpec0           2
#define DFLT_VAL_NX90_clock_enable0_mask_tpec0      0x00000004U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_tpec0   0x00000001U
#define MSK_NX90_clock_enable0_mask_tpec1           0x00000008U
#define SRT_NX90_clock_enable0_mask_tpec1           3
#define DFLT_VAL_NX90_clock_enable0_mask_tpec1      0x00000008U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_tpec1   0x00000001U
#define MSK_NX90_clock_enable0_mask_xmac0           0x00000010U
#define SRT_NX90_clock_enable0_mask_xmac0           4
#define DFLT_VAL_NX90_clock_enable0_mask_xmac0      0x00000010U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_xmac0   0x00000001U
#define MSK_NX90_clock_enable0_mask_xmac1           0x00000020U
#define SRT_NX90_clock_enable0_mask_xmac1           5
#define DFLT_VAL_NX90_clock_enable0_mask_xmac1      0x00000020U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_xmac1   0x00000001U
#define MSK_NX90_clock_enable0_mask_fb0             0x00000040U
#define SRT_NX90_clock_enable0_mask_fb0             6
#define DFLT_VAL_NX90_clock_enable0_mask_fb0        0x00000040U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_fb0     0x00000001U
#define MSK_NX90_clock_enable0_mask_fb1             0x00000080U
#define SRT_NX90_clock_enable0_mask_fb1             7
#define DFLT_VAL_NX90_clock_enable0_mask_fb1        0x00000080U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_fb1     0x00000001U
#define MSK_NX90_clock_enable0_mask_xc_misc         0x00000100U
#define SRT_NX90_clock_enable0_mask_xc_misc         8
#define DFLT_VAL_NX90_clock_enable0_mask_xc_misc    0x00000100U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_xc_misc 0x00000001U
#define MSK_NX90_clock_enable0_mask_xpic0           0x00000200U
#define SRT_NX90_clock_enable0_mask_xpic0           9
#define DFLT_VAL_NX90_clock_enable0_mask_xpic0      0x00000200U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_xpic0   0x00000001U
#define MSK_NX90_clock_enable0_mask_dma_com         0x00000400U
#define SRT_NX90_clock_enable0_mask_dma_com         10
#define DFLT_VAL_NX90_clock_enable0_mask_dma_com    0x00000400U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_dma_com 0x00000001U
#define MSK_NX90_clock_enable0_mask_arm_app         0x00000800U
#define SRT_NX90_clock_enable0_mask_arm_app         11
#define DFLT_VAL_NX90_clock_enable0_mask_arm_app    0x00000800U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_arm_app 0x00000001U
#define MSK_NX90_clock_enable0_mask_debug           0x00001000U
#define SRT_NX90_clock_enable0_mask_debug           12
#define DFLT_VAL_NX90_clock_enable0_mask_debug      0x00001000U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_debug   0x00000001U
#define MSK_NX90_clock_enable0_mask_dpm             0x00002000U
#define SRT_NX90_clock_enable0_mask_dpm             13
#define DFLT_VAL_NX90_clock_enable0_mask_dpm        0x00002000U
#define DFLT_BF_VAL_NX90_clock_enable0_mask_dpm     0x00000001U

/* all used bits of 'NX90_clock_enable0_mask': */
#define MSK_USED_BITS_NX90_clock_enable0_mask 0x00003fffU

enum {
  BFW_NX90_clock_enable0_mask_rpec0     = 1,  /* [0] */
  BFW_NX90_clock_enable0_mask_rpec1     = 1,  /* [1] */
  BFW_NX90_clock_enable0_mask_tpec0     = 1,  /* [2] */
  BFW_NX90_clock_enable0_mask_tpec1     = 1,  /* [3] */
  BFW_NX90_clock_enable0_mask_xmac0     = 1,  /* [4] */
  BFW_NX90_clock_enable0_mask_xmac1     = 1,  /* [5] */
  BFW_NX90_clock_enable0_mask_fb0       = 1,  /* [6] */
  BFW_NX90_clock_enable0_mask_fb1       = 1,  /* [7] */
  BFW_NX90_clock_enable0_mask_xc_misc   = 1,  /* [8] */
  BFW_NX90_clock_enable0_mask_xpic0     = 1,  /* [9] */
  BFW_NX90_clock_enable0_mask_dma_com   = 1,  /* [10] */
  BFW_NX90_clock_enable0_mask_arm_app   = 1,  /* [11] */
  BFW_NX90_clock_enable0_mask_debug     = 1,  /* [12] */
  BFW_NX90_clock_enable0_mask_dpm       = 1,  /* [13] */
  BFW_NX90_clock_enable0_mask_reserved1 = 18  /* [31:14] */
};

typedef struct NX90_CLOCK_ENABLE0_MASK_BIT_Ttag {
  unsigned int rpec0     : BFW_NX90_clock_enable0_mask_rpec0;     /* enables clock for rPEC0                                     */
  unsigned int rpec1     : BFW_NX90_clock_enable0_mask_rpec1;     /* enables clock for rPEC1                                     */
  unsigned int tpec0     : BFW_NX90_clock_enable0_mask_tpec0;     /* enables clock for tPEC0                                     */
  unsigned int tpec1     : BFW_NX90_clock_enable0_mask_tpec1;     /* enables clock for tPEC1                                     */
  unsigned int xmac0     : BFW_NX90_clock_enable0_mask_xmac0;     /* enables clock for xMAC0                                     */
  unsigned int xmac1     : BFW_NX90_clock_enable0_mask_xmac1;     /* enables clock for xMAC1                                     */
  unsigned int fb0       : BFW_NX90_clock_enable0_mask_fb0;       /* enables clock for fieldbus0                                 */
  unsigned int fb1       : BFW_NX90_clock_enable0_mask_fb1;       /* enables clock for fieldbus1                                 */
  unsigned int xc_misc   : BFW_NX90_clock_enable0_mask_xc_misc;   /* enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN */
  unsigned int xpic0     : BFW_NX90_clock_enable0_mask_xpic0;     /* enables clock for XPIC0                                     */
  unsigned int dma_com   : BFW_NX90_clock_enable0_mask_dma_com;   /* enables clock for COM DMA-Ctrl                              */
  unsigned int arm_app   : BFW_NX90_clock_enable0_mask_arm_app;   /* enables clock for ARM-APP                                   */
  unsigned int debug     : BFW_NX90_clock_enable0_mask_debug;     /* enables clock for Coresight Debugging                       */
  unsigned int dpm       : BFW_NX90_clock_enable0_mask_dpm;       /* enables clock for DPM                                       */
  unsigned int reserved1 : BFW_NX90_clock_enable0_mask_reserved1; /* reserved                                                    */
} NX90_CLOCK_ENABLE0_MASK_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CLOCK_ENABLE0_MASK_BIT_T bf;
} NX90_CLOCK_ENABLE0_MASK_T;

/* --------------------------------------------------------------------- */
/* Register clock_enable1 */
/* => Global Clock Enable Register: */
/*    Use this registers to disable modules completely for power saving purposes. */
/*    Changes will only have effect if according bit in clock_enable_mask-register is set. */
/*    Note: For low power consumption at power on, all switchable clocks are disabled after reset and must be enabled before module usage. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_clock_enable1       0x00000058U
#define Adr_NX90_asic_ctrl_clock_enable1 0xFF401258U
#define Adr_NX90_clock_enable1           0xFF401258U
#define DFLT_VAL_NX90_clock_enable1      0x00000000U

#define MSK_NX90_clock_enable1_xpic1           0x00000001U
#define SRT_NX90_clock_enable1_xpic1           0
#define DFLT_VAL_NX90_clock_enable1_xpic1      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable1_xpic1   0x00000000U
#define MSK_NX90_clock_enable1_dma_app         0x00000002U
#define SRT_NX90_clock_enable1_dma_app         1
#define DFLT_VAL_NX90_clock_enable1_dma_app    0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable1_dma_app 0x00000000U
#define MSK_NX90_clock_enable1_crypt           0x00000004U
#define SRT_NX90_clock_enable1_crypt           2
#define DFLT_VAL_NX90_clock_enable1_crypt      0x00000000U
#define DFLT_BF_VAL_NX90_clock_enable1_crypt   0x00000000U

/* all used bits of 'NX90_clock_enable1': */
#define MSK_USED_BITS_NX90_clock_enable1 0x00000007U

enum {
  BFW_NX90_clock_enable1_xpic1     = 1,  /* [0] */
  BFW_NX90_clock_enable1_dma_app   = 1,  /* [1] */
  BFW_NX90_clock_enable1_crypt     = 1,  /* [2] */
  BFW_NX90_clock_enable1_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_CLOCK_ENABLE1_BIT_Ttag {
  unsigned int xpic1     : BFW_NX90_clock_enable1_xpic1;     /* enables clock for XPIC1        */
  unsigned int dma_app   : BFW_NX90_clock_enable1_dma_app;   /* enables clock for APP DMA-Ctrl */
  unsigned int crypt     : BFW_NX90_clock_enable1_crypt;     /* enables clock for CRYPT Unit   */
  unsigned int reserved1 : BFW_NX90_clock_enable1_reserved1; /* reserved                       */
} NX90_CLOCK_ENABLE1_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CLOCK_ENABLE1_BIT_T bf;
} NX90_CLOCK_ENABLE1_T;

/* --------------------------------------------------------------------- */
/* Register clock_enable1_mask */
/* => Global Clock Enable Mask Register: */
/*    This register might be used to lock clock_enable1 register. \ */
/*    Any bit of the clock_enable1 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_clock_enable1_mask       0x0000005CU
#define Adr_NX90_asic_ctrl_clock_enable1_mask 0xFF40125CU
#define Adr_NX90_clock_enable1_mask           0xFF40125CU
#define DFLT_VAL_NX90_clock_enable1_mask      0x00000007U

#define MSK_NX90_clock_enable1_mask_xpic1           0x00000001U
#define SRT_NX90_clock_enable1_mask_xpic1           0
#define DFLT_VAL_NX90_clock_enable1_mask_xpic1      0x00000001U
#define DFLT_BF_VAL_NX90_clock_enable1_mask_xpic1   0x00000001U
#define MSK_NX90_clock_enable1_mask_dma_app         0x00000002U
#define SRT_NX90_clock_enable1_mask_dma_app         1
#define DFLT_VAL_NX90_clock_enable1_mask_dma_app    0x00000002U
#define DFLT_BF_VAL_NX90_clock_enable1_mask_dma_app 0x00000001U
#define MSK_NX90_clock_enable1_mask_crypt           0x00000004U
#define SRT_NX90_clock_enable1_mask_crypt           2
#define DFLT_VAL_NX90_clock_enable1_mask_crypt      0x00000004U
#define DFLT_BF_VAL_NX90_clock_enable1_mask_crypt   0x00000001U

/* all used bits of 'NX90_clock_enable1_mask': */
#define MSK_USED_BITS_NX90_clock_enable1_mask 0x00000007U

enum {
  BFW_NX90_clock_enable1_mask_xpic1     = 1,  /* [0] */
  BFW_NX90_clock_enable1_mask_dma_app   = 1,  /* [1] */
  BFW_NX90_clock_enable1_mask_crypt     = 1,  /* [2] */
  BFW_NX90_clock_enable1_mask_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_CLOCK_ENABLE1_MASK_BIT_Ttag {
  unsigned int xpic1     : BFW_NX90_clock_enable1_mask_xpic1;     /* enables clock for XPIC1        */
  unsigned int dma_app   : BFW_NX90_clock_enable1_mask_dma_app;   /* enables clock for APP DMA-Ctrl */
  unsigned int crypt     : BFW_NX90_clock_enable1_mask_crypt;     /* enables clock for CRYPT Unit   */
  unsigned int reserved1 : BFW_NX90_clock_enable1_mask_reserved1; /* reserved                       */
} NX90_CLOCK_ENABLE1_MASK_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_CLOCK_ENABLE1_MASK_BIT_T bf;
} NX90_CLOCK_ENABLE1_MASK_T;

/* --------------------------------------------------------------------- */
/* Register reset_ctrl */
/* => Reset Control Register: */
/*    This register controls the reset functions of the netX chip and indicates the reset state. The reset state */
/*    shows which resets have occurred, allowing the firmware to detect which resets were active. In order to */
/*    determine the source of the last reset, the firmware should evaluate and reset these bits during its start */
/*    sequence. After a power on reset, the RESET_CTRL register is cleared completely. */
/*     */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_reset_ctrl       0x00000060U
#define Adr_NX90_asic_ctrl_reset_ctrl 0xFF401260U
#define Adr_NX90_reset_ctrl           0xFF401260U
#define DFLT_VAL_NX90_reset_ctrl      0x00000000U

#define MSK_NX90_reset_ctrl_RES_IN                   0x00000001U
#define SRT_NX90_reset_ctrl_RES_IN                   0
#define DFLT_VAL_NX90_reset_ctrl_RES_IN              0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_IN           0x00000000U
#define MSK_NX90_reset_ctrl_RES_WDOG                 0x00000002U
#define SRT_NX90_reset_ctrl_RES_WDOG                 1
#define DFLT_VAL_NX90_reset_ctrl_RES_WDOG            0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_WDOG         0x00000000U
#define MSK_NX90_reset_ctrl_RES_HOST                 0x00000004U
#define SRT_NX90_reset_ctrl_RES_HOST                 2
#define DFLT_VAL_NX90_reset_ctrl_RES_HOST            0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_HOST         0x00000000U
#define MSK_NX90_reset_ctrl_RES_FIRMWARE             0x00000008U
#define SRT_NX90_reset_ctrl_RES_FIRMWARE             3
#define DFLT_VAL_NX90_reset_ctrl_RES_FIRMWARE        0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_FIRMWARE     0x00000000U
#define MSK_NX90_reset_ctrl_RES_ARM_COM              0x00000010U
#define SRT_NX90_reset_ctrl_RES_ARM_COM              4
#define DFLT_VAL_NX90_reset_ctrl_RES_ARM_COM         0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_ARM_COM      0x00000000U
#define MSK_NX90_reset_ctrl_RES_ARM_APP              0x00000020U
#define SRT_NX90_reset_ctrl_RES_ARM_APP              5
#define DFLT_VAL_NX90_reset_ctrl_RES_ARM_APP         0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_ARM_APP      0x00000000U
#define MSK_NX90_reset_ctrl_FIRMWARE_STATUS0         0x00100000U
#define SRT_NX90_reset_ctrl_FIRMWARE_STATUS0         20
#define DFLT_VAL_NX90_reset_ctrl_FIRMWARE_STATUS0    0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_FIRMWARE_STATUS0 0x00000000U
#define MSK_NX90_reset_ctrl_FIRMWARE_STATUS1         0x00200000U
#define SRT_NX90_reset_ctrl_FIRMWARE_STATUS1         21
#define DFLT_VAL_NX90_reset_ctrl_FIRMWARE_STATUS1    0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_FIRMWARE_STATUS1 0x00000000U
#define MSK_NX90_reset_ctrl_FIRMWARE_STATUS2         0x00400000U
#define SRT_NX90_reset_ctrl_FIRMWARE_STATUS2         22
#define DFLT_VAL_NX90_reset_ctrl_FIRMWARE_STATUS2    0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_FIRMWARE_STATUS2 0x00000000U
#define MSK_NX90_reset_ctrl_FIRMWARE_STATUS3         0x00800000U
#define SRT_NX90_reset_ctrl_FIRMWARE_STATUS3         23
#define DFLT_VAL_NX90_reset_ctrl_FIRMWARE_STATUS3    0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_FIRMWARE_STATUS3 0x00000000U
#define MSK_NX90_reset_ctrl_RES_REQ_FIRMWARE         0x01000000U
#define SRT_NX90_reset_ctrl_RES_REQ_FIRMWARE         24
#define DFLT_VAL_NX90_reset_ctrl_RES_REQ_FIRMWARE    0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_REQ_FIRMWARE 0x00000000U
#define MSK_NX90_reset_ctrl_RES_REQ_OUT              0x02000000U
#define SRT_NX90_reset_ctrl_RES_REQ_OUT              25
#define DFLT_VAL_NX90_reset_ctrl_RES_REQ_OUT         0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_RES_REQ_OUT      0x00000000U
#define MSK_NX90_reset_ctrl_EN_RES_REQ_OUT           0x04000000U
#define SRT_NX90_reset_ctrl_EN_RES_REQ_OUT           26
#define DFLT_VAL_NX90_reset_ctrl_EN_RES_REQ_OUT      0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_EN_RES_REQ_OUT   0x00000000U
#define MSK_NX90_reset_ctrl_rst_out_n_in_ro          0x08000000U
#define SRT_NX90_reset_ctrl_rst_out_n_in_ro          27
#define DFLT_VAL_NX90_reset_ctrl_rst_out_n_in_ro     0x00000000U
#define DFLT_BF_VAL_NX90_reset_ctrl_rst_out_n_in_ro  0x00000000U

/* all used bits of 'NX90_reset_ctrl': */
#define MSK_USED_BITS_NX90_reset_ctrl 0x0ff0003fU

enum {
  BFW_NX90_reset_ctrl_RES_IN           = 1,  /* [0] */
  BFW_NX90_reset_ctrl_RES_WDOG         = 1,  /* [1] */
  BFW_NX90_reset_ctrl_RES_HOST         = 1,  /* [2] */
  BFW_NX90_reset_ctrl_RES_FIRMWARE     = 1,  /* [3] */
  BFW_NX90_reset_ctrl_RES_ARM_COM      = 1,  /* [4] */
  BFW_NX90_reset_ctrl_RES_ARM_APP      = 1,  /* [5] */
  BFW_NX90_reset_ctrl_reserved1        = 14, /* [19:6] */
  BFW_NX90_reset_ctrl_FIRMWARE_STATUS0 = 1,  /* [20] */
  BFW_NX90_reset_ctrl_FIRMWARE_STATUS1 = 1,  /* [21] */
  BFW_NX90_reset_ctrl_FIRMWARE_STATUS2 = 1,  /* [22] */
  BFW_NX90_reset_ctrl_FIRMWARE_STATUS3 = 1,  /* [23] */
  BFW_NX90_reset_ctrl_RES_REQ_FIRMWARE = 1,  /* [24] */
  BFW_NX90_reset_ctrl_RES_REQ_OUT      = 1,  /* [25] */
  BFW_NX90_reset_ctrl_EN_RES_REQ_OUT   = 1,  /* [26] */
  BFW_NX90_reset_ctrl_rst_out_n_in_ro  = 1,  /* [27] */
  BFW_NX90_reset_ctrl_reserved2        = 4   /* [31:28] */
};

typedef struct NX90_RESET_CTRL_BIT_Ttag {
  unsigned int RES_IN           : BFW_NX90_reset_ctrl_RES_IN;           /* Reset status: A reset was performed by the external pin (RST_IN_N).                                    */
                                                                        /* After reading write back a "1" to clear the status bit.                                                */
  unsigned int RES_WDOG         : BFW_NX90_reset_ctrl_RES_WDOG;         /* Reset status: A reset was performed by the system watchdog.                                            */
                                                                        /* After reading write back a "1" to clear the status bit.                                                */
  unsigned int RES_HOST         : BFW_NX90_reset_ctrl_RES_HOST;         /* Reset status: A software reset was performed by an external host by the DPM interface.                 */
                                                                        /* After reading write back a "1" to clear the status bit.                                                */
  unsigned int RES_FIRMWARE     : BFW_NX90_reset_ctrl_RES_FIRMWARE;     /* Reset status: A software reset was performed by the RES_REQ_FIRMWARE bit of this register.             */
                                                                        /* After reading write back a "1" to clear the status bit.                                                */
  unsigned int RES_ARM_COM      : BFW_NX90_reset_ctrl_RES_ARM_COM;      /* Reset status: A reset was performed by the SYSRESETREQ of the Com ARM.                                 */
                                                                        /* After reading write back a "1" to clear the status bit.                                                */
  unsigned int RES_ARM_APP      : BFW_NX90_reset_ctrl_RES_ARM_APP;      /* Reset status: A reset was performed by the SYSRESETREQ of the App ARM.                                 */
                                                                        /* After reading write back a "1" to clear the status bit.                                                */
  unsigned int reserved1        : BFW_NX90_reset_ctrl_reserved1;        /* reserved                                                                                               */
  unsigned int FIRMWARE_STATUS0 : BFW_NX90_reset_ctrl_FIRMWARE_STATUS0; /* Readable and writable bit to save the firmware status; only a power-on-reset will clear this bit.      */
  unsigned int FIRMWARE_STATUS1 : BFW_NX90_reset_ctrl_FIRMWARE_STATUS1; /* Readable and writable bit to save the firmware status; only a power-on-reset will clear this bit.      */
  unsigned int FIRMWARE_STATUS2 : BFW_NX90_reset_ctrl_FIRMWARE_STATUS2; /* Readable and writable bit to save the firmware status; only a power-on-reset will clear this bit.      */
  unsigned int FIRMWARE_STATUS3 : BFW_NX90_reset_ctrl_FIRMWARE_STATUS3; /* Readable and writable bit to save the firmware status; only a power-on-reset will clear this bit.      */
  unsigned int RES_REQ_FIRMWARE : BFW_NX90_reset_ctrl_RES_REQ_FIRMWARE; /* Software reset: Writing a "1" will reset the whole system - except logic and register bits             */
                                                                        /* which are only reset on power-on-reset. This bit is reset to 0 by hardware during the reset procedure. */
  unsigned int RES_REQ_OUT      : BFW_NX90_reset_ctrl_RES_REQ_OUT;      /* Software reset for external devices: This bit controls the level of the RST_OUT_N output               */
                                                                        /* for normal operation. For all resets this bit is cleared, however driving of RST_OUT_N                 */
                                                                        /* is also disabled (view EN_RES_REQ_OUT bit).                                                            */
  unsigned int EN_RES_REQ_OUT   : BFW_NX90_reset_ctrl_EN_RES_REQ_OUT;   /* This bit enables the driving of the programmable reset output RST_OUT_N.                               */
                                                                        /* When this bit is not set RST_OUT_N will be in high impedance state.                                    */
                                                                        /* For all resets this bit is cleared. The external level of the RST_OUT_N output during the reset        */
                                                                        /* must be realized by an external pull up or down resistor (when RST_OUT_N function is desired).         */
  unsigned int rst_out_n_in_ro  : BFW_NX90_reset_ctrl_rst_out_n_in_ro;  /* Status of reset pin (RST_OUT_N). This bit is a read only status and indicates the reset state.         */
  unsigned int reserved2        : BFW_NX90_reset_ctrl_reserved2;        /* reserved                                                                                               */
} NX90_RESET_CTRL_BIT_T;

typedef union {
  uint32_t              val;
  NX90_RESET_CTRL_BIT_T bf;
} NX90_RESET_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ahbl_master_ready */
/* => All AHBL master ready signals. */
/*    Before stop, reset or clockdisable of any master, check that this bit of the appropriate master is 1. */
/*    If it is 0, a current access of this master to the system is not finished. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ahbl_master_ready       0x00000064U
#define Adr_NX90_asic_ctrl_ahbl_master_ready 0xFF401264U
#define Adr_NX90_ahbl_master_ready           0xFF401264U

#define MSK_NX90_ahbl_master_ready_val 0x0007ffffU
#define SRT_NX90_ahbl_master_ready_val 0

/* all used bits of 'NX90_ahbl_master_ready': */
#define MSK_USED_BITS_NX90_ahbl_master_ready 0x0007ffffU

enum {
  BFW_NX90_ahbl_master_ready_val       = 19, /* [18:0] */
  BFW_NX90_ahbl_master_ready_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_AHBL_MASTER_READY_BIT_Ttag {
  unsigned int val       : BFW_NX90_ahbl_master_ready_val;       /* netx ahbl_master readys (0-18) */
                                                                 /* M_DPM0          0              */
                                                                 /* M_DPM1          1              */
                                                                 /* M_XC01_d        2              */
                                                                 /* M_XC01_s        3              */
                                                                 /* M_IPC_MASTER    4              */
                                                                 /* M_IDPM_MASTER   5              */
                                                                 /* M_DEBUG_MASTER  6              */
                                                                 /* M_XPIC_COM_d    7              */
                                                                 /* M_XPIC_COM_i    8              */
                                                                 /* M_XPIC_APP_d    9              */
                                                                 /* M_XPIC_APP_i   10              */
                                                                 /* M_ARM_COM_d    11              */
                                                                 /* M_ARM_COM_i    12              */
                                                                 /* M_ARM_COM_s    13              */
                                                                 /* M_ARM_APP_d    14              */
                                                                 /* M_ARM_APP_i    15              */
                                                                 /* M_ARM_APP_s    16              */
                                                                 /* M_DMAC_COM     17              */
                                                                 /* M_DMAC_APP     18              */
  unsigned int reserved1 : BFW_NX90_ahbl_master_ready_reserved1; /* reserved                       */
} NX90_AHBL_MASTER_READY_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_AHBL_MASTER_READY_BIT_T bf;
} NX90_AHBL_MASTER_READY_T;

/* --------------------------------------------------------------------- */
/* Register system_status */
/* => netX System Status Register. */
/*    This register provides information of special netX system events, e.g: System related interrupt activity, Abort activity. */
/*    Abort or IRQ status flag can be cleared by writing a '1' to the appropriate bits. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_system_status       0x00000074U
#define Adr_NX90_asic_ctrl_system_status 0xFF401274U
#define Adr_NX90_system_status           0xFF401274U

#define MSK_NX90_system_status_lic_err_irq_status   0x00000001U
#define SRT_NX90_system_status_lic_err_irq_status   0
#define MSK_NX90_system_status_extbus_to_irq_status 0x00000002U
#define SRT_NX90_system_status_extbus_to_irq_status 1
#define MSK_NX90_system_status_testmode             0x00000100U
#define SRT_NX90_system_status_testmode             8
#define MSK_NX90_system_status_pw_bod_ok            0x00000200U
#define SRT_NX90_system_status_pw_bod_ok            9
#define MSK_NX90_system_status_pll_bypass           0x00000400U
#define SRT_NX90_system_status_pll_bypass           10
#define MSK_NX90_system_status_quick_count          0x00000800U
#define SRT_NX90_system_status_quick_count          11
#define MSK_NX90_system_status_lic_err_abort_status 0x00010000U
#define SRT_NX90_system_status_lic_err_abort_status 16

/* all used bits of 'NX90_system_status': */
#define MSK_USED_BITS_NX90_system_status 0x00010f03U

enum {
  BFW_NX90_system_status_lic_err_irq_status   = 1,  /* [0] */
  BFW_NX90_system_status_extbus_to_irq_status = 1,  /* [1] */
  BFW_NX90_system_status_reserved1            = 6,  /* [7:2] */
  BFW_NX90_system_status_testmode             = 1,  /* [8] */
  BFW_NX90_system_status_pw_bod_ok            = 1,  /* [9] */
  BFW_NX90_system_status_pll_bypass           = 1,  /* [10] */
  BFW_NX90_system_status_quick_count          = 1,  /* [11] */
  BFW_NX90_system_status_reserved2            = 4,  /* [15:12] */
  BFW_NX90_system_status_lic_err_abort_status = 1,  /* [16] */
  BFW_NX90_system_status_reserved3            = 15  /* [31:17] */
};

typedef struct NX90_SYSTEM_STATUS_BIT_Ttag {
  unsigned int lic_err_irq_status   : BFW_NX90_system_status_lic_err_irq_status;   /* Current status of netX licence error IRQ.                                                                              */
                                                                                   /* Note: This IRQ (bit) can only be cleared by running a valid netx licence check sequence.                               */
                                                                                   /* Note: Generation of this IRQ is controlled by misc_asic_ctrl register.                                                 */
                                                                                   /* Note: This IRQ is not maskable.                                                                                        */
  unsigned int extbus_to_irq_status : BFW_NX90_system_status_extbus_to_irq_status; /* Current status of HIF-Extension Bus Ready Timeout IRQ.                                                                 */
                                                                                   /* Note: This IRQ is controlled/cleared by ext_rdy_cfg register (area hif_asyncmem_ctrl).                                 */
  unsigned int reserved1            : BFW_NX90_system_status_reserved1;            /* reserved                                                                                                               */
  unsigned int testmode             : BFW_NX90_system_status_testmode;             /* sampled netx TESTMODE input for production test purpose                                                                */
  unsigned int pw_bod_ok            : BFW_NX90_system_status_pw_bod_ok;            /* Power watch brown-out detection status                                                                                 */
  unsigned int pll_bypass           : BFW_NX90_system_status_pll_bypass;           /* Testmode 'pll_bypass' is activated by BSCAN JTAG TAP controller                                                        */
                                                                                   /* -> 400MHz-PLL is bypassed, PLL output is unused, 400MHz-Clocks (clk400, clk400_2sdram) is directly connected to XTALIN */
  unsigned int quick_count          : BFW_NX90_system_status_quick_count;          /* Testmode 'quick_count' is activated by BSCAN JTAG TAP controller                                                       */
                                                                                   /* -> diverse internal counters count faster (RTC-clock-divider, PLL-stby-controller,...)                                 */
  unsigned int reserved2            : BFW_NX90_system_status_reserved2;            /* reserved                                                                                                               */
  unsigned int lic_err_abort_status : BFW_NX90_system_status_lic_err_abort_status; /* Current status of netX licence abort.                                                                                  */
                                                                                   /* Note: This bit must be cleared by writing a '1'. It is not cleared automatically if ARM Abort mode is left.            */
                                                                                   /* Note: Generation of this Abort is controlled by misc_asic_ctrl register.                                               */
  unsigned int reserved3            : BFW_NX90_system_status_reserved3;            /* reserved                                                                                                               */
} NX90_SYSTEM_STATUS_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_SYSTEM_STATUS_BIT_T bf;
} NX90_SYSTEM_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register systime_feth_ctrl */
/* => Select systime for FETH */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_systime_feth_ctrl       0x00000078U
#define Adr_NX90_asic_ctrl_systime_feth_ctrl 0xFF401278U
#define Adr_NX90_systime_feth_ctrl           0xFF401278U
#define DFLT_VAL_NX90_systime_feth_ctrl      0x00000000U

#define MSK_NX90_systime_feth_ctrl_feth         0x00000003U
#define SRT_NX90_systime_feth_ctrl_feth         0
#define DFLT_VAL_NX90_systime_feth_ctrl_feth    0x00000000U
#define DFLT_BF_VAL_NX90_systime_feth_ctrl_feth 0x00000000U

/* all used bits of 'NX90_systime_feth_ctrl': */
#define MSK_USED_BITS_NX90_systime_feth_ctrl 0x00000003U

enum {
  BFW_NX90_systime_feth_ctrl_feth      = 2,  /* [1:0] */
  BFW_NX90_systime_feth_ctrl_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_SYSTIME_FETH_CTRL_BIT_Ttag {
  unsigned int feth      : BFW_NX90_systime_feth_ctrl_feth;      /* Systime for FETH   */
                                                                 /* 00: systime_com    */
                                                                 /* 01: systime_com_uc */
                                                                 /* 10: systime_app    */
  unsigned int reserved1 : BFW_NX90_systime_feth_ctrl_reserved1; /* reserved           */
} NX90_SYSTIME_FETH_CTRL_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_SYSTIME_FETH_CTRL_BIT_T bf;
} NX90_SYSTIME_FETH_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register systime_gpio_app_ctrl */
/* => Select systime for GPIO_APP */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_systime_gpio_app_ctrl       0x00000080U
#define Adr_NX90_asic_ctrl_systime_gpio_app_ctrl 0xFF401280U
#define Adr_NX90_systime_gpio_app_ctrl           0xFF401280U
#define DFLT_VAL_NX90_systime_gpio_app_ctrl      0x00000000U

#define MSK_NX90_systime_gpio_app_ctrl_gpio_app         0x00000003U
#define SRT_NX90_systime_gpio_app_ctrl_gpio_app         0
#define DFLT_VAL_NX90_systime_gpio_app_ctrl_gpio_app    0x00000000U
#define DFLT_BF_VAL_NX90_systime_gpio_app_ctrl_gpio_app 0x00000000U

/* all used bits of 'NX90_systime_gpio_app_ctrl': */
#define MSK_USED_BITS_NX90_systime_gpio_app_ctrl 0x00000003U

enum {
  BFW_NX90_systime_gpio_app_ctrl_gpio_app  = 2,  /* [1:0] */
  BFW_NX90_systime_gpio_app_ctrl_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_SYSTIME_GPIO_APP_CTRL_BIT_Ttag {
  unsigned int gpio_app  : BFW_NX90_systime_gpio_app_ctrl_gpio_app;  /* Systime for GPIO_APP */
                                                                     /* 00: systime_com      */
                                                                     /* 01: systime_com_uc   */
                                                                     /* 10: systime_app      */
  unsigned int reserved1 : BFW_NX90_systime_gpio_app_ctrl_reserved1; /* reserved             */
} NX90_SYSTIME_GPIO_APP_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_SYSTIME_GPIO_APP_CTRL_BIT_T bf;
} NX90_SYSTIME_GPIO_APP_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register only_porn */
/* => Firmware Status register: */
/*    This register is not Reset by SW resets, only PORn will reset this register. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_only_porn       0x00000084U
#define Adr_NX90_asic_ctrl_only_porn 0xFF401284U
#define Adr_NX90_only_porn           0xFF401284U
#define DFLT_VAL_NX90_only_porn      0x00000000U

#define MSK_NX90_only_porn_only_porn         0xffffffffU
#define SRT_NX90_only_porn_only_porn         0
#define DFLT_VAL_NX90_only_porn_only_porn    0x00000000U
#define DFLT_BF_VAL_NX90_only_porn_only_porn 0x00000000U

/* all used bits of 'NX90_only_porn': */
#define MSK_USED_BITS_NX90_only_porn 0xffffffffU

enum {
  BFW_NX90_only_porn_only_porn = 32  /* [31:0] */
};

typedef struct NX90_ONLY_PORN_BIT_Ttag {
  unsigned int only_porn : BFW_NX90_only_porn_only_porn; /* netX Firmware status */
} NX90_ONLY_PORN_BIT_T;

typedef union {
  uint32_t             val;
  NX90_ONLY_PORN_BIT_T bf;
} NX90_ONLY_PORN_T;

/* --------------------------------------------------------------------- */
/* Register only_porn_rom */
/* => Firmware Status register for handling boot/rom-code issues: */
/*    This register is not Reset by SW resets, only PORn will reset this register. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_only_porn_rom       0x00000088U
#define Adr_NX90_asic_ctrl_only_porn_rom 0xFF401288U
#define Adr_NX90_only_porn_rom           0xFF401288U
#define DFLT_VAL_NX90_only_porn_rom      0x00000000U

#define MSK_NX90_only_porn_rom_val         0xffffffffU
#define SRT_NX90_only_porn_rom_val         0
#define DFLT_VAL_NX90_only_porn_rom_val    0x00000000U
#define DFLT_BF_VAL_NX90_only_porn_rom_val 0x00000000U

/* all used bits of 'NX90_only_porn_rom': */
#define MSK_USED_BITS_NX90_only_porn_rom 0xffffffffU

enum {
  BFW_NX90_only_porn_rom_val = 32  /* [31:0] */
};

typedef struct NX90_ONLY_PORN_ROM_BIT_Ttag {
  unsigned int val : BFW_NX90_only_porn_rom_val; /* netX Firmware status */
} NX90_ONLY_PORN_ROM_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_ONLY_PORN_ROM_BIT_T bf;
} NX90_ONLY_PORN_ROM_T;

/* --------------------------------------------------------------------- */
/* Register netx_version */
/* => netX Revision Register: */
/*    This register contains information about netX hardware and bootloader revision. */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_version       0x0000008CU
#define Adr_NX90_asic_ctrl_netx_version 0xFF40128CU
#define Adr_NX90_netx_version           0xFF40128CU
#define DFLT_VAL_NX90_netx_version      0x0000000cU

#define MSK_NX90_netx_version_netx_version         0xffffffffU
#define SRT_NX90_netx_version_netx_version         0
#define DFLT_VAL_NX90_netx_version_netx_version    0x0000000cU
#define DFLT_BF_VAL_NX90_netx_version_netx_version 0x0000000cU

/* all used bits of 'NX90_netx_version': */
#define MSK_USED_BITS_NX90_netx_version 0xffffffffU

enum {
  BFW_NX90_netx_version_netx_version = 32  /* [31:0] */
};

typedef struct NX90_NETX_VERSION_BIT_Ttag {
  unsigned int netx_version : BFW_NX90_netx_version_netx_version; /* netX revision number:                                                      */
                                                                  /* Hardware reset values of netX version register is:                         */
                                                                  /* 0x01: netx100, netx500                                                     */
                                                                  /* 0x01: netx50                                                               */
                                                                  /* 0x02: netx5_mpw                                                            */
                                                                  /* 0x41: netx5                                                                */
                                                                  /* 0x50: netx10                                                               */
                                                                  /* 0x05: netx51/52                                                            */
                                                                  /* 0x06: reserved                                                             */
                                                                  /* 0x07: netx6                                                                */
                                                                  /* 0x08: netx4000_relaxed                                                     */
                                                                  /* 0x09: reserved                                                             */
                                                                  /* 0x0a: netx4000                                                             */
                                                                  /* 0x0b: reserved                                                             */
                                                                  /* 0x0c: netx90_mpw                                                           */
                                                                  /* 0x0d: netx90                                                               */
                                                                  /* Further netX revisions should increment (next: 0x0e).                      */
                                                                  /* This register is changed to Hilscher netX bootloader revision by ROM-code: */
                                                                  /* Hardware reset values should differ from Hilscher values!                  */
                                                                  /* netX50 revision number starts with "B" (0x42).                             */
                                                                  /* 0x41: netx500                                                              */
                                                                  /* 0x42: netx50                                                               */
                                                                  /* 0x42: netx100                                                              */
                                                                  /* 0x41: netx5                                                                */
                                                                  /* 0x42: netx10                                                               */
                                                                  /* 0x42: netx51/52                                                            */
} NX90_NETX_VERSION_BIT_T;

typedef union {
  uint32_t                val;
  NX90_NETX_VERSION_BIT_T bf;
} NX90_NETX_VERSION_T;

/* --------------------------------------------------------------------- */
/* Register netx_status */
/* => netX Legacy System Status Configuration Register. */
/*    This Register was implemented in Hilscher HIF module originally. */
/*    From Hilscher Program Reference Guide: The general status of a netX based system is usually indicated by the System LED, which can either */
/*    consist of a dual LED or two single LEDs. */
/*     */
/*    Access to this register is not protected by any locking or access protection algorithm. */
/*     */
/*    IMPORTANT: netX50/100/500 Change Note: */
/*       The netX50/100/500 SYS_STA register was byte accessible. This changed: This register is only 32bit accessible. */
/*       In netx50/100/500, write access to bits 0..15 of SYS_STA register can generate an IRQ to external host CPU. */
/*       As the register now is 32bit accessible only, this is changed to whole register access. I.e. any write */
/*       access to this register will generate an host IRQ if enabled. To change the upper 16 bits of this register without */
/*       host IRQ generation, use register rdy_run_cfg. */
/*     */
/*    Note: */
/*       Changing bits here will also change rdy_run_cfg register bits. */
/*     */
/*    Note: */
/*       Bits 0..3 and 8..15 are read-only-mirrored to DPM/Host Status register dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). */
/*       Read-only bits 4..7 can be programmed by DPM/Host Status register dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). */
/*     */
/*    Note: */
/*       Don't spend too much time in searching a deeper sense in this register. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_status       0x00000090U
#define Adr_NX90_asic_ctrl_netx_status 0xFF401290U
#define Adr_NX90_netx_status           0xFF401290U
#define DFLT_VAL_NX90_netx_status      0x0003f000U

#define MSK_NX90_netx_status_RDY                   0x00000001U
#define SRT_NX90_netx_status_RDY                   0
#define DFLT_VAL_NX90_netx_status_RDY              0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_RDY           0x00000000U
#define MSK_NX90_netx_status_RUN                   0x00000002U
#define SRT_NX90_netx_status_RUN                   1
#define DFLT_VAL_NX90_netx_status_RUN              0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_RUN           0x00000000U
#define MSK_NX90_netx_status_NETX_STATE            0x0000000cU
#define SRT_NX90_netx_status_NETX_STATE            2
#define DFLT_VAL_NX90_netx_status_NETX_STATE       0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_NETX_STATE    0x00000000U
#define MSK_NX90_netx_status_HOST_STATE_ro         0x000000f0U
#define SRT_NX90_netx_status_HOST_STATE_ro         4
#define DFLT_VAL_NX90_netx_status_HOST_STATE_ro    0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_HOST_STATE_ro 0x00000000U
#define MSK_NX90_netx_status_NETX_STA_CODE         0x0000ff00U
#define SRT_NX90_netx_status_NETX_STA_CODE         8
#define DFLT_VAL_NX90_netx_status_NETX_STA_CODE    0x0000f000U
#define DFLT_BF_VAL_NX90_netx_status_NETX_STA_CODE 0x000000f0U
#define MSK_NX90_netx_status_RDY_IN                0x00010000U
#define SRT_NX90_netx_status_RDY_IN                16
#define DFLT_VAL_NX90_netx_status_RDY_IN           0x00010000U
#define DFLT_BF_VAL_NX90_netx_status_RDY_IN        0x00000001U
#define MSK_NX90_netx_status_RUN_IN                0x00020000U
#define SRT_NX90_netx_status_RUN_IN                17
#define DFLT_VAL_NX90_netx_status_RUN_IN           0x00020000U
#define DFLT_BF_VAL_NX90_netx_status_RUN_IN        0x00000001U
#define MSK_NX90_netx_status_RDY_POL               0x00040000U
#define SRT_NX90_netx_status_RDY_POL               18
#define DFLT_VAL_NX90_netx_status_RDY_POL          0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_RDY_POL       0x00000000U
#define MSK_NX90_netx_status_RUN_POL               0x00080000U
#define SRT_NX90_netx_status_RUN_POL               19
#define DFLT_VAL_NX90_netx_status_RUN_POL          0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_RUN_POL       0x00000000U
#define MSK_NX90_netx_status_RDY_DRV               0x01000000U
#define SRT_NX90_netx_status_RDY_DRV               24
#define DFLT_VAL_NX90_netx_status_RDY_DRV          0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_RDY_DRV       0x00000000U
#define MSK_NX90_netx_status_RUN_DRV               0x02000000U
#define SRT_NX90_netx_status_RUN_DRV               25
#define DFLT_VAL_NX90_netx_status_RUN_DRV          0x00000000U
#define DFLT_BF_VAL_NX90_netx_status_RUN_DRV       0x00000000U

/* all used bits of 'NX90_netx_status': */
#define MSK_USED_BITS_NX90_netx_status 0x030fffffU

enum {
  BFW_NX90_netx_status_RDY           = 1, /* [0] */
  BFW_NX90_netx_status_RUN           = 1, /* [1] */
  BFW_NX90_netx_status_NETX_STATE    = 2, /* [3:2] */
  BFW_NX90_netx_status_HOST_STATE_ro = 4, /* [7:4] */
  BFW_NX90_netx_status_NETX_STA_CODE = 8, /* [15:8] */
  BFW_NX90_netx_status_RDY_IN        = 1, /* [16] */
  BFW_NX90_netx_status_RUN_IN        = 1, /* [17] */
  BFW_NX90_netx_status_RDY_POL       = 1, /* [18] */
  BFW_NX90_netx_status_RUN_POL       = 1, /* [19] */
  BFW_NX90_netx_status_reserved1     = 4, /* [23:20] */
  BFW_NX90_netx_status_RDY_DRV       = 1, /* [24] */
  BFW_NX90_netx_status_RUN_DRV       = 1, /* [25] */
  BFW_NX90_netx_status_reserved2     = 6  /* [31:26] */
};

typedef struct NX90_NETX_STATUS_BIT_Ttag {
  unsigned int RDY           : BFW_NX90_netx_status_RDY;           /* Signal level of the RDY LED output.                                             */
                                                                   /* Note:                                                                           */
                                                                   /*    This bit is read-only-mirrored to DPM/Host Status register                   */
                                                                   /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing this bit can produce    */
                                                                   /*    a IRQ to host CPU.                                                           */
  unsigned int RUN           : BFW_NX90_netx_status_RUN;           /* Signal Level of the RUN LED output.                                             */
                                                                   /* Note:                                                                           */
                                                                   /*    This bit is read-only-mirrored to DPM/Host Status register                   */
                                                                   /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing this bit can produce    */
                                                                   /*    a IRQ to host CPU.                                                           */
  unsigned int NETX_STATE    : BFW_NX90_netx_status_NETX_STATE;    /* User defined status bits.                                                       */
                                                                   /* Note:                                                                           */
                                                                   /*    These bits are read-only-mirrored to DPM/Host Status register                */
                                                                   /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing these bits can produce  */
                                                                   /*    a IRQ to host CPU.                                                           */
  unsigned int HOST_STATE_ro : BFW_NX90_netx_status_HOST_STATE_ro; /* Host Status Code.                                                               */
                                                                   /* User defined status is read only here. These bits can be programmed by DPM/Host */
                                                                   /* Status register dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM).                     */
  unsigned int NETX_STA_CODE : BFW_NX90_netx_status_NETX_STA_CODE; /* netX Status Code.                                                               */
                                                                   /* The netX status codes are software defined.                                     */
                                                                   /* The predefined code values are:                                                 */
                                                                   /*    F0h: Status after power on reset.                                            */
                                                                   /* Note:                                                                           */
                                                                   /*    These bits are read-only-mirrored to DPM/Host Status register                */
                                                                   /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing these bits can produce  */
                                                                   /*    a IRQ to host CPU.                                                           */
  unsigned int RDY_IN        : BFW_NX90_netx_status_RDY_IN;        /* Physical input signal level at RDY pin (read-only).                             */
  unsigned int RUN_IN        : BFW_NX90_netx_status_RUN_IN;        /* Physical input signal level at RUN pin (read-only).                             */
  unsigned int RDY_POL       : BFW_NX90_netx_status_RDY_POL;       /* Output polarity RDY LED; outsig = RDY exor RDY_POL.                             */
  unsigned int RUN_POL       : BFW_NX90_netx_status_RUN_POL;       /* Output polarity RUN LED; outsig = RUN exor RUN_POL.                             */
  unsigned int reserved1     : BFW_NX90_netx_status_reserved1;     /* reserved                                                                        */
  unsigned int RDY_DRV       : BFW_NX90_netx_status_RDY_DRV;       /* Driver enable for RDY LED. Enables output driver when set.                      */
  unsigned int RUN_DRV       : BFW_NX90_netx_status_RUN_DRV;       /* Driver enable for RUN LED. Enables output driver when set.                      */
  unsigned int reserved2     : BFW_NX90_netx_status_reserved2;     /* reserved                                                                        */
} NX90_NETX_STATUS_BIT_T;

typedef union {
  uint32_t               val;
  NX90_NETX_STATUS_BIT_T bf;
} NX90_NETX_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register rdy_run_cfg */
/* => netX Legacy RDY/RUN IO System Status Configuration Register. */
/*    RDY/RUN signal programming was implemented in Hilscher HIF module originally. */
/*    From Hilscher Program Reference Guide: The general status of a netX based system is usually indicated by the System LED, which can either */
/*    consist of a dual LED or two single LEDs. */
/*     */
/*    Access to this register is not protected by any locking or access protection algorithm. */
/*     */
/*    Note: */
/*       Use this register to change the upper 16 bits of sys_sta (SYS_STA) register witout */
/*       host IRQ generation. For further information see sys_sta register description. Changing bits here */
/*       will also change sys_sta register bits, however no host IRQ will be generated. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_rdy_run_cfg       0x00000094U
#define Adr_NX90_asic_ctrl_rdy_run_cfg 0xFF401294U
#define Adr_NX90_rdy_run_cfg           0xFF401294U
#define DFLT_VAL_NX90_rdy_run_cfg      0x00030000U

#define MSK_NX90_rdy_run_cfg_RDY             0x00000001U
#define SRT_NX90_rdy_run_cfg_RDY             0
#define DFLT_VAL_NX90_rdy_run_cfg_RDY        0x00000000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RDY     0x00000000U
#define MSK_NX90_rdy_run_cfg_RUN             0x00000002U
#define SRT_NX90_rdy_run_cfg_RUN             1
#define DFLT_VAL_NX90_rdy_run_cfg_RUN        0x00000000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RUN     0x00000000U
#define MSK_NX90_rdy_run_cfg_RDY_IN          0x00010000U
#define SRT_NX90_rdy_run_cfg_RDY_IN          16
#define DFLT_VAL_NX90_rdy_run_cfg_RDY_IN     0x00010000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RDY_IN  0x00000001U
#define MSK_NX90_rdy_run_cfg_RUN_IN          0x00020000U
#define SRT_NX90_rdy_run_cfg_RUN_IN          17
#define DFLT_VAL_NX90_rdy_run_cfg_RUN_IN     0x00020000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RUN_IN  0x00000001U
#define MSK_NX90_rdy_run_cfg_RDY_POL         0x00040000U
#define SRT_NX90_rdy_run_cfg_RDY_POL         18
#define DFLT_VAL_NX90_rdy_run_cfg_RDY_POL    0x00000000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RDY_POL 0x00000000U
#define MSK_NX90_rdy_run_cfg_RUN_POL         0x00080000U
#define SRT_NX90_rdy_run_cfg_RUN_POL         19
#define DFLT_VAL_NX90_rdy_run_cfg_RUN_POL    0x00000000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RUN_POL 0x00000000U
#define MSK_NX90_rdy_run_cfg_RDY_DRV         0x01000000U
#define SRT_NX90_rdy_run_cfg_RDY_DRV         24
#define DFLT_VAL_NX90_rdy_run_cfg_RDY_DRV    0x00000000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RDY_DRV 0x00000000U
#define MSK_NX90_rdy_run_cfg_RUN_DRV         0x02000000U
#define SRT_NX90_rdy_run_cfg_RUN_DRV         25
#define DFLT_VAL_NX90_rdy_run_cfg_RUN_DRV    0x00000000U
#define DFLT_BF_VAL_NX90_rdy_run_cfg_RUN_DRV 0x00000000U

/* all used bits of 'NX90_rdy_run_cfg': */
#define MSK_USED_BITS_NX90_rdy_run_cfg 0x030f0003U

enum {
  BFW_NX90_rdy_run_cfg_RDY       = 1,  /* [0] */
  BFW_NX90_rdy_run_cfg_RUN       = 1,  /* [1] */
  BFW_NX90_rdy_run_cfg_reserved1 = 14, /* [15:2] */
  BFW_NX90_rdy_run_cfg_RDY_IN    = 1,  /* [16] */
  BFW_NX90_rdy_run_cfg_RUN_IN    = 1,  /* [17] */
  BFW_NX90_rdy_run_cfg_RDY_POL   = 1,  /* [18] */
  BFW_NX90_rdy_run_cfg_RUN_POL   = 1,  /* [19] */
  BFW_NX90_rdy_run_cfg_reserved2 = 4,  /* [23:20] */
  BFW_NX90_rdy_run_cfg_RDY_DRV   = 1,  /* [24] */
  BFW_NX90_rdy_run_cfg_RUN_DRV   = 1,  /* [25] */
  BFW_NX90_rdy_run_cfg_reserved3 = 6   /* [31:26] */
};

typedef struct NX90_RDY_RUN_CFG_BIT_Ttag {
  unsigned int RDY       : BFW_NX90_rdy_run_cfg_RDY;       /* Signal level of the RDY LED output.                        */
  unsigned int RUN       : BFW_NX90_rdy_run_cfg_RUN;       /* Signal Level of the RUN LED output.                        */
  unsigned int reserved1 : BFW_NX90_rdy_run_cfg_reserved1; /* reserved                                                   */
  unsigned int RDY_IN    : BFW_NX90_rdy_run_cfg_RDY_IN;    /* Physical input signal level at RDY pin (read-only).        */
  unsigned int RUN_IN    : BFW_NX90_rdy_run_cfg_RUN_IN;    /* Physical input signal level at RUN pin (read-only).        */
  unsigned int RDY_POL   : BFW_NX90_rdy_run_cfg_RDY_POL;   /* Output polarity RDY LED; outsig = RDY exor RDY_POL.        */
  unsigned int RUN_POL   : BFW_NX90_rdy_run_cfg_RUN_POL;   /* Output polarity RUN LED; outsig = RUN exor RUN_POL.        */
  unsigned int reserved2 : BFW_NX90_rdy_run_cfg_reserved2; /* reserved                                                   */
  unsigned int RDY_DRV   : BFW_NX90_rdy_run_cfg_RDY_DRV;   /* Driver enable for RDY LED. Enables output driver when set. */
  unsigned int RUN_DRV   : BFW_NX90_rdy_run_cfg_RUN_DRV;   /* Driver enable for RUN LED. Enables output driver when set. */
  unsigned int reserved3 : BFW_NX90_rdy_run_cfg_reserved3; /* reserved                                                   */
} NX90_RDY_RUN_CFG_BIT_T;

typedef union {
  uint32_t               val;
  NX90_RDY_RUN_CFG_BIT_T bf;
} NX90_RDY_RUN_CFG_T;

/* --------------------------------------------------------------------- */
/* Register firewall_cfg_hifmem_sdram */
/* => Firewall configuration register for the HIFMEM_SDRAM NETX AHB channel. */
/*     */
/*    IMPORTANT: */
/*      Changing permissions must not be done while any master accesses the slave protected by this register. */
/*      If permissions are changed during an access a whole system lockup could occur. */
/*     */
/*    Note: */
/*      APP-side masters are: DPM0, DPM1, XC01, XPIC_COM, ARM_COM, DMAC_COM. */
/*      COM-side masters are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP. */
/*      Other masters which cannot be filtered but globally disabled are: IPC_MASTER, DEBUG_MASTER. */
/*    Note: */
/*      A denied write access will be ignored. */
/*      A denied read access will return unpredictable data. */
/*      A denied access will generate an ERROR-response (abort) if the appropriate abort_en-bit is set. */
/*      A denied access will generate an interrupt in the ASIC_CTRL IRQ registers, which is maskable there. */
/*    Note: */
/*      This register can be locked to protect it from reconfiguration by ASIC_CTRL_COM-netx_lock-lock_firewall. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_firewall_cfg_hifmem_sdram       0x00000098U
#define Adr_NX90_asic_ctrl_firewall_cfg_hifmem_sdram 0xFF401298U
#define Adr_NX90_firewall_cfg_hifmem_sdram           0xFF401298U
#define DFLT_VAL_NX90_firewall_cfg_hifmem_sdram      0x00000033U

#define MSK_NX90_firewall_cfg_hifmem_sdram_wp_com               0x00000001U
#define SRT_NX90_firewall_cfg_hifmem_sdram_wp_com               0
#define DFLT_VAL_NX90_firewall_cfg_hifmem_sdram_wp_com          0x00000001U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_sdram_wp_com       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_sdram_wp_app               0x00000002U
#define SRT_NX90_firewall_cfg_hifmem_sdram_wp_app               1
#define DFLT_VAL_NX90_firewall_cfg_hifmem_sdram_wp_app          0x00000002U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_sdram_wp_app       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_sdram_rp_com               0x00000010U
#define SRT_NX90_firewall_cfg_hifmem_sdram_rp_com               4
#define DFLT_VAL_NX90_firewall_cfg_hifmem_sdram_rp_com          0x00000010U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_sdram_rp_com       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_sdram_rp_app               0x00000020U
#define SRT_NX90_firewall_cfg_hifmem_sdram_rp_app               5
#define DFLT_VAL_NX90_firewall_cfg_hifmem_sdram_rp_app          0x00000020U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_sdram_rp_app       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_sdram_abort_en_com         0x00000100U
#define SRT_NX90_firewall_cfg_hifmem_sdram_abort_en_com         8
#define DFLT_VAL_NX90_firewall_cfg_hifmem_sdram_abort_en_com    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_sdram_abort_en_com 0x00000000U
#define MSK_NX90_firewall_cfg_hifmem_sdram_abort_en_app         0x00000200U
#define SRT_NX90_firewall_cfg_hifmem_sdram_abort_en_app         9
#define DFLT_VAL_NX90_firewall_cfg_hifmem_sdram_abort_en_app    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_sdram_abort_en_app 0x00000000U

/* all used bits of 'NX90_firewall_cfg_hifmem_sdram': */
#define MSK_USED_BITS_NX90_firewall_cfg_hifmem_sdram 0x00000333U

enum {
  BFW_NX90_firewall_cfg_hifmem_sdram_wp_com       = 1,  /* [0] */
  BFW_NX90_firewall_cfg_hifmem_sdram_wp_app       = 1,  /* [1] */
  BFW_NX90_firewall_cfg_hifmem_sdram_reserved1    = 2,  /* [3:2] */
  BFW_NX90_firewall_cfg_hifmem_sdram_rp_com       = 1,  /* [4] */
  BFW_NX90_firewall_cfg_hifmem_sdram_rp_app       = 1,  /* [5] */
  BFW_NX90_firewall_cfg_hifmem_sdram_reserved2    = 2,  /* [7:6] */
  BFW_NX90_firewall_cfg_hifmem_sdram_abort_en_com = 1,  /* [8] */
  BFW_NX90_firewall_cfg_hifmem_sdram_abort_en_app = 1,  /* [9] */
  BFW_NX90_firewall_cfg_hifmem_sdram_reserved3    = 22  /* [31:10] */
};

typedef struct NX90_FIREWALL_CFG_HIFMEM_SDRAM_BIT_Ttag {
  unsigned int wp_com       : BFW_NX90_firewall_cfg_hifmem_sdram_wp_com;       /* write permission for COM side masters.                                  */
                                                                               /*   1: permit write access.                                               */
                                                                               /*   0: deny write access.                                                 */
  unsigned int wp_app       : BFW_NX90_firewall_cfg_hifmem_sdram_wp_app;       /* write permission for APP side masters                                   */
  unsigned int reserved1    : BFW_NX90_firewall_cfg_hifmem_sdram_reserved1;    /* reserved                                                                */
  unsigned int rp_com       : BFW_NX90_firewall_cfg_hifmem_sdram_rp_com;       /* read permission for COM side masters.                                   */
                                                                               /*   1: permit read access.                                                */
                                                                               /*   0: deny read access.                                                  */
  unsigned int rp_app       : BFW_NX90_firewall_cfg_hifmem_sdram_rp_app;       /* read permission for APP side masters.                                   */
  unsigned int reserved2    : BFW_NX90_firewall_cfg_hifmem_sdram_reserved2;    /* reserved                                                                */
  unsigned int abort_en_com : BFW_NX90_firewall_cfg_hifmem_sdram_abort_en_com; /* TBD: abort enable for COM side masters for denied accesss               */
                                                                               /*   1: ERROR response to COM side masters on denied access                */
                                                                               /*   0: no ERROR response to COM side masters.                             */
                                                                               /* Note:                                                                   */
                                                                               /*    Only the following COM-side masters support ERROR-response handling: */
                                                                               /*    ARM_COM, DMAC_COM                                                    */
  unsigned int abort_en_app : BFW_NX90_firewall_cfg_hifmem_sdram_abort_en_app; /* TBD: abort enable for APP side masters                                  */
                                                                               /* Note:                                                                   */
                                                                               /*    Only the following COM-side masters support ERROR-response handling: */
                                                                               /*    ARM_APP, DMAC_APP                                                    */
  unsigned int reserved3    : BFW_NX90_firewall_cfg_hifmem_sdram_reserved3;    /* reserved                                                                */
} NX90_FIREWALL_CFG_HIFMEM_SDRAM_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_FIREWALL_CFG_HIFMEM_SDRAM_BIT_T bf;
} NX90_FIREWALL_CFG_HIFMEM_SDRAM_T;

/* --------------------------------------------------------------------- */
/* Register firewall_cfg_hifmem_amem */
/* => Firewall configuration register for the HIFMEM_AMEM NETX AHB channel. */
/*     */
/*    IMPORTANT: */
/*      Changing permissions must not be done while any master accesses the slave protected by this register. */
/*      If permissions are changed during an access a whole system lockup could occur. */
/*     */
/*    Note: */
/*      APP-side masters are: DPM0, DPM1, XC01, XPIC_COM, ARM_COM, DMAC_COM. */
/*      COM-side masters are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP. */
/*      Other masters which cannot be filtered but globally disabled are: IPC_MASTER, DEBUG_MASTER. */
/*    Note: */
/*      A denied write access will be ignored. */
/*      A denied read access will return unpredictable data. */
/*      A denied access will generate an ERROR-response (abort) if the appropriate abort_en-bit is set. */
/*      A denied access will generate an interrupt in the ASIC_CTRL IRQ registers, which is maskable there. */
/*    Note: */
/*      This register can be locked to protect it from reconfiguration by ASIC_CTRL_COM-netx_lock-lock_firewall. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_firewall_cfg_hifmem_amem       0x0000009CU
#define Adr_NX90_asic_ctrl_firewall_cfg_hifmem_amem 0xFF40129CU
#define Adr_NX90_firewall_cfg_hifmem_amem           0xFF40129CU
#define DFLT_VAL_NX90_firewall_cfg_hifmem_amem      0x00000033U

#define MSK_NX90_firewall_cfg_hifmem_amem_wp_com               0x00000001U
#define SRT_NX90_firewall_cfg_hifmem_amem_wp_com               0
#define DFLT_VAL_NX90_firewall_cfg_hifmem_amem_wp_com          0x00000001U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_amem_wp_com       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_amem_wp_app               0x00000002U
#define SRT_NX90_firewall_cfg_hifmem_amem_wp_app               1
#define DFLT_VAL_NX90_firewall_cfg_hifmem_amem_wp_app          0x00000002U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_amem_wp_app       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_amem_rp_com               0x00000010U
#define SRT_NX90_firewall_cfg_hifmem_amem_rp_com               4
#define DFLT_VAL_NX90_firewall_cfg_hifmem_amem_rp_com          0x00000010U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_amem_rp_com       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_amem_rp_app               0x00000020U
#define SRT_NX90_firewall_cfg_hifmem_amem_rp_app               5
#define DFLT_VAL_NX90_firewall_cfg_hifmem_amem_rp_app          0x00000020U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_amem_rp_app       0x00000001U
#define MSK_NX90_firewall_cfg_hifmem_amem_abort_en_com         0x00000100U
#define SRT_NX90_firewall_cfg_hifmem_amem_abort_en_com         8
#define DFLT_VAL_NX90_firewall_cfg_hifmem_amem_abort_en_com    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_amem_abort_en_com 0x00000000U
#define MSK_NX90_firewall_cfg_hifmem_amem_abort_en_app         0x00000200U
#define SRT_NX90_firewall_cfg_hifmem_amem_abort_en_app         9
#define DFLT_VAL_NX90_firewall_cfg_hifmem_amem_abort_en_app    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_hifmem_amem_abort_en_app 0x00000000U

/* all used bits of 'NX90_firewall_cfg_hifmem_amem': */
#define MSK_USED_BITS_NX90_firewall_cfg_hifmem_amem 0x00000333U

enum {
  BFW_NX90_firewall_cfg_hifmem_amem_wp_com       = 1,  /* [0] */
  BFW_NX90_firewall_cfg_hifmem_amem_wp_app       = 1,  /* [1] */
  BFW_NX90_firewall_cfg_hifmem_amem_reserved1    = 2,  /* [3:2] */
  BFW_NX90_firewall_cfg_hifmem_amem_rp_com       = 1,  /* [4] */
  BFW_NX90_firewall_cfg_hifmem_amem_rp_app       = 1,  /* [5] */
  BFW_NX90_firewall_cfg_hifmem_amem_reserved2    = 2,  /* [7:6] */
  BFW_NX90_firewall_cfg_hifmem_amem_abort_en_com = 1,  /* [8] */
  BFW_NX90_firewall_cfg_hifmem_amem_abort_en_app = 1,  /* [9] */
  BFW_NX90_firewall_cfg_hifmem_amem_reserved3    = 22  /* [31:10] */
};

typedef struct NX90_FIREWALL_CFG_HIFMEM_AMEM_BIT_Ttag {
  unsigned int wp_com       : BFW_NX90_firewall_cfg_hifmem_amem_wp_com;       /* write permission for COM side masters.                                  */
                                                                              /*   1: permit write access.                                               */
                                                                              /*   0: deny write access.                                                 */
  unsigned int wp_app       : BFW_NX90_firewall_cfg_hifmem_amem_wp_app;       /* write permission for APP side masters                                   */
  unsigned int reserved1    : BFW_NX90_firewall_cfg_hifmem_amem_reserved1;    /* reserved                                                                */
  unsigned int rp_com       : BFW_NX90_firewall_cfg_hifmem_amem_rp_com;       /* read permission for COM side masters.                                   */
                                                                              /*   1: permit read access.                                                */
                                                                              /*   0: deny read access.                                                  */
  unsigned int rp_app       : BFW_NX90_firewall_cfg_hifmem_amem_rp_app;       /* read permission for APP side masters.                                   */
  unsigned int reserved2    : BFW_NX90_firewall_cfg_hifmem_amem_reserved2;    /* reserved                                                                */
  unsigned int abort_en_com : BFW_NX90_firewall_cfg_hifmem_amem_abort_en_com; /* TBD: abort enable for COM side masters for denied accesss               */
                                                                              /*   1: ERROR response to COM side masters on denied access                */
                                                                              /*   0: no ERROR response to COM side masters.                             */
                                                                              /* Note:                                                                   */
                                                                              /*    Only the following COM-side masters support ERROR-response handling: */
                                                                              /*    ARM_COM, DMAC_COM                                                    */
  unsigned int abort_en_app : BFW_NX90_firewall_cfg_hifmem_amem_abort_en_app; /* TBD: abort enable for APP side masters                                  */
                                                                              /* Note:                                                                   */
                                                                              /*    Only the following COM-side masters support ERROR-response handling: */
                                                                              /*    ARM_APP, DMAC_APP                                                    */
  unsigned int reserved3    : BFW_NX90_firewall_cfg_hifmem_amem_reserved3;    /* reserved                                                                */
} NX90_FIREWALL_CFG_HIFMEM_AMEM_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_FIREWALL_CFG_HIFMEM_AMEM_BIT_T bf;
} NX90_FIREWALL_CFG_HIFMEM_AMEM_T;

/* --------------------------------------------------------------------- */
/* Register firewall_cfg_sqirom */
/* => Firewall configuration register for the SQIROM NETX AHB channel. */
/*     */
/*    IMPORTANT: */
/*      Changing permissions must not be done while any master accesses the slave protected by this register. */
/*      If permissions are changed during an access a whole system lockup could occur. */
/*     */
/*    Note: */
/*      APP-side masters are: DPM0, DPM1, XC01, XPIC_COM, ARM_COM, DMAC_COM. */
/*      COM-side masters are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP. */
/*      Other masters which cannot be filtered but globally disabled are: IPC_MASTER, DEBUG_MASTER. */
/*    Note: */
/*      A denied write access will be ignored. */
/*      A denied read access will return unpredictable data. */
/*      A denied access will generate an ERROR-response (abort) if the appropriate abort_en-bit is set. */
/*      A denied access will generate an interrupt in the ASIC_CTRL IRQ registers, which is maskable there. */
/*    Note: */
/*      This register can be locked to protect it from reconfiguration by ASIC_CTRL_COM-netx_lock-lock_firewall. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_firewall_cfg_sqirom       0x000000A0U
#define Adr_NX90_asic_ctrl_firewall_cfg_sqirom 0xFF4012A0U
#define Adr_NX90_firewall_cfg_sqirom           0xFF4012A0U
#define DFLT_VAL_NX90_firewall_cfg_sqirom      0x00000033U

#define MSK_NX90_firewall_cfg_sqirom_wp_com               0x00000001U
#define SRT_NX90_firewall_cfg_sqirom_wp_com               0
#define DFLT_VAL_NX90_firewall_cfg_sqirom_wp_com          0x00000001U
#define DFLT_BF_VAL_NX90_firewall_cfg_sqirom_wp_com       0x00000001U
#define MSK_NX90_firewall_cfg_sqirom_wp_app               0x00000002U
#define SRT_NX90_firewall_cfg_sqirom_wp_app               1
#define DFLT_VAL_NX90_firewall_cfg_sqirom_wp_app          0x00000002U
#define DFLT_BF_VAL_NX90_firewall_cfg_sqirom_wp_app       0x00000001U
#define MSK_NX90_firewall_cfg_sqirom_rp_com               0x00000010U
#define SRT_NX90_firewall_cfg_sqirom_rp_com               4
#define DFLT_VAL_NX90_firewall_cfg_sqirom_rp_com          0x00000010U
#define DFLT_BF_VAL_NX90_firewall_cfg_sqirom_rp_com       0x00000001U
#define MSK_NX90_firewall_cfg_sqirom_rp_app               0x00000020U
#define SRT_NX90_firewall_cfg_sqirom_rp_app               5
#define DFLT_VAL_NX90_firewall_cfg_sqirom_rp_app          0x00000020U
#define DFLT_BF_VAL_NX90_firewall_cfg_sqirom_rp_app       0x00000001U
#define MSK_NX90_firewall_cfg_sqirom_abort_en_com         0x00000100U
#define SRT_NX90_firewall_cfg_sqirom_abort_en_com         8
#define DFLT_VAL_NX90_firewall_cfg_sqirom_abort_en_com    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_sqirom_abort_en_com 0x00000000U
#define MSK_NX90_firewall_cfg_sqirom_abort_en_app         0x00000200U
#define SRT_NX90_firewall_cfg_sqirom_abort_en_app         9
#define DFLT_VAL_NX90_firewall_cfg_sqirom_abort_en_app    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_sqirom_abort_en_app 0x00000000U

/* all used bits of 'NX90_firewall_cfg_sqirom': */
#define MSK_USED_BITS_NX90_firewall_cfg_sqirom 0x00000333U

enum {
  BFW_NX90_firewall_cfg_sqirom_wp_com       = 1,  /* [0] */
  BFW_NX90_firewall_cfg_sqirom_wp_app       = 1,  /* [1] */
  BFW_NX90_firewall_cfg_sqirom_reserved1    = 2,  /* [3:2] */
  BFW_NX90_firewall_cfg_sqirom_rp_com       = 1,  /* [4] */
  BFW_NX90_firewall_cfg_sqirom_rp_app       = 1,  /* [5] */
  BFW_NX90_firewall_cfg_sqirom_reserved2    = 2,  /* [7:6] */
  BFW_NX90_firewall_cfg_sqirom_abort_en_com = 1,  /* [8] */
  BFW_NX90_firewall_cfg_sqirom_abort_en_app = 1,  /* [9] */
  BFW_NX90_firewall_cfg_sqirom_reserved3    = 22  /* [31:10] */
};

typedef struct NX90_FIREWALL_CFG_SQIROM_BIT_Ttag {
  unsigned int wp_com       : BFW_NX90_firewall_cfg_sqirom_wp_com;       /* write permission for COM side masters.                                  */
                                                                         /*   1: permit write access.                                               */
                                                                         /*   0: deny write access.                                                 */
  unsigned int wp_app       : BFW_NX90_firewall_cfg_sqirom_wp_app;       /* write permission for APP side masters                                   */
  unsigned int reserved1    : BFW_NX90_firewall_cfg_sqirom_reserved1;    /* reserved                                                                */
  unsigned int rp_com       : BFW_NX90_firewall_cfg_sqirom_rp_com;       /* read permission for COM side masters.                                   */
                                                                         /*   1: permit read access.                                                */
                                                                         /*   0: deny read access.                                                  */
  unsigned int rp_app       : BFW_NX90_firewall_cfg_sqirom_rp_app;       /* read permission for APP side masters.                                   */
  unsigned int reserved2    : BFW_NX90_firewall_cfg_sqirom_reserved2;    /* reserved                                                                */
  unsigned int abort_en_com : BFW_NX90_firewall_cfg_sqirom_abort_en_com; /* TBD: abort enable for COM side masters for denied accesss               */
                                                                         /*   1: ERROR response to COM side masters on denied access                */
                                                                         /*   0: no ERROR response to COM side masters.                             */
                                                                         /* Note:                                                                   */
                                                                         /*    Only the following COM-side masters support ERROR-response handling: */
                                                                         /*    ARM_COM, DMAC_COM                                                    */
  unsigned int abort_en_app : BFW_NX90_firewall_cfg_sqirom_abort_en_app; /* TBD: abort enable for APP side masters                                  */
                                                                         /* Note:                                                                   */
                                                                         /*    Only the following COM-side masters support ERROR-response handling: */
                                                                         /*    ARM_APP, DMAC_APP                                                    */
  unsigned int reserved3    : BFW_NX90_firewall_cfg_sqirom_reserved3;    /* reserved                                                                */
} NX90_FIREWALL_CFG_SQIROM_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_FIREWALL_CFG_SQIROM_BIT_T bf;
} NX90_FIREWALL_CFG_SQIROM_T;

/* --------------------------------------------------------------------- */
/* Register firewall_cfg_crypt */
/* => Firewall configuration register for the CRYPT NETX AHB channel. */
/*     */
/*    IMPORTANT: */
/*      Changing permissions must not be done while any master accesses the slave protected by this register. */
/*      If permissions are changed during an access a whole system lockup could occur. */
/*     */
/*    Note: */
/*      APP-side masters are: DPM0, DPM1, XC01, XPIC_COM, ARM_COM, DMAC_COM. */
/*      COM-side masters are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP. */
/*      Other masters which cannot be filtered but globally disabled are: IPC_MASTER, DEBUG_MASTER. */
/*    Note: */
/*      A denied write access will be ignored. */
/*      A denied read access will return unpredictable data. */
/*      A denied access will generate an ERROR-response (abort) if the appropriate abort_en-bit is set. */
/*      A denied access will generate an interrupt in the ASIC_CTRL IRQ registers, which is maskable there. */
/*    Note: */
/*      This register can be locked to protect it from reconfiguration by ASIC_CTRL_COM-netx_lock-lock_firewall. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_firewall_cfg_crypt       0x000000A4U
#define Adr_NX90_asic_ctrl_firewall_cfg_crypt 0xFF4012A4U
#define Adr_NX90_firewall_cfg_crypt           0xFF4012A4U
#define DFLT_VAL_NX90_firewall_cfg_crypt      0x00000033U

#define MSK_NX90_firewall_cfg_crypt_wp_com               0x00000001U
#define SRT_NX90_firewall_cfg_crypt_wp_com               0
#define DFLT_VAL_NX90_firewall_cfg_crypt_wp_com          0x00000001U
#define DFLT_BF_VAL_NX90_firewall_cfg_crypt_wp_com       0x00000001U
#define MSK_NX90_firewall_cfg_crypt_wp_app               0x00000002U
#define SRT_NX90_firewall_cfg_crypt_wp_app               1
#define DFLT_VAL_NX90_firewall_cfg_crypt_wp_app          0x00000002U
#define DFLT_BF_VAL_NX90_firewall_cfg_crypt_wp_app       0x00000001U
#define MSK_NX90_firewall_cfg_crypt_rp_com               0x00000010U
#define SRT_NX90_firewall_cfg_crypt_rp_com               4
#define DFLT_VAL_NX90_firewall_cfg_crypt_rp_com          0x00000010U
#define DFLT_BF_VAL_NX90_firewall_cfg_crypt_rp_com       0x00000001U
#define MSK_NX90_firewall_cfg_crypt_rp_app               0x00000020U
#define SRT_NX90_firewall_cfg_crypt_rp_app               5
#define DFLT_VAL_NX90_firewall_cfg_crypt_rp_app          0x00000020U
#define DFLT_BF_VAL_NX90_firewall_cfg_crypt_rp_app       0x00000001U
#define MSK_NX90_firewall_cfg_crypt_abort_en_com         0x00000100U
#define SRT_NX90_firewall_cfg_crypt_abort_en_com         8
#define DFLT_VAL_NX90_firewall_cfg_crypt_abort_en_com    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_crypt_abort_en_com 0x00000000U
#define MSK_NX90_firewall_cfg_crypt_abort_en_app         0x00000200U
#define SRT_NX90_firewall_cfg_crypt_abort_en_app         9
#define DFLT_VAL_NX90_firewall_cfg_crypt_abort_en_app    0x00000000U
#define DFLT_BF_VAL_NX90_firewall_cfg_crypt_abort_en_app 0x00000000U

/* all used bits of 'NX90_firewall_cfg_crypt': */
#define MSK_USED_BITS_NX90_firewall_cfg_crypt 0x00000333U

enum {
  BFW_NX90_firewall_cfg_crypt_wp_com       = 1,  /* [0] */
  BFW_NX90_firewall_cfg_crypt_wp_app       = 1,  /* [1] */
  BFW_NX90_firewall_cfg_crypt_reserved1    = 2,  /* [3:2] */
  BFW_NX90_firewall_cfg_crypt_rp_com       = 1,  /* [4] */
  BFW_NX90_firewall_cfg_crypt_rp_app       = 1,  /* [5] */
  BFW_NX90_firewall_cfg_crypt_reserved2    = 2,  /* [7:6] */
  BFW_NX90_firewall_cfg_crypt_abort_en_com = 1,  /* [8] */
  BFW_NX90_firewall_cfg_crypt_abort_en_app = 1,  /* [9] */
  BFW_NX90_firewall_cfg_crypt_reserved3    = 22  /* [31:10] */
};

typedef struct NX90_FIREWALL_CFG_CRYPT_BIT_Ttag {
  unsigned int wp_com       : BFW_NX90_firewall_cfg_crypt_wp_com;       /* write permission for COM side masters.                                  */
                                                                        /*   1: permit write access.                                               */
                                                                        /*   0: deny write access.                                                 */
  unsigned int wp_app       : BFW_NX90_firewall_cfg_crypt_wp_app;       /* write permission for APP side masters                                   */
  unsigned int reserved1    : BFW_NX90_firewall_cfg_crypt_reserved1;    /* reserved                                                                */
  unsigned int rp_com       : BFW_NX90_firewall_cfg_crypt_rp_com;       /* read permission for COM side masters.                                   */
                                                                        /*   1: permit read access.                                                */
                                                                        /*   0: deny read access.                                                  */
  unsigned int rp_app       : BFW_NX90_firewall_cfg_crypt_rp_app;       /* read permission for APP side masters.                                   */
  unsigned int reserved2    : BFW_NX90_firewall_cfg_crypt_reserved2;    /* reserved                                                                */
  unsigned int abort_en_com : BFW_NX90_firewall_cfg_crypt_abort_en_com; /* TBD: abort enable for COM side masters for denied accesss               */
                                                                        /*   1: ERROR response to COM side masters on denied access                */
                                                                        /*   0: no ERROR response to COM side masters.                             */
                                                                        /* Note:                                                                   */
                                                                        /*    Only the following COM-side masters support ERROR-response handling: */
                                                                        /*    ARM_COM, DMAC_COM                                                    */
  unsigned int abort_en_app : BFW_NX90_firewall_cfg_crypt_abort_en_app; /* TBD: abort enable for APP side masters                                  */
                                                                        /* Note:                                                                   */
                                                                        /*    Only the following COM-side masters support ERROR-response handling: */
                                                                        /*    ARM_APP, DMAC_APP                                                    */
  unsigned int reserved3    : BFW_NX90_firewall_cfg_crypt_reserved3;    /* reserved                                                                */
} NX90_FIREWALL_CFG_CRYPT_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_FIREWALL_CFG_CRYPT_BIT_T bf;
} NX90_FIREWALL_CFG_CRYPT_T;

/* --------------------------------------------------------------------- */
/* Register misc_asic_ctrl */
/* => TBD: anpassen/ausbauen */
/*    Miscellaneous ASIC Control Register: */
/*    This register is lockable by asic_ctrl_com_netx_lock-lock_register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_misc_asic_ctrl       0x000000A8U
#define Adr_NX90_asic_ctrl_misc_asic_ctrl 0xFF4012A8U
#define Adr_NX90_misc_asic_ctrl           0xFF4012A8U
#define DFLT_VAL_NX90_misc_asic_ctrl      0x00000000U

#define MSK_NX90_misc_asic_ctrl_lic_err_taint_en         0x00000001U
#define SRT_NX90_misc_asic_ctrl_lic_err_taint_en         0
#define DFLT_VAL_NX90_misc_asic_ctrl_lic_err_taint_en    0x00000000U
#define DFLT_BF_VAL_NX90_misc_asic_ctrl_lic_err_taint_en 0x00000000U
#define MSK_NX90_misc_asic_ctrl_lic_err_abort_en         0x00000002U
#define SRT_NX90_misc_asic_ctrl_lic_err_abort_en         1
#define DFLT_VAL_NX90_misc_asic_ctrl_lic_err_abort_en    0x00000000U
#define DFLT_BF_VAL_NX90_misc_asic_ctrl_lic_err_abort_en 0x00000000U
#define MSK_NX90_misc_asic_ctrl_lic_err_irq_en           0x00000004U
#define SRT_NX90_misc_asic_ctrl_lic_err_irq_en           2
#define DFLT_VAL_NX90_misc_asic_ctrl_lic_err_irq_en      0x00000000U
#define DFLT_BF_VAL_NX90_misc_asic_ctrl_lic_err_irq_en   0x00000000U
#define MSK_NX90_misc_asic_ctrl_lic_err_delay_en         0x00000008U
#define SRT_NX90_misc_asic_ctrl_lic_err_delay_en         3
#define DFLT_VAL_NX90_misc_asic_ctrl_lic_err_delay_en    0x00000000U
#define DFLT_BF_VAL_NX90_misc_asic_ctrl_lic_err_delay_en 0x00000000U

/* all used bits of 'NX90_misc_asic_ctrl': */
#define MSK_USED_BITS_NX90_misc_asic_ctrl 0x0000000fU

enum {
  BFW_NX90_misc_asic_ctrl_lic_err_taint_en = 1,  /* [0] */
  BFW_NX90_misc_asic_ctrl_lic_err_abort_en = 1,  /* [1] */
  BFW_NX90_misc_asic_ctrl_lic_err_irq_en   = 1,  /* [2] */
  BFW_NX90_misc_asic_ctrl_lic_err_delay_en = 1,  /* [3] */
  BFW_NX90_misc_asic_ctrl_reserved1        = 28  /* [31:4] */
};

typedef struct NX90_MISC_ASIC_CTRL_BIT_Ttag {
  unsigned int lic_err_taint_en : BFW_NX90_misc_asic_ctrl_lic_err_taint_en; /* In case of a detected license error, system clock will be reduced to 80MHz                                                    */
                                                                            /* Tainted mode can be left when this bit is disabled or at unprotected phase after power-on-reset by a valid LICCHECK sequence. */
  unsigned int lic_err_abort_en : BFW_NX90_misc_asic_ctrl_lic_err_abort_en; /* In case of a detected license error, ARM-Abort will be generated on the next data write (no data loss caused)                 */
  unsigned int lic_err_irq_en   : BFW_NX90_misc_asic_ctrl_lic_err_irq_en;   /* In case of a detected license error, ARM-IRQ will be generated                                                                */
  unsigned int lic_err_delay_en : BFW_NX90_misc_asic_ctrl_lic_err_delay_en; /* Random Delay between a detected license error and abort-generation/change to tainted mode                                     */
  unsigned int reserved1        : BFW_NX90_misc_asic_ctrl_reserved1;        /* reserved                                                                                                                      */
} NX90_MISC_ASIC_CTRL_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_MISC_ASIC_CTRL_BIT_T bf;
} NX90_MISC_ASIC_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register asic_ctrl_access_key */
/* => ASIC Control Locking access-key Register: */
/*    Writing to any register in the asic_ctrl or mmio_ctrl address area is only possible after */
/*    setting the correct key here to avoid unmeant changes e.g. by crashed software. */
/*    ---- */
/*    Changing a control register in the asic_ctrl or mmio_ctrl address area is only possible by the following sequence: */
/*    1.: Read out the Locking access-key from this register. */
/*    2.: Write back this Locking access-key to this register. */
/*    3.: Write desired value to the control register. */
/*    ---- */
/*    The Locking access-key will become invalid after each access to any register in the asic_ctrl or mmio_ctrl address area */
/*    and has to be read out and set again for sequent accesses. */
/*     */
/*    Note: */
/*       Since netX51/52 there are 3 separated instances of access-key-protection logic: One for ARM, one for xPIC and */
/*       one shared by all other netX system masters. That allows ARM and XPIC running access-key read-write sequence */
/*       and configuration access without any synchronisation or locking completely independent. Before netX51/52 a sequence */
/*       started by one master (e.g. ARM) became invalid when interrupted by another master (e.g. xPIC). That was changed: ARM */
/*       and xPIC are able to remove protection without being influenced by each other (or by any other master). Once a */
/*       access-key-sequence was performed protected configuration registers are only writable for the master which performed */
/*       it. */
/*       To allow access to protected register for other masters (e.g. XPECs or SYSDEBUG) the third instance of */
/*       access-key-protection logic is implemented. This is shared by all masters except ARM and xPIC. When more */
/*       than one of these masters should use this, locking must be done in software to avoid sequence of one master */
/*       being interrupted by another. */
/*       Access-key read and write address is the same for all masters. However, ARM-key is only readable or writable by ARM, xPIC-key */
/*       only by xPIC and shared key only by all other masters but never by ARM or xPIC. */
/*     */
/*    Note: */
/*       netX4000 has separate access-keys for the following CPUs: CR7, CA9, SYSDEBUG, xPIC0, xPIC1, xPIC2, xPIC3. All other masters */
/*       use the shared key. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_asic_ctrl_access_key       0x000000C0U
#define Adr_NX90_asic_ctrl_asic_ctrl_access_key 0xFF4012C0U
#define Adr_NX90_asic_ctrl_access_key           0xFF4012C0U
#define DFLT_VAL_NX90_asic_ctrl_access_key      0x00000000U

#define MSK_NX90_asic_ctrl_access_key_access_key         0x0000ffffU
#define SRT_NX90_asic_ctrl_access_key_access_key         0
#define DFLT_VAL_NX90_asic_ctrl_access_key_access_key    0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_access_key_access_key 0x00000000U

/* all used bits of 'NX90_asic_ctrl_access_key': */
#define MSK_USED_BITS_NX90_asic_ctrl_access_key 0x0000ffffU

enum {
  BFW_NX90_asic_ctrl_access_key_access_key = 16, /* [15:0] */
  BFW_NX90_asic_ctrl_access_key_reserved1  = 16  /* [31:16] */
};

typedef struct NX90_ASIC_CTRL_ACCESS_KEY_BIT_Ttag {
  unsigned int access_key : BFW_NX90_asic_ctrl_access_key_access_key; /* Locking access-key for next write access. */
  unsigned int reserved1  : BFW_NX90_asic_ctrl_access_key_reserved1;  /* reserved                                  */
} NX90_ASIC_CTRL_ACCESS_KEY_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_ASIC_CTRL_ACCESS_KEY_BIT_T bf;
} NX90_ASIC_CTRL_ACCESS_KEY_T;

/* --------------------------------------------------------------------- */
/* Register asic_ctrl_irq_raw */
/* => ASIC_CTRL raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_asic_ctrl_irq_raw       0x000000C8U
#define Adr_NX90_asic_ctrl_asic_ctrl_irq_raw 0xFF4012C8U
#define Adr_NX90_asic_ctrl_irq_raw           0xFF4012C8U
#define DFLT_VAL_NX90_asic_ctrl_irq_raw      0x00000000U

#define MSK_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_com         0x00000001U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_com         0
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_com    0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_com 0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_app         0x00000002U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_app         1
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_app    0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_app 0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_com          0x00000004U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_com          2
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_com     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_com  0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_app          0x00000008U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_app          3
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_app     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_app  0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_firewall_sqirom_com               0x00000010U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_sqirom_com               4
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_sqirom_com          0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_sqirom_com       0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_firewall_sqirom_app               0x00000020U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_sqirom_app               5
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_sqirom_app          0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_sqirom_app       0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_firewall_crypt_com                0x00000040U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_crypt_com                6
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_crypt_com           0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_crypt_com        0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_firewall_crypt_app                0x00000080U
#define SRT_NX90_asic_ctrl_irq_raw_firewall_crypt_app                7
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_firewall_crypt_app           0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_firewall_crypt_app        0x00000000U
#define MSK_NX90_asic_ctrl_irq_raw_bod_fail                          0x00000100U
#define SRT_NX90_asic_ctrl_irq_raw_bod_fail                          8
#define DFLT_VAL_NX90_asic_ctrl_irq_raw_bod_fail                     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_raw_bod_fail                  0x00000000U

/* all used bits of 'NX90_asic_ctrl_irq_raw': */
#define MSK_USED_BITS_NX90_asic_ctrl_irq_raw 0x000001ffU

enum {
  BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_com = 1,  /* [0] */
  BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_app = 1,  /* [1] */
  BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_com  = 1,  /* [2] */
  BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_app  = 1,  /* [3] */
  BFW_NX90_asic_ctrl_irq_raw_firewall_sqirom_com       = 1,  /* [4] */
  BFW_NX90_asic_ctrl_irq_raw_firewall_sqirom_app       = 1,  /* [5] */
  BFW_NX90_asic_ctrl_irq_raw_firewall_crypt_com        = 1,  /* [6] */
  BFW_NX90_asic_ctrl_irq_raw_firewall_crypt_app        = 1,  /* [7] */
  BFW_NX90_asic_ctrl_irq_raw_bod_fail                  = 1,  /* [8] */
  BFW_NX90_asic_ctrl_irq_raw_reserved1                 = 23  /* [31:9] */
};

typedef struct NX90_ASIC_CTRL_IRQ_RAW_BIT_Ttag {
  unsigned int firewall_hifmem_sdram_com : BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_com; /* Firewall of hifmem_sdram blocked a request of COM side */
  unsigned int firewall_hifmem_sdram_app : BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_sdram_app; /* Firewall of hifmem_sdram blocked a request of APP side */
  unsigned int firewall_hifmem_amem_com  : BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_com;  /* Firewall of hifmem_amem blocked a request of COM side  */
  unsigned int firewall_hifmem_amem_app  : BFW_NX90_asic_ctrl_irq_raw_firewall_hifmem_amem_app;  /* Firewall of hifmem_amem blocked a request of APP side  */
  unsigned int firewall_sqirom_com       : BFW_NX90_asic_ctrl_irq_raw_firewall_sqirom_com;       /* Firewall of sqirom blocked a request of COM side       */
  unsigned int firewall_sqirom_app       : BFW_NX90_asic_ctrl_irq_raw_firewall_sqirom_app;       /* Firewall of sqirom blocked a request of APP side       */
  unsigned int firewall_crypt_com        : BFW_NX90_asic_ctrl_irq_raw_firewall_crypt_com;        /* Firewall of crypt blocked a request of COM side        */
  unsigned int firewall_crypt_app        : BFW_NX90_asic_ctrl_irq_raw_firewall_crypt_app;        /* Firewall of crypt blocked a request of APP side        */
  unsigned int bod_fail                  : BFW_NX90_asic_ctrl_irq_raw_bod_fail;                  /* Voltage at BOD pad dropped below threshold.            */
  unsigned int reserved1                 : BFW_NX90_asic_ctrl_irq_raw_reserved1;                 /* reserved                                               */
} NX90_ASIC_CTRL_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_ASIC_CTRL_IRQ_RAW_BIT_T bf;
} NX90_ASIC_CTRL_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register asic_ctrl_irq_masked */
/* => ASIC_CTRL masked IRQ: */
/*    Shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_asic_ctrl_irq_masked       0x000000CCU
#define Adr_NX90_asic_ctrl_asic_ctrl_irq_masked 0xFF4012CCU
#define Adr_NX90_asic_ctrl_irq_masked           0xFF4012CCU

#define MSK_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_com 0x00000001U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_com 0
#define MSK_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_app 0x00000002U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_app 1
#define MSK_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_com  0x00000004U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_com  2
#define MSK_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_app  0x00000008U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_app  3
#define MSK_NX90_asic_ctrl_irq_masked_firewall_sqirom_com       0x00000010U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_sqirom_com       4
#define MSK_NX90_asic_ctrl_irq_masked_firewall_sqirom_app       0x00000020U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_sqirom_app       5
#define MSK_NX90_asic_ctrl_irq_masked_firewall_crypt_com        0x00000040U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_crypt_com        6
#define MSK_NX90_asic_ctrl_irq_masked_firewall_crypt_app        0x00000080U
#define SRT_NX90_asic_ctrl_irq_masked_firewall_crypt_app        7
#define MSK_NX90_asic_ctrl_irq_masked_bod_fail                  0x00000100U
#define SRT_NX90_asic_ctrl_irq_masked_bod_fail                  8

/* all used bits of 'NX90_asic_ctrl_irq_masked': */
#define MSK_USED_BITS_NX90_asic_ctrl_irq_masked 0x000001ffU

enum {
  BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_com = 1,  /* [0] */
  BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_app = 1,  /* [1] */
  BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_com  = 1,  /* [2] */
  BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_app  = 1,  /* [3] */
  BFW_NX90_asic_ctrl_irq_masked_firewall_sqirom_com       = 1,  /* [4] */
  BFW_NX90_asic_ctrl_irq_masked_firewall_sqirom_app       = 1,  /* [5] */
  BFW_NX90_asic_ctrl_irq_masked_firewall_crypt_com        = 1,  /* [6] */
  BFW_NX90_asic_ctrl_irq_masked_firewall_crypt_app        = 1,  /* [7] */
  BFW_NX90_asic_ctrl_irq_masked_bod_fail                  = 1,  /* [8] */
  BFW_NX90_asic_ctrl_irq_masked_reserved1                 = 23  /* [31:9] */
};

typedef struct NX90_ASIC_CTRL_IRQ_MASKED_BIT_Ttag {
  unsigned int firewall_hifmem_sdram_com : BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_com; /* Firewall of hifmem_sdram blocked a request of COM side */
  unsigned int firewall_hifmem_sdram_app : BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_sdram_app; /* Firewall of hifmem_sdram blocked a request of APP side */
  unsigned int firewall_hifmem_amem_com  : BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_com;  /* Firewall of hifmem_amem blocked a request of COM side  */
  unsigned int firewall_hifmem_amem_app  : BFW_NX90_asic_ctrl_irq_masked_firewall_hifmem_amem_app;  /* Firewall of hifmem_amem blocked a request of APP side  */
  unsigned int firewall_sqirom_com       : BFW_NX90_asic_ctrl_irq_masked_firewall_sqirom_com;       /* Firewall of sqirom blocked a request of COM side       */
  unsigned int firewall_sqirom_app       : BFW_NX90_asic_ctrl_irq_masked_firewall_sqirom_app;       /* Firewall of sqirom blocked a request of APP side       */
  unsigned int firewall_crypt_com        : BFW_NX90_asic_ctrl_irq_masked_firewall_crypt_com;        /* Firewall of crypt blocked a request of COM side        */
  unsigned int firewall_crypt_app        : BFW_NX90_asic_ctrl_irq_masked_firewall_crypt_app;        /* Firewall of crypt blocked a request of APP side        */
  unsigned int bod_fail                  : BFW_NX90_asic_ctrl_irq_masked_bod_fail;                  /* Voltage at BOD pad dropped below threshold             */
  unsigned int reserved1                 : BFW_NX90_asic_ctrl_irq_masked_reserved1;                 /* reserved                                               */
} NX90_ASIC_CTRL_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_ASIC_CTRL_IRQ_MASKED_BIT_T bf;
} NX90_ASIC_CTRL_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register asic_ctrl_irq_mask_set */
/* => ASIC_CTRL IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ maskq register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to bod_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_asic_ctrl_irq_mask_set       0x000000D0U
#define Adr_NX90_asic_ctrl_asic_ctrl_irq_mask_set 0xFF4012D0U
#define Adr_NX90_asic_ctrl_irq_mask_set           0xFF4012D0U
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set      0x00000000U

#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com         0x00000001U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com         0
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com    0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com 0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app         0x00000002U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app         1
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app    0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app 0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com          0x00000004U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com          2
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com  0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app          0x00000008U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app          3
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app  0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_com               0x00000010U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_com               4
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_com          0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_com       0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_app               0x00000020U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_app               5
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_app          0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_app       0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_crypt_com                0x00000040U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_crypt_com                6
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_crypt_com           0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_crypt_com        0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_firewall_crypt_app                0x00000080U
#define SRT_NX90_asic_ctrl_irq_mask_set_firewall_crypt_app                7
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_firewall_crypt_app           0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_firewall_crypt_app        0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_set_bod_fail                          0x00000100U
#define SRT_NX90_asic_ctrl_irq_mask_set_bod_fail                          8
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_set_bod_fail                     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_set_bod_fail                  0x00000000U

/* all used bits of 'NX90_asic_ctrl_irq_mask_set': */
#define MSK_USED_BITS_NX90_asic_ctrl_irq_mask_set 0x000001ffU

enum {
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com = 1,  /* [0] */
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app = 1,  /* [1] */
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com  = 1,  /* [2] */
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app  = 1,  /* [3] */
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_com       = 1,  /* [4] */
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_app       = 1,  /* [5] */
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_crypt_com        = 1,  /* [6] */
  BFW_NX90_asic_ctrl_irq_mask_set_firewall_crypt_app        = 1,  /* [7] */
  BFW_NX90_asic_ctrl_irq_mask_set_bod_fail                  = 1,  /* [8] */
  BFW_NX90_asic_ctrl_irq_mask_set_reserved1                 = 23  /* [31:9] */
};

typedef struct NX90_ASIC_CTRL_IRQ_MASK_SET_BIT_Ttag {
  unsigned int firewall_hifmem_sdram_com : BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_com; /* Firewall of hifmem_sdram blocked a request of COM side */
  unsigned int firewall_hifmem_sdram_app : BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_sdram_app; /* Firewall of hifmem_sdram blocked a request of APP side */
  unsigned int firewall_hifmem_amem_com  : BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_com;  /* Firewall of hifmem_amem blocked a request of COM side  */
  unsigned int firewall_hifmem_amem_app  : BFW_NX90_asic_ctrl_irq_mask_set_firewall_hifmem_amem_app;  /* Firewall of hifmem_amem blocked a request of APP side  */
  unsigned int firewall_sqirom_com       : BFW_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_com;       /* Firewall of sqirom blocked a request of COM side       */
  unsigned int firewall_sqirom_app       : BFW_NX90_asic_ctrl_irq_mask_set_firewall_sqirom_app;       /* Firewall of sqirom blocked a request of APP side       */
  unsigned int firewall_crypt_com        : BFW_NX90_asic_ctrl_irq_mask_set_firewall_crypt_com;        /* Firewall of crypt blocked a request of COM side        */
  unsigned int firewall_crypt_app        : BFW_NX90_asic_ctrl_irq_mask_set_firewall_crypt_app;        /* Firewall of crypt blocked a request of APP side        */
  unsigned int bod_fail                  : BFW_NX90_asic_ctrl_irq_mask_set_bod_fail;                  /* Voltage at BOD pad dropped below threshold.            */
  unsigned int reserved1                 : BFW_NX90_asic_ctrl_irq_mask_set_reserved1;                 /* reserved                                               */
} NX90_ASIC_CTRL_IRQ_MASK_SET_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_ASIC_CTRL_IRQ_MASK_SET_BIT_T bf;
} NX90_ASIC_CTRL_IRQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register asic_ctrl_irq_mask_reset */
/* => ASIC_CTRL IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_asic_ctrl_irq_mask_reset       0x000000D4U
#define Adr_NX90_asic_ctrl_asic_ctrl_irq_mask_reset 0xFF4012D4U
#define Adr_NX90_asic_ctrl_irq_mask_reset           0xFF4012D4U
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset      0x00000000U

#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com         0x00000001U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com         0
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com    0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com 0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app         0x00000002U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app         1
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app    0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app 0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com          0x00000004U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com          2
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com  0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app          0x00000008U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app          3
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app  0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_com               0x00000010U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_com               4
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_com          0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_com       0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_app               0x00000020U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_app               5
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_app          0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_app       0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_com                0x00000040U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_com                6
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_com           0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_com        0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_app                0x00000080U
#define SRT_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_app                7
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_app           0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_app        0x00000000U
#define MSK_NX90_asic_ctrl_irq_mask_reset_bod_fail                          0x00000100U
#define SRT_NX90_asic_ctrl_irq_mask_reset_bod_fail                          8
#define DFLT_VAL_NX90_asic_ctrl_irq_mask_reset_bod_fail                     0x00000000U
#define DFLT_BF_VAL_NX90_asic_ctrl_irq_mask_reset_bod_fail                  0x00000000U

/* all used bits of 'NX90_asic_ctrl_irq_mask_reset': */
#define MSK_USED_BITS_NX90_asic_ctrl_irq_mask_reset 0x000001ffU

enum {
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com = 1,  /* [0] */
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app = 1,  /* [1] */
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com  = 1,  /* [2] */
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app  = 1,  /* [3] */
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_com       = 1,  /* [4] */
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_app       = 1,  /* [5] */
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_com        = 1,  /* [6] */
  BFW_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_app        = 1,  /* [7] */
  BFW_NX90_asic_ctrl_irq_mask_reset_bod_fail                  = 1,  /* [8] */
  BFW_NX90_asic_ctrl_irq_mask_reset_reserved1                 = 23  /* [31:9] */
};

typedef struct NX90_ASIC_CTRL_IRQ_MASK_RESET_BIT_Ttag {
  unsigned int firewall_hifmem_sdram_com : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_com; /* Firewall of hifmem_sdram blocked a request of COM side */
  unsigned int firewall_hifmem_sdram_app : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_sdram_app; /* Firewall of hifmem_sdram blocked a request of APP side */
  unsigned int firewall_hifmem_amem_com  : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_com;  /* Firewall of hifmem_amem blocked a request of COM side  */
  unsigned int firewall_hifmem_amem_app  : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_hifmem_amem_app;  /* Firewall of hifmem_amem blocked a request of APP side  */
  unsigned int firewall_sqirom_com       : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_com;       /* Firewall of sqirom blocked a request of COM side       */
  unsigned int firewall_sqirom_app       : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_sqirom_app;       /* Firewall of sqirom blocked a request of APP side       */
  unsigned int firewall_crypt_com        : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_com;        /* Firewall of crypt blocked a request of COM side        */
  unsigned int firewall_crypt_app        : BFW_NX90_asic_ctrl_irq_mask_reset_firewall_crypt_app;        /* Firewall of crypt blocked a request of APP side        */
  unsigned int bod_fail                  : BFW_NX90_asic_ctrl_irq_mask_reset_bod_fail;                  /* Voltage at BOD pad dropped below threshold.            */
  unsigned int reserved1                 : BFW_NX90_asic_ctrl_irq_mask_reset_reserved1;                 /* reserved                                               */
} NX90_ASIC_CTRL_IRQ_MASK_RESET_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_ASIC_CTRL_IRQ_MASK_RESET_BIT_T bf;
} NX90_ASIC_CTRL_IRQ_MASK_RESET_T;


/* ===================================================================== */

/* Area of mmio_ctrl */

/* ===================================================================== */

#define Addr_NX90_mmio_ctrl 0xFF401300U

/* --------------------------------------------------------------------- */
/* Register mmio0_cfg */
/* => Multiplexmatrix Configuration Register for MMIO0 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    ------------------------------- */
/*    mmio*_sel - coding: */
/*     */
/*    {     |                        |                           | border=1 */
/*    Coding netX internal function \ signal type                 functional group */
/*           (core connection) */
/*    0x00   xc_sample0               input,                      Trigger/Latch Unit */
/*    0x01   xc_sample1               input,                      Trigger/Latch Unit */
/*    0x02   xc_trigger0              tristatable output,         Trigger/Latch Unit */
/*    0x03   xc_trigger1              tristatable output,         Trigger/Latch Unit */
/*    0x04   can0_app_rx              input,                      CAN of app side ARM */
/*    0x05   can0_app_tx              always driven output,       CAN of app side ARM */
/*    0x06   can1_app_rx              input,                      CAN of app side ARM */
/*    0x07   can1_app_tx              always driven output,       CAN of app side ARM */
/*    0x08   i2c_xpic_app_scl         bidirectional,              I2C of app side xPIC */
/*    0x09   i2c_xpic_app_sda         bidirectional,              I2C of app side xPIC */
/*    0x0a   i2c_app_scl              bidirectional,              I2C of app side ARM */
/*    0x0b   i2c_app_sda              bidirectional,              I2C of app side ARM */
/*    0x0c   spi_xpic_app_clk         bidirectional,              SPI of app side xPIC */
/*    0x0d   spi_xpic_app_cs0n        bidirectional,              SPI of app side xPIC */
/*    0x0e   spi_xpic_app_cs1n        bidirectional,              SPI of app side xPIC */
/*    0x0f   spi_xpic_app_cs2n        bidirectional,              SPI of app side xPIC */
/*    0x10   spi_xpic_app_miso        bidirectional,              SPI of app side xPIC */
/*    0x11   spi_xpic_app_mosi        bidirectional,              SPI of app side xPIC */
/*    0x12   spi1_app_clk             bidirectional,              SPI of app side ARM */
/*    0x13   spi1_app_cs0n            bidirectional,              SPI of app side ARM */
/*    0x14   spi1_app_cs1n            bidirectional,              SPI of app side ARM */
/*    0x15   spi1_app_cs2n            bidirectional,              SPI of app side ARM */
/*    0x16   spi1_app_miso            bidirectional,              SPI of app side ARM */
/*    0x17   spi1_app_mosi            bidirectional,              SPI of app side ARM */
/*    0x18   uart_xpic_app_rxd        input,                      UART of app side xPIC */
/*    0x19   uart_xpic_app_txd        tristatable output,         UART of app side xPIC */
/*    0x1a   uart_xpic_app_rtsn       tristatable output,         UART of app side xPIC */
/*    0x1b   uart_xpic_app_ctsn       input,                      UART of app side xPIC */
/*    0x1c   uart_app_rxd             input,                      UART of app side ARM */
/*    0x1d   uart_app_txd             tristatable output,         UART of app side ARM */
/*    0x1e   uart_app_rtsn            tristatable output,         UART of app side ARM */
/*    0x1f   uart_app_ctsn            input,                      UART of app side ARM */
/*    0x20   gpio0                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x21   gpio1                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x22   gpio2                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x23   gpio3                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x24   gpio4                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x25   gpio5                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x26   gpio6                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x27   gpio7                    bidirectional,              GPIO (Timer/PWM/Blink etc) */
/*    0x28   wdg_act                  always driven output,       System Watchdog */
/*    0x29   en_in                    input,                      HIF pio input sampling enable */
/*    0x2a   eth_mmio_mdc             always driven output,       MDIO */
/*    0x2b   eth_mmio_mdio            bidirectional,              MDIO */
/*     */
/*    0x3f   PIO mode                 use MMIO PIO line registers PIO function} */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio0_cfg       0x00000000U
#define Adr_NX90_mmio_ctrl_mmio0_cfg 0xFF401300U
#define Adr_NX90_mmio0_cfg           0xFF401300U
#define DFLT_VAL_NX90_mmio0_cfg      0x0000003fU

#define MSK_NX90_mmio0_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio0_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio0_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio0_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio0_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio0_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio0_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio0_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio0_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio0_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio0_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio0_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio0_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio0_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio0_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio0_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio0_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio0_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio0_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio0_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio0_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio0_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio0_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio0_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio0_cfg': */
#define MSK_USED_BITS_NX90_mmio0_cfg 0x0007063fU

enum {
  BFW_NX90_mmio0_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio0_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio0_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio0_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio0_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio0_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio0_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio0_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio0_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO0_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio0_cfg_mmio_sel;     /* mmio0 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio0_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio0_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio0_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio0_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio0_cfg_pio_oe;       /* PIO mode output enable of mmio0, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio0_cfg_pio_out;      /* PIO mode output drive level of mmio0, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio0_cfg_status_in_ro; /* current input status of mmio0, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio0_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO0_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO0_CFG_BIT_T bf;
} NX90_MMIO0_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio1_cfg */
/* => Multiplexmatrix Configuration Register for MMIO1 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio1_cfg       0x00000004U
#define Adr_NX90_mmio_ctrl_mmio1_cfg 0xFF401304U
#define Adr_NX90_mmio1_cfg           0xFF401304U
#define DFLT_VAL_NX90_mmio1_cfg      0x0000003fU

#define MSK_NX90_mmio1_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio1_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio1_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio1_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio1_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio1_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio1_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio1_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio1_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio1_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio1_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio1_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio1_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio1_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio1_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio1_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio1_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio1_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio1_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio1_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio1_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio1_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio1_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio1_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio1_cfg': */
#define MSK_USED_BITS_NX90_mmio1_cfg 0x0007063fU

enum {
  BFW_NX90_mmio1_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio1_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio1_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio1_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio1_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio1_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio1_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio1_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio1_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO1_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio1_cfg_mmio_sel;     /* mmio1 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio1_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio1_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio1_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio1_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio1_cfg_pio_oe;       /* PIO mode output enable of mmio1, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio1_cfg_pio_out;      /* PIO mode output drive level of mmio1, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio1_cfg_status_in_ro; /* current input status of mmio1, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio1_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO1_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO1_CFG_BIT_T bf;
} NX90_MMIO1_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio2_cfg */
/* => Multiplexmatrix Configuration Register for MMIO2 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio2_cfg       0x00000008U
#define Adr_NX90_mmio_ctrl_mmio2_cfg 0xFF401308U
#define Adr_NX90_mmio2_cfg           0xFF401308U
#define DFLT_VAL_NX90_mmio2_cfg      0x0000003fU

#define MSK_NX90_mmio2_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio2_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio2_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio2_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio2_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio2_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio2_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio2_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio2_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio2_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio2_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio2_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio2_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio2_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio2_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio2_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio2_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio2_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio2_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio2_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio2_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio2_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio2_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio2_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio2_cfg': */
#define MSK_USED_BITS_NX90_mmio2_cfg 0x0007063fU

enum {
  BFW_NX90_mmio2_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio2_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio2_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio2_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio2_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio2_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio2_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio2_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio2_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO2_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio2_cfg_mmio_sel;     /* mmio2 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio2_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio2_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio2_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio2_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio2_cfg_pio_oe;       /* PIO mode output enable of mmio2, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio2_cfg_pio_out;      /* PIO mode output drive level of mmio2, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio2_cfg_status_in_ro; /* current input status of mmio2, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio2_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO2_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO2_CFG_BIT_T bf;
} NX90_MMIO2_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio3_cfg */
/* => Multiplexmatrix Configuration Register for MMIO3 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio3_cfg       0x0000000CU
#define Adr_NX90_mmio_ctrl_mmio3_cfg 0xFF40130CU
#define Adr_NX90_mmio3_cfg           0xFF40130CU
#define DFLT_VAL_NX90_mmio3_cfg      0x0000003fU

#define MSK_NX90_mmio3_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio3_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio3_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio3_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio3_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio3_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio3_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio3_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio3_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio3_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio3_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio3_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio3_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio3_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio3_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio3_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio3_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio3_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio3_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio3_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio3_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio3_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio3_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio3_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio3_cfg': */
#define MSK_USED_BITS_NX90_mmio3_cfg 0x0007063fU

enum {
  BFW_NX90_mmio3_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio3_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio3_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio3_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio3_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio3_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio3_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio3_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio3_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO3_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio3_cfg_mmio_sel;     /* mmio3 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio3_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio3_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio3_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio3_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio3_cfg_pio_oe;       /* PIO mode output enable of mmio3, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio3_cfg_pio_out;      /* PIO mode output drive level of mmio3, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio3_cfg_status_in_ro; /* current input status of mmio3, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio3_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO3_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO3_CFG_BIT_T bf;
} NX90_MMIO3_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio4_cfg */
/* => Multiplexmatrix Configuration Register for MMIO4 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio4_cfg       0x00000010U
#define Adr_NX90_mmio_ctrl_mmio4_cfg 0xFF401310U
#define Adr_NX90_mmio4_cfg           0xFF401310U
#define DFLT_VAL_NX90_mmio4_cfg      0x0000003fU

#define MSK_NX90_mmio4_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio4_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio4_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio4_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio4_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio4_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio4_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio4_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio4_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio4_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio4_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio4_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio4_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio4_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio4_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio4_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio4_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio4_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio4_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio4_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio4_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio4_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio4_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio4_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio4_cfg': */
#define MSK_USED_BITS_NX90_mmio4_cfg 0x0007063fU

enum {
  BFW_NX90_mmio4_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio4_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio4_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio4_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio4_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio4_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio4_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio4_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio4_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO4_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio4_cfg_mmio_sel;     /* mmio4 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio4_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio4_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio4_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio4_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio4_cfg_pio_oe;       /* PIO mode output enable of mmio4, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio4_cfg_pio_out;      /* PIO mode output drive level of mmio4, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio4_cfg_status_in_ro; /* current input status of mmio4, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio4_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO4_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO4_CFG_BIT_T bf;
} NX90_MMIO4_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio5_cfg */
/* => Multiplexmatrix Configuration Register for MMIO5 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio5_cfg       0x00000014U
#define Adr_NX90_mmio_ctrl_mmio5_cfg 0xFF401314U
#define Adr_NX90_mmio5_cfg           0xFF401314U
#define DFLT_VAL_NX90_mmio5_cfg      0x0000003fU

#define MSK_NX90_mmio5_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio5_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio5_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio5_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio5_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio5_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio5_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio5_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio5_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio5_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio5_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio5_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio5_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio5_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio5_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio5_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio5_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio5_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio5_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio5_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio5_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio5_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio5_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio5_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio5_cfg': */
#define MSK_USED_BITS_NX90_mmio5_cfg 0x0007063fU

enum {
  BFW_NX90_mmio5_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio5_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio5_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio5_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio5_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio5_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio5_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio5_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio5_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO5_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio5_cfg_mmio_sel;     /* mmio5 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio5_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio5_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio5_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio5_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio5_cfg_pio_oe;       /* PIO mode output enable of mmio5, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio5_cfg_pio_out;      /* PIO mode output drive level of mmio5, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio5_cfg_status_in_ro; /* current input status of mmio5, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio5_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO5_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO5_CFG_BIT_T bf;
} NX90_MMIO5_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio6_cfg */
/* => Multiplexmatrix Configuration Register for MMIO6 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio6_cfg       0x00000018U
#define Adr_NX90_mmio_ctrl_mmio6_cfg 0xFF401318U
#define Adr_NX90_mmio6_cfg           0xFF401318U
#define DFLT_VAL_NX90_mmio6_cfg      0x0000003fU

#define MSK_NX90_mmio6_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio6_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio6_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio6_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio6_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio6_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio6_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio6_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio6_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio6_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio6_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio6_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio6_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio6_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio6_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio6_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio6_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio6_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio6_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio6_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio6_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio6_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio6_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio6_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio6_cfg': */
#define MSK_USED_BITS_NX90_mmio6_cfg 0x0007063fU

enum {
  BFW_NX90_mmio6_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio6_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio6_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio6_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio6_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio6_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio6_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio6_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio6_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO6_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio6_cfg_mmio_sel;     /* mmio6 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio6_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio6_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio6_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio6_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio6_cfg_pio_oe;       /* PIO mode output enable of mmio6, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio6_cfg_pio_out;      /* PIO mode output drive level of mmio6, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio6_cfg_status_in_ro; /* current input status of mmio6, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio6_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO6_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO6_CFG_BIT_T bf;
} NX90_MMIO6_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio7_cfg */
/* => Multiplexmatrix Configuration Register for MMIO7 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio7_cfg       0x0000001CU
#define Adr_NX90_mmio_ctrl_mmio7_cfg 0xFF40131CU
#define Adr_NX90_mmio7_cfg           0xFF40131CU
#define DFLT_VAL_NX90_mmio7_cfg      0x0000003fU

#define MSK_NX90_mmio7_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio7_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio7_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio7_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio7_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio7_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio7_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio7_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio7_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio7_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio7_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio7_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio7_cfg_pio_oe               0x00010000U
#define SRT_NX90_mmio7_cfg_pio_oe               16
#define DFLT_VAL_NX90_mmio7_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX90_mmio7_cfg_pio_oe       0x00000000U
#define MSK_NX90_mmio7_cfg_pio_out              0x00020000U
#define SRT_NX90_mmio7_cfg_pio_out              17
#define DFLT_VAL_NX90_mmio7_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX90_mmio7_cfg_pio_out      0x00000000U
#define MSK_NX90_mmio7_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio7_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio7_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio7_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio7_cfg': */
#define MSK_USED_BITS_NX90_mmio7_cfg 0x0007063fU

enum {
  BFW_NX90_mmio7_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio7_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio7_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio7_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio7_cfg_reserved2    = 5,  /* [15:11] */
  BFW_NX90_mmio7_cfg_pio_oe       = 1,  /* [16] */
  BFW_NX90_mmio7_cfg_pio_out      = 1,  /* [17] */
  BFW_NX90_mmio7_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio7_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO7_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio7_cfg_mmio_sel;     /* mmio7 signal selection (default: PIO mode, access-key-protected).                                                 */
  unsigned int reserved1    : BFW_NX90_mmio7_cfg_reserved1;    /* reserved                                                                                                          */
  unsigned int mmio_out_inv : BFW_NX90_mmio7_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
  unsigned int mmio_in_inv  : BFW_NX90_mmio7_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
  unsigned int reserved2    : BFW_NX90_mmio7_cfg_reserved2;    /* reserved                                                                                                          */
  unsigned int pio_oe       : BFW_NX90_mmio7_cfg_pio_oe;       /* PIO mode output enable of mmio7, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
  unsigned int pio_out      : BFW_NX90_mmio7_cfg_pio_out;      /* PIO mode output drive level of mmio7, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
                                                               /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
  unsigned int status_in_ro : BFW_NX90_mmio7_cfg_status_in_ro; /* current input status of mmio7, could also be read from 'mmio_in_line_status' register                             */
  unsigned int reserved3    : BFW_NX90_mmio7_cfg_reserved3;    /* reserved                                                                                                          */
} NX90_MMIO7_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO7_CFG_BIT_T bf;
} NX90_MMIO7_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio8_cfg */
/* => Multiplexmatrix Configuration Register for MMIO8 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio8 signal is a multiplex option of HIF_D8 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio8_cfg       0x00000020U
#define Adr_NX90_mmio_ctrl_mmio8_cfg 0xFF401320U
#define Adr_NX90_mmio8_cfg           0xFF401320U
#define DFLT_VAL_NX90_mmio8_cfg      0x0000003fU

#define MSK_NX90_mmio8_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio8_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio8_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio8_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio8_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio8_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio8_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio8_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio8_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio8_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio8_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio8_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio8_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio8_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio8_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio8_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio8_cfg': */
#define MSK_USED_BITS_NX90_mmio8_cfg 0x0004063fU

enum {
  BFW_NX90_mmio8_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio8_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio8_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio8_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio8_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio8_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio8_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO8_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio8_cfg_mmio_sel;     /* mmio8 signal selection and multiplex function enable (access-key-protected).           */
                                                               /* mmio8 signal is a multiplex option of HIF_D8 and will be selected when this bit-field  */
                                                               /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio8 signal. */
                                                               /* Default value 0x3f deselects mmio8 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio8_cfg_reserved1;    /* reserved                                                                               */
  unsigned int mmio_out_inv : BFW_NX90_mmio8_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)       */
  unsigned int mmio_in_inv  : BFW_NX90_mmio8_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int reserved2    : BFW_NX90_mmio8_cfg_reserved2;    /* reserved                                                                               */
  unsigned int status_in_ro : BFW_NX90_mmio8_cfg_status_in_ro; /* current input status of mmio8 port HIF_D8.                                             */
                                                               /* Could also be read from mmio_in_line_status register                                   */
  unsigned int reserved3    : BFW_NX90_mmio8_cfg_reserved3;    /* reserved                                                                               */
} NX90_MMIO8_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO8_CFG_BIT_T bf;
} NX90_MMIO8_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio9_cfg */
/* => Multiplexmatrix Configuration Register for MMIO9 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio9 signal is a multiplex option of HIF_D9 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio9_cfg       0x00000024U
#define Adr_NX90_mmio_ctrl_mmio9_cfg 0xFF401324U
#define Adr_NX90_mmio9_cfg           0xFF401324U
#define DFLT_VAL_NX90_mmio9_cfg      0x0000003fU

#define MSK_NX90_mmio9_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio9_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio9_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio9_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio9_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio9_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio9_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio9_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio9_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio9_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio9_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio9_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio9_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio9_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio9_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio9_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio9_cfg': */
#define MSK_USED_BITS_NX90_mmio9_cfg 0x0004063fU

enum {
  BFW_NX90_mmio9_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio9_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio9_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio9_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio9_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio9_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio9_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO9_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio9_cfg_mmio_sel;     /* mmio9 signal selection and multiplex function enable (access-key-protected).           */
                                                               /* mmio9 signal is a multiplex option of HIF_D9 and will be selected when this bit-field  */
                                                               /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio9 signal. */
                                                               /* Default value 0x3f deselects mmio9 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio9_cfg_reserved1;    /* reserved                                                                               */
  unsigned int mmio_out_inv : BFW_NX90_mmio9_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)       */
  unsigned int mmio_in_inv  : BFW_NX90_mmio9_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int reserved2    : BFW_NX90_mmio9_cfg_reserved2;    /* reserved                                                                               */
  unsigned int status_in_ro : BFW_NX90_mmio9_cfg_status_in_ro; /* current input status of mmio9 port HIF_D9.                                             */
                                                               /* Could also be read from mmio_in_line_status register                                   */
  unsigned int reserved3    : BFW_NX90_mmio9_cfg_reserved3;    /* reserved                                                                               */
} NX90_MMIO9_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_MMIO9_CFG_BIT_T bf;
} NX90_MMIO9_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio10_cfg */
/* => Multiplexmatrix Configuration Register for MMIO10 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio10 signal is a multiplex option of HIF_D10 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio10_cfg       0x00000028U
#define Adr_NX90_mmio_ctrl_mmio10_cfg 0xFF401328U
#define Adr_NX90_mmio10_cfg           0xFF401328U
#define DFLT_VAL_NX90_mmio10_cfg      0x0000003fU

#define MSK_NX90_mmio10_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio10_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio10_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio10_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio10_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio10_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio10_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio10_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio10_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio10_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio10_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio10_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio10_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio10_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio10_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio10_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio10_cfg': */
#define MSK_USED_BITS_NX90_mmio10_cfg 0x0004063fU

enum {
  BFW_NX90_mmio10_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio10_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio10_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio10_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio10_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio10_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio10_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO10_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio10_cfg_mmio_sel;     /* mmio10 signal selection and multiplex function enable (access-key-protected).           */
                                                                /* mmio10 signal is a multiplex option of HIF_D10 and will be selected when this bit-field */
                                                                /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio10 signal. */
                                                                /* Default value 0x3f deselects mmio10 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio10_cfg_reserved1;    /* reserved                                                                                */
  unsigned int mmio_out_inv : BFW_NX90_mmio10_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int mmio_in_inv  : BFW_NX90_mmio10_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
  unsigned int reserved2    : BFW_NX90_mmio10_cfg_reserved2;    /* reserved                                                                                */
  unsigned int status_in_ro : BFW_NX90_mmio10_cfg_status_in_ro; /* current input status of mmio10 port HIF_D10.                                            */
                                                                /* Could also be read from mmio_in_line_status register                                    */
  unsigned int reserved3    : BFW_NX90_mmio10_cfg_reserved3;    /* reserved                                                                                */
} NX90_MMIO10_CFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MMIO10_CFG_BIT_T bf;
} NX90_MMIO10_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio11_cfg */
/* => Multiplexmatrix Configuration Register for MMIO11 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio11 signal is a multiplex option of HIF_D11 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio11_cfg       0x0000002CU
#define Adr_NX90_mmio_ctrl_mmio11_cfg 0xFF40132CU
#define Adr_NX90_mmio11_cfg           0xFF40132CU
#define DFLT_VAL_NX90_mmio11_cfg      0x0000003fU

#define MSK_NX90_mmio11_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio11_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio11_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio11_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio11_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio11_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio11_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio11_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio11_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio11_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio11_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio11_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio11_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio11_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio11_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio11_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio11_cfg': */
#define MSK_USED_BITS_NX90_mmio11_cfg 0x0004063fU

enum {
  BFW_NX90_mmio11_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio11_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio11_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio11_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio11_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio11_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio11_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO11_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio11_cfg_mmio_sel;     /* mmio11 signal selection and multiplex function enable (access-key-protected).           */
                                                                /* mmio11 signal is a multiplex option of HIF_D11 and will be selected when this bit-field */
                                                                /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio11 signal. */
                                                                /* Default value 0x3f deselects mmio11 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio11_cfg_reserved1;    /* reserved                                                                                */
  unsigned int mmio_out_inv : BFW_NX90_mmio11_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int mmio_in_inv  : BFW_NX90_mmio11_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
  unsigned int reserved2    : BFW_NX90_mmio11_cfg_reserved2;    /* reserved                                                                                */
  unsigned int status_in_ro : BFW_NX90_mmio11_cfg_status_in_ro; /* current input status of mmio11 port HIF_D11.                                            */
                                                                /* Could also be read from mmio_in_line_status register                                    */
  unsigned int reserved3    : BFW_NX90_mmio11_cfg_reserved3;    /* reserved                                                                                */
} NX90_MMIO11_CFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MMIO11_CFG_BIT_T bf;
} NX90_MMIO11_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio12_cfg */
/* => Multiplexmatrix Configuration Register for MMIO12 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio12 signal is a multiplex option of HIF_D12 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio12_cfg       0x00000030U
#define Adr_NX90_mmio_ctrl_mmio12_cfg 0xFF401330U
#define Adr_NX90_mmio12_cfg           0xFF401330U
#define DFLT_VAL_NX90_mmio12_cfg      0x0000003fU

#define MSK_NX90_mmio12_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio12_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio12_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio12_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio12_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio12_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio12_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio12_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio12_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio12_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio12_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio12_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio12_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio12_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio12_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio12_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio12_cfg': */
#define MSK_USED_BITS_NX90_mmio12_cfg 0x0004063fU

enum {
  BFW_NX90_mmio12_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio12_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio12_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio12_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio12_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio12_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio12_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO12_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio12_cfg_mmio_sel;     /* mmio12 signal selection and multiplex function enable (access-key-protected).           */
                                                                /* mmio12 signal is a multiplex option of HIF_D12 and will be selected when this bit-field */
                                                                /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio12 signal. */
                                                                /* Default value 0x3f deselects mmio12 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio12_cfg_reserved1;    /* reserved                                                                                */
  unsigned int mmio_out_inv : BFW_NX90_mmio12_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int mmio_in_inv  : BFW_NX90_mmio12_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
  unsigned int reserved2    : BFW_NX90_mmio12_cfg_reserved2;    /* reserved                                                                                */
  unsigned int status_in_ro : BFW_NX90_mmio12_cfg_status_in_ro; /* current input status of mmio12 port HIF_D12.                                            */
                                                                /* Could also be read from mmio_in_line_status register                                    */
  unsigned int reserved3    : BFW_NX90_mmio12_cfg_reserved3;    /* reserved                                                                                */
} NX90_MMIO12_CFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MMIO12_CFG_BIT_T bf;
} NX90_MMIO12_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio13_cfg */
/* => Multiplexmatrix Configuration Register for MMIO13 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio13 signal is a multiplex option of HIF_D13 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio13_cfg       0x00000034U
#define Adr_NX90_mmio_ctrl_mmio13_cfg 0xFF401334U
#define Adr_NX90_mmio13_cfg           0xFF401334U
#define DFLT_VAL_NX90_mmio13_cfg      0x0000003fU

#define MSK_NX90_mmio13_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio13_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio13_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio13_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio13_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio13_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio13_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio13_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio13_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio13_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio13_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio13_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio13_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio13_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio13_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio13_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio13_cfg': */
#define MSK_USED_BITS_NX90_mmio13_cfg 0x0004063fU

enum {
  BFW_NX90_mmio13_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio13_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio13_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio13_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio13_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio13_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio13_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO13_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio13_cfg_mmio_sel;     /* mmio13 signal selection and multiplex function enable (access-key-protected).           */
                                                                /* mmio13 signal is a multiplex option of HIF_D13 and will be selected when this bit-field */
                                                                /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio13 signal. */
                                                                /* Default value 0x3f deselects mmio13 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio13_cfg_reserved1;    /* reserved                                                                                */
  unsigned int mmio_out_inv : BFW_NX90_mmio13_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int mmio_in_inv  : BFW_NX90_mmio13_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
  unsigned int reserved2    : BFW_NX90_mmio13_cfg_reserved2;    /* reserved                                                                                */
  unsigned int status_in_ro : BFW_NX90_mmio13_cfg_status_in_ro; /* current input status of mmio13 port HIF_D13.                                            */
                                                                /* Could also be read from mmio_in_line_status register                                    */
  unsigned int reserved3    : BFW_NX90_mmio13_cfg_reserved3;    /* reserved                                                                                */
} NX90_MMIO13_CFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MMIO13_CFG_BIT_T bf;
} NX90_MMIO13_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio14_cfg */
/* => Multiplexmatrix Configuration Register for MMIO14 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio14 signal is a multiplex option of HIF_D14 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio14_cfg       0x00000038U
#define Adr_NX90_mmio_ctrl_mmio14_cfg 0xFF401338U
#define Adr_NX90_mmio14_cfg           0xFF401338U
#define DFLT_VAL_NX90_mmio14_cfg      0x0000003fU

#define MSK_NX90_mmio14_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio14_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio14_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio14_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio14_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio14_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio14_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio14_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio14_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio14_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio14_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio14_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio14_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio14_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio14_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio14_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio14_cfg': */
#define MSK_USED_BITS_NX90_mmio14_cfg 0x0004063fU

enum {
  BFW_NX90_mmio14_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio14_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio14_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio14_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio14_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio14_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio14_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO14_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio14_cfg_mmio_sel;     /* mmio14 signal selection and multiplex function enable (access-key-protected).           */
                                                                /* mmio14 signal is a multiplex option of HIF_D14 and will be selected when this bit-field */
                                                                /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio14 signal. */
                                                                /* Default value 0x3f deselects mmio14 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio14_cfg_reserved1;    /* reserved                                                                                */
  unsigned int mmio_out_inv : BFW_NX90_mmio14_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int mmio_in_inv  : BFW_NX90_mmio14_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
  unsigned int reserved2    : BFW_NX90_mmio14_cfg_reserved2;    /* reserved                                                                                */
  unsigned int status_in_ro : BFW_NX90_mmio14_cfg_status_in_ro; /* current input status of mmio14 port HIF_D14.                                            */
                                                                /* Could also be read from mmio_in_line_status register                                    */
  unsigned int reserved3    : BFW_NX90_mmio14_cfg_reserved3;    /* reserved                                                                                */
} NX90_MMIO14_CFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MMIO14_CFG_BIT_T bf;
} NX90_MMIO14_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio15_cfg */
/* => Multiplexmatrix Configuration Register for MMIO15 */
/*    ------------------------------- */
/*    Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from asic_ctrl_access_key register */
/*    2.: write back access-key to asic_ctrl_access_key register */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio15 signal is a multiplex option of HIF_D15 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio15_cfg       0x0000003CU
#define Adr_NX90_mmio_ctrl_mmio15_cfg 0xFF40133CU
#define Adr_NX90_mmio15_cfg           0xFF40133CU
#define DFLT_VAL_NX90_mmio15_cfg      0x0000003fU

#define MSK_NX90_mmio15_cfg_mmio_sel             0x0000003fU
#define SRT_NX90_mmio15_cfg_mmio_sel             0
#define DFLT_VAL_NX90_mmio15_cfg_mmio_sel        0x0000003fU
#define DFLT_BF_VAL_NX90_mmio15_cfg_mmio_sel     0x0000003fU
#define MSK_NX90_mmio15_cfg_mmio_out_inv         0x00000200U
#define SRT_NX90_mmio15_cfg_mmio_out_inv         9
#define DFLT_VAL_NX90_mmio15_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mmio15_cfg_mmio_out_inv 0x00000000U
#define MSK_NX90_mmio15_cfg_mmio_in_inv          0x00000400U
#define SRT_NX90_mmio15_cfg_mmio_in_inv          10
#define DFLT_VAL_NX90_mmio15_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX90_mmio15_cfg_mmio_in_inv  0x00000000U
#define MSK_NX90_mmio15_cfg_status_in_ro         0x00040000U
#define SRT_NX90_mmio15_cfg_status_in_ro         18
#define DFLT_VAL_NX90_mmio15_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX90_mmio15_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX90_mmio15_cfg': */
#define MSK_USED_BITS_NX90_mmio15_cfg 0x0004063fU

enum {
  BFW_NX90_mmio15_cfg_mmio_sel     = 6,  /* [5:0] */
  BFW_NX90_mmio15_cfg_reserved1    = 3,  /* [8:6] */
  BFW_NX90_mmio15_cfg_mmio_out_inv = 1,  /* [9] */
  BFW_NX90_mmio15_cfg_mmio_in_inv  = 1,  /* [10] */
  BFW_NX90_mmio15_cfg_reserved2    = 7,  /* [17:11] */
  BFW_NX90_mmio15_cfg_status_in_ro = 1,  /* [18] */
  BFW_NX90_mmio15_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX90_MMIO15_CFG_BIT_Ttag {
  unsigned int mmio_sel     : BFW_NX90_mmio15_cfg_mmio_sel;     /* mmio15 signal selection and multiplex function enable (access-key-protected).           */
                                                                /* mmio15 signal is a multiplex option of HIF_D15 and will be selected when this bit-field */
                                                                /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio15 signal. */
                                                                /* Default value 0x3f deselects mmio15 multiplex option.                                   */
  unsigned int reserved1    : BFW_NX90_mmio15_cfg_reserved1;    /* reserved                                                                                */
  unsigned int mmio_out_inv : BFW_NX90_mmio15_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
  unsigned int mmio_in_inv  : BFW_NX90_mmio15_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
  unsigned int reserved2    : BFW_NX90_mmio15_cfg_reserved2;    /* reserved                                                                                */
  unsigned int status_in_ro : BFW_NX90_mmio15_cfg_status_in_ro; /* current input status of mmio15 port HIF_D15.                                            */
                                                                /* Could also be read from mmio_in_line_status register                                    */
  unsigned int reserved3    : BFW_NX90_mmio15_cfg_reserved3;    /* reserved                                                                                */
} NX90_MMIO15_CFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_MMIO15_CFG_BIT_T bf;
} NX90_MMIO15_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_out_line_cfg0 */
/* => MMIO PIO line output level register of MMIO 0 to 15. */
/*    Changing bits here will change 'pio_out' bit of related mmio*_cfg register. Changes there will change related bit inside this register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored. */
/*       MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored. */
/*       MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored. */
/*       MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored. */
/*       MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored. */
/*       MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored. */
/*       MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored. */
/*       MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_pio_out_line_cfg0       0x00000040U
#define Adr_NX90_mmio_ctrl_mmio_pio_out_line_cfg0 0xFF401340U
#define Adr_NX90_mmio_pio_out_line_cfg0           0xFF401340U
#define DFLT_VAL_NX90_mmio_pio_out_line_cfg0      0x00000000U

#define MSK_NX90_mmio_pio_out_line_cfg0_line         0x0000ffffU
#define SRT_NX90_mmio_pio_out_line_cfg0_line         0
#define DFLT_VAL_NX90_mmio_pio_out_line_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX90_mmio_pio_out_line_cfg0_line 0x00000000U

/* all used bits of 'NX90_mmio_pio_out_line_cfg0': */
#define MSK_USED_BITS_NX90_mmio_pio_out_line_cfg0 0x0000ffffU

enum {
  BFW_NX90_mmio_pio_out_line_cfg0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_pio_out_line_cfg0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_PIO_OUT_LINE_CFG0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_pio_out_line_cfg0_line;      /* MMIO output state if related MMIO is in PIO mode.                        */
                                                                      /* If related MMIO is not in PIO mode, programmed setting is ignored.       */
                                                                      /* Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15 controlls MMIO15. */
  unsigned int reserved1 : BFW_NX90_mmio_pio_out_line_cfg0_reserved1; /* reserved                                                                 */
} NX90_MMIO_PIO_OUT_LINE_CFG0_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_MMIO_PIO_OUT_LINE_CFG0_BIT_T bf;
} NX90_MMIO_PIO_OUT_LINE_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_out_line_set_cfg0 */
/* => MMIO PIO line output level set register of MMIO 0 to 15. */
/*    This register is for setting single MMIO PIOs to high level with a single access. In contrast to using the 'mmio_pio_out_line_cfg0' register */
/*    no read-modify-write sequence (which could be interrupted) is required. */
/*    Writing '1's here will activate the 'pio_out' bit of related 'mmio*_cfg' register and also activate */
/*    the related bits in the 'mmio_pio_out_line_cfg0' register. */
/*    For read this register returns the same value as the 'mmio_pio_out_line_cfg0' register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored. */
/*       MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored. */
/*       MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored. */
/*       MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored. */
/*       MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored. */
/*       MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored. */
/*       MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored. */
/*       MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_pio_out_line_set_cfg0       0x00000044U
#define Adr_NX90_mmio_ctrl_mmio_pio_out_line_set_cfg0 0xFF401344U
#define Adr_NX90_mmio_pio_out_line_set_cfg0           0xFF401344U
#define DFLT_VAL_NX90_mmio_pio_out_line_set_cfg0      0x00000000U

#define MSK_NX90_mmio_pio_out_line_set_cfg0_line         0x0000ffffU
#define SRT_NX90_mmio_pio_out_line_set_cfg0_line         0
#define DFLT_VAL_NX90_mmio_pio_out_line_set_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX90_mmio_pio_out_line_set_cfg0_line 0x00000000U

/* all used bits of 'NX90_mmio_pio_out_line_set_cfg0': */
#define MSK_USED_BITS_NX90_mmio_pio_out_line_set_cfg0 0x0000ffffU

enum {
  BFW_NX90_mmio_pio_out_line_set_cfg0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_pio_out_line_set_cfg0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_PIO_OUT_LINE_SET_CFG0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_pio_out_line_set_cfg0_line;      /* Write '1's to set the related MMIO output to high level (when it is in PIO mode and output is enabled).            */
                                                                          /* If related MMIO is not in PIO mode, programmed setting is ignored.                                                 */
                                                                          /* Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15 controlls MMIO15.                                           */
                                                                          /* For read the current value of the programmed output states is returned (i.e. the value of mmio_pio_out_line_cfg0). */
  unsigned int reserved1 : BFW_NX90_mmio_pio_out_line_set_cfg0_reserved1; /* reserved                                                                                                           */
} NX90_MMIO_PIO_OUT_LINE_SET_CFG0_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_MMIO_PIO_OUT_LINE_SET_CFG0_BIT_T bf;
} NX90_MMIO_PIO_OUT_LINE_SET_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_out_line_reset_cfg0 */
/* => MMIO PIO line output level reset register of MMIO 0 to 15. */
/*    This register is for deactivating single MMIO PIOs with a single access. In contrast to using the 'mmio_pio_out_line_cfg0' register */
/*    no read-modify-write sequence (which could be interrupted) is required. */
/*    Writing '1's here will clear the 'pio_out' bit of related 'mmio*_cfg' register and also clear */
/*    the related bits in the 'mmio_pio_out_line_cfg0' register. */
/*    For read this register returns the same value as the 'mmio_pio_out_line_cfg0' register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored. */
/*       MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored. */
/*       MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored. */
/*       MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored. */
/*       MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored. */
/*       MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored. */
/*       MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored. */
/*       MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_pio_out_line_reset_cfg0       0x00000048U
#define Adr_NX90_mmio_ctrl_mmio_pio_out_line_reset_cfg0 0xFF401348U
#define Adr_NX90_mmio_pio_out_line_reset_cfg0           0xFF401348U
#define DFLT_VAL_NX90_mmio_pio_out_line_reset_cfg0      0x00000000U

#define MSK_NX90_mmio_pio_out_line_reset_cfg0_line         0x0000ffffU
#define SRT_NX90_mmio_pio_out_line_reset_cfg0_line         0
#define DFLT_VAL_NX90_mmio_pio_out_line_reset_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX90_mmio_pio_out_line_reset_cfg0_line 0x00000000U

/* all used bits of 'NX90_mmio_pio_out_line_reset_cfg0': */
#define MSK_USED_BITS_NX90_mmio_pio_out_line_reset_cfg0 0x0000ffffU

enum {
  BFW_NX90_mmio_pio_out_line_reset_cfg0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_pio_out_line_reset_cfg0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_PIO_OUT_LINE_RESET_CFG0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_pio_out_line_reset_cfg0_line;      /* Write '1's to set the related MMIO output to low level (when it is in PIO mode and output is enabled).             */
                                                                            /* If related MMIO is not in PIO mode, programmed setting is ignored.                                                 */
                                                                            /* Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15 controlls MMIO15.                                           */
                                                                            /* For read the current value of the programmed output states is returned (i.e. the value of mmio_pio_out_line_cfg0). */
  unsigned int reserved1 : BFW_NX90_mmio_pio_out_line_reset_cfg0_reserved1; /* reserved                                                                                                           */
} NX90_MMIO_PIO_OUT_LINE_RESET_CFG0_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_MMIO_PIO_OUT_LINE_RESET_CFG0_BIT_T bf;
} NX90_MMIO_PIO_OUT_LINE_RESET_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_oe_line_cfg0 */
/* => MMIO PIO line output enable register of MMIO 0 to 15. */
/*    Changing bits here will change 'pio_oe' bit of related mmio*_cfg register. Changes there will change related bit inside this register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored. */
/*       MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored. */
/*       MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored. */
/*       MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored. */
/*       MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored. */
/*       MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored. */
/*       MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored. */
/*       MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_pio_oe_line_cfg0       0x0000004CU
#define Adr_NX90_mmio_ctrl_mmio_pio_oe_line_cfg0 0xFF40134CU
#define Adr_NX90_mmio_pio_oe_line_cfg0           0xFF40134CU
#define DFLT_VAL_NX90_mmio_pio_oe_line_cfg0      0x00000000U

#define MSK_NX90_mmio_pio_oe_line_cfg0_line         0x0000ffffU
#define SRT_NX90_mmio_pio_oe_line_cfg0_line         0
#define DFLT_VAL_NX90_mmio_pio_oe_line_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX90_mmio_pio_oe_line_cfg0_line 0x00000000U

/* all used bits of 'NX90_mmio_pio_oe_line_cfg0': */
#define MSK_USED_BITS_NX90_mmio_pio_oe_line_cfg0 0x0000ffffU

enum {
  BFW_NX90_mmio_pio_oe_line_cfg0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_pio_oe_line_cfg0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_PIO_OE_LINE_CFG0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_pio_oe_line_cfg0_line;      /* MMIO output enable if related MMIO is in PIO mode.                       */
                                                                     /* If related MMIO is not in PIO mode, programmed setting is ignored.       */
                                                                     /* Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15 controlls MMIO15. */
  unsigned int reserved1 : BFW_NX90_mmio_pio_oe_line_cfg0_reserved1; /* reserved                                                                 */
} NX90_MMIO_PIO_OE_LINE_CFG0_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_MMIO_PIO_OE_LINE_CFG0_BIT_T bf;
} NX90_MMIO_PIO_OE_LINE_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_oe_line_set_cfg0 */
/* => MMIO PIO line output enable set register of MMIO 0 to 15. */
/*    This register is for activating single MMIO PIOs with a single access. In contrast to using the 'mmio_pio_oe_line_cfg0' register */
/*    no read-modify-write sequence (which could be interrupted) is required. */
/*    Writing '1's here will activate the 'pio_oe' bit of related 'mmio*_cfg' register and also activate */
/*    the related bits in the 'mmio_pio_oe_line_cfg0' register. */
/*    For read this register returns the same value as the 'mmio_pio_oe_line_cfg0' register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored. */
/*       MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored. */
/*       MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored. */
/*       MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored. */
/*       MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored. */
/*       MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored. */
/*       MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored. */
/*       MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_pio_oe_line_set_cfg0       0x00000050U
#define Adr_NX90_mmio_ctrl_mmio_pio_oe_line_set_cfg0 0xFF401350U
#define Adr_NX90_mmio_pio_oe_line_set_cfg0           0xFF401350U
#define DFLT_VAL_NX90_mmio_pio_oe_line_set_cfg0      0x00000000U

#define MSK_NX90_mmio_pio_oe_line_set_cfg0_line         0x0000ffffU
#define SRT_NX90_mmio_pio_oe_line_set_cfg0_line         0
#define DFLT_VAL_NX90_mmio_pio_oe_line_set_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX90_mmio_pio_oe_line_set_cfg0_line 0x00000000U

/* all used bits of 'NX90_mmio_pio_oe_line_set_cfg0': */
#define MSK_USED_BITS_NX90_mmio_pio_oe_line_set_cfg0 0x0000ffffU

enum {
  BFW_NX90_mmio_pio_oe_line_set_cfg0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_pio_oe_line_set_cfg0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_PIO_OE_LINE_SET_CFG0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_pio_oe_line_set_cfg0_line;      /* Write '1's to activate the related MMIO output enable (when it is in PIO mode).                                    */
                                                                         /* If related MMIO is not in PIO mode, programmed setting is ignored.                                                 */
                                                                         /* Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15 controlls MMIO15.                                           */
                                                                         /* For read the current value of the programmed output enables is returned (i.e. the value of mmio_pio_oe_line_cfg0). */
  unsigned int reserved1 : BFW_NX90_mmio_pio_oe_line_set_cfg0_reserved1; /* reserved                                                                                                           */
} NX90_MMIO_PIO_OE_LINE_SET_CFG0_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MMIO_PIO_OE_LINE_SET_CFG0_BIT_T bf;
} NX90_MMIO_PIO_OE_LINE_SET_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_oe_line_reset_cfg0 */
/* => MMIO PIO line output enable reset register of MMIO 0 to 15. */
/*    This register is for deactivating single MMIO PIOs with a single access. In contrast to using the 'mmio_pio_oe_line_cfg0' register */
/*    no read-modify-write sequence (which could be interrupted) is required. */
/*    Writing '1's here will clear the 'pio_oe' bit of related 'mmio*_cfg' register and also clear */
/*    the related bits in the 'mmio_pio_oe_line_cfg0' register. */
/*    For read this register returns the same value as the 'mmio_pio_oe_line_cfg0' register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored. */
/*       MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored. */
/*       MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored. */
/*       MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored. */
/*       MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored. */
/*       MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored. */
/*       MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored. */
/*       MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_pio_oe_line_reset_cfg0       0x00000054U
#define Adr_NX90_mmio_ctrl_mmio_pio_oe_line_reset_cfg0 0xFF401354U
#define Adr_NX90_mmio_pio_oe_line_reset_cfg0           0xFF401354U
#define DFLT_VAL_NX90_mmio_pio_oe_line_reset_cfg0      0x00000000U

#define MSK_NX90_mmio_pio_oe_line_reset_cfg0_line         0x0000ffffU
#define SRT_NX90_mmio_pio_oe_line_reset_cfg0_line         0
#define DFLT_VAL_NX90_mmio_pio_oe_line_reset_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX90_mmio_pio_oe_line_reset_cfg0_line 0x00000000U

/* all used bits of 'NX90_mmio_pio_oe_line_reset_cfg0': */
#define MSK_USED_BITS_NX90_mmio_pio_oe_line_reset_cfg0 0x0000ffffU

enum {
  BFW_NX90_mmio_pio_oe_line_reset_cfg0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_pio_oe_line_reset_cfg0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_PIO_OE_LINE_RESET_CFG0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_pio_oe_line_reset_cfg0_line;      /* Write '1's to clear the related MMIO output enable (when it is in PIO mode).                                       */
                                                                           /* If related MMIO is not in PIO mode, programmed setting is ignored.                                                 */
                                                                           /* Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 15 controlls MMIO15.                                           */
                                                                           /* For read the current value of the programmed output enables is returned (i.e. the value of mmio_pio_oe_line_cfg0). */
  unsigned int reserved1 : BFW_NX90_mmio_pio_oe_line_reset_cfg0_reserved1; /* reserved                                                                                                           */
} NX90_MMIO_PIO_OE_LINE_RESET_CFG0_BIT_T;

typedef union {
  uint32_t                               val;
  NX90_MMIO_PIO_OE_LINE_RESET_CFG0_BIT_T bf;
} NX90_MMIO_PIO_OE_LINE_RESET_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_in_line_status0 */
/* => MMIO input line register of MMIO 0 to 15. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_in_line_status0       0x00000058U
#define Adr_NX90_mmio_ctrl_mmio_in_line_status0 0xFF401358U
#define Adr_NX90_mmio_in_line_status0           0xFF401358U

#define MSK_NX90_mmio_in_line_status0_line 0x0000ffffU
#define SRT_NX90_mmio_in_line_status0_line 0

/* all used bits of 'NX90_mmio_in_line_status0': */
#define MSK_USED_BITS_NX90_mmio_in_line_status0 0x0000ffffU

enum {
  BFW_NX90_mmio_in_line_status0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_in_line_status0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_IN_LINE_STATUS0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_in_line_status0_line;      /* sampled MMIO input state.                                               */
                                                                    /* Does not depend whether MMIO is in PIO mode or not.                     */
                                                                    /* Bit 0 monitors MMIO0, Bit 1 monitors MMIO1, ... bit 15 monitors MMIO15. */
  unsigned int reserved1 : BFW_NX90_mmio_in_line_status0_reserved1; /* reserved                                                                */
} NX90_MMIO_IN_LINE_STATUS0_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_MMIO_IN_LINE_STATUS0_BIT_T bf;
} NX90_MMIO_IN_LINE_STATUS0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_is_pio_status0 */
/* => MMIO mode line register of MMIO 0 to 15. */
/*    Note: PIO Mode can be enabled or disabled in mmio_cfg registers. */
/*    Note */
/*       MMIO8 is not a standard-function MMIO and has no PIO function. When bit 8 is set, MMIO8-function will be active on HIF_D8. */
/*       MMIO9 is not a standard-function MMIO and has no PIO function. When bit 9 is set, MMIO9-function will be active on HIF_D9. */
/*       MMIO10 is not a standard-function MMIO and has no PIO function. When bit 10 is set, MMIO10-function will be active on HIF_D10. */
/*       MMIO11 is not a standard-function MMIO and has no PIO function. When bit 11 is set, MMIO11-function will be active on HIF_D11. */
/*       MMIO12 is not a standard-function MMIO and has no PIO function. When bit 12 is set, MMIO12-function will be active on HIF_D12. */
/*       MMIO13 is not a standard-function MMIO and has no PIO function. When bit 13 is set, MMIO13-function will be active on HIF_D13. */
/*       MMIO14 is not a standard-function MMIO and has no PIO function. When bit 14 is set, MMIO14-function will be active on HIF_D14. */
/*       MMIO15 is not a standard-function MMIO and has no PIO function. When bit 15 is set, MMIO15-function will be active on HIF_D15. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mmio_is_pio_status0       0x0000005CU
#define Adr_NX90_mmio_ctrl_mmio_is_pio_status0 0xFF40135CU
#define Adr_NX90_mmio_is_pio_status0           0xFF40135CU

#define MSK_NX90_mmio_is_pio_status0_line 0x0000ffffU
#define SRT_NX90_mmio_is_pio_status0_line 0

/* all used bits of 'NX90_mmio_is_pio_status0': */
#define MSK_USED_BITS_NX90_mmio_is_pio_status0 0x0000ffffU

enum {
  BFW_NX90_mmio_is_pio_status0_line      = 16, /* [15:0] */
  BFW_NX90_mmio_is_pio_status0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MMIO_IS_PIO_STATUS0_BIT_Ttag {
  unsigned int line      : BFW_NX90_mmio_is_pio_status0_line;      /* Bit 0 shows status of MMIO0, Bit 1 shows status of  MMIO1, ... bit 15 shows MMIO15.                                                 */
                                                                   /* If the MMIO is the standard function of the netX IO (i.e. the netX pin name is MMIOx), the bit of the                               */
                                                                   /* related MMIO shows whether the MMIO is in PIO mode or not.                                                                          */
                                                                   /* If the MMIO is a multiplex function of a netX IO (i.e. the netX pin name is another than MMIOx), a PIO function is not              */
                                                                   /* available by the MMIO function. In this case the bit of the related MMIO shows whether the MMIO function is selected or not.        */
                                                                   /* {                                 |       |                                                                                         */
                                                                   /*   The related MMIO is a standard-   Value   Status                                                                                  */
                                                                   /*   function MMIO (netX MMIOx pin)                                                                                                    */
                                                                   /*                 yes                   0     The related MMIO is not in PIO mode (is assigned to core functionality).                */
                                                                   /*                 yes                   1     The related MMIO is in PIO mode (is not assigned to core functionality).                */
                                                                   /*                 no                    0     The MMIO-function of the netX IO is selected and assigned to a MMIO core functionality. */
                                                                   /*                 no                    1     The MMIO-function of the related netX IO is not selected. }                             */
                                                                   /* Note: When the MMIO function is selected it could be possible that also another IO multiplex function is                            */
                                                                   /*    activated (e.g. by global IO-configuration registers 'io_config'). This function could have higher priority                      */
                                                                   /*    in global IO multiplexing and could deselect the MMIO function.                                                                  */
  unsigned int reserved1 : BFW_NX90_mmio_is_pio_status0_reserved1; /* reserved                                                                                                                            */
} NX90_MMIO_IS_PIO_STATUS0_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_MMIO_IS_PIO_STATUS0_BIT_T bf;
} NX90_MMIO_IS_PIO_STATUS0_T;


/* ===================================================================== */

/* Area of global_buf_man */

/* ===================================================================== */

#define Addr_NX90_global_buf_man 0xFF401380U

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_0 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_0            0x00000000U
#define Adr_NX90_global_buf_man_global_read_buffer_0 0xFF401380U
#define Adr_NX90_global_read_buffer_0                0xFF401380U
#define DFLT_VAL_NX90_global_read_buffer_0           0x00000003U

#define MSK_NX90_global_read_buffer_0_val         0x00000003U
#define SRT_NX90_global_read_buffer_0_val         0
#define DFLT_VAL_NX90_global_read_buffer_0_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_0_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_0': */
#define MSK_USED_BITS_NX90_global_read_buffer_0 0x00000003U

enum {
  BFW_NX90_global_read_buffer_0_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_0_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_0_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_0_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_0_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_0_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_0_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_0_T;

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_1 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_1            0x00000004U
#define Adr_NX90_global_buf_man_global_read_buffer_1 0xFF401384U
#define Adr_NX90_global_read_buffer_1                0xFF401384U
#define DFLT_VAL_NX90_global_read_buffer_1           0x00000003U

#define MSK_NX90_global_read_buffer_1_val         0x00000003U
#define SRT_NX90_global_read_buffer_1_val         0
#define DFLT_VAL_NX90_global_read_buffer_1_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_1_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_1': */
#define MSK_USED_BITS_NX90_global_read_buffer_1 0x00000003U

enum {
  BFW_NX90_global_read_buffer_1_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_1_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_1_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_1_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_1_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_1_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_1_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_1_T;

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_2 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_2            0x00000008U
#define Adr_NX90_global_buf_man_global_read_buffer_2 0xFF401388U
#define Adr_NX90_global_read_buffer_2                0xFF401388U
#define DFLT_VAL_NX90_global_read_buffer_2           0x00000003U

#define MSK_NX90_global_read_buffer_2_val         0x00000003U
#define SRT_NX90_global_read_buffer_2_val         0
#define DFLT_VAL_NX90_global_read_buffer_2_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_2_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_2': */
#define MSK_USED_BITS_NX90_global_read_buffer_2 0x00000003U

enum {
  BFW_NX90_global_read_buffer_2_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_2_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_2_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_2_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_2_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_2_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_2_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_2_T;

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_3 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_3            0x0000000CU
#define Adr_NX90_global_buf_man_global_read_buffer_3 0xFF40138CU
#define Adr_NX90_global_read_buffer_3                0xFF40138CU
#define DFLT_VAL_NX90_global_read_buffer_3           0x00000003U

#define MSK_NX90_global_read_buffer_3_val         0x00000003U
#define SRT_NX90_global_read_buffer_3_val         0
#define DFLT_VAL_NX90_global_read_buffer_3_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_3_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_3': */
#define MSK_USED_BITS_NX90_global_read_buffer_3 0x00000003U

enum {
  BFW_NX90_global_read_buffer_3_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_3_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_3_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_3_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_3_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_3_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_3_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_3_T;

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_4 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_4            0x00000010U
#define Adr_NX90_global_buf_man_global_read_buffer_4 0xFF401390U
#define Adr_NX90_global_read_buffer_4                0xFF401390U
#define DFLT_VAL_NX90_global_read_buffer_4           0x00000003U

#define MSK_NX90_global_read_buffer_4_val         0x00000003U
#define SRT_NX90_global_read_buffer_4_val         0
#define DFLT_VAL_NX90_global_read_buffer_4_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_4_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_4': */
#define MSK_USED_BITS_NX90_global_read_buffer_4 0x00000003U

enum {
  BFW_NX90_global_read_buffer_4_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_4_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_4_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_4_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_4_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_4_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_4_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_4_T;

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_5 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_5            0x00000014U
#define Adr_NX90_global_buf_man_global_read_buffer_5 0xFF401394U
#define Adr_NX90_global_read_buffer_5                0xFF401394U
#define DFLT_VAL_NX90_global_read_buffer_5           0x00000003U

#define MSK_NX90_global_read_buffer_5_val         0x00000003U
#define SRT_NX90_global_read_buffer_5_val         0
#define DFLT_VAL_NX90_global_read_buffer_5_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_5_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_5': */
#define MSK_USED_BITS_NX90_global_read_buffer_5 0x00000003U

enum {
  BFW_NX90_global_read_buffer_5_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_5_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_5_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_5_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_5_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_5_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_5_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_5_T;

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_6 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_6            0x00000018U
#define Adr_NX90_global_buf_man_global_read_buffer_6 0xFF401398U
#define Adr_NX90_global_read_buffer_6                0xFF401398U
#define DFLT_VAL_NX90_global_read_buffer_6           0x00000003U

#define MSK_NX90_global_read_buffer_6_val         0x00000003U
#define SRT_NX90_global_read_buffer_6_val         0
#define DFLT_VAL_NX90_global_read_buffer_6_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_6_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_6': */
#define MSK_USED_BITS_NX90_global_read_buffer_6 0x00000003U

enum {
  BFW_NX90_global_read_buffer_6_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_6_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_6_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_6_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_6_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_6_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_6_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_6_T;

/* --------------------------------------------------------------------- */
/* Register global_read_buffer_7 */
/* => read: get read buffer number */
/*    write reset buffer states */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_read_buffer_7            0x0000001CU
#define Adr_NX90_global_buf_man_global_read_buffer_7 0xFF40139CU
#define Adr_NX90_global_read_buffer_7                0xFF40139CU
#define DFLT_VAL_NX90_global_read_buffer_7           0x00000003U

#define MSK_NX90_global_read_buffer_7_val         0x00000003U
#define SRT_NX90_global_read_buffer_7_val         0
#define DFLT_VAL_NX90_global_read_buffer_7_val    0x00000003U
#define DFLT_BF_VAL_NX90_global_read_buffer_7_val 0x00000003U

/* all used bits of 'NX90_global_read_buffer_7': */
#define MSK_USED_BITS_NX90_global_read_buffer_7 0x00000003U

enum {
  BFW_NX90_global_read_buffer_7_val       = 2,  /* [1:0] */
  BFW_NX90_global_read_buffer_7_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_READ_BUFFER_7_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_read_buffer_7_val;       /* read: read buffer number[0,1,2] , [3] = empty-no buffer */
  unsigned int reserved1 : BFW_NX90_global_read_buffer_7_reserved1; /* reserved                                                */
} NX90_GLOBAL_READ_BUFFER_7_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GLOBAL_READ_BUFFER_7_BIT_T bf;
} NX90_GLOBAL_READ_BUFFER_7_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_0 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_0            0x00000020U
#define Adr_NX90_global_buf_man_global_write_buffer_0 0xFF4013A0U
#define Adr_NX90_global_write_buffer_0                0xFF4013A0U
#define DFLT_VAL_NX90_global_write_buffer_0           0x00000000U

#define MSK_NX90_global_write_buffer_0_val         0x00000003U
#define SRT_NX90_global_write_buffer_0_val         0
#define DFLT_VAL_NX90_global_write_buffer_0_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_0_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_0': */
#define MSK_USED_BITS_NX90_global_write_buffer_0 0x00000003U

enum {
  BFW_NX90_global_write_buffer_0_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_0_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_0_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_0_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_0_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_0_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_0_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_0_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_1 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_1            0x00000024U
#define Adr_NX90_global_buf_man_global_write_buffer_1 0xFF4013A4U
#define Adr_NX90_global_write_buffer_1                0xFF4013A4U
#define DFLT_VAL_NX90_global_write_buffer_1           0x00000000U

#define MSK_NX90_global_write_buffer_1_val         0x00000003U
#define SRT_NX90_global_write_buffer_1_val         0
#define DFLT_VAL_NX90_global_write_buffer_1_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_1_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_1': */
#define MSK_USED_BITS_NX90_global_write_buffer_1 0x00000003U

enum {
  BFW_NX90_global_write_buffer_1_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_1_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_1_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_1_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_1_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_1_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_1_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_1_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_2 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_2            0x00000028U
#define Adr_NX90_global_buf_man_global_write_buffer_2 0xFF4013A8U
#define Adr_NX90_global_write_buffer_2                0xFF4013A8U
#define DFLT_VAL_NX90_global_write_buffer_2           0x00000000U

#define MSK_NX90_global_write_buffer_2_val         0x00000003U
#define SRT_NX90_global_write_buffer_2_val         0
#define DFLT_VAL_NX90_global_write_buffer_2_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_2_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_2': */
#define MSK_USED_BITS_NX90_global_write_buffer_2 0x00000003U

enum {
  BFW_NX90_global_write_buffer_2_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_2_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_2_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_2_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_2_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_2_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_2_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_2_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_3 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_3            0x0000002CU
#define Adr_NX90_global_buf_man_global_write_buffer_3 0xFF4013ACU
#define Adr_NX90_global_write_buffer_3                0xFF4013ACU
#define DFLT_VAL_NX90_global_write_buffer_3           0x00000000U

#define MSK_NX90_global_write_buffer_3_val         0x00000003U
#define SRT_NX90_global_write_buffer_3_val         0
#define DFLT_VAL_NX90_global_write_buffer_3_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_3_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_3': */
#define MSK_USED_BITS_NX90_global_write_buffer_3 0x00000003U

enum {
  BFW_NX90_global_write_buffer_3_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_3_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_3_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_3_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_3_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_3_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_3_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_3_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_4 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_4            0x00000030U
#define Adr_NX90_global_buf_man_global_write_buffer_4 0xFF4013B0U
#define Adr_NX90_global_write_buffer_4                0xFF4013B0U
#define DFLT_VAL_NX90_global_write_buffer_4           0x00000000U

#define MSK_NX90_global_write_buffer_4_val         0x00000003U
#define SRT_NX90_global_write_buffer_4_val         0
#define DFLT_VAL_NX90_global_write_buffer_4_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_4_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_4': */
#define MSK_USED_BITS_NX90_global_write_buffer_4 0x00000003U

enum {
  BFW_NX90_global_write_buffer_4_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_4_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_4_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_4_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_4_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_4_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_4_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_4_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_5 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_5            0x00000034U
#define Adr_NX90_global_buf_man_global_write_buffer_5 0xFF4013B4U
#define Adr_NX90_global_write_buffer_5                0xFF4013B4U
#define DFLT_VAL_NX90_global_write_buffer_5           0x00000000U

#define MSK_NX90_global_write_buffer_5_val         0x00000003U
#define SRT_NX90_global_write_buffer_5_val         0
#define DFLT_VAL_NX90_global_write_buffer_5_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_5_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_5': */
#define MSK_USED_BITS_NX90_global_write_buffer_5 0x00000003U

enum {
  BFW_NX90_global_write_buffer_5_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_5_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_5_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_5_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_5_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_5_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_5_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_5_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_6 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_6            0x00000038U
#define Adr_NX90_global_buf_man_global_write_buffer_6 0xFF4013B8U
#define Adr_NX90_global_write_buffer_6                0xFF4013B8U
#define DFLT_VAL_NX90_global_write_buffer_6           0x00000000U

#define MSK_NX90_global_write_buffer_6_val         0x00000003U
#define SRT_NX90_global_write_buffer_6_val         0
#define DFLT_VAL_NX90_global_write_buffer_6_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_6_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_6': */
#define MSK_USED_BITS_NX90_global_write_buffer_6 0x00000003U

enum {
  BFW_NX90_global_write_buffer_6_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_6_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_6_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_6_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_6_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_6_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_6_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_6_T;

/* --------------------------------------------------------------------- */
/* Register global_write_buffer_7 */
/* => read: get write buffer number */
/*    write release write buffer */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_global_write_buffer_7            0x0000003CU
#define Adr_NX90_global_buf_man_global_write_buffer_7 0xFF4013BCU
#define Adr_NX90_global_write_buffer_7                0xFF4013BCU
#define DFLT_VAL_NX90_global_write_buffer_7           0x00000000U

#define MSK_NX90_global_write_buffer_7_val         0x00000003U
#define SRT_NX90_global_write_buffer_7_val         0
#define DFLT_VAL_NX90_global_write_buffer_7_val    0x00000000U
#define DFLT_BF_VAL_NX90_global_write_buffer_7_val 0x00000000U

/* all used bits of 'NX90_global_write_buffer_7': */
#define MSK_USED_BITS_NX90_global_write_buffer_7 0x00000003U

enum {
  BFW_NX90_global_write_buffer_7_val       = 2,  /* [1:0] */
  BFW_NX90_global_write_buffer_7_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_GLOBAL_WRITE_BUFFER_7_BIT_Ttag {
  unsigned int val       : BFW_NX90_global_write_buffer_7_val;       /* read: write buffer number[0,1,2] */
  unsigned int reserved1 : BFW_NX90_global_write_buffer_7_reserved1; /* reserved                         */
} NX90_GLOBAL_WRITE_BUFFER_7_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GLOBAL_WRITE_BUFFER_7_BIT_T bf;
} NX90_GLOBAL_WRITE_BUFFER_7_T;


/* ===================================================================== */

/* AREA iflash_cfg */
/* Area of iflash_cfg2 */

/* ===================================================================== */

#define Addr_NX90_iflash_cfg2 0xFF401400U

/* --------------------------------------------------------------------- */
/* Register buffer_read_ahead_instructions */
/* => read ahead on instruction channel of flash controller */
/*    max read ahead = buffer lines - 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_buffer_read_ahead_instructions         0x00000000U
#define Adr_NX90_iflash_cfg2_buffer_read_ahead_instructions 0xFF401400U
#define Adr_NX90_buffer_read_ahead_instructions             0xFF401400U
#define DFLT_VAL_NX90_buffer_read_ahead_instructions        0x00000000U

#define MSK_NX90_buffer_read_ahead_instructions_val         0xffffffffU
#define SRT_NX90_buffer_read_ahead_instructions_val         0
#define DFLT_VAL_NX90_buffer_read_ahead_instructions_val    0x00000000U
#define DFLT_BF_VAL_NX90_buffer_read_ahead_instructions_val 0x00000000U

/* all used bits of 'NX90_buffer_read_ahead_instructions': */
#define MSK_USED_BITS_NX90_buffer_read_ahead_instructions 0xffffffffU

enum {
  BFW_NX90_buffer_read_ahead_instructions_val = 32  /* [31:0] */
};

typedef struct NX90_BUFFER_READ_AHEAD_INSTRUCTIONS_BIT_Ttag {
  unsigned int val : BFW_NX90_buffer_read_ahead_instructions_val; /*  read ahead on instruction channel of flash controller */
} NX90_BUFFER_READ_AHEAD_INSTRUCTIONS_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_BUFFER_READ_AHEAD_INSTRUCTIONS_BIT_T bf;
} NX90_BUFFER_READ_AHEAD_INSTRUCTIONS_T;

/* --------------------------------------------------------------------- */
/* Register buffer_read_ahead_data */
/* => read ahead on data channel of flash controller */
/*    max read ahead = buffer lines - 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_buffer_read_ahead_data         0x00000004U
#define Adr_NX90_iflash_cfg2_buffer_read_ahead_data 0xFF401404U
#define Adr_NX90_buffer_read_ahead_data             0xFF401404U
#define DFLT_VAL_NX90_buffer_read_ahead_data        0x00000000U

#define MSK_NX90_buffer_read_ahead_data_val         0xffffffffU
#define SRT_NX90_buffer_read_ahead_data_val         0
#define DFLT_VAL_NX90_buffer_read_ahead_data_val    0x00000000U
#define DFLT_BF_VAL_NX90_buffer_read_ahead_data_val 0x00000000U

/* all used bits of 'NX90_buffer_read_ahead_data': */
#define MSK_USED_BITS_NX90_buffer_read_ahead_data 0xffffffffU

enum {
  BFW_NX90_buffer_read_ahead_data_val = 32  /* [31:0] */
};

typedef struct NX90_BUFFER_READ_AHEAD_DATA_BIT_Ttag {
  unsigned int val : BFW_NX90_buffer_read_ahead_data_val; /*  read ahead on data channel of flash controller */
} NX90_BUFFER_READ_AHEAD_DATA_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_BUFFER_READ_AHEAD_DATA_BIT_T bf;
} NX90_BUFFER_READ_AHEAD_DATA_T;

/* --------------------------------------------------------------------- */
/* Register iflash_signals_cfg */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_signals_cfg         0x00000008U
#define Adr_NX90_iflash_cfg2_iflash_signals_cfg 0xFF401408U
#define Adr_NX90_iflash_signals_cfg             0xFF401408U
#define DFLT_VAL_NX90_iflash_signals_cfg        0x00000000U

#define MSK_NX90_iflash_signals_cfg_xe            0x00000001U
#define SRT_NX90_iflash_signals_cfg_xe            0
#define DFLT_VAL_NX90_iflash_signals_cfg_xe       0x00000000U
#define DFLT_BF_VAL_NX90_iflash_signals_cfg_xe    0x00000000U
#define MSK_NX90_iflash_signals_cfg_ye            0x00000002U
#define SRT_NX90_iflash_signals_cfg_ye            1
#define DFLT_VAL_NX90_iflash_signals_cfg_ye       0x00000000U
#define DFLT_BF_VAL_NX90_iflash_signals_cfg_ye    0x00000000U
#define MSK_NX90_iflash_signals_cfg_erase         0x00000004U
#define SRT_NX90_iflash_signals_cfg_erase         2
#define DFLT_VAL_NX90_iflash_signals_cfg_erase    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_signals_cfg_erase 0x00000000U
#define MSK_NX90_iflash_signals_cfg_mas1          0x00000008U
#define SRT_NX90_iflash_signals_cfg_mas1          3
#define DFLT_VAL_NX90_iflash_signals_cfg_mas1     0x00000000U
#define DFLT_BF_VAL_NX90_iflash_signals_cfg_mas1  0x00000000U
#define MSK_NX90_iflash_signals_cfg_nvstr         0x00000010U
#define SRT_NX90_iflash_signals_cfg_nvstr         4
#define DFLT_VAL_NX90_iflash_signals_cfg_nvstr    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_signals_cfg_nvstr 0x00000000U
#define MSK_NX90_iflash_signals_cfg_prog          0x00000020U
#define SRT_NX90_iflash_signals_cfg_prog          5
#define DFLT_VAL_NX90_iflash_signals_cfg_prog     0x00000000U
#define DFLT_BF_VAL_NX90_iflash_signals_cfg_prog  0x00000000U
#define MSK_NX90_iflash_signals_cfg_se            0x00000040U
#define SRT_NX90_iflash_signals_cfg_se            6
#define DFLT_VAL_NX90_iflash_signals_cfg_se       0x00000000U
#define DFLT_BF_VAL_NX90_iflash_signals_cfg_se    0x00000000U

/* all used bits of 'NX90_iflash_signals_cfg': */
#define MSK_USED_BITS_NX90_iflash_signals_cfg 0x0000007fU

enum {
  BFW_NX90_iflash_signals_cfg_xe        = 1,  /* [0] */
  BFW_NX90_iflash_signals_cfg_ye        = 1,  /* [1] */
  BFW_NX90_iflash_signals_cfg_erase     = 1,  /* [2] */
  BFW_NX90_iflash_signals_cfg_mas1      = 1,  /* [3] */
  BFW_NX90_iflash_signals_cfg_nvstr     = 1,  /* [4] */
  BFW_NX90_iflash_signals_cfg_prog      = 1,  /* [5] */
  BFW_NX90_iflash_signals_cfg_se        = 1,  /* [6] */
  BFW_NX90_iflash_signals_cfg_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_IFLASH_SIGNALS_CFG_BIT_Ttag {
  unsigned int xe        : BFW_NX90_iflash_signals_cfg_xe;        /* x address enable                 */
  unsigned int ye        : BFW_NX90_iflash_signals_cfg_ye;        /* y address enable                 */
  unsigned int erase     : BFW_NX90_iflash_signals_cfg_erase;     /* defines erase cycle              */
  unsigned int mas1      : BFW_NX90_iflash_signals_cfg_mas1;      /* defines mass erase cycle         */
  unsigned int nvstr     : BFW_NX90_iflash_signals_cfg_nvstr;     /* defines non-volatile store cycle */
  unsigned int prog      : BFW_NX90_iflash_signals_cfg_prog;      /* defines program cycle            */
  unsigned int se        : BFW_NX90_iflash_signals_cfg_se;        /* flash clock                      */
  unsigned int reserved1 : BFW_NX90_iflash_signals_cfg_reserved1; /* reserved                         */
} NX90_IFLASH_SIGNALS_CFG_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_IFLASH_SIGNALS_CFG_BIT_T bf;
} NX90_IFLASH_SIGNALS_CFG_T;

/* --------------------------------------------------------------------- */
/* Register iflash_mode_cfg */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_mode_cfg         0x0000000CU
#define Adr_NX90_iflash_cfg2_iflash_mode_cfg 0xFF40140CU
#define Adr_NX90_iflash_mode_cfg             0xFF40140CU
#define DFLT_VAL_NX90_iflash_mode_cfg        0x00000000U

#define MSK_NX90_iflash_mode_cfg_iflash_mode         0x00000007U
#define SRT_NX90_iflash_mode_cfg_iflash_mode         0
#define DFLT_VAL_NX90_iflash_mode_cfg_iflash_mode    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_mode_cfg_iflash_mode 0x00000000U

/* all used bits of 'NX90_iflash_mode_cfg': */
#define MSK_USED_BITS_NX90_iflash_mode_cfg 0x00000007U

enum {
  BFW_NX90_iflash_mode_cfg_iflash_mode = 3,  /* [2:0] */
  BFW_NX90_iflash_mode_cfg_reserved1   = 29  /* [31:3] */
};

typedef struct NX90_IFLASH_MODE_CFG_BIT_Ttag {
  unsigned int iflash_mode : BFW_NX90_iflash_mode_cfg_iflash_mode; /* 3'b000 READ_MODE /  3'b001 PROGRAM_MODE /  3'b010 ERASE_MODE / 3'b011 MASS_ERASE_MODE / 3'b100 MANUAL_MODE */
  unsigned int reserved1   : BFW_NX90_iflash_mode_cfg_reserved1;   /* reserved                                                                                                   */
} NX90_IFLASH_MODE_CFG_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IFLASH_MODE_CFG_BIT_T bf;
} NX90_IFLASH_MODE_CFG_T;

/* --------------------------------------------------------------------- */
/* Register iflash_access */
/* => read only for the ready bit, write 1 to start access */
/*    flash action depends on iflash_mode_cfg */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_access         0x00000010U
#define Adr_NX90_iflash_cfg2_iflash_access 0xFF401410U
#define Adr_NX90_iflash_access             0xFF401410U

#define MSK_NX90_iflash_access_run 0x00000001U
#define SRT_NX90_iflash_access_run 0

/* all used bits of 'NX90_iflash_access': */
#define MSK_USED_BITS_NX90_iflash_access 0x00000001U

enum {
  BFW_NX90_iflash_access_run       = 1,  /* [0] */
  BFW_NX90_iflash_access_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_IFLASH_ACCESS_BIT_Ttag {
  unsigned int run       : BFW_NX90_iflash_access_run;       /* write 1 to start accesss, poll until set to 0 for finsh */
  unsigned int reserved1 : BFW_NX90_iflash_access_reserved1; /* reserved                                                */
} NX90_IFLASH_ACCESS_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_IFLASH_ACCESS_BIT_T bf;
} NX90_IFLASH_ACCESS_T;

/* --------------------------------------------------------------------- */
/* Register iflash_yadr */
/* => Y address of flash controller */
/*    not all bits are used see: implementation size of flash */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_yadr         0x00000014U
#define Adr_NX90_iflash_cfg2_iflash_yadr 0xFF401414U
#define Adr_NX90_iflash_yadr             0xFF401414U
#define DFLT_VAL_NX90_iflash_yadr        0x00000000U

#define MSK_NX90_iflash_yadr_val         0x0000001fU
#define SRT_NX90_iflash_yadr_val         0
#define DFLT_VAL_NX90_iflash_yadr_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_yadr_val 0x00000000U

/* all used bits of 'NX90_iflash_yadr': */
#define MSK_USED_BITS_NX90_iflash_yadr 0x0000001fU

enum {
  BFW_NX90_iflash_yadr_val       = 5,  /* [4:0] */
  BFW_NX90_iflash_yadr_reserved1 = 27  /* [31:5] */
};

typedef struct NX90_IFLASH_YADR_BIT_Ttag {
  unsigned int val       : BFW_NX90_iflash_yadr_val;       /* Y address of flash controller */
  unsigned int reserved1 : BFW_NX90_iflash_yadr_reserved1; /* reserved                      */
} NX90_IFLASH_YADR_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IFLASH_YADR_BIT_T bf;
} NX90_IFLASH_YADR_T;

/* --------------------------------------------------------------------- */
/* Register iflash_xadr */
/* => X address of flash controller */
/*    not all bits are used see: implementation size of flash */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_xadr         0x00000018U
#define Adr_NX90_iflash_cfg2_iflash_xadr 0xFF401418U
#define Adr_NX90_iflash_xadr             0xFF401418U
#define DFLT_VAL_NX90_iflash_xadr        0x00000000U

#define MSK_NX90_iflash_xadr_val         0x000003ffU
#define SRT_NX90_iflash_xadr_val         0
#define DFLT_VAL_NX90_iflash_xadr_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_xadr_val 0x00000000U

/* all used bits of 'NX90_iflash_xadr': */
#define MSK_USED_BITS_NX90_iflash_xadr 0x000003ffU

enum {
  BFW_NX90_iflash_xadr_val       = 10, /* [9:0] */
  BFW_NX90_iflash_xadr_reserved1 = 22  /* [31:10] */
};

typedef struct NX90_IFLASH_XADR_BIT_Ttag {
  unsigned int val       : BFW_NX90_iflash_xadr_val;       /* X address of flash controller */
  unsigned int reserved1 : BFW_NX90_iflash_xadr_reserved1; /* reserved                      */
} NX90_IFLASH_XADR_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IFLASH_XADR_BIT_T bf;
} NX90_IFLASH_XADR_T;

/* --------------------------------------------------------------------- */
/* Register iflash_din0 */
/* => data[31:0] of din flash controller */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_din0         0x0000001CU
#define Adr_NX90_iflash_cfg2_iflash_din0 0xFF40141CU
#define Adr_NX90_iflash_din0             0xFF40141CU
#define DFLT_VAL_NX90_iflash_din0        0x00000000U

#define MSK_NX90_iflash_din0_val         0xffffffffU
#define SRT_NX90_iflash_din0_val         0
#define DFLT_VAL_NX90_iflash_din0_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_din0_val 0x00000000U

/* all used bits of 'NX90_iflash_din0': */
#define MSK_USED_BITS_NX90_iflash_din0 0xffffffffU

enum {
  BFW_NX90_iflash_din0_val = 32  /* [31:0] */
};

typedef struct NX90_IFLASH_DIN0_BIT_Ttag {
  unsigned int val : BFW_NX90_iflash_din0_val; /* data[31:0] of din flash controller */
} NX90_IFLASH_DIN0_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IFLASH_DIN0_BIT_T bf;
} NX90_IFLASH_DIN0_T;

/* --------------------------------------------------------------------- */
/* Register iflash_din1 */
/* => data[63:32] of din flash controller */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_din1         0x00000020U
#define Adr_NX90_iflash_cfg2_iflash_din1 0xFF401420U
#define Adr_NX90_iflash_din1             0xFF401420U
#define DFLT_VAL_NX90_iflash_din1        0x00000000U

#define MSK_NX90_iflash_din1_val         0xffffffffU
#define SRT_NX90_iflash_din1_val         0
#define DFLT_VAL_NX90_iflash_din1_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_din1_val 0x00000000U

/* all used bits of 'NX90_iflash_din1': */
#define MSK_USED_BITS_NX90_iflash_din1 0xffffffffU

enum {
  BFW_NX90_iflash_din1_val = 32  /* [31:0] */
};

typedef struct NX90_IFLASH_DIN1_BIT_Ttag {
  unsigned int val : BFW_NX90_iflash_din1_val; /* data[63:32] of din flash controller */
} NX90_IFLASH_DIN1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IFLASH_DIN1_BIT_T bf;
} NX90_IFLASH_DIN1_T;

/* --------------------------------------------------------------------- */
/* Register iflash_din2 */
/* => data[95:64] of din flash controller */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_din2         0x00000024U
#define Adr_NX90_iflash_cfg2_iflash_din2 0xFF401424U
#define Adr_NX90_iflash_din2             0xFF401424U
#define DFLT_VAL_NX90_iflash_din2        0x00000000U

#define MSK_NX90_iflash_din2_val         0xffffffffU
#define SRT_NX90_iflash_din2_val         0
#define DFLT_VAL_NX90_iflash_din2_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_din2_val 0x00000000U

/* all used bits of 'NX90_iflash_din2': */
#define MSK_USED_BITS_NX90_iflash_din2 0xffffffffU

enum {
  BFW_NX90_iflash_din2_val = 32  /* [31:0] */
};

typedef struct NX90_IFLASH_DIN2_BIT_Ttag {
  unsigned int val : BFW_NX90_iflash_din2_val; /* data[95:64] of din flash controller */
} NX90_IFLASH_DIN2_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IFLASH_DIN2_BIT_T bf;
} NX90_IFLASH_DIN2_T;

/* --------------------------------------------------------------------- */
/* Register iflash_din3 */
/* => data[127:96] of din flash controller */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_din3         0x00000028U
#define Adr_NX90_iflash_cfg2_iflash_din3 0xFF401428U
#define Adr_NX90_iflash_din3             0xFF401428U
#define DFLT_VAL_NX90_iflash_din3        0x00000000U

#define MSK_NX90_iflash_din3_val         0xffffffffU
#define SRT_NX90_iflash_din3_val         0
#define DFLT_VAL_NX90_iflash_din3_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_din3_val 0x00000000U

/* all used bits of 'NX90_iflash_din3': */
#define MSK_USED_BITS_NX90_iflash_din3 0xffffffffU

enum {
  BFW_NX90_iflash_din3_val = 32  /* [31:0] */
};

typedef struct NX90_IFLASH_DIN3_BIT_Ttag {
  unsigned int val : BFW_NX90_iflash_din3_val; /* data[127:96] of din flash controller */
} NX90_IFLASH_DIN3_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IFLASH_DIN3_BIT_T bf;
} NX90_IFLASH_DIN3_T;

/* --------------------------------------------------------------------- */
/* Register iflash_din4 */
/* => in manual mode for din */
/*    data[143:128] of din flash controller */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_din4         0x0000002CU
#define Adr_NX90_iflash_cfg2_iflash_din4 0xFF40142CU
#define Adr_NX90_iflash_din4             0xFF40142CU
#define DFLT_VAL_NX90_iflash_din4        0x00000000U

#define MSK_NX90_iflash_din4_val         0x0000ffffU
#define SRT_NX90_iflash_din4_val         0
#define DFLT_VAL_NX90_iflash_din4_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_din4_val 0x00000000U

/* all used bits of 'NX90_iflash_din4': */
#define MSK_USED_BITS_NX90_iflash_din4 0x0000ffffU

enum {
  BFW_NX90_iflash_din4_val       = 16, /* [15:0] */
  BFW_NX90_iflash_din4_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_IFLASH_DIN4_BIT_Ttag {
  unsigned int val       : BFW_NX90_iflash_din4_val;       /* data[143:128] of din flash controller */
  unsigned int reserved1 : BFW_NX90_iflash_din4_reserved1; /* reserved                              */
} NX90_IFLASH_DIN4_BIT_T;

typedef union {
  uint32_t               val;
  NX90_IFLASH_DIN4_BIT_T bf;
} NX90_IFLASH_DIN4_T;

/* --------------------------------------------------------------------- */
/* Register iflash_reset */
/* => reset flash controller */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_reset         0x00000030U
#define Adr_NX90_iflash_cfg2_iflash_reset 0xFF401430U
#define Adr_NX90_iflash_reset             0xFF401430U
#define DFLT_VAL_NX90_iflash_reset        0x00000000U

#define MSK_NX90_iflash_reset_reset         0x00000001U
#define SRT_NX90_iflash_reset_reset         0
#define DFLT_VAL_NX90_iflash_reset_reset    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_reset_reset 0x00000000U

/* all used bits of 'NX90_iflash_reset': */
#define MSK_USED_BITS_NX90_iflash_reset 0x00000001U

enum {
  BFW_NX90_iflash_reset_reset     = 1,  /* [0] */
  BFW_NX90_iflash_reset_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_IFLASH_RESET_BIT_Ttag {
  unsigned int reset     : BFW_NX90_iflash_reset_reset;     /* 1= reset; 0= release reset */
  unsigned int reserved1 : BFW_NX90_iflash_reset_reserved1; /* reserved                   */
} NX90_IFLASH_RESET_BIT_T;

typedef union {
  uint32_t                val;
  NX90_IFLASH_RESET_BIT_T bf;
} NX90_IFLASH_RESET_T;

/* --------------------------------------------------------------------- */
/* Register iflash_red_cfg0 */
/* => enable redundancy page XADR[9:3] */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_red_cfg0         0x00000034U
#define Adr_NX90_iflash_cfg2_iflash_red_cfg0 0xFF401434U
#define Adr_NX90_iflash_red_cfg0             0xFF401434U
#define DFLT_VAL_NX90_iflash_red_cfg0        0x00000001U

#define MSK_NX90_iflash_red_cfg0_n_enb         0x00000001U
#define SRT_NX90_iflash_red_cfg0_n_enb         0
#define DFLT_VAL_NX90_iflash_red_cfg0_n_enb    0x00000001U
#define DFLT_BF_VAL_NX90_iflash_red_cfg0_n_enb 0x00000001U
#define MSK_NX90_iflash_red_cfg0_adr0          0x000000feU
#define SRT_NX90_iflash_red_cfg0_adr0          1
#define DFLT_VAL_NX90_iflash_red_cfg0_adr0     0x00000000U
#define DFLT_BF_VAL_NX90_iflash_red_cfg0_adr0  0x00000000U

/* all used bits of 'NX90_iflash_red_cfg0': */
#define MSK_USED_BITS_NX90_iflash_red_cfg0 0x000000ffU

enum {
  BFW_NX90_iflash_red_cfg0_n_enb     = 1,  /* [0] */
  BFW_NX90_iflash_red_cfg0_adr0      = 7,  /* [7:1] */
  BFW_NX90_iflash_red_cfg0_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_IFLASH_RED_CFG0_BIT_Ttag {
  unsigned int n_enb     : BFW_NX90_iflash_red_cfg0_n_enb;     /* 0= enable XADR compare; 1= disable XADR compare */
  unsigned int adr0      : BFW_NX90_iflash_red_cfg0_adr0;      /* XADR to compare                                 */
  unsigned int reserved1 : BFW_NX90_iflash_red_cfg0_reserved1; /* reserved                                        */
} NX90_IFLASH_RED_CFG0_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IFLASH_RED_CFG0_BIT_T bf;
} NX90_IFLASH_RED_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register iflash_red_cfg1 */
/* => enable redundancy page XADR[9:3] */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_red_cfg1         0x00000038U
#define Adr_NX90_iflash_cfg2_iflash_red_cfg1 0xFF401438U
#define Adr_NX90_iflash_red_cfg1             0xFF401438U
#define DFLT_VAL_NX90_iflash_red_cfg1        0x00000001U

#define MSK_NX90_iflash_red_cfg1_n_enb         0x00000001U
#define SRT_NX90_iflash_red_cfg1_n_enb         0
#define DFLT_VAL_NX90_iflash_red_cfg1_n_enb    0x00000001U
#define DFLT_BF_VAL_NX90_iflash_red_cfg1_n_enb 0x00000001U
#define MSK_NX90_iflash_red_cfg1_adr1          0x000000feU
#define SRT_NX90_iflash_red_cfg1_adr1          1
#define DFLT_VAL_NX90_iflash_red_cfg1_adr1     0x00000000U
#define DFLT_BF_VAL_NX90_iflash_red_cfg1_adr1  0x00000000U

/* all used bits of 'NX90_iflash_red_cfg1': */
#define MSK_USED_BITS_NX90_iflash_red_cfg1 0x000000ffU

enum {
  BFW_NX90_iflash_red_cfg1_n_enb     = 1,  /* [0] */
  BFW_NX90_iflash_red_cfg1_adr1      = 7,  /* [7:1] */
  BFW_NX90_iflash_red_cfg1_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_IFLASH_RED_CFG1_BIT_Ttag {
  unsigned int n_enb     : BFW_NX90_iflash_red_cfg1_n_enb;     /* 0= enable XADR compare; 1= disable XADR compare */
  unsigned int adr1      : BFW_NX90_iflash_red_cfg1_adr1;      /* XADR to compare                                 */
  unsigned int reserved1 : BFW_NX90_iflash_red_cfg1_reserved1; /* reserved                                        */
} NX90_IFLASH_RED_CFG1_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IFLASH_RED_CFG1_BIT_T bf;
} NX90_IFLASH_RED_CFG1_T;

/* --------------------------------------------------------------------- */
/* Register iflash_ifren_cfg */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_ifren_cfg         0x0000003CU
#define Adr_NX90_iflash_cfg2_iflash_ifren_cfg 0xFF40143CU
#define Adr_NX90_iflash_ifren_cfg             0xFF40143CU
#define DFLT_VAL_NX90_iflash_ifren_cfg        0x00000000U

#define MSK_NX90_iflash_ifren_cfg_ifren          0x00000001U
#define SRT_NX90_iflash_ifren_cfg_ifren          0
#define DFLT_VAL_NX90_iflash_ifren_cfg_ifren     0x00000000U
#define DFLT_BF_VAL_NX90_iflash_ifren_cfg_ifren  0x00000000U
#define MSK_NX90_iflash_ifren_cfg_ifren1         0x00000002U
#define SRT_NX90_iflash_ifren_cfg_ifren1         1
#define DFLT_VAL_NX90_iflash_ifren_cfg_ifren1    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_ifren_cfg_ifren1 0x00000000U

/* all used bits of 'NX90_iflash_ifren_cfg': */
#define MSK_USED_BITS_NX90_iflash_ifren_cfg 0x00000003U

enum {
  BFW_NX90_iflash_ifren_cfg_ifren     = 1,  /* [0] */
  BFW_NX90_iflash_ifren_cfg_ifren1    = 1,  /* [1] */
  BFW_NX90_iflash_ifren_cfg_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_IFLASH_IFREN_CFG_BIT_Ttag {
  unsigned int ifren     : BFW_NX90_iflash_ifren_cfg_ifren;     /* information block enable                 */
  unsigned int ifren1    : BFW_NX90_iflash_ifren_cfg_ifren1;    /* information 1 block enable for read only */
  unsigned int reserved1 : BFW_NX90_iflash_ifren_cfg_reserved1; /* reserved                                 */
} NX90_IFLASH_IFREN_CFG_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_IFLASH_IFREN_CFG_BIT_T bf;
} NX90_IFLASH_IFREN_CFG_T;

/* --------------------------------------------------------------------- */
/* Register iflash_din4_ecc */
/* => in manual mode for ecc calculation of din3..0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_din4_ecc         0x00000040U
#define Adr_NX90_iflash_cfg2_iflash_din4_ecc 0xFF401440U
#define Adr_NX90_iflash_din4_ecc             0xFF401440U

#define MSK_NX90_iflash_din4_ecc_val 0x0000ffffU
#define SRT_NX90_iflash_din4_ecc_val 0

/* all used bits of 'NX90_iflash_din4_ecc': */
#define MSK_USED_BITS_NX90_iflash_din4_ecc 0x0000ffffU

enum {
  BFW_NX90_iflash_din4_ecc_val       = 16, /* [15:0] */
  BFW_NX90_iflash_din4_ecc_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_IFLASH_DIN4_ECC_BIT_Ttag {
  unsigned int val       : BFW_NX90_iflash_din4_ecc_val;       /* ecc of din3..0 flash controller */
  unsigned int reserved1 : BFW_NX90_iflash_din4_ecc_reserved1; /* reserved                        */
} NX90_IFLASH_DIN4_ECC_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IFLASH_DIN4_ECC_BIT_T bf;
} NX90_IFLASH_DIN4_ECC_T;

/* --------------------------------------------------------------------- */
/* Register iflash_special_cfg */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_special_cfg         0x00000044U
#define Adr_NX90_iflash_cfg2_iflash_special_cfg 0xFF401444U
#define Adr_NX90_iflash_special_cfg             0xFF401444U
#define DFLT_VAL_NX90_iflash_special_cfg        0x00000001U

#define MSK_NX90_iflash_special_cfg_tmr         0x00000001U
#define SRT_NX90_iflash_special_cfg_tmr         0
#define DFLT_VAL_NX90_iflash_special_cfg_tmr    0x00000001U
#define DFLT_BF_VAL_NX90_iflash_special_cfg_tmr 0x00000001U
#define MSK_NX90_iflash_special_cfg_slm         0x00000002U
#define SRT_NX90_iflash_special_cfg_slm         1
#define DFLT_VAL_NX90_iflash_special_cfg_slm    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_special_cfg_slm 0x00000000U

/* all used bits of 'NX90_iflash_special_cfg': */
#define MSK_USED_BITS_NX90_iflash_special_cfg 0x00000003U

enum {
  BFW_NX90_iflash_special_cfg_tmr       = 1,  /* [0] */
  BFW_NX90_iflash_special_cfg_slm       = 1,  /* [1] */
  BFW_NX90_iflash_special_cfg_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_IFLASH_SPECIAL_CFG_BIT_Ttag {
  unsigned int tmr       : BFW_NX90_iflash_special_cfg_tmr;       /* test mode  */
  unsigned int slm       : BFW_NX90_iflash_special_cfg_slm;       /* sleep mode */
  unsigned int reserved1 : BFW_NX90_iflash_special_cfg_reserved1; /* reserved   */
} NX90_IFLASH_SPECIAL_CFG_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_IFLASH_SPECIAL_CFG_BIT_T bf;
} NX90_IFLASH_SPECIAL_CFG_T;

/* --------------------------------------------------------------------- */
/* Register iflash_protection_info */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_protection_info         0x00000048U
#define Adr_NX90_iflash_cfg2_iflash_protection_info 0xFF401448U
#define Adr_NX90_iflash_protection_info             0xFF401448U
#define DFLT_VAL_NX90_iflash_protection_info        0x00000000U

#define MSK_NX90_iflash_protection_info_write_dw         0x00000001U
#define SRT_NX90_iflash_protection_info_write_dw         0
#define DFLT_VAL_NX90_iflash_protection_info_write_dw    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_protection_info_write_dw 0x00000000U
#define MSK_NX90_iflash_protection_info_write_up         0x00000002U
#define SRT_NX90_iflash_protection_info_write_up         1
#define DFLT_VAL_NX90_iflash_protection_info_write_up    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_protection_info_write_up 0x00000000U
#define MSK_NX90_iflash_protection_info_read_dw          0x00000004U
#define SRT_NX90_iflash_protection_info_read_dw          2
#define DFLT_VAL_NX90_iflash_protection_info_read_dw     0x00000000U
#define DFLT_BF_VAL_NX90_iflash_protection_info_read_dw  0x00000000U
#define MSK_NX90_iflash_protection_info_read_up          0x00000008U
#define SRT_NX90_iflash_protection_info_read_up          3
#define DFLT_VAL_NX90_iflash_protection_info_read_up     0x00000000U
#define DFLT_BF_VAL_NX90_iflash_protection_info_read_up  0x00000000U

/* all used bits of 'NX90_iflash_protection_info': */
#define MSK_USED_BITS_NX90_iflash_protection_info 0x0000000fU

enum {
  BFW_NX90_iflash_protection_info_write_dw  = 1,  /* [0] */
  BFW_NX90_iflash_protection_info_write_up  = 1,  /* [1] */
  BFW_NX90_iflash_protection_info_read_dw   = 1,  /* [2] */
  BFW_NX90_iflash_protection_info_read_up   = 1,  /* [3] */
  BFW_NX90_iflash_protection_info_reserved1 = 28  /* [31:4] */
};

typedef struct NX90_IFLASH_PROTECTION_INFO_BIT_Ttag {
  unsigned int write_dw  : BFW_NX90_iflash_protection_info_write_dw;  /* protect infopage 0 lower 4k page for write */
  unsigned int write_up  : BFW_NX90_iflash_protection_info_write_up;  /* protect infopage 0 upper 4k page for write */
  unsigned int read_dw   : BFW_NX90_iflash_protection_info_read_dw;   /* protect infopage 0 lower 4k page for read  */
  unsigned int read_up   : BFW_NX90_iflash_protection_info_read_up;   /* protect infopage 0 upper 4k page for read  */
  unsigned int reserved1 : BFW_NX90_iflash_protection_info_reserved1; /* reserved                                   */
} NX90_IFLASH_PROTECTION_INFO_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_IFLASH_PROTECTION_INFO_BIT_T bf;
} NX90_IFLASH_PROTECTION_INFO_T;

/* --------------------------------------------------------------------- */
/* Register iflash_write_protection_main */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_iflash_write_protection_main         0x0000004CU
#define Adr_NX90_iflash_cfg2_iflash_write_protection_main 0xFF40144CU
#define Adr_NX90_iflash_write_protection_main             0xFF40144CU
#define DFLT_VAL_NX90_iflash_write_protection_main        0x00000000U

#define MSK_NX90_iflash_write_protection_main_val         0xffffffffU
#define SRT_NX90_iflash_write_protection_main_val         0
#define DFLT_VAL_NX90_iflash_write_protection_main_val    0x00000000U
#define DFLT_BF_VAL_NX90_iflash_write_protection_main_val 0x00000000U

/* all used bits of 'NX90_iflash_write_protection_main': */
#define MSK_USED_BITS_NX90_iflash_write_protection_main 0xffffffffU

enum {
  BFW_NX90_iflash_write_protection_main_val = 32  /* [31:0] */
};

typedef struct NX90_IFLASH_WRITE_PROTECTION_MAIN_BIT_Ttag {
  unsigned int val : BFW_NX90_iflash_write_protection_main_val; /* protect flash main memory each bit protect 16k (16k x 32 = 512 kByte) xadr[9:5] */
} NX90_IFLASH_WRITE_PROTECTION_MAIN_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_IFLASH_WRITE_PROTECTION_MAIN_BIT_T bf;
} NX90_IFLASH_WRITE_PROTECTION_MAIN_T;


/* ===================================================================== */

/* Area of hif_io_ctrl */

/* ===================================================================== */

#define Addr_NX90_hif_io_ctrl 0xFF401480U

/* --------------------------------------------------------------------- */
/* Register hif_io_cfg */
/* => IO Config Register: */
/*    Selects of HIF pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    This configuration must be set up according to external netX connection before any access to external logic. */
/*    This register is protected by the netX access key mechanism; changing this register is only possible by the following sequence: */
/*     */
/*    1.: read out access key from ACCESS_KEY register (ASIC_CTRL address area) */
/*    2.: write back access key to ACCESS_KEY register (ASIC_CTRL address area) */
/*    3.: write desired value to this register (ASIC_CTRL address area) */
/*     */
/*    Attention: Be very careful programming this register. False settings may cause permanent damage on netX or devices connected */
/*               to HIF-IOs. */
/*     */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_io_cfg         0x00000000U
#define Adr_NX90_hif_io_ctrl_hif_io_cfg 0xFF401480U
#define Adr_NX90_hif_io_cfg             0xFF401480U
#define DFLT_VAL_NX90_hif_io_cfg        0x01000060U

#define MSK_NX90_hif_io_cfg_sel_hif_dpm                    0x00000001U
#define SRT_NX90_hif_io_cfg_sel_hif_dpm                    0
#define DFLT_VAL_NX90_hif_io_cfg_sel_hif_dpm               0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_sel_hif_dpm            0x00000000U
#define MSK_NX90_hif_io_cfg_sel_dpm_serial                 0x00000002U
#define SRT_NX90_hif_io_cfg_sel_dpm_serial                 1
#define DFLT_VAL_NX90_hif_io_cfg_sel_dpm_serial            0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_sel_dpm_serial         0x00000000U
#define MSK_NX90_hif_io_cfg_sel_dpm_serial_sph             0x00000004U
#define SRT_NX90_hif_io_cfg_sel_dpm_serial_sph             2
#define DFLT_VAL_NX90_hif_io_cfg_sel_dpm_serial_sph        0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_sel_dpm_serial_sph     0x00000000U
#define MSK_NX90_hif_io_cfg_sel_dpm_serial_spo             0x00000008U
#define SRT_NX90_hif_io_cfg_sel_dpm_serial_spo             3
#define DFLT_VAL_NX90_hif_io_cfg_sel_dpm_serial_spo        0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_sel_dpm_serial_spo     0x00000000U
#define MSK_NX90_hif_io_cfg_en_sdpm1                       0x00000010U
#define SRT_NX90_hif_io_cfg_en_sdpm1                       4
#define DFLT_VAL_NX90_hif_io_cfg_en_sdpm1                  0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_en_sdpm1               0x00000000U
#define MSK_NX90_hif_io_cfg_hif_mi_cfg                     0x00000060U
#define SRT_NX90_hif_io_cfg_hif_mi_cfg                     5
#define DFLT_VAL_NX90_hif_io_cfg_hif_mi_cfg                0x00000060U
#define DFLT_BF_VAL_NX90_hif_io_cfg_hif_mi_cfg             0x00000003U
#define MSK_NX90_hif_io_cfg_en_hif_sdram_mi                0x00000080U
#define SRT_NX90_hif_io_cfg_en_hif_sdram_mi                7
#define DFLT_VAL_NX90_hif_io_cfg_en_hif_sdram_mi           0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_en_hif_sdram_mi        0x00000000U
#define MSK_NX90_hif_io_cfg_sel_hif_a_width                0x00000f00U
#define SRT_NX90_hif_io_cfg_sel_hif_a_width                8
#define DFLT_VAL_NX90_hif_io_cfg_sel_hif_a_width           0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_sel_hif_a_width        0x00000000U
#define MSK_NX90_hif_io_cfg_en_hif_rdy_pio_mi              0x01000000U
#define SRT_NX90_hif_io_cfg_en_hif_rdy_pio_mi              24
#define DFLT_VAL_NX90_hif_io_cfg_en_hif_rdy_pio_mi         0x01000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_en_hif_rdy_pio_mi      0x00000001U
#define MSK_NX90_hif_io_cfg_en_hif_wdg_sys_hif_d19         0x02000000U
#define SRT_NX90_hif_io_cfg_en_hif_wdg_sys_hif_d19         25
#define DFLT_VAL_NX90_hif_io_cfg_en_hif_wdg_sys_hif_d19    0x00000000U
#define DFLT_BF_VAL_NX90_hif_io_cfg_en_hif_wdg_sys_hif_d19 0x00000000U

/* all used bits of 'NX90_hif_io_cfg': */
#define MSK_USED_BITS_NX90_hif_io_cfg 0x03000fffU

enum {
  BFW_NX90_hif_io_cfg_sel_hif_dpm            = 1,  /* [0] */
  BFW_NX90_hif_io_cfg_sel_dpm_serial         = 1,  /* [1] */
  BFW_NX90_hif_io_cfg_sel_dpm_serial_sph     = 1,  /* [2] */
  BFW_NX90_hif_io_cfg_sel_dpm_serial_spo     = 1,  /* [3] */
  BFW_NX90_hif_io_cfg_en_sdpm1               = 1,  /* [4] */
  BFW_NX90_hif_io_cfg_hif_mi_cfg             = 2,  /* [6:5] */
  BFW_NX90_hif_io_cfg_en_hif_sdram_mi        = 1,  /* [7] */
  BFW_NX90_hif_io_cfg_sel_hif_a_width        = 4,  /* [11:8] */
  BFW_NX90_hif_io_cfg_reserved1              = 12, /* [23:12] */
  BFW_NX90_hif_io_cfg_en_hif_rdy_pio_mi      = 1,  /* [24] */
  BFW_NX90_hif_io_cfg_en_hif_wdg_sys_hif_d19 = 1,  /* [25] */
  BFW_NX90_hif_io_cfg_reserved2              = 6   /* [31:26] */
};

typedef struct NX90_HIF_IO_CFG_BIT_Ttag {
  unsigned int sel_hif_dpm            : BFW_NX90_hif_io_cfg_sel_hif_dpm;            /* select DPM mode for HIF (serial or parallel)                                                                                        */
                                                                                    /* Note: For parallel DPM IO configuration use config registers in address area DPM.                                                   */
                                                                                    /* Note: Parallel DPM fast/service IRQ functionality (SIRQ/FIQ) on HIF_SDCLK is controlled by                                          */
                                                                                    /*       en_hif_sdram_mi bit                                                                                                           */
                                                                                    /* Note: For parallel DPM host IRQs can be generated on HIF_DIRQ and HIF_SDCLK IOs.                                                    */
                                                                                    /* Note: For parallel DPM HIF PIO function muse be configured inside 'dpm_pio_cfg'                                                     */
                                                                                    /*       registers for all HIF IOs.                                                                                                    */
  unsigned int sel_dpm_serial         : BFW_NX90_hif_io_cfg_sel_dpm_serial;         /* serial (SPI) DPM mode selection (ignored if sel_hif_dpm not set).                                                                   */
                                                                                    /* There are 2 independent serial DPM interfaces for netX90. They can be used together,                                                */
                                                                                    /* e.g. one for cyclic and one for acyclic data) or stand-alone. The 1st sDPM (sDPM0) can                                              */
                                                                                    /* always be used together with external memory (even 16bit mode). sDPM1 can only be used with                                         */
                                                                                    /* an 8 bit MI. The pinning positions of serial DPM interfaces are provided by the main pinning                                        */
                                                                                    /* table: The pinning-functions "dpm0_spi*" represent sDPM0,  pinning-functions "dpm1_spi*" represent sDPM1.                           */
                                                                                    /* Note: For parallel DPM, the IRQ signals to the host are located on HIF_DIRQ and HIF_SDCLK (DPM0 only).                              */
                                                                                    /*       When external SDRAM is used (en_hif_sdram_mi) the IRQ on HIF_SDCLK is not available). For serial DPM                          */
                                                                                    /*       the IRQs are located on different IOs (refer to main pinning table).                                                          */
  unsigned int sel_dpm_serial_sph     : BFW_NX90_hif_io_cfg_sel_dpm_serial_sph;     /* serial DPM mode SPI clock phase selection (sel_hif_dpm and sel_dpm_serial must be set)                                              */
                                                                                    /*  0: Serial data sampling on first serial clock edge.                                                                                */
                                                                                    /*  1: Serial data sampling on second serial clock edge.                                                                               */
  unsigned int sel_dpm_serial_spo     : BFW_NX90_hif_io_cfg_sel_dpm_serial_spo;     /* serial DPM mode SPI clock polarity selection (sel_hif_dpm and sel_dpm_serial must be set)                                           */
                                                                                    /*  0: Serial clock idle state is low.                                                                                                 */
                                                                                    /*  1: Serial clock idle state is high.                                                                                                */
  unsigned int en_sdpm1               : BFW_NX90_hif_io_cfg_en_sdpm1;               /* Enables the 2nd serial DPM for netX90.                                                                                              */
                                                                                    /*  0: 2nd serial DPM is disabled.                                                                                                     */
                                                                                    /*  1: 2nd serial DPM is enabled.                                                                                                      */
                                                                                    /* Note:                                                                                                                               */
                                                                                    /*    It is possible to enable the 2nd serial DPM stand-alone or together with the normal DPM                                          */
                                                                                    /*    in serial mode (i.e. both bits 'sel_hif_dpm' and 'sel_dpm_serial' set).                                                          */
                                                                                    /*    It is not possible to use the 2nd serial DPM together with the first DPM in parallel mode                                        */
                                                                                    /*    as they use the same IOs (the 2nd DPM does not provide the parallel mode).                                                       */
                                                                                    /* Note:                                                                                                                               */
                                                                                    /*    The mode of the 2nd serial DPM is same as for the first DPM (programmed by                                                       */
                                                                                    /*    the bits 'sel_dpm_serial_spo' and 'sel_dpm_serial_sph')                                                                          */
  unsigned int hif_mi_cfg             : BFW_NX90_hif_io_cfg_hif_mi_cfg;             /* Global HIF IO Memory Interface usage configuration.                                                                                 */
                                                                                    /* Extensionbus/HIF-Memory-Interface and must be enabled and data width selected here before                                           */
                                                                                    /* memory devices like SRAM/FLASH/SDRAM can be used on HIF.                                                                            */
                                                                                    /* Settings:                                                                                                                           */
                                                                                    /* {   |                                                                                                                               */
                                                                                    /*  00: HIF IOs are used as 8 bit MI.                                                                                                  */
                                                                                    /*      Minimally used HIF IOs: HIF_A0..10, HIF_RDN, HIF_WRN + 1 Chip-select.                                                          */
                                                                                    /*      Other HIF IOs can be used for non-MI functions (e.g. MMIO8..15, sDPM0 or MLED4..11).                                           */
                                                                                    /*      Up to 3 Chip-Selects are provided (they are PIO by default, view notes):                                                       */
                                                                                    /*  01: HIF IOs are used as 16 bit MI, HIF_D0..7 are additionally used for the upper data byte.                                        */
                                                                                    /*  10: reserved                                                                                                                       */
                                                                                    /*  11: No MI usage. HIF IOs can be used as PIOs or for parallel DPM. }                                                                */
                                                                                    /*                                                                                                                                     */
                                                                                    /* HIF Extension-bus signal mapping for SRAM/FLASH or SDRAM:                                                                           */
                                                                                    /* {                    |          |          |           |                                                                            */
                                                                                    /*         IO                 MI8       MI16     SDRAM8     SDRAM16                                                                    */
                                                                                    /*      HIF_A0                 A0     BE0/A0         A0          A0                                                                    */
                                                                                    /*      HIF_A1                 A1         A1         A1          A1                                                                    */
                                                                                    /*      HIF_A2                 A2         A2         A2          A2                                                                    */
                                                                                    /*      HIF_A3                 A3         A3         A3          A3                                                                    */
                                                                                    /*      HIF_A4                 A4         A4         A4          A4                                                                    */
                                                                                    /*      HIF_A5                 A5         A5         A5          A5                                                                    */
                                                                                    /*      HIF_A6                 A6         A6         A6          A6                                                                    */
                                                                                    /*      HIF_A7                 A7         A7         A7          A7                                                                    */
                                                                                    /*      HIF_A8                 A8         A8         A8          A8                                                                    */
                                                                                    /*      HIF_A9                 A9         A9         A9          A9                                                                    */
                                                                                    /*      HIF_A10                A10        A10        A10         A10                                                                   */
                                                                                    /*      HIF_A11           (n2) A11   (n2) A11   (n2) A11    (n2) A11                                                                   */
                                                                                    /*      HIF_A12           (n2) A12   (n2) A12   (n2) A12    (n2) A12                                                                   */
                                                                                    /*      HIF_A13           (n2) A13   (n2) A13        BA0         BA0                                                                   */
                                                                                    /*      HIF_A14           (n2) A14   (n2) A14   (n2) BA1    (n2) BA1                                                                   */
                                                                                    /*      HIF_A15           (n2) A15   (n2) A15        RAS         RAS                                                                   */
                                                                                    /*      HIF_A16           (n2) A16   (n2) A16        CAS         CAS                                                                   */
                                                                                    /*      HIF_A17           (n2) A17   (n2) A17        DQM0        DQM0                                                                  */
                                                                                    /*                                                                                                                                     */
                                                                                    /*      MII1_RXER              D0         D0         D0          D0                                                                    */
                                                                                    /*      MII1_CRS               D1         D1         D1          D1                                                                    */
                                                                                    /*      MII1_COL               D2         D2         D2          D2                                                                    */
                                                                                    /*      PHY0_LED_LINK_IN       D3         D3         D3          D3                                                                    */
                                                                                    /*      PHY1_LED_LINK_IN       D4         D4         D4          D4                                                                    */
                                                                                    /*      MII0_TXEN              D5         D5         D5          D5                                                                    */
                                                                                    /*      MII0_COL               D6         D6         D6          D6                                                                    */
                                                                                    /*      MII0_CRS               D7         D7         D7          D7                                                                    */
                                                                                    /*      HIF_D0                (n1)        D8        (n1)         D8                                                                    */
                                                                                    /*      HIF_D1                (n1)        D9        (n1)         D9                                                                    */
                                                                                    /*      HIF_D2                (n1)        D10       (n1)         D10                                                                   */
                                                                                    /*      HIF_D3                (n1)        D11       (n1)         D11                                                                   */
                                                                                    /*      HIF_D4                (n1)        D12       (n1)         D12                                                                   */
                                                                                    /*      HIF_D5                (n1)        D13       (n1)         D13                                                                   */
                                                                                    /*      HIF_D6                (n1)        D14       (n1)         D14                                                                   */
                                                                                    /*      HIF_D7                (n1)        D15       (n1)         D15                                                                   */
                                                                                    /*                                                                                                                                     */
                                                                                    /*      HIF_BHEN              (n1)    BHE/BE1       (n1)         DQM1                                                                  */
                                                                                    /*      HIF_CSN                CS0        CS0        CSN         CSN                                                                   */
                                                                                    /*      HIF_RDN                RDN        RDN                                                                                          */
                                                                                    /*      HIF_WRN                WRN        WRN        WEN         WEN                                                                   */
                                                                                    /*      HIF_RDY           (n2) RDY   (n2) RDY        CKE         CKE                                                                   */
                                                                                    /*      HIF_DIRQ               CS1        CS1                                                                                          */
                                                                                    /*      HIF_SDCLK              CS2        CS2        CLK         CLK                                                                   */
                                                                                    /* }                                                                                                                                   */
                                                                                    /*                                                                                                                                     */
                                                                                    /* Table Notes:                                                                                                                        */
                                                                                    /* (n1): IOs could be used for other purpose, e.g. for serial DPM0, MMIO (refer to main pinning table).                                */
                                                                                    /* (n2): Optional, (depends on further configuration, e.g. 'sel_hif_a_width' bit-field).                                               */
                                                                                    /*                                                                                                                                     */
                                                                                    /* Note: 8 and 16 bit SRAM and SDRAM devices can be shared.                                                                            */
                                                                                    /* Note: Configuration of single SRAM/FLASH Chip-Select usage must be done additionally in                                             */
                                                                                    /*       HIF related ASYNCMEM_CTRL address area. By default, all Chip-Selects are disabled and                                         */
                                                                                    /*       available for PIO usage. If any external memory is used, Chip-Select configuration must be done                               */
                                                                                    /*       before the first access to external memory. Otherwise netX or memory                                                          */
                                                                                    /*       devices could be damaged. No data width must be configured in the ASYNCMEM_CTRL regsiters, which                              */
                                                                                    /*       exceeds globally enabled data width of this bit-field.                                                                        */
                                                                                    /* Note: If upper address lines above HIF_A10 are not used as PIOs, this must be configured in                                         */
                                                                                    /*       bits 'sel_hif_a_width'.                                                                                                       */
                                                                                    /* Note: SDRAM Chip-Select is multiplexed with SRAM/FLASH Chip-Select 0 on HIF_CSN. If 'en_hif_sdram_mi'                               */
                                                                                    /*       is set and SRAM/FLASH Chip-Select 0 enabled in the ASYNCMEM_CTRL address area, SDRAM Chip-Select                              */
                                                                                    /*       gains priority and SRAM/FLASH Chip-Select 0 will not be available.                                                            */
  unsigned int en_hif_sdram_mi        : BFW_NX90_hif_io_cfg_en_hif_sdram_mi;        /* Enable HIF IOs for SDRAM Memory Interface configuration.                                                                            */
                                                                                    /* HIF-SDRAM Chip-Select is generated on HIF_CSN when this bit is set. ExtBus Chip-Select area                                         */
                                                                                    /* 0 is not available then. Ready-Signal for ExtBus is never available when SDRAM is enabled here.                                     */
                                                                                    /* If enabled following IOs are used for SDRAM (netX90, partial shared with SRAM/FLASH ctrl signals):                                  */
                                                                                    /* {                  |          |                                                                                                     */
                                                                                    /*    netX90 IO         Function   Comment                                                                                             */
                                                                                    /*    HIF_A0..12        SD_A0..12  Shared SDRAM/FLASH/SRAM address lines, small SDRAM devices do not need all lines (sel_hif_a_width). */
                                                                                    /*    MII1_RXER         SD_D0      Lower data byte bit 0. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    MII1_CRS          SD_D1      Lower data byte bit 1. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    MII1_COL          SD_D2      Lower data byte bit 2. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    PHY0_LED_LINK_IN  SD_D3      Lower data byte bit 3. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    PHY1_LED_LINK_IN  SD_D4      Lower data byte bit 4. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    MII0_TXEN         SD_D5      Lower data byte bit 5. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    MII0_COL          SD_D6      Lower data byte bit 6. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    MII0_CRS          SD_D7      Lower data byte bit 7. Shared SDRAM/FLASH/SRAM data lines.                                          */
                                                                                    /*    HIF_D0..7         SD_D8..15  Upper data byte, Shared SDRAM/FLASH/SRAM data lines.                                                */
                                                                                    /*    HIF_A13..14       SD_BA0..1  Only during SDRAM access, usable as FLASH/SRAM A13..14 simultaneously.                              */
                                                                                    /*    HIF_A15           SD_RASN    Only during SDRAM access, usable as FLASH/SRAM A15 simultaneously.                                  */
                                                                                    /*    HIF_A16           SD_CASN    Only during SDRAM access, usable as FLASH/SRAM A16 simultaneously.                                  */
                                                                                    /*    HIF_A17           SD_DQM0N   Only during SDRAM access, usable as FLASH/SRAM A17 simultaneously.                                  */
                                                                                    /*    HIF_BHEN          SD_DQM1N   Only during SDRAM access, usable as FLASH/SRAM BHEN simultaneously.                                 */
                                                                                    /*    HIF_WRN           SD_WEN     Only during SDRAM access, usable as FLASH/SRAM nWR simultaneously.                                  */
                                                                                    /*    HIF_CSN           SD_CSN     ExtBus CS0 not available                                                                            */
                                                                                    /*    HIF_RDY           SD_CKE     ExtBus Ready never available when SDRAM enabled                                                     */
                                                                                    /*    HIF_SDCLK         SD_CLK     HIF SDRAM clock, ExtBus CS2 not available }                                                         */
                                                                                    /*                                                                                                                                     */
                                                                                    /* Note: HIF_A lines used for SDRAM will always be driven when this bit is set. This does not depend                                   */
                                                                                    /*       on programmed value of 'sel_hif_a_width' bit field. However 'sel_hif_a_width' must be set                                     */
                                                                                    /*       wide enough for SDRAM row and column addressing (depending on used SDRAM device).                                             */
  unsigned int sel_hif_a_width        : BFW_NX90_hif_io_cfg_sel_hif_a_width;        /* Select HIF MI address width.                                                                                                        */
                                                                                    /* Selecting smaller address bus width will allow PIO usage on related IOs when not used                                               */
                                                                                    /* otherwise (e.g. as SDRAM control signals, see en_hif_sdram_mi). A0 to A11 are always enabled                                        */
                                                                                    /* when the HIF MI is enabled by the hif_mi_cfg bits.                                                                                  */
                                                                                    /* Following settings are valid for 8 or 16 bit data modes. Please note:                                                               */
                                                                                    /* - The lower byte of the MI is located on the MII signals (refer to the pinning table).                                              */
                                                                                    /* - The upper byte of the MI is located on the lower HIF_D IOs (HIF_D0..7, not on HIF_D8..15).                                        */
                                                                                    /* - 32bit data is not supported for netX90                                                                                            */
                                                                                    /* {    |       |       |               |          |                                                                                   */
                                                                                    /*        Lines   Range           IOs     Function   Comment                                                                           */
                                                                                    /*  0000:    11      2k   HIF_A0..10      A0..A10    ext_a0..ext_a10                                                                   */
                                                                                    /*  0001:    12      4k   HIF_A0..11      A0..A11    + ext_a11                                                                         */
                                                                                    /*  0010:    13      8k   HIF_A0..12      A0..A12    + ext_a12                                                                         */
                                                                                    /*  0011:    14     16k   HIF_A0..13      A0..A13    + ext_a13                                                                         */
                                                                                    /*  0100:    15     32k   HIF_A0..14      A0..A14    + ext_a14                                                                         */
                                                                                    /*  0101:    16     64k   HIF_A0..15      A0..A15    + ext_a15                                                                         */
                                                                                    /*  0110:    17    128k   HIF_A0..16      A0..A16    + ext_a16                                                                         */
                                                                                    /*  0111:    18    256k   HIF_A0..17      A0..A17    + ext_a17}                                                                        */
                                                                                    /*                                                                                                                                     */
                                                                                    /* Following settings are only valid for 8 bit data mode:                                                                              */
                                                                                    /* {    |       |       |               |          |                                                                                   */
                                                                                    /*        Lines   Range   IOs             Function   Comment                                                                           */
                                                                                    /*  1000     19    512k   HIF_A0..17      A0..A17    ext_a0..ext_a17                                                                   */
                                                                                    /*                        HIF_D0          A18        ext_a18                                                                           */
                                                                                    /*  1001     20      1M   HIF_A0..17      A0..A17    ext_a0..ext_a17                                                                   */
                                                                                    /*                        HIF_D0,1        A18,A19    ext_a18,ext_a19                                                                   */
                                                                                    /*  1010     21      2M   HIF_A0..17      A0..A17    ext_a0..ext_a17                                                                   */
                                                                                    /*                        HIF_D0..2       A18..A20   ext_a18..ext_a20                                                                  */
                                                                                    /*  1011     22      4M   HIF_A0..17      A0..A17    ext_a0..ext_a17                                                                   */
                                                                                    /*                        HIF_D0..3       A18..A21   ext_a18..ext_a21                                                                  */
                                                                                    /*  1100     23      8M   HIF_A0..17      A0..A17    ext_a0..ext_a17                                                                   */
                                                                                    /*                        HIF_D0..4       A18..A22   ext_a18..ext_a22                                                                  */
                                                                                    /*  1101     24     16M   HIF_A0..17      A0..A17    ext_a0..ext_a17                                                                   */
                                                                                    /*                        HIF_D0..5       A18..A23   ext_a18..ext_a23                                                                  */
                                                                                    /*  1110     25     32M   HIF_A0..17      A0..A17    ext_a0..ext_a17                                                                   */
                                                                                    /*                        HIF_D0..6       A18..A24   ext_a18..ext_a24 }                                                                */
  unsigned int reserved1              : BFW_NX90_hif_io_cfg_reserved1;              /* reserved                                                                                                                            */
  unsigned int en_hif_rdy_pio_mi      : BFW_NX90_hif_io_cfg_en_hif_rdy_pio_mi;      /* Enable HIF_RDY for PIO usage (or other netX MUX function) when the HIF is in memory-mode.                                           */
                                                                                    /* Note: This bit must be disabled if HIF_RDY is used as EXT_BUS RDY (extension bus ready input).                                      */
                                                                                    /* Note: This bit is ignored if HIF is DPM. Use DPM RDY configuration if HIF_RDY should                                                */
                                                                                    /*       be used as PIO together with DPM functionality.                                                                               */
  unsigned int en_hif_wdg_sys_hif_d19 : BFW_NX90_hif_io_cfg_en_hif_wdg_sys_hif_d19; /* Obsolete for netX90, removed by regdef filter script.                                                                               */
                                                                                    /* Enable 'wdg_active'/'WDGACT'-signal of netX system watchdog on HIF_D19. # default 0                                                 */
                                                                                    /* When this bit is set HIF_D19 will be set to output mode and provide watchdog-active signal. However                                 */
                                                                                    /* this will have no effect when HIF_D19 is used for another function. For parallel                                                    */
                                                                                    /* DPM with watchdog HIF_D19 must be set to PIO mode inside DPM module.                                                                */
                                                                                    /* Note: netX system watch can be programmed inside address area 'WATCHDOG'/'NETX_WDG_AREA'.                                           */
  unsigned int reserved2              : BFW_NX90_hif_io_cfg_reserved2;              /* reserved                                                                                                                            */
} NX90_HIF_IO_CFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_HIF_IO_CFG_BIT_T bf;
} NX90_HIF_IO_CFG_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_cfg */
/* => HIF PIO Mode configuration register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_cfg         0x00000004U
#define Adr_NX90_hif_io_ctrl_hif_pio_cfg 0xFF401484U
#define Adr_NX90_hif_pio_cfg             0xFF401484U
#define DFLT_VAL_NX90_hif_pio_cfg        0x80000008U

#define MSK_NX90_hif_pio_cfg_in_ctrl                  0x00000003U
#define SRT_NX90_hif_pio_cfg_in_ctrl                  0
#define DFLT_VAL_NX90_hif_pio_cfg_in_ctrl             0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_cfg_in_ctrl          0x00000000U
#define MSK_NX90_hif_pio_cfg_filter_en_in             0x00000008U
#define SRT_NX90_hif_pio_cfg_filter_en_in             3
#define DFLT_VAL_NX90_hif_pio_cfg_filter_en_in        0x00000008U
#define DFLT_BF_VAL_NX90_hif_pio_cfg_filter_en_in     0x00000001U
#define MSK_NX90_hif_pio_cfg_irq_hif_d12_cfg          0x00030000U
#define SRT_NX90_hif_pio_cfg_irq_hif_d12_cfg          16
#define DFLT_VAL_NX90_hif_pio_cfg_irq_hif_d12_cfg     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_cfg_irq_hif_d12_cfg  0x00000000U
#define MSK_NX90_hif_pio_cfg_irq_hif_a16_cfg          0x000c0000U
#define SRT_NX90_hif_pio_cfg_irq_hif_a16_cfg          18
#define DFLT_VAL_NX90_hif_pio_cfg_irq_hif_a16_cfg     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_cfg_irq_hif_a16_cfg  0x00000000U
#define MSK_NX90_hif_pio_cfg_irq_hif_a17_cfg          0x00300000U
#define SRT_NX90_hif_pio_cfg_irq_hif_a17_cfg          20
#define DFLT_VAL_NX90_hif_pio_cfg_irq_hif_a17_cfg     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_cfg_irq_hif_a17_cfg  0x00000000U
#define MSK_NX90_hif_pio_cfg_irq_hif_dirq_cfg         0x0c000000U
#define SRT_NX90_hif_pio_cfg_irq_hif_dirq_cfg         26
#define DFLT_VAL_NX90_hif_pio_cfg_irq_hif_dirq_cfg    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_cfg_irq_hif_dirq_cfg 0x00000000U
#define MSK_NX90_hif_pio_cfg_filter_irqs              0x80000000U
#define SRT_NX90_hif_pio_cfg_filter_irqs              31
#define DFLT_VAL_NX90_hif_pio_cfg_filter_irqs         0x80000000U
#define DFLT_BF_VAL_NX90_hif_pio_cfg_filter_irqs      0x00000001U

/* all used bits of 'NX90_hif_pio_cfg': */
#define MSK_USED_BITS_NX90_hif_pio_cfg 0x8c3f000bU

enum {
  BFW_NX90_hif_pio_cfg_in_ctrl          = 2,  /* [1:0] */
  BFW_NX90_hif_pio_cfg_reserved1        = 1,  /* [2] */
  BFW_NX90_hif_pio_cfg_filter_en_in     = 1,  /* [3] */
  BFW_NX90_hif_pio_cfg_reserved2        = 12, /* [15:4] */
  BFW_NX90_hif_pio_cfg_irq_hif_d12_cfg  = 2,  /* [17:16] */
  BFW_NX90_hif_pio_cfg_irq_hif_a16_cfg  = 2,  /* [19:18] */
  BFW_NX90_hif_pio_cfg_irq_hif_a17_cfg  = 2,  /* [21:20] */
  BFW_NX90_hif_pio_cfg_reserved3        = 4,  /* [25:22] */
  BFW_NX90_hif_pio_cfg_irq_hif_dirq_cfg = 2,  /* [27:26] */
  BFW_NX90_hif_pio_cfg_reserved4        = 3,  /* [30:28] */
  BFW_NX90_hif_pio_cfg_filter_irqs      = 1   /* [31] */
};

typedef struct NX90_HIF_PIO_CFG_BIT_Ttag {
  unsigned int in_ctrl          : BFW_NX90_hif_pio_cfg_in_ctrl;          /* HIF PIO Input sampling mode.                                                                               */
                                                                         /* HIF input status registers hif_pio_in0,1 can be configured by programming these bits.                      */
                                                                         /* {         |                                                                                                */
                                                                         /*     Mode   Function                                                                                        */
                                                                         /*       00   pio_in registers show HIF IO states sampled at power-on-reset release.                          */
                                                                         /*       01   HIF IO states are sampled continuously (each netX system clock cycle)                           */
                                                                         /*       10   HIF IO states are sampling is done each system clock cycle when enable signal                   */
                                                                         /*            EN_IN (MMIO-function) level is low.                                                             */
                                                                         /*       11   HIF IO states are sampling is done each system clock cycle when enable signal                   */
                                                                         /*            EN_IN (MMIO-function) level is high.                                                            */
                                                                         /*   others   reserved }                                                                                      */
                                                                         /* Note:                                                                                                      */
                                                                         /*    Settings 00 to 11 are netX 50 compatible (netX 50 register DPM_ARM_IO_MODE1.IN_CONTROL).                */
                                                                         /* Note:                                                                                                      */
                                                                         /*    Power-on-reset states will not be lost when 'in_ctrl' is set to a value not 0.                          */
                                                                         /* Note:                                                                                                      */
                                                                         /*     Power-on-reset states can be used to read pullup/down configuration of HIF-IOs.                        */
                                                                         /*     However, be careful using reset sampled values of HIF data lines when SDRAM is                         */
                                                                         /*     connected: When Reset is done during SDRAM read access, SDRAM device will keep                         */
                                                                         /*     driving data bus. Pull-up/down values will be overdriven by that.                                      */
  unsigned int reserved1        : BFW_NX90_hif_pio_cfg_reserved1;        /* reserved                                                                                                   */
  unsigned int filter_en_in     : BFW_NX90_hif_pio_cfg_filter_en_in;     /* HIF PIO Input sampling enable (EN_IN) filter.                                                              */
                                                                         /*  0 Spikes will not be suppressed for EN_IN.                                                                */
                                                                         /*  1 Spikes up to 10ns will be suppressed by HIF PIO EN_IN sample stages.                                    */
                                                                         /* Note:                                                                                                      */
                                                                         /*    Spike suppression can only done for EN_IN input.                                                        */
                                                                         /*    There is no spike suppression for data inputs of 'hif_pio_in0,1' registers.                             */
  unsigned int reserved2        : BFW_NX90_hif_pio_cfg_reserved2;        /* reserved                                                                                                   */
  unsigned int irq_hif_d12_cfg  : BFW_NX90_hif_pio_cfg_irq_hif_d12_cfg;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) IRQ input configuration                                                    */
                                                                         /* For coding refer to irq_hif_dirq_cfg bit-field.                                                            */
  unsigned int irq_hif_a16_cfg  : BFW_NX90_hif_pio_cfg_irq_hif_a16_cfg;  /* HIF_A16 IRQ input configuration                                                                            */
                                                                         /* For coding refer to irq_hif_dirq_cfg bit-field.                                                            */
  unsigned int irq_hif_a17_cfg  : BFW_NX90_hif_pio_cfg_irq_hif_a17_cfg;  /* HIF_A17 IRQ input configuration                                                                            */
                                                                         /* For coding refer to irq_hif_dirq_cfg bit-field.                                                            */
  unsigned int reserved3        : BFW_NX90_hif_pio_cfg_reserved3;        /* reserved                                                                                                   */
  unsigned int irq_hif_dirq_cfg : BFW_NX90_hif_pio_cfg_irq_hif_dirq_cfg; /* HIF_DIRQ IRQ input configuration                                                                           */
                                                                         /* {         |                                                                                                */
                                                                         /*     Mode   Function                                                                                        */
                                                                         /*       00   low level active IRQ                                                                            */
                                                                         /*       01   high level active IRQ                                                                           */
                                                                         /*       10   falling edge active IRQ                                                                         */
                                                                         /*       11   rising edge active IRQ }                                                                        */
                                                                         /* For IRQ usage this IO should be in PIO input mode, (programmed in the 'hif_io_cfg' register or             */
                                                                         /* PIO-configuration registers of the DPM module). For input its PIO output enable must be programmed to '0'. */
                                                                         /* Spikes on related PIO can be suppressed by 'filter_irqs' bit.                                              */
                                                                         /* Note: HIF PIO IRQs can be assigned and monitored in hif_pio_irq registers further down.                    */
                                                                         /* Note: The HIF IRQ input bit fields are reordered since netx51/52                                           */
  unsigned int reserved4        : BFW_NX90_hif_pio_cfg_reserved4;        /* reserved                                                                                                   */
  unsigned int filter_irqs      : BFW_NX90_hif_pio_cfg_filter_irqs;      /* Filtering of HIF PIO inputs for IRQ generation.                                                            */
                                                                         /* By default filtering is applied on HIF PIO inputs before IRQ generation.                                   */
                                                                         /*  0 Spikes on PIOs will not be suppressed for HIF PIO IRQ generation.                                       */
                                                                         /*  1 Spikes up to 10ns on HIF PIOs will be suppressed by sample stages for HIF PIO                           */
                                                                         /*    IRQ generation. That causes 10ns additionally IRQ latency.                                              */
} NX90_HIF_PIO_CFG_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HIF_PIO_CFG_BIT_T bf;
} NX90_HIF_PIO_CFG_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_out0 */
/* => HIF PIO Output State Configuration Register 0. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the programmed state if appropriate enable bit */
/*    is set in hif_pio_oe0 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_out0         0x00000008U
#define Adr_NX90_hif_io_ctrl_hif_pio_out0 0xFF401488U
#define Adr_NX90_hif_pio_out0             0xFF401488U
#define DFLT_VAL_NX90_hif_pio_out0        0x00000000U

#define MSK_NX90_hif_pio_out0_hif_d0          0x00000001U
#define SRT_NX90_hif_pio_out0_hif_d0          0
#define DFLT_VAL_NX90_hif_pio_out0_hif_d0     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d0  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d1          0x00000002U
#define SRT_NX90_hif_pio_out0_hif_d1          1
#define DFLT_VAL_NX90_hif_pio_out0_hif_d1     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d1  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d2          0x00000004U
#define SRT_NX90_hif_pio_out0_hif_d2          2
#define DFLT_VAL_NX90_hif_pio_out0_hif_d2     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d2  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d3          0x00000008U
#define SRT_NX90_hif_pio_out0_hif_d3          3
#define DFLT_VAL_NX90_hif_pio_out0_hif_d3     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d3  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d4          0x00000010U
#define SRT_NX90_hif_pio_out0_hif_d4          4
#define DFLT_VAL_NX90_hif_pio_out0_hif_d4     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d4  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d5          0x00000020U
#define SRT_NX90_hif_pio_out0_hif_d5          5
#define DFLT_VAL_NX90_hif_pio_out0_hif_d5     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d5  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d6          0x00000040U
#define SRT_NX90_hif_pio_out0_hif_d6          6
#define DFLT_VAL_NX90_hif_pio_out0_hif_d6     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d6  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d7          0x00000080U
#define SRT_NX90_hif_pio_out0_hif_d7          7
#define DFLT_VAL_NX90_hif_pio_out0_hif_d7     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d7  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d8          0x00000100U
#define SRT_NX90_hif_pio_out0_hif_d8          8
#define DFLT_VAL_NX90_hif_pio_out0_hif_d8     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d8  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d9          0x00000200U
#define SRT_NX90_hif_pio_out0_hif_d9          9
#define DFLT_VAL_NX90_hif_pio_out0_hif_d9     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d9  0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d10         0x00000400U
#define SRT_NX90_hif_pio_out0_hif_d10         10
#define DFLT_VAL_NX90_hif_pio_out0_hif_d10    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d10 0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d11         0x00000800U
#define SRT_NX90_hif_pio_out0_hif_d11         11
#define DFLT_VAL_NX90_hif_pio_out0_hif_d11    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d11 0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d12         0x00001000U
#define SRT_NX90_hif_pio_out0_hif_d12         12
#define DFLT_VAL_NX90_hif_pio_out0_hif_d12    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d12 0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d13         0x00002000U
#define SRT_NX90_hif_pio_out0_hif_d13         13
#define DFLT_VAL_NX90_hif_pio_out0_hif_d13    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d13 0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d14         0x00004000U
#define SRT_NX90_hif_pio_out0_hif_d14         14
#define DFLT_VAL_NX90_hif_pio_out0_hif_d14    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d14 0x00000000U
#define MSK_NX90_hif_pio_out0_hif_d15         0x00008000U
#define SRT_NX90_hif_pio_out0_hif_d15         15
#define DFLT_VAL_NX90_hif_pio_out0_hif_d15    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out0_hif_d15 0x00000000U

/* all used bits of 'NX90_hif_pio_out0': */
#define MSK_USED_BITS_NX90_hif_pio_out0 0x0000ffffU

enum {
  BFW_NX90_hif_pio_out0_hif_d0    = 1,  /* [0] */
  BFW_NX90_hif_pio_out0_hif_d1    = 1,  /* [1] */
  BFW_NX90_hif_pio_out0_hif_d2    = 1,  /* [2] */
  BFW_NX90_hif_pio_out0_hif_d3    = 1,  /* [3] */
  BFW_NX90_hif_pio_out0_hif_d4    = 1,  /* [4] */
  BFW_NX90_hif_pio_out0_hif_d5    = 1,  /* [5] */
  BFW_NX90_hif_pio_out0_hif_d6    = 1,  /* [6] */
  BFW_NX90_hif_pio_out0_hif_d7    = 1,  /* [7] */
  BFW_NX90_hif_pio_out0_hif_d8    = 1,  /* [8] */
  BFW_NX90_hif_pio_out0_hif_d9    = 1,  /* [9] */
  BFW_NX90_hif_pio_out0_hif_d10   = 1,  /* [10] */
  BFW_NX90_hif_pio_out0_hif_d11   = 1,  /* [11] */
  BFW_NX90_hif_pio_out0_hif_d12   = 1,  /* [12] */
  BFW_NX90_hif_pio_out0_hif_d13   = 1,  /* [13] */
  BFW_NX90_hif_pio_out0_hif_d14   = 1,  /* [14] */
  BFW_NX90_hif_pio_out0_hif_d15   = 1,  /* [15] */
  BFW_NX90_hif_pio_out0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_HIF_PIO_OUT0_BIT_Ttag {
  unsigned int hif_d0    : BFW_NX90_hif_pio_out0_hif_d0;    /* PIO output drive level of HIF_D0 signal.  */
  unsigned int hif_d1    : BFW_NX90_hif_pio_out0_hif_d1;    /* PIO output drive level of HIF_D1 signal.  */
  unsigned int hif_d2    : BFW_NX90_hif_pio_out0_hif_d2;    /* PIO output drive level of HIF_D2 signal.  */
  unsigned int hif_d3    : BFW_NX90_hif_pio_out0_hif_d3;    /* PIO output drive level of HIF_D3 signal.  */
  unsigned int hif_d4    : BFW_NX90_hif_pio_out0_hif_d4;    /* PIO output drive level of HIF_D4 signal.  */
  unsigned int hif_d5    : BFW_NX90_hif_pio_out0_hif_d5;    /* PIO output drive level of HIF_D5 signal.  */
  unsigned int hif_d6    : BFW_NX90_hif_pio_out0_hif_d6;    /* PIO output drive level of HIF_D6 signal.  */
  unsigned int hif_d7    : BFW_NX90_hif_pio_out0_hif_d7;    /* PIO output drive level of HIF_D7 signal.  */
  unsigned int hif_d8    : BFW_NX90_hif_pio_out0_hif_d8;    /* PIO output drive level of HIF_D8 signal.  */
  unsigned int hif_d9    : BFW_NX90_hif_pio_out0_hif_d9;    /* PIO output drive level of HIF_D9 signal.  */
  unsigned int hif_d10   : BFW_NX90_hif_pio_out0_hif_d10;   /* PIO output drive level of HIF_D10 signal. */
  unsigned int hif_d11   : BFW_NX90_hif_pio_out0_hif_d11;   /* PIO output drive level of HIF_D11 signal. */
  unsigned int hif_d12   : BFW_NX90_hif_pio_out0_hif_d12;   /* PIO output drive level of HIF_D12 signal. */
  unsigned int hif_d13   : BFW_NX90_hif_pio_out0_hif_d13;   /* PIO output drive level of HIF_D13 signal. */
  unsigned int hif_d14   : BFW_NX90_hif_pio_out0_hif_d14;   /* PIO output drive level of HIF_D14 signal. */
  unsigned int hif_d15   : BFW_NX90_hif_pio_out0_hif_d15;   /* PIO output drive level of HIF_D15 signal. */
  unsigned int reserved1 : BFW_NX90_hif_pio_out0_reserved1; /* reserved                                  */
} NX90_HIF_PIO_OUT0_BIT_T;

typedef union {
  uint32_t                val;
  NX90_HIF_PIO_OUT0_BIT_T bf;
} NX90_HIF_PIO_OUT0_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_out1 */
/* => HIF PIO Output State Configuration Register 1. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the programmed state if appropriate enable bit */
/*    is set in hif_pio_oe1 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_out1         0x0000000CU
#define Adr_NX90_hif_io_ctrl_hif_pio_out1 0xFF40148CU
#define Adr_NX90_hif_pio_out1             0xFF40148CU
#define DFLT_VAL_NX90_hif_pio_out1        0x00000000U

#define MSK_NX90_hif_pio_out1_hif_a0            0x00000001U
#define SRT_NX90_hif_pio_out1_hif_a0            0
#define DFLT_VAL_NX90_hif_pio_out1_hif_a0       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a0    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a1            0x00000002U
#define SRT_NX90_hif_pio_out1_hif_a1            1
#define DFLT_VAL_NX90_hif_pio_out1_hif_a1       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a1    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a2            0x00000004U
#define SRT_NX90_hif_pio_out1_hif_a2            2
#define DFLT_VAL_NX90_hif_pio_out1_hif_a2       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a2    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a3            0x00000008U
#define SRT_NX90_hif_pio_out1_hif_a3            3
#define DFLT_VAL_NX90_hif_pio_out1_hif_a3       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a3    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a4            0x00000010U
#define SRT_NX90_hif_pio_out1_hif_a4            4
#define DFLT_VAL_NX90_hif_pio_out1_hif_a4       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a4    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a5            0x00000020U
#define SRT_NX90_hif_pio_out1_hif_a5            5
#define DFLT_VAL_NX90_hif_pio_out1_hif_a5       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a5    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a6            0x00000040U
#define SRT_NX90_hif_pio_out1_hif_a6            6
#define DFLT_VAL_NX90_hif_pio_out1_hif_a6       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a6    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a7            0x00000080U
#define SRT_NX90_hif_pio_out1_hif_a7            7
#define DFLT_VAL_NX90_hif_pio_out1_hif_a7       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a7    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a8            0x00000100U
#define SRT_NX90_hif_pio_out1_hif_a8            8
#define DFLT_VAL_NX90_hif_pio_out1_hif_a8       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a8    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a9            0x00000200U
#define SRT_NX90_hif_pio_out1_hif_a9            9
#define DFLT_VAL_NX90_hif_pio_out1_hif_a9       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a9    0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a10           0x00000400U
#define SRT_NX90_hif_pio_out1_hif_a10           10
#define DFLT_VAL_NX90_hif_pio_out1_hif_a10      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a10   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a11           0x00000800U
#define SRT_NX90_hif_pio_out1_hif_a11           11
#define DFLT_VAL_NX90_hif_pio_out1_hif_a11      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a11   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a12           0x00001000U
#define SRT_NX90_hif_pio_out1_hif_a12           12
#define DFLT_VAL_NX90_hif_pio_out1_hif_a12      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a12   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a13           0x00002000U
#define SRT_NX90_hif_pio_out1_hif_a13           13
#define DFLT_VAL_NX90_hif_pio_out1_hif_a13      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a13   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a14           0x00004000U
#define SRT_NX90_hif_pio_out1_hif_a14           14
#define DFLT_VAL_NX90_hif_pio_out1_hif_a14      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a14   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a15           0x00008000U
#define SRT_NX90_hif_pio_out1_hif_a15           15
#define DFLT_VAL_NX90_hif_pio_out1_hif_a15      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a15   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a16           0x00010000U
#define SRT_NX90_hif_pio_out1_hif_a16           16
#define DFLT_VAL_NX90_hif_pio_out1_hif_a16      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a16   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_a17           0x00020000U
#define SRT_NX90_hif_pio_out1_hif_a17           17
#define DFLT_VAL_NX90_hif_pio_out1_hif_a17      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_a17   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_bhen          0x02000000U
#define SRT_NX90_hif_pio_out1_hif_bhen          25
#define DFLT_VAL_NX90_hif_pio_out1_hif_bhen     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_bhen  0x00000000U
#define MSK_NX90_hif_pio_out1_hif_rdn           0x04000000U
#define SRT_NX90_hif_pio_out1_hif_rdn           26
#define DFLT_VAL_NX90_hif_pio_out1_hif_rdn      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_rdn   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_wrn           0x08000000U
#define SRT_NX90_hif_pio_out1_hif_wrn           27
#define DFLT_VAL_NX90_hif_pio_out1_hif_wrn      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_wrn   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_csn           0x10000000U
#define SRT_NX90_hif_pio_out1_hif_csn           28
#define DFLT_VAL_NX90_hif_pio_out1_hif_csn      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_csn   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_rdy           0x20000000U
#define SRT_NX90_hif_pio_out1_hif_rdy           29
#define DFLT_VAL_NX90_hif_pio_out1_hif_rdy      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_rdy   0x00000000U
#define MSK_NX90_hif_pio_out1_hif_dirq          0x40000000U
#define SRT_NX90_hif_pio_out1_hif_dirq          30
#define DFLT_VAL_NX90_hif_pio_out1_hif_dirq     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_dirq  0x00000000U
#define MSK_NX90_hif_pio_out1_hif_sdclk         0x80000000U
#define SRT_NX90_hif_pio_out1_hif_sdclk         31
#define DFLT_VAL_NX90_hif_pio_out1_hif_sdclk    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_out1_hif_sdclk 0x00000000U

/* all used bits of 'NX90_hif_pio_out1': */
#define MSK_USED_BITS_NX90_hif_pio_out1 0xfe03ffffU

enum {
  BFW_NX90_hif_pio_out1_hif_a0    = 1, /* [0] */
  BFW_NX90_hif_pio_out1_hif_a1    = 1, /* [1] */
  BFW_NX90_hif_pio_out1_hif_a2    = 1, /* [2] */
  BFW_NX90_hif_pio_out1_hif_a3    = 1, /* [3] */
  BFW_NX90_hif_pio_out1_hif_a4    = 1, /* [4] */
  BFW_NX90_hif_pio_out1_hif_a5    = 1, /* [5] */
  BFW_NX90_hif_pio_out1_hif_a6    = 1, /* [6] */
  BFW_NX90_hif_pio_out1_hif_a7    = 1, /* [7] */
  BFW_NX90_hif_pio_out1_hif_a8    = 1, /* [8] */
  BFW_NX90_hif_pio_out1_hif_a9    = 1, /* [9] */
  BFW_NX90_hif_pio_out1_hif_a10   = 1, /* [10] */
  BFW_NX90_hif_pio_out1_hif_a11   = 1, /* [11] */
  BFW_NX90_hif_pio_out1_hif_a12   = 1, /* [12] */
  BFW_NX90_hif_pio_out1_hif_a13   = 1, /* [13] */
  BFW_NX90_hif_pio_out1_hif_a14   = 1, /* [14] */
  BFW_NX90_hif_pio_out1_hif_a15   = 1, /* [15] */
  BFW_NX90_hif_pio_out1_hif_a16   = 1, /* [16] */
  BFW_NX90_hif_pio_out1_hif_a17   = 1, /* [17] */
  BFW_NX90_hif_pio_out1_reserved1 = 7, /* [24:18] */
  BFW_NX90_hif_pio_out1_hif_bhen  = 1, /* [25] */
  BFW_NX90_hif_pio_out1_hif_rdn   = 1, /* [26] */
  BFW_NX90_hif_pio_out1_hif_wrn   = 1, /* [27] */
  BFW_NX90_hif_pio_out1_hif_csn   = 1, /* [28] */
  BFW_NX90_hif_pio_out1_hif_rdy   = 1, /* [29] */
  BFW_NX90_hif_pio_out1_hif_dirq  = 1, /* [30] */
  BFW_NX90_hif_pio_out1_hif_sdclk = 1  /* [31] */
};

typedef struct NX90_HIF_PIO_OUT1_BIT_Ttag {
  unsigned int hif_a0    : BFW_NX90_hif_pio_out1_hif_a0;    /* PIO output drive level of HIF_A0 signal.    */
  unsigned int hif_a1    : BFW_NX90_hif_pio_out1_hif_a1;    /* PIO output drive level of HIF_A1 signal.    */
  unsigned int hif_a2    : BFW_NX90_hif_pio_out1_hif_a2;    /* PIO output drive level of HIF_A2 signal.    */
  unsigned int hif_a3    : BFW_NX90_hif_pio_out1_hif_a3;    /* PIO output drive level of HIF_A3 signal.    */
  unsigned int hif_a4    : BFW_NX90_hif_pio_out1_hif_a4;    /* PIO output drive level of HIF_A4 signal.    */
  unsigned int hif_a5    : BFW_NX90_hif_pio_out1_hif_a5;    /* PIO output drive level of HIF_A5 signal.    */
  unsigned int hif_a6    : BFW_NX90_hif_pio_out1_hif_a6;    /* PIO output drive level of HIF_A6 signal.    */
  unsigned int hif_a7    : BFW_NX90_hif_pio_out1_hif_a7;    /* PIO output drive level of HIF_A7 signal.    */
  unsigned int hif_a8    : BFW_NX90_hif_pio_out1_hif_a8;    /* PIO output drive level of HIF_A8 signal.    */
  unsigned int hif_a9    : BFW_NX90_hif_pio_out1_hif_a9;    /* PIO output drive level of HIF_A9 signal.    */
  unsigned int hif_a10   : BFW_NX90_hif_pio_out1_hif_a10;   /* PIO output drive level of HIF_A10 signal.   */
  unsigned int hif_a11   : BFW_NX90_hif_pio_out1_hif_a11;   /* PIO output drive level of HIF_A11 signal.   */
  unsigned int hif_a12   : BFW_NX90_hif_pio_out1_hif_a12;   /* PIO output drive level of HIF_A12 signal.   */
  unsigned int hif_a13   : BFW_NX90_hif_pio_out1_hif_a13;   /* PIO output drive level of HIF_A13 signal.   */
  unsigned int hif_a14   : BFW_NX90_hif_pio_out1_hif_a14;   /* PIO output drive level of HIF_A14 signal.   */
  unsigned int hif_a15   : BFW_NX90_hif_pio_out1_hif_a15;   /* PIO output drive level of HIF_A15 signal.   */
  unsigned int hif_a16   : BFW_NX90_hif_pio_out1_hif_a16;   /* PIO output drive level of HIF_A16 signal.   */
  unsigned int hif_a17   : BFW_NX90_hif_pio_out1_hif_a17;   /* PIO output drive level of HIF_A17 signal.   */
  unsigned int reserved1 : BFW_NX90_hif_pio_out1_reserved1; /* reserved                                    */
  unsigned int hif_bhen  : BFW_NX90_hif_pio_out1_hif_bhen;  /* PIO output drive level of HIF_BHEN signals. */
  unsigned int hif_rdn   : BFW_NX90_hif_pio_out1_hif_rdn;   /* PIO output drive level of HIF_RDN signal.   */
  unsigned int hif_wrn   : BFW_NX90_hif_pio_out1_hif_wrn;   /* PIO output drive level of HIF_WRN signal.   */
  unsigned int hif_csn   : BFW_NX90_hif_pio_out1_hif_csn;   /* PIO output drive level of HIF_CSN signal.   */
  unsigned int hif_rdy   : BFW_NX90_hif_pio_out1_hif_rdy;   /* PIO output drive level of HIF_RDY signal.   */
  unsigned int hif_dirq  : BFW_NX90_hif_pio_out1_hif_dirq;  /* PIO output drive level of HIF_DIRQ signal.  */
  unsigned int hif_sdclk : BFW_NX90_hif_pio_out1_hif_sdclk; /* PIO output drive level of HIF_SDCLK signal. */
} NX90_HIF_PIO_OUT1_BIT_T;

typedef union {
  uint32_t                val;
  NX90_HIF_PIO_OUT1_BIT_T bf;
} NX90_HIF_PIO_OUT1_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_oe0 */
/* => HIF PIO Output Enable Configuration Register 0. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the output state */
/*    programmed in in hif_pio_out0 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_oe0         0x00000010U
#define Adr_NX90_hif_io_ctrl_hif_pio_oe0 0xFF401490U
#define Adr_NX90_hif_pio_oe0             0xFF401490U
#define DFLT_VAL_NX90_hif_pio_oe0        0x00000000U

#define MSK_NX90_hif_pio_oe0_hif_d0          0x00000001U
#define SRT_NX90_hif_pio_oe0_hif_d0          0
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d0     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d0  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d1          0x00000002U
#define SRT_NX90_hif_pio_oe0_hif_d1          1
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d1     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d1  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d2          0x00000004U
#define SRT_NX90_hif_pio_oe0_hif_d2          2
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d2     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d2  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d3          0x00000008U
#define SRT_NX90_hif_pio_oe0_hif_d3          3
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d3     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d3  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d4          0x00000010U
#define SRT_NX90_hif_pio_oe0_hif_d4          4
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d4     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d4  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d5          0x00000020U
#define SRT_NX90_hif_pio_oe0_hif_d5          5
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d5     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d5  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d6          0x00000040U
#define SRT_NX90_hif_pio_oe0_hif_d6          6
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d6     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d6  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d7          0x00000080U
#define SRT_NX90_hif_pio_oe0_hif_d7          7
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d7     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d7  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d8          0x00000100U
#define SRT_NX90_hif_pio_oe0_hif_d8          8
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d8     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d8  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d9          0x00000200U
#define SRT_NX90_hif_pio_oe0_hif_d9          9
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d9     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d9  0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d10         0x00000400U
#define SRT_NX90_hif_pio_oe0_hif_d10         10
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d10    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d10 0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d11         0x00000800U
#define SRT_NX90_hif_pio_oe0_hif_d11         11
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d11    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d11 0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d12         0x00001000U
#define SRT_NX90_hif_pio_oe0_hif_d12         12
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d12    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d12 0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d13         0x00002000U
#define SRT_NX90_hif_pio_oe0_hif_d13         13
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d13    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d13 0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d14         0x00004000U
#define SRT_NX90_hif_pio_oe0_hif_d14         14
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d14    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d14 0x00000000U
#define MSK_NX90_hif_pio_oe0_hif_d15         0x00008000U
#define SRT_NX90_hif_pio_oe0_hif_d15         15
#define DFLT_VAL_NX90_hif_pio_oe0_hif_d15    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe0_hif_d15 0x00000000U

/* all used bits of 'NX90_hif_pio_oe0': */
#define MSK_USED_BITS_NX90_hif_pio_oe0 0x0000ffffU

enum {
  BFW_NX90_hif_pio_oe0_hif_d0    = 1,  /* [0] */
  BFW_NX90_hif_pio_oe0_hif_d1    = 1,  /* [1] */
  BFW_NX90_hif_pio_oe0_hif_d2    = 1,  /* [2] */
  BFW_NX90_hif_pio_oe0_hif_d3    = 1,  /* [3] */
  BFW_NX90_hif_pio_oe0_hif_d4    = 1,  /* [4] */
  BFW_NX90_hif_pio_oe0_hif_d5    = 1,  /* [5] */
  BFW_NX90_hif_pio_oe0_hif_d6    = 1,  /* [6] */
  BFW_NX90_hif_pio_oe0_hif_d7    = 1,  /* [7] */
  BFW_NX90_hif_pio_oe0_hif_d8    = 1,  /* [8] */
  BFW_NX90_hif_pio_oe0_hif_d9    = 1,  /* [9] */
  BFW_NX90_hif_pio_oe0_hif_d10   = 1,  /* [10] */
  BFW_NX90_hif_pio_oe0_hif_d11   = 1,  /* [11] */
  BFW_NX90_hif_pio_oe0_hif_d12   = 1,  /* [12] */
  BFW_NX90_hif_pio_oe0_hif_d13   = 1,  /* [13] */
  BFW_NX90_hif_pio_oe0_hif_d14   = 1,  /* [14] */
  BFW_NX90_hif_pio_oe0_hif_d15   = 1,  /* [15] */
  BFW_NX90_hif_pio_oe0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_HIF_PIO_OE0_BIT_Ttag {
  unsigned int hif_d0    : BFW_NX90_hif_pio_oe0_hif_d0;    /* PIO output enable of HIF_D0 signal.  */
  unsigned int hif_d1    : BFW_NX90_hif_pio_oe0_hif_d1;    /* PIO output enable of HIF_D1 signal.  */
  unsigned int hif_d2    : BFW_NX90_hif_pio_oe0_hif_d2;    /* PIO output enable of HIF_D2 signal.  */
  unsigned int hif_d3    : BFW_NX90_hif_pio_oe0_hif_d3;    /* PIO output enable of HIF_D3 signal.  */
  unsigned int hif_d4    : BFW_NX90_hif_pio_oe0_hif_d4;    /* PIO output enable of HIF_D4 signal.  */
  unsigned int hif_d5    : BFW_NX90_hif_pio_oe0_hif_d5;    /* PIO output enable of HIF_D5 signal.  */
  unsigned int hif_d6    : BFW_NX90_hif_pio_oe0_hif_d6;    /* PIO output enable of HIF_D6 signal.  */
  unsigned int hif_d7    : BFW_NX90_hif_pio_oe0_hif_d7;    /* PIO output enable of HIF_D7 signal.  */
  unsigned int hif_d8    : BFW_NX90_hif_pio_oe0_hif_d8;    /* PIO output enable of HIF_D8 signal.  */
  unsigned int hif_d9    : BFW_NX90_hif_pio_oe0_hif_d9;    /* PIO output enable of HIF_D9 signal.  */
  unsigned int hif_d10   : BFW_NX90_hif_pio_oe0_hif_d10;   /* PIO output enable of HIF_D10 signal. */
  unsigned int hif_d11   : BFW_NX90_hif_pio_oe0_hif_d11;   /* PIO output enable of HIF_D11 signal. */
  unsigned int hif_d12   : BFW_NX90_hif_pio_oe0_hif_d12;   /* PIO output enable of HIF_D12 signal. */
  unsigned int hif_d13   : BFW_NX90_hif_pio_oe0_hif_d13;   /* PIO output enable of HIF_D13 signal. */
  unsigned int hif_d14   : BFW_NX90_hif_pio_oe0_hif_d14;   /* PIO output enable of HIF_D14 signal. */
  unsigned int hif_d15   : BFW_NX90_hif_pio_oe0_hif_d15;   /* PIO output enable of HIF_D15 signal. */
  unsigned int reserved1 : BFW_NX90_hif_pio_oe0_reserved1; /* reserved                             */
} NX90_HIF_PIO_OE0_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HIF_PIO_OE0_BIT_T bf;
} NX90_HIF_PIO_OE0_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_oe1 */
/* => HIF PIO Output Enable Configuration Register 1. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the output state */
/*    programmed in in hif_pio_out1 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_oe1         0x00000014U
#define Adr_NX90_hif_io_ctrl_hif_pio_oe1 0xFF401494U
#define Adr_NX90_hif_pio_oe1             0xFF401494U
#define DFLT_VAL_NX90_hif_pio_oe1        0x00000000U

#define MSK_NX90_hif_pio_oe1_hif_a0            0x00000001U
#define SRT_NX90_hif_pio_oe1_hif_a0            0
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a0       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a0    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a1            0x00000002U
#define SRT_NX90_hif_pio_oe1_hif_a1            1
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a1       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a1    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a2            0x00000004U
#define SRT_NX90_hif_pio_oe1_hif_a2            2
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a2       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a2    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a3            0x00000008U
#define SRT_NX90_hif_pio_oe1_hif_a3            3
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a3       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a3    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a4            0x00000010U
#define SRT_NX90_hif_pio_oe1_hif_a4            4
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a4       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a4    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a5            0x00000020U
#define SRT_NX90_hif_pio_oe1_hif_a5            5
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a5       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a5    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a6            0x00000040U
#define SRT_NX90_hif_pio_oe1_hif_a6            6
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a6       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a6    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a7            0x00000080U
#define SRT_NX90_hif_pio_oe1_hif_a7            7
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a7       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a7    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a8            0x00000100U
#define SRT_NX90_hif_pio_oe1_hif_a8            8
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a8       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a8    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a9            0x00000200U
#define SRT_NX90_hif_pio_oe1_hif_a9            9
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a9       0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a9    0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a10           0x00000400U
#define SRT_NX90_hif_pio_oe1_hif_a10           10
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a10      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a10   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a11           0x00000800U
#define SRT_NX90_hif_pio_oe1_hif_a11           11
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a11      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a11   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a12           0x00001000U
#define SRT_NX90_hif_pio_oe1_hif_a12           12
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a12      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a12   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a13           0x00002000U
#define SRT_NX90_hif_pio_oe1_hif_a13           13
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a13      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a13   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a14           0x00004000U
#define SRT_NX90_hif_pio_oe1_hif_a14           14
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a14      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a14   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a15           0x00008000U
#define SRT_NX90_hif_pio_oe1_hif_a15           15
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a15      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a15   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a16           0x00010000U
#define SRT_NX90_hif_pio_oe1_hif_a16           16
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a16      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a16   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_a17           0x00020000U
#define SRT_NX90_hif_pio_oe1_hif_a17           17
#define DFLT_VAL_NX90_hif_pio_oe1_hif_a17      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_a17   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_bhen          0x02000000U
#define SRT_NX90_hif_pio_oe1_hif_bhen          25
#define DFLT_VAL_NX90_hif_pio_oe1_hif_bhen     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_bhen  0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_rdn           0x04000000U
#define SRT_NX90_hif_pio_oe1_hif_rdn           26
#define DFLT_VAL_NX90_hif_pio_oe1_hif_rdn      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_rdn   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_wrn           0x08000000U
#define SRT_NX90_hif_pio_oe1_hif_wrn           27
#define DFLT_VAL_NX90_hif_pio_oe1_hif_wrn      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_wrn   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_csn           0x10000000U
#define SRT_NX90_hif_pio_oe1_hif_csn           28
#define DFLT_VAL_NX90_hif_pio_oe1_hif_csn      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_csn   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_rdy           0x20000000U
#define SRT_NX90_hif_pio_oe1_hif_rdy           29
#define DFLT_VAL_NX90_hif_pio_oe1_hif_rdy      0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_rdy   0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_dirq          0x40000000U
#define SRT_NX90_hif_pio_oe1_hif_dirq          30
#define DFLT_VAL_NX90_hif_pio_oe1_hif_dirq     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_dirq  0x00000000U
#define MSK_NX90_hif_pio_oe1_hif_sdclk         0x80000000U
#define SRT_NX90_hif_pio_oe1_hif_sdclk         31
#define DFLT_VAL_NX90_hif_pio_oe1_hif_sdclk    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_oe1_hif_sdclk 0x00000000U

/* all used bits of 'NX90_hif_pio_oe1': */
#define MSK_USED_BITS_NX90_hif_pio_oe1 0xfe03ffffU

enum {
  BFW_NX90_hif_pio_oe1_hif_a0    = 1, /* [0] */
  BFW_NX90_hif_pio_oe1_hif_a1    = 1, /* [1] */
  BFW_NX90_hif_pio_oe1_hif_a2    = 1, /* [2] */
  BFW_NX90_hif_pio_oe1_hif_a3    = 1, /* [3] */
  BFW_NX90_hif_pio_oe1_hif_a4    = 1, /* [4] */
  BFW_NX90_hif_pio_oe1_hif_a5    = 1, /* [5] */
  BFW_NX90_hif_pio_oe1_hif_a6    = 1, /* [6] */
  BFW_NX90_hif_pio_oe1_hif_a7    = 1, /* [7] */
  BFW_NX90_hif_pio_oe1_hif_a8    = 1, /* [8] */
  BFW_NX90_hif_pio_oe1_hif_a9    = 1, /* [9] */
  BFW_NX90_hif_pio_oe1_hif_a10   = 1, /* [10] */
  BFW_NX90_hif_pio_oe1_hif_a11   = 1, /* [11] */
  BFW_NX90_hif_pio_oe1_hif_a12   = 1, /* [12] */
  BFW_NX90_hif_pio_oe1_hif_a13   = 1, /* [13] */
  BFW_NX90_hif_pio_oe1_hif_a14   = 1, /* [14] */
  BFW_NX90_hif_pio_oe1_hif_a15   = 1, /* [15] */
  BFW_NX90_hif_pio_oe1_hif_a16   = 1, /* [16] */
  BFW_NX90_hif_pio_oe1_hif_a17   = 1, /* [17] */
  BFW_NX90_hif_pio_oe1_reserved1 = 7, /* [24:18] */
  BFW_NX90_hif_pio_oe1_hif_bhen  = 1, /* [25] */
  BFW_NX90_hif_pio_oe1_hif_rdn   = 1, /* [26] */
  BFW_NX90_hif_pio_oe1_hif_wrn   = 1, /* [27] */
  BFW_NX90_hif_pio_oe1_hif_csn   = 1, /* [28] */
  BFW_NX90_hif_pio_oe1_hif_rdy   = 1, /* [29] */
  BFW_NX90_hif_pio_oe1_hif_dirq  = 1, /* [30] */
  BFW_NX90_hif_pio_oe1_hif_sdclk = 1  /* [31] */
};

typedef struct NX90_HIF_PIO_OE1_BIT_Ttag {
  unsigned int hif_a0    : BFW_NX90_hif_pio_oe1_hif_a0;    /* PIO output enable of HIF_A0 signal.    */
  unsigned int hif_a1    : BFW_NX90_hif_pio_oe1_hif_a1;    /* PIO output enable of HIF_A1 signal.    */
  unsigned int hif_a2    : BFW_NX90_hif_pio_oe1_hif_a2;    /* PIO output enable of HIF_A2 signal.    */
  unsigned int hif_a3    : BFW_NX90_hif_pio_oe1_hif_a3;    /* PIO output enable of HIF_A3 signal.    */
  unsigned int hif_a4    : BFW_NX90_hif_pio_oe1_hif_a4;    /* PIO output enable of HIF_A4 signal.    */
  unsigned int hif_a5    : BFW_NX90_hif_pio_oe1_hif_a5;    /* PIO output enable of HIF_A5 signal.    */
  unsigned int hif_a6    : BFW_NX90_hif_pio_oe1_hif_a6;    /* PIO output enable of HIF_A6 signal.    */
  unsigned int hif_a7    : BFW_NX90_hif_pio_oe1_hif_a7;    /* PIO output enable of HIF_A7 signal.    */
  unsigned int hif_a8    : BFW_NX90_hif_pio_oe1_hif_a8;    /* PIO output enable of HIF_A8 signal.    */
  unsigned int hif_a9    : BFW_NX90_hif_pio_oe1_hif_a9;    /* PIO output enable of HIF_A9 signal.    */
  unsigned int hif_a10   : BFW_NX90_hif_pio_oe1_hif_a10;   /* PIO output enable of HIF_A10 signal.   */
  unsigned int hif_a11   : BFW_NX90_hif_pio_oe1_hif_a11;   /* PIO output enable of HIF_A11 signal.   */
  unsigned int hif_a12   : BFW_NX90_hif_pio_oe1_hif_a12;   /* PIO output enable of HIF_A12 signal.   */
  unsigned int hif_a13   : BFW_NX90_hif_pio_oe1_hif_a13;   /* PIO output enable of HIF_A13 signal.   */
  unsigned int hif_a14   : BFW_NX90_hif_pio_oe1_hif_a14;   /* PIO output enable of HIF_A14 signal.   */
  unsigned int hif_a15   : BFW_NX90_hif_pio_oe1_hif_a15;   /* PIO output enable of HIF_A15 signal.   */
  unsigned int hif_a16   : BFW_NX90_hif_pio_oe1_hif_a16;   /* PIO output enable of HIF_A16 signal.   */
  unsigned int hif_a17   : BFW_NX90_hif_pio_oe1_hif_a17;   /* PIO output enable of HIF_A17 signal.   */
  unsigned int reserved1 : BFW_NX90_hif_pio_oe1_reserved1; /* reserved                               */
  unsigned int hif_bhen  : BFW_NX90_hif_pio_oe1_hif_bhen;  /* PIO output enable of HIF_BHEN signals. */
  unsigned int hif_rdn   : BFW_NX90_hif_pio_oe1_hif_rdn;   /* PIO output enable of HIF_RDN signal.   */
  unsigned int hif_wrn   : BFW_NX90_hif_pio_oe1_hif_wrn;   /* PIO output enable of HIF_WRN signal.   */
  unsigned int hif_csn   : BFW_NX90_hif_pio_oe1_hif_csn;   /* PIO output enable of HIF_CSN signal.   */
  unsigned int hif_rdy   : BFW_NX90_hif_pio_oe1_hif_rdy;   /* PIO output enable of HIF_RDY signal.   */
  unsigned int hif_dirq  : BFW_NX90_hif_pio_oe1_hif_dirq;  /* PIO output enable of HIF_DIRQ signal.  */
  unsigned int hif_sdclk : BFW_NX90_hif_pio_oe1_hif_sdclk; /* PIO output enable of HIF_SDCLK signal. */
} NX90_HIF_PIO_OE1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HIF_PIO_OE1_BIT_T bf;
} NX90_HIF_PIO_OE1_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_in0 */
/* => HIF PIO Input State Register 0. */
/*    IO input states can be read here regardless whether IO is used in current HIF/EXT_BUS Memory Interface configuration. */
/*    HIF IO sampling behaviour can be programmed by 'in_ctrl' bits of 'hif_pio_cfg' register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_in0         0x00000018U
#define Adr_NX90_hif_io_ctrl_hif_pio_in0 0xFF401498U
#define Adr_NX90_hif_pio_in0             0xFF401498U

#define MSK_NX90_hif_pio_in0_hif_d0  0x00000001U
#define SRT_NX90_hif_pio_in0_hif_d0  0
#define MSK_NX90_hif_pio_in0_hif_d1  0x00000002U
#define SRT_NX90_hif_pio_in0_hif_d1  1
#define MSK_NX90_hif_pio_in0_hif_d2  0x00000004U
#define SRT_NX90_hif_pio_in0_hif_d2  2
#define MSK_NX90_hif_pio_in0_hif_d3  0x00000008U
#define SRT_NX90_hif_pio_in0_hif_d3  3
#define MSK_NX90_hif_pio_in0_hif_d4  0x00000010U
#define SRT_NX90_hif_pio_in0_hif_d4  4
#define MSK_NX90_hif_pio_in0_hif_d5  0x00000020U
#define SRT_NX90_hif_pio_in0_hif_d5  5
#define MSK_NX90_hif_pio_in0_hif_d6  0x00000040U
#define SRT_NX90_hif_pio_in0_hif_d6  6
#define MSK_NX90_hif_pio_in0_hif_d7  0x00000080U
#define SRT_NX90_hif_pio_in0_hif_d7  7
#define MSK_NX90_hif_pio_in0_hif_d8  0x00000100U
#define SRT_NX90_hif_pio_in0_hif_d8  8
#define MSK_NX90_hif_pio_in0_hif_d9  0x00000200U
#define SRT_NX90_hif_pio_in0_hif_d9  9
#define MSK_NX90_hif_pio_in0_hif_d10 0x00000400U
#define SRT_NX90_hif_pio_in0_hif_d10 10
#define MSK_NX90_hif_pio_in0_hif_d11 0x00000800U
#define SRT_NX90_hif_pio_in0_hif_d11 11
#define MSK_NX90_hif_pio_in0_hif_d12 0x00001000U
#define SRT_NX90_hif_pio_in0_hif_d12 12
#define MSK_NX90_hif_pio_in0_hif_d13 0x00002000U
#define SRT_NX90_hif_pio_in0_hif_d13 13
#define MSK_NX90_hif_pio_in0_hif_d14 0x00004000U
#define SRT_NX90_hif_pio_in0_hif_d14 14
#define MSK_NX90_hif_pio_in0_hif_d15 0x00008000U
#define SRT_NX90_hif_pio_in0_hif_d15 15

/* all used bits of 'NX90_hif_pio_in0': */
#define MSK_USED_BITS_NX90_hif_pio_in0 0x0000ffffU

enum {
  BFW_NX90_hif_pio_in0_hif_d0    = 1,  /* [0] */
  BFW_NX90_hif_pio_in0_hif_d1    = 1,  /* [1] */
  BFW_NX90_hif_pio_in0_hif_d2    = 1,  /* [2] */
  BFW_NX90_hif_pio_in0_hif_d3    = 1,  /* [3] */
  BFW_NX90_hif_pio_in0_hif_d4    = 1,  /* [4] */
  BFW_NX90_hif_pio_in0_hif_d5    = 1,  /* [5] */
  BFW_NX90_hif_pio_in0_hif_d6    = 1,  /* [6] */
  BFW_NX90_hif_pio_in0_hif_d7    = 1,  /* [7] */
  BFW_NX90_hif_pio_in0_hif_d8    = 1,  /* [8] */
  BFW_NX90_hif_pio_in0_hif_d9    = 1,  /* [9] */
  BFW_NX90_hif_pio_in0_hif_d10   = 1,  /* [10] */
  BFW_NX90_hif_pio_in0_hif_d11   = 1,  /* [11] */
  BFW_NX90_hif_pio_in0_hif_d12   = 1,  /* [12] */
  BFW_NX90_hif_pio_in0_hif_d13   = 1,  /* [13] */
  BFW_NX90_hif_pio_in0_hif_d14   = 1,  /* [14] */
  BFW_NX90_hif_pio_in0_hif_d15   = 1,  /* [15] */
  BFW_NX90_hif_pio_in0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_HIF_PIO_IN0_BIT_Ttag {
  unsigned int hif_d0    : BFW_NX90_hif_pio_in0_hif_d0;    /* PIO input state of HIF_D0 signal.  */
  unsigned int hif_d1    : BFW_NX90_hif_pio_in0_hif_d1;    /* PIO input state of HIF_D1 signal.  */
  unsigned int hif_d2    : BFW_NX90_hif_pio_in0_hif_d2;    /* PIO input state of HIF_D2 signal.  */
  unsigned int hif_d3    : BFW_NX90_hif_pio_in0_hif_d3;    /* PIO input state of HIF_D3 signal.  */
  unsigned int hif_d4    : BFW_NX90_hif_pio_in0_hif_d4;    /* PIO input state of HIF_D4 signal.  */
  unsigned int hif_d5    : BFW_NX90_hif_pio_in0_hif_d5;    /* PIO input state of HIF_D5 signal.  */
  unsigned int hif_d6    : BFW_NX90_hif_pio_in0_hif_d6;    /* PIO input state of HIF_D6 signal.  */
  unsigned int hif_d7    : BFW_NX90_hif_pio_in0_hif_d7;    /* PIO input state of HIF_D7 signal.  */
  unsigned int hif_d8    : BFW_NX90_hif_pio_in0_hif_d8;    /* PIO input state of HIF_D8 signal.  */
  unsigned int hif_d9    : BFW_NX90_hif_pio_in0_hif_d9;    /* PIO input state of HIF_D9 signal.  */
  unsigned int hif_d10   : BFW_NX90_hif_pio_in0_hif_d10;   /* PIO input state of HIF_D10 signal. */
  unsigned int hif_d11   : BFW_NX90_hif_pio_in0_hif_d11;   /* PIO input state of HIF_D11 signal. */
  unsigned int hif_d12   : BFW_NX90_hif_pio_in0_hif_d12;   /* PIO input state of HIF_D12 signal. */
  unsigned int hif_d13   : BFW_NX90_hif_pio_in0_hif_d13;   /* PIO input state of HIF_D13 signal. */
  unsigned int hif_d14   : BFW_NX90_hif_pio_in0_hif_d14;   /* PIO input state of HIF_D14 signal. */
  unsigned int hif_d15   : BFW_NX90_hif_pio_in0_hif_d15;   /* PIO input state of HIF_D15 signal. */
  unsigned int reserved1 : BFW_NX90_hif_pio_in0_reserved1; /* reserved                           */
} NX90_HIF_PIO_IN0_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HIF_PIO_IN0_BIT_T bf;
} NX90_HIF_PIO_IN0_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_in1 */
/* => HIF PIO Input State Register 1. */
/*    IO input states can be read here regardless whether IO is used in current HIF/EXT_BUS Memory Interface configuration. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_in1         0x0000001CU
#define Adr_NX90_hif_io_ctrl_hif_pio_in1 0xFF40149CU
#define Adr_NX90_hif_pio_in1             0xFF40149CU

#define MSK_NX90_hif_pio_in1_hif_a0    0x00000001U
#define SRT_NX90_hif_pio_in1_hif_a0    0
#define MSK_NX90_hif_pio_in1_hif_a1    0x00000002U
#define SRT_NX90_hif_pio_in1_hif_a1    1
#define MSK_NX90_hif_pio_in1_hif_a2    0x00000004U
#define SRT_NX90_hif_pio_in1_hif_a2    2
#define MSK_NX90_hif_pio_in1_hif_a3    0x00000008U
#define SRT_NX90_hif_pio_in1_hif_a3    3
#define MSK_NX90_hif_pio_in1_hif_a4    0x00000010U
#define SRT_NX90_hif_pio_in1_hif_a4    4
#define MSK_NX90_hif_pio_in1_hif_a5    0x00000020U
#define SRT_NX90_hif_pio_in1_hif_a5    5
#define MSK_NX90_hif_pio_in1_hif_a6    0x00000040U
#define SRT_NX90_hif_pio_in1_hif_a6    6
#define MSK_NX90_hif_pio_in1_hif_a7    0x00000080U
#define SRT_NX90_hif_pio_in1_hif_a7    7
#define MSK_NX90_hif_pio_in1_hif_a8    0x00000100U
#define SRT_NX90_hif_pio_in1_hif_a8    8
#define MSK_NX90_hif_pio_in1_hif_a9    0x00000200U
#define SRT_NX90_hif_pio_in1_hif_a9    9
#define MSK_NX90_hif_pio_in1_hif_a10   0x00000400U
#define SRT_NX90_hif_pio_in1_hif_a10   10
#define MSK_NX90_hif_pio_in1_hif_a11   0x00000800U
#define SRT_NX90_hif_pio_in1_hif_a11   11
#define MSK_NX90_hif_pio_in1_hif_a12   0x00001000U
#define SRT_NX90_hif_pio_in1_hif_a12   12
#define MSK_NX90_hif_pio_in1_hif_a13   0x00002000U
#define SRT_NX90_hif_pio_in1_hif_a13   13
#define MSK_NX90_hif_pio_in1_hif_a14   0x00004000U
#define SRT_NX90_hif_pio_in1_hif_a14   14
#define MSK_NX90_hif_pio_in1_hif_a15   0x00008000U
#define SRT_NX90_hif_pio_in1_hif_a15   15
#define MSK_NX90_hif_pio_in1_hif_a16   0x00010000U
#define SRT_NX90_hif_pio_in1_hif_a16   16
#define MSK_NX90_hif_pio_in1_hif_a17   0x00020000U
#define SRT_NX90_hif_pio_in1_hif_a17   17
#define MSK_NX90_hif_pio_in1_hif_bhen  0x02000000U
#define SRT_NX90_hif_pio_in1_hif_bhen  25
#define MSK_NX90_hif_pio_in1_hif_rdn   0x04000000U
#define SRT_NX90_hif_pio_in1_hif_rdn   26
#define MSK_NX90_hif_pio_in1_hif_wrn   0x08000000U
#define SRT_NX90_hif_pio_in1_hif_wrn   27
#define MSK_NX90_hif_pio_in1_hif_csn   0x10000000U
#define SRT_NX90_hif_pio_in1_hif_csn   28
#define MSK_NX90_hif_pio_in1_hif_rdy   0x20000000U
#define SRT_NX90_hif_pio_in1_hif_rdy   29
#define MSK_NX90_hif_pio_in1_hif_dirq  0x40000000U
#define SRT_NX90_hif_pio_in1_hif_dirq  30
#define MSK_NX90_hif_pio_in1_hif_sdclk 0x80000000U
#define SRT_NX90_hif_pio_in1_hif_sdclk 31

/* all used bits of 'NX90_hif_pio_in1': */
#define MSK_USED_BITS_NX90_hif_pio_in1 0xfe03ffffU

enum {
  BFW_NX90_hif_pio_in1_hif_a0    = 1, /* [0] */
  BFW_NX90_hif_pio_in1_hif_a1    = 1, /* [1] */
  BFW_NX90_hif_pio_in1_hif_a2    = 1, /* [2] */
  BFW_NX90_hif_pio_in1_hif_a3    = 1, /* [3] */
  BFW_NX90_hif_pio_in1_hif_a4    = 1, /* [4] */
  BFW_NX90_hif_pio_in1_hif_a5    = 1, /* [5] */
  BFW_NX90_hif_pio_in1_hif_a6    = 1, /* [6] */
  BFW_NX90_hif_pio_in1_hif_a7    = 1, /* [7] */
  BFW_NX90_hif_pio_in1_hif_a8    = 1, /* [8] */
  BFW_NX90_hif_pio_in1_hif_a9    = 1, /* [9] */
  BFW_NX90_hif_pio_in1_hif_a10   = 1, /* [10] */
  BFW_NX90_hif_pio_in1_hif_a11   = 1, /* [11] */
  BFW_NX90_hif_pio_in1_hif_a12   = 1, /* [12] */
  BFW_NX90_hif_pio_in1_hif_a13   = 1, /* [13] */
  BFW_NX90_hif_pio_in1_hif_a14   = 1, /* [14] */
  BFW_NX90_hif_pio_in1_hif_a15   = 1, /* [15] */
  BFW_NX90_hif_pio_in1_hif_a16   = 1, /* [16] */
  BFW_NX90_hif_pio_in1_hif_a17   = 1, /* [17] */
  BFW_NX90_hif_pio_in1_reserved1 = 7, /* [24:18] */
  BFW_NX90_hif_pio_in1_hif_bhen  = 1, /* [25] */
  BFW_NX90_hif_pio_in1_hif_rdn   = 1, /* [26] */
  BFW_NX90_hif_pio_in1_hif_wrn   = 1, /* [27] */
  BFW_NX90_hif_pio_in1_hif_csn   = 1, /* [28] */
  BFW_NX90_hif_pio_in1_hif_rdy   = 1, /* [29] */
  BFW_NX90_hif_pio_in1_hif_dirq  = 1, /* [30] */
  BFW_NX90_hif_pio_in1_hif_sdclk = 1  /* [31] */
};

typedef struct NX90_HIF_PIO_IN1_BIT_Ttag {
  unsigned int hif_a0    : BFW_NX90_hif_pio_in1_hif_a0;    /* PIO input state of HIF_A0 signal.    */
  unsigned int hif_a1    : BFW_NX90_hif_pio_in1_hif_a1;    /* PIO input state of HIF_A1 signal.    */
  unsigned int hif_a2    : BFW_NX90_hif_pio_in1_hif_a2;    /* PIO input state of HIF_A2 signal.    */
  unsigned int hif_a3    : BFW_NX90_hif_pio_in1_hif_a3;    /* PIO input state of HIF_A3 signal.    */
  unsigned int hif_a4    : BFW_NX90_hif_pio_in1_hif_a4;    /* PIO input state of HIF_A4 signal.    */
  unsigned int hif_a5    : BFW_NX90_hif_pio_in1_hif_a5;    /* PIO input state of HIF_A5 signal.    */
  unsigned int hif_a6    : BFW_NX90_hif_pio_in1_hif_a6;    /* PIO input state of HIF_A6 signal.    */
  unsigned int hif_a7    : BFW_NX90_hif_pio_in1_hif_a7;    /* PIO input state of HIF_A7 signal.    */
  unsigned int hif_a8    : BFW_NX90_hif_pio_in1_hif_a8;    /* PIO input state of HIF_A8 signal.    */
  unsigned int hif_a9    : BFW_NX90_hif_pio_in1_hif_a9;    /* PIO input state of HIF_A9 signal.    */
  unsigned int hif_a10   : BFW_NX90_hif_pio_in1_hif_a10;   /* PIO input state of HIF_A10 signal.   */
  unsigned int hif_a11   : BFW_NX90_hif_pio_in1_hif_a11;   /* PIO input state of HIF_A11 signal.   */
  unsigned int hif_a12   : BFW_NX90_hif_pio_in1_hif_a12;   /* PIO input state of HIF_A12 signal.   */
  unsigned int hif_a13   : BFW_NX90_hif_pio_in1_hif_a13;   /* PIO input state of HIF_A13 signal.   */
  unsigned int hif_a14   : BFW_NX90_hif_pio_in1_hif_a14;   /* PIO input state of HIF_A14 signal.   */
  unsigned int hif_a15   : BFW_NX90_hif_pio_in1_hif_a15;   /* PIO input state of HIF_A15 signal.   */
  unsigned int hif_a16   : BFW_NX90_hif_pio_in1_hif_a16;   /* PIO input state of HIF_A16 signal    */
  unsigned int hif_a17   : BFW_NX90_hif_pio_in1_hif_a17;   /* PIO input state of HIF_A17 signal    */
  unsigned int reserved1 : BFW_NX90_hif_pio_in1_reserved1; /* reserved                             */
  unsigned int hif_bhen  : BFW_NX90_hif_pio_in1_hif_bhen;  /* PIO input state of HIF_BHEN signal.  */
  unsigned int hif_rdn   : BFW_NX90_hif_pio_in1_hif_rdn;   /* PIO input state of HIF_RDN signal.   */
  unsigned int hif_wrn   : BFW_NX90_hif_pio_in1_hif_wrn;   /* PIO input state of HIF_WRN signal.   */
  unsigned int hif_csn   : BFW_NX90_hif_pio_in1_hif_csn;   /* PIO input state of HIF_CSN signal.   */
  unsigned int hif_rdy   : BFW_NX90_hif_pio_in1_hif_rdy;   /* PIO input state of HIF_RDY signal.   */
  unsigned int hif_dirq  : BFW_NX90_hif_pio_in1_hif_dirq;  /* PIO input state of HIF_DIRQ signal.  */
  unsigned int hif_sdclk : BFW_NX90_hif_pio_in1_hif_sdclk; /* PIO input state of HIF_SDCLK signal. */
} NX90_HIF_PIO_IN1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_HIF_PIO_IN1_BIT_T bf;
} NX90_HIF_PIO_IN1_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_raw */
/* => HIF PIO Raw (before masking) IRQ Status Register. */
/*    If bit is set, the according interrupt is asserted. */
/*    Interrupt status can be cleared by writing ones to this register. */
/*    Each IRQ source can be assigned either to xPIC or to ARM (or to both) by the following registers. */
/*    IRQ clearing has lower priority than IRQ set when done simultaneously. */
/*    Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/*    Note: The bits of this register are reordered since netx51/52. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_irq_raw         0x00000024U
#define Adr_NX90_hif_io_ctrl_hif_pio_irq_raw 0xFF4014A4U
#define Adr_NX90_hif_pio_irq_raw             0xFF4014A4U

#define MSK_NX90_hif_pio_irq_raw_irq_hif_d12  0x00000001U
#define SRT_NX90_hif_pio_irq_raw_irq_hif_d12  0
#define MSK_NX90_hif_pio_irq_raw_irq_hif_a16  0x00000002U
#define SRT_NX90_hif_pio_irq_raw_irq_hif_a16  1
#define MSK_NX90_hif_pio_irq_raw_irq_hif_a17  0x00000004U
#define SRT_NX90_hif_pio_irq_raw_irq_hif_a17  2
#define MSK_NX90_hif_pio_irq_raw_irq_hif_dirq 0x00000008U
#define SRT_NX90_hif_pio_irq_raw_irq_hif_dirq 3

/* all used bits of 'NX90_hif_pio_irq_raw': */
#define MSK_USED_BITS_NX90_hif_pio_irq_raw 0x0000000fU

enum {
  BFW_NX90_hif_pio_irq_raw_irq_hif_d12  = 1,  /* [0] */
  BFW_NX90_hif_pio_irq_raw_irq_hif_a16  = 1,  /* [1] */
  BFW_NX90_hif_pio_irq_raw_irq_hif_a17  = 1,  /* [2] */
  BFW_NX90_hif_pio_irq_raw_irq_hif_dirq = 1,  /* [3] */
  BFW_NX90_hif_pio_irq_raw_reserved1    = 28  /* [31:4] */
};

typedef struct NX90_HIF_PIO_IRQ_RAW_BIT_Ttag {
  unsigned int irq_hif_d12  : BFW_NX90_hif_pio_irq_raw_irq_hif_d12;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) */
  unsigned int irq_hif_a16  : BFW_NX90_hif_pio_irq_raw_irq_hif_a16;  /* HIF_A16 IRQ                     */
  unsigned int irq_hif_a17  : BFW_NX90_hif_pio_irq_raw_irq_hif_a17;  /* HIF_A17 IRQ                     */
  unsigned int irq_hif_dirq : BFW_NX90_hif_pio_irq_raw_irq_hif_dirq; /* HIF_DIRQ IRQ                    */
  unsigned int reserved1    : BFW_NX90_hif_pio_irq_raw_reserved1;    /* reserved                        */
} NX90_HIF_PIO_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_HIF_PIO_IRQ_RAW_BIT_T bf;
} NX90_HIF_PIO_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_arm_mask_set */
/* => HIF PIO Interrupt Mask Register for netX internal ARM. */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal ARM. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal ARM without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_irq_arm_mask_set         0x00000028U
#define Adr_NX90_hif_io_ctrl_hif_pio_irq_arm_mask_set 0xFF4014A8U
#define Adr_NX90_hif_pio_irq_arm_mask_set             0xFF4014A8U
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_set        0x00000000U

#define MSK_NX90_hif_pio_irq_arm_mask_set_irq_hif_d12          0x00000001U
#define SRT_NX90_hif_pio_irq_arm_mask_set_irq_hif_d12          0
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_d12     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_d12  0x00000000U
#define MSK_NX90_hif_pio_irq_arm_mask_set_irq_hif_a16          0x00000002U
#define SRT_NX90_hif_pio_irq_arm_mask_set_irq_hif_a16          1
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_a16     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_a16  0x00000000U
#define MSK_NX90_hif_pio_irq_arm_mask_set_irq_hif_a17          0x00000004U
#define SRT_NX90_hif_pio_irq_arm_mask_set_irq_hif_a17          2
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_a17     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_a17  0x00000000U
#define MSK_NX90_hif_pio_irq_arm_mask_set_irq_hif_dirq         0x00000008U
#define SRT_NX90_hif_pio_irq_arm_mask_set_irq_hif_dirq         3
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_dirq    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_set_irq_hif_dirq 0x00000000U

/* all used bits of 'NX90_hif_pio_irq_arm_mask_set': */
#define MSK_USED_BITS_NX90_hif_pio_irq_arm_mask_set 0x0000000fU

enum {
  BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_d12  = 1,  /* [0] */
  BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_a16  = 1,  /* [1] */
  BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_a17  = 1,  /* [2] */
  BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_dirq = 1,  /* [3] */
  BFW_NX90_hif_pio_irq_arm_mask_set_reserved1    = 28  /* [31:4] */
};

typedef struct NX90_HIF_PIO_IRQ_ARM_MASK_SET_BIT_Ttag {
  unsigned int irq_hif_d12  : BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_d12;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) */
  unsigned int irq_hif_a16  : BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_a16;  /* HIF_A16 IRQ                     */
  unsigned int irq_hif_a17  : BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_a17;  /* HIF_A17 IRQ                     */
  unsigned int irq_hif_dirq : BFW_NX90_hif_pio_irq_arm_mask_set_irq_hif_dirq; /* HIF_DIRQ IRQ                    */
  unsigned int reserved1    : BFW_NX90_hif_pio_irq_arm_mask_set_reserved1;    /* reserved                        */
} NX90_HIF_PIO_IRQ_ARM_MASK_SET_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_HIF_PIO_IRQ_ARM_MASK_SET_BIT_T bf;
} NX90_HIF_PIO_IRQ_ARM_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_arm_mask_reset */
/* => HIF PIO Interrupt Mask Reset Register for netX internal ARM. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal ARM if asserted. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal ARM without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_irq_arm_mask_reset         0x0000002CU
#define Adr_NX90_hif_io_ctrl_hif_pio_irq_arm_mask_reset 0xFF4014ACU
#define Adr_NX90_hif_pio_irq_arm_mask_reset             0xFF4014ACU
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_reset        0x00000000U

#define MSK_NX90_hif_pio_irq_arm_mask_reset_irq_hif_d12          0x00000001U
#define SRT_NX90_hif_pio_irq_arm_mask_reset_irq_hif_d12          0
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_d12     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_d12  0x00000000U
#define MSK_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a16          0x00000002U
#define SRT_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a16          1
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a16     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a16  0x00000000U
#define MSK_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a17          0x00000004U
#define SRT_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a17          2
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a17     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a17  0x00000000U
#define MSK_NX90_hif_pio_irq_arm_mask_reset_irq_hif_dirq         0x00000008U
#define SRT_NX90_hif_pio_irq_arm_mask_reset_irq_hif_dirq         3
#define DFLT_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_dirq    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_arm_mask_reset_irq_hif_dirq 0x00000000U

/* all used bits of 'NX90_hif_pio_irq_arm_mask_reset': */
#define MSK_USED_BITS_NX90_hif_pio_irq_arm_mask_reset 0x0000000fU

enum {
  BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_d12  = 1,  /* [0] */
  BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a16  = 1,  /* [1] */
  BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a17  = 1,  /* [2] */
  BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_dirq = 1,  /* [3] */
  BFW_NX90_hif_pio_irq_arm_mask_reset_reserved1    = 28  /* [31:4] */
};

typedef struct NX90_HIF_PIO_IRQ_ARM_MASK_RESET_BIT_Ttag {
  unsigned int irq_hif_d12  : BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_d12;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) */
  unsigned int irq_hif_a16  : BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a16;  /* HIF_A16 IRQ                     */
  unsigned int irq_hif_a17  : BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_a17;  /* HIF_A17 IRQ                     */
  unsigned int irq_hif_dirq : BFW_NX90_hif_pio_irq_arm_mask_reset_irq_hif_dirq; /* HIF_DIRQ IRQ                    */
  unsigned int reserved1    : BFW_NX90_hif_pio_irq_arm_mask_reset_reserved1;    /* reserved                        */
} NX90_HIF_PIO_IRQ_ARM_MASK_RESET_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_HIF_PIO_IRQ_ARM_MASK_RESET_BIT_T bf;
} NX90_HIF_PIO_IRQ_ARM_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_arm_masked */
/* => HIF PIO Masked Interrupt Status Register for netX internal ARM. */
/*    If bit is set, if the according mask bit is set in hif_pio_irq_arm_mask-register and the according interrupt is asserted. */
/*    IRQ for netX internal ARM signal is asserted if at least one bit is set here. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal ARM signal without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_irq_arm_masked         0x00000030U
#define Adr_NX90_hif_io_ctrl_hif_pio_irq_arm_masked 0xFF4014B0U
#define Adr_NX90_hif_pio_irq_arm_masked             0xFF4014B0U

#define MSK_NX90_hif_pio_irq_arm_masked_irq_hif_d12  0x00000001U
#define SRT_NX90_hif_pio_irq_arm_masked_irq_hif_d12  0
#define MSK_NX90_hif_pio_irq_arm_masked_irq_hif_a16  0x00000002U
#define SRT_NX90_hif_pio_irq_arm_masked_irq_hif_a16  1
#define MSK_NX90_hif_pio_irq_arm_masked_irq_hif_a17  0x00000004U
#define SRT_NX90_hif_pio_irq_arm_masked_irq_hif_a17  2
#define MSK_NX90_hif_pio_irq_arm_masked_irq_hif_dirq 0x00000008U
#define SRT_NX90_hif_pio_irq_arm_masked_irq_hif_dirq 3

/* all used bits of 'NX90_hif_pio_irq_arm_masked': */
#define MSK_USED_BITS_NX90_hif_pio_irq_arm_masked 0x0000000fU

enum {
  BFW_NX90_hif_pio_irq_arm_masked_irq_hif_d12  = 1,  /* [0] */
  BFW_NX90_hif_pio_irq_arm_masked_irq_hif_a16  = 1,  /* [1] */
  BFW_NX90_hif_pio_irq_arm_masked_irq_hif_a17  = 1,  /* [2] */
  BFW_NX90_hif_pio_irq_arm_masked_irq_hif_dirq = 1,  /* [3] */
  BFW_NX90_hif_pio_irq_arm_masked_reserved1    = 28  /* [31:4] */
};

typedef struct NX90_HIF_PIO_IRQ_ARM_MASKED_BIT_Ttag {
  unsigned int irq_hif_d12  : BFW_NX90_hif_pio_irq_arm_masked_irq_hif_d12;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) */
  unsigned int irq_hif_a16  : BFW_NX90_hif_pio_irq_arm_masked_irq_hif_a16;  /* HIF_A16 IRQ                     */
  unsigned int irq_hif_a17  : BFW_NX90_hif_pio_irq_arm_masked_irq_hif_a17;  /* HIF_A17 IRQ                     */
  unsigned int irq_hif_dirq : BFW_NX90_hif_pio_irq_arm_masked_irq_hif_dirq; /* HIF_DIRQ IRQ                    */
  unsigned int reserved1    : BFW_NX90_hif_pio_irq_arm_masked_reserved1;    /* reserved                        */
} NX90_HIF_PIO_IRQ_ARM_MASKED_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_HIF_PIO_IRQ_ARM_MASKED_BIT_T bf;
} NX90_HIF_PIO_IRQ_ARM_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_xpic_mask_set */
/* => HIF PIO Interrupt Mask Register for netX internal xPIC. */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal xPIC. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal xPIC without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_irq_xpic_mask_set         0x00000034U
#define Adr_NX90_hif_io_ctrl_hif_pio_irq_xpic_mask_set 0xFF4014B4U
#define Adr_NX90_hif_pio_irq_xpic_mask_set             0xFF4014B4U
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_set        0x00000000U

#define MSK_NX90_hif_pio_irq_xpic_mask_set_irq_hif_d12          0x00000001U
#define SRT_NX90_hif_pio_irq_xpic_mask_set_irq_hif_d12          0
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_d12     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_d12  0x00000000U
#define MSK_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a16          0x00000002U
#define SRT_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a16          1
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a16     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a16  0x00000000U
#define MSK_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a17          0x00000004U
#define SRT_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a17          2
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a17     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a17  0x00000000U
#define MSK_NX90_hif_pio_irq_xpic_mask_set_irq_hif_dirq         0x00000008U
#define SRT_NX90_hif_pio_irq_xpic_mask_set_irq_hif_dirq         3
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_dirq    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_set_irq_hif_dirq 0x00000000U

/* all used bits of 'NX90_hif_pio_irq_xpic_mask_set': */
#define MSK_USED_BITS_NX90_hif_pio_irq_xpic_mask_set 0x0000000fU

enum {
  BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_d12  = 1,  /* [0] */
  BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a16  = 1,  /* [1] */
  BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a17  = 1,  /* [2] */
  BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_dirq = 1,  /* [3] */
  BFW_NX90_hif_pio_irq_xpic_mask_set_reserved1    = 28  /* [31:4] */
};

typedef struct NX90_HIF_PIO_IRQ_XPIC_MASK_SET_BIT_Ttag {
  unsigned int irq_hif_d12  : BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_d12;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) */
  unsigned int irq_hif_a16  : BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a16;  /* HIF_A16 IRQ                     */
  unsigned int irq_hif_a17  : BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_a17;  /* HIF_A17 IRQ                     */
  unsigned int irq_hif_dirq : BFW_NX90_hif_pio_irq_xpic_mask_set_irq_hif_dirq; /* HIF_DIRQ IRQ                    */
  unsigned int reserved1    : BFW_NX90_hif_pio_irq_xpic_mask_set_reserved1;    /* reserved                        */
} NX90_HIF_PIO_IRQ_XPIC_MASK_SET_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_HIF_PIO_IRQ_XPIC_MASK_SET_BIT_T bf;
} NX90_HIF_PIO_IRQ_XPIC_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_xpic_mask_reset */
/* => HIF PIO Interrupt Mask Reset Register for netX internal xPIC. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal xPIC if asserted. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal xPIC without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_irq_xpic_mask_reset         0x00000038U
#define Adr_NX90_hif_io_ctrl_hif_pio_irq_xpic_mask_reset 0xFF4014B8U
#define Adr_NX90_hif_pio_irq_xpic_mask_reset             0xFF4014B8U
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_reset        0x00000000U

#define MSK_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_d12          0x00000001U
#define SRT_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_d12          0
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_d12     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_d12  0x00000000U
#define MSK_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a16          0x00000002U
#define SRT_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a16          1
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a16     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a16  0x00000000U
#define MSK_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a17          0x00000004U
#define SRT_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a17          2
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a17     0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a17  0x00000000U
#define MSK_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_dirq         0x00000008U
#define SRT_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_dirq         3
#define DFLT_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_dirq    0x00000000U
#define DFLT_BF_VAL_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_dirq 0x00000000U

/* all used bits of 'NX90_hif_pio_irq_xpic_mask_reset': */
#define MSK_USED_BITS_NX90_hif_pio_irq_xpic_mask_reset 0x0000000fU

enum {
  BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_d12  = 1,  /* [0] */
  BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a16  = 1,  /* [1] */
  BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a17  = 1,  /* [2] */
  BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_dirq = 1,  /* [3] */
  BFW_NX90_hif_pio_irq_xpic_mask_reset_reserved1    = 28  /* [31:4] */
};

typedef struct NX90_HIF_PIO_IRQ_XPIC_MASK_RESET_BIT_Ttag {
  unsigned int irq_hif_d12  : BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_d12;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) */
  unsigned int irq_hif_a16  : BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a16;  /* HIF_A16 IRQ                     */
  unsigned int irq_hif_a17  : BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_a17;  /* HIF_A17 IRQ                     */
  unsigned int irq_hif_dirq : BFW_NX90_hif_pio_irq_xpic_mask_reset_irq_hif_dirq; /* HIF_DIRQ IRQ                    */
  unsigned int reserved1    : BFW_NX90_hif_pio_irq_xpic_mask_reset_reserved1;    /* reserved                        */
} NX90_HIF_PIO_IRQ_XPIC_MASK_RESET_BIT_T;

typedef union {
  uint32_t                               val;
  NX90_HIF_PIO_IRQ_XPIC_MASK_RESET_BIT_T bf;
} NX90_HIF_PIO_IRQ_XPIC_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_xpic_masked */
/* => HIF PIO Masked Interrupt Status Register for netX internal xPIC. */
/*    If bit is set, if the according mask bit is set in hif_pio_irq_xpic_mask-register and the according interrupt is asserted. */
/*    IRQ for netX internal xPIC signal is asserted if at least one bit is set here. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal xPIC signal without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hif_pio_irq_xpic_masked         0x0000003CU
#define Adr_NX90_hif_io_ctrl_hif_pio_irq_xpic_masked 0xFF4014BCU
#define Adr_NX90_hif_pio_irq_xpic_masked             0xFF4014BCU

#define MSK_NX90_hif_pio_irq_xpic_masked_irq_hif_d12  0x00000001U
#define SRT_NX90_hif_pio_irq_xpic_masked_irq_hif_d12  0
#define MSK_NX90_hif_pio_irq_xpic_masked_irq_hif_a16  0x00000002U
#define SRT_NX90_hif_pio_irq_xpic_masked_irq_hif_a16  1
#define MSK_NX90_hif_pio_irq_xpic_masked_irq_hif_a17  0x00000004U
#define SRT_NX90_hif_pio_irq_xpic_masked_irq_hif_a17  2
#define MSK_NX90_hif_pio_irq_xpic_masked_irq_hif_dirq 0x00000008U
#define SRT_NX90_hif_pio_irq_xpic_masked_irq_hif_dirq 3

/* all used bits of 'NX90_hif_pio_irq_xpic_masked': */
#define MSK_USED_BITS_NX90_hif_pio_irq_xpic_masked 0x0000000fU

enum {
  BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_d12  = 1,  /* [0] */
  BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_a16  = 1,  /* [1] */
  BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_a17  = 1,  /* [2] */
  BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_dirq = 1,  /* [3] */
  BFW_NX90_hif_pio_irq_xpic_masked_reserved1    = 28  /* [31:4] */
};

typedef struct NX90_HIF_PIO_IRQ_XPIC_MASKED_BIT_Ttag {
  unsigned int irq_hif_d12  : BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_d12;  /* HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) */
  unsigned int irq_hif_a16  : BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_a16;  /* HIF_A16 IRQ                     */
  unsigned int irq_hif_a17  : BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_a17;  /* HIF_A17 IRQ                     */
  unsigned int irq_hif_dirq : BFW_NX90_hif_pio_irq_xpic_masked_irq_hif_dirq; /* HIF_DIRQ IRQ                    */
  unsigned int reserved1    : BFW_NX90_hif_pio_irq_xpic_masked_reserved1;    /* reserved                        */
} NX90_HIF_PIO_IRQ_XPIC_MASKED_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_HIF_PIO_IRQ_XPIC_MASKED_BIT_T bf;
} NX90_HIF_PIO_IRQ_XPIC_MASKED_T;


/* ===================================================================== */

/* Area of hifmemctrl */

/* ===================================================================== */

#define Addr_NX90_hifmemctrl 0xFF401500U

/* ===================================================================== */

/* AREA ext_asyncmem_ctrl */
/* Area of hif_asyncmem_ctrl */

/* ===================================================================== */

#define Addr_NX90_hif_asyncmem_ctrl 0xFF401500U

/* --------------------------------------------------------------------- */
/* Register extsram0_ctrl */
/* => Control Register for external bus interface and wait-states for chip-select 0 area. */
/*    External addresses always be byte addresses. */
/*    For additional byte-enables/DQM signals view netX pinout documentation. */
/*    For all wait state configuration 1 cycle is 1 netx system clock cycle, i.e. 10ns for netX running on 100MHz at normal operation. */
/*    Note: Pause and data width configuration is compatible to netx500/100 and netx50. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_extsram0_ctrl               0x00000000U
#define Adr_NX90_hif_asyncmem_ctrl_extsram0_ctrl 0xFF401500U
#define Adr_NX90_extsram0_ctrl                   0xFF401500U
#define DFLT_VAL_NX90_extsram0_ctrl              0x0303033fU

#define MSK_NX90_extsram0_ctrl_ws                       0x0000003fU
#define SRT_NX90_extsram0_ctrl_ws                       0
#define DFLT_VAL_NX90_extsram0_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX90_extsram0_ctrl_ws               0x0000003fU
#define MSK_NX90_extsram0_ctrl_p_pre                    0x00000300U
#define SRT_NX90_extsram0_ctrl_p_pre                    8
#define DFLT_VAL_NX90_extsram0_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX90_extsram0_ctrl_p_pre            0x00000003U
#define MSK_NX90_extsram0_ctrl_p_post                   0x00030000U
#define SRT_NX90_extsram0_ctrl_p_post                   16
#define DFLT_VAL_NX90_extsram0_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX90_extsram0_ctrl_p_post           0x00000003U
#define MSK_NX90_extsram0_ctrl_dwidth                   0x03000000U
#define SRT_NX90_extsram0_ctrl_dwidth                   24
#define DFLT_VAL_NX90_extsram0_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX90_extsram0_ctrl_dwidth           0x00000003U
#define MSK_NX90_extsram0_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX90_extsram0_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX90_extsram0_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX90_extsram0_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX90_extsram0_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX90_extsram0_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX90_extsram0_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX90_extsram0_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX90_extsram0_ctrl_static_cs                0x40000000U
#define SRT_NX90_extsram0_ctrl_static_cs                30
#define DFLT_VAL_NX90_extsram0_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX90_extsram0_ctrl_static_cs        0x00000000U
#define MSK_NX90_extsram0_ctrl_ready_en                 0x80000000U
#define SRT_NX90_extsram0_ctrl_ready_en                 31
#define DFLT_VAL_NX90_extsram0_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX90_extsram0_ctrl_ready_en         0x00000000U

/* all used bits of 'NX90_extsram0_ctrl': */
#define MSK_USED_BITS_NX90_extsram0_ctrl 0xf303033fU

enum {
  BFW_NX90_extsram0_ctrl_ws               = 6, /* [5:0] */
  BFW_NX90_extsram0_ctrl_reserved1        = 2, /* [7:6] */
  BFW_NX90_extsram0_ctrl_p_pre            = 2, /* [9:8] */
  BFW_NX90_extsram0_ctrl_reserved2        = 6, /* [15:10] */
  BFW_NX90_extsram0_ctrl_p_post           = 2, /* [17:16] */
  BFW_NX90_extsram0_ctrl_reserved3        = 6, /* [23:18] */
  BFW_NX90_extsram0_ctrl_dwidth           = 2, /* [25:24] */
  BFW_NX90_extsram0_ctrl_reserved4        = 2, /* [27:26] */
  BFW_NX90_extsram0_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
  BFW_NX90_extsram0_ctrl_no_p_post_seq_rd = 1, /* [29] */
  BFW_NX90_extsram0_ctrl_static_cs        = 1, /* [30] */
  BFW_NX90_extsram0_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX90_EXTSRAM0_CTRL_BIT_Ttag {
  unsigned int ws               : BFW_NX90_extsram0_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem0 area.                                                      */
                                                                           /* During read access nRD-signal active low phase is ws+1.                                           */
                                                                           /* During write access nWR-signal active low phase is ws+1..                                         */
                                                                           /* Address, chip-select and byte-enable signals remain stable in this phase.                         */
                                                                           /* After ws wait-cycles have passed signals remain stable and final data-access cycle is done.       */
                                                                           /* To match memory device data access time tACC: program  WS=ceil(tACC/10ns)-1.                      */
  unsigned int reserved1        : BFW_NX90_extsram0_ctrl_reserved1;        /* reserved                                                                                          */
  unsigned int p_pre            : BFW_NX90_extsram0_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem0 area.                                                         */
                                                                           /* Additional wait-states to match memory device setup times.                                        */
                                                                           /* If programmed value is not 0, this Pre-Pause will be inserted at external access start            */
                                                                           /* before Wait-State phase is started.                                                               */
                                                                           /* Address, chip-select and byte-enable signals will be stable in this phase.                        */
                                                                           /* but nRD-signal and nWR-signal remains inactive high.                                              */
                                                                           /* Note: The Pre-Pause could be extended by 1 cycle under certain conditions by                      */
                                                                           /*       netX memory controller. E.g. this becomes necessary for some access sequences               */
                                                                           /*       (e.g. write-after-read or chip-select area change) to avoid collisions on external          */
                                                                           /*       data bus.                                                                                   */
  unsigned int reserved2        : BFW_NX90_extsram0_ctrl_reserved2;        /* reserved                                                                                          */
  unsigned int p_post           : BFW_NX90_extsram0_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem0 area.                                                        */
                                                                           /* Additional wait-states to match memory device Output-Disable or Address-Hold times.               */
                                                                           /* If programmed value is not 0, this Post-Pause will be inserted at external access end             */
                                                                           /* after Wait-State phase and data access cycle.                                                     */
                                                                           /* Address, chip-select and byte-enable signals will remain stable in this phase.                    */
                                                                           /* but nRD-signal and nWR-signal will become inactive high.                                          */
                                                                           /* After write access netX memory controller will always insert at least                             */
                                                                           /* 1 Post-Pause cycle to generate positive edge on nWR-signal.                                       */
  unsigned int reserved3        : BFW_NX90_extsram0_ctrl_reserved3;        /* reserved                                                                                          */
  unsigned int dwidth           : BFW_NX90_extsram0_ctrl_dwidth;           /* Data bus width of ExtMem0 area.                                                                   */
                                                                           /*  00 :  8bit memory device connected to this chip-select address area.                             */
                                                                           /*  01 : 16bit memory device connected to this chip-select address area.                             */
                                                                           /*  10 : reserved.                                                                                   */
                                                                           /*  11 : memory is disabled, related chip-select signal can be used for other purpose (e.g. as PIO). */
                                                                           /* Note: Chip-selects are disabled by default. However it could be possible                          */
                                                                           /*       that they are enabled during netX boot phase to search for boot device.                     */
                                                                           /*       View bootloader information for this.                                                       */
                                                                           /* Note: When chip-select is disabled related netX IO can be used for other                          */
                                                                           /*       functions. View memory interface multiplex options or netX pinning for more information.    */
                                                                           /* Note: All access to disabled chip-select area will be ignored. No wait will be                    */
                                                                           /*       generated to requesting master. Read data will be unvalid. External MI signal states        */
                                                                           /*       will not change.                                                                            */
  unsigned int reserved4        : BFW_NX90_extsram0_ctrl_reserved4;        /* reserved                                                                                          */
  unsigned int no_p_pre_seq_rd  : BFW_NX90_extsram0_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                                  */
                                                                           /* 0: Pre-Pause will be inserted after each read access.                                             */
                                                                           /* 1: Disable Pre-Pause between sequential reads.                                                    */
                                                                           /* Note: default setting '0' is for netx100/50 compatibility only. Typically there is                */
                                                                           /*       no need of Pre-Pause insertion between sequential reads.                                    */
  unsigned int no_p_post_seq_rd : BFW_NX90_extsram0_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                                 */
                                                                           /* 0: Post-Pause will be inserted after each read access.                                            */
                                                                           /* 1: Disable Post-Pause between sequential reads.                                                   */
                                                                           /* Note: Default setting '0' is for netx100/50 compatibility only. Typically there is                */
                                                                           /*       no need of Post-Pause insertion between sequential reads. A Post-Pause will                 */
                                                                           /*       always be inserted if the next access addresses another chip-select area, is a write        */
                                                                           /*       access or is not predictable by the memory controller.                                      */
  unsigned int static_cs        : BFW_NX90_extsram0_ctrl_static_cs;        /* Static chip-select signal generation.                                                             */
                                                                           /* 0: No static chip-select signal generation                                                        */
                                                                           /* 1: Static chip-select signal generation enabled (e.g. for i80 displays).                          */
                                                                           /* All chip-select signals will return to inactive (high) level when no access is performed          */
                                                                           /* by default (when this bit is not set). However some devices (e.g. some i80 displays) require      */
                                                                           /* subsequent access without chip-select becoming inactive in between. For that purpose              */
                                                                           /* 'static_cs' bit can be set. Chip-select will remain active once an access was performed           */
                                                                           /* to this chip-select address-area until an access targets another chip-select address-area.        */
                                                                           /* Hence, for proper i80 sequence, software must avoid that the current access sequence is           */
                                                                           /* interrupted by an access to another chip-select area (including SDRAM access of this memory       */
                                                                           /* interface), e.g. cause by interrupt execution, other masters or SDRAM refresh generation.         */
                                                                           /* To release chip-select to idle state,                                                             */
                                                                           /* - access another chip-select area of this memory interface or                                     */
                                                                           /* - clear the 'static_cs' bit of this chip-select area or                                           */
                                                                           /* - disable this chip-select area (set 'dwidth' to '11').                                           */
                                                                           /* Note: Clearing the 'static_cs'-bit while an access is running to this chip-select area            */
                                                                           /*       will have no impact on the current access. However disabling the whole chip-select area     */
                                                                           /*       while an access is running could lead to an invalid access.                                 */
                                                                           /* Note: This is a new feature since netx51/52.                                                      */
  unsigned int ready_en         : BFW_NX90_extsram0_ctrl_ready_en;         /* Ready Signal Enable.                                                                              */
                                                                           /* 0: Access timing is only controlled by Wait-State and Pre/Post-Pause configuration above.         */
                                                                           /* 1: Use external ready input to stretch Wait-State phase.                                          */
                                                                           /*    Wait-States and Pre/Post-Pauses will be done according to configuration above. However         */
                                                                           /*    Wait-State phase can be extended by an external device by holding netX ready input             */
                                                                           /*    inactive. Data access cycle is done after external device sets netX ready input to             */
                                                                           /*    active state.                                                                                  */
                                                                           /* Note: An external device must assert ready to inactive state while                                */
                                                                           /*       Wait-States phase is running (defined by ws in this register). Ready input                  */
                                                                           /*       sampling and latency takes 20ns. Hence ws must be set to a value greater                    */
                                                                           /*       than 2 for proper functionality using ready. The value must be increased                    */
                                                                           /*       if there is a ready setup time of the ready generating external device.                     */
                                                                           /* Note: For detailed ready input configuration and handling view ext_rdy_cfg register description.  */
} NX90_EXTSRAM0_CTRL_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_EXTSRAM0_CTRL_BIT_T bf;
} NX90_EXTSRAM0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extsram1_ctrl */
/* => Control Register for external bus interface and wait-states for chip-select 1 area. */
/*    For detailed register description view extsram0_ctrl register. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_extsram1_ctrl               0x00000004U
#define Adr_NX90_hif_asyncmem_ctrl_extsram1_ctrl 0xFF401504U
#define Adr_NX90_extsram1_ctrl                   0xFF401504U
#define DFLT_VAL_NX90_extsram1_ctrl              0x0303033fU

#define MSK_NX90_extsram1_ctrl_ws                       0x0000003fU
#define SRT_NX90_extsram1_ctrl_ws                       0
#define DFLT_VAL_NX90_extsram1_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX90_extsram1_ctrl_ws               0x0000003fU
#define MSK_NX90_extsram1_ctrl_p_pre                    0x00000300U
#define SRT_NX90_extsram1_ctrl_p_pre                    8
#define DFLT_VAL_NX90_extsram1_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX90_extsram1_ctrl_p_pre            0x00000003U
#define MSK_NX90_extsram1_ctrl_p_post                   0x00030000U
#define SRT_NX90_extsram1_ctrl_p_post                   16
#define DFLT_VAL_NX90_extsram1_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX90_extsram1_ctrl_p_post           0x00000003U
#define MSK_NX90_extsram1_ctrl_dwidth                   0x03000000U
#define SRT_NX90_extsram1_ctrl_dwidth                   24
#define DFLT_VAL_NX90_extsram1_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX90_extsram1_ctrl_dwidth           0x00000003U
#define MSK_NX90_extsram1_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX90_extsram1_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX90_extsram1_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX90_extsram1_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX90_extsram1_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX90_extsram1_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX90_extsram1_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX90_extsram1_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX90_extsram1_ctrl_static_cs                0x40000000U
#define SRT_NX90_extsram1_ctrl_static_cs                30
#define DFLT_VAL_NX90_extsram1_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX90_extsram1_ctrl_static_cs        0x00000000U
#define MSK_NX90_extsram1_ctrl_ready_en                 0x80000000U
#define SRT_NX90_extsram1_ctrl_ready_en                 31
#define DFLT_VAL_NX90_extsram1_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX90_extsram1_ctrl_ready_en         0x00000000U

/* all used bits of 'NX90_extsram1_ctrl': */
#define MSK_USED_BITS_NX90_extsram1_ctrl 0xf303033fU

enum {
  BFW_NX90_extsram1_ctrl_ws               = 6, /* [5:0] */
  BFW_NX90_extsram1_ctrl_reserved1        = 2, /* [7:6] */
  BFW_NX90_extsram1_ctrl_p_pre            = 2, /* [9:8] */
  BFW_NX90_extsram1_ctrl_reserved2        = 6, /* [15:10] */
  BFW_NX90_extsram1_ctrl_p_post           = 2, /* [17:16] */
  BFW_NX90_extsram1_ctrl_reserved3        = 6, /* [23:18] */
  BFW_NX90_extsram1_ctrl_dwidth           = 2, /* [25:24] */
  BFW_NX90_extsram1_ctrl_reserved4        = 2, /* [27:26] */
  BFW_NX90_extsram1_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
  BFW_NX90_extsram1_ctrl_no_p_post_seq_rd = 1, /* [29] */
  BFW_NX90_extsram1_ctrl_static_cs        = 1, /* [30] */
  BFW_NX90_extsram1_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX90_EXTSRAM1_CTRL_BIT_Ttag {
  unsigned int ws               : BFW_NX90_extsram1_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem1 area.                                          */
  unsigned int reserved1        : BFW_NX90_extsram1_ctrl_reserved1;        /* reserved                                                                              */
  unsigned int p_pre            : BFW_NX90_extsram1_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem1 area.                                             */
  unsigned int reserved2        : BFW_NX90_extsram1_ctrl_reserved2;        /* reserved                                                                              */
  unsigned int p_post           : BFW_NX90_extsram1_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem1 area.                                            */
  unsigned int reserved3        : BFW_NX90_extsram1_ctrl_reserved3;        /* reserved                                                                              */
  unsigned int dwidth           : BFW_NX90_extsram1_ctrl_dwidth;           /* Data bus width of ExtMem1 area.                                                       */
                                                                           /* Note: This chip-select is disabled by default and may be shared with other functions. */
                                                                           /*       View memory interface multiplex options for more information.                   */
  unsigned int reserved4        : BFW_NX90_extsram1_ctrl_reserved4;        /* reserved                                                                              */
  unsigned int no_p_pre_seq_rd  : BFW_NX90_extsram1_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                      */
  unsigned int no_p_post_seq_rd : BFW_NX90_extsram1_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                     */
  unsigned int static_cs        : BFW_NX90_extsram1_ctrl_static_cs;        /* Static chip-select signal generation.                                                 */
  unsigned int ready_en         : BFW_NX90_extsram1_ctrl_ready_en;         /* Ready Signal Enable.                                                                  */
} NX90_EXTSRAM1_CTRL_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_EXTSRAM1_CTRL_BIT_T bf;
} NX90_EXTSRAM1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extsram2_ctrl */
/* => Control Register for external bus interface and wait-states for chip-select 2 area. */
/*    For detailed register description view extsram0_ctrl register. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_extsram2_ctrl               0x00000008U
#define Adr_NX90_hif_asyncmem_ctrl_extsram2_ctrl 0xFF401508U
#define Adr_NX90_extsram2_ctrl                   0xFF401508U
#define DFLT_VAL_NX90_extsram2_ctrl              0x0303033fU

#define MSK_NX90_extsram2_ctrl_ws                       0x0000003fU
#define SRT_NX90_extsram2_ctrl_ws                       0
#define DFLT_VAL_NX90_extsram2_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX90_extsram2_ctrl_ws               0x0000003fU
#define MSK_NX90_extsram2_ctrl_p_pre                    0x00000300U
#define SRT_NX90_extsram2_ctrl_p_pre                    8
#define DFLT_VAL_NX90_extsram2_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX90_extsram2_ctrl_p_pre            0x00000003U
#define MSK_NX90_extsram2_ctrl_p_post                   0x00030000U
#define SRT_NX90_extsram2_ctrl_p_post                   16
#define DFLT_VAL_NX90_extsram2_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX90_extsram2_ctrl_p_post           0x00000003U
#define MSK_NX90_extsram2_ctrl_dwidth                   0x03000000U
#define SRT_NX90_extsram2_ctrl_dwidth                   24
#define DFLT_VAL_NX90_extsram2_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX90_extsram2_ctrl_dwidth           0x00000003U
#define MSK_NX90_extsram2_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX90_extsram2_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX90_extsram2_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX90_extsram2_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX90_extsram2_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX90_extsram2_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX90_extsram2_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX90_extsram2_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX90_extsram2_ctrl_static_cs                0x40000000U
#define SRT_NX90_extsram2_ctrl_static_cs                30
#define DFLT_VAL_NX90_extsram2_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX90_extsram2_ctrl_static_cs        0x00000000U
#define MSK_NX90_extsram2_ctrl_ready_en                 0x80000000U
#define SRT_NX90_extsram2_ctrl_ready_en                 31
#define DFLT_VAL_NX90_extsram2_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX90_extsram2_ctrl_ready_en         0x00000000U

/* all used bits of 'NX90_extsram2_ctrl': */
#define MSK_USED_BITS_NX90_extsram2_ctrl 0xf303033fU

enum {
  BFW_NX90_extsram2_ctrl_ws               = 6, /* [5:0] */
  BFW_NX90_extsram2_ctrl_reserved1        = 2, /* [7:6] */
  BFW_NX90_extsram2_ctrl_p_pre            = 2, /* [9:8] */
  BFW_NX90_extsram2_ctrl_reserved2        = 6, /* [15:10] */
  BFW_NX90_extsram2_ctrl_p_post           = 2, /* [17:16] */
  BFW_NX90_extsram2_ctrl_reserved3        = 6, /* [23:18] */
  BFW_NX90_extsram2_ctrl_dwidth           = 2, /* [25:24] */
  BFW_NX90_extsram2_ctrl_reserved4        = 2, /* [27:26] */
  BFW_NX90_extsram2_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
  BFW_NX90_extsram2_ctrl_no_p_post_seq_rd = 1, /* [29] */
  BFW_NX90_extsram2_ctrl_static_cs        = 1, /* [30] */
  BFW_NX90_extsram2_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX90_EXTSRAM2_CTRL_BIT_Ttag {
  unsigned int ws               : BFW_NX90_extsram2_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem2 area.                                          */
  unsigned int reserved1        : BFW_NX90_extsram2_ctrl_reserved1;        /* reserved                                                                              */
  unsigned int p_pre            : BFW_NX90_extsram2_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem2 area.                                             */
  unsigned int reserved2        : BFW_NX90_extsram2_ctrl_reserved2;        /* reserved                                                                              */
  unsigned int p_post           : BFW_NX90_extsram2_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem2 area.                                            */
  unsigned int reserved3        : BFW_NX90_extsram2_ctrl_reserved3;        /* reserved                                                                              */
  unsigned int dwidth           : BFW_NX90_extsram2_ctrl_dwidth;           /* Data bus width of ExtMem2 area.                                                       */
                                                                           /* Note: This chip-select is disabled by default and may be shared with other functions. */
                                                                           /*       View memory interface multiplex options for more information.                   */
  unsigned int reserved4        : BFW_NX90_extsram2_ctrl_reserved4;        /* reserved                                                                              */
  unsigned int no_p_pre_seq_rd  : BFW_NX90_extsram2_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                      */
  unsigned int no_p_post_seq_rd : BFW_NX90_extsram2_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                     */
  unsigned int static_cs        : BFW_NX90_extsram2_ctrl_static_cs;        /* Static chip-select signal generation.                                                 */
  unsigned int ready_en         : BFW_NX90_extsram2_ctrl_ready_en;         /* Ready Signal Enable.                                                                  */
} NX90_EXTSRAM2_CTRL_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_EXTSRAM2_CTRL_BIT_T bf;
} NX90_EXTSRAM2_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extsram3_ctrl */
/* => Control Register for external bus interface and wait-states for ExtMem1 chip-select 3 area. */
/*    For detailed register description view extsram0_ctrl register. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_extsram3_ctrl               0x0000000CU
#define Adr_NX90_hif_asyncmem_ctrl_extsram3_ctrl 0xFF40150CU
#define Adr_NX90_extsram3_ctrl                   0xFF40150CU
#define DFLT_VAL_NX90_extsram3_ctrl              0x0303033fU

#define MSK_NX90_extsram3_ctrl_ws                       0x0000003fU
#define SRT_NX90_extsram3_ctrl_ws                       0
#define DFLT_VAL_NX90_extsram3_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX90_extsram3_ctrl_ws               0x0000003fU
#define MSK_NX90_extsram3_ctrl_p_pre                    0x00000300U
#define SRT_NX90_extsram3_ctrl_p_pre                    8
#define DFLT_VAL_NX90_extsram3_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX90_extsram3_ctrl_p_pre            0x00000003U
#define MSK_NX90_extsram3_ctrl_p_post                   0x00030000U
#define SRT_NX90_extsram3_ctrl_p_post                   16
#define DFLT_VAL_NX90_extsram3_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX90_extsram3_ctrl_p_post           0x00000003U
#define MSK_NX90_extsram3_ctrl_dwidth                   0x03000000U
#define SRT_NX90_extsram3_ctrl_dwidth                   24
#define DFLT_VAL_NX90_extsram3_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX90_extsram3_ctrl_dwidth           0x00000003U
#define MSK_NX90_extsram3_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX90_extsram3_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX90_extsram3_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX90_extsram3_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX90_extsram3_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX90_extsram3_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX90_extsram3_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX90_extsram3_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX90_extsram3_ctrl_static_cs                0x40000000U
#define SRT_NX90_extsram3_ctrl_static_cs                30
#define DFLT_VAL_NX90_extsram3_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX90_extsram3_ctrl_static_cs        0x00000000U
#define MSK_NX90_extsram3_ctrl_ready_en                 0x80000000U
#define SRT_NX90_extsram3_ctrl_ready_en                 31
#define DFLT_VAL_NX90_extsram3_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX90_extsram3_ctrl_ready_en         0x00000000U

/* all used bits of 'NX90_extsram3_ctrl': */
#define MSK_USED_BITS_NX90_extsram3_ctrl 0xf303033fU

enum {
  BFW_NX90_extsram3_ctrl_ws               = 6, /* [5:0] */
  BFW_NX90_extsram3_ctrl_reserved1        = 2, /* [7:6] */
  BFW_NX90_extsram3_ctrl_p_pre            = 2, /* [9:8] */
  BFW_NX90_extsram3_ctrl_reserved2        = 6, /* [15:10] */
  BFW_NX90_extsram3_ctrl_p_post           = 2, /* [17:16] */
  BFW_NX90_extsram3_ctrl_reserved3        = 6, /* [23:18] */
  BFW_NX90_extsram3_ctrl_dwidth           = 2, /* [25:24] */
  BFW_NX90_extsram3_ctrl_reserved4        = 2, /* [27:26] */
  BFW_NX90_extsram3_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
  BFW_NX90_extsram3_ctrl_no_p_post_seq_rd = 1, /* [29] */
  BFW_NX90_extsram3_ctrl_static_cs        = 1, /* [30] */
  BFW_NX90_extsram3_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX90_EXTSRAM3_CTRL_BIT_Ttag {
  unsigned int ws               : BFW_NX90_extsram3_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem3 area.                                          */
  unsigned int reserved1        : BFW_NX90_extsram3_ctrl_reserved1;        /* reserved                                                                              */
  unsigned int p_pre            : BFW_NX90_extsram3_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem3 area.                                             */
  unsigned int reserved2        : BFW_NX90_extsram3_ctrl_reserved2;        /* reserved                                                                              */
  unsigned int p_post           : BFW_NX90_extsram3_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem3 area.                                            */
  unsigned int reserved3        : BFW_NX90_extsram3_ctrl_reserved3;        /* reserved                                                                              */
  unsigned int dwidth           : BFW_NX90_extsram3_ctrl_dwidth;           /* Data bus width of ExtMem3 area.                                                       */
                                                                           /* Note: This chip-select is disabled by default and may be shared with other functions. */
                                                                           /*       View memory interface multiplex options for more information.                   */
  unsigned int reserved4        : BFW_NX90_extsram3_ctrl_reserved4;        /* reserved                                                                              */
  unsigned int no_p_pre_seq_rd  : BFW_NX90_extsram3_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                      */
  unsigned int no_p_post_seq_rd : BFW_NX90_extsram3_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                     */
  unsigned int static_cs        : BFW_NX90_extsram3_ctrl_static_cs;        /* Static chip-select signal generation.                                                 */
  unsigned int ready_en         : BFW_NX90_extsram3_ctrl_ready_en;         /* Ready Signal Enable.                                                                  */
} NX90_EXTSRAM3_CTRL_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_EXTSRAM3_CTRL_BIT_T bf;
} NX90_EXTSRAM3_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ext_cs0_apm_ctrl */
/* => Asynchronous Page Mode (APM) Control Register for ExtMem0 chip-select area. */
/*    Only ExtMem0 chip-select area supports fast Asynchronous-Page-Mode (APM) Access. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ext_cs0_apm_ctrl               0x00000010U
#define Adr_NX90_hif_asyncmem_ctrl_ext_cs0_apm_ctrl 0xFF401510U
#define Adr_NX90_ext_cs0_apm_ctrl                   0xFF401510U
#define DFLT_VAL_NX90_ext_cs0_apm_ctrl              0x0000000fU

#define MSK_NX90_ext_cs0_apm_ctrl_ws_apm          0x0000000fU
#define SRT_NX90_ext_cs0_apm_ctrl_ws_apm          0
#define DFLT_VAL_NX90_ext_cs0_apm_ctrl_ws_apm     0x0000000fU
#define DFLT_BF_VAL_NX90_ext_cs0_apm_ctrl_ws_apm  0x0000000fU
#define MSK_NX90_ext_cs0_apm_ctrl_apm_cfg         0x00000700U
#define SRT_NX90_ext_cs0_apm_ctrl_apm_cfg         8
#define DFLT_VAL_NX90_ext_cs0_apm_ctrl_apm_cfg    0x00000000U
#define DFLT_BF_VAL_NX90_ext_cs0_apm_ctrl_apm_cfg 0x00000000U

/* all used bits of 'NX90_ext_cs0_apm_ctrl': */
#define MSK_USED_BITS_NX90_ext_cs0_apm_ctrl 0x0000070fU

enum {
  BFW_NX90_ext_cs0_apm_ctrl_ws_apm    = 4,  /* [3:0] */
  BFW_NX90_ext_cs0_apm_ctrl_reserved1 = 4,  /* [7:4] */
  BFW_NX90_ext_cs0_apm_ctrl_apm_cfg   = 3,  /* [10:8] */
  BFW_NX90_ext_cs0_apm_ctrl_reserved2 = 21  /* [31:11] */
};

typedef struct NX90_EXT_CS0_APM_CTRL_BIT_Ttag {
  unsigned int ws_apm    : BFW_NX90_ext_cs0_apm_ctrl_ws_apm;    /* APM read burst wait-states (0 - 15 cycles).                                                                        */
                                                                /* If APM is enabled by apm_cfg-bits, first read access is done                                                       */
                                                                /* with number of wait-states programmed in extsram0_ctrl register. Following read accesses to                        */
                                                                /* ExtMem0 chip-select area are done with wait-states programmed here until APM-accesses are terminated.              */
                                                                /* If netX runs internal read bursts only netX address lines will change. chip-select and nRD signals                 */
                                                                /* will remain active low.                                                                                            */
                                                                /* APM accesses are terminated if chip-select of ExtMem0 address area becomes inactive, if write access               */
                                                                /* is done between read accesses or if read access is leaving APM address boundary.                                   */
                                                                /* Note:                                                                                                              */
                                                                /*    Chip-select remains active low after read even if no further access is currently requested by netX. Chip-select */
                                                                /*    will become inactive, if access to another external chip-select area is requested or if external memory         */
                                                                /*    bus is shared with SDRAM and netX SDRAM controller performs access or refresh cycles.                           */
  unsigned int reserved1 : BFW_NX90_ext_cs0_apm_ctrl_reserved1; /* reserved                                                                                                           */
  unsigned int apm_cfg   : BFW_NX90_ext_cs0_apm_ctrl_apm_cfg;   /* APM configuration.                                                                                                 */
                                                                /* 000 : read bursts are disabled                                                                                     */
                                                                /* 001 :  1 D-word (4 byte) address boundary for APM                                                                  */
                                                                /* 010 :  2 D-word (8 byte) address boundary for APM                                                                  */
                                                                /* 011 :  4 D-word (16 byte) address boundary for APM                                                                 */
                                                                /* 100 :  8 D-word (32 byte) address boundary for APM                                                                 */
                                                                /* 101 : 16 D-word (64 byte) address boundary for APM                                                                 */
                                                                /* 110 : 32 D-word (128 byte) address boundary for APM                                                                */
                                                                /* all other settings are reserved.                                                                                   */
                                                                /* APM burst length programming is related to system address boundaries. For                                          */
                                                                /* correct programming device data width and page size must be considdered.                                           */
                                                                /* Examples:                                                                                                          */
                                                                /* 8 bit device providing 4 word page: Page size is 1 D-word. Hence program '000'.                                    */
                                                                /* 16 bit device providing 8 word page: Page size is 4 D-word. Hence program '011'.                                   */
                                                                /* 32 bit device providing 32 word page: Page size is 32 D-word. Hence program '110'.                                 */
                                                                /* Note:                                                                                                              */
                                                                /*   When device page size exceeds 32 D-words (128 byte), set 'apm_cfg' bit field to '110'.                           */
  unsigned int reserved2 : BFW_NX90_ext_cs0_apm_ctrl_reserved2; /* reserved                                                                                                           */
} NX90_EXT_CS0_APM_CTRL_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_EXT_CS0_APM_CTRL_BIT_T bf;
} NX90_EXT_CS0_APM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ext_rdy_cfg */
/* => External Memory Ready Control Register. */
/*    Note: Timeout is generated if ready usage is enabled by the extsramX_ctrl registers and is not asserted to active state within 10us. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ext_rdy_cfg               0x00000020U
#define Adr_NX90_hif_asyncmem_ctrl_ext_rdy_cfg 0xFF401520U
#define Adr_NX90_ext_rdy_cfg                   0xFF401520U
#define DFLT_VAL_NX90_ext_rdy_cfg              0x00000001U

#define MSK_NX90_ext_rdy_cfg_rdy_act_level         0x00000001U
#define SRT_NX90_ext_rdy_cfg_rdy_act_level         0
#define DFLT_VAL_NX90_ext_rdy_cfg_rdy_act_level    0x00000001U
#define DFLT_BF_VAL_NX90_ext_rdy_cfg_rdy_act_level 0x00000001U
#define MSK_NX90_ext_rdy_cfg_rdy_filter            0x00000030U
#define SRT_NX90_ext_rdy_cfg_rdy_filter            4
#define DFLT_VAL_NX90_ext_rdy_cfg_rdy_filter       0x00000000U
#define DFLT_BF_VAL_NX90_ext_rdy_cfg_rdy_filter    0x00000000U
#define MSK_NX90_ext_rdy_cfg_rdy_to_irq_en         0x00000100U
#define SRT_NX90_ext_rdy_cfg_rdy_to_irq_en         8
#define DFLT_VAL_NX90_ext_rdy_cfg_rdy_to_irq_en    0x00000000U
#define DFLT_BF_VAL_NX90_ext_rdy_cfg_rdy_to_irq_en 0x00000000U
#define MSK_NX90_ext_rdy_cfg_rdy_to_dis            0x00000800U
#define SRT_NX90_ext_rdy_cfg_rdy_to_dis            11
#define DFLT_VAL_NX90_ext_rdy_cfg_rdy_to_dis       0x00000000U
#define DFLT_BF_VAL_NX90_ext_rdy_cfg_rdy_to_dis    0x00000000U

/* all used bits of 'NX90_ext_rdy_cfg': */
#define MSK_USED_BITS_NX90_ext_rdy_cfg 0x00000931U

enum {
  BFW_NX90_ext_rdy_cfg_rdy_act_level = 1,  /* [0] */
  BFW_NX90_ext_rdy_cfg_reserved1     = 3,  /* [3:1] */
  BFW_NX90_ext_rdy_cfg_rdy_filter    = 2,  /* [5:4] */
  BFW_NX90_ext_rdy_cfg_reserved2     = 2,  /* [7:6] */
  BFW_NX90_ext_rdy_cfg_rdy_to_irq_en = 1,  /* [8] */
  BFW_NX90_ext_rdy_cfg_reserved3     = 2,  /* [10:9] */
  BFW_NX90_ext_rdy_cfg_rdy_to_dis    = 1,  /* [11] */
  BFW_NX90_ext_rdy_cfg_reserved4     = 20  /* [31:12] */
};

typedef struct NX90_EXT_RDY_CFG_BIT_Ttag {
  unsigned int rdy_act_level : BFW_NX90_ext_rdy_cfg_rdy_act_level; /* Ready Active Level                                                                                                          */
                                                                   /* 0: Ready is active low / stall access while ready input is high.                                                            */
                                                                   /* 1: Ready is active high / stall access while ready input is low.                                                            */
  unsigned int reserved1     : BFW_NX90_ext_rdy_cfg_reserved1;     /* reserved                                                                                                                    */
  unsigned int rdy_filter    : BFW_NX90_ext_rdy_cfg_rdy_filter;    /* Ready Input Filter.                                                                                                         */
                                                                   /* Ready input filtering is implemented to avoid false ready active detection especially if                                    */
                                                                   /* ready signal is not always driven and ready active state is realized by pull-up or down resistors.                          */
                                                                   /*  00: Ready active state is detected after ready signal is sampled once in active state (no filtering).                      */
                                                                   /*  01: Ready active state is detected after ready signal is consecutively sampled twice in active state.                      */
                                                                   /*  10: Ready active state is detected after ready signal is consecutively sampled 3 times in active state.                    */
                                                                   /*  11: Ready active state is detected after ready signal is consecutively sampled 4 times in active state.                    */
                                                                   /* Note: If ready is sampled in inactive state, active state counting will restart at zero.                                    */
                                                                   /* Note: If ready input filering is enabled, access time will be increased at least                                            */
                                                                   /*       by filter time (ready is sampled any 10ns).                                                                           */
  unsigned int reserved2     : BFW_NX90_ext_rdy_cfg_reserved2;     /* reserved                                                                                                                    */
  unsigned int rdy_to_irq_en : BFW_NX90_ext_rdy_cfg_rdy_to_irq_en; /* Ready Timeout IRQ Enable                                                                                                    */
                                                                   /* 0: No IRQ generation in case of ready timeout.                                                                              */
                                                                   /* 1: generate an IRQ in case of ready timeout.                                                                                */
                                                                   /* Note: Ready Timeout IRQ is part of netX System Status IRQ (view system_status register in area asic_ctrl and VIC registers) */
  unsigned int reserved3     : BFW_NX90_ext_rdy_cfg_reserved3;     /* reserved                                                                                                                    */
  unsigned int rdy_to_dis    : BFW_NX90_ext_rdy_cfg_rdy_to_dis;    /* Ready Timeout Disable                                                                                                       */
                                                                   /* By default ready timeout is enabled. Timeout is generated if ready usage is enabled                                         */
                                                                   /* by the extsramX_ctrl registers and is not asserted to active state within 10us (1024 system clocks).                        */
                                                                   /* If an external device requires even longer response time, ready timeout can be disabled                                     */
                                                                   /* by setting this bit. However be careful: If ready is not asserted anytime, netX system will stall. Escape                   */
                                                                   /* from this can only be achieved by Hardware Reset (e.g. by system watchdog timeout).                                         */
                                                                   /* 0: Ready timeout is enabled.                                                                                                */
                                                                   /* 1: Ready timeout is disabled.                                                                                               */
  unsigned int reserved4     : BFW_NX90_ext_rdy_cfg_reserved4;     /* reserved                                                                                                                    */
} NX90_EXT_RDY_CFG_BIT_T;

typedef union {
  uint32_t               val;
  NX90_EXT_RDY_CFG_BIT_T bf;
} NX90_EXT_RDY_CFG_T;

/* --------------------------------------------------------------------- */
/* Register ext_rdy_status */
/* => External Memory Ready Status Register. */
/*    Note: Timeout is generated if ready usage is enabled by the extsramX_ctrl registers and is not asserted to active state within 10us. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ext_rdy_status               0x00000024U
#define Adr_NX90_hif_asyncmem_ctrl_ext_rdy_status 0xFF401524U
#define Adr_NX90_ext_rdy_status                   0xFF401524U
#define DFLT_VAL_NX90_ext_rdy_status              0x00000000U

#define MSK_NX90_ext_rdy_status_rdy_to_err_adr         0x07ffffffU
#define SRT_NX90_ext_rdy_status_rdy_to_err_adr         0
#define DFLT_VAL_NX90_ext_rdy_status_rdy_to_err_adr    0x00000000U
#define DFLT_BF_VAL_NX90_ext_rdy_status_rdy_to_err_adr 0x00000000U
#define MSK_NX90_ext_rdy_status_rdy_to_err_cs          0x30000000U
#define SRT_NX90_ext_rdy_status_rdy_to_err_cs          28
#define DFLT_VAL_NX90_ext_rdy_status_rdy_to_err_cs     0x00000000U
#define DFLT_BF_VAL_NX90_ext_rdy_status_rdy_to_err_cs  0x00000000U
#define MSK_NX90_ext_rdy_status_rdy_to_err             0x80000000U
#define SRT_NX90_ext_rdy_status_rdy_to_err             31
#define DFLT_VAL_NX90_ext_rdy_status_rdy_to_err        0x00000000U
#define DFLT_BF_VAL_NX90_ext_rdy_status_rdy_to_err     0x00000000U

/* all used bits of 'NX90_ext_rdy_status': */
#define MSK_USED_BITS_NX90_ext_rdy_status 0xb7ffffffU

enum {
  BFW_NX90_ext_rdy_status_rdy_to_err_adr = 27, /* [26:0] */
  BFW_NX90_ext_rdy_status_reserved1      = 1,  /* [27] */
  BFW_NX90_ext_rdy_status_rdy_to_err_cs  = 2,  /* [29:28] */
  BFW_NX90_ext_rdy_status_reserved2      = 1,  /* [30] */
  BFW_NX90_ext_rdy_status_rdy_to_err     = 1   /* [31] */
};

typedef struct NX90_EXT_RDY_STATUS_BIT_Ttag {
  unsigned int rdy_to_err_adr : BFW_NX90_ext_rdy_status_rdy_to_err_adr; /* Ready timeout error address logging.                                                                                        */
  unsigned int reserved1      : BFW_NX90_ext_rdy_status_reserved1;      /* reserved                                                                                                                    */
  unsigned int rdy_to_err_cs  : BFW_NX90_ext_rdy_status_rdy_to_err_cs;  /* Ready timeout error chip-select logging.                                                                                    */
  unsigned int reserved2      : BFW_NX90_ext_rdy_status_reserved2;      /* reserved                                                                                                                    */
  unsigned int rdy_to_err     : BFW_NX90_ext_rdy_status_rdy_to_err;     /* Ready Timeout Error.                                                                                                        */
                                                                        /* This bit is set if a ready timeout error is detected. The external address                                                  */
                                                                        /* and chip-select will be logged then in the lower bits of this register. An IRQ/Abort will be generated if                   */
                                                                        /* enabled by the ext_rdy_cfg register.                                                                                        */
                                                                        /* Writing a '1' here will reset this bit and the IRQ.                                                                         */
                                                                        /* Note: If multiple timeouts are detected, the first timeout address and chip-select will be logged.                          */
                                                                        /* Note: Ready Timeout IRQ is part of netX System Status IRQ (view system_status register in area asic_ctrl and VIC registers) */
} NX90_EXT_RDY_STATUS_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_EXT_RDY_STATUS_BIT_T bf;
} NX90_EXT_RDY_STATUS_T;


/* ===================================================================== */

/* AREA ext_sdram_ctrl */
/* Area of hif_sdram_ctrl */

/* ===================================================================== */

#define Addr_NX90_hif_sdram_ctrl 0xFF401540U

/* --------------------------------------------------------------------- */
/* Register sdram_general_ctrl */
/* => Control Register for external SDRAM access. */
/*    For initializing procedure netX SDRAM controller view description of 'ctrl_en' bit inside this register. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sdram_general_ctrl            0x00000000U
#define Adr_NX90_hif_sdram_ctrl_sdram_general_ctrl 0xFF401540U
#define Adr_NX90_sdram_general_ctrl                0xFF401540U
#define DFLT_VAL_NX90_sdram_general_ctrl           0x01000001U

#define MSK_NX90_sdram_general_ctrl_banks                  0x00000003U
#define SRT_NX90_sdram_general_ctrl_banks                  0
#define DFLT_VAL_NX90_sdram_general_ctrl_banks             0x00000001U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_banks          0x00000001U
#define MSK_NX90_sdram_general_ctrl_rows                   0x00000030U
#define SRT_NX90_sdram_general_ctrl_rows                   4
#define DFLT_VAL_NX90_sdram_general_ctrl_rows              0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_rows           0x00000000U
#define MSK_NX90_sdram_general_ctrl_columns                0x00000700U
#define SRT_NX90_sdram_general_ctrl_columns                8
#define DFLT_VAL_NX90_sdram_general_ctrl_columns           0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_columns        0x00000000U
#define MSK_NX90_sdram_general_ctrl_dbus16                 0x00010000U
#define SRT_NX90_sdram_general_ctrl_dbus16                 16
#define DFLT_VAL_NX90_sdram_general_ctrl_dbus16            0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_dbus16         0x00000000U
#define MSK_NX90_sdram_general_ctrl_sdram_pwdn             0x00020000U
#define SRT_NX90_sdram_general_ctrl_sdram_pwdn             17
#define DFLT_VAL_NX90_sdram_general_ctrl_sdram_pwdn        0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_sdram_pwdn     0x00000000U
#define MSK_NX90_sdram_general_ctrl_extclk_en              0x00040000U
#define SRT_NX90_sdram_general_ctrl_extclk_en              18
#define DFLT_VAL_NX90_sdram_general_ctrl_extclk_en         0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_extclk_en      0x00000000U
#define MSK_NX90_sdram_general_ctrl_ctrl_en                0x00080000U
#define SRT_NX90_sdram_general_ctrl_ctrl_en                19
#define DFLT_VAL_NX90_sdram_general_ctrl_ctrl_en           0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_ctrl_en        0x00000000U
#define MSK_NX90_sdram_general_ctrl_refresh_mode           0x03000000U
#define SRT_NX90_sdram_general_ctrl_refresh_mode           24
#define DFLT_VAL_NX90_sdram_general_ctrl_refresh_mode      0x01000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_refresh_mode   0x00000001U
#define MSK_NX90_sdram_general_ctrl_sdram_ready            0x40000000U
#define SRT_NX90_sdram_general_ctrl_sdram_ready            30
#define DFLT_VAL_NX90_sdram_general_ctrl_sdram_ready       0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_sdram_ready    0x00000000U
#define MSK_NX90_sdram_general_ctrl_refresh_status         0x80000000U
#define SRT_NX90_sdram_general_ctrl_refresh_status         31
#define DFLT_VAL_NX90_sdram_general_ctrl_refresh_status    0x00000000U
#define DFLT_BF_VAL_NX90_sdram_general_ctrl_refresh_status 0x00000000U

/* all used bits of 'NX90_sdram_general_ctrl': */
#define MSK_USED_BITS_NX90_sdram_general_ctrl 0xc30f0733U

enum {
  BFW_NX90_sdram_general_ctrl_banks          = 2, /* [1:0] */
  BFW_NX90_sdram_general_ctrl_reserved1      = 2, /* [3:2] */
  BFW_NX90_sdram_general_ctrl_rows           = 2, /* [5:4] */
  BFW_NX90_sdram_general_ctrl_reserved2      = 2, /* [7:6] */
  BFW_NX90_sdram_general_ctrl_columns        = 3, /* [10:8] */
  BFW_NX90_sdram_general_ctrl_reserved3      = 5, /* [15:11] */
  BFW_NX90_sdram_general_ctrl_dbus16         = 1, /* [16] */
  BFW_NX90_sdram_general_ctrl_sdram_pwdn     = 1, /* [17] */
  BFW_NX90_sdram_general_ctrl_extclk_en      = 1, /* [18] */
  BFW_NX90_sdram_general_ctrl_ctrl_en        = 1, /* [19] */
  BFW_NX90_sdram_general_ctrl_reserved4      = 4, /* [23:20] */
  BFW_NX90_sdram_general_ctrl_refresh_mode   = 2, /* [25:24] */
  BFW_NX90_sdram_general_ctrl_reserved5      = 4, /* [29:26] */
  BFW_NX90_sdram_general_ctrl_sdram_ready    = 1, /* [30] */
  BFW_NX90_sdram_general_ctrl_refresh_status = 1  /* [31] */
};

typedef struct NX90_SDRAM_GENERAL_CTRL_BIT_Ttag {
  unsigned int banks          : BFW_NX90_sdram_general_ctrl_banks;          /* Number of SDRAM device banks and address lines.                                                                   */
                                                                            /*  00 : 2 banks, address (BA0)                                                                                      */
                                                                            /*  01 : 4 banks, address lines (BA1, BA0)(default)                                                                  */
                                                                            /* All others: reserved                                                                                              */
  unsigned int reserved1      : BFW_NX90_sdram_general_ctrl_reserved1;      /* reserved                                                                                                          */
  unsigned int rows           : BFW_NX90_sdram_general_ctrl_rows;           /* Number of SDRAM device rows and address lines.                                                                    */
                                                                            /*   00 : 2k rows, address lines A0..A10 (default)                                                                   */
                                                                            /*   01 : 4k rows, address lines A0..A11                                                                             */
                                                                            /*   10 : 8k rows, address lines A0..A12                                                                             */
  unsigned int reserved2      : BFW_NX90_sdram_general_ctrl_reserved2;      /* reserved                                                                                                          */
  unsigned int columns        : BFW_NX90_sdram_general_ctrl_columns;        /* Number of SDRAM device columns and address lines.                                                                 */
                                                                            /*  000 : 256 columns, address lines A0..A7 (default)                                                                */
                                                                            /*  001 : 512 columns, address lines A0..A8                                                                          */
                                                                            /*  010 : 1k columns, address lines A0..A9                                                                           */
                                                                            /*  011 : 2k columns, address lines A0..A9,A11                                                                       */
                                                                            /*  100 : 4k columns, address lines A0..A9,A11,A12                                                                   */
                                                                            /* All others: reserved                                                                                              */
  unsigned int reserved3      : BFW_NX90_sdram_general_ctrl_reserved3;      /* reserved                                                                                                          */
  unsigned int dbus16         : BFW_NX90_sdram_general_ctrl_dbus16;         /* SDRAM data bus width                                                                                              */
                                                                            /*  0 : SDRAM data bus is 8 bit wide  (default)                                                                      */
                                                                            /*  1 : SDRAM data bus is 16 bit wide                                                                                */
  unsigned int sdram_pwdn     : BFW_NX90_sdram_general_ctrl_sdram_pwdn;     /* SDRAM power down                                                                                                  */
                                                                            /* If this bit is set, the controller will move SDRAM to power down self refresh mode (no data loss)                 */
                                                                            /* and stop the external SDRAM clock. Return from power-down mode can be done by clearing this bit.                  */
  unsigned int extclk_en      : BFW_NX90_sdram_general_ctrl_extclk_en;      /* external SDRAM clock enable                                                                                       */
                                                                            /*  0 : SDRAM clock disabled  (default)                                                                              */
                                                                            /*  1 : SDRAM clock enabled                                                                                          */
                                                                            /* Note:                                                                                                             */
                                                                            /*    The external SDRAM clock will not run if the controller is disabled.                                           */
  unsigned int ctrl_en        : BFW_NX90_sdram_general_ctrl_ctrl_en;        /* Global SDRAM controller enable.                                                                                   */
                                                                            /* Note:                                                                                                             */
                                                                            /*    The sdram_timing_ctrl and the sdram_mr register can only be changed while this bit is 0.                       */
                                                                            /* Initializing and enabling SDRAM should be done as follows:                                                        */
                                                                            /* {  |                                                                                                              */
                                                                            /*  A. Special attention must be done before enabling SDRAM after netX reset without power supply                    */
                                                                            /*     was disabled (e.g. pressing some kind of reset button). In this case a reset could be done                    */
                                                                            /*     while a SDRAM read burst was performed. As SDRAM clock will be disabled immediately in case                   */
                                                                            /*     of reset external SDRAM device will keep driving data-lines. To free data lines at least 10                   */
                                                                            /*     SDRAM clock cycles must be performed. This should be done by enabling (extclk_en-bit set and                  */
                                                                            /*     ctrl_en-bit set) the controller and disabling again (ctrl_en-bit cleared) before really enabling              */
                                                                            /*     SDRAM and before any other access to external memory devices sharing SDRAM data-lines (e.g.                   */
                                                                            /*     parallel flash devices).                                                                                      */
                                                                            /*  B. If SDRAM was already enabled: Disable SDRAM controller by setting the ctrl_en-bit to 0.                       */
                                                                            /*     Ensure that no netX system master is trying to access SDRAM address area. Otherwise related                   */
                                                                            /*     master will be stalled (no ready) until re-enabling SDRAM.                                                    */
                                                                            /*  1. Configure the sdram_timing_ctrl register:                                                                     */
                                                                            /*     All timing parameters of the t_* bit fields must be taken from SDRAM device data sheet.                       */
                                                                            /*     All other timing parameters like clock and sample phases are provided by Hilscher.                            */
                                                                            /*  2. Configure the sdram_mr register:                                                                              */
                                                                            /*     Typically only setting of correct CAS-Latency is required (CL2 or CL3 supported                               */
                                                                            /*     by netX SDRAM controller). CL2 provides better performance an should be preferred.                            */
                                                                            /*     Please read description of the sdram_mr register for further details.                                         */
                                                                            /*  3. Configure the sdram_general_ctrl (this) register and enable the controller by setting the 'ctrl_en' bit.      */
                                                                            /*     The values for 'banks', 'rows' and 'columns' depend on the used SDRAM device and                              */
                                                                            /*     must be taken from the related data sheet.                                                                    */
                                                                            /*  4. Wait until 'sdram_ready' status bit is set before accessing SDRAM device. }                                   */
                                                                            /* ------------------------------------                                                                              */
                                                                            /* After enable, the controller will run the following SDRAM initialisation procedure (100MHz, 1 cycle = 10ns).      */
                                                                            /* {                  |        |                 |                                                                   */
                                                                            /* command             cycles   time              comment                                                            */
                                                                            /* NOP                 20050    200.5us           running sd_clk (if extclk_en), *cs low, cke high)                  */
                                                                            /* PRECH ALL, NOP      1+15     10ns + 150ns                                                                         */
                                                                            /* 7x(AUTO REF, NOP)   7x(1+31) 7x(10ns + 310ns)                                                                     */
                                                                            /* AUTO REF, NOP       1+22     10ns + 220ns                                                                         */
                                                                            /* LOAD MREG, NOP      1+3      10ns + 30ns       with settings done by the sdram_mr registers                       */
                                                                            /* ACTIVATE            1        10ns              first access if requested, sdram_ready will be set to 1 here }     */
                                                                            /* ------------------------------------                                                                              */
                                                                            /* Attention:                                                                                                        */
                                                                            /*    Accesses requested to SDRAM address area when the controller is not enabled                                    */
                                                                            /*    or before SDRAM initialisation procedure was finished (before sdram_ready                                      */
                                                                            /*    bit is 1) will be blocked (no ready). This could cause system freezing.                                        */
                                                                            /* Note:                                                                                                             */
                                                                            /*    The external SDRAM clock will not run if the controller is disabled.                                           */
  unsigned int reserved4      : BFW_NX90_sdram_general_ctrl_reserved4;      /* reserved                                                                                                          */
  unsigned int refresh_mode   : BFW_NX90_sdram_general_ctrl_refresh_mode;   /* Refresh request generation mode.                                                                                  */
                                                                            /* Refresh behaviour changed from netx100/500/50: SDRAM controller now has an additional high priority refresh mode. */
                                                                            /* Refresh generation has lower priority than accesses on external memory interface normally. That means refreshes   */
                                                                            /* do not block data access. To avoid data loss under all conditions without checking critical situations by         */
                                                                            /* software a high priority refresh mode is implemented for netX10 and later: If there was too much traffic          */
                                                                            /* to SDRAM to run refreshes according to programmed refresh_mode the controller changes to high                     */
                                                                            /* priority refresh mode automatically. In this mode the controller generates immediately as many refreshes          */
                                                                            /* as required to avoid imminent data loss. After that the controller falls back to low priority refresh             */
                                                                            /* generation automatically.                                                                                         */
                                                                            /* In normal low priority refresh mode refreshes can be collected. That means single refreshes are not               */
                                                                            /* necessarily done in programmed average refresh interval (t_REFI in sdram_timing_ctrl register). However           */
                                                                            /* the controller ensures by hardware that t_REFI is kept as mean refresh interval for a certain number              */
                                                                            /* of subsequent refreshes. This number of refreshes that will be collected to a long term refresh sequence          */
                                                                            /* can be programmed in this bit field.                                                                              */
                                                                            /* The following refresh request generation mode can be programmed:                                                  */
                                                                            /*  00 : fix interval: expect one refresh any programmed refresh period (sdram_timing_ctrl.t_REFI)                   */
                                                                            /*  01 : collect up to 8 refreshes (default)                                                                         */
                                                                            /*  10 : collect up to 16 refreshes                                                                                  */
                                                                            /*  11 : collect up to 2047 refreshes                                                                                */
                                                                            /* Note:                                                                                                             */
                                                                            /* Typically SDRAM devices do not require a fix refresh interval. Collecting more refreshes will lead                */
                                                                            /* to improved performance (as high priority refresh mode blocking normal access is entered more                     */
                                                                            /* often when only few refreshes can be collected). Hence, it is recommended setting this bit field                  */
                                                                            /* to '11' (collecting up to 2047 refreshes).                                                                        */
                                                                            /* Note:                                                                                                             */
                                                                            /* Entering high priority refresh mode typically occurs when SDRAM becomes system performance                        */
                                                                            /* bottleneck. To detect this, a status bit (refresh_status) will be set when high priority                          */
                                                                            /* refresh mode was entered. It can be used for debugging or system status information purpose.                      */
  unsigned int reserved5      : BFW_NX90_sdram_general_ctrl_reserved5;      /* reserved                                                                                                          */
  unsigned int sdram_ready    : BFW_NX90_sdram_general_ctrl_sdram_ready;    /* SDRAM ready.                                                                                                      */
                                                                            /* This bit is set to 1 if SDRAM is ready for access. If sdram_general_ctrl.ctrl_en == 0 or                          */
                                                                            /* sdram_general_ctrl.sdram_pwdn == 0 sdram_ready will be low. It will be set to 1 after                             */
                                                                            /* SDRAM has been initialized or after power down wake up.                                                           */
                                                                            /* Note: This bit is a read only status flag.                                                                        */
  unsigned int refresh_status : BFW_NX90_sdram_general_ctrl_refresh_status; /* Refresh status flag.                                                                                              */
                                                                            /* Refresh behaviour changed from netx100/500/50: SDRAM controller now has an additional high                        */
                                                                            /* priority refresh mode (view refresh_mode bit description).                                                        */
                                                                            /* There is no need to guarantee sufficient SDRAM refresh generation by checking this bit by                         */
                                                                            /* software any longer (necessary for netx100/500/50 depending on application). It is only for                       */
                                                                            /* information purpose for netX10 or later.                                                                          */
                                                                            /* This bit can be reset by writing '0' to it.                                                                       */
                                                                            /* Note: This bit is writable but can also be changed by hardware.                                                   */
} NX90_SDRAM_GENERAL_CTRL_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_SDRAM_GENERAL_CTRL_BIT_T bf;
} NX90_SDRAM_GENERAL_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register sdram_timing_ctrl */
/* => Control Register for external SDRAM access. */
/*    Changes can only be done, if the SDRAM controller is disabled (sdram_general_ctrl.ctrl_en == 0) */
/*    to avoid configuration problems. */
/*    Please view description of 'ctrl_en' bit inside sdram_general_ctrl register for initializing-procedure of netX SDRAM controller. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/*    Note: For some registers the reset-value is a reserved value. I.e. these registers must be programmed to another value */
/*          than the reset-value at initialization (e.g. t_WR). The values with the remark "(default)" are the values which should */
/*          be applicable for all SDRAM devices. However it is strongly recommended to set the values best-fitting the connected device */
/*          as the default values typically lead to an immense performance penalty (e.g. t_RAS default is 10). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sdram_timing_ctrl            0x00000004U
#define Adr_NX90_hif_sdram_ctrl_sdram_timing_ctrl 0xFF401544U
#define Adr_NX90_sdram_timing_ctrl                0xFF401544U
#define DFLT_VAL_NX90_sdram_timing_ctrl           0x0301f7f3U

#define MSK_NX90_sdram_timing_ctrl_t_RCD                     0x00000003U
#define SRT_NX90_sdram_timing_ctrl_t_RCD                     0
#define DFLT_VAL_NX90_sdram_timing_ctrl_t_RCD                0x00000003U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_t_RCD             0x00000003U
#define MSK_NX90_sdram_timing_ctrl_t_WR                      0x00000030U
#define SRT_NX90_sdram_timing_ctrl_t_WR                      4
#define DFLT_VAL_NX90_sdram_timing_ctrl_t_WR                 0x00000030U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_t_WR              0x00000003U
#define MSK_NX90_sdram_timing_ctrl_t_RP                      0x000000c0U
#define SRT_NX90_sdram_timing_ctrl_t_RP                      6
#define DFLT_VAL_NX90_sdram_timing_ctrl_t_RP                 0x000000c0U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_t_RP              0x00000003U
#define MSK_NX90_sdram_timing_ctrl_t_RAS                     0x00000700U
#define SRT_NX90_sdram_timing_ctrl_t_RAS                     8
#define DFLT_VAL_NX90_sdram_timing_ctrl_t_RAS                0x00000700U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_t_RAS             0x00000007U
#define MSK_NX90_sdram_timing_ctrl_t_RFC                     0x0000f000U
#define SRT_NX90_sdram_timing_ctrl_t_RFC                     12
#define DFLT_VAL_NX90_sdram_timing_ctrl_t_RFC                0x0000f000U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_t_RFC             0x0000000fU
#define MSK_NX90_sdram_timing_ctrl_t_REFI                    0x00030000U
#define SRT_NX90_sdram_timing_ctrl_t_REFI                    16
#define DFLT_VAL_NX90_sdram_timing_ctrl_t_REFI               0x00010000U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_t_REFI            0x00000001U
#define MSK_NX90_sdram_timing_ctrl_mem_sdclk_phase           0x00700000U
#define SRT_NX90_sdram_timing_ctrl_mem_sdclk_phase           20
#define DFLT_VAL_NX90_sdram_timing_ctrl_mem_sdclk_phase      0x00000000U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_mem_sdclk_phase   0x00000000U
#define MSK_NX90_sdram_timing_ctrl_data_sample_phase         0x07000000U
#define SRT_NX90_sdram_timing_ctrl_data_sample_phase         24
#define DFLT_VAL_NX90_sdram_timing_ctrl_data_sample_phase    0x03000000U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_data_sample_phase 0x00000003U
#define MSK_NX90_sdram_timing_ctrl_bypass_neg_delay          0x10000000U
#define SRT_NX90_sdram_timing_ctrl_bypass_neg_delay          28
#define DFLT_VAL_NX90_sdram_timing_ctrl_bypass_neg_delay     0x00000000U
#define DFLT_BF_VAL_NX90_sdram_timing_ctrl_bypass_neg_delay  0x00000000U

/* all used bits of 'NX90_sdram_timing_ctrl': */
#define MSK_USED_BITS_NX90_sdram_timing_ctrl 0x1773f7f3U

enum {
  BFW_NX90_sdram_timing_ctrl_t_RCD             = 2, /* [1:0] */
  BFW_NX90_sdram_timing_ctrl_reserved1         = 2, /* [3:2] */
  BFW_NX90_sdram_timing_ctrl_t_WR              = 2, /* [5:4] */
  BFW_NX90_sdram_timing_ctrl_t_RP              = 2, /* [7:6] */
  BFW_NX90_sdram_timing_ctrl_t_RAS             = 3, /* [10:8] */
  BFW_NX90_sdram_timing_ctrl_reserved2         = 1, /* [11] */
  BFW_NX90_sdram_timing_ctrl_t_RFC             = 4, /* [15:12] */
  BFW_NX90_sdram_timing_ctrl_t_REFI            = 2, /* [17:16] */
  BFW_NX90_sdram_timing_ctrl_reserved3         = 2, /* [19:18] */
  BFW_NX90_sdram_timing_ctrl_mem_sdclk_phase   = 3, /* [22:20] */
  BFW_NX90_sdram_timing_ctrl_reserved4         = 1, /* [23] */
  BFW_NX90_sdram_timing_ctrl_data_sample_phase = 3, /* [26:24] */
  BFW_NX90_sdram_timing_ctrl_reserved5         = 1, /* [27] */
  BFW_NX90_sdram_timing_ctrl_bypass_neg_delay  = 1, /* [28] */
  BFW_NX90_sdram_timing_ctrl_reserved6         = 3  /* [31:29] */
};

typedef struct NX90_SDRAM_TIMING_CTRL_BIT_Ttag {
  unsigned int t_RCD             : BFW_NX90_sdram_timing_ctrl_t_RCD;             /* ACTIVE to READ or WRITE time (RAS to CAS, clk = t_RCD)                                                        */
                                                                                 /* This value will be also taken as t_RRD (ACTIVE bank A to ACTIVE bank B time)                                  */
                                                                                 /*  00 : 1 clk                                                                                                   */
                                                                                 /*  01 : 2 clks                                                                                                  */
                                                                                 /*  10 : 3 clks (default)                                                                                        */
                                                                                 /*  11 : reserved                                                                                                */
  unsigned int reserved1         : BFW_NX90_sdram_timing_ctrl_reserved1;         /* reserved                                                                                                      */
  unsigned int t_WR              : BFW_NX90_sdram_timing_ctrl_t_WR;              /* Write recovery time (last write data to PRECHARGE)                                                            */
                                                                                 /*  00 : 1 clk                                                                                                   */
                                                                                 /*  01 : 2 clks                                                                                                  */
                                                                                 /*  10 : 3 clks (default)                                                                                        */
                                                                                 /*  11 : reserved                                                                                                */
  unsigned int t_RP              : BFW_NX90_sdram_timing_ctrl_t_RP;              /* Precharge command period time (PRECHARGE to next command)                                                     */
                                                                                 /*  00 : 1 clk                                                                                                   */
                                                                                 /*  01 : 2 clks                                                                                                  */
                                                                                 /*  10 : 3 clks (default)                                                                                        */
                                                                                 /*  11 : reserved                                                                                                */
                                                                                 /* Note:                                                                                                         */
                                                                                 /* For Active-to-Active-command-period (t_RC) view note at t_RAS.                                                */
  unsigned int t_RAS             : BFW_NX90_sdram_timing_ctrl_t_RAS;             /* ACTIVE to PRECHARGE command time (clk = t_RAS + 3)                                                            */
                                                                                 /*  000 :  3 clks                                                                                                */
                                                                                 /*  001 :  4 clks                                                                                                */
                                                                                 /*  and so on                                                                                                    */
                                                                                 /*  111 : 10 clks (default)                                                                                      */
                                                                                 /* Note:                                                                                                         */
                                                                                 /* If Active-to-Active-command-period (t_RC) exceeds t_RAS+t_RP, set t_RAS and t_RP                              */
                                                                                 /* in a way that the following condition is met: t_RAS+t_RP>=t_RC.                                               */
  unsigned int reserved2         : BFW_NX90_sdram_timing_ctrl_reserved2;         /* reserved                                                                                                      */
  unsigned int t_RFC             : BFW_NX90_sdram_timing_ctrl_t_RFC;             /* REFRESH to next command time (clk = tRFC + 4)                                                                 */
                                                                                 /*  0000 :  4 clks                                                                                               */
                                                                                 /*  0001 :  5 clks                                                                                               */
                                                                                 /*  and so on                                                                                                    */
                                                                                 /*  1111 :  19 clks (default)                                                                                    */
  unsigned int t_REFI            : BFW_NX90_sdram_timing_ctrl_t_REFI;            /* Average periodic refresh interval (3.90 us * 2^t_REFI                                                         */
                                                                                 /*  00 :   3.90 us                                                                                               */
                                                                                 /*  01 :   7.80 us (default)                                                                                     */
                                                                                 /*  10 :  15.60 us                                                                                               */
                                                                                 /*  11 :  31.20 us                                                                                               */
                                                                                 /* Note:                                                                                                         */
                                                                                 /* Typically refresh of SDRAM devices is specified by a certain number of refreshes that must be                 */
                                                                                 /* performed within a certain time. E.g. 8192 refreshes for 64ms. Dividing the time by the                       */
                                                                                 /* number of refreshes leads to the average periodic refresh interval. E.g. 64ms/8192 = 7.8us.                   */
                                                                                 /* Please view also description of 'refresh_mode' of 'sdram_general_ctrl' register for details.                  */
  unsigned int reserved3         : BFW_NX90_sdram_timing_ctrl_reserved3;         /* reserved                                                                                                      */
  unsigned int mem_sdclk_phase   : BFW_NX90_sdram_timing_ctrl_mem_sdclk_phase;   /* MEM_SDCLK phase shift.                                                                                        */
                                                                                 /* 0..5: adjustable phase-shift for external SDRAM clock depending on external capacitive                        */
                                                                                 /* load on MEM_SDCLK-signal to match SDRAM signals setup times. The phase can be shifted in 1.25ns steps.        */
                                                                                 /* MEM_SDCLK will internally rise at the mem_sdclk_phase+1st clk400 edge after internal changes of               */
                                                                                 /* SDRAM signals (MEM_SD*-signals, MI address and data buses driven by clk_memsig)                               */
                                                                                 /* For correct settings delays depending on external capacitive load have to be respected.                       */
                                                                                 /* Note: The phase shift logic was optimized. Since netX90:                                                      */
                                                                                 /*  - the mem_sdclk_ssneg-bit is obsolete.                                                                       */
                                                                                 /*  - phase shift now can be done by (0..5)*1.25ns + 1.25ns, previousely: (0..5)*1.25ns + 2.5ns                  */
  unsigned int reserved4         : BFW_NX90_sdram_timing_ctrl_reserved4;         /* reserved                                                                                                      */
  unsigned int data_sample_phase : BFW_NX90_sdram_timing_ctrl_data_sample_phase; /* Data sample clock phase shift.                                                                                */
                                                                                 /* 0..5: adjustable phase-shift for data sampling SDRAM loopback clock (clk_sdloopback)                          */
                                                                                 /* depending on external capacitive load and SDRAM access time (t_AC). The phase can be shifted in 1.25ns steps. */
                                                                                 /* clk_sdloopback will internally rise (sample SDRAM read data) at the data_sample_phase+4th clk400 edge         */
                                                                                 /* after rise of external MEM_SDCLK (including external capacitive load).                                        */
                                                                                 /* For correct settings, the delays depending on external capacitive have to be respected.                       */
                                                                                 /* Data sampling has to be done at least 8ns after internal changes of SDRAM ctrl-signals (MEM_SD*-signals,      */
                                                                                 /* driven by clk_memsig).                                                                                        */
  unsigned int reserved5         : BFW_NX90_sdram_timing_ctrl_reserved5;         /* reserved                                                                                                      */
  unsigned int bypass_neg_delay  : BFW_NX90_sdram_timing_ctrl_bypass_neg_delay;  /* Bypass data sample clock phase shift.                                                                         */
                                                                                 /*  0: use phase shifted (negative delayed) SDRAM loopback clock for data sampling.                              */
                                                                                 /*  1: bypass phase shift logic for SDRAM data sampling. Use SDRAM loopback clock for data sampling.             */
                                                                                 /* Bypass must be used for system clock frequencies <= 80MHz (rate_mull_add <= 0xC0).                            */
                                                                                 /* If this bit is programmed with '0' by software but system clock frequency is below                            */
                                                                                 /* 80MHz, it will be changed to '1' to enable bypass automatically. When system                                  */
                                                                                 /* frequency is changed to a rate more than 80MHz, the bit is released to '0' again.                             */
                                                                                 /* This allows entering netX power save mode entry and leave without reconfiguring                               */
                                                                                 /* this bit by software. However take care that no SDRAM access is running                                       */
                                                                                 /* at the moment of system clock frequency change around the 80MHz border.                                       */
                                                                                 /* Note: The bit will always remain '1' if it is programmed high.                                                */
                                                                                 /* Note: This bit is writable but can also be changed by hardware.                                               */
  unsigned int reserved6         : BFW_NX90_sdram_timing_ctrl_reserved6;         /* reserved                                                                                                      */
} NX90_SDRAM_TIMING_CTRL_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_SDRAM_TIMING_CTRL_BIT_T bf;
} NX90_SDRAM_TIMING_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register sdram_mr */
/* => Mode Register for SDRAM device. */
/*    Changes can only be done, if the SDRAM controller is disabled (sdram_general_ctrl.ctrl_en == 0) */
/*    to avoid configuration problems. */
/*    The SDRAM Mode Registers of the used SDRAM device will be set after enabling the SDRAM controller in the 200us */
/*    SDRAM memory initialisation procedure. It is part of the SDRAM device and programmed by the LOAD MODE REGISTER command. */
/*    For details of SDRAM Mode Register view datasheet of used SDRAM device. */
/*    Please view description of 'ctrl_en' bit inside sdram_general_ctrl register for initializing-procedure of netX SDRAM controller. */
/*    Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sdram_mr            0x00000008U
#define Adr_NX90_hif_sdram_ctrl_sdram_mr 0xFF401548U
#define Adr_NX90_sdram_mr                0xFF401548U
#define DFLT_VAL_NX90_sdram_mr           0x00000033U

#define MSK_NX90_sdram_mr_MR         0x00003fffU
#define SRT_NX90_sdram_mr_MR         0
#define DFLT_VAL_NX90_sdram_mr_MR    0x00000033U
#define DFLT_BF_VAL_NX90_sdram_mr_MR 0x00000033U

/* all used bits of 'NX90_sdram_mr': */
#define MSK_USED_BITS_NX90_sdram_mr 0x00003fffU

enum {
  BFW_NX90_sdram_mr_MR        = 14, /* [13:0] */
  BFW_NX90_sdram_mr_reserved1 = 18  /* [31:14] */
};

typedef struct NX90_SDRAM_MR_BIT_Ttag {
  unsigned int MR        : BFW_NX90_sdram_mr_MR;        /* SDRAM Mode Register.                                                                                       */
                                                        /* CAS latency bits are typically located in MR[6:4]. Only CL2 and CL3 are supported, not CL1; default is CL3 */
                                                        /* Burst Length in MR[2:0] is read only here. Burst length                                                    */
                                                        /* depends on data bus width programmed in sdram_general_ctrl.dbus16 register bit                             */
                                                        /* The netX10 controller supports only Burst Length 8 (default) for 8bit SDRAM interface and 4 for            */
                                                        /* 16bit SDRAM interface.                                                                                     */
                                                        /* Note:                                                                                                      */
                                                        /*    SDRAM devices where burst length is not located in Mode Register bits MR[2:0] are not                   */
                                                        /*    supported by netX SDRAM controller. However these devices are not common.                               */
                                                        /* Note: This bit is writable but can also be changed by hardware.                                            */
  unsigned int reserved1 : BFW_NX90_sdram_mr_reserved1; /* reserved                                                                                                   */
} NX90_SDRAM_MR_BIT_T;

typedef union {
  uint32_t            val;
  NX90_SDRAM_MR_BIT_T bf;
} NX90_SDRAM_MR_T;


/* ===================================================================== */

/* AREA extmem_priority_ctrl */
/* Area of hifmem_priority_ctrl */

/* ===================================================================== */

#define Addr_NX90_hifmem_priority_ctrl 0xFF401580U

/* --------------------------------------------------------------------- */
/* Register extmem_prio_timslot_ctrl */
/* =>  Memory interface master timeslot priority control register. */
/*     Note: */
/*     Any master can access in one timeslot ((ts_accessrate_mX*ts_length_mX)/64) + 1 times (i.e. at */
/*     maximum (ts_accessrate_mX)/64 bandwidth on external memory bus, ts_accessrate_mX is programmed */
/*     by extmem_prio_accesstime_ctrl-register). */
/*     Priority control will watch data accesses on external memory data bus (SDRAM and non SDRAM), */
/*     including pauses on non SDRAM-accesses, not including control commands to SDRAM. */
/*     Any master requesting more accesses will be forced to wait for the remaining timeslot. */
/*    -------------------------------------------------------- */
/*     Programmable timeslots are: */
/*        ts_length =  0 :             64 systen clock cycles (i.e  0.64us at 100MHz) */
/*        ts_length =  1 :            128 systen clock cycles (i.e  1.28us at 100MHz) */
/*        ts_length =  2 :            256 systen clock cycles (i.e  2.56us at 100MHz) */
/*        ts_length =  3 :            512 systen clock cycles (i.e  5.12us at 100MHz) */
/*        ts_length =  4 :           1024 systen clock cycles (i.e 10.24us at 100MHz) */
/*        ts_length =  5 :           2048 systen clock cycles (i.e 20.48us at 100MHz) */
/*        ts_length =  6 :           4096 systen clock cycles (i.e 40.96us at 100MHz) */
/*        ts_length =  7 :           8192 systen clock cycles (i.e 81.92us at 100MHz) */
/*    -------------------------------------------------------- */
/*     For netX90 only SDRAM accesses are regarded for timeslot priority, SRAM/FLASH accesses are not. */
/*     Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_extmem_prio_timslot_ctrl                  0x00000000U
#define Adr_NX90_hifmem_priority_ctrl_extmem_prio_timslot_ctrl 0xFF401580U
#define Adr_NX90_extmem_prio_timslot_ctrl                      0xFF401580U
#define DFLT_VAL_NX90_extmem_prio_timslot_ctrl                 0x00077777U

#define MSK_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_d         0x00000007U
#define SRT_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_d         0
#define DFLT_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_d    0x00000007U
#define DFLT_BF_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_d 0x00000007U
#define MSK_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_i         0x00000070U
#define SRT_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_i         4
#define DFLT_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_i    0x00000070U
#define DFLT_BF_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_i 0x00000007U
#define MSK_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_d         0x00000700U
#define SRT_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_d         8
#define DFLT_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_d    0x00000700U
#define DFLT_BF_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_d 0x00000007U
#define MSK_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_i         0x00007000U
#define SRT_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_i         12
#define DFLT_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_i    0x00007000U
#define DFLT_BF_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_i 0x00000007U
#define MSK_NX90_extmem_prio_timslot_ctrl_ts_length_shared_mi         0x00070000U
#define SRT_NX90_extmem_prio_timslot_ctrl_ts_length_shared_mi         16
#define DFLT_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_shared_mi    0x00070000U
#define DFLT_BF_VAL_NX90_extmem_prio_timslot_ctrl_ts_length_shared_mi 0x00000007U

/* all used bits of 'NX90_extmem_prio_timslot_ctrl': */
#define MSK_USED_BITS_NX90_extmem_prio_timslot_ctrl 0x00077777U

enum {
  BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_d = 3,  /* [2:0] */
  BFW_NX90_extmem_prio_timslot_ctrl_reserved1           = 1,  /* [3] */
  BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_i = 3,  /* [6:4] */
  BFW_NX90_extmem_prio_timslot_ctrl_reserved2           = 1,  /* [7] */
  BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_d = 3,  /* [10:8] */
  BFW_NX90_extmem_prio_timslot_ctrl_reserved3           = 1,  /* [11] */
  BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_i = 3,  /* [14:12] */
  BFW_NX90_extmem_prio_timslot_ctrl_reserved4           = 1,  /* [15] */
  BFW_NX90_extmem_prio_timslot_ctrl_ts_length_shared_mi = 3,  /* [18:16] */
  BFW_NX90_extmem_prio_timslot_ctrl_reserved5           = 13  /* [31:19] */
};

typedef struct NX90_EXTMEM_PRIO_TIMSLOT_CTRL_BIT_Ttag {
  unsigned int ts_length_arm_com_d : BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_d; /* 0..7: the timeslot of hifmem-master 0 is on external memory interface 64*2^ts_length_arm_com_d systen clock cycles */
  unsigned int reserved1           : BFW_NX90_extmem_prio_timslot_ctrl_reserved1;           /* reserved                                                                                                           */
  unsigned int ts_length_arm_com_i : BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_com_i; /* 0..7: the timeslot of hifmem-master 1 is on external memory interface 64*2^ts_length_arm_com_i systen clock cycles */
  unsigned int reserved2           : BFW_NX90_extmem_prio_timslot_ctrl_reserved2;           /* reserved                                                                                                           */
  unsigned int ts_length_arm_app_d : BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_d; /* 0..7: the timeslot of hifmem-master 2 is on external memory interface 64*2^ts_length_arm_app_d systen clock cycles */
  unsigned int reserved3           : BFW_NX90_extmem_prio_timslot_ctrl_reserved3;           /* reserved                                                                                                           */
  unsigned int ts_length_arm_app_i : BFW_NX90_extmem_prio_timslot_ctrl_ts_length_arm_app_i; /* 0..7: the timeslot of hifmem-master 3 is on external memory interface 64*2^ts_length_arm_app_i systen clock cycles */
  unsigned int reserved4           : BFW_NX90_extmem_prio_timslot_ctrl_reserved4;           /* reserved                                                                                                           */
  unsigned int ts_length_shared_mi : BFW_NX90_extmem_prio_timslot_ctrl_ts_length_shared_mi; /* 0..7: the timeslot of hifmem-master 4 is on external memory interface 64*2^ts_length_shared_mi systen clock cycles */
  unsigned int reserved5           : BFW_NX90_extmem_prio_timslot_ctrl_reserved5;           /* reserved                                                                                                           */
} NX90_EXTMEM_PRIO_TIMSLOT_CTRL_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_EXTMEM_PRIO_TIMSLOT_CTRL_BIT_T bf;
} NX90_EXTMEM_PRIO_TIMSLOT_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extmem_prio_accesstime_ctrl */
/* =>  Control Register for master channel accesses per timeslot on external meory interface. */
/*     For detailed priority controlling read note at extmem_prio_timslot_ctrl-register description. */
/*    -------------------------------------------------------- */
/*     For netX90 only SDRAM accesses are regarded for timeslot priority, SRAM/FLASH accesses are not. */
/*     Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_extmem_prio_accesstime_ctrl                  0x00000004U
#define Adr_NX90_hifmem_priority_ctrl_extmem_prio_accesstime_ctrl 0xFF401584U
#define Adr_NX90_extmem_prio_accesstime_ctrl                      0xFF401584U
#define DFLT_VAL_NX90_extmem_prio_accesstime_ctrl                 0x3fffffffU

#define MSK_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d         0x0000003fU
#define SRT_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d         0
#define DFLT_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d    0x0000003fU
#define DFLT_BF_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d 0x0000003fU
#define MSK_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i         0x00000fc0U
#define SRT_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i         6
#define DFLT_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i    0x00000fc0U
#define DFLT_BF_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i 0x0000003fU
#define MSK_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d         0x0003f000U
#define SRT_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d         12
#define DFLT_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d    0x0003f000U
#define DFLT_BF_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d 0x0000003fU
#define MSK_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i         0x00fc0000U
#define SRT_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i         18
#define DFLT_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i    0x00fc0000U
#define DFLT_BF_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i 0x0000003fU
#define MSK_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi         0x3f000000U
#define SRT_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi         24
#define DFLT_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi    0x3f000000U
#define DFLT_BF_VAL_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi 0x0000003fU

/* all used bits of 'NX90_extmem_prio_accesstime_ctrl': */
#define MSK_USED_BITS_NX90_extmem_prio_accesstime_ctrl 0x3fffffffU

enum {
  BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d = 6, /* [5:0] */
  BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i = 6, /* [11:6] */
  BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d = 6, /* [17:12] */
  BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i = 6, /* [23:18] */
  BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi = 6, /* [29:24] */
  BFW_NX90_extmem_prio_accesstime_ctrl_reserved1               = 2  /* [31:30] */
};

typedef struct NX90_EXTMEM_PRIO_ACCESSTIME_CTRL_BIT_Ttag {
  unsigned int ts_accessrate_arm_com_d : BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_d; /* 0..63: hifmem-master 0 is alowed to request ((ts_accessrate_arm_com_d*ts_length_arm_com_d)/64) + 1 accesses on external memory */
  unsigned int ts_accessrate_arm_com_i : BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_com_i; /* 0..63: hifmem-master 1 is alowed to request ((ts_accessrate_arm_com_i*ts_length_arm_com_i)/64) + 1 accesses on external memory */
  unsigned int ts_accessrate_arm_app_d : BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_d; /* 0..63: hifmem-master 2 is alowed to request ((ts_accessrate_arm_app_d*ts_length_arm_app_d)/64) + 1 accesses on external memory */
  unsigned int ts_accessrate_arm_app_i : BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_arm_app_i; /* 0..63: hifmem-master 3 is alowed to request ((ts_accessrate_arm_app_i*ts_length_arm_app_i)/64) + 1 accesses on external memory */
  unsigned int ts_accessrate_shared_mi : BFW_NX90_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi; /* 0..63: hifmem-master 4 is alowed to request ((ts_accessrate_shared_mi*ts_length_shared_mi)/64) + 1 accesses on external memory */
  unsigned int reserved1               : BFW_NX90_extmem_prio_accesstime_ctrl_reserved1;               /* reserved                                                                                                                       */
} NX90_EXTMEM_PRIO_ACCESSTIME_CTRL_BIT_T;

typedef union {
  uint32_t                               val;
  NX90_EXTMEM_PRIO_ACCESSTIME_CTRL_BIT_T bf;
} NX90_EXTMEM_PRIO_ACCESSTIME_CTRL_T;


/* ===================================================================== */

/* Area of abort */

/* ===================================================================== */

#define Addr_NX90_abort 0xFF401600U

/* --------------------------------------------------------------------- */
/* Register abort_base */
/* => Start-address of abort generating address area. */
/*    Area size: 16Bytes */
/*    Abort (AHB: HRESP=ERROR) will be generated by access to this area. */
/*    Write access will be ignored. */
/*    Read access returns 0xdeadbeef. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_abort_base   0x00000000U
#define Adr_NX90_abort_abort_base 0xFF401600U
#define Adr_NX90_abort_base       0xFF401600U

/* --------------------------------------------------------------------- */
/* Register abort_end */
/* => End-address of abort generating address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_abort_end   0x0000000CU
#define Adr_NX90_abort_abort_end 0xFF40160CU
#define Adr_NX90_abort_end       0xFF40160CU


/* ===================================================================== */

/* Area of sqi */

/* ===================================================================== */

#define Addr_NX90_sqi 0xFF401640U

/* --------------------------------------------------------------------- */
/* Register sqi_cr0 */
/* => SQI control register 0 */
/*    This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module \ */
/*    provides master function only. Slave settings are omitted. The SQI module does not support the compatible mode for netX100. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_cr0  0x00000000U
#define Adr_NX90_sqi_sqi_cr0  0xFF401640U
#define Adr_NX90_sqi_cr0      0xFF401640U
#define DFLT_VAL_NX90_sqi_cr0 0x00080007U

#define MSK_NX90_sqi_cr0_datasize           0x0000000fU
#define SRT_NX90_sqi_cr0_datasize           0
#define DFLT_VAL_NX90_sqi_cr0_datasize      0x00000007U
#define DFLT_BF_VAL_NX90_sqi_cr0_datasize   0x00000007U
#define MSK_NX90_sqi_cr0_sck_pol            0x00000040U
#define SRT_NX90_sqi_cr0_sck_pol            6
#define DFLT_VAL_NX90_sqi_cr0_sck_pol       0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr0_sck_pol    0x00000000U
#define MSK_NX90_sqi_cr0_sck_phase          0x00000080U
#define SRT_NX90_sqi_cr0_sck_phase          7
#define DFLT_VAL_NX90_sqi_cr0_sck_phase     0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr0_sck_phase  0x00000000U
#define MSK_NX90_sqi_cr0_sck_muladd         0x000fff00U
#define SRT_NX90_sqi_cr0_sck_muladd         8
#define DFLT_VAL_NX90_sqi_cr0_sck_muladd    0x00080000U
#define DFLT_BF_VAL_NX90_sqi_cr0_sck_muladd 0x00000800U
#define MSK_NX90_sqi_cr0_sio_cfg            0x00c00000U
#define SRT_NX90_sqi_cr0_sio_cfg            22
#define DFLT_VAL_NX90_sqi_cr0_sio_cfg       0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr0_sio_cfg    0x00000000U
#define MSK_NX90_sqi_cr0_filter_in          0x08000000U
#define SRT_NX90_sqi_cr0_filter_in          27
#define DFLT_VAL_NX90_sqi_cr0_filter_in     0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr0_filter_in  0x00000000U

/* all used bits of 'NX90_sqi_cr0': */
#define MSK_USED_BITS_NX90_sqi_cr0 0x08cfffcfU

enum {
  BFW_NX90_sqi_cr0_datasize   = 4,  /* [3:0] */
  BFW_NX90_sqi_cr0_reserved1  = 2,  /* [5:4] */
  BFW_NX90_sqi_cr0_sck_pol    = 1,  /* [6] */
  BFW_NX90_sqi_cr0_sck_phase  = 1,  /* [7] */
  BFW_NX90_sqi_cr0_sck_muladd = 12, /* [19:8] */
  BFW_NX90_sqi_cr0_reserved2  = 2,  /* [21:20] */
  BFW_NX90_sqi_cr0_sio_cfg    = 2,  /* [23:22] */
  BFW_NX90_sqi_cr0_reserved3  = 3,  /* [26:24] */
  BFW_NX90_sqi_cr0_filter_in  = 1,  /* [27] */
  BFW_NX90_sqi_cr0_reserved4  = 4   /* [31:28] */
};

typedef struct NX90_SQI_CR0_BIT_Ttag {
  unsigned int datasize   : BFW_NX90_sqi_cr0_datasize;   /* Data size select for standard Motorola SPI mode                                                      */
                                                         /* This bit field is unused in 2-bit and 4-bit SPI modes (i.e. data size fixed to 8 bit).               */
                                                         /* The actual transfer size is 'datasize' + 1 bit.                                                      */
                                                         /* {            |                                                                                       */
                                                         /* 0000...0010: reserved                                                                                */
                                                         /* 0011:        4 bit                                                                                   */
                                                         /* 0100:        5 bit                                                                                   */
                                                         /* ...                                                                                                  */
                                                         /* 0111:        8 bit                                                                                   */
                                                         /* ...                                                                                                  */
                                                         /* 1111:        16 bit }                                                                                */
  unsigned int reserved1  : BFW_NX90_sqi_cr0_reserved1;  /* reserved                                                                                             */
  unsigned int sck_pol    : BFW_NX90_sqi_cr0_sck_pol;    /* Serial clock polarity                                                                                */
                                                         /* 0: idle: clock is low, first edge is rising                                                          */
                                                         /* 1: idle: clock is high, first edge is falling                                                        */
                                                         /* Note: sck_pol value equals bit 1 of SPI mode value (mode = (sck_pol, sck_phase)).                    */
  unsigned int sck_phase  : BFW_NX90_sqi_cr0_sck_phase;  /* Serial clock phase                                                                                   */
                                                         /* 1: Sample data at second clock edge, data is generated half a clock phase before sampling            */
                                                         /* 0: Sample data at first clock edge, data is generated half a clock phase before sampling             */
                                                         /* Note: sck_phase value equals bit 0 of SPI mode value (mode = (sck_pol, sck_phase)).                  */
  unsigned int sck_muladd : BFW_NX90_sqi_cr0_sck_muladd; /* Serial clock rate multiply add value for sck generation                                              */
                                                         /* sck-frequency: f_sck = (sck_muladd * 100)/4096 [MHz].                                                */
                                                         /* Programmed value of sck_muladd must be <= 0x800.                                                     */
                                                         /* Default value 0x800 equals 50 MHz clock rate.                                                        */
                                                         /* Note: If sck_muladd is set to zero, transfer will freeze.                                            */
                                                         /* Note: SQIROM (XiP) serial clock rate must be programmed in register 'sqi_sqirom_cfg'.                */
  unsigned int reserved2  : BFW_NX90_sqi_cr0_reserved2;  /* reserved                                                                                             */
  unsigned int sio_cfg    : BFW_NX90_sqi_cr0_sio_cfg;    /* SQI IO configuration                                                                                 */
                                                         /* Default: All additional SQI-IOs (SIO2+3) are in PIO input mode.                                      */
                                                         /* Coding                                                                                               */
                                                         /* 00: only SIO2+3 are controllable as PIOs (2-bit SPI or standard Motorola SPI)                        */
                                                         /* 01: all SQI IOs are used for transfers (4-bit SPI/SQI)                                               */
                                                         /* 10: reserved                                                                                         */
                                                         /* 11: all SQI IOs are controllable as PIOs                                                             */
  unsigned int reserved3  : BFW_NX90_sqi_cr0_reserved3;  /* reserved                                                                                             */
  unsigned int filter_in  : BFW_NX90_sqi_cr0_filter_in;  /* Input filtering                                                                                      */
                                                         /* Receive data is sampled every 10 ns (100 MHz system clock). If this bit is set, the                  */
                                                         /* stored receive value will be the result of a majority decision of the three sampling points          */
                                                         /* around an sck clock edge (if two or more '1's have been sampled, a '1' will be stored. If this bit   */
                                                         /* is not set, a '0' will be stored).                                                                   */
                                                         /* Input filtering should be used for sck_muladd<=0x200 (i.e. below 12.5 MHz). For higher frequencies,  */
                                                         /* stable signal phases are too short for filtering.                                                    */
  unsigned int reserved4  : BFW_NX90_sqi_cr0_reserved4;  /* reserved                                                                                             */
} NX90_SQI_CR0_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SQI_CR0_BIT_T bf;
} NX90_SQI_CR0_T;

/* --------------------------------------------------------------------- */
/* Register sqi_cr1 */
/* => SQI control register 1 */
/*    This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module \ */
/*    provides master function only. Slave settings are omitted. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_cr1  0x00000004U
#define Adr_NX90_sqi_sqi_cr1  0xFF401644U
#define Adr_NX90_sqi_cr1      0xFF401644U
#define DFLT_VAL_NX90_sqi_cr1 0x08080000U

#define MSK_NX90_sqi_cr1_sqi_en                 0x00000002U
#define SRT_NX90_sqi_cr1_sqi_en                 1
#define DFLT_VAL_NX90_sqi_cr1_sqi_en            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr1_sqi_en         0x00000000U
#define MSK_NX90_sqi_cr1_fss                    0x00000700U
#define SRT_NX90_sqi_cr1_fss                    8
#define DFLT_VAL_NX90_sqi_cr1_fss               0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr1_fss            0x00000000U
#define MSK_NX90_sqi_cr1_fss_static             0x00000800U
#define SRT_NX90_sqi_cr1_fss_static             11
#define DFLT_VAL_NX90_sqi_cr1_fss_static        0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr1_fss_static     0x00000000U
#define MSK_NX90_sqi_cr1_spi_trans_ctrl         0x00001000U
#define SRT_NX90_sqi_cr1_spi_trans_ctrl         12
#define DFLT_VAL_NX90_sqi_cr1_spi_trans_ctrl    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr1_spi_trans_ctrl 0x00000000U
#define MSK_NX90_sqi_cr1_tx_fifo_wm             0x000f0000U
#define SRT_NX90_sqi_cr1_tx_fifo_wm             16
#define DFLT_VAL_NX90_sqi_cr1_tx_fifo_wm        0x00080000U
#define DFLT_BF_VAL_NX90_sqi_cr1_tx_fifo_wm     0x00000008U
#define MSK_NX90_sqi_cr1_tx_fifo_clr            0x00100000U
#define SRT_NX90_sqi_cr1_tx_fifo_clr            20
#define DFLT_VAL_NX90_sqi_cr1_tx_fifo_clr       0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr1_tx_fifo_clr    0x00000000U
#define MSK_NX90_sqi_cr1_rx_fifo_wm             0x0f000000U
#define SRT_NX90_sqi_cr1_rx_fifo_wm             24
#define DFLT_VAL_NX90_sqi_cr1_rx_fifo_wm        0x08000000U
#define DFLT_BF_VAL_NX90_sqi_cr1_rx_fifo_wm     0x00000008U
#define MSK_NX90_sqi_cr1_rx_fifo_clr            0x10000000U
#define SRT_NX90_sqi_cr1_rx_fifo_clr            28
#define DFLT_VAL_NX90_sqi_cr1_rx_fifo_clr       0x00000000U
#define DFLT_BF_VAL_NX90_sqi_cr1_rx_fifo_clr    0x00000000U

/* all used bits of 'NX90_sqi_cr1': */
#define MSK_USED_BITS_NX90_sqi_cr1 0x1f1f1f02U

enum {
  BFW_NX90_sqi_cr1_reserved1      = 1, /* [0] */
  BFW_NX90_sqi_cr1_sqi_en         = 1, /* [1] */
  BFW_NX90_sqi_cr1_reserved2      = 6, /* [7:2] */
  BFW_NX90_sqi_cr1_fss            = 3, /* [10:8] */
  BFW_NX90_sqi_cr1_fss_static     = 1, /* [11] */
  BFW_NX90_sqi_cr1_spi_trans_ctrl = 1, /* [12] */
  BFW_NX90_sqi_cr1_reserved3      = 3, /* [15:13] */
  BFW_NX90_sqi_cr1_tx_fifo_wm     = 4, /* [19:16] */
  BFW_NX90_sqi_cr1_tx_fifo_clr    = 1, /* [20] */
  BFW_NX90_sqi_cr1_reserved4      = 3, /* [23:21] */
  BFW_NX90_sqi_cr1_rx_fifo_wm     = 4, /* [27:24] */
  BFW_NX90_sqi_cr1_rx_fifo_clr    = 1, /* [28] */
  BFW_NX90_sqi_cr1_reserved5      = 3  /* [31:29] */
};

typedef struct NX90_SQI_CR1_BIT_Ttag {
  unsigned int reserved1      : BFW_NX90_sqi_cr1_reserved1;      /* reserved                                                                                                                */
  unsigned int sqi_en         : BFW_NX90_sqi_cr1_sqi_en;         /* SQI enable                                                                                                              */
                                                                 /* 0: Interface disabled                                                                                                   */
                                                                 /* 1: Interface enabled                                                                                                    */
                                                                 /* Note: If you select the SQIROM/XiP function by bit 'enable' of register 'sqi_sqirom_cfg' (see description               */
                                                                 /* of register 'sqi_sqirom_cfg'), the standard SQI/SPI function will not be available.                                     */
  unsigned int reserved2      : BFW_NX90_sqi_cr1_reserved2;      /* reserved                                                                                                                */
  unsigned int fss            : BFW_NX90_sqi_cr1_fss;            /* Frame slave select                                                                                                      */
                                                                 /* Up to 3 devices can be assigned directly. Up to 8 devices can be assigned if an external de-multiplexer is used.        */
                                                                 /* This signal is active low, i.e. the bits will be inverted before they are output to the SQI pins.                       */
  unsigned int fss_static     : BFW_NX90_sqi_cr1_fss_static;     /* SQI static chip select                                                                                                  */
                                                                 /* 0: Chip select will be generated automatically at data frame begin/end according to fss and datasize.                   */
                                                                 /* 1: Chip select will be set statically according to 'fss' bits (see below).                                              */
                                                                 /* If fss is set to static mode, fss must be toggled manually after each data frame in Motorola SPI mode when              */
                                                                 /* sck_phase is 0 for compatibility with the specification!                                                                */
                                                                 /* Note: This bit is used only in standard Motorola SPI mode. For SQI modes, chip select is never generated automatically. */
  unsigned int spi_trans_ctrl : BFW_NX90_sqi_cr1_spi_trans_ctrl; /* Transfer control for standard Motorola SPI (default: disabled)                                                          */
                                                                 /* This bit is used only for standard Motorola SPI (bits 'mode' of register 'sqi_tcr')                                     */
                                                                 /* in full-duplex and half-duplex mode.                                                                                    */
                                                                 /* If this bit is set, SPI transfers will be controlled by 'start_transfer' and 'transfer_size'                            */
                                                                 /* of register 'sqi_tcr'.                                                                                                  */
                                                                 /* If this bit is not set (default), SPI transfers start immediately after transfer data has been written to               */
                                                                 /* TX FIFO (this is compatible with the SPI module). Settings of 'start_transfer' and 'transfer_size'                      */
                                                                 /* of register 'sqi_tcr' then remain unaffected and will be ignored.                                                       */
                                                                 /* If this bit is set and SPI is used in receive mode (full-duplex or half-duplex receive                                  */
                                                                 /* mode set by bit field 'duplex' in register 'sqi_tcr'), transfers will stop when the                                     */
                                                                 /* receive FIFO runs full. Transfers will continue after the receive data is read from the                                 */
                                                                 /* receive FIFO to avoid an overflow of the receive FIFO.                                                                  */
  unsigned int reserved3      : BFW_NX90_sqi_cr1_reserved3;      /* reserved                                                                                                                */
  unsigned int tx_fifo_wm     : BFW_NX90_sqi_cr1_tx_fifo_wm;     /* Transmit FIFO watermark for IRQ generation                                                                              */
  unsigned int tx_fifo_clr    : BFW_NX90_sqi_cr1_tx_fifo_clr;    /* Transmit FIFO clear                                                                                                     */
                                                                 /* Writing "1" to this bit will clear the transmit FIFO. The hardware will automatically reset this bit.                   */
                                                                 /* This bit is always '0' when read.                                                                                       */
  unsigned int reserved4      : BFW_NX90_sqi_cr1_reserved4;      /* reserved                                                                                                                */
  unsigned int rx_fifo_wm     : BFW_NX90_sqi_cr1_rx_fifo_wm;     /* Receive FIFO watermark for IRQ generation                                                                               */
                                                                 /* If the receive FIFO watermark IRQ is enabled (bit 'RXIM' is set in register 'sqi_irq_mask'),                            */
                                                                 /* transfers will stop when the receive FIFO runs full. Transfers will continue after the                                  */
                                                                 /* receive data is read from the receive FIFO to avoid an overflow of the receive FIFO.                                    */
                                                                 /* If the receive FIFO watermark IRQ is disabled (bit 'RXIM' is not set in register 'sqi_irq_mask'),                       */
                                                                 /* transfers will not stop when the receive FIFO runs full. This may cause an overflow of the                              */
                                                                 /* receive FIFO. This is compatible with netX50 behavior and allows writing data in                                        */
                                                                 /* full-duplex mode without reading the receive FIFO.                                                                      */
  unsigned int rx_fifo_clr    : BFW_NX90_sqi_cr1_rx_fifo_clr;    /* Receive FIFO clear                                                                                                      */
                                                                 /* Writing "1" to this bit will clear the receive FIFO. The hardware will automatically reset this bit.                    */
                                                                 /* This bit is always '0' when read.                                                                                       */
  unsigned int reserved5      : BFW_NX90_sqi_cr1_reserved5;      /* reserved                                                                                                                */
} NX90_SQI_CR1_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SQI_CR1_BIT_T bf;
} NX90_SQI_CR1_T;

/* --------------------------------------------------------------------- */
/* Register sqi_dr */
/* => SQI data register (DR) */
/*    Read access: Received data word is delivered from receive FIFO. */
/*    Write access: Data word to be sent is written to send FIFO. */
/*    Receive and transmit FIFO both have a depth of 16 words (standard SPI mode). The SQI mode combines both FIFOs, i.e. 64 bytes are \ */
/*    available. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_dr  0x00000008U
#define Adr_NX90_sqi_sqi_dr  0xFF401648U
#define Adr_NX90_sqi_dr      0xFF401648U
#define DFLT_VAL_NX90_sqi_dr 0x00000000U

#define MSK_NX90_sqi_dr_data         0xffffffffU
#define SRT_NX90_sqi_dr_data         0
#define DFLT_VAL_NX90_sqi_dr_data    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_dr_data 0x00000000U

/* all used bits of 'NX90_sqi_dr': */
#define MSK_USED_BITS_NX90_sqi_dr 0xffffffffU

enum {
  BFW_NX90_sqi_dr_data = 32  /* [31:0] */
};

typedef struct NX90_SQI_DR_BIT_Ttag {
  unsigned int data : BFW_NX90_sqi_dr_data; /* Transmit data                                                                                                                  */
                                            /* The data must be right-aligned during writing.                                                                                 */
                                            /* In Standard SPI mode only bits according to sqi_cr0.datasize are transferred.                                                  */
                                            /* In SQI mode data must be written in full DWords (i.e. the software has to collect four bytes prior to writing).                */
                                            /* Unused bytes will not be transferred and may be padded at will (number of transferred bytes depends on sqi_tcr.transfer_size). */
                                            /* Receive data will always be right-aligned; unused bits will be "0".                                                            */
} NX90_SQI_DR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_SQI_DR_BIT_T bf;
} NX90_SQI_DR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_sr */
/* => Read-only SQI status register */
/*    Shows the current status of the SQI interface. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_sr 0x0000000CU
#define Adr_NX90_sqi_sqi_sr 0xFF40164CU
#define Adr_NX90_sqi_sr     0xFF40164CU

#define MSK_NX90_sqi_sr_tx_fifo_empty       0x00000001U
#define SRT_NX90_sqi_sr_tx_fifo_empty       0
#define MSK_NX90_sqi_sr_tx_fifo_not_full    0x00000002U
#define SRT_NX90_sqi_sr_tx_fifo_not_full    1
#define MSK_NX90_sqi_sr_rx_fifo_not_empty   0x00000004U
#define SRT_NX90_sqi_sr_rx_fifo_not_empty   2
#define MSK_NX90_sqi_sr_rx_fifo_full        0x00000008U
#define SRT_NX90_sqi_sr_rx_fifo_full        3
#define MSK_NX90_sqi_sr_busy                0x00000010U
#define SRT_NX90_sqi_sr_busy                4
#define MSK_NX90_sqi_sr_sqirom_timeout_err  0x00002000U
#define SRT_NX90_sqi_sr_sqirom_timeout_err  13
#define MSK_NX90_sqi_sr_sqirom_write_err    0x00004000U
#define SRT_NX90_sqi_sr_sqirom_write_err    14
#define MSK_NX90_sqi_sr_sqirom_disabled_err 0x00008000U
#define SRT_NX90_sqi_sr_sqirom_disabled_err 15
#define MSK_NX90_sqi_sr_tx_fifo_level       0x001f0000U
#define SRT_NX90_sqi_sr_tx_fifo_level       16
#define MSK_NX90_sqi_sr_tx_fifo_err_ovfl    0x00400000U
#define SRT_NX90_sqi_sr_tx_fifo_err_ovfl    22
#define MSK_NX90_sqi_sr_tx_fifo_err_undr    0x00800000U
#define SRT_NX90_sqi_sr_tx_fifo_err_undr    23
#define MSK_NX90_sqi_sr_rx_fifo_level       0x1f000000U
#define SRT_NX90_sqi_sr_rx_fifo_level       24
#define MSK_NX90_sqi_sr_rx_fifo_err_ovfl    0x40000000U
#define SRT_NX90_sqi_sr_rx_fifo_err_ovfl    30
#define MSK_NX90_sqi_sr_rx_fifo_err_undr    0x80000000U
#define SRT_NX90_sqi_sr_rx_fifo_err_undr    31

/* all used bits of 'NX90_sqi_sr': */
#define MSK_USED_BITS_NX90_sqi_sr 0xdfdfe01fU

enum {
  BFW_NX90_sqi_sr_tx_fifo_empty       = 1, /* [0] */
  BFW_NX90_sqi_sr_tx_fifo_not_full    = 1, /* [1] */
  BFW_NX90_sqi_sr_rx_fifo_not_empty   = 1, /* [2] */
  BFW_NX90_sqi_sr_rx_fifo_full        = 1, /* [3] */
  BFW_NX90_sqi_sr_busy                = 1, /* [4] */
  BFW_NX90_sqi_sr_reserved1           = 8, /* [12:5] */
  BFW_NX90_sqi_sr_sqirom_timeout_err  = 1, /* [13] */
  BFW_NX90_sqi_sr_sqirom_write_err    = 1, /* [14] */
  BFW_NX90_sqi_sr_sqirom_disabled_err = 1, /* [15] */
  BFW_NX90_sqi_sr_tx_fifo_level       = 5, /* [20:16] */
  BFW_NX90_sqi_sr_reserved2           = 1, /* [21] */
  BFW_NX90_sqi_sr_tx_fifo_err_ovfl    = 1, /* [22] */
  BFW_NX90_sqi_sr_tx_fifo_err_undr    = 1, /* [23] */
  BFW_NX90_sqi_sr_rx_fifo_level       = 5, /* [28:24] */
  BFW_NX90_sqi_sr_reserved3           = 1, /* [29] */
  BFW_NX90_sqi_sr_rx_fifo_err_ovfl    = 1, /* [30] */
  BFW_NX90_sqi_sr_rx_fifo_err_undr    = 1  /* [31] */
};

typedef struct NX90_SQI_SR_BIT_Ttag {
  unsigned int tx_fifo_empty       : BFW_NX90_sqi_sr_tx_fifo_empty;       /* Transmit FIFO is empty (1 if empty).                                                   */
  unsigned int tx_fifo_not_full    : BFW_NX90_sqi_sr_tx_fifo_not_full;    /* Transmit FIFO is not full (0 if full).                                                 */
  unsigned int rx_fifo_not_empty   : BFW_NX90_sqi_sr_rx_fifo_not_empty;   /* Receive FIFO is not empty (0 if empty).                                                */
  unsigned int rx_fifo_full        : BFW_NX90_sqi_sr_rx_fifo_full;        /* Receive FIFO is full (1 if full).                                                      */
  unsigned int busy                : BFW_NX90_sqi_sr_busy;                /* Device is busy                                                                         */
                                                                          /* 1 if data is currently transmitted/received or the transmit FIFO is not empty.         */
  unsigned int reserved1           : BFW_NX90_sqi_sr_reserved1;           /* reserved                                                                               */
  unsigned int sqirom_timeout_err  : BFW_NX90_sqi_sr_sqirom_timeout_err;  /* Timeout during a read of the SQIROM area has occurred.                                 */
                                                                          /* A timeout results from a fix level of the netX serial clock IO. Check IO               */
                                                                          /* multiplexing configuration and make sure that the serial clock output is not           */
                                                                          /* externally clamped.                                                                    */
                                                                          /* This bit can be used to determine why the IRQ 'sqirom_error' has occurred.             */
                                                                          /* Clearing this status flag is possible only by writing a '1' here.                      */
                                                                          /* The SQIROM function must be disabled and enabled again to reset module-internal state  */
                                                                          /* machines after this bit has been set (register 'sqirom_cfg', therefore reset and set   */
                                                                          /* again the 'enable' bit).                                                               */
  unsigned int sqirom_write_err    : BFW_NX90_sqi_sr_sqirom_write_err;    /* Write access to the read-only SQIROM area has occurred.                                */
                                                                          /* This bit can be used to determine why the IRQ 'sqirom_error' has occurred.             */
                                                                          /* Clearing this status flag is possible only by writing a '1' here.                      */
  unsigned int sqirom_disabled_err : BFW_NX90_sqi_sr_sqirom_disabled_err; /* Access to the disabled SQIROM area has occurred.                                       */
                                                                          /* To enable the SQIROM function, set bit 'enable' in register 'sqi_sqirom_cfg'.          */
                                                                          /* This bit can be used to determine why the IRQ 'sqirom_error' has occurred.             */
                                                                          /* Clearing this status flag is possible only by writing a '1' here.                      */
  unsigned int tx_fifo_level       : BFW_NX90_sqi_sr_tx_fifo_level;       /* Transmit FIFO level (number of words to be transmitted are left in the FIFO).          */
  unsigned int reserved2           : BFW_NX90_sqi_sr_reserved2;           /* reserved                                                                               */
  unsigned int tx_fifo_err_ovfl    : BFW_NX90_sqi_sr_tx_fifo_err_ovfl;    /* Transmit FIFO overflow error occurred, data is lost.                                   */
                                                                          /* To clear this status flag, clear TX FIFO (register 'sqi_cr1').                         */
  unsigned int tx_fifo_err_undr    : BFW_NX90_sqi_sr_tx_fifo_err_undr;    /* Transmit FIFO underrun error has occurred, unexpected data has been sent.              */
                                                                          /* To clear this status flag, clear TX FIFO (register 'sqi_cr1').                         */
  unsigned int rx_fifo_level       : BFW_NX90_sqi_sr_rx_fifo_level;       /* Receive FIFO level (number of received words to be read from the FIFO).                */
  unsigned int reserved3           : BFW_NX90_sqi_sr_reserved3;           /* reserved                                                                               */
  unsigned int rx_fifo_err_ovfl    : BFW_NX90_sqi_sr_rx_fifo_err_ovfl;    /* Receive FIFO overflow error occurred, data is lost.                                    */
                                                                          /* To clear this status flag, clear RX FIFO (register 'sqi_cr1').                         */
  unsigned int rx_fifo_err_undr    : BFW_NX90_sqi_sr_rx_fifo_err_undr;    /* Receive FIFO underrun error has occurred, unexpected data has been read.               */
                                                                          /* To clear this status flag, clear RX FIFO (register 'sqi_cr1').                         */
} NX90_SQI_SR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_SQI_SR_BIT_T bf;
} NX90_SQI_SR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_tcr */
/* => SQI transfer control */
/*    This register must not be changed during a transfer (bit 'busy' of register 'sqi_sr' is '1') to avoid corrupted transfers causing \ */
/*    damage to the hardware. */
/*    Module address offset 0x10 is reserved in the netX10/50 SPI module. Thus, no compatibility problems will result from using this \ */
/*    address for extended transfer control features. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_tcr  0x00000010U
#define Adr_NX90_sqi_sqi_tcr  0xFF401650U
#define Adr_NX90_sqi_tcr      0xFF401650U
#define DFLT_VAL_NX90_sqi_tcr 0x1c000000U

#define MSK_NX90_sqi_tcr_transfer_size          0x0007ffffU
#define SRT_NX90_sqi_tcr_transfer_size          0
#define DFLT_VAL_NX90_sqi_tcr_transfer_size     0x00000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_transfer_size  0x00000000U
#define MSK_NX90_sqi_tcr_tx_out                 0x00200000U
#define SRT_NX90_sqi_tcr_tx_out                 21
#define DFLT_VAL_NX90_sqi_tcr_tx_out            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_tx_out         0x00000000U
#define MSK_NX90_sqi_tcr_tx_oe                  0x00400000U
#define SRT_NX90_sqi_tcr_tx_oe                  22
#define DFLT_VAL_NX90_sqi_tcr_tx_oe             0x00000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_tx_oe          0x00000000U
#define MSK_NX90_sqi_tcr_start_transfer         0x00800000U
#define SRT_NX90_sqi_tcr_start_transfer         23
#define DFLT_VAL_NX90_sqi_tcr_start_transfer    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_start_transfer 0x00000000U
#define MSK_NX90_sqi_tcr_mode                   0x03000000U
#define SRT_NX90_sqi_tcr_mode                   24
#define DFLT_VAL_NX90_sqi_tcr_mode              0x00000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_mode           0x00000000U
#define MSK_NX90_sqi_tcr_duplex                 0x0c000000U
#define SRT_NX90_sqi_tcr_duplex                 26
#define DFLT_VAL_NX90_sqi_tcr_duplex            0x0c000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_duplex         0x00000003U
#define MSK_NX90_sqi_tcr_ms_bit_first           0x10000000U
#define SRT_NX90_sqi_tcr_ms_bit_first           28
#define DFLT_VAL_NX90_sqi_tcr_ms_bit_first      0x10000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_ms_bit_first   0x00000001U
#define MSK_NX90_sqi_tcr_ms_byte_first          0x20000000U
#define SRT_NX90_sqi_tcr_ms_byte_first          29
#define DFLT_VAL_NX90_sqi_tcr_ms_byte_first     0x00000000U
#define DFLT_BF_VAL_NX90_sqi_tcr_ms_byte_first  0x00000000U

/* all used bits of 'NX90_sqi_tcr': */
#define MSK_USED_BITS_NX90_sqi_tcr 0x3fe7ffffU

enum {
  BFW_NX90_sqi_tcr_transfer_size  = 19, /* [18:0] */
  BFW_NX90_sqi_tcr_reserved1      = 2,  /* [20:19] */
  BFW_NX90_sqi_tcr_tx_out         = 1,  /* [21] */
  BFW_NX90_sqi_tcr_tx_oe          = 1,  /* [22] */
  BFW_NX90_sqi_tcr_start_transfer = 1,  /* [23] */
  BFW_NX90_sqi_tcr_mode           = 2,  /* [25:24] */
  BFW_NX90_sqi_tcr_duplex         = 2,  /* [27:26] */
  BFW_NX90_sqi_tcr_ms_bit_first   = 1,  /* [28] */
  BFW_NX90_sqi_tcr_ms_byte_first  = 1,  /* [29] */
  BFW_NX90_sqi_tcr_reserved2      = 2   /* [31:30] */
};

typedef struct NX90_SQI_TCR_BIT_Ttag {
  unsigned int transfer_size  : BFW_NX90_sqi_tcr_transfer_size;  /* Number of bytes within the current SQI transaction                                                         */
                                                                 /* Program (number of bytes - 1) or (number of dummy clock cycles - 1).                                       */
                                                                 /* Example:                                                                                                   */
                                                                 /* {        |                                                                                                 */
                                                                 /*  0x00000: one byte/dummy cycle                                                                             */
                                                                 /*  ...                                                                                                       */
                                                                 /*  0x7ffff: 512k bytes/dummy cycles }                                                                        */
                                                                 /* This bit field counts down during transfers with each transferred word/byte or dummy cycle. This           */
                                                                 /* bit field is writable only after a transfer sequence is finished or if it has been terminated              */
                                                                 /* by a FIFO clear. Hence, this bit is writable, but it can also be changed by hardware.                      */
                                                                 /* A running transfer sequence can be terminated by clearing the FIFO (register 'sqi_cr1').                   */
                                                                 /* This may become necessary for terminating a read sequence.                                                 */
                                                                 /* Example:                                                                                                   */
                                                                 /* A half-duplex write transfer of 128 kbytes has been programmed, but there is not enough                    */
                                                                 /* write data. To terminate this write sequence, clear the TX FIFO. If an external                            */
                                                                 /* transfer is running while the FIFO is being cleared, this transfer will be continued                       */
                                                                 /* and finished with the last bit to be transferred.                                                          */
                                                                 /* Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set.              */
  unsigned int reserved1      : BFW_NX90_sqi_tcr_reserved1;      /* reserved                                                                                                   */
  unsigned int tx_out         : BFW_NX90_sqi_tcr_tx_out;         /* Output level in dummy or standard SPI receive-only mode                                                    */
                                                                 /* This bit selects the output level when the output driver is enabled in the dummy mode.                     */
  unsigned int tx_oe          : BFW_NX90_sqi_tcr_tx_oe;          /* Output driver enable in dummy or standard SPI receive-only mode                                            */
                                                                 /* Writing a "1" enables the output drivers of the data pins in the dummy mode.                               */
  unsigned int start_transfer : BFW_NX90_sqi_tcr_start_transfer; /* Transfer start signal                                                                                      */
                                                                 /* Writing a "1" starts the transfer of transfer_size bytes or dummy cycles.                                  */
                                                                 /* The hardware will automatically reset this bit. This bit is always '0' when read. This bit                 */
                                                                 /* is writable only after a transfer sequence is finished or if it has been terminated                        */
                                                                 /* by a FIFO clear.                                                                                           */
                                                                 /* Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set.              */
                                                                 /* Note: In standard Motorola SPI mode, this function can be controlled by bit 'spi_trans_ctrl' of            */
                                                                 /*       register 'sqi_cr1' (for SPI module compatibility).                                                   */
  unsigned int mode           : BFW_NX90_sqi_tcr_mode;           /* SPI/SQI mode selection                                                                                     */
                                                                 /* 00: Standard Motorola SPI mode.                                                                            */
                                                                 /* 01: 2-bit SPI mode                                                                                         */
                                                                 /* 10: 4-bit SPI mode                                                                                         */
                                                                 /* 11: reserved                                                                                               */
  unsigned int duplex         : BFW_NX90_sqi_tcr_duplex;         /* Transfer type selection                                                                                    */
                                                                 /* Default is '11' for standard SPI compatibility.                                                            */
                                                                 /* 00: dummy                                                                                                  */
                                                                 /*     Generates 'transfer_size' + 1 serial clock periods. No change of RX and TX FIFOs.                      */
                                                                 /*     Data lines (standard Motorola SPI mode: SPI_MOSI) are controlled by 'tx_oe' and 'tx_out'.              */
                                                                 /* 01: half-duplex receive                                                                                    */
                                                                 /*     Receives 'transfer_size' + 1 words.                                                                    */
                                                                 /*     In 2-bit and 4-bit mode, TX-FIFO will be cleared and is not available during receive.                  */
                                                                 /*     In standard SPI mode, SPI_MOSI is controlled by 'tx_oe' and 'tx_out'. You need not                     */
                                                                 /*     fill the TX-FIFO with dummy TX-data to receive RX-data. TX FIFOs are not changed and always available. */
                                                                 /* 10: half-duplex transmit                                                                                   */
                                                                 /*     Transmits 'transfer_size' + 1 words.                                                                   */
                                                                 /*     In 2-bit and 4-bit mode, RX-FIFO will be cleared and is not available during transmit.                 */
                                                                 /*     In standard SPI mode, SPI_MISO input is ignored. RX-FIFO is available and remains unchanged.           */
                                                                 /* 11: full-duplex                                                                                            */
                                                                 /*     Standard Motorola SPI mode only, reserved in 2-bit and 4-bit modes.                                    */
                                                                 /*     The full-duplex standard Motorola SPI mode always transmits and receives data. Transmit data           */
                                                                 /*     is taken from TX-FIFO, receive data is stored in RX-FIFO.                                              */
                                                                 /* Note: If '11' is set in 2-bit or 4-bit mode, this is treated as 'receive' (like '01' setting).             */
                                                                 /* Note: In case of a FIFO error (overflow, underrun) before changing to '01' or '10',                        */
                                                                 /*       the FIFO error status bits in register 'sqi_sr' will not be cleared by half-duplex                   */
                                                                 /*       modes FIFO clearing.                                                                                 */
  unsigned int ms_bit_first   : BFW_NX90_sqi_tcr_ms_bit_first;   /* Most significant bit first                                                                                 */
                                                                 /* 2- and 4-bit mode: Writing "1" to this bit will transfer most significant bit first (default).             */
                                                                 /* In standard Motorola SPI mode this bit is ignored.                                                         */
  unsigned int ms_byte_first  : BFW_NX90_sqi_tcr_ms_byte_first;  /* Most significant byte first                                                                                */
                                                                 /* 2- and 4-bit mode: Writing "1" to this bit will use most significant byte first in DWords (big endian).    */
                                                                 /* Default is little endian                                                                                   */
                                                                 /* In standard Motorola SPI mode this bit is ignored.                                                         */
  unsigned int reserved2      : BFW_NX90_sqi_tcr_reserved2;      /* reserved                                                                                                   */
} NX90_SQI_TCR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SQI_TCR_BIT_T bf;
} NX90_SQI_TCR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_mask */
/* => SQI interrupt mask register: */
/*    IRQ mask is an AND-mask: Only raw interrupts with mask bit set can generate a module IRQ to CPU. \ */
/*    For detailed IRQ behavior and function, see register 'sqi_irq_raw'. */
/*    The functionality of this register is similar to that of the corresponding SPI register spi_imsc. \ */
/*    In contrast to this register, setting bits in spi_imsc also clears the corresponding raw interrupts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_irq_mask  0x00000014U
#define Adr_NX90_sqi_sqi_irq_mask  0xFF401654U
#define Adr_NX90_sqi_irq_mask      0xFF401654U
#define DFLT_VAL_NX90_sqi_irq_mask 0x00000000U

#define MSK_NX90_sqi_irq_mask_RORIM                0x00000001U
#define SRT_NX90_sqi_irq_mask_RORIM                0
#define DFLT_VAL_NX90_sqi_irq_mask_RORIM           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_RORIM        0x00000000U
#define MSK_NX90_sqi_irq_mask_RTIM                 0x00000002U
#define SRT_NX90_sqi_irq_mask_RTIM                 1
#define DFLT_VAL_NX90_sqi_irq_mask_RTIM            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_RTIM         0x00000000U
#define MSK_NX90_sqi_irq_mask_RXIM                 0x00000004U
#define SRT_NX90_sqi_irq_mask_RXIM                 2
#define DFLT_VAL_NX90_sqi_irq_mask_RXIM            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_RXIM         0x00000000U
#define MSK_NX90_sqi_irq_mask_TXIM                 0x00000008U
#define SRT_NX90_sqi_irq_mask_TXIM                 3
#define DFLT_VAL_NX90_sqi_irq_mask_TXIM            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_TXIM         0x00000000U
#define MSK_NX90_sqi_irq_mask_rxneim               0x00000010U
#define SRT_NX90_sqi_irq_mask_rxneim               4
#define DFLT_VAL_NX90_sqi_irq_mask_rxneim          0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_rxneim       0x00000000U
#define MSK_NX90_sqi_irq_mask_rxfim                0x00000020U
#define SRT_NX90_sqi_irq_mask_rxfim                5
#define DFLT_VAL_NX90_sqi_irq_mask_rxfim           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_rxfim        0x00000000U
#define MSK_NX90_sqi_irq_mask_txeim                0x00000040U
#define SRT_NX90_sqi_irq_mask_txeim                6
#define DFLT_VAL_NX90_sqi_irq_mask_txeim           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_txeim        0x00000000U
#define MSK_NX90_sqi_irq_mask_trans_end            0x00000080U
#define SRT_NX90_sqi_irq_mask_trans_end            7
#define DFLT_VAL_NX90_sqi_irq_mask_trans_end       0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_trans_end    0x00000000U
#define MSK_NX90_sqi_irq_mask_sqirom_error         0x00000100U
#define SRT_NX90_sqi_irq_mask_sqirom_error         8
#define DFLT_VAL_NX90_sqi_irq_mask_sqirom_error    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_mask_sqirom_error 0x00000000U

/* all used bits of 'NX90_sqi_irq_mask': */
#define MSK_USED_BITS_NX90_sqi_irq_mask 0x000001ffU

enum {
  BFW_NX90_sqi_irq_mask_RORIM        = 1,  /* [0] */
  BFW_NX90_sqi_irq_mask_RTIM         = 1,  /* [1] */
  BFW_NX90_sqi_irq_mask_RXIM         = 1,  /* [2] */
  BFW_NX90_sqi_irq_mask_TXIM         = 1,  /* [3] */
  BFW_NX90_sqi_irq_mask_rxneim       = 1,  /* [4] */
  BFW_NX90_sqi_irq_mask_rxfim        = 1,  /* [5] */
  BFW_NX90_sqi_irq_mask_txeim        = 1,  /* [6] */
  BFW_NX90_sqi_irq_mask_trans_end    = 1,  /* [7] */
  BFW_NX90_sqi_irq_mask_sqirom_error = 1,  /* [8] */
  BFW_NX90_sqi_irq_mask_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_SQI_IRQ_MASK_BIT_Ttag {
  unsigned int RORIM        : BFW_NX90_sqi_irq_mask_RORIM;        /* Receive FIFO overrun interrupt mask                                        */
  unsigned int RTIM         : BFW_NX90_sqi_irq_mask_RTIM;         /* Receive timeout interrupt mask                                             */
  unsigned int RXIM         : BFW_NX90_sqi_irq_mask_RXIM;         /* Receive FIFO interrupt mask                                                */
  unsigned int TXIM         : BFW_NX90_sqi_irq_mask_TXIM;         /* Transmit FIFO interrupt mask                                               */
  unsigned int rxneim       : BFW_NX90_sqi_irq_mask_rxneim;       /* Receive FIFO not empty interrupt mask (for compatibility with netx100/500) */
  unsigned int rxfim        : BFW_NX90_sqi_irq_mask_rxfim;        /* Receive FIFO full interrupt mask (for compatibility with netx100/500)      */
  unsigned int txeim        : BFW_NX90_sqi_irq_mask_txeim;        /* Transmit FIFO empty interrupt mask (for compatibility with netx100/500)    */
  unsigned int trans_end    : BFW_NX90_sqi_irq_mask_trans_end;    /* Transfer end interrupt mask                                                */
  unsigned int sqirom_error : BFW_NX90_sqi_irq_mask_sqirom_error; /* SQIROM error interrupt mask                                                */
  unsigned int reserved1    : BFW_NX90_sqi_irq_mask_reserved1;    /* reserved                                                                   */
} NX90_SQI_IRQ_MASK_BIT_T;

typedef union {
  uint32_t                val;
  NX90_SQI_IRQ_MASK_BIT_T bf;
} NX90_SQI_IRQ_MASK_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_raw */
/* => SQI interrupt state before masking register (raw interrupt). */
/*    Writing a "1" to a bit clears this interrupt. */
/*    IRQ flags can also be cleared by using 'sqi_irq_clear' for SPI module compatibility. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_irq_raw  0x00000018U
#define Adr_NX90_sqi_sqi_irq_raw  0xFF401658U
#define Adr_NX90_sqi_irq_raw      0xFF401658U
#define DFLT_VAL_NX90_sqi_irq_raw 0x00000008U

#define MSK_NX90_sqi_irq_raw_RORRIS               0x00000001U
#define SRT_NX90_sqi_irq_raw_RORRIS               0
#define DFLT_VAL_NX90_sqi_irq_raw_RORRIS          0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_RORRIS       0x00000000U
#define MSK_NX90_sqi_irq_raw_RTRIS                0x00000002U
#define SRT_NX90_sqi_irq_raw_RTRIS                1
#define DFLT_VAL_NX90_sqi_irq_raw_RTRIS           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_RTRIS        0x00000000U
#define MSK_NX90_sqi_irq_raw_RXRIS                0x00000004U
#define SRT_NX90_sqi_irq_raw_RXRIS                2
#define DFLT_VAL_NX90_sqi_irq_raw_RXRIS           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_RXRIS        0x00000000U
#define MSK_NX90_sqi_irq_raw_TXRIS                0x00000008U
#define SRT_NX90_sqi_irq_raw_TXRIS                3
#define DFLT_VAL_NX90_sqi_irq_raw_TXRIS           0x00000008U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_TXRIS        0x00000001U
#define MSK_NX90_sqi_irq_raw_rxneris              0x00000010U
#define SRT_NX90_sqi_irq_raw_rxneris              4
#define DFLT_VAL_NX90_sqi_irq_raw_rxneris         0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_rxneris      0x00000000U
#define MSK_NX90_sqi_irq_raw_rxfris               0x00000020U
#define SRT_NX90_sqi_irq_raw_rxfris               5
#define DFLT_VAL_NX90_sqi_irq_raw_rxfris          0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_rxfris       0x00000000U
#define MSK_NX90_sqi_irq_raw_txeris               0x00000040U
#define SRT_NX90_sqi_irq_raw_txeris               6
#define DFLT_VAL_NX90_sqi_irq_raw_txeris          0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_txeris       0x00000000U
#define MSK_NX90_sqi_irq_raw_trans_end            0x00000080U
#define SRT_NX90_sqi_irq_raw_trans_end            7
#define DFLT_VAL_NX90_sqi_irq_raw_trans_end       0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_trans_end    0x00000000U
#define MSK_NX90_sqi_irq_raw_sqirom_error         0x00000100U
#define SRT_NX90_sqi_irq_raw_sqirom_error         8
#define DFLT_VAL_NX90_sqi_irq_raw_sqirom_error    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_raw_sqirom_error 0x00000000U

/* all used bits of 'NX90_sqi_irq_raw': */
#define MSK_USED_BITS_NX90_sqi_irq_raw 0x000001ffU

enum {
  BFW_NX90_sqi_irq_raw_RORRIS       = 1,  /* [0] */
  BFW_NX90_sqi_irq_raw_RTRIS        = 1,  /* [1] */
  BFW_NX90_sqi_irq_raw_RXRIS        = 1,  /* [2] */
  BFW_NX90_sqi_irq_raw_TXRIS        = 1,  /* [3] */
  BFW_NX90_sqi_irq_raw_rxneris      = 1,  /* [4] */
  BFW_NX90_sqi_irq_raw_rxfris       = 1,  /* [5] */
  BFW_NX90_sqi_irq_raw_txeris       = 1,  /* [6] */
  BFW_NX90_sqi_irq_raw_trans_end    = 1,  /* [7] */
  BFW_NX90_sqi_irq_raw_sqirom_error = 1,  /* [8] */
  BFW_NX90_sqi_irq_raw_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_SQI_IRQ_RAW_BIT_Ttag {
  unsigned int RORRIS       : BFW_NX90_sqi_irq_raw_RORRIS;       /* Unmasked receive FIFO overrun interrupt state                                                 */
                                                                 /* 1: receive FIFO overrun error occurred                                                        */
                                                                 /* 0: no receive FIFO overrun error occurred                                                     */
  unsigned int RTRIS        : BFW_NX90_sqi_irq_raw_RTRIS;        /* Unmasked receive timeout interrupt state                                                      */
                                                                 /* Timeout period is 32 serial clock periods (depending on adr_sqi_cr0.sck_muladd).              */
                                                                 /* 1: receive FIFO is not empty and has not been read out during the timeout period              */
                                                                 /* 0: receive FIFO is empty or read during the last timeout period                               */
  unsigned int RXRIS        : BFW_NX90_sqi_irq_raw_RXRIS;        /* Unmasked receive FIFO interrupt state                                                         */
                                                                 /* 1: receive FIFO is higher than sqi_cr1.rx_fifo_wm                                             */
                                                                 /* 0: receive FIFO is equal or below sqi_cr1.rx_fifo_wm                                          */
                                                                 /* Note: Before programming this IRQ, see description of bits 'spi_trans_ctrl' and 'rx_fifo_wm'  */
                                                                 /* of register 'sqi_cr1' for receive FIFO behavior.                                              */
  unsigned int TXRIS        : BFW_NX90_sqi_irq_raw_TXRIS;        /* Unmasked transmit FIFO interrupt state                                                        */
                                                                 /* 1: transmit FIFO level is below sqi_cr1.tx_fifo_wm                                            */
                                                                 /* 0: transmit FIFO is equal or higher than sqi_cr1.tx_fifo_wm                                   */
  unsigned int rxneris      : BFW_NX90_sqi_irq_raw_rxneris;      /* Unmasked receive FIFO not empty interrupt state (for compatibility with netx100/500)          */
                                                                 /* 1: receive FIFO is not empty                                                                  */
                                                                 /* 0: receive FIFO is empty                                                                      */
  unsigned int rxfris       : BFW_NX90_sqi_irq_raw_rxfris;       /* Unmasked receive FIFO full interrupt state (for compatibility with netx100/500)               */
                                                                 /* 1: receive FIFO is full                                                                       */
                                                                 /* 0: receive FIFO is not full                                                                   */
  unsigned int txeris       : BFW_NX90_sqi_irq_raw_txeris;       /* Unmasked transmit FIFO empty interrupt state (for compatibility with netx100/500)             */
                                                                 /* 1: transmit FIFO is empty                                                                     */
                                                                 /* 0: transmit FIFO is not empty                                                                 */
  unsigned int trans_end    : BFW_NX90_sqi_irq_raw_trans_end;    /* Unmasked transfer end interrupt state (related to bit 'busy' of register 'sqi_sr')            */
                                                                 /* 1: transfer finished. Bit 'busy' of register 'sqi_sr' has become inactive.                    */
                                                                 /* 0: transfer not finished. Bit 'busy' of register 'sqi_sr' is active.                          */
  unsigned int sqirom_error : BFW_NX90_sqi_irq_raw_sqirom_error; /* Unmasked SQIROM error interrupt state                                                         */
                                                                 /* 1: SQIROM access error detected.                                                              */
                                                                 /*    This IRQ will be set if an error occurs during an SQIROM access.                           */
                                                                 /*    For detailed information on the error, see SQIROM error bits in register 'sqi_sr'.         */
                                                                 /*    For error handling, clear this IRQ bit and the bits of register 'sqi_sr'.                  */
                                                                 /* 0: no SQIROM error detected.                                                                  */
  unsigned int reserved1    : BFW_NX90_sqi_irq_raw_reserved1;    /* reserved                                                                                      */
} NX90_SQI_IRQ_RAW_BIT_T;

typedef union {
  uint32_t               val;
  NX90_SQI_IRQ_RAW_BIT_T bf;
} NX90_SQI_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_masked */
/* => SQI masked interrupt status register */
/*    For detailed IRQ behavior and function, see register 'sqi_irq_raw'. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_irq_masked 0x0000001CU
#define Adr_NX90_sqi_sqi_irq_masked 0xFF40165CU
#define Adr_NX90_sqi_irq_masked     0xFF40165CU

#define MSK_NX90_sqi_irq_masked_RORMIS       0x00000001U
#define SRT_NX90_sqi_irq_masked_RORMIS       0
#define MSK_NX90_sqi_irq_masked_RTMIS        0x00000002U
#define SRT_NX90_sqi_irq_masked_RTMIS        1
#define MSK_NX90_sqi_irq_masked_RXMIS        0x00000004U
#define SRT_NX90_sqi_irq_masked_RXMIS        2
#define MSK_NX90_sqi_irq_masked_TXMIS        0x00000008U
#define SRT_NX90_sqi_irq_masked_TXMIS        3
#define MSK_NX90_sqi_irq_masked_rxnemis      0x00000010U
#define SRT_NX90_sqi_irq_masked_rxnemis      4
#define MSK_NX90_sqi_irq_masked_rxfmis       0x00000020U
#define SRT_NX90_sqi_irq_masked_rxfmis       5
#define MSK_NX90_sqi_irq_masked_txemis       0x00000040U
#define SRT_NX90_sqi_irq_masked_txemis       6
#define MSK_NX90_sqi_irq_masked_trans_end    0x00000080U
#define SRT_NX90_sqi_irq_masked_trans_end    7
#define MSK_NX90_sqi_irq_masked_sqirom_error 0x00000100U
#define SRT_NX90_sqi_irq_masked_sqirom_error 8

/* all used bits of 'NX90_sqi_irq_masked': */
#define MSK_USED_BITS_NX90_sqi_irq_masked 0x000001ffU

enum {
  BFW_NX90_sqi_irq_masked_RORMIS       = 1,  /* [0] */
  BFW_NX90_sqi_irq_masked_RTMIS        = 1,  /* [1] */
  BFW_NX90_sqi_irq_masked_RXMIS        = 1,  /* [2] */
  BFW_NX90_sqi_irq_masked_TXMIS        = 1,  /* [3] */
  BFW_NX90_sqi_irq_masked_rxnemis      = 1,  /* [4] */
  BFW_NX90_sqi_irq_masked_rxfmis       = 1,  /* [5] */
  BFW_NX90_sqi_irq_masked_txemis       = 1,  /* [6] */
  BFW_NX90_sqi_irq_masked_trans_end    = 1,  /* [7] */
  BFW_NX90_sqi_irq_masked_sqirom_error = 1,  /* [8] */
  BFW_NX90_sqi_irq_masked_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_SQI_IRQ_MASKED_BIT_Ttag {
  unsigned int RORMIS       : BFW_NX90_sqi_irq_masked_RORMIS;       /* Masked receive FIFO overrun interrupt state                                        */
  unsigned int RTMIS        : BFW_NX90_sqi_irq_masked_RTMIS;        /* Masked receive timeout interrupt state                                             */
  unsigned int RXMIS        : BFW_NX90_sqi_irq_masked_RXMIS;        /* Masked receive FIFO interrupt state                                                */
  unsigned int TXMIS        : BFW_NX90_sqi_irq_masked_TXMIS;        /* Masked transmit FIFO interrupt state                                               */
  unsigned int rxnemis      : BFW_NX90_sqi_irq_masked_rxnemis;      /* Masked receive FIFO not empty interrupt state (for compatibility with netx100/500) */
  unsigned int rxfmis       : BFW_NX90_sqi_irq_masked_rxfmis;       /* Masked receive FIFO full interrupt state (for compatibility with netx100/500)      */
  unsigned int txemis       : BFW_NX90_sqi_irq_masked_txemis;       /* Masked transmit FIFO empty interrupt state (for compatibility with netx100/500)    */
  unsigned int trans_end    : BFW_NX90_sqi_irq_masked_trans_end;    /* Masked transfer end interrupt state                                                */
  unsigned int sqirom_error : BFW_NX90_sqi_irq_masked_sqirom_error; /* Masked SQIROM error interrupt state                                                */
  unsigned int reserved1    : BFW_NX90_sqi_irq_masked_reserved1;    /* reserved                                                                           */
} NX90_SQI_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_SQI_IRQ_MASKED_BIT_T bf;
} NX90_SQI_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_clear */
/* => SQI interrupt clear register (for compatibility with netX10/50 SPI module). */
/*    This register is always '0' on read. */
/*    IRQ flags can also be cleared by writing register 'sqi_irq_raw'. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_irq_clear  0x00000020U
#define Adr_NX90_sqi_sqi_irq_clear  0xFF401660U
#define Adr_NX90_sqi_irq_clear      0xFF401660U
#define DFLT_VAL_NX90_sqi_irq_clear 0x00000000U

#define MSK_NX90_sqi_irq_clear_RORIC                0x00000001U
#define SRT_NX90_sqi_irq_clear_RORIC                0
#define DFLT_VAL_NX90_sqi_irq_clear_RORIC           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_RORIC        0x00000000U
#define MSK_NX90_sqi_irq_clear_RTIC                 0x00000002U
#define SRT_NX90_sqi_irq_clear_RTIC                 1
#define DFLT_VAL_NX90_sqi_irq_clear_RTIC            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_RTIC         0x00000000U
#define MSK_NX90_sqi_irq_clear_RXIC                 0x00000004U
#define SRT_NX90_sqi_irq_clear_RXIC                 2
#define DFLT_VAL_NX90_sqi_irq_clear_RXIC            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_RXIC         0x00000000U
#define MSK_NX90_sqi_irq_clear_TXIC                 0x00000008U
#define SRT_NX90_sqi_irq_clear_TXIC                 3
#define DFLT_VAL_NX90_sqi_irq_clear_TXIC            0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_TXIC         0x00000000U
#define MSK_NX90_sqi_irq_clear_rxneic               0x00000010U
#define SRT_NX90_sqi_irq_clear_rxneic               4
#define DFLT_VAL_NX90_sqi_irq_clear_rxneic          0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_rxneic       0x00000000U
#define MSK_NX90_sqi_irq_clear_rxfic                0x00000020U
#define SRT_NX90_sqi_irq_clear_rxfic                5
#define DFLT_VAL_NX90_sqi_irq_clear_rxfic           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_rxfic        0x00000000U
#define MSK_NX90_sqi_irq_clear_txeic                0x00000040U
#define SRT_NX90_sqi_irq_clear_txeic                6
#define DFLT_VAL_NX90_sqi_irq_clear_txeic           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_txeic        0x00000000U
#define MSK_NX90_sqi_irq_clear_trans_end            0x00000080U
#define SRT_NX90_sqi_irq_clear_trans_end            7
#define DFLT_VAL_NX90_sqi_irq_clear_trans_end       0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_trans_end    0x00000000U
#define MSK_NX90_sqi_irq_clear_sqirom_error         0x00000100U
#define SRT_NX90_sqi_irq_clear_sqirom_error         8
#define DFLT_VAL_NX90_sqi_irq_clear_sqirom_error    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_irq_clear_sqirom_error 0x00000000U

/* all used bits of 'NX90_sqi_irq_clear': */
#define MSK_USED_BITS_NX90_sqi_irq_clear 0x000001ffU

enum {
  BFW_NX90_sqi_irq_clear_RORIC        = 1,  /* [0] */
  BFW_NX90_sqi_irq_clear_RTIC         = 1,  /* [1] */
  BFW_NX90_sqi_irq_clear_RXIC         = 1,  /* [2] */
  BFW_NX90_sqi_irq_clear_TXIC         = 1,  /* [3] */
  BFW_NX90_sqi_irq_clear_rxneic       = 1,  /* [4] */
  BFW_NX90_sqi_irq_clear_rxfic        = 1,  /* [5] */
  BFW_NX90_sqi_irq_clear_txeic        = 1,  /* [6] */
  BFW_NX90_sqi_irq_clear_trans_end    = 1,  /* [7] */
  BFW_NX90_sqi_irq_clear_sqirom_error = 1,  /* [8] */
  BFW_NX90_sqi_irq_clear_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_SQI_IRQ_CLEAR_BIT_Ttag {
  unsigned int RORIC        : BFW_NX90_sqi_irq_clear_RORIC;        /* Clear receive FIFO overrun interrupt                                        */
  unsigned int RTIC         : BFW_NX90_sqi_irq_clear_RTIC;         /* Clear receive timeout interrupt                                             */
  unsigned int RXIC         : BFW_NX90_sqi_irq_clear_RXIC;         /* Clear receive FIFO interrupt                                                */
  unsigned int TXIC         : BFW_NX90_sqi_irq_clear_TXIC;         /* Clear transmit FIFO interrupt                                               */
  unsigned int rxneic       : BFW_NX90_sqi_irq_clear_rxneic;       /* Clear receive FIFO not empty interrupt (for compatibility with netx100/500) */
  unsigned int rxfic        : BFW_NX90_sqi_irq_clear_rxfic;        /* Clear receive FIFO full interrupt (for compatibility with netx100/500)      */
  unsigned int txeic        : BFW_NX90_sqi_irq_clear_txeic;        /* Clear transmit FIFO empty interrupt (for compatibility with netx100/500)    */
  unsigned int trans_end    : BFW_NX90_sqi_irq_clear_trans_end;    /* Clear transfer end interrupt                                                */
  unsigned int sqirom_error : BFW_NX90_sqi_irq_clear_sqirom_error; /* Clear SQIROM error interrupt                                                */
  unsigned int reserved1    : BFW_NX90_sqi_irq_clear_reserved1;    /* reserved                                                                    */
} NX90_SQI_IRQ_CLEAR_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_SQI_IRQ_CLEAR_BIT_T bf;
} NX90_SQI_IRQ_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_dmacr */
/* => SQI DMA control register */
/*    This module generates normal transfer requests only (i.e. no last requests will be issued). In consequence, \ */
/*    you can use DMAC-controlled transfers only (no peripheral-controlled mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_dmacr  0x00000024U
#define Adr_NX90_sqi_sqi_dmacr  0xFF401664U
#define Adr_NX90_sqi_dmacr      0xFF401664U
#define DFLT_VAL_NX90_sqi_dmacr 0x00000000U

#define MSK_NX90_sqi_dmacr_rx_dma_en         0x00000001U
#define SRT_NX90_sqi_dmacr_rx_dma_en         0
#define DFLT_VAL_NX90_sqi_dmacr_rx_dma_en    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_dmacr_rx_dma_en 0x00000000U
#define MSK_NX90_sqi_dmacr_tx_dma_en         0x00000002U
#define SRT_NX90_sqi_dmacr_tx_dma_en         1
#define DFLT_VAL_NX90_sqi_dmacr_tx_dma_en    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_dmacr_tx_dma_en 0x00000000U

/* all used bits of 'NX90_sqi_dmacr': */
#define MSK_USED_BITS_NX90_sqi_dmacr 0x00000003U

enum {
  BFW_NX90_sqi_dmacr_rx_dma_en = 1,  /* [0] */
  BFW_NX90_sqi_dmacr_tx_dma_en = 1,  /* [1] */
  BFW_NX90_sqi_dmacr_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_SQI_DMACR_BIT_Ttag {
  unsigned int rx_dma_en : BFW_NX90_sqi_dmacr_rx_dma_en; /* Enable DMA for SQI-receive data                                                                */
                                                         /* A request will be generated if RX-FIFO is not empty and sqi_cr1.sqi_en (module enable) is set. */
                                                         /* If the RX-FIFO contains at least 4 words, there will be a burst request                        */
                                                         /* to the DMAC. Set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMAC module.               */
                                                         /* If this bit is reset or the module is disabled, DMA request will also be reset.                */
  unsigned int tx_dma_en : BFW_NX90_sqi_dmacr_tx_dma_en; /* Enable DMA for SQI-transmit data                                                               */
                                                         /* A request will be generated if TX-FIFO is not full and sqi_cr1.sqi_en (module enable) is set.  */
                                                         /* If at least 4 words are writable to the TX-FIFO, there will be a burst request                 */
                                                         /* to the DMAC. Set dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMAC module.               */
                                                         /* If this bit is reset or the module is disabled, DMA request will also be reset.                */
  unsigned int reserved1 : BFW_NX90_sqi_dmacr_reserved1; /* reserved                                                                                       */
} NX90_SQI_DMACR_BIT_T;

typedef union {
  uint32_t             val;
  NX90_SQI_DMACR_BIT_T bf;
} NX90_SQI_DMACR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_pio_out */
/* => SQI PIO output level control register */
/*    Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. */
/*    Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. */
/*    PIO input signal states are never filtered (bit 'filter_in' of register 'sqi_cr0'). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_pio_out  0x00000028U
#define Adr_NX90_sqi_sqi_pio_out  0xFF401668U
#define Adr_NX90_sqi_pio_out      0xFF401668U
#define DFLT_VAL_NX90_sqi_pio_out 0x0000000eU

#define MSK_NX90_sqi_pio_out_sclk         0x00000001U
#define SRT_NX90_sqi_pio_out_sclk         0
#define DFLT_VAL_NX90_sqi_pio_out_sclk    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_out_sclk 0x00000000U
#define MSK_NX90_sqi_pio_out_csn          0x0000000eU
#define SRT_NX90_sqi_pio_out_csn          1
#define DFLT_VAL_NX90_sqi_pio_out_csn     0x0000000eU
#define DFLT_BF_VAL_NX90_sqi_pio_out_csn  0x00000007U
#define MSK_NX90_sqi_pio_out_mosi         0x00000010U
#define SRT_NX90_sqi_pio_out_mosi         4
#define DFLT_VAL_NX90_sqi_pio_out_mosi    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_out_mosi 0x00000000U
#define MSK_NX90_sqi_pio_out_miso         0x00000020U
#define SRT_NX90_sqi_pio_out_miso         5
#define DFLT_VAL_NX90_sqi_pio_out_miso    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_out_miso 0x00000000U
#define MSK_NX90_sqi_pio_out_sio2         0x00000040U
#define SRT_NX90_sqi_pio_out_sio2         6
#define DFLT_VAL_NX90_sqi_pio_out_sio2    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_out_sio2 0x00000000U
#define MSK_NX90_sqi_pio_out_sio3         0x00000080U
#define SRT_NX90_sqi_pio_out_sio3         7
#define DFLT_VAL_NX90_sqi_pio_out_sio3    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_out_sio3 0x00000000U

/* all used bits of 'NX90_sqi_pio_out': */
#define MSK_USED_BITS_NX90_sqi_pio_out 0x000000ffU

enum {
  BFW_NX90_sqi_pio_out_sclk      = 1,  /* [0] */
  BFW_NX90_sqi_pio_out_csn       = 3,  /* [3:1] */
  BFW_NX90_sqi_pio_out_mosi      = 1,  /* [4] */
  BFW_NX90_sqi_pio_out_miso      = 1,  /* [5] */
  BFW_NX90_sqi_pio_out_sio2      = 1,  /* [6] */
  BFW_NX90_sqi_pio_out_sio3      = 1,  /* [7] */
  BFW_NX90_sqi_pio_out_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_SQI_PIO_OUT_BIT_Ttag {
  unsigned int sclk      : BFW_NX90_sqi_pio_out_sclk;      /* Serial SPI clock output state                */
  unsigned int csn       : BFW_NX90_sqi_pio_out_csn;       /* Chip select/FSS output state {CS2, CS1, CS0} */
  unsigned int mosi      : BFW_NX90_sqi_pio_out_mosi;      /* MOSI/SIO0 output state                       */
  unsigned int miso      : BFW_NX90_sqi_pio_out_miso;      /* MISO/SIO1 output state                       */
  unsigned int sio2      : BFW_NX90_sqi_pio_out_sio2;      /* SIO2 output state                            */
  unsigned int sio3      : BFW_NX90_sqi_pio_out_sio3;      /* SIO3 output state                            */
  unsigned int reserved1 : BFW_NX90_sqi_pio_out_reserved1; /* reserved                                     */
} NX90_SQI_PIO_OUT_BIT_T;

typedef union {
  uint32_t               val;
  NX90_SQI_PIO_OUT_BIT_T bf;
} NX90_SQI_PIO_OUT_T;

/* --------------------------------------------------------------------- */
/* Register sqi_pio_oe */
/* => SQI PIO output enable control register */
/*    Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. */
/*    Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_pio_oe  0x00000030U
#define Adr_NX90_sqi_sqi_pio_oe  0xFF401670U
#define Adr_NX90_sqi_pio_oe      0xFF401670U
#define DFLT_VAL_NX90_sqi_pio_oe 0x00000000U

#define MSK_NX90_sqi_pio_oe_sclk         0x00000001U
#define SRT_NX90_sqi_pio_oe_sclk         0
#define DFLT_VAL_NX90_sqi_pio_oe_sclk    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_oe_sclk 0x00000000U
#define MSK_NX90_sqi_pio_oe_csn          0x0000000eU
#define SRT_NX90_sqi_pio_oe_csn          1
#define DFLT_VAL_NX90_sqi_pio_oe_csn     0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_oe_csn  0x00000000U
#define MSK_NX90_sqi_pio_oe_mosi         0x00000010U
#define SRT_NX90_sqi_pio_oe_mosi         4
#define DFLT_VAL_NX90_sqi_pio_oe_mosi    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_oe_mosi 0x00000000U
#define MSK_NX90_sqi_pio_oe_miso         0x00000020U
#define SRT_NX90_sqi_pio_oe_miso         5
#define DFLT_VAL_NX90_sqi_pio_oe_miso    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_oe_miso 0x00000000U
#define MSK_NX90_sqi_pio_oe_sio2         0x00000040U
#define SRT_NX90_sqi_pio_oe_sio2         6
#define DFLT_VAL_NX90_sqi_pio_oe_sio2    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_oe_sio2 0x00000000U
#define MSK_NX90_sqi_pio_oe_sio3         0x00000080U
#define SRT_NX90_sqi_pio_oe_sio3         7
#define DFLT_VAL_NX90_sqi_pio_oe_sio3    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_pio_oe_sio3 0x00000000U

/* all used bits of 'NX90_sqi_pio_oe': */
#define MSK_USED_BITS_NX90_sqi_pio_oe 0x000000ffU

enum {
  BFW_NX90_sqi_pio_oe_sclk      = 1,  /* [0] */
  BFW_NX90_sqi_pio_oe_csn       = 3,  /* [3:1] */
  BFW_NX90_sqi_pio_oe_mosi      = 1,  /* [4] */
  BFW_NX90_sqi_pio_oe_miso      = 1,  /* [5] */
  BFW_NX90_sqi_pio_oe_sio2      = 1,  /* [6] */
  BFW_NX90_sqi_pio_oe_sio3      = 1,  /* [7] */
  BFW_NX90_sqi_pio_oe_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_SQI_PIO_OE_BIT_Ttag {
  unsigned int sclk      : BFW_NX90_sqi_pio_oe_sclk;      /* Serial SPI clock output enable                */
  unsigned int csn       : BFW_NX90_sqi_pio_oe_csn;       /* Chip select/FSS output enable {CS2, CS1, CS0} */
  unsigned int mosi      : BFW_NX90_sqi_pio_oe_mosi;      /* MOSI/SIO0 output enable                       */
  unsigned int miso      : BFW_NX90_sqi_pio_oe_miso;      /* MISO/SIO1 output enable                       */
  unsigned int sio2      : BFW_NX90_sqi_pio_oe_sio2;      /* SIO2 output enable                            */
  unsigned int sio3      : BFW_NX90_sqi_pio_oe_sio3;      /* SIO3 output enable                            */
  unsigned int reserved1 : BFW_NX90_sqi_pio_oe_reserved1; /* reserved                                      */
} NX90_SQI_PIO_OE_BIT_T;

typedef union {
  uint32_t              val;
  NX90_SQI_PIO_OE_BIT_T bf;
} NX90_SQI_PIO_OE_T;

/* --------------------------------------------------------------------- */
/* Register sqi_pio_in */
/* => SQI PIO input status register */
/*    Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_pio_in 0x00000034U
#define Adr_NX90_sqi_sqi_pio_in 0xFF401674U
#define Adr_NX90_sqi_pio_in     0xFF401674U

#define MSK_NX90_sqi_pio_in_sclk 0x00000001U
#define SRT_NX90_sqi_pio_in_sclk 0
#define MSK_NX90_sqi_pio_in_csn  0x0000000eU
#define SRT_NX90_sqi_pio_in_csn  1
#define MSK_NX90_sqi_pio_in_mosi 0x00000010U
#define SRT_NX90_sqi_pio_in_mosi 4
#define MSK_NX90_sqi_pio_in_miso 0x00000020U
#define SRT_NX90_sqi_pio_in_miso 5
#define MSK_NX90_sqi_pio_in_sio2 0x00000040U
#define SRT_NX90_sqi_pio_in_sio2 6
#define MSK_NX90_sqi_pio_in_sio3 0x00000080U
#define SRT_NX90_sqi_pio_in_sio3 7

/* all used bits of 'NX90_sqi_pio_in': */
#define MSK_USED_BITS_NX90_sqi_pio_in 0x000000ffU

enum {
  BFW_NX90_sqi_pio_in_sclk      = 1,  /* [0] */
  BFW_NX90_sqi_pio_in_csn       = 3,  /* [3:1] */
  BFW_NX90_sqi_pio_in_mosi      = 1,  /* [4] */
  BFW_NX90_sqi_pio_in_miso      = 1,  /* [5] */
  BFW_NX90_sqi_pio_in_sio2      = 1,  /* [6] */
  BFW_NX90_sqi_pio_in_sio3      = 1,  /* [7] */
  BFW_NX90_sqi_pio_in_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_SQI_PIO_IN_BIT_Ttag {
  unsigned int sclk      : BFW_NX90_sqi_pio_in_sclk;      /* Serial SPI clock input state                */
  unsigned int csn       : BFW_NX90_sqi_pio_in_csn;       /* Chip select/FSS input state {CS2, CS1, CS0} */
  unsigned int mosi      : BFW_NX90_sqi_pio_in_mosi;      /* MOSI/SIO0 input state                       */
  unsigned int miso      : BFW_NX90_sqi_pio_in_miso;      /* MISO/SIO1 input state                       */
  unsigned int sio2      : BFW_NX90_sqi_pio_in_sio2;      /* SIO2 input state                            */
  unsigned int sio3      : BFW_NX90_sqi_pio_in_sio3;      /* SIO3 input state                            */
  unsigned int reserved1 : BFW_NX90_sqi_pio_in_reserved1; /* reserved                                    */
} NX90_SQI_PIO_IN_BIT_T;

typedef union {
  uint32_t              val;
  NX90_SQI_PIO_IN_BIT_T bf;
} NX90_SQI_PIO_IN_T;

/* --------------------------------------------------------------------- */
/* Register sqi_sqirom_cfg */
/* => SQIROM mode configuration */
/*    This mode supports the 'eXecute in Place' (XiP) feature of SQI flash chips. This register serves to configure the position of command \ */
/*    byte and address nibbles as well as the number of address nibbles and dummy cycles. To support a wide range of frequencies for the \ */
/*    serial clock output, you can also change the clock divider. */
/*    Notes: */
/*    1. Before enabling this mode, make sure that the SQI flash chip is in 4-bit command mode, otherwise the module is not able to fetch data \ */
/*    from the flash. */
/*    2. When enabled, the SQI module is completely blocked, i.e. other SQI or SPI transactions are not possible. */
/*    3. The chip select signal of the flash must be connected to sqi_cs0. */
/*    4. SQIROM transfers can be generated in SPI mode 0 or 3, which can be selected in register 'sqi_cr0'. DO NOT select mode 1 and 2 \ */
/*    for SQIROM usage. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sqi_sqirom_cfg  0x00000038U
#define Adr_NX90_sqi_sqi_sqirom_cfg  0xFF401678U
#define Adr_NX90_sqi_sqirom_cfg      0xFF401678U
#define DFLT_VAL_NX90_sqi_sqirom_cfg 0x02020004U

#define MSK_NX90_sqi_sqirom_cfg_enable                  0x00000001U
#define SRT_NX90_sqi_sqirom_cfg_enable                  0
#define DFLT_VAL_NX90_sqi_sqirom_cfg_enable             0x00000000U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_enable          0x00000000U
#define MSK_NX90_sqi_sqirom_cfg_addr_before_cmd         0x00000002U
#define SRT_NX90_sqi_sqirom_cfg_addr_before_cmd         1
#define DFLT_VAL_NX90_sqi_sqirom_cfg_addr_before_cmd    0x00000000U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_addr_before_cmd 0x00000000U
#define MSK_NX90_sqi_sqirom_cfg_addr_nibbles            0x0000000cU
#define SRT_NX90_sqi_sqirom_cfg_addr_nibbles            2
#define DFLT_VAL_NX90_sqi_sqirom_cfg_addr_nibbles       0x00000004U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_addr_nibbles    0x00000001U
#define MSK_NX90_sqi_sqirom_cfg_addr_bits               0x00000070U
#define SRT_NX90_sqi_sqirom_cfg_addr_bits               4
#define DFLT_VAL_NX90_sqi_sqirom_cfg_addr_bits          0x00000000U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_addr_bits       0x00000000U
#define MSK_NX90_sqi_sqirom_cfg_cmd_byte                0x0000ff00U
#define SRT_NX90_sqi_sqirom_cfg_cmd_byte                8
#define DFLT_VAL_NX90_sqi_sqirom_cfg_cmd_byte           0x00000000U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_cmd_byte        0x00000000U
#define MSK_NX90_sqi_sqirom_cfg_dummy_cycles            0x000f0000U
#define SRT_NX90_sqi_sqirom_cfg_dummy_cycles            16
#define DFLT_VAL_NX90_sqi_sqirom_cfg_dummy_cycles       0x00020000U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_dummy_cycles    0x00000002U
#define MSK_NX90_sqi_sqirom_cfg_t_csh                   0x00300000U
#define SRT_NX90_sqi_sqirom_cfg_t_csh                   20
#define DFLT_VAL_NX90_sqi_sqirom_cfg_t_csh              0x00000000U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_t_csh           0x00000000U
#define MSK_NX90_sqi_sqirom_cfg_clk_div_val             0xff000000U
#define SRT_NX90_sqi_sqirom_cfg_clk_div_val             24
#define DFLT_VAL_NX90_sqi_sqirom_cfg_clk_div_val        0x02000000U
#define DFLT_BF_VAL_NX90_sqi_sqirom_cfg_clk_div_val     0x00000002U

/* all used bits of 'NX90_sqi_sqirom_cfg': */
#define MSK_USED_BITS_NX90_sqi_sqirom_cfg 0xff3fff7fU

enum {
  BFW_NX90_sqi_sqirom_cfg_enable          = 1, /* [0] */
  BFW_NX90_sqi_sqirom_cfg_addr_before_cmd = 1, /* [1] */
  BFW_NX90_sqi_sqirom_cfg_addr_nibbles    = 2, /* [3:2] */
  BFW_NX90_sqi_sqirom_cfg_addr_bits       = 3, /* [6:4] */
  BFW_NX90_sqi_sqirom_cfg_reserved1       = 1, /* [7] */
  BFW_NX90_sqi_sqirom_cfg_cmd_byte        = 8, /* [15:8] */
  BFW_NX90_sqi_sqirom_cfg_dummy_cycles    = 4, /* [19:16] */
  BFW_NX90_sqi_sqirom_cfg_t_csh           = 2, /* [21:20] */
  BFW_NX90_sqi_sqirom_cfg_reserved2       = 2, /* [23:22] */
  BFW_NX90_sqi_sqirom_cfg_clk_div_val     = 8  /* [31:24] */
};

typedef struct NX90_SQI_SQIROM_CFG_BIT_Ttag {
  unsigned int enable          : BFW_NX90_sqi_sqirom_cfg_enable;          /* Enables the SQIROM mode of the SQI module.                                                                              */
                                                                          /* The SQI chip needs to be initialized to accept 4-bit read-command before you activate                                   */
                                                                          /* the SQIROM mode.                                                                                                        */
                                                                          /* This bit is also used to switch between the SQIROM/XiP and the standard SQI/SPI function.                               */
                                                                          /* If this bit is set, the standard SQI/SPI function is not available. The SQIROM/XiP function                             */
                                                                          /* does not depend on the programmed value of bit 'sqi_en' of register 'sqi_cr1'.                                          */
                                                                          /* If the multiplex matrix provides the SQI function, it is available only in                                              */
                                                                          /* standard SQI/SPI, but not for SQIROM/XiP usage. The SQIROM/XiP function is provided                                     */
                                                                          /* only on dedicated SQI IOs, but not as a multiplex matrix function even if standard                                      */
                                                                          /* SQI/SPI is provided there.                                                                                              */
  unsigned int addr_before_cmd : BFW_NX90_sqi_sqirom_cfg_addr_before_cmd; /* Address before command                                                                                                  */
                                                                          /* When set to '1', the address nibbles will be transferred before the command byte.                                       */
                                                                          /* Otherwise, the command will be transferred first (default).                                                             */
  unsigned int addr_nibbles    : BFW_NX90_sqi_sqirom_cfg_addr_nibbles;    /* The number of nibbles to be transferred as the address to the SQI chip.                                                 */
                                                                          /* This setting depends on the command format of the SQI chip.                                                             */
                                                                          /* Bit 'addr_before_cmd' controls the address command order.                                                               */
                                                                          /* The most significant address bits will be transmitted in the first address nibble.                                      */
                                                                          /* The least significant address bits will be transmitted in the last address nibble.                                      */
                                                                          /* 00: 5 nibbles                                                                                                           */
                                                                          /* 01: 6 nibbles (default)                                                                                                 */
                                                                          /* 10: 7 nibbles                                                                                                           */
                                                                          /* 11: 8 nibbles                                                                                                           */
  unsigned int addr_bits       : BFW_NX90_sqi_sqirom_cfg_addr_bits;       /* The number of address bits of the access address considered to generate the address                                     */
                                                                          /* for the SQI chip.                                                                                                       */
                                                                          /* This setting depends on the size of the SQI chip.                                                                       */
                                                                          /* {     |                                                                                                                 */
                                                                          /*  000:  20 bits (1-MByte/8-MBit device) (default)                                                                        */
                                                                          /*  001:  21 bits (2-MByte/16-MBit device)                                                                                 */
                                                                          /*  010:  22 bits (4-MByte/32-MBit device)                                                                                 */
                                                                          /*  011:  23 bits (8-MByte/64-MBit device)                                                                                 */
                                                                          /*  100:  24 bits (16-MByte/128-MBit device)                                                                               */
                                                                          /*  101:  25 bits (32-MByte/256-MBit device)                                                                               */
                                                                          /*  110:  26 bits (64-MByte/512-MBit device)                                                                               */
                                                                          /*  111:  reserved }                                                                                                       */
  unsigned int reserved1       : BFW_NX90_sqi_sqirom_cfg_reserved1;       /* reserved                                                                                                                */
  unsigned int cmd_byte        : BFW_NX90_sqi_sqirom_cfg_cmd_byte;        /* This byte is transferred to the SQI chip as the command sequence.                                                       */
                                                                          /* Bit 'addr_before_cmd' controls the address command order.                                                               */
  unsigned int dummy_cycles    : BFW_NX90_sqi_sqirom_cfg_dummy_cycles;    /* Selects the number of dummy cycles before data will be sampled from the SQI chip.                                       */
                                                                          /* {     |                                                                                                                 */
                                                                          /*  0000: 0 cycles                                                                                                         */
                                                                          /*  0001: 1 cycle                                                                                                          */
                                                                          /*  0010: 2 cycles (default)                                                                                               */
                                                                          /*  ...                                                                                                                    */
                                                                          /*  1111: 15 cycles }                                                                                                      */
  unsigned int t_csh           : BFW_NX90_sqi_sqirom_cfg_t_csh;           /* Min. SQI chip select high (idle) time: (t_csh+1) * t_sck (according to clk_div_val).                                    */
                                                                          /* Programmable values are 0 to 3.                                                                                         */
                                                                          /* Change this parameter if the SQI device used requires min. chip select high times                                       */
                                                                          /* exceeding 1 serial clock period. The data sheet of the SQI device used provides the required timing.                    */
                                                                          /* Note: Serial clock will not toggle if the device is not selected. Hence, only chip select active                        */
                                                                          /* timing has to be considered.                                                                                            */
  unsigned int reserved2       : BFW_NX90_sqi_sqirom_cfg_reserved2;       /* reserved                                                                                                                */
  unsigned int clk_div_val     : BFW_NX90_sqi_sqirom_cfg_clk_div_val;     /* clk400 will be divided by (clk_div_val+3) for sqirom_clk generation.                                                    */
                                                                          /* Default setting '2' is 80 MHz. Maximum serial clock rate (programming '0') is 133 MHz.                                  */
                                                                          /* Serial clock period (t_sck) will be (clk_div_val+3) * 2.5 ns. Clock high and low phase will be generated symmetrically. */
} NX90_SQI_SQIROM_CFG_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_SQI_SQIROM_CFG_BIT_T bf;
} NX90_SQI_SQIROM_CFG_T;


/* ===================================================================== */

/* Area of sample_at_porn_stat */

/* ===================================================================== */

#define Addr_NX90_sample_at_porn_stat 0xFF401680U

/* --------------------------------------------------------------------- */
/* Register sample_at_porn_stat_in0 */
/* => Status of inputs sampled at power-on-reset (PORn) register 0. */
/*    This register shows the status of the inputs sampled at power-on-reset. It will not change on normal system reset. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sample_at_porn_stat_in0                 0x00000000U
#define Adr_NX90_sample_at_porn_stat_sample_at_porn_stat_in0 0xFF401680U
#define Adr_NX90_sample_at_porn_stat_in0                     0xFF401680U

#define MSK_NX90_sample_at_porn_stat_in0_hif_d0  0x00000001U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d0  0
#define MSK_NX90_sample_at_porn_stat_in0_hif_d1  0x00000002U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d1  1
#define MSK_NX90_sample_at_porn_stat_in0_hif_d2  0x00000004U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d2  2
#define MSK_NX90_sample_at_porn_stat_in0_hif_d3  0x00000008U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d3  3
#define MSK_NX90_sample_at_porn_stat_in0_hif_d4  0x00000010U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d4  4
#define MSK_NX90_sample_at_porn_stat_in0_hif_d5  0x00000020U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d5  5
#define MSK_NX90_sample_at_porn_stat_in0_hif_d6  0x00000040U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d6  6
#define MSK_NX90_sample_at_porn_stat_in0_hif_d7  0x00000080U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d7  7
#define MSK_NX90_sample_at_porn_stat_in0_hif_d8  0x00000100U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d8  8
#define MSK_NX90_sample_at_porn_stat_in0_hif_d9  0x00000200U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d9  9
#define MSK_NX90_sample_at_porn_stat_in0_hif_d10 0x00000400U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d10 10
#define MSK_NX90_sample_at_porn_stat_in0_hif_d11 0x00000800U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d11 11
#define MSK_NX90_sample_at_porn_stat_in0_hif_d12 0x00001000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d12 12
#define MSK_NX90_sample_at_porn_stat_in0_hif_d13 0x00002000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d13 13
#define MSK_NX90_sample_at_porn_stat_in0_hif_d14 0x00004000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d14 14
#define MSK_NX90_sample_at_porn_stat_in0_hif_d15 0x00008000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_d15 15
#define MSK_NX90_sample_at_porn_stat_in0_hif_a0  0x00010000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a0  16
#define MSK_NX90_sample_at_porn_stat_in0_hif_a1  0x00020000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a1  17
#define MSK_NX90_sample_at_porn_stat_in0_hif_a2  0x00040000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a2  18
#define MSK_NX90_sample_at_porn_stat_in0_hif_a3  0x00080000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a3  19
#define MSK_NX90_sample_at_porn_stat_in0_hif_a4  0x00100000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a4  20
#define MSK_NX90_sample_at_porn_stat_in0_hif_a5  0x00200000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a5  21
#define MSK_NX90_sample_at_porn_stat_in0_hif_a6  0x00400000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a6  22
#define MSK_NX90_sample_at_porn_stat_in0_hif_a7  0x00800000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a7  23
#define MSK_NX90_sample_at_porn_stat_in0_hif_a8  0x01000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a8  24
#define MSK_NX90_sample_at_porn_stat_in0_hif_a9  0x02000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a9  25
#define MSK_NX90_sample_at_porn_stat_in0_hif_a10 0x04000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a10 26
#define MSK_NX90_sample_at_porn_stat_in0_hif_a11 0x08000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a11 27
#define MSK_NX90_sample_at_porn_stat_in0_hif_a12 0x10000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a12 28
#define MSK_NX90_sample_at_porn_stat_in0_hif_a13 0x20000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a13 29
#define MSK_NX90_sample_at_porn_stat_in0_hif_a14 0x40000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a14 30
#define MSK_NX90_sample_at_porn_stat_in0_hif_a15 0x80000000U
#define SRT_NX90_sample_at_porn_stat_in0_hif_a15 31

/* all used bits of 'NX90_sample_at_porn_stat_in0': */
#define MSK_USED_BITS_NX90_sample_at_porn_stat_in0 0xffffffffU

enum {
  BFW_NX90_sample_at_porn_stat_in0_hif_d0  = 1, /* [0] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d1  = 1, /* [1] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d2  = 1, /* [2] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d3  = 1, /* [3] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d4  = 1, /* [4] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d5  = 1, /* [5] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d6  = 1, /* [6] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d7  = 1, /* [7] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d8  = 1, /* [8] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d9  = 1, /* [9] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d10 = 1, /* [10] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d11 = 1, /* [11] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d12 = 1, /* [12] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d13 = 1, /* [13] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d14 = 1, /* [14] */
  BFW_NX90_sample_at_porn_stat_in0_hif_d15 = 1, /* [15] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a0  = 1, /* [16] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a1  = 1, /* [17] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a2  = 1, /* [18] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a3  = 1, /* [19] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a4  = 1, /* [20] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a5  = 1, /* [21] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a6  = 1, /* [22] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a7  = 1, /* [23] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a8  = 1, /* [24] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a9  = 1, /* [25] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a10 = 1, /* [26] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a11 = 1, /* [27] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a12 = 1, /* [28] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a13 = 1, /* [29] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a14 = 1, /* [30] */
  BFW_NX90_sample_at_porn_stat_in0_hif_a15 = 1  /* [31] */
};

typedef struct NX90_SAMPLE_AT_PORN_STAT_IN0_BIT_Ttag {
  unsigned int hif_d0  : BFW_NX90_sample_at_porn_stat_in0_hif_d0;  /* Input status of pin 'hif_d0' sampled at power-on-reset  */
  unsigned int hif_d1  : BFW_NX90_sample_at_porn_stat_in0_hif_d1;  /* Input status of pin 'hif_d1' sampled at power-on-reset  */
  unsigned int hif_d2  : BFW_NX90_sample_at_porn_stat_in0_hif_d2;  /* Input status of pin 'hif_d2' sampled at power-on-reset  */
  unsigned int hif_d3  : BFW_NX90_sample_at_porn_stat_in0_hif_d3;  /* Input status of pin 'hif_d3' sampled at power-on-reset  */
  unsigned int hif_d4  : BFW_NX90_sample_at_porn_stat_in0_hif_d4;  /* Input status of pin 'hif_d4' sampled at power-on-reset  */
  unsigned int hif_d5  : BFW_NX90_sample_at_porn_stat_in0_hif_d5;  /* Input status of pin 'hif_d5' sampled at power-on-reset  */
  unsigned int hif_d6  : BFW_NX90_sample_at_porn_stat_in0_hif_d6;  /* Input status of pin 'hif_d6' sampled at power-on-reset  */
  unsigned int hif_d7  : BFW_NX90_sample_at_porn_stat_in0_hif_d7;  /* Input status of pin 'hif_d7' sampled at power-on-reset  */
  unsigned int hif_d8  : BFW_NX90_sample_at_porn_stat_in0_hif_d8;  /* Input status of pin 'hif_d8' sampled at power-on-reset  */
  unsigned int hif_d9  : BFW_NX90_sample_at_porn_stat_in0_hif_d9;  /* Input status of pin 'hif_d9' sampled at power-on-reset  */
  unsigned int hif_d10 : BFW_NX90_sample_at_porn_stat_in0_hif_d10; /* Input status of pin 'hif_d10' sampled at power-on-reset */
  unsigned int hif_d11 : BFW_NX90_sample_at_porn_stat_in0_hif_d11; /* Input status of pin 'hif_d11' sampled at power-on-reset */
  unsigned int hif_d12 : BFW_NX90_sample_at_porn_stat_in0_hif_d12; /* Input status of pin 'hif_d12' sampled at power-on-reset */
  unsigned int hif_d13 : BFW_NX90_sample_at_porn_stat_in0_hif_d13; /* Input status of pin 'hif_d13' sampled at power-on-reset */
  unsigned int hif_d14 : BFW_NX90_sample_at_porn_stat_in0_hif_d14; /* Input status of pin 'hif_d14' sampled at power-on-reset */
  unsigned int hif_d15 : BFW_NX90_sample_at_porn_stat_in0_hif_d15; /* Input status of pin 'hif_d15' sampled at power-on-reset */
  unsigned int hif_a0  : BFW_NX90_sample_at_porn_stat_in0_hif_a0;  /* Input status of pin 'hif_a0' sampled at power-on-reset  */
  unsigned int hif_a1  : BFW_NX90_sample_at_porn_stat_in0_hif_a1;  /* Input status of pin 'hif_a1' sampled at power-on-reset  */
  unsigned int hif_a2  : BFW_NX90_sample_at_porn_stat_in0_hif_a2;  /* Input status of pin 'hif_a2' sampled at power-on-reset  */
  unsigned int hif_a3  : BFW_NX90_sample_at_porn_stat_in0_hif_a3;  /* Input status of pin 'hif_a3' sampled at power-on-reset  */
  unsigned int hif_a4  : BFW_NX90_sample_at_porn_stat_in0_hif_a4;  /* Input status of pin 'hif_a4' sampled at power-on-reset  */
  unsigned int hif_a5  : BFW_NX90_sample_at_porn_stat_in0_hif_a5;  /* Input status of pin 'hif_a5' sampled at power-on-reset  */
  unsigned int hif_a6  : BFW_NX90_sample_at_porn_stat_in0_hif_a6;  /* Input status of pin 'hif_a6' sampled at power-on-reset  */
  unsigned int hif_a7  : BFW_NX90_sample_at_porn_stat_in0_hif_a7;  /* Input status of pin 'hif_a7' sampled at power-on-reset  */
  unsigned int hif_a8  : BFW_NX90_sample_at_porn_stat_in0_hif_a8;  /* Input status of pin 'hif_a8' sampled at power-on-reset  */
  unsigned int hif_a9  : BFW_NX90_sample_at_porn_stat_in0_hif_a9;  /* Input status of pin 'hif_a9' sampled at power-on-reset  */
  unsigned int hif_a10 : BFW_NX90_sample_at_porn_stat_in0_hif_a10; /* Input status of pin 'hif_a10' sampled at power-on-reset */
  unsigned int hif_a11 : BFW_NX90_sample_at_porn_stat_in0_hif_a11; /* Input status of pin 'hif_a11' sampled at power-on-reset */
  unsigned int hif_a12 : BFW_NX90_sample_at_porn_stat_in0_hif_a12; /* Input status of pin 'hif_a12' sampled at power-on-reset */
  unsigned int hif_a13 : BFW_NX90_sample_at_porn_stat_in0_hif_a13; /* Input status of pin 'hif_a13' sampled at power-on-reset */
  unsigned int hif_a14 : BFW_NX90_sample_at_porn_stat_in0_hif_a14; /* Input status of pin 'hif_a14' sampled at power-on-reset */
  unsigned int hif_a15 : BFW_NX90_sample_at_porn_stat_in0_hif_a15; /* Input status of pin 'hif_a15' sampled at power-on-reset */
} NX90_SAMPLE_AT_PORN_STAT_IN0_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_SAMPLE_AT_PORN_STAT_IN0_BIT_T bf;
} NX90_SAMPLE_AT_PORN_STAT_IN0_T;

/* --------------------------------------------------------------------- */
/* Register sample_at_porn_stat_in1 */
/* => Status of inputs sampled at power-on-reset (PORn) register 1. */
/*    This register shows the status of the inputs sampled at power-on-reset. It will not change on normal system reset. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_sample_at_porn_stat_in1                 0x00000004U
#define Adr_NX90_sample_at_porn_stat_sample_at_porn_stat_in1 0xFF401684U
#define Adr_NX90_sample_at_porn_stat_in1                     0xFF401684U

#define MSK_NX90_sample_at_porn_stat_in1_hif_a16   0x00000001U
#define SRT_NX90_sample_at_porn_stat_in1_hif_a16   0
#define MSK_NX90_sample_at_porn_stat_in1_hif_a17   0x00000002U
#define SRT_NX90_sample_at_porn_stat_in1_hif_a17   1
#define MSK_NX90_sample_at_porn_stat_in1_hif_bhen  0x00000004U
#define SRT_NX90_sample_at_porn_stat_in1_hif_bhen  2
#define MSK_NX90_sample_at_porn_stat_in1_hif_rdn   0x00000008U
#define SRT_NX90_sample_at_porn_stat_in1_hif_rdn   3
#define MSK_NX90_sample_at_porn_stat_in1_hif_wrn   0x00000010U
#define SRT_NX90_sample_at_porn_stat_in1_hif_wrn   4
#define MSK_NX90_sample_at_porn_stat_in1_hif_csn   0x00000020U
#define SRT_NX90_sample_at_porn_stat_in1_hif_csn   5
#define MSK_NX90_sample_at_porn_stat_in1_hif_rdy   0x00000040U
#define SRT_NX90_sample_at_porn_stat_in1_hif_rdy   6
#define MSK_NX90_sample_at_porn_stat_in1_hif_dirq  0x00000080U
#define SRT_NX90_sample_at_porn_stat_in1_hif_dirq  7
#define MSK_NX90_sample_at_porn_stat_in1_hif_sdclk 0x00000100U
#define SRT_NX90_sample_at_porn_stat_in1_hif_sdclk 8
#define MSK_NX90_sample_at_porn_stat_in1_rdy_n     0x00000200U
#define SRT_NX90_sample_at_porn_stat_in1_rdy_n     9
#define MSK_NX90_sample_at_porn_stat_in1_run_n     0x00000400U
#define SRT_NX90_sample_at_porn_stat_in1_run_n     10
#define MSK_NX90_sample_at_porn_stat_in1_sqi_clk   0x00000800U
#define SRT_NX90_sample_at_porn_stat_in1_sqi_clk   11
#define MSK_NX90_sample_at_porn_stat_in1_sqi_cs0n  0x00001000U
#define SRT_NX90_sample_at_porn_stat_in1_sqi_cs0n  12
#define MSK_NX90_sample_at_porn_stat_in1_sqi_mosi  0x00002000U
#define SRT_NX90_sample_at_porn_stat_in1_sqi_mosi  13
#define MSK_NX90_sample_at_porn_stat_in1_sqi_miso  0x00004000U
#define SRT_NX90_sample_at_porn_stat_in1_sqi_miso  14
#define MSK_NX90_sample_at_porn_stat_in1_sqi_sio2  0x00008000U
#define SRT_NX90_sample_at_porn_stat_in1_sqi_sio2  15
#define MSK_NX90_sample_at_porn_stat_in1_sqi_sio3  0x00010000U
#define SRT_NX90_sample_at_porn_stat_in1_sqi_sio3  16

/* all used bits of 'NX90_sample_at_porn_stat_in1': */
#define MSK_USED_BITS_NX90_sample_at_porn_stat_in1 0x0001ffffU

enum {
  BFW_NX90_sample_at_porn_stat_in1_hif_a16   = 1,  /* [0] */
  BFW_NX90_sample_at_porn_stat_in1_hif_a17   = 1,  /* [1] */
  BFW_NX90_sample_at_porn_stat_in1_hif_bhen  = 1,  /* [2] */
  BFW_NX90_sample_at_porn_stat_in1_hif_rdn   = 1,  /* [3] */
  BFW_NX90_sample_at_porn_stat_in1_hif_wrn   = 1,  /* [4] */
  BFW_NX90_sample_at_porn_stat_in1_hif_csn   = 1,  /* [5] */
  BFW_NX90_sample_at_porn_stat_in1_hif_rdy   = 1,  /* [6] */
  BFW_NX90_sample_at_porn_stat_in1_hif_dirq  = 1,  /* [7] */
  BFW_NX90_sample_at_porn_stat_in1_hif_sdclk = 1,  /* [8] */
  BFW_NX90_sample_at_porn_stat_in1_rdy_n     = 1,  /* [9] */
  BFW_NX90_sample_at_porn_stat_in1_run_n     = 1,  /* [10] */
  BFW_NX90_sample_at_porn_stat_in1_sqi_clk   = 1,  /* [11] */
  BFW_NX90_sample_at_porn_stat_in1_sqi_cs0n  = 1,  /* [12] */
  BFW_NX90_sample_at_porn_stat_in1_sqi_mosi  = 1,  /* [13] */
  BFW_NX90_sample_at_porn_stat_in1_sqi_miso  = 1,  /* [14] */
  BFW_NX90_sample_at_porn_stat_in1_sqi_sio2  = 1,  /* [15] */
  BFW_NX90_sample_at_porn_stat_in1_sqi_sio3  = 1,  /* [16] */
  BFW_NX90_sample_at_porn_stat_in1_reserved1 = 15  /* [31:17] */
};

typedef struct NX90_SAMPLE_AT_PORN_STAT_IN1_BIT_Ttag {
  unsigned int hif_a16   : BFW_NX90_sample_at_porn_stat_in1_hif_a16;   /* Input status of pin 'hif_a16' sampled at power-on-reset   */
  unsigned int hif_a17   : BFW_NX90_sample_at_porn_stat_in1_hif_a17;   /* Input status of pin 'hif_a17' sampled at power-on-reset   */
  unsigned int hif_bhen  : BFW_NX90_sample_at_porn_stat_in1_hif_bhen;  /* Input status of pin 'hif_bhen' sampled at power-on-reset  */
  unsigned int hif_rdn   : BFW_NX90_sample_at_porn_stat_in1_hif_rdn;   /* Input status of pin 'hif_rdn' sampled at power-on-reset   */
  unsigned int hif_wrn   : BFW_NX90_sample_at_porn_stat_in1_hif_wrn;   /* Input status of pin 'hif_wrn' sampled at power-on-reset   */
  unsigned int hif_csn   : BFW_NX90_sample_at_porn_stat_in1_hif_csn;   /* Input status of pin 'hif_csn' sampled at power-on-reset   */
  unsigned int hif_rdy   : BFW_NX90_sample_at_porn_stat_in1_hif_rdy;   /* Input status of pin 'hif_rdy' sampled at power-on-reset   */
  unsigned int hif_dirq  : BFW_NX90_sample_at_porn_stat_in1_hif_dirq;  /* Input status of pin 'hif_dirq' sampled at power-on-reset  */
  unsigned int hif_sdclk : BFW_NX90_sample_at_porn_stat_in1_hif_sdclk; /* Input status of pin 'hif_sdclk' sampled at power-on-reset */
  unsigned int rdy_n     : BFW_NX90_sample_at_porn_stat_in1_rdy_n;     /* Input status of pin 'rdy_n' sampled at power-on-reset     */
  unsigned int run_n     : BFW_NX90_sample_at_porn_stat_in1_run_n;     /* Input status of pin 'run_n' sampled at power-on-reset     */
  unsigned int sqi_clk   : BFW_NX90_sample_at_porn_stat_in1_sqi_clk;   /* Input status of pin 'sqi_clk' sampled at power-on-reset   */
  unsigned int sqi_cs0n  : BFW_NX90_sample_at_porn_stat_in1_sqi_cs0n;  /* Input status of pin 'sqi_cs0n' sampled at power-on-reset  */
  unsigned int sqi_mosi  : BFW_NX90_sample_at_porn_stat_in1_sqi_mosi;  /* Input status of pin 'sqi_mosi' sampled at power-on-reset  */
  unsigned int sqi_miso  : BFW_NX90_sample_at_porn_stat_in1_sqi_miso;  /* Input status of pin 'sqi_miso' sampled at power-on-reset  */
  unsigned int sqi_sio2  : BFW_NX90_sample_at_porn_stat_in1_sqi_sio2;  /* Input status of pin 'sqi_sio2' sampled at power-on-reset  */
  unsigned int sqi_sio3  : BFW_NX90_sample_at_porn_stat_in1_sqi_sio3;  /* Input status of pin 'sqi_sio3' sampled at power-on-reset  */
  unsigned int reserved1 : BFW_NX90_sample_at_porn_stat_in1_reserved1; /* reserved                                                  */
} NX90_SAMPLE_AT_PORN_STAT_IN1_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_SAMPLE_AT_PORN_STAT_IN1_BIT_T bf;
} NX90_SAMPLE_AT_PORN_STAT_IN1_T;


/* ===================================================================== */

/* Area of adc_seq */

/* ===================================================================== */

#define Addr_NX90_adc_seq 0xFF4016C0U

/* --------------------------------------------------------------------- */
/* Register adc_seq_start */
/* => ADC start register: */
/*    The bits start_adc0 and start_adc1 are write enables for the preceeding bits, respectively. */
/*    Setting one or both of these bits to 1 starts ADC control state machine for the appropriate ADC */
/*    using the configuration defined by the preceeding bits (sel_adc, ref_adc, tt_add_adc). */
/*    The configuration bits can only be changed in the write cycles starting the appropriate ADC. */
/*    This register is writable but can also be changed by hardware (reset). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_start     0x00000000U
#define Adr_NX90_adc_seq_adc_seq_start 0xFF4016C0U
#define Adr_NX90_adc_seq_start         0xFF4016C0U
#define DFLT_VAL_NX90_adc_seq_start    0x00060006U

#define MSK_NX90_adc_seq_start_start_adc0          0x00000001U
#define SRT_NX90_adc_seq_start_start_adc0          0
#define DFLT_VAL_NX90_adc_seq_start_start_adc0     0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_start_start_adc0  0x00000000U
#define MSK_NX90_adc_seq_start_sel_adc0            0x00000006U
#define SRT_NX90_adc_seq_start_sel_adc0            1
#define DFLT_VAL_NX90_adc_seq_start_sel_adc0       0x00000006U
#define DFLT_BF_VAL_NX90_adc_seq_start_sel_adc0    0x00000003U
#define MSK_NX90_adc_seq_start_ref_adc0            0x00000008U
#define SRT_NX90_adc_seq_start_ref_adc0            3
#define DFLT_VAL_NX90_adc_seq_start_ref_adc0       0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_start_ref_adc0    0x00000000U
#define MSK_NX90_adc_seq_start_tt_add_adc0         0x000003f0U
#define SRT_NX90_adc_seq_start_tt_add_adc0         4
#define DFLT_VAL_NX90_adc_seq_start_tt_add_adc0    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_start_tt_add_adc0 0x00000000U
#define MSK_NX90_adc_seq_start_start_adc1          0x00010000U
#define SRT_NX90_adc_seq_start_start_adc1          16
#define DFLT_VAL_NX90_adc_seq_start_start_adc1     0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_start_start_adc1  0x00000000U
#define MSK_NX90_adc_seq_start_sel_adc1            0x00060000U
#define SRT_NX90_adc_seq_start_sel_adc1            17
#define DFLT_VAL_NX90_adc_seq_start_sel_adc1       0x00060000U
#define DFLT_BF_VAL_NX90_adc_seq_start_sel_adc1    0x00000003U
#define MSK_NX90_adc_seq_start_ref_adc1            0x00080000U
#define SRT_NX90_adc_seq_start_ref_adc1            19
#define DFLT_VAL_NX90_adc_seq_start_ref_adc1       0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_start_ref_adc1    0x00000000U
#define MSK_NX90_adc_seq_start_tt_add_adc1         0x03f00000U
#define SRT_NX90_adc_seq_start_tt_add_adc1         20
#define DFLT_VAL_NX90_adc_seq_start_tt_add_adc1    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_start_tt_add_adc1 0x00000000U

/* all used bits of 'NX90_adc_seq_start': */
#define MSK_USED_BITS_NX90_adc_seq_start 0x03ff03ffU

enum {
  BFW_NX90_adc_seq_start_start_adc0  = 1, /* [0] */
  BFW_NX90_adc_seq_start_sel_adc0    = 2, /* [2:1] */
  BFW_NX90_adc_seq_start_ref_adc0    = 1, /* [3] */
  BFW_NX90_adc_seq_start_tt_add_adc0 = 6, /* [9:4] */
  BFW_NX90_adc_seq_start_reserved1   = 6, /* [15:10] */
  BFW_NX90_adc_seq_start_start_adc1  = 1, /* [16] */
  BFW_NX90_adc_seq_start_sel_adc1    = 2, /* [18:17] */
  BFW_NX90_adc_seq_start_ref_adc1    = 1, /* [19] */
  BFW_NX90_adc_seq_start_tt_add_adc1 = 6, /* [25:20] */
  BFW_NX90_adc_seq_start_reserved2   = 6  /* [31:26] */
};

typedef struct NX90_ADC_SEQ_START_BIT_Ttag {
  unsigned int start_adc0  : BFW_NX90_adc_seq_start_start_adc0;  /* Start ADC0:                                                               */
                                                                 /* Setting this bit to 1 starts ADC control state machine for ADC0.          */
                                                                 /* It will reset automatically after sampling phase.                         */
                                                                 /* If it is reset, it can be set for next conversion.                        */
                                                                 /* If start_adc0 and start_adc1 are set, the next conversion will be started */
                                                                 /* after both ADCs are finished. Otherwise the next conversion will start    */
                                                                 /* directly after current conversion of ADC0 is finished.                    */
  unsigned int sel_adc0    : BFW_NX90_adc_seq_start_sel_adc0;    /* Multiplexer Input Select of ADC0:                                         */
                                                                 /* 00: Vin0                                                                  */
                                                                 /* 01: Vin1                                                                  */
                                                                 /* 10: Temperature Diode                                                     */
                                                                 /* 11: Vref                                                                  */
  unsigned int ref_adc0    : BFW_NX90_adc_seq_start_ref_adc0;    /* Reference Select of ADC0:                                                 */
                                                                 /* 0: use internal reference                                                 */
                                                                 /* 1: use VREF_ADC as reference                                              */
  unsigned int tt_add_adc0 : BFW_NX90_adc_seq_start_tt_add_adc0; /* Tracking Time Addon of ADC0:                                              */
                                                                 /* Time that 3rd ADC_CLK edge is delayed (in steps of cfg_clock-period).     */
                                                                 /* The capacitor inside ADC needs time to be charged depending               */
                                                                 /* on the driving strength of the external signal.                           */
                                                                 /* For 12 bit precision, this time should be 9*(Rint+Rext)*C,                */
                                                                 /* with Rint=1kOhm and C=7.5pF.                                              */
                                                                 /* The ADC already waits for 2 ADC_CLK cycles, so the total formular         */
                                                                 /* for this value is:                                                        */
                                                                 /* tt_add = ceil((((67,5pF x Rext) + 67,5ns) / period) - 2)                  */
                                                                 /* Set tt_add=0 if calculated value is negative.                             */
  unsigned int reserved1   : BFW_NX90_adc_seq_start_reserved1;   /* reserved                                                                  */
  unsigned int start_adc1  : BFW_NX90_adc_seq_start_start_adc1;  /* Start ADC1:                                                               */
                                                                 /* Setting this bit to 1 starts ADC control state machine for ADC1.          */
                                                                 /* It will reset automatically after sampling phase.                         */
                                                                 /* If it is reset, it can be set for next conversion.                        */
                                                                 /* If start_adc0 and start_adc1 are set, the next conversion will be started */
                                                                 /* after both ADCs are finished. Otherwise the next conversion will start    */
                                                                 /* directly after current conversion of ADC1 is finished.                    */
  unsigned int sel_adc1    : BFW_NX90_adc_seq_start_sel_adc1;    /* Multiplexer Input Select of ADC1:                                         */
                                                                 /* 00: Vin2                                                                  */
                                                                 /* 01: Vin3                                                                  */
                                                                 /* 10: Vref/2 (for voltage monitoring)                                       */
                                                                 /* 11: Vref                                                                  */
  unsigned int ref_adc1    : BFW_NX90_adc_seq_start_ref_adc1;    /* Reference Select of ADC1:                                                 */
                                                                 /* 0: use internal reference                                                 */
                                                                 /* 1: use VREF_ADC as reference                                              */
  unsigned int tt_add_adc1 : BFW_NX90_adc_seq_start_tt_add_adc1; /* Tracking Time Addon of ADC1:                                              */
                                                                 /* Time that 3rd ADC_CLK edge is delayed (in steps of cfg_clock-period).     */
                                                                 /* The capacitor inside ADC needs time to be charged depending               */
                                                                 /* on the driving strength of the external signal.                           */
                                                                 /* For 12 bit precision, this time should be 9*(Rint+Rext)*C,                */
                                                                 /* with Rint=1kOhm and C=7.5pF.                                              */
                                                                 /* The ADC already waits for 2 ADC_CLK cycles, so the total formular         */
                                                                 /* for this value is:                                                        */
                                                                 /* tt_add = ceil((((67,5pF x Rext) + 67,5ns) / period) - 2)                  */
                                                                 /* Set tt_add=0 if calculated value is negative.                             */
  unsigned int reserved2   : BFW_NX90_adc_seq_start_reserved2;   /* reserved                                                                  */
} NX90_ADC_SEQ_START_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_ADC_SEQ_START_BIT_T bf;
} NX90_ADC_SEQ_START_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_cfg */
/* => ADC general config register: */
/*    This register is for static config values of ADC. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_cfg     0x00000004U
#define Adr_NX90_adc_seq_adc_seq_cfg 0xFF4016C4U
#define Adr_NX90_adc_seq_cfg         0xFF4016C4U
#define DFLT_VAL_NX90_adc_seq_cfg    0x00000000U

#define MSK_NX90_adc_seq_cfg_enable                                    0x00000001U
#define SRT_NX90_adc_seq_cfg_enable                                    0
#define DFLT_VAL_NX90_adc_seq_cfg_enable                               0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_cfg_enable                            0x00000000U
#define MSK_NX90_adc_seq_cfg_reset_n                                   0x00000002U
#define SRT_NX90_adc_seq_cfg_reset_n                                   1
#define DFLT_VAL_NX90_adc_seq_cfg_reset_n                              0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_cfg_reset_n                           0x00000000U
#define MSK_NX90_adc_seq_cfg_buffer_enable                             0x00000004U
#define SRT_NX90_adc_seq_cfg_buffer_enable                             2
#define DFLT_VAL_NX90_adc_seq_cfg_buffer_enable                        0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_cfg_buffer_enable                     0x00000000U
#define MSK_NX90_adc_seq_cfg_debug                                     0x00000008U
#define SRT_NX90_adc_seq_cfg_debug                                     3
#define DFLT_VAL_NX90_adc_seq_cfg_debug                                0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_cfg_debug                             0x00000000U
#define MSK_NX90_adc_seq_cfg_sync_sample_start_if_restart_both         0x00000010U
#define SRT_NX90_adc_seq_cfg_sync_sample_start_if_restart_both         4
#define DFLT_VAL_NX90_adc_seq_cfg_sync_sample_start_if_restart_both    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_cfg_sync_sample_start_if_restart_both 0x00000000U

/* all used bits of 'NX90_adc_seq_cfg': */
#define MSK_USED_BITS_NX90_adc_seq_cfg 0x0000001fU

enum {
  BFW_NX90_adc_seq_cfg_enable                            = 1,  /* [0] */
  BFW_NX90_adc_seq_cfg_reset_n                           = 1,  /* [1] */
  BFW_NX90_adc_seq_cfg_buffer_enable                     = 1,  /* [2] */
  BFW_NX90_adc_seq_cfg_debug                             = 1,  /* [3] */
  BFW_NX90_adc_seq_cfg_sync_sample_start_if_restart_both = 1,  /* [4] */
  BFW_NX90_adc_seq_cfg_reserved1                         = 27  /* [31:5] */
};

typedef struct NX90_ADC_SEQ_CFG_BIT_Ttag {
  unsigned int enable                            : BFW_NX90_adc_seq_cfg_enable;                            /* Power-down mode of ADC:                                                  */
                                                                                                           /* 1: Enable ADC (Power up)                                                 */
                                                                                                           /* 0: Disable ADC (Power-down)                                              */
  unsigned int reset_n                           : BFW_NX90_adc_seq_cfg_reset_n;                           /* Low active reset of ADC and state machine:                               */
                                                                                                           /* There are no constraints on reset length.                                */
                                                                                                           /* 1: Soft-Reset is inactive.                                               */
                                                                                                           /* 0: Soft-Reset is active.                                                 */
  unsigned int buffer_enable                     : BFW_NX90_adc_seq_cfg_buffer_enable;                     /* Enable of Vref at ADCs                                                   */
  unsigned int debug                             : BFW_NX90_adc_seq_cfg_debug;                             /* Debug mode:                                                              */
                                                                                                           /* Activate Debug Mode, which directly controls ADC via debug register.     */
                                                                                                           /* 1: Debug Mode is active.                                                 */
                                                                                                           /* 0: Debug is inactive.                                                    */
  unsigned int sync_sample_start_if_restart_both : BFW_NX90_adc_seq_cfg_sync_sample_start_if_restart_both; /* Synchronous start of sampling at restart of both ADCs:                   */
                                                                                                           /* This option should be activated for debug purposes only!                 */
                                                                                                           /* Due to cfg_clock-adc1_shift the sampling times of ADC0 and ADC1 might be */
                                                                                                           /* a bit longer than defined in start-tt_add_adc1.                          */
                                                                                                           /* The difference is in the beginning of the sampling phase. Both ADCs will */
                                                                                                           /* always finish their sampling phase synchronously.                        */
                                                                                                           /* To overcome this unbeautiful behaviour, this mode allows to include      */
                                                                                                           /* a wait state between data-output and start-of-sample.                    */
                                                                                                           /* It will only affect the case, where both ADCs are started in parallel.   */
                                                                                                           /* This mode reduces the max. sampling rate by ~15% and should be activated */
                                                                                                           /* for debug purposes only!                                                 */
  unsigned int reserved1                         : BFW_NX90_adc_seq_cfg_reserved1;                         /* reserved                                                                 */
} NX90_ADC_SEQ_CFG_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ADC_SEQ_CFG_BIT_T bf;
} NX90_ADC_SEQ_CFG_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_cfg_clock */
/* => ADC config register for ADC clock (same for both ADCs): */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_cfg_clock     0x00000008U
#define Adr_NX90_adc_seq_adc_seq_cfg_clock 0xFF4016C8U
#define Adr_NX90_adc_seq_cfg_clock         0xFF4016C8U
#define DFLT_VAL_NX90_adc_seq_cfg_clock    0x0000001dU

#define MSK_NX90_adc_seq_cfg_clock_period             0x00000007U
#define SRT_NX90_adc_seq_cfg_clock_period             0
#define DFLT_VAL_NX90_adc_seq_cfg_clock_period        0x00000005U
#define DFLT_BF_VAL_NX90_adc_seq_cfg_clock_period     0x00000005U
#define MSK_NX90_adc_seq_cfg_clock_adc1_shift         0x00000038U
#define SRT_NX90_adc_seq_cfg_clock_adc1_shift         3
#define DFLT_VAL_NX90_adc_seq_cfg_clock_adc1_shift    0x00000018U
#define DFLT_BF_VAL_NX90_adc_seq_cfg_clock_adc1_shift 0x00000003U

/* all used bits of 'NX90_adc_seq_cfg_clock': */
#define MSK_USED_BITS_NX90_adc_seq_cfg_clock 0x0000003fU

enum {
  BFW_NX90_adc_seq_cfg_clock_period     = 3,  /* [2:0] */
  BFW_NX90_adc_seq_cfg_clock_adc1_shift = 3,  /* [5:3] */
  BFW_NX90_adc_seq_cfg_clock_reserved1  = 26  /* [31:6] */
};

typedef struct NX90_ADC_SEQ_CFG_CLOCK_BIT_Ttag {
  unsigned int period     : BFW_NX90_adc_seq_cfg_clock_period;     /* Clock Period:                                                  */
                                                                   /* 000: 20ns                                                      */
                                                                   /* 001: 30ns                                                      */
                                                                   /* 010: 40ns                                                      */
                                                                   /* 011: 50ns                                                      */
                                                                   /* 100: 60ns                                                      */
                                                                   /* 101: 70ns                                                      */
                                                                   /* 110: 80ns                                                      */
                                                                   /* 111: 90ns                                                      */
  unsigned int adc1_shift : BFW_NX90_adc_seq_cfg_clock_adc1_shift; /* ADC1 Shift:                                                    */
                                                                   /* To avoid cross-talk the posedge of ADC1 will be shifted.       */
                                                                   /* This happens only during conversion (4..15th ADC_CLK posedge). */
                                                                   /* ADC1 Shift must be smaller than Clock Period!                  */
                                                                   /* 000: 0ns                                                       */
                                                                   /* 001: 10ns                                                      */
                                                                   /* 010: 20ns                                                      */
                                                                   /* 011: 30ns                                                      */
                                                                   /* 100: 40ns                                                      */
                                                                   /* 101: 50ns                                                      */
                                                                   /* 110: 60ns                                                      */
                                                                   /* 111: 70ns                                                      */
  unsigned int reserved1  : BFW_NX90_adc_seq_cfg_clock_reserved1;  /* reserved                                                       */
} NX90_ADC_SEQ_CFG_CLOCK_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_ADC_SEQ_CFG_CLOCK_BIT_T bf;
} NX90_ADC_SEQ_CFG_CLOCK_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_status */
/* => ADC status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_status     0x0000000CU
#define Adr_NX90_adc_seq_adc_seq_status 0xFF4016CCU
#define Adr_NX90_adc_seq_status         0xFF4016CCU

#define MSK_NX90_adc_seq_status_adc0_sample       0x00000001U
#define SRT_NX90_adc_seq_status_adc0_sample       0
#define MSK_NX90_adc_seq_status_adc1_sample       0x00000002U
#define SRT_NX90_adc_seq_status_adc1_sample       1
#define MSK_NX90_adc_seq_status_adc0_running      0x00000004U
#define SRT_NX90_adc_seq_status_adc0_running      2
#define MSK_NX90_adc_seq_status_adc1_running      0x00000008U
#define SRT_NX90_adc_seq_status_adc1_running      3
#define MSK_NX90_adc_seq_status_adc0_data         0x00000010U
#define SRT_NX90_adc_seq_status_adc0_data         4
#define MSK_NX90_adc_seq_status_adc1_data         0x00000020U
#define SRT_NX90_adc_seq_status_adc1_data         5
#define MSK_NX90_adc_seq_status_adc_clock_running 0x00000040U
#define SRT_NX90_adc_seq_status_adc_clock_running 6

/* all used bits of 'NX90_adc_seq_status': */
#define MSK_USED_BITS_NX90_adc_seq_status 0x0000007fU

enum {
  BFW_NX90_adc_seq_status_adc0_sample       = 1,  /* [0] */
  BFW_NX90_adc_seq_status_adc1_sample       = 1,  /* [1] */
  BFW_NX90_adc_seq_status_adc0_running      = 1,  /* [2] */
  BFW_NX90_adc_seq_status_adc1_running      = 1,  /* [3] */
  BFW_NX90_adc_seq_status_adc0_data         = 1,  /* [4] */
  BFW_NX90_adc_seq_status_adc1_data         = 1,  /* [5] */
  BFW_NX90_adc_seq_status_adc_clock_running = 1,  /* [6] */
  BFW_NX90_adc_seq_status_reserved1         = 25  /* [31:7] */
};

typedef struct NX90_ADC_SEQ_STATUS_BIT_Ttag {
  unsigned int adc0_sample       : BFW_NX90_adc_seq_status_adc0_sample;       /* ADC0 is sampling data.                                               */
  unsigned int adc1_sample       : BFW_NX90_adc_seq_status_adc1_sample;       /* ADC1 is sampling data                                                */
  unsigned int adc0_running      : BFW_NX90_adc_seq_status_adc0_running;      /* ADC0 is running.                                                     */
  unsigned int adc1_running      : BFW_NX90_adc_seq_status_adc1_running;      /* ADC1 is running.                                                     */
  unsigned int adc0_data         : BFW_NX90_adc_seq_status_adc0_data;         /* ADC0 data is ready to be read. Reset automatically at read of data0. */
  unsigned int adc1_data         : BFW_NX90_adc_seq_status_adc1_data;         /* ADC1 data is ready to be read. Reset automatically at read of data1. */
  unsigned int adc_clock_running : BFW_NX90_adc_seq_status_adc_clock_running; /* at least one ADC_CLK is running                                      */
  unsigned int reserved1         : BFW_NX90_adc_seq_status_reserved1;         /* reserved                                                             */
} NX90_ADC_SEQ_STATUS_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_ADC_SEQ_STATUS_BIT_T bf;
} NX90_ADC_SEQ_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_adc_data0 */
/* => ADC0 value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_adc_data0     0x00000010U
#define Adr_NX90_adc_seq_adc_seq_adc_data0 0xFF4016D0U
#define Adr_NX90_adc_seq_adc_data0         0xFF4016D0U

#define MSK_NX90_adc_seq_adc_data0_val 0x00000fffU
#define SRT_NX90_adc_seq_adc_data0_val 0

/* all used bits of 'NX90_adc_seq_adc_data0': */
#define MSK_USED_BITS_NX90_adc_seq_adc_data0 0x00000fffU

enum {
  BFW_NX90_adc_seq_adc_data0_val       = 12, /* [11:0] */
  BFW_NX90_adc_seq_adc_data0_reserved1 = 20  /* [31:12] */
};

typedef struct NX90_ADC_SEQ_ADC_DATA0_BIT_Ttag {
  unsigned int val       : BFW_NX90_adc_seq_adc_data0_val;       /* Sampled value */
  unsigned int reserved1 : BFW_NX90_adc_seq_adc_data0_reserved1; /* reserved      */
} NX90_ADC_SEQ_ADC_DATA0_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_ADC_SEQ_ADC_DATA0_BIT_T bf;
} NX90_ADC_SEQ_ADC_DATA0_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_adc_data1 */
/* => ADC1 value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_adc_data1     0x00000014U
#define Adr_NX90_adc_seq_adc_seq_adc_data1 0xFF4016D4U
#define Adr_NX90_adc_seq_adc_data1         0xFF4016D4U

#define MSK_NX90_adc_seq_adc_data1_val 0x00000fffU
#define SRT_NX90_adc_seq_adc_data1_val 0

/* all used bits of 'NX90_adc_seq_adc_data1': */
#define MSK_USED_BITS_NX90_adc_seq_adc_data1 0x00000fffU

enum {
  BFW_NX90_adc_seq_adc_data1_val       = 12, /* [11:0] */
  BFW_NX90_adc_seq_adc_data1_reserved1 = 20  /* [31:12] */
};

typedef struct NX90_ADC_SEQ_ADC_DATA1_BIT_Ttag {
  unsigned int val       : BFW_NX90_adc_seq_adc_data1_val;       /* Sampled value */
  unsigned int reserved1 : BFW_NX90_adc_seq_adc_data1_reserved1; /* reserved      */
} NX90_ADC_SEQ_ADC_DATA1_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_ADC_SEQ_ADC_DATA1_BIT_T bf;
} NX90_ADC_SEQ_ADC_DATA1_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_debug */
/* => Debug Mode register: */
/*    If cgf-debug is enabled, this register directly controls inputs of both ADCs. */
/*    Output data of both ADCs will still be at data0 and data1. */
/*    In debug mode, a software reset (cfg-reset_n) will not influence these values (only directly signal ADC_NRES). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_debug     0x00000018U
#define Adr_NX90_adc_seq_adc_seq_debug 0xFF4016D8U
#define Adr_NX90_adc_seq_debug         0xFF4016D8U
#define DFLT_VAL_NX90_adc_seq_debug    0x00004040U

#define MSK_NX90_adc_seq_debug_adc0_clk                  0x00000001U
#define SRT_NX90_adc_seq_debug_adc0_clk                  0
#define DFLT_VAL_NX90_adc_seq_debug_adc0_clk             0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc0_clk          0x00000000U
#define MSK_NX90_adc_seq_debug_adc0_soc                  0x00000002U
#define SRT_NX90_adc_seq_debug_adc0_soc                  1
#define DFLT_VAL_NX90_adc_seq_debug_adc0_soc             0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc0_soc          0x00000000U
#define MSK_NX90_adc_seq_debug_adc0_use_ref_vdd3         0x00000004U
#define SRT_NX90_adc_seq_debug_adc0_use_ref_vdd3         2
#define DFLT_VAL_NX90_adc_seq_debug_adc0_use_ref_vdd3    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc0_use_ref_vdd3 0x00000000U
#define MSK_NX90_adc_seq_debug_adc0_set_mux0             0x00000008U
#define SRT_NX90_adc_seq_debug_adc0_set_mux0             3
#define DFLT_VAL_NX90_adc_seq_debug_adc0_set_mux0        0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc0_set_mux0     0x00000000U
#define MSK_NX90_adc_seq_debug_adc0_set_mux1             0x00000010U
#define SRT_NX90_adc_seq_debug_adc0_set_mux1             4
#define DFLT_VAL_NX90_adc_seq_debug_adc0_set_mux1        0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc0_set_mux1     0x00000000U
#define MSK_NX90_adc_seq_debug_adc0_set_mux2             0x00000020U
#define SRT_NX90_adc_seq_debug_adc0_set_mux2             5
#define DFLT_VAL_NX90_adc_seq_debug_adc0_set_mux2        0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc0_set_mux2     0x00000000U
#define MSK_NX90_adc_seq_debug_adc0_set_mux3             0x00000040U
#define SRT_NX90_adc_seq_debug_adc0_set_mux3             6
#define DFLT_VAL_NX90_adc_seq_debug_adc0_set_mux3        0x00000040U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc0_set_mux3     0x00000001U
#define MSK_NX90_adc_seq_debug_adc1_clk                  0x00000100U
#define SRT_NX90_adc_seq_debug_adc1_clk                  8
#define DFLT_VAL_NX90_adc_seq_debug_adc1_clk             0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc1_clk          0x00000000U
#define MSK_NX90_adc_seq_debug_adc1_soc                  0x00000200U
#define SRT_NX90_adc_seq_debug_adc1_soc                  9
#define DFLT_VAL_NX90_adc_seq_debug_adc1_soc             0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc1_soc          0x00000000U
#define MSK_NX90_adc_seq_debug_adc1_use_ref_vdd3         0x00000400U
#define SRT_NX90_adc_seq_debug_adc1_use_ref_vdd3         10
#define DFLT_VAL_NX90_adc_seq_debug_adc1_use_ref_vdd3    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc1_use_ref_vdd3 0x00000000U
#define MSK_NX90_adc_seq_debug_adc1_set_mux0             0x00000800U
#define SRT_NX90_adc_seq_debug_adc1_set_mux0             11
#define DFLT_VAL_NX90_adc_seq_debug_adc1_set_mux0        0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc1_set_mux0     0x00000000U
#define MSK_NX90_adc_seq_debug_adc1_set_mux1             0x00001000U
#define SRT_NX90_adc_seq_debug_adc1_set_mux1             12
#define DFLT_VAL_NX90_adc_seq_debug_adc1_set_mux1        0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc1_set_mux1     0x00000000U
#define MSK_NX90_adc_seq_debug_adc1_set_mux2             0x00002000U
#define SRT_NX90_adc_seq_debug_adc1_set_mux2             13
#define DFLT_VAL_NX90_adc_seq_debug_adc1_set_mux2        0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc1_set_mux2     0x00000000U
#define MSK_NX90_adc_seq_debug_adc1_set_mux3             0x00004000U
#define SRT_NX90_adc_seq_debug_adc1_set_mux3             14
#define DFLT_VAL_NX90_adc_seq_debug_adc1_set_mux3        0x00004000U
#define DFLT_BF_VAL_NX90_adc_seq_debug_adc1_set_mux3     0x00000001U

/* all used bits of 'NX90_adc_seq_debug': */
#define MSK_USED_BITS_NX90_adc_seq_debug 0x00007f7fU

enum {
  BFW_NX90_adc_seq_debug_adc0_clk          = 1,  /* [0] */
  BFW_NX90_adc_seq_debug_adc0_soc          = 1,  /* [1] */
  BFW_NX90_adc_seq_debug_adc0_use_ref_vdd3 = 1,  /* [2] */
  BFW_NX90_adc_seq_debug_adc0_set_mux0     = 1,  /* [3] */
  BFW_NX90_adc_seq_debug_adc0_set_mux1     = 1,  /* [4] */
  BFW_NX90_adc_seq_debug_adc0_set_mux2     = 1,  /* [5] */
  BFW_NX90_adc_seq_debug_adc0_set_mux3     = 1,  /* [6] */
  BFW_NX90_adc_seq_debug_reserved1         = 1,  /* [7] */
  BFW_NX90_adc_seq_debug_adc1_clk          = 1,  /* [8] */
  BFW_NX90_adc_seq_debug_adc1_soc          = 1,  /* [9] */
  BFW_NX90_adc_seq_debug_adc1_use_ref_vdd3 = 1,  /* [10] */
  BFW_NX90_adc_seq_debug_adc1_set_mux0     = 1,  /* [11] */
  BFW_NX90_adc_seq_debug_adc1_set_mux1     = 1,  /* [12] */
  BFW_NX90_adc_seq_debug_adc1_set_mux2     = 1,  /* [13] */
  BFW_NX90_adc_seq_debug_adc1_set_mux3     = 1,  /* [14] */
  BFW_NX90_adc_seq_debug_reserved2         = 17  /* [31:15] */
};

typedef struct NX90_ADC_SEQ_DEBUG_BIT_Ttag {
  unsigned int adc0_clk          : BFW_NX90_adc_seq_debug_adc0_clk;          /* ADC0 is sampling data.   */
  unsigned int adc0_soc          : BFW_NX90_adc_seq_debug_adc0_soc;          /* ADC0_SOC signal          */
  unsigned int adc0_use_ref_vdd3 : BFW_NX90_adc_seq_debug_adc0_use_ref_vdd3; /* ADC0_USE_REF_VDD3 signal */
  unsigned int adc0_set_mux0     : BFW_NX90_adc_seq_debug_adc0_set_mux0;     /* ADC0_SET_MUX0 signal     */
  unsigned int adc0_set_mux1     : BFW_NX90_adc_seq_debug_adc0_set_mux1;     /* ADC0_SET_MUX1 signal     */
  unsigned int adc0_set_mux2     : BFW_NX90_adc_seq_debug_adc0_set_mux2;     /* ADC0_SET_MUX2 signal     */
  unsigned int adc0_set_mux3     : BFW_NX90_adc_seq_debug_adc0_set_mux3;     /* ADC0_SET_MUX3 signal     */
  unsigned int reserved1         : BFW_NX90_adc_seq_debug_reserved1;         /* reserved                 */
  unsigned int adc1_clk          : BFW_NX90_adc_seq_debug_adc1_clk;          /* ADC1 is sampling data.   */
  unsigned int adc1_soc          : BFW_NX90_adc_seq_debug_adc1_soc;          /* ADC1_SOC signal          */
  unsigned int adc1_use_ref_vdd3 : BFW_NX90_adc_seq_debug_adc1_use_ref_vdd3; /* ADC1_USE_REF_VDD3 signal */
  unsigned int adc1_set_mux0     : BFW_NX90_adc_seq_debug_adc1_set_mux0;     /* ADC1_SET_MUX0 signal     */
  unsigned int adc1_set_mux1     : BFW_NX90_adc_seq_debug_adc1_set_mux1;     /* ADC1_SET_MUX1 signal     */
  unsigned int adc1_set_mux2     : BFW_NX90_adc_seq_debug_adc1_set_mux2;     /* ADC1_SET_MUX2 signal     */
  unsigned int adc1_set_mux3     : BFW_NX90_adc_seq_debug_adc1_set_mux3;     /* ADC1_SET_MUX3 signal     */
  unsigned int reserved2         : BFW_NX90_adc_seq_debug_reserved2;         /* reserved                 */
} NX90_ADC_SEQ_DEBUG_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_ADC_SEQ_DEBUG_BIT_T bf;
} NX90_ADC_SEQ_DEBUG_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_irq_raw */
/* => Raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_irq_raw     0x0000001CU
#define Adr_NX90_adc_seq_adc_seq_irq_raw 0xFF4016DCU
#define Adr_NX90_adc_seq_irq_raw         0xFF4016DCU
#define DFLT_VAL_NX90_adc_seq_irq_raw    0x00000000U

#define MSK_NX90_adc_seq_irq_raw_adc0_sample_finish         0x00000001U
#define SRT_NX90_adc_seq_irq_raw_adc0_sample_finish         0
#define DFLT_VAL_NX90_adc_seq_irq_raw_adc0_sample_finish    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_raw_adc0_sample_finish 0x00000000U
#define MSK_NX90_adc_seq_irq_raw_adc1_sample_finish         0x00000002U
#define SRT_NX90_adc_seq_irq_raw_adc1_sample_finish         1
#define DFLT_VAL_NX90_adc_seq_irq_raw_adc1_sample_finish    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_raw_adc1_sample_finish 0x00000000U
#define MSK_NX90_adc_seq_irq_raw_adc0_data_finish           0x00000004U
#define SRT_NX90_adc_seq_irq_raw_adc0_data_finish           2
#define DFLT_VAL_NX90_adc_seq_irq_raw_adc0_data_finish      0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_raw_adc0_data_finish   0x00000000U
#define MSK_NX90_adc_seq_irq_raw_adc1_data_finish           0x00000008U
#define SRT_NX90_adc_seq_irq_raw_adc1_data_finish           3
#define DFLT_VAL_NX90_adc_seq_irq_raw_adc1_data_finish      0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_raw_adc1_data_finish   0x00000000U

/* all used bits of 'NX90_adc_seq_irq_raw': */
#define MSK_USED_BITS_NX90_adc_seq_irq_raw 0x0000000fU

enum {
  BFW_NX90_adc_seq_irq_raw_adc0_sample_finish = 1,  /* [0] */
  BFW_NX90_adc_seq_irq_raw_adc1_sample_finish = 1,  /* [1] */
  BFW_NX90_adc_seq_irq_raw_adc0_data_finish   = 1,  /* [2] */
  BFW_NX90_adc_seq_irq_raw_adc1_data_finish   = 1,  /* [3] */
  BFW_NX90_adc_seq_irq_raw_reserved1          = 28  /* [31:4] */
};

typedef struct NX90_ADC_SEQ_IRQ_RAW_BIT_Ttag {
  unsigned int adc0_sample_finish : BFW_NX90_adc_seq_irq_raw_adc0_sample_finish; /* Sampling phase of ADC0 is finished, ADC0 can be restarted. */
  unsigned int adc1_sample_finish : BFW_NX90_adc_seq_irq_raw_adc1_sample_finish; /* Sampling phase of ADC1 is finished, ADC1 can be restarted. */
  unsigned int adc0_data_finish   : BFW_NX90_adc_seq_irq_raw_adc0_data_finish;   /* Data of ADC0 is ready to be read.                          */
  unsigned int adc1_data_finish   : BFW_NX90_adc_seq_irq_raw_adc1_data_finish;   /* Data of ADC1 is ready to be read.                          */
  unsigned int reserved1          : BFW_NX90_adc_seq_irq_raw_reserved1;          /* reserved                                                   */
} NX90_ADC_SEQ_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_ADC_SEQ_IRQ_RAW_BIT_T bf;
} NX90_ADC_SEQ_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_irq_masked */
/* => Masked IRQ: */
/*    Shows status of masked IRQs (as connected to ARM/xPIC). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_irq_masked     0x00000020U
#define Adr_NX90_adc_seq_adc_seq_irq_masked 0xFF4016E0U
#define Adr_NX90_adc_seq_irq_masked         0xFF4016E0U

#define MSK_NX90_adc_seq_irq_masked_adc0_sample_finish 0x00000001U
#define SRT_NX90_adc_seq_irq_masked_adc0_sample_finish 0
#define MSK_NX90_adc_seq_irq_masked_adc1_sample_finish 0x00000002U
#define SRT_NX90_adc_seq_irq_masked_adc1_sample_finish 1
#define MSK_NX90_adc_seq_irq_masked_adc0_data_finish   0x00000004U
#define SRT_NX90_adc_seq_irq_masked_adc0_data_finish   2
#define MSK_NX90_adc_seq_irq_masked_adc1_data_finish   0x00000008U
#define SRT_NX90_adc_seq_irq_masked_adc1_data_finish   3

/* all used bits of 'NX90_adc_seq_irq_masked': */
#define MSK_USED_BITS_NX90_adc_seq_irq_masked 0x0000000fU

enum {
  BFW_NX90_adc_seq_irq_masked_adc0_sample_finish = 1,  /* [0] */
  BFW_NX90_adc_seq_irq_masked_adc1_sample_finish = 1,  /* [1] */
  BFW_NX90_adc_seq_irq_masked_adc0_data_finish   = 1,  /* [2] */
  BFW_NX90_adc_seq_irq_masked_adc1_data_finish   = 1,  /* [3] */
  BFW_NX90_adc_seq_irq_masked_reserved1          = 28  /* [31:4] */
};

typedef struct NX90_ADC_SEQ_IRQ_MASKED_BIT_Ttag {
  unsigned int adc0_sample_finish : BFW_NX90_adc_seq_irq_masked_adc0_sample_finish; /* Sampling phase of ADC0 is finished, ADC0 can be restarted. */
  unsigned int adc1_sample_finish : BFW_NX90_adc_seq_irq_masked_adc1_sample_finish; /* Sampling phase of ADC1 is finished, ADC1 can be restarted. */
  unsigned int adc0_data_finish   : BFW_NX90_adc_seq_irq_masked_adc0_data_finish;   /* Data of ADC0 is ready to be read.                          */
  unsigned int adc1_data_finish   : BFW_NX90_adc_seq_irq_masked_adc1_data_finish;   /* Data of ADC1 is ready to be read.                          */
  unsigned int reserved1          : BFW_NX90_adc_seq_irq_masked_reserved1;          /* reserved                                                   */
} NX90_ADC_SEQ_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_ADC_SEQ_IRQ_MASKED_BIT_T bf;
} NX90_ADC_SEQ_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_irq_mask_set */
/* => IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adc_seq_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_irq_mask_set     0x00000024U
#define Adr_NX90_adc_seq_adc_seq_irq_mask_set 0xFF4016E4U
#define Adr_NX90_adc_seq_irq_mask_set         0xFF4016E4U
#define DFLT_VAL_NX90_adc_seq_irq_mask_set    0x00000000U

#define MSK_NX90_adc_seq_irq_mask_set_adc0_sample_finish         0x00000001U
#define SRT_NX90_adc_seq_irq_mask_set_adc0_sample_finish         0
#define DFLT_VAL_NX90_adc_seq_irq_mask_set_adc0_sample_finish    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_set_adc0_sample_finish 0x00000000U
#define MSK_NX90_adc_seq_irq_mask_set_adc1_sample_finish         0x00000002U
#define SRT_NX90_adc_seq_irq_mask_set_adc1_sample_finish         1
#define DFLT_VAL_NX90_adc_seq_irq_mask_set_adc1_sample_finish    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_set_adc1_sample_finish 0x00000000U
#define MSK_NX90_adc_seq_irq_mask_set_adc0_data_finish           0x00000004U
#define SRT_NX90_adc_seq_irq_mask_set_adc0_data_finish           2
#define DFLT_VAL_NX90_adc_seq_irq_mask_set_adc0_data_finish      0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_set_adc0_data_finish   0x00000000U
#define MSK_NX90_adc_seq_irq_mask_set_adc1_data_finish           0x00000008U
#define SRT_NX90_adc_seq_irq_mask_set_adc1_data_finish           3
#define DFLT_VAL_NX90_adc_seq_irq_mask_set_adc1_data_finish      0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_set_adc1_data_finish   0x00000000U

/* all used bits of 'NX90_adc_seq_irq_mask_set': */
#define MSK_USED_BITS_NX90_adc_seq_irq_mask_set 0x0000000fU

enum {
  BFW_NX90_adc_seq_irq_mask_set_adc0_sample_finish = 1,  /* [0] */
  BFW_NX90_adc_seq_irq_mask_set_adc1_sample_finish = 1,  /* [1] */
  BFW_NX90_adc_seq_irq_mask_set_adc0_data_finish   = 1,  /* [2] */
  BFW_NX90_adc_seq_irq_mask_set_adc1_data_finish   = 1,  /* [3] */
  BFW_NX90_adc_seq_irq_mask_set_reserved1          = 28  /* [31:4] */
};

typedef struct NX90_ADC_SEQ_IRQ_MASK_SET_BIT_Ttag {
  unsigned int adc0_sample_finish : BFW_NX90_adc_seq_irq_mask_set_adc0_sample_finish; /* Sampling phase of ADC0 is finished, ADC0 can be restarted. */
  unsigned int adc1_sample_finish : BFW_NX90_adc_seq_irq_mask_set_adc1_sample_finish; /* Sampling phase of ADC1 is finished, ADC1 can be restarted. */
  unsigned int adc0_data_finish   : BFW_NX90_adc_seq_irq_mask_set_adc0_data_finish;   /* Data of ADC0 is ready to be read.                          */
  unsigned int adc1_data_finish   : BFW_NX90_adc_seq_irq_mask_set_adc1_data_finish;   /* Data of ADC1 is ready to be read.                          */
  unsigned int reserved1          : BFW_NX90_adc_seq_irq_mask_set_reserved1;          /* reserved                                                   */
} NX90_ADC_SEQ_IRQ_MASK_SET_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_ADC_SEQ_IRQ_MASK_SET_BIT_T bf;
} NX90_ADC_SEQ_IRQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register adc_seq_irq_mask_reset */
/* => IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_adc_seq_irq_mask_reset     0x00000028U
#define Adr_NX90_adc_seq_adc_seq_irq_mask_reset 0xFF4016E8U
#define Adr_NX90_adc_seq_irq_mask_reset         0xFF4016E8U
#define DFLT_VAL_NX90_adc_seq_irq_mask_reset    0x00000000U

#define MSK_NX90_adc_seq_irq_mask_reset_adc0_sample_finish         0x00000001U
#define SRT_NX90_adc_seq_irq_mask_reset_adc0_sample_finish         0
#define DFLT_VAL_NX90_adc_seq_irq_mask_reset_adc0_sample_finish    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_reset_adc0_sample_finish 0x00000000U
#define MSK_NX90_adc_seq_irq_mask_reset_adc1_sample_finish         0x00000002U
#define SRT_NX90_adc_seq_irq_mask_reset_adc1_sample_finish         1
#define DFLT_VAL_NX90_adc_seq_irq_mask_reset_adc1_sample_finish    0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_reset_adc1_sample_finish 0x00000000U
#define MSK_NX90_adc_seq_irq_mask_reset_adc0_data_finish           0x00000004U
#define SRT_NX90_adc_seq_irq_mask_reset_adc0_data_finish           2
#define DFLT_VAL_NX90_adc_seq_irq_mask_reset_adc0_data_finish      0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_reset_adc0_data_finish   0x00000000U
#define MSK_NX90_adc_seq_irq_mask_reset_adc1_data_finish           0x00000008U
#define SRT_NX90_adc_seq_irq_mask_reset_adc1_data_finish           3
#define DFLT_VAL_NX90_adc_seq_irq_mask_reset_adc1_data_finish      0x00000000U
#define DFLT_BF_VAL_NX90_adc_seq_irq_mask_reset_adc1_data_finish   0x00000000U

/* all used bits of 'NX90_adc_seq_irq_mask_reset': */
#define MSK_USED_BITS_NX90_adc_seq_irq_mask_reset 0x0000000fU

enum {
  BFW_NX90_adc_seq_irq_mask_reset_adc0_sample_finish = 1,  /* [0] */
  BFW_NX90_adc_seq_irq_mask_reset_adc1_sample_finish = 1,  /* [1] */
  BFW_NX90_adc_seq_irq_mask_reset_adc0_data_finish   = 1,  /* [2] */
  BFW_NX90_adc_seq_irq_mask_reset_adc1_data_finish   = 1,  /* [3] */
  BFW_NX90_adc_seq_irq_mask_reset_reserved1          = 28  /* [31:4] */
};

typedef struct NX90_ADC_SEQ_IRQ_MASK_RESET_BIT_Ttag {
  unsigned int adc0_sample_finish : BFW_NX90_adc_seq_irq_mask_reset_adc0_sample_finish; /* Sampling phase of ADC0 is finished, ADC0 can be restarted. */
  unsigned int adc1_sample_finish : BFW_NX90_adc_seq_irq_mask_reset_adc1_sample_finish; /* Sampling phase of ADC1 is finished, ADC1 can be restarted. */
  unsigned int adc0_data_finish   : BFW_NX90_adc_seq_irq_mask_reset_adc0_data_finish;   /* Data of ADC0 is ready to be read.                          */
  unsigned int adc1_data_finish   : BFW_NX90_adc_seq_irq_mask_reset_adc1_data_finish;   /* Data of ADC1 is ready to be read.                          */
  unsigned int reserved1          : BFW_NX90_adc_seq_irq_mask_reset_reserved1;          /* reserved                                                   */
} NX90_ADC_SEQ_IRQ_MASK_RESET_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_ADC_SEQ_IRQ_MASK_RESET_BIT_T bf;
} NX90_ADC_SEQ_IRQ_MASK_RESET_T;


/* ===================================================================== */

/* Area of miimu */

/* ===================================================================== */

#define Addr_NX90_miimu 0xFF401700U

/* --------------------------------------------------------------------- */
/* Register miimu */
/* => MDIO FSM interface controlling for netX external PHY. */
/*    Note: */
/*       Loopback for purpose is provided by miimu_sw register and also performed */
/*       in non-software-mode when enabled. */
/*    Note: */
/*       Prior phy_nres-bit was removed. PHY reset must be done by register ASIC_CTRL.phy_control. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_miimu   0x00000000U
#define Adr_NX90_miimu_miimu 0xFF401700U
#define Adr_NX90_miimu       0xFF401700U
#define DFLT_VAL_NX90_miimu  0x00000000U

#define MSK_NX90_miimu_snrdy              0x00000001U
#define SRT_NX90_miimu_snrdy              0
#define DFLT_VAL_NX90_miimu_snrdy         0x00000000U
#define DFLT_BF_VAL_NX90_miimu_snrdy      0x00000000U
#define MSK_NX90_miimu_preamble           0x00000002U
#define SRT_NX90_miimu_preamble           1
#define DFLT_VAL_NX90_miimu_preamble      0x00000000U
#define DFLT_BF_VAL_NX90_miimu_preamble   0x00000000U
#define MSK_NX90_miimu_opmode             0x00000004U
#define SRT_NX90_miimu_opmode             2
#define DFLT_VAL_NX90_miimu_opmode        0x00000000U
#define DFLT_BF_VAL_NX90_miimu_opmode     0x00000000U
#define MSK_NX90_miimu_mdc_period         0x00000008U
#define SRT_NX90_miimu_mdc_period         3
#define DFLT_VAL_NX90_miimu_mdc_period    0x00000000U
#define DFLT_BF_VAL_NX90_miimu_mdc_period 0x00000000U
#define MSK_NX90_miimu_rta                0x00000020U
#define SRT_NX90_miimu_rta                5
#define DFLT_VAL_NX90_miimu_rta           0x00000000U
#define DFLT_BF_VAL_NX90_miimu_rta        0x00000000U
#define MSK_NX90_miimu_regaddr            0x000007c0U
#define SRT_NX90_miimu_regaddr            6
#define DFLT_VAL_NX90_miimu_regaddr       0x00000000U
#define DFLT_BF_VAL_NX90_miimu_regaddr    0x00000000U
#define MSK_NX90_miimu_phyaddr            0x0000f800U
#define SRT_NX90_miimu_phyaddr            11
#define DFLT_VAL_NX90_miimu_phyaddr       0x00000000U
#define DFLT_BF_VAL_NX90_miimu_phyaddr    0x00000000U
#define MSK_NX90_miimu_data               0xffff0000U
#define SRT_NX90_miimu_data               16
#define DFLT_VAL_NX90_miimu_data          0x00000000U
#define DFLT_BF_VAL_NX90_miimu_data       0x00000000U

/* all used bits of 'NX90_miimu': */
#define MSK_USED_BITS_NX90_miimu 0xffffffefU

enum {
  BFW_NX90_miimu_snrdy      = 1,  /* [0] */
  BFW_NX90_miimu_preamble   = 1,  /* [1] */
  BFW_NX90_miimu_opmode     = 1,  /* [2] */
  BFW_NX90_miimu_mdc_period = 1,  /* [3] */
  BFW_NX90_miimu_reserved1  = 1,  /* [4] */
  BFW_NX90_miimu_rta        = 1,  /* [5] */
  BFW_NX90_miimu_regaddr    = 5,  /* [10:6] */
  BFW_NX90_miimu_phyaddr    = 5,  /* [15:11] */
  BFW_NX90_miimu_data       = 16  /* [31:16] */
};

typedef struct NX90_MIIMU_BIT_Ttag {
  unsigned int snrdy      : BFW_NX90_miimu_snrdy;      /* Start not ready              */
  unsigned int preamble   : BFW_NX90_miimu_preamble;   /* Send preamble                */
  unsigned int opmode     : BFW_NX90_miimu_opmode;     /* Operation mode:              */
                                                       /* 1: write                     */
                                                       /* 0: read                      */
  unsigned int mdc_period : BFW_NX90_miimu_mdc_period; /* MDC period:                  */
                                                       /* 1: 800ns                     */
                                                       /* 0: 400ns                     */
  unsigned int reserved1  : BFW_NX90_miimu_reserved1;  /* reserved                     */
  unsigned int rta        : BFW_NX90_miimu_rta;        /* Read Turn Around field:      */
                                                       /* 0: one bit                   */
                                                       /* 1: two bits                  */
  unsigned int regaddr    : BFW_NX90_miimu_regaddr;    /* Register address             */
  unsigned int phyaddr    : BFW_NX90_miimu_phyaddr;    /* PHY address                  */
  unsigned int data       : BFW_NX90_miimu_data;       /* Data to or from PHY register */
} NX90_MIIMU_BIT_T;

typedef union {
  uint32_t         val;
  NX90_MIIMU_BIT_T bf;
} NX90_MIIMU_T;

/* --------------------------------------------------------------------- */
/* Register miimu_sw */
/* => MDIO software interface controlling for netX internal PHY. */
/*    Note: */
/*       Function is similar to old MIIMU unit register 'miimu_sw', however data output */
/*       enable was removed as it is not necessary for MDIO interface to internal PHY (due */
/*       to non-bidirectional data signal). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_miimu_sw   0x00000004U
#define Adr_NX90_miimu_miimu_sw 0xFF401704U
#define Adr_NX90_miimu_sw       0xFF401704U
#define DFLT_VAL_NX90_miimu_sw  0x00000000U

#define MSK_NX90_miimu_sw_enable           0x00000001U
#define SRT_NX90_miimu_sw_enable           0
#define DFLT_VAL_NX90_miimu_sw_enable      0x00000000U
#define DFLT_BF_VAL_NX90_miimu_sw_enable   0x00000000U
#define MSK_NX90_miimu_sw_mdc              0x00000010U
#define SRT_NX90_miimu_sw_mdc              4
#define DFLT_VAL_NX90_miimu_sw_mdc         0x00000000U
#define DFLT_BF_VAL_NX90_miimu_sw_mdc      0x00000000U
#define MSK_NX90_miimu_sw_mdo              0x00000020U
#define SRT_NX90_miimu_sw_mdo              5
#define DFLT_VAL_NX90_miimu_sw_mdo         0x00000000U
#define DFLT_BF_VAL_NX90_miimu_sw_mdo      0x00000000U
#define MSK_NX90_miimu_sw_mdoe             0x00000040U
#define SRT_NX90_miimu_sw_mdoe             6
#define DFLT_VAL_NX90_miimu_sw_mdoe        0x00000000U
#define DFLT_BF_VAL_NX90_miimu_sw_mdoe     0x00000000U
#define MSK_NX90_miimu_sw_mdi_ro           0x00000080U
#define SRT_NX90_miimu_sw_mdi_ro           7
#define DFLT_VAL_NX90_miimu_sw_mdi_ro      0x00000000U
#define DFLT_BF_VAL_NX90_miimu_sw_mdi_ro   0x00000000U
#define MSK_NX90_miimu_sw_loopback         0x00000100U
#define SRT_NX90_miimu_sw_loopback         8
#define DFLT_VAL_NX90_miimu_sw_loopback    0x00000000U
#define DFLT_BF_VAL_NX90_miimu_sw_loopback 0x00000000U

/* all used bits of 'NX90_miimu_sw': */
#define MSK_USED_BITS_NX90_miimu_sw 0x000001f1U

enum {
  BFW_NX90_miimu_sw_enable    = 1,  /* [0] */
  BFW_NX90_miimu_sw_reserved1 = 3,  /* [3:1] */
  BFW_NX90_miimu_sw_mdc       = 1,  /* [4] */
  BFW_NX90_miimu_sw_mdo       = 1,  /* [5] */
  BFW_NX90_miimu_sw_mdoe      = 1,  /* [6] */
  BFW_NX90_miimu_sw_mdi_ro    = 1,  /* [7] */
  BFW_NX90_miimu_sw_loopback  = 1,  /* [8] */
  BFW_NX90_miimu_sw_reserved2 = 23  /* [31:9] */
};

typedef struct NX90_MIIMU_SW_BIT_Ttag {
  unsigned int enable    : BFW_NX90_miimu_sw_enable;    /* Enables software mode:                                      */
                                                        /* MDC, MDO and MDOE are set by software.                      */
  unsigned int reserved1 : BFW_NX90_miimu_sw_reserved1; /* reserved                                                    */
  unsigned int mdc       : BFW_NX90_miimu_sw_mdc;       /* MDC value for software mode                                 */
  unsigned int mdo       : BFW_NX90_miimu_sw_mdo;       /* MDO value for software mode                                 */
  unsigned int mdoe      : BFW_NX90_miimu_sw_mdoe;      /* MDOE value for software mode                                */
  unsigned int mdi_ro    : BFW_NX90_miimu_sw_mdi_ro;    /* current MDI value                                           */
  unsigned int loopback  : BFW_NX90_miimu_sw_loopback;  /* MDIO-data-out to data-in loopback for test purpose.         */
                                                        /* 0: no loopback, MDIO-data-in comes from internal PHY.       */
                                                        /* 1: loopback, MDIO-data-in comes from current MDIO-data-out. */
                                                        /* Note:                                                       */
                                                        /*    Loopback can also be used in non-software-mode.          */
  unsigned int reserved2 : BFW_NX90_miimu_sw_reserved2; /* reserved                                                    */
} NX90_MIIMU_SW_BIT_T;

typedef union {
  uint32_t            val;
  NX90_MIIMU_SW_BIT_T bf;
} NX90_MIIMU_SW_T;


/* ===================================================================== */

/* Area of feth */

/* ===================================================================== */

#define Addr_NX90_feth 0xFF480000U

/* ===================================================================== */

/* Area of eth_system */

/* ===================================================================== */

#define Addr_NX90_eth_system 0xFF480000U

/* ===================================================================== */

/* Area of eth */

/* ===================================================================== */

#define Addr_NX90_eth 0xFF480000U

/* --------------------------------------------------------------------- */
/* Register eth_config */
/* => ETH config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_config  0x00000000U
#define Adr_NX90_eth_eth_config  0xFF480000U
#define Adr_NX90_eth_config      0xFF480000U
#define DFLT_VAL_NX90_eth_config 0x00000004U

#define MSK_NX90_eth_config_rx_watermark_irq               0x0000000fU
#define SRT_NX90_eth_config_rx_watermark_irq               0
#define DFLT_VAL_NX90_eth_config_rx_watermark_irq          0x00000004U
#define DFLT_BF_VAL_NX90_eth_config_rx_watermark_irq       0x00000004U
#define MSK_NX90_eth_config_rx_sample_phase                0x00000070U
#define SRT_NX90_eth_config_rx_sample_phase                4
#define DFLT_VAL_NX90_eth_config_rx_sample_phase           0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_sample_phase        0x00000000U
#define MSK_NX90_eth_config_rx_delay_inputs                0x00000080U
#define SRT_NX90_eth_config_rx_delay_inputs                7
#define DFLT_VAL_NX90_eth_config_rx_delay_inputs           0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_delay_inputs        0x00000000U
#define MSK_NX90_eth_config_rx_allow_jumbo_packets         0x00000100U
#define SRT_NX90_eth_config_rx_allow_jumbo_packets         8
#define DFLT_VAL_NX90_eth_config_rx_allow_jumbo_packets    0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_allow_jumbo_packets 0x00000000U
#define MSK_NX90_eth_config_rx_exact_preamble              0x00000200U
#define SRT_NX90_eth_config_rx_exact_preamble              9
#define DFLT_VAL_NX90_eth_config_rx_exact_preamble         0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_exact_preamble      0x00000000U
#define MSK_NX90_eth_config_rx_no_preamble                 0x00000400U
#define SRT_NX90_eth_config_rx_no_preamble                 10
#define DFLT_VAL_NX90_eth_config_rx_no_preamble            0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_no_preamble         0x00000000U
#define MSK_NX90_eth_config_rx_dma_mode                    0x00000800U
#define SRT_NX90_eth_config_rx_dma_mode                    11
#define DFLT_VAL_NX90_eth_config_rx_dma_mode               0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_dma_mode            0x00000000U
#define MSK_NX90_eth_config_rx_systime_sfd                 0x00001000U
#define SRT_NX90_eth_config_rx_systime_sfd                 12
#define DFLT_VAL_NX90_eth_config_rx_systime_sfd            0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_systime_sfd         0x00000000U
#define MSK_NX90_eth_config_rx_enable                      0x00002000U
#define SRT_NX90_eth_config_rx_enable                      13
#define DFLT_VAL_NX90_eth_config_rx_enable                 0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_rx_enable              0x00000000U
#define MSK_NX90_eth_config_frequency                      0x08000000U
#define SRT_NX90_eth_config_frequency                      27
#define DFLT_VAL_NX90_eth_config_frequency                 0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_frequency              0x00000000U
#define MSK_NX90_eth_config_hd_suppress_loopback           0x10000000U
#define SRT_NX90_eth_config_hd_suppress_loopback           28
#define DFLT_VAL_NX90_eth_config_hd_suppress_loopback      0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_hd_suppress_loopback   0x00000000U
#define MSK_NX90_eth_config_phy_mode                       0x20000000U
#define SRT_NX90_eth_config_phy_mode                       29
#define DFLT_VAL_NX90_eth_config_phy_mode                  0x00000000U
#define DFLT_BF_VAL_NX90_eth_config_phy_mode               0x00000000U

/* all used bits of 'NX90_eth_config': */
#define MSK_USED_BITS_NX90_eth_config 0x38003fffU

enum {
  BFW_NX90_eth_config_rx_watermark_irq       = 4,  /* [3:0] */
  BFW_NX90_eth_config_rx_sample_phase        = 3,  /* [6:4] */
  BFW_NX90_eth_config_rx_delay_inputs        = 1,  /* [7] */
  BFW_NX90_eth_config_rx_allow_jumbo_packets = 1,  /* [8] */
  BFW_NX90_eth_config_rx_exact_preamble      = 1,  /* [9] */
  BFW_NX90_eth_config_rx_no_preamble         = 1,  /* [10] */
  BFW_NX90_eth_config_rx_dma_mode            = 1,  /* [11] */
  BFW_NX90_eth_config_rx_systime_sfd         = 1,  /* [12] */
  BFW_NX90_eth_config_rx_enable              = 1,  /* [13] */
  BFW_NX90_eth_config_reserved1              = 13, /* [26:14] */
  BFW_NX90_eth_config_frequency              = 1,  /* [27] */
  BFW_NX90_eth_config_hd_suppress_loopback   = 1,  /* [28] */
  BFW_NX90_eth_config_phy_mode               = 1,  /* [29] */
  BFW_NX90_eth_config_reserved2              = 2   /* [31:30] */
};

typedef struct NX90_ETH_CONFIG_BIT_Ttag {
  unsigned int rx_watermark_irq       : BFW_NX90_eth_config_rx_watermark_irq;       /* Watermark for RX-FIFO, that generates interrupt                                          */
                                                                                    /* This number of DWords is available inside RX-FIFO                                        */
  unsigned int rx_sample_phase        : BFW_NX90_eth_config_rx_sample_phase;        /*  clk-phase in which rxd is sampled:                                                      */
                                                                                    /*  PHY mode (phy_mode=1):                                                                  */
                                                                                    /* {    |                                                                                   */
                                                                                    /*  0,4: sample at posedge tx_clk                                                           */
                                                                                    /*  1,5: sample at posedge tx_clk + 1cc                                                     */
                                                                                    /*  2,6: sample at posedge tx_clk + 2cc                                                     */
                                                                                    /*  3,7: sample at posedge tx_clk + 3cc}                                                    */
                                                                                    /*  MAC mode (phy_mode=0):                                                                  */
                                                                                    /* {  |                                                                                     */
                                                                                    /*  0: sample at posedge rx_clk + 1cc                                                       */
                                                                                    /*  1: sample at posedge rx_clk + 2cc                                                       */
                                                                                    /*  2: sample at posedge rx_clk + 3cc                                                       */
                                                                                    /*  3: sample at posedge rx_clk + 4cc                                                       */
                                                                                    /*  4: sample at negedge rx_clk + 3cc                                                       */
                                                                                    /*  5: sample at negedge rx_clk + 4cc                                                       */
                                                                                    /*  6: sample at negedge rx_clk + 1cc                                                       */
                                                                                    /*  7: sample at negedge rx_clk + 2cc}                                                      */
  unsigned int rx_delay_inputs        : BFW_NX90_eth_config_rx_delay_inputs;        /* Delay mii inputs (rx_d, rx_dv, rx_err, crs, col) by 1 clockcycle before sampling them.   */
                                                                                    /* This leads to inputs fitting to sampled rxclk.                                           */
                                                                                    /* Enable this in MAC mode, disable in PHY mode.                                            */
  unsigned int rx_allow_jumbo_packets : BFW_NX90_eth_config_rx_allow_jumbo_packets; /* Receive frames > 1522 bytes.                                                             */
                                                                                    /* If jumbo_packets are not allowed, the receive frame buffer must be 1524 bytes.           */
                                                                                    /* Warning: Frames with len > 2047 will be received, but rx_frame_len has only 11 bit.      */
  unsigned int rx_exact_preamble      : BFW_NX90_eth_config_rx_exact_preamble;      /* Accept only packages with exact preamble,                                                */
                                                                                    /* rx_preamble_error IRQ will be generated independant on this setting.                     */
  unsigned int rx_no_preamble         : BFW_NX90_eth_config_rx_no_preamble;         /* receive starts, when rxdv gets active                                                    */
  unsigned int rx_dma_mode            : BFW_NX90_eth_config_rx_dma_mode;            /* Receive DMA mode:                                                                        */
                                                                                    /* Each received frame needs 2 DMA-transfers, one for package data and                      */
                                                                                    /* one for rx_len/status.                                                                   */
                                                                                    /* In rx_dma_mode irq_raw-rx_frame_finished is reset automatically.                         */
  unsigned int rx_systime_sfd         : BFW_NX90_eth_config_rx_systime_sfd;         /* Sample systime at SFD of received frame:                                                 */
                                                                                    /* 1: Sample systime_ns to eth_rx_systime_ns at SFD (+constant offset)                      */
                                                                                    /* 0: Sample systime_ns to eth_rx_systime_ns when rxdv gets active (+constant offset)       */
  unsigned int rx_enable              : BFW_NX90_eth_config_rx_enable;              /* Enable of receive state machine:                                                         */
                                                                                    /* When disabled, receive state machine is reset.                                           */
                                                                                    /* After enabling, receive state machine waits for rxdv going down.                         */
                                                                                    /* If rxdv is already down, proper IFG is expected.                                         */
  unsigned int reserved1              : BFW_NX90_eth_config_reserved1;              /* reserved                                                                                 */
  unsigned int frequency              : BFW_NX90_eth_config_frequency;              /* MII clock frequency:                                                                     */
                                                                                    /* 1: 50MHz (use in PHY mode only)                                                          */
                                                                                    /* 0: 25MHz                                                                                 */
  unsigned int hd_suppress_loopback   : BFW_NX90_eth_config_hd_suppress_loopback;   /* Suppress loopback in half_duplex mode:                                                   */
                                                                                    /* 1: don't start RX-process, if txen is active.                                            */
                                                                                    /* 0: RX and TX work indepentently.                                                         */
  unsigned int phy_mode               : BFW_NX90_eth_config_phy_mode;               /*  PHY mode:                                                                               */
                                                                                    /*  0: behave like an ethernet MAC, sync to external rxclk/txclk                            */
                                                                                    /*  1: behave like an ethernet PHY, generate txclk (=rxclk), signals change their function: */
                                                                                    /* {            |                                                                           */
                                                                                    /*     rxclk:    not used                                                                   */
                                                                                    /*     rxd[3:0]: data input, to be connected to txd[3:0] of MAC device                      */
                                                                                    /*     rxdv:     Data valid input, to be connected to txen of MAC device                    */
                                                                                    /*     rxer:     Error input, to be connected to txer of MAC device                         */
                                                                                    /*     txclk:    Clock output, to be connected to rxclk and txclk of MAC device             */
                                                                                    /*     txd[3:0]: Data output, to be connected to rxd[3:0] of MAC device                     */
                                                                                    /*     txen:     Data valid output, to be connected to rxdv of MAC device                   */
                                                                                    /*     txer:     Error output. to be connected to rxer of MAC device                        */
                                                                                    /*     col:      not used                                                                   */
                                                                                    /*     crs:      not used}                                                                  */
  unsigned int reserved2              : BFW_NX90_eth_config_reserved2;              /* reserved                                                                                 */
} NX90_ETH_CONFIG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_ETH_CONFIG_BIT_T bf;
} NX90_ETH_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_config */
/* => ETH config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_tx_config  0x00000004U
#define Adr_NX90_eth_eth_tx_config  0xFF480004U
#define Adr_NX90_eth_tx_config      0xFF480004U
#define DFLT_VAL_NX90_eth_tx_config 0x02188084U

#define MSK_NX90_eth_tx_config_tx_watermark_irq           0x0000000fU
#define SRT_NX90_eth_tx_config_tx_watermark_irq           0
#define DFLT_VAL_NX90_eth_tx_config_tx_watermark_irq      0x00000004U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_watermark_irq   0x00000004U
#define MSK_NX90_eth_tx_config_tx_watermark_start         0x000000f0U
#define SRT_NX90_eth_tx_config_tx_watermark_start         4
#define DFLT_VAL_NX90_eth_tx_config_tx_watermark_start    0x00000080U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_watermark_start 0x00000008U
#define MSK_NX90_eth_tx_config_tx_output_phase            0x00000700U
#define SRT_NX90_eth_tx_config_tx_output_phase            8
#define DFLT_VAL_NX90_eth_tx_config_tx_output_phase       0x00000000U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_output_phase    0x00000000U
#define MSK_NX90_eth_tx_config_tx_preamble_len            0x0000f800U
#define SRT_NX90_eth_tx_config_tx_preamble_len            11
#define DFLT_VAL_NX90_eth_tx_config_tx_preamble_len       0x00008000U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_preamble_len    0x00000010U
#define MSK_NX90_eth_tx_config_tx_min_ifg_cycles          0x001f0000U
#define SRT_NX90_eth_tx_config_tx_min_ifg_cycles          16
#define DFLT_VAL_NX90_eth_tx_config_tx_min_ifg_cycles     0x00180000U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_min_ifg_cycles  0x00000018U
#define MSK_NX90_eth_tx_config_tx_crs_low_cycles          0x03e00000U
#define SRT_NX90_eth_tx_config_tx_crs_low_cycles          21
#define DFLT_VAL_NX90_eth_tx_config_tx_crs_low_cycles     0x02000000U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_crs_low_cycles  0x00000010U
#define MSK_NX90_eth_tx_config_tx_abort_frame             0x1c000000U
#define SRT_NX90_eth_tx_config_tx_abort_frame             26
#define DFLT_VAL_NX90_eth_tx_config_tx_abort_frame        0x00000000U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_abort_frame     0x00000000U
#define MSK_NX90_eth_tx_config_tx_systime_sfd             0x20000000U
#define SRT_NX90_eth_tx_config_tx_systime_sfd             29
#define DFLT_VAL_NX90_eth_tx_config_tx_systime_sfd        0x00000000U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_systime_sfd     0x00000000U
#define MSK_NX90_eth_tx_config_tx_dma_mode                0x40000000U
#define SRT_NX90_eth_tx_config_tx_dma_mode                30
#define DFLT_VAL_NX90_eth_tx_config_tx_dma_mode           0x00000000U
#define DFLT_BF_VAL_NX90_eth_tx_config_tx_dma_mode        0x00000000U
#define MSK_NX90_eth_tx_config_half_duplex                0x80000000U
#define SRT_NX90_eth_tx_config_half_duplex                31
#define DFLT_VAL_NX90_eth_tx_config_half_duplex           0x00000000U
#define DFLT_BF_VAL_NX90_eth_tx_config_half_duplex        0x00000000U

/* all used bits of 'NX90_eth_tx_config': */
#define MSK_USED_BITS_NX90_eth_tx_config 0xffffffffU

enum {
  BFW_NX90_eth_tx_config_tx_watermark_irq   = 4, /* [3:0] */
  BFW_NX90_eth_tx_config_tx_watermark_start = 4, /* [7:4] */
  BFW_NX90_eth_tx_config_tx_output_phase    = 3, /* [10:8] */
  BFW_NX90_eth_tx_config_tx_preamble_len    = 5, /* [15:11] */
  BFW_NX90_eth_tx_config_tx_min_ifg_cycles  = 5, /* [20:16] */
  BFW_NX90_eth_tx_config_tx_crs_low_cycles  = 5, /* [25:21] */
  BFW_NX90_eth_tx_config_tx_abort_frame     = 3, /* [28:26] */
  BFW_NX90_eth_tx_config_tx_systime_sfd     = 1, /* [29] */
  BFW_NX90_eth_tx_config_tx_dma_mode        = 1, /* [30] */
  BFW_NX90_eth_tx_config_half_duplex        = 1  /* [31] */
};

typedef struct NX90_ETH_TX_CONFIG_BIT_Ttag {
  unsigned int tx_watermark_irq   : BFW_NX90_eth_tx_config_tx_watermark_irq;   /* Watermark for TX-FIFO, that generates IRQ.                                                                                     */
                                                                               /* This number of DWords is free inside TX-FIFO                                                                                   */
  unsigned int tx_watermark_start : BFW_NX90_eth_tx_config_tx_watermark_start; /* Watermark for TX-FIFO, that starts transmission.                                                                               */
                                                                               /* This number of DWords is inside TX-FIFO                                                                                        */
  unsigned int tx_output_phase    : BFW_NX90_eth_tx_config_tx_output_phase;    /*  clk-phase in which txd, txen, txer is changed at output                                                                       */
                                                                               /*  PHY mode (phy_mode=1):                                                                                                        */
                                                                               /* {    |                                                                                                                         */
                                                                               /*  0,4: change output at negedge tx_clk                                                                                          */
                                                                               /*  1,5: change output at negedge tx_clk + 1cc                                                                                    */
                                                                               /*  2,6: change output at negedge tx_clk + 2cc                                                                                    */
                                                                               /*  3,7: change output at negedge tx_clk + 3cc}                                                                                   */
                                                                               /*  MAC mode (phy_mode=0):                                                                                                        */
                                                                               /* {  |                                                                                                                           */
                                                                               /*  0: change output at posedge tx_clk + 2cc                                                                                      */
                                                                               /*  1: change output at posedge tx_clk + 3cc                                                                                      */
                                                                               /*  2: change output at posedge tx_clk + 4cc                                                                                      */
                                                                               /*  3: change output at posedge tx_clk + 5cc                                                                                      */
                                                                               /*  4: change output at negedge tx_clk + 4cc                                                                                      */
                                                                               /*  5: change output at negedge tx_clk + 5cc                                                                                      */
                                                                               /*  6: change output at negedge tx_clk + 2cc                                                                                      */
                                                                               /*  7: change output at negedge tx_clk + 3cc}                                                                                     */
  unsigned int tx_preamble_len    : BFW_NX90_eth_tx_config_tx_preamble_len;    /* Length of TX-preamble in nibbles (incl. SFD)                                                                                   */
  unsigned int tx_min_ifg_cycles  : BFW_NX90_eth_tx_config_tx_min_ifg_cycles;  /* minimum IFG in txclk-cycles                                                                                                    */
                                                                               /* In half_duplex mode reduce value by 2 to compensate cycles for sampling of mii_crs.                                            */
  unsigned int tx_crs_low_cycles  : BFW_NX90_eth_tx_config_tx_crs_low_cycles;  /* txclk-cycles with mii_crs low, before free carrier is detected (only used in half_duplex mode):                                */
                                                                               /* Value range: [0,tx_min_ifg_cycles].                                                                                            */
                                                                               /* For details s. half_duplex mode.                                                                                               */
  unsigned int tx_abort_frame     : BFW_NX90_eth_tx_config_tx_abort_frame;     /* Different abort mechanisms:                                                                                                    */
                                                                               /* 000: no abort:                                                                                                                 */
                                                                               /*      Transmit frame from TX-FIFO until tx_len and append correct FCS.                                                          */
                                                                               /* 001: standard abort:                                                                                                           */
                                                                               /*      Abort transmission, send wrong FCS, activate mii_txer.                                                                    */
                                                                               /*      SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO.                                                */
                                                                               /* 010: abort with dribble nibble:                                                                                                */
                                                                               /*      Like standard abort, but append dribble nibble after wrong FCS (needed by some PHYs to detect error condition)            */
                                                                               /*      SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO.                                                */
                                                                               /* 011: no FCS mode:                                                                                                              */
                                                                               /*      Transmit frame from TX-FIFO until tx_len but do not append FCS. Never activate mii_txer (except in case of tx_fifo_undr). */
                                                                               /* 100: Fast Track Switching controlled abort:                                                                                    */
                                                                               /*      Wait for next byte-border, then attach special FCS as wrong FCS.                                                          */
                                                                               /*      Special FCS is "a0a0a0a0", or "a0a0a0a1" in case that real FCS would end with "a0".                                       */
                                                                               /*      Do not activate mii_txer.                                                                                                 */
                                                                               /*      SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO.                                                */
                                                                               /* 101: reserved                                                                                                                  */
                                                                               /* 110: reserved                                                                                                                  */
                                                                               /* 111: reserved                                                                                                                  */
  unsigned int tx_systime_sfd     : BFW_NX90_eth_tx_config_tx_systime_sfd;     /* Sample systime at SFD:                                                                                                         */
                                                                               /* 1: Sample systime_ns to eth_tx_systime_ns at SFD (-constant offset)                                                            */
                                                                               /* 0: Sample systime_ns to eth_tx_systime_ns when txen gets active (-constant offset)                                             */
  unsigned int tx_dma_mode        : BFW_NX90_eth_tx_config_tx_dma_mode;        /* In tx_dma_mode tx_len comes from DMAC automatically.                                                                           */
                                                                               /* An extra tx_lsreq will be generated to request tx_len,                                                                         */
                                                                               /* before frame data is requested (and after previous frame is finished).                                                         */
                                                                               /* In tx_dma_mode irq_raw-tx_frame_finished is reset automatically.                                                               */
  unsigned int half_duplex        : BFW_NX90_eth_tx_config_half_duplex;        /* Half Duplex Mode:                                                                                                              */
                                                                               /* 1: In half duplex mode transmission of a frame starts after the following sequence:                                            */
                                                                               /*    - tx_watermark_start was reached                                                                                            */
                                                                               /*    - mii_crs became low and stayed low for tx_crs_low_cycles                                                                   */
                                                                               /*    - (tx_min_ifg_cycles - tx_crs_low_cycles) are passed                                                                        */
                                                                               /* 0: In full duplex mode transmission of a frame starts after the following sequence:                                            */
                                                                               /*    - tx_min_ifg_cycles are passed after the last transmitted frame                                                             */
                                                                               /*    - tx_watermark_start was reached                                                                                            */
} NX90_ETH_TX_CONFIG_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_ETH_TX_CONFIG_BIT_T bf;
} NX90_ETH_TX_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register eth_status */
/* => ETH status register: */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_status 0x00000008U
#define Adr_NX90_eth_eth_status 0xFF480008U
#define Adr_NX90_eth_status     0xFF480008U

#define MSK_NX90_eth_status_rx_fill 0x0000001fU
#define SRT_NX90_eth_status_rx_fill 0
#define MSK_NX90_eth_status_tx_fill 0x00000f80U
#define SRT_NX90_eth_status_tx_fill 7

/* all used bits of 'NX90_eth_status': */
#define MSK_USED_BITS_NX90_eth_status 0x00000f9fU

enum {
  BFW_NX90_eth_status_rx_fill   = 5,  /* [4:0] */
  BFW_NX90_eth_status_reserved1 = 2,  /* [6:5] */
  BFW_NX90_eth_status_tx_fill   = 5,  /* [11:7] */
  BFW_NX90_eth_status_reserved2 = 20  /* [31:12] */
};

typedef struct NX90_ETH_STATUS_BIT_Ttag {
  unsigned int rx_fill   : BFW_NX90_eth_status_rx_fill;   /* Fill-level of RX-FIFO */
  unsigned int reserved1 : BFW_NX90_eth_status_reserved1; /* reserved              */
  unsigned int tx_fill   : BFW_NX90_eth_status_tx_fill;   /* Fill-level of TX-FIFO */
  unsigned int reserved2 : BFW_NX90_eth_status_reserved2; /* reserved              */
} NX90_ETH_STATUS_BIT_T;

typedef union {
  uint32_t              val;
  NX90_ETH_STATUS_BIT_T bf;
} NX90_ETH_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_data */
/* => Data to TX-FIFO: */
/*    returns 0xdeadbeef on read */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_tx_data  0x0000000CU
#define Adr_NX90_eth_eth_tx_data  0xFF48000CU
#define Adr_NX90_eth_tx_data      0xFF48000CU
#define DFLT_VAL_NX90_eth_tx_data 0x00000000U

#define MSK_NX90_eth_tx_data_val         0xffffffffU
#define SRT_NX90_eth_tx_data_val         0
#define DFLT_VAL_NX90_eth_tx_data_val    0x00000000U
#define DFLT_BF_VAL_NX90_eth_tx_data_val 0x00000000U

/* all used bits of 'NX90_eth_tx_data': */
#define MSK_USED_BITS_NX90_eth_tx_data 0xffffffffU

enum {
  BFW_NX90_eth_tx_data_val = 32  /* [31:0] */
};

typedef struct NX90_ETH_TX_DATA_BIT_Ttag {
  unsigned int val : BFW_NX90_eth_tx_data_val; /* data to TX-FIFO */
} NX90_ETH_TX_DATA_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ETH_TX_DATA_BIT_T bf;
} NX90_ETH_TX_DATA_T;

/* --------------------------------------------------------------------- */
/* Register eth_rx_data */
/* => Data from RX-FIFO: */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_rx_data 0x00000010U
#define Adr_NX90_eth_eth_rx_data 0xFF480010U
#define Adr_NX90_eth_rx_data     0xFF480010U

#define MSK_NX90_eth_rx_data_val 0xffffffffU
#define SRT_NX90_eth_rx_data_val 0

/* all used bits of 'NX90_eth_rx_data': */
#define MSK_USED_BITS_NX90_eth_rx_data 0xffffffffU

enum {
  BFW_NX90_eth_rx_data_val = 32  /* [31:0] */
};

typedef struct NX90_ETH_RX_DATA_BIT_Ttag {
  unsigned int val : BFW_NX90_eth_rx_data_val; /* data from RX-FIFO */
} NX90_ETH_RX_DATA_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ETH_RX_DATA_BIT_T bf;
} NX90_ETH_RX_DATA_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_len */
/* => Length of data inside transmitted frame (between SFD and FCS) */
/*    Note: Set this value after previous frame is completely transmitted (irq-tx_frame_finished). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_tx_len  0x00000014U
#define Adr_NX90_eth_eth_tx_len  0xFF480014U
#define Adr_NX90_eth_tx_len      0xFF480014U
#define DFLT_VAL_NX90_eth_tx_len 0x000005eaU

#define MSK_NX90_eth_tx_len_val         0x000007ffU
#define SRT_NX90_eth_tx_len_val         0
#define DFLT_VAL_NX90_eth_tx_len_val    0x000005eaU
#define DFLT_BF_VAL_NX90_eth_tx_len_val 0x000005eaU

/* all used bits of 'NX90_eth_tx_len': */
#define MSK_USED_BITS_NX90_eth_tx_len 0x000007ffU

enum {
  BFW_NX90_eth_tx_len_val       = 11, /* [10:0] */
  BFW_NX90_eth_tx_len_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ETH_TX_LEN_BIT_Ttag {
  unsigned int val       : BFW_NX90_eth_tx_len_val;       /* To be transmitted data length (excluding SFD and excluding FCS) */
  unsigned int reserved1 : BFW_NX90_eth_tx_len_reserved1; /* reserved                                                        */
} NX90_ETH_TX_LEN_BIT_T;

typedef union {
  uint32_t              val;
  NX90_ETH_TX_LEN_BIT_T bf;
} NX90_ETH_TX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register eth_rx_len_stat */
/* => Length and status information of lastly received frame */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_rx_len_stat 0x00000018U
#define Adr_NX90_eth_eth_rx_len_stat 0xFF480018U
#define Adr_NX90_eth_rx_len_stat     0xFF480018U

#define MSK_NX90_eth_rx_len_stat_rx_len            0x000007ffU
#define SRT_NX90_eth_rx_len_stat_rx_len            0
#define MSK_NX90_eth_rx_len_stat_rx_short_ifg      0x08000000U
#define SRT_NX90_eth_rx_len_stat_rx_short_ifg      27
#define MSK_NX90_eth_rx_len_stat_rx_jumbo_packet   0x10000000U
#define SRT_NX90_eth_rx_len_stat_rx_jumbo_packet   28
#define MSK_NX90_eth_rx_len_stat_rx_dribble_nibble 0x20000000U
#define SRT_NX90_eth_rx_len_stat_rx_dribble_nibble 29
#define MSK_NX90_eth_rx_len_stat_rx_crc_error      0x40000000U
#define SRT_NX90_eth_rx_len_stat_rx_crc_error      30
#define MSK_NX90_eth_rx_len_stat_rx_mii_rxerr      0x80000000U
#define SRT_NX90_eth_rx_len_stat_rx_mii_rxerr      31

/* all used bits of 'NX90_eth_rx_len_stat': */
#define MSK_USED_BITS_NX90_eth_rx_len_stat 0xf80007ffU

enum {
  BFW_NX90_eth_rx_len_stat_rx_len            = 11, /* [10:0] */
  BFW_NX90_eth_rx_len_stat_reserved1         = 16, /* [26:11] */
  BFW_NX90_eth_rx_len_stat_rx_short_ifg      = 1,  /* [27] */
  BFW_NX90_eth_rx_len_stat_rx_jumbo_packet   = 1,  /* [28] */
  BFW_NX90_eth_rx_len_stat_rx_dribble_nibble = 1,  /* [29] */
  BFW_NX90_eth_rx_len_stat_rx_crc_error      = 1,  /* [30] */
  BFW_NX90_eth_rx_len_stat_rx_mii_rxerr      = 1   /* [31] */
};

typedef struct NX90_ETH_RX_LEN_STAT_BIT_Ttag {
  unsigned int rx_len            : BFW_NX90_eth_rx_len_stat_rx_len;            /* Received data (excluding SFD and including FCS)                               */
  unsigned int reserved1         : BFW_NX90_eth_rx_len_stat_reserved1;         /* reserved                                                                      */
  unsigned int rx_short_ifg      : BFW_NX90_eth_rx_len_stat_rx_short_ifg;      /* IFG shorter 960ns detected (preceeding this frame).                           */
  unsigned int rx_jumbo_packet   : BFW_NX90_eth_rx_len_stat_rx_jumbo_packet;   /* rx_frame_len > 1522 detected:                                                 */
                                                                               /* In case of eth_config-allow_jumbo_packets=1, this frame was received, but     */
                                                                               /* rx_len will overflow at 2048.                                                 */
                                                                               /* In case of eth_config-allow_jumbo_packets=0, frame is stopped after 1522, but */
                                                                               /* other status information (rxerr, crc, dribble_nibble) will be checked anyway. */
  unsigned int rx_dribble_nibble : BFW_NX90_eth_rx_len_stat_rx_dribble_nibble; /* frame finished at non-even nibble count, last nibble was dropped              */
  unsigned int rx_crc_error      : BFW_NX90_eth_rx_len_stat_rx_crc_error;      /* wrong RX FCS detected                                                         */
  unsigned int rx_mii_rxerr      : BFW_NX90_eth_rx_len_stat_rx_mii_rxerr;      /* external rxerr signal was active in last frame                                */
} NX90_ETH_RX_LEN_STAT_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_ETH_RX_LEN_STAT_BIT_T bf;
} NX90_ETH_RX_LEN_STAT_T;

/* --------------------------------------------------------------------- */
/* Register eth_rx_systime_ns */
/* => Systime_ns sampled at start of received frame. */
/*    Exact position of start of frame is defined in eth_config-systime_sfd. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_rx_systime_ns 0x00000020U
#define Adr_NX90_eth_eth_rx_systime_ns 0xFF480020U
#define Adr_NX90_eth_rx_systime_ns     0xFF480020U

#define MSK_NX90_eth_rx_systime_ns_val 0xffffffffU
#define SRT_NX90_eth_rx_systime_ns_val 0

/* all used bits of 'NX90_eth_rx_systime_ns': */
#define MSK_USED_BITS_NX90_eth_rx_systime_ns 0xffffffffU

enum {
  BFW_NX90_eth_rx_systime_ns_val = 32  /* [31:0] */
};

typedef struct NX90_ETH_RX_SYSTIME_NS_BIT_Ttag {
  unsigned int val : BFW_NX90_eth_rx_systime_ns_val; /* Sampled systime_ns */
} NX90_ETH_RX_SYSTIME_NS_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_ETH_RX_SYSTIME_NS_BIT_T bf;
} NX90_ETH_RX_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_systime_ns */
/* => Systime_ns sampled at start of transmitted frame. */
/*    Exact position of start of frame is defined in eth_tx_config-systime_sfd. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_tx_systime_ns 0x00000024U
#define Adr_NX90_eth_eth_tx_systime_ns 0xFF480024U
#define Adr_NX90_eth_tx_systime_ns     0xFF480024U

#define MSK_NX90_eth_tx_systime_ns_val 0xffffffffU
#define SRT_NX90_eth_tx_systime_ns_val 0

/* all used bits of 'NX90_eth_tx_systime_ns': */
#define MSK_USED_BITS_NX90_eth_tx_systime_ns 0xffffffffU

enum {
  BFW_NX90_eth_tx_systime_ns_val = 32  /* [31:0] */
};

typedef struct NX90_ETH_TX_SYSTIME_NS_BIT_Ttag {
  unsigned int val : BFW_NX90_eth_tx_systime_ns_val; /* Sampled systime_ns */
} NX90_ETH_TX_SYSTIME_NS_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_ETH_TX_SYSTIME_NS_BIT_T bf;
} NX90_ETH_TX_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_raw */
/* => Raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/*    Write access with '1' to rx_/tx_fifo_undr/_ovfl resets RX-FIFO/TX-FIFO. */
/*    Bits rx_data and tx_fifo are cleared by reading from/filling the appropriate FIFO. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_irq_raw  0x00000028U
#define Adr_NX90_eth_eth_irq_raw  0xFF480028U
#define Adr_NX90_eth_irq_raw      0xFF480028U
#define DFLT_VAL_NX90_eth_irq_raw 0x00000000U

#define MSK_NX90_eth_irq_raw_tx_fifo                   0x00000001U
#define SRT_NX90_eth_irq_raw_tx_fifo                   0
#define DFLT_VAL_NX90_eth_irq_raw_tx_fifo              0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_tx_fifo           0x00000000U
#define MSK_NX90_eth_irq_raw_tx_frame_finished         0x00000002U
#define SRT_NX90_eth_irq_raw_tx_frame_finished         1
#define DFLT_VAL_NX90_eth_irq_raw_tx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_tx_frame_finished 0x00000000U
#define MSK_NX90_eth_irq_raw_rx_data                   0x00000004U
#define SRT_NX90_eth_irq_raw_rx_data                   2
#define DFLT_VAL_NX90_eth_irq_raw_rx_data              0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_rx_data           0x00000000U
#define MSK_NX90_eth_irq_raw_rx_frame_finished         0x00000008U
#define SRT_NX90_eth_irq_raw_rx_frame_finished         3
#define DFLT_VAL_NX90_eth_irq_raw_rx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_rx_frame_finished 0x00000000U
#define MSK_NX90_eth_irq_raw_tx_fifo_undr              0x00000010U
#define SRT_NX90_eth_irq_raw_tx_fifo_undr              4
#define DFLT_VAL_NX90_eth_irq_raw_tx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_tx_fifo_undr      0x00000000U
#define MSK_NX90_eth_irq_raw_tx_fifo_ovfl              0x00000020U
#define SRT_NX90_eth_irq_raw_tx_fifo_ovfl              5
#define DFLT_VAL_NX90_eth_irq_raw_tx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_tx_fifo_ovfl      0x00000000U
#define MSK_NX90_eth_irq_raw_rx_fifo_undr              0x00000040U
#define SRT_NX90_eth_irq_raw_rx_fifo_undr              6
#define DFLT_VAL_NX90_eth_irq_raw_rx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_rx_fifo_undr      0x00000000U
#define MSK_NX90_eth_irq_raw_rx_fifo_ovfl              0x00000080U
#define SRT_NX90_eth_irq_raw_rx_fifo_ovfl              7
#define DFLT_VAL_NX90_eth_irq_raw_rx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_rx_fifo_ovfl      0x00000000U
#define MSK_NX90_eth_irq_raw_rx_cpu_too_slow           0x00000100U
#define SRT_NX90_eth_irq_raw_rx_cpu_too_slow           8
#define DFLT_VAL_NX90_eth_irq_raw_rx_cpu_too_slow      0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_rx_cpu_too_slow   0x00000000U
#define MSK_NX90_eth_irq_raw_rx_short_dv               0x00000200U
#define SRT_NX90_eth_irq_raw_rx_short_dv               9
#define DFLT_VAL_NX90_eth_irq_raw_rx_short_dv          0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_rx_short_dv       0x00000000U
#define MSK_NX90_eth_irq_raw_rx_preamble_error         0x00000400U
#define SRT_NX90_eth_irq_raw_rx_preamble_error         10
#define DFLT_VAL_NX90_eth_irq_raw_rx_preamble_error    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_rx_preamble_error 0x00000000U
#define MSK_NX90_eth_irq_raw_tx_col                    0x00000800U
#define SRT_NX90_eth_irq_raw_tx_col                    11
#define DFLT_VAL_NX90_eth_irq_raw_tx_col               0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_tx_col            0x00000000U
#define MSK_NX90_eth_irq_raw_tx_late_col               0x00001000U
#define SRT_NX90_eth_irq_raw_tx_late_col               12
#define DFLT_VAL_NX90_eth_irq_raw_tx_late_col          0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_raw_tx_late_col       0x00000000U

/* all used bits of 'NX90_eth_irq_raw': */
#define MSK_USED_BITS_NX90_eth_irq_raw 0x00001fffU

enum {
  BFW_NX90_eth_irq_raw_tx_fifo           = 1,  /* [0] */
  BFW_NX90_eth_irq_raw_tx_frame_finished = 1,  /* [1] */
  BFW_NX90_eth_irq_raw_rx_data           = 1,  /* [2] */
  BFW_NX90_eth_irq_raw_rx_frame_finished = 1,  /* [3] */
  BFW_NX90_eth_irq_raw_tx_fifo_undr      = 1,  /* [4] */
  BFW_NX90_eth_irq_raw_tx_fifo_ovfl      = 1,  /* [5] */
  BFW_NX90_eth_irq_raw_rx_fifo_undr      = 1,  /* [6] */
  BFW_NX90_eth_irq_raw_rx_fifo_ovfl      = 1,  /* [7] */
  BFW_NX90_eth_irq_raw_rx_cpu_too_slow   = 1,  /* [8] */
  BFW_NX90_eth_irq_raw_rx_short_dv       = 1,  /* [9] */
  BFW_NX90_eth_irq_raw_rx_preamble_error = 1,  /* [10] */
  BFW_NX90_eth_irq_raw_tx_col            = 1,  /* [11] */
  BFW_NX90_eth_irq_raw_tx_late_col       = 1,  /* [12] */
  BFW_NX90_eth_irq_raw_reserved1         = 19  /* [31:13] */
};

typedef struct NX90_ETH_IRQ_RAW_BIT_Ttag {
  unsigned int tx_fifo           : BFW_NX90_eth_irq_raw_tx_fifo;           /* TX-FIFO has free entries                                                                                  */
  unsigned int tx_frame_finished : BFW_NX90_eth_irq_raw_tx_frame_finished; /* TX frame finished:                                                                                        */
                                                                           /* In tx_dma_mode this bit is handled automatically, demask it to the CPU.                                   */
  unsigned int rx_data           : BFW_NX90_eth_irq_raw_rx_data;           /* RX Data is available                                                                                      */
  unsigned int rx_frame_finished : BFW_NX90_eth_irq_raw_rx_frame_finished; /* RX frame finished:                                                                                        */
                                                                           /* Clearing this bit tells the module, that the CPU has read rx_len_stat and the next frame can be received. */
                                                                           /* In rx_dma_mode this bit is handled automatically, demask it to the CPU.                                   */
  unsigned int tx_fifo_undr      : BFW_NX90_eth_irq_raw_tx_fifo_undr;      /* TX-FIFO underrun                                                                                          */
  unsigned int tx_fifo_ovfl      : BFW_NX90_eth_irq_raw_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)                                                   */
  unsigned int rx_fifo_undr      : BFW_NX90_eth_irq_raw_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)                                                   */
  unsigned int rx_fifo_ovfl      : BFW_NX90_eth_irq_raw_rx_fifo_ovfl;      /* RX-FIFO overflow                                                                                          */
  unsigned int rx_cpu_too_slow   : BFW_NX90_eth_irq_raw_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared                                           */
  unsigned int rx_short_dv       : BFW_NX90_eth_irq_raw_rx_short_dv;       /* mii_rxdv becomes low before SFD                                                                           */
  unsigned int rx_preamble_error : BFW_NX90_eth_irq_raw_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble                                                   */
  unsigned int tx_col            : BFW_NX90_eth_irq_raw_tx_col;            /* collision detected in half_duplex mode, started sending jam                                               */
  unsigned int tx_late_col       : BFW_NX90_eth_irq_raw_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam                                           */
  unsigned int reserved1         : BFW_NX90_eth_irq_raw_reserved1;         /* reserved                                                                                                  */
} NX90_ETH_IRQ_RAW_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ETH_IRQ_RAW_BIT_T bf;
} NX90_ETH_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_masked */
/* => Masked IRQ: */
/*    Shows status of masked IRQs as connected to ARM/xPIC. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_irq_masked 0x0000002CU
#define Adr_NX90_eth_eth_irq_masked 0xFF48002CU
#define Adr_NX90_eth_irq_masked     0xFF48002CU

#define MSK_NX90_eth_irq_masked_tx_fifo           0x00000001U
#define SRT_NX90_eth_irq_masked_tx_fifo           0
#define MSK_NX90_eth_irq_masked_tx_frame_finished 0x00000002U
#define SRT_NX90_eth_irq_masked_tx_frame_finished 1
#define MSK_NX90_eth_irq_masked_rx_data           0x00000004U
#define SRT_NX90_eth_irq_masked_rx_data           2
#define MSK_NX90_eth_irq_masked_rx_frame_finished 0x00000008U
#define SRT_NX90_eth_irq_masked_rx_frame_finished 3
#define MSK_NX90_eth_irq_masked_tx_fifo_undr      0x00000010U
#define SRT_NX90_eth_irq_masked_tx_fifo_undr      4
#define MSK_NX90_eth_irq_masked_tx_fifo_ovfl      0x00000020U
#define SRT_NX90_eth_irq_masked_tx_fifo_ovfl      5
#define MSK_NX90_eth_irq_masked_rx_fifo_undr      0x00000040U
#define SRT_NX90_eth_irq_masked_rx_fifo_undr      6
#define MSK_NX90_eth_irq_masked_rx_fifo_ovfl      0x00000080U
#define SRT_NX90_eth_irq_masked_rx_fifo_ovfl      7
#define MSK_NX90_eth_irq_masked_rx_cpu_too_slow   0x00000100U
#define SRT_NX90_eth_irq_masked_rx_cpu_too_slow   8
#define MSK_NX90_eth_irq_masked_rx_short_dv       0x00000200U
#define SRT_NX90_eth_irq_masked_rx_short_dv       9
#define MSK_NX90_eth_irq_masked_rx_preamble_error 0x00000400U
#define SRT_NX90_eth_irq_masked_rx_preamble_error 10
#define MSK_NX90_eth_irq_masked_tx_col            0x00000800U
#define SRT_NX90_eth_irq_masked_tx_col            11
#define MSK_NX90_eth_irq_masked_tx_late_col       0x00001000U
#define SRT_NX90_eth_irq_masked_tx_late_col       12

/* all used bits of 'NX90_eth_irq_masked': */
#define MSK_USED_BITS_NX90_eth_irq_masked 0x00001fffU

enum {
  BFW_NX90_eth_irq_masked_tx_fifo           = 1,  /* [0] */
  BFW_NX90_eth_irq_masked_tx_frame_finished = 1,  /* [1] */
  BFW_NX90_eth_irq_masked_rx_data           = 1,  /* [2] */
  BFW_NX90_eth_irq_masked_rx_frame_finished = 1,  /* [3] */
  BFW_NX90_eth_irq_masked_tx_fifo_undr      = 1,  /* [4] */
  BFW_NX90_eth_irq_masked_tx_fifo_ovfl      = 1,  /* [5] */
  BFW_NX90_eth_irq_masked_rx_fifo_undr      = 1,  /* [6] */
  BFW_NX90_eth_irq_masked_rx_fifo_ovfl      = 1,  /* [7] */
  BFW_NX90_eth_irq_masked_rx_cpu_too_slow   = 1,  /* [8] */
  BFW_NX90_eth_irq_masked_rx_short_dv       = 1,  /* [9] */
  BFW_NX90_eth_irq_masked_rx_preamble_error = 1,  /* [10] */
  BFW_NX90_eth_irq_masked_tx_col            = 1,  /* [11] */
  BFW_NX90_eth_irq_masked_tx_late_col       = 1,  /* [12] */
  BFW_NX90_eth_irq_masked_reserved1         = 19  /* [31:13] */
};

typedef struct NX90_ETH_IRQ_MASKED_BIT_Ttag {
  unsigned int tx_fifo           : BFW_NX90_eth_irq_masked_tx_fifo;           /* TX-FIFO has free entries                                        */
  unsigned int tx_frame_finished : BFW_NX90_eth_irq_masked_tx_frame_finished; /* TX frame finished                                               */
  unsigned int rx_data           : BFW_NX90_eth_irq_masked_rx_data;           /* RX Data is available                                            */
  unsigned int rx_frame_finished : BFW_NX90_eth_irq_masked_rx_frame_finished; /* RX frame finished                                               */
  unsigned int tx_fifo_undr      : BFW_NX90_eth_irq_masked_tx_fifo_undr;      /* TX-FIFO underrun                                                */
  unsigned int tx_fifo_ovfl      : BFW_NX90_eth_irq_masked_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)         */
  unsigned int rx_fifo_undr      : BFW_NX90_eth_irq_masked_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)         */
  unsigned int rx_fifo_ovfl      : BFW_NX90_eth_irq_masked_rx_fifo_ovfl;      /* RX-FIFO overflow                                                */
  unsigned int rx_cpu_too_slow   : BFW_NX90_eth_irq_masked_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared */
  unsigned int rx_short_dv       : BFW_NX90_eth_irq_masked_rx_short_dv;       /* mii_rxdv becomes low before SFD                                 */
  unsigned int rx_preamble_error : BFW_NX90_eth_irq_masked_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble         */
  unsigned int tx_col            : BFW_NX90_eth_irq_masked_tx_col;            /* collision detected in half_duplex mode, started sending jam     */
  unsigned int tx_late_col       : BFW_NX90_eth_irq_masked_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam */
  unsigned int reserved1         : BFW_NX90_eth_irq_masked_reserved1;         /* reserved                                                        */
} NX90_ETH_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_ETH_IRQ_MASKED_BIT_T bf;
} NX90_ETH_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_msk_set */
/* => IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_eth_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_irq_msk_set  0x00000030U
#define Adr_NX90_eth_eth_irq_msk_set  0xFF480030U
#define Adr_NX90_eth_irq_msk_set      0xFF480030U
#define DFLT_VAL_NX90_eth_irq_msk_set 0x00000000U

#define MSK_NX90_eth_irq_msk_set_tx_fifo                   0x00000001U
#define SRT_NX90_eth_irq_msk_set_tx_fifo                   0
#define DFLT_VAL_NX90_eth_irq_msk_set_tx_fifo              0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_tx_fifo           0x00000000U
#define MSK_NX90_eth_irq_msk_set_tx_frame_finished         0x00000002U
#define SRT_NX90_eth_irq_msk_set_tx_frame_finished         1
#define DFLT_VAL_NX90_eth_irq_msk_set_tx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_tx_frame_finished 0x00000000U
#define MSK_NX90_eth_irq_msk_set_rx_data                   0x00000004U
#define SRT_NX90_eth_irq_msk_set_rx_data                   2
#define DFLT_VAL_NX90_eth_irq_msk_set_rx_data              0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_rx_data           0x00000000U
#define MSK_NX90_eth_irq_msk_set_rx_frame_finished         0x00000008U
#define SRT_NX90_eth_irq_msk_set_rx_frame_finished         3
#define DFLT_VAL_NX90_eth_irq_msk_set_rx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_rx_frame_finished 0x00000000U
#define MSK_NX90_eth_irq_msk_set_tx_fifo_undr              0x00000010U
#define SRT_NX90_eth_irq_msk_set_tx_fifo_undr              4
#define DFLT_VAL_NX90_eth_irq_msk_set_tx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_tx_fifo_undr      0x00000000U
#define MSK_NX90_eth_irq_msk_set_tx_fifo_ovfl              0x00000020U
#define SRT_NX90_eth_irq_msk_set_tx_fifo_ovfl              5
#define DFLT_VAL_NX90_eth_irq_msk_set_tx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_tx_fifo_ovfl      0x00000000U
#define MSK_NX90_eth_irq_msk_set_rx_fifo_undr              0x00000040U
#define SRT_NX90_eth_irq_msk_set_rx_fifo_undr              6
#define DFLT_VAL_NX90_eth_irq_msk_set_rx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_rx_fifo_undr      0x00000000U
#define MSK_NX90_eth_irq_msk_set_rx_fifo_ovfl              0x00000080U
#define SRT_NX90_eth_irq_msk_set_rx_fifo_ovfl              7
#define DFLT_VAL_NX90_eth_irq_msk_set_rx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_rx_fifo_ovfl      0x00000000U
#define MSK_NX90_eth_irq_msk_set_rx_cpu_too_slow           0x00000100U
#define SRT_NX90_eth_irq_msk_set_rx_cpu_too_slow           8
#define DFLT_VAL_NX90_eth_irq_msk_set_rx_cpu_too_slow      0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_rx_cpu_too_slow   0x00000000U
#define MSK_NX90_eth_irq_msk_set_rx_short_dv               0x00000200U
#define SRT_NX90_eth_irq_msk_set_rx_short_dv               9
#define DFLT_VAL_NX90_eth_irq_msk_set_rx_short_dv          0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_rx_short_dv       0x00000000U
#define MSK_NX90_eth_irq_msk_set_rx_preamble_error         0x00000400U
#define SRT_NX90_eth_irq_msk_set_rx_preamble_error         10
#define DFLT_VAL_NX90_eth_irq_msk_set_rx_preamble_error    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_rx_preamble_error 0x00000000U
#define MSK_NX90_eth_irq_msk_set_tx_col                    0x00000800U
#define SRT_NX90_eth_irq_msk_set_tx_col                    11
#define DFLT_VAL_NX90_eth_irq_msk_set_tx_col               0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_tx_col            0x00000000U
#define MSK_NX90_eth_irq_msk_set_tx_late_col               0x00001000U
#define SRT_NX90_eth_irq_msk_set_tx_late_col               12
#define DFLT_VAL_NX90_eth_irq_msk_set_tx_late_col          0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_set_tx_late_col       0x00000000U

/* all used bits of 'NX90_eth_irq_msk_set': */
#define MSK_USED_BITS_NX90_eth_irq_msk_set 0x00001fffU

enum {
  BFW_NX90_eth_irq_msk_set_tx_fifo           = 1,  /* [0] */
  BFW_NX90_eth_irq_msk_set_tx_frame_finished = 1,  /* [1] */
  BFW_NX90_eth_irq_msk_set_rx_data           = 1,  /* [2] */
  BFW_NX90_eth_irq_msk_set_rx_frame_finished = 1,  /* [3] */
  BFW_NX90_eth_irq_msk_set_tx_fifo_undr      = 1,  /* [4] */
  BFW_NX90_eth_irq_msk_set_tx_fifo_ovfl      = 1,  /* [5] */
  BFW_NX90_eth_irq_msk_set_rx_fifo_undr      = 1,  /* [6] */
  BFW_NX90_eth_irq_msk_set_rx_fifo_ovfl      = 1,  /* [7] */
  BFW_NX90_eth_irq_msk_set_rx_cpu_too_slow   = 1,  /* [8] */
  BFW_NX90_eth_irq_msk_set_rx_short_dv       = 1,  /* [9] */
  BFW_NX90_eth_irq_msk_set_rx_preamble_error = 1,  /* [10] */
  BFW_NX90_eth_irq_msk_set_tx_col            = 1,  /* [11] */
  BFW_NX90_eth_irq_msk_set_tx_late_col       = 1,  /* [12] */
  BFW_NX90_eth_irq_msk_set_reserved1         = 19  /* [31:13] */
};

typedef struct NX90_ETH_IRQ_MSK_SET_BIT_Ttag {
  unsigned int tx_fifo           : BFW_NX90_eth_irq_msk_set_tx_fifo;           /* TX-FIFO has free entries                                        */
  unsigned int tx_frame_finished : BFW_NX90_eth_irq_msk_set_tx_frame_finished; /* TX frame finished                                               */
  unsigned int rx_data           : BFW_NX90_eth_irq_msk_set_rx_data;           /* RX Data is available                                            */
  unsigned int rx_frame_finished : BFW_NX90_eth_irq_msk_set_rx_frame_finished; /* RX frame finished                                               */
  unsigned int tx_fifo_undr      : BFW_NX90_eth_irq_msk_set_tx_fifo_undr;      /* TX-FIFO underrun                                                */
  unsigned int tx_fifo_ovfl      : BFW_NX90_eth_irq_msk_set_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)         */
  unsigned int rx_fifo_undr      : BFW_NX90_eth_irq_msk_set_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)         */
  unsigned int rx_fifo_ovfl      : BFW_NX90_eth_irq_msk_set_rx_fifo_ovfl;      /* RX-FIFO overflow                                                */
  unsigned int rx_cpu_too_slow   : BFW_NX90_eth_irq_msk_set_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared */
  unsigned int rx_short_dv       : BFW_NX90_eth_irq_msk_set_rx_short_dv;       /* mii_rxdv becomes low before SFD                                 */
  unsigned int rx_preamble_error : BFW_NX90_eth_irq_msk_set_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble         */
  unsigned int tx_col            : BFW_NX90_eth_irq_msk_set_tx_col;            /* collision detected in half_duplex mode, started sending jam     */
  unsigned int tx_late_col       : BFW_NX90_eth_irq_msk_set_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam */
  unsigned int reserved1         : BFW_NX90_eth_irq_msk_set_reserved1;         /* reserved                                                        */
} NX90_ETH_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_ETH_IRQ_MSK_SET_BIT_T bf;
} NX90_ETH_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_msk_reset */
/* => IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_eth_irq_msk_reset  0x00000034U
#define Adr_NX90_eth_eth_irq_msk_reset  0xFF480034U
#define Adr_NX90_eth_irq_msk_reset      0xFF480034U
#define DFLT_VAL_NX90_eth_irq_msk_reset 0x00000000U

#define MSK_NX90_eth_irq_msk_reset_tx_fifo                   0x00000001U
#define SRT_NX90_eth_irq_msk_reset_tx_fifo                   0
#define DFLT_VAL_NX90_eth_irq_msk_reset_tx_fifo              0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_tx_fifo           0x00000000U
#define MSK_NX90_eth_irq_msk_reset_tx_frame_finished         0x00000002U
#define SRT_NX90_eth_irq_msk_reset_tx_frame_finished         1
#define DFLT_VAL_NX90_eth_irq_msk_reset_tx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_tx_frame_finished 0x00000000U
#define MSK_NX90_eth_irq_msk_reset_rx_data                   0x00000004U
#define SRT_NX90_eth_irq_msk_reset_rx_data                   2
#define DFLT_VAL_NX90_eth_irq_msk_reset_rx_data              0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_rx_data           0x00000000U
#define MSK_NX90_eth_irq_msk_reset_rx_frame_finished         0x00000008U
#define SRT_NX90_eth_irq_msk_reset_rx_frame_finished         3
#define DFLT_VAL_NX90_eth_irq_msk_reset_rx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_rx_frame_finished 0x00000000U
#define MSK_NX90_eth_irq_msk_reset_tx_fifo_undr              0x00000010U
#define SRT_NX90_eth_irq_msk_reset_tx_fifo_undr              4
#define DFLT_VAL_NX90_eth_irq_msk_reset_tx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_tx_fifo_undr      0x00000000U
#define MSK_NX90_eth_irq_msk_reset_tx_fifo_ovfl              0x00000020U
#define SRT_NX90_eth_irq_msk_reset_tx_fifo_ovfl              5
#define DFLT_VAL_NX90_eth_irq_msk_reset_tx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_tx_fifo_ovfl      0x00000000U
#define MSK_NX90_eth_irq_msk_reset_rx_fifo_undr              0x00000040U
#define SRT_NX90_eth_irq_msk_reset_rx_fifo_undr              6
#define DFLT_VAL_NX90_eth_irq_msk_reset_rx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_rx_fifo_undr      0x00000000U
#define MSK_NX90_eth_irq_msk_reset_rx_fifo_ovfl              0x00000080U
#define SRT_NX90_eth_irq_msk_reset_rx_fifo_ovfl              7
#define DFLT_VAL_NX90_eth_irq_msk_reset_rx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_rx_fifo_ovfl      0x00000000U
#define MSK_NX90_eth_irq_msk_reset_rx_cpu_too_slow           0x00000100U
#define SRT_NX90_eth_irq_msk_reset_rx_cpu_too_slow           8
#define DFLT_VAL_NX90_eth_irq_msk_reset_rx_cpu_too_slow      0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_rx_cpu_too_slow   0x00000000U
#define MSK_NX90_eth_irq_msk_reset_rx_short_dv               0x00000200U
#define SRT_NX90_eth_irq_msk_reset_rx_short_dv               9
#define DFLT_VAL_NX90_eth_irq_msk_reset_rx_short_dv          0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_rx_short_dv       0x00000000U
#define MSK_NX90_eth_irq_msk_reset_rx_preamble_error         0x00000400U
#define SRT_NX90_eth_irq_msk_reset_rx_preamble_error         10
#define DFLT_VAL_NX90_eth_irq_msk_reset_rx_preamble_error    0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_rx_preamble_error 0x00000000U
#define MSK_NX90_eth_irq_msk_reset_tx_col                    0x00000800U
#define SRT_NX90_eth_irq_msk_reset_tx_col                    11
#define DFLT_VAL_NX90_eth_irq_msk_reset_tx_col               0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_tx_col            0x00000000U
#define MSK_NX90_eth_irq_msk_reset_tx_late_col               0x00001000U
#define SRT_NX90_eth_irq_msk_reset_tx_late_col               12
#define DFLT_VAL_NX90_eth_irq_msk_reset_tx_late_col          0x00000000U
#define DFLT_BF_VAL_NX90_eth_irq_msk_reset_tx_late_col       0x00000000U

/* all used bits of 'NX90_eth_irq_msk_reset': */
#define MSK_USED_BITS_NX90_eth_irq_msk_reset 0x00001fffU

enum {
  BFW_NX90_eth_irq_msk_reset_tx_fifo           = 1,  /* [0] */
  BFW_NX90_eth_irq_msk_reset_tx_frame_finished = 1,  /* [1] */
  BFW_NX90_eth_irq_msk_reset_rx_data           = 1,  /* [2] */
  BFW_NX90_eth_irq_msk_reset_rx_frame_finished = 1,  /* [3] */
  BFW_NX90_eth_irq_msk_reset_tx_fifo_undr      = 1,  /* [4] */
  BFW_NX90_eth_irq_msk_reset_tx_fifo_ovfl      = 1,  /* [5] */
  BFW_NX90_eth_irq_msk_reset_rx_fifo_undr      = 1,  /* [6] */
  BFW_NX90_eth_irq_msk_reset_rx_fifo_ovfl      = 1,  /* [7] */
  BFW_NX90_eth_irq_msk_reset_rx_cpu_too_slow   = 1,  /* [8] */
  BFW_NX90_eth_irq_msk_reset_rx_short_dv       = 1,  /* [9] */
  BFW_NX90_eth_irq_msk_reset_rx_preamble_error = 1,  /* [10] */
  BFW_NX90_eth_irq_msk_reset_tx_col            = 1,  /* [11] */
  BFW_NX90_eth_irq_msk_reset_tx_late_col       = 1,  /* [12] */
  BFW_NX90_eth_irq_msk_reset_reserved1         = 19  /* [31:13] */
};

typedef struct NX90_ETH_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int tx_fifo           : BFW_NX90_eth_irq_msk_reset_tx_fifo;           /* TX-FIFO has free entries                                        */
  unsigned int tx_frame_finished : BFW_NX90_eth_irq_msk_reset_tx_frame_finished; /* TX frame finished                                               */
  unsigned int rx_data           : BFW_NX90_eth_irq_msk_reset_rx_data;           /* RX Data is available                                            */
  unsigned int rx_frame_finished : BFW_NX90_eth_irq_msk_reset_rx_frame_finished; /* RX frame finished                                               */
  unsigned int tx_fifo_undr      : BFW_NX90_eth_irq_msk_reset_tx_fifo_undr;      /* TX-FIFO underrun                                                */
  unsigned int tx_fifo_ovfl      : BFW_NX90_eth_irq_msk_reset_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)         */
  unsigned int rx_fifo_undr      : BFW_NX90_eth_irq_msk_reset_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)         */
  unsigned int rx_fifo_ovfl      : BFW_NX90_eth_irq_msk_reset_rx_fifo_ovfl;      /* RX-FIFO overflow                                                */
  unsigned int rx_cpu_too_slow   : BFW_NX90_eth_irq_msk_reset_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared */
  unsigned int rx_short_dv       : BFW_NX90_eth_irq_msk_reset_rx_short_dv;       /* mii_rxdv becomes low before SFD                                 */
  unsigned int rx_preamble_error : BFW_NX90_eth_irq_msk_reset_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble         */
  unsigned int tx_col            : BFW_NX90_eth_irq_msk_reset_tx_col;            /* collision detected in half_duplex mode, started sending jam     */
  unsigned int tx_late_col       : BFW_NX90_eth_irq_msk_reset_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam */
  unsigned int reserved1         : BFW_NX90_eth_irq_msk_reset_reserved1;         /* reserved                                                        */
} NX90_ETH_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_ETH_IRQ_MSK_RESET_BIT_T bf;
} NX90_ETH_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* Area of intlogic_app */

/* ===================================================================== */

#define Addr_NX90_intlogic_app 0xFF800000U

/* ===================================================================== */

/* AREA dmac */
/* Area of dmac_app */

/* ===================================================================== */

#define Addr_NX90_dmac_app 0xFF800000U

/* ===================================================================== */

/* AREA dmac_ch */
/* Area of dmac_app_ch0, dmac_app_ch1, dmac_app_ch2 */

/* ===================================================================== */

#define Addr_NX90_dmac_app_ch0 0xFF800100U
#define Addr_NX90_dmac_app_ch1 0xFF800120U
#define Addr_NX90_dmac_app_ch2 0xFF800140U

/* --------------------------------------------------------------------- */
/* Register dmac_chsrc_ad */
/* => channel source address registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_chsrc_ad          0x00000000U
#define Adr_NX90_dmac_app_ch0_dmac_chsrc_ad 0xFF800100U
#define Adr_NX90_dmac_app_ch1_dmac_chsrc_ad 0xFF800120U
#define Adr_NX90_dmac_app_ch2_dmac_chsrc_ad 0xFF800140U
#define DFLT_VAL_NX90_dmac_chsrc_ad         0x00000000U

#define MSK_NX90_dmac_chsrc_ad_DMACCHSRCADDR         0xffffffffU
#define SRT_NX90_dmac_chsrc_ad_DMACCHSRCADDR         0
#define DFLT_VAL_NX90_dmac_chsrc_ad_DMACCHSRCADDR    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chsrc_ad_DMACCHSRCADDR 0x00000000U

/* all used bits of 'NX90_dmac_chsrc_ad': */
#define MSK_USED_BITS_NX90_dmac_chsrc_ad 0xffffffffU

enum {
  BFW_NX90_dmac_chsrc_ad_DMACCHSRCADDR = 32  /* [31:0] */
};

typedef struct NX90_DMAC_CHSRC_AD_BIT_Ttag {
  unsigned int DMACCHSRCADDR : BFW_NX90_dmac_chsrc_ad_DMACCHSRCADDR; /* DMA source address */
} NX90_DMAC_CHSRC_AD_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_DMAC_CHSRC_AD_BIT_T bf;
} NX90_DMAC_CHSRC_AD_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chdest_ad */
/* => channel destination address registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_chdest_ad          0x00000004U
#define Adr_NX90_dmac_app_ch0_dmac_chdest_ad 0xFF800104U
#define Adr_NX90_dmac_app_ch1_dmac_chdest_ad 0xFF800124U
#define Adr_NX90_dmac_app_ch2_dmac_chdest_ad 0xFF800144U
#define DFLT_VAL_NX90_dmac_chdest_ad         0x00000000U

#define MSK_NX90_dmac_chdest_ad_DMACCHDESTADDR         0xffffffffU
#define SRT_NX90_dmac_chdest_ad_DMACCHDESTADDR         0
#define DFLT_VAL_NX90_dmac_chdest_ad_DMACCHDESTADDR    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chdest_ad_DMACCHDESTADDR 0x00000000U

/* all used bits of 'NX90_dmac_chdest_ad': */
#define MSK_USED_BITS_NX90_dmac_chdest_ad 0xffffffffU

enum {
  BFW_NX90_dmac_chdest_ad_DMACCHDESTADDR = 32  /* [31:0] */
};

typedef struct NX90_DMAC_CHDEST_AD_BIT_Ttag {
  unsigned int DMACCHDESTADDR : BFW_NX90_dmac_chdest_ad_DMACCHDESTADDR; /* DMA destination address */
} NX90_DMAC_CHDEST_AD_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_DMAC_CHDEST_AD_BIT_T bf;
} NX90_DMAC_CHDEST_AD_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chlink */
/* => channel linked list item register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_chlink          0x00000008U
#define Adr_NX90_dmac_app_ch0_dmac_chlink 0xFF800108U
#define Adr_NX90_dmac_app_ch1_dmac_chlink 0xFF800128U
#define Adr_NX90_dmac_app_ch2_dmac_chlink 0xFF800148U
#define DFLT_VAL_NX90_dmac_chlink         0x00000000U

#define MSK_NX90_dmac_chlink_LLIADDR         0xfffffffcU
#define SRT_NX90_dmac_chlink_LLIADDR         2
#define DFLT_VAL_NX90_dmac_chlink_LLIADDR    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chlink_LLIADDR 0x00000000U

/* all used bits of 'NX90_dmac_chlink': */
#define MSK_USED_BITS_NX90_dmac_chlink 0xfffffffcU

enum {
  BFW_NX90_dmac_chlink_reserved1 = 2,  /* [1:0] */
  BFW_NX90_dmac_chlink_LLIADDR   = 30  /* [31:2] */
};

typedef struct NX90_DMAC_CHLINK_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_dmac_chlink_reserved1; /* reserved                                                                                 */
  unsigned int LLIADDR   : BFW_NX90_dmac_chlink_LLIADDR;   /* Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0. */
} NX90_DMAC_CHLINK_BIT_T;

typedef union {
  uint32_t               val;
  NX90_DMAC_CHLINK_BIT_T bf;
} NX90_DMAC_CHLINK_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chctrl */
/* => channel control registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_chctrl          0x0000000CU
#define Adr_NX90_dmac_app_ch0_dmac_chctrl 0xFF80010CU
#define Adr_NX90_dmac_app_ch1_dmac_chctrl 0xFF80012CU
#define Adr_NX90_dmac_app_ch2_dmac_chctrl 0xFF80014CU
#define DFLT_VAL_NX90_dmac_chctrl         0x00000000U

#define MSK_NX90_dmac_chctrl_TransferSize         0x00000fffU
#define SRT_NX90_dmac_chctrl_TransferSize         0
#define DFLT_VAL_NX90_dmac_chctrl_TransferSize    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_TransferSize 0x00000000U
#define MSK_NX90_dmac_chctrl_SBSize               0x00007000U
#define SRT_NX90_dmac_chctrl_SBSize               12
#define DFLT_VAL_NX90_dmac_chctrl_SBSize          0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_SBSize       0x00000000U
#define MSK_NX90_dmac_chctrl_DBSize               0x00038000U
#define SRT_NX90_dmac_chctrl_DBSize               15
#define DFLT_VAL_NX90_dmac_chctrl_DBSize          0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_DBSize       0x00000000U
#define MSK_NX90_dmac_chctrl_SWidth               0x001c0000U
#define SRT_NX90_dmac_chctrl_SWidth               18
#define DFLT_VAL_NX90_dmac_chctrl_SWidth          0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_SWidth       0x00000000U
#define MSK_NX90_dmac_chctrl_DWidth               0x00e00000U
#define SRT_NX90_dmac_chctrl_DWidth               21
#define DFLT_VAL_NX90_dmac_chctrl_DWidth          0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_DWidth       0x00000000U
#define MSK_NX90_dmac_chctrl_ARM_EQ               0x01000000U
#define SRT_NX90_dmac_chctrl_ARM_EQ               24
#define DFLT_VAL_NX90_dmac_chctrl_ARM_EQ          0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_ARM_EQ       0x00000000U
#define MSK_NX90_dmac_chctrl_SI                   0x04000000U
#define SRT_NX90_dmac_chctrl_SI                   26
#define DFLT_VAL_NX90_dmac_chctrl_SI              0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_SI           0x00000000U
#define MSK_NX90_dmac_chctrl_DI                   0x08000000U
#define SRT_NX90_dmac_chctrl_DI                   27
#define DFLT_VAL_NX90_dmac_chctrl_DI              0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_DI           0x00000000U
#define MSK_NX90_dmac_chctrl_Prot                 0x70000000U
#define SRT_NX90_dmac_chctrl_Prot                 28
#define DFLT_VAL_NX90_dmac_chctrl_Prot            0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_Prot         0x00000000U
#define MSK_NX90_dmac_chctrl_I                    0x80000000U
#define SRT_NX90_dmac_chctrl_I                    31
#define DFLT_VAL_NX90_dmac_chctrl_I               0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chctrl_I            0x00000000U

/* all used bits of 'NX90_dmac_chctrl': */
#define MSK_USED_BITS_NX90_dmac_chctrl 0xfdffffffU

enum {
  BFW_NX90_dmac_chctrl_TransferSize = 12, /* [11:0] */
  BFW_NX90_dmac_chctrl_SBSize       = 3,  /* [14:12] */
  BFW_NX90_dmac_chctrl_DBSize       = 3,  /* [17:15] */
  BFW_NX90_dmac_chctrl_SWidth       = 3,  /* [20:18] */
  BFW_NX90_dmac_chctrl_DWidth       = 3,  /* [23:21] */
  BFW_NX90_dmac_chctrl_ARM_EQ       = 1,  /* [24] */
  BFW_NX90_dmac_chctrl_reserved1    = 1,  /* [25] */
  BFW_NX90_dmac_chctrl_SI           = 1,  /* [26] */
  BFW_NX90_dmac_chctrl_DI           = 1,  /* [27] */
  BFW_NX90_dmac_chctrl_Prot         = 3,  /* [30:28] */
  BFW_NX90_dmac_chctrl_I            = 1   /* [31] */
};

typedef struct NX90_DMAC_CHCTRL_BIT_Ttag {
  unsigned int TransferSize : BFW_NX90_dmac_chctrl_TransferSize; /* Transfer size:                                                                                                                                               */
                                                                 /* For writes, this field indicates the number of (Source width) transfers to perform when the DMAC is the flow controller.                                     */
                                                                 /* For reads, the transfer size indicates the number of transfers completed on the destination bus.                                                             */
                                                                 /* Reading the register when the channel is active does not give useful information,                                                                            */
                                                                 /* as by the time that the software has processed the value read,                                                                                               */
                                                                 /* the channel might have progressed.                                                                                                                           */
                                                                 /* It is intended to be used only when a channel is enabled and then disabled.                                                                                  */
                                                                 /* If the DMAC controller is not the flow controller the transfer size should be set to 0.                                                                      */
  unsigned int SBSize       : BFW_NX90_dmac_chctrl_SBSize;       /* Source burst size:                                                                                                                                           */
                                                                 /* Indicates the number of transfers which make up a source burst.                                                                                              */
                                                                 /* This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size.                                  */
                                                                 /* The burst size is the amount of data that is transferred when the DMACxBREQ signal goes active in the source peripheral.                                     */
                                                                 /* The burst size is not related to the AHB HBURST signal.                                                                                                      */
                                                                 /* ________________________________                                                                                                                             */
                                                                 /* bit_value    burst_transfer_size                                                                                                                             */
                                                                 /* --------------------------------                                                                                                                             */
                                                                 /*  000         1                                                                                                                                               */
                                                                 /*  001         4                                                                                                                                               */
                                                                 /*  010         8                                                                                                                                               */
                                                                 /*  011         16                                                                                                                                              */
                                                                 /*  100         32                                                                                                                                              */
                                                                 /*  101         64                                                                                                                                              */
                                                                 /*  110         128                                                                                                                                             */
                                                                 /*  111         256                                                                                                                                             */
                                                                 /* ================================                                                                                                                             */
  unsigned int DBSize       : BFW_NX90_dmac_chctrl_DBSize;       /* Destination burst size:                                                                                                                                      */
                                                                 /* Indicates the number of transfers which make up a destination burst transfer request.                                                                        */
                                                                 /* This value must be set to the burst size of the destination peripheral, or if the destination is memory, to the memory boundary size.                        */
                                                                 /* The burst size is the amount of data that is transferred when the DMACxBREQ signal goes active in the destination peripheral.                                */
                                                                 /* The burst size is not related to the AHB HBURST signal.                                                                                                      */
                                                                 /* Note: If flow controller is DMAC and destination is a peripheral, only bursts are transferred to the peripheral (DMACxSREQ is ignored if set by peripheral). */
                                                                 /*       The source burst size has no such limitation.                                                                                                          */
                                                                 /* ________________________________                                                                                                                             */
                                                                 /* bit_value    burst_transfer_size                                                                                                                             */
                                                                 /* --------------------------------                                                                                                                             */
                                                                 /*  000         1                                                                                                                                               */
                                                                 /*  001         4                                                                                                                                               */
                                                                 /*  010         8                                                                                                                                               */
                                                                 /*  011         16                                                                                                                                              */
                                                                 /*  100         32                                                                                                                                              */
                                                                 /*  101         64                                                                                                                                              */
                                                                 /*  110         128                                                                                                                                             */
                                                                 /*  111         256                                                                                                                                             */
                                                                 /* ================================                                                                                                                             */
  unsigned int SWidth       : BFW_NX90_dmac_chctrl_SWidth;       /* Source transfer width:                                                                                                                                       */
                                                                 /* The source and destination widths can be different from each other.                                                                                          */
                                                                 /* The hardware automatically packs and unpacks the data as required.                                                                                           */
                                                                 /* _________________________                                                                                                                                    */
                                                                 /* bit_value      data_width                                                                                                                                    */
                                                                 /* -------------------------                                                                                                                                    */
                                                                 /*  000             8 bit                                                                                                                                       */
                                                                 /*  001            16 bit                                                                                                                                       */
                                                                 /*  010            32 bit                                                                                                                                       */
                                                                 /* =========================                                                                                                                                    */
  unsigned int DWidth       : BFW_NX90_dmac_chctrl_DWidth;       /* Destination transfer width:                                                                                                                                  */
                                                                 /* The source and destination widths can be different from each other.                                                                                          */
                                                                 /* The hardware automatically packs and unpacks the data as required.                                                                                           */
                                                                 /* _________________________                                                                                                                                    */
                                                                 /* bit_value      data_width                                                                                                                                    */
                                                                 /* -------------------------                                                                                                                                    */
                                                                 /*  000             8 bit                                                                                                                                       */
                                                                 /*  001            16 bit                                                                                                                                       */
                                                                 /*  010            32 bit                                                                                                                                       */
                                                                 /* =========================                                                                                                                                    */
  unsigned int ARM_EQ       : BFW_NX90_dmac_chctrl_ARM_EQ;       /* Set equal behaviour to arm implementation                                                                                                                    */
                                                                 /* This bit should always be set to 1 (default of 0 is from historical reasons).                                                                                */
                                                                 /* This bit changes 2 behavioural details:                                                                                                                      */
                                                                 /* 1. ARM_EQ=1: ignore single requests in DMA-controlled Memory-to-Peripheral accesses.                                                                         */
                                                                 /*    ARM_EQ=0: handle single requests like burst requests (in this case DBSize should be 1 access).                                                            */
                                                                 /*    Note: In DMA-controlled Memory-to-Peripheral mode only burst request signals are allowed.                                                                 */
                                                                 /*          The behaviour of single requests (from peripheral to DMAC) is not defined.                                                                          */
                                                                 /*          Modules generating single requests anyways might use ARM_EQ=0 in combination with DBSize=000.                                                       */
                                                                 /* 2. ARM_EQ=1: Always read 0 from TransferSize in this register.                                                                                               */
                                                                 /*    ARM_EQ=0: Read some internal value for debug purposes                                                                                                     */
  unsigned int reserved1    : BFW_NX90_dmac_chctrl_reserved1;    /* reserved                                                                                                                                                     */
  unsigned int SI           : BFW_NX90_dmac_chctrl_SI;           /* Source increment. When set the source address is incremented after each transfer.                                                                            */
  unsigned int DI           : BFW_NX90_dmac_chctrl_DI;           /* Destination increment. When set the destination address is incremented after each transfer.                                                                  */
  unsigned int Prot         : BFW_NX90_dmac_chctrl_Prot;         /* Protection.                                                                                                                                                  */
  unsigned int I            : BFW_NX90_dmac_chctrl_I;            /* Terminal count interrupt enable bit. It controls whether the current LLI is expected to trigger the terminal count interrupt.                                */
} NX90_DMAC_CHCTRL_BIT_T;

typedef union {
  uint32_t               val;
  NX90_DMAC_CHCTRL_BIT_T bf;
} NX90_DMAC_CHCTRL_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chcfg */
/* => channel configuration registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_chcfg          0x00000010U
#define Adr_NX90_dmac_app_ch0_dmac_chcfg 0xFF800110U
#define Adr_NX90_dmac_app_ch1_dmac_chcfg 0xFF800130U
#define Adr_NX90_dmac_app_ch2_dmac_chcfg 0xFF800150U
#define DFLT_VAL_NX90_dmac_chcfg         0x00000000U

#define MSK_NX90_dmac_chcfg_E                      0x00000001U
#define SRT_NX90_dmac_chcfg_E                      0
#define DFLT_VAL_NX90_dmac_chcfg_E                 0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_E              0x00000000U
#define MSK_NX90_dmac_chcfg_SrcPeripheral          0x0000001eU
#define SRT_NX90_dmac_chcfg_SrcPeripheral          1
#define DFLT_VAL_NX90_dmac_chcfg_SrcPeripheral     0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_SrcPeripheral  0x00000000U
#define MSK_NX90_dmac_chcfg_DestPeripheral         0x000003c0U
#define SRT_NX90_dmac_chcfg_DestPeripheral         6
#define DFLT_VAL_NX90_dmac_chcfg_DestPeripheral    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_DestPeripheral 0x00000000U
#define MSK_NX90_dmac_chcfg_FlowCntrl              0x00003800U
#define SRT_NX90_dmac_chcfg_FlowCntrl              11
#define DFLT_VAL_NX90_dmac_chcfg_FlowCntrl         0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_FlowCntrl      0x00000000U
#define MSK_NX90_dmac_chcfg_IE                     0x00004000U
#define SRT_NX90_dmac_chcfg_IE                     14
#define DFLT_VAL_NX90_dmac_chcfg_IE                0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_IE             0x00000000U
#define MSK_NX90_dmac_chcfg_ITC                    0x00008000U
#define SRT_NX90_dmac_chcfg_ITC                    15
#define DFLT_VAL_NX90_dmac_chcfg_ITC               0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_ITC            0x00000000U
#define MSK_NX90_dmac_chcfg_L                      0x00010000U
#define SRT_NX90_dmac_chcfg_L                      16
#define DFLT_VAL_NX90_dmac_chcfg_L                 0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_L              0x00000000U
#define MSK_NX90_dmac_chcfg_A                      0x00020000U
#define SRT_NX90_dmac_chcfg_A                      17
#define DFLT_VAL_NX90_dmac_chcfg_A                 0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_A              0x00000000U
#define MSK_NX90_dmac_chcfg_H                      0x00040000U
#define SRT_NX90_dmac_chcfg_H                      18
#define DFLT_VAL_NX90_dmac_chcfg_H                 0x00000000U
#define DFLT_BF_VAL_NX90_dmac_chcfg_H              0x00000000U

/* all used bits of 'NX90_dmac_chcfg': */
#define MSK_USED_BITS_NX90_dmac_chcfg 0x0007fbdfU

enum {
  BFW_NX90_dmac_chcfg_E              = 1,  /* [0] */
  BFW_NX90_dmac_chcfg_SrcPeripheral  = 4,  /* [4:1] */
  BFW_NX90_dmac_chcfg_reserved1      = 1,  /* [5] */
  BFW_NX90_dmac_chcfg_DestPeripheral = 4,  /* [9:6] */
  BFW_NX90_dmac_chcfg_reserved2      = 1,  /* [10] */
  BFW_NX90_dmac_chcfg_FlowCntrl      = 3,  /* [13:11] */
  BFW_NX90_dmac_chcfg_IE             = 1,  /* [14] */
  BFW_NX90_dmac_chcfg_ITC            = 1,  /* [15] */
  BFW_NX90_dmac_chcfg_L              = 1,  /* [16] */
  BFW_NX90_dmac_chcfg_A              = 1,  /* [17] */
  BFW_NX90_dmac_chcfg_H              = 1,  /* [18] */
  BFW_NX90_dmac_chcfg_reserved3      = 13  /* [31:19] */
};

typedef struct NX90_DMAC_CHCFG_BIT_Ttag {
  unsigned int E              : BFW_NX90_dmac_chcfg_E;              /* Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled 1 = channel enabled.                                          */
                                                                    /* The Channel Enable bit status can also be found by reading the DMACEnbldChns register.                                                                                            */
                                                                    /* A channel is enabled by setting this bit. Before enabling a single channel the DMA controller must be enabled globally by setting the DMACENABLE bit in the dmac_config register. */
                                                                    /* Enabling a channel while the controller is disabled leads to undefined behaviour. A channel can be disabled by clearing the Enable bit.                                           */
                                                                    /* This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled.                                                                        */
                                                                    /* Any data in the channels FIFO is lost.                                                                                                                                            */
                                                                    /* Restarting the channel by simply setting the Channel Enable bit has unpredictable effects and the channel must be fully re-initialized.                                           */
                                                                    /* The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached or if a channel error is encountered.                                                  */
                                                                    /* If a channel has to be disabled without losing data in a channels FIFO the Halt bit must be set so that further DMA requests are ignored.                                         */
                                                                    /* The Active bit must then be polled until it reaches 0, indicating that there is no data left in the channels FIFO.                                                                */
                                                                    /* Finally the Channel Enable bit can be cleared.                                                                                                                                    */
  unsigned int SrcPeripheral  : BFW_NX90_dmac_chcfg_SrcPeripheral;  /* Source peripheral. This value selects the DMA source request peripheral.                                                                                                          */
                                                                    /* This field is ignored if the source of the transfer is from memory.                                                                                                               */
                                                                    /* Note: The mapping of peripherals to App-side DMAC inputs is done within the DMAC_MUX_APP module.                                                                                  */
                                                                    /* See 'dmac_mux_peripheral_input_sel*' registers for default mapping / current mapping.                                                                                             */
                                                                    /* {      |                  |                                                                                                                                                       */
                                                                    /*  value   Com-side           App-side                                                                                                                                              */
                                                                    /*  0        uart_rx           dmac_mux_peripheral_input_sel0                                                                                                                        */
                                                                    /*  1        uart_tx           dmac_mux_peripheral_input_sel1                                                                                                                        */
                                                                    /*  2        i2c0_com_master   dmac_mux_peripheral_input_sel2                                                                                                                        */
                                                                    /*  3        i2c0_com_slave    dmac_mux_peripheral_input_sel3                                                                                                                        */
                                                                    /*  4        i2c1_com_master   dmac_mux_peripheral_input_sel4                                                                                                                        */
                                                                    /*  5        i2c1_com_slave    dmac_mux_peripheral_input_sel5                                                                                                                        */
                                                                    /*  6        sqi_rx            reserved                                                                                                                                              */
                                                                    /*  7        sqi_tx            reserved                                                                                                                                              */
                                                                    /*  8        eth_rx            reserved                                                                                                                                              */
                                                                    /*  9        eth_tx            reserved                                                                                                                                              */
                                                                    /*  10       hash              reserved                                                                                                                                              */
                                                                    /*  11       aes_in            reserved                                                                                                                                              */
                                                                    /*  12       aes_out           reserved                                                                                                                                              */
                                                                    /*  13       mtgy0             reserved                                                                                                                                              */
                                                                    /*  14       mtgy1             reserved                                                                                                                                              */
                                                                    /*  15       reserved          reserved                                                                                                                                              */
                                                                    /* }                                                                                                                                                                                 */
  unsigned int reserved1      : BFW_NX90_dmac_chcfg_reserved1;      /* reserved                                                                                                                                                                          */
  unsigned int DestPeripheral : BFW_NX90_dmac_chcfg_DestPeripheral; /* Destination peripheral. This value selects the DMA destination request peripheral.                                                                                                */
                                                                    /* This field is ignored if the destination of the transfer is to memory.                                                                                                            */
                                                                    /* For mapping of peripheral to value see 'SrcPeripheral' bit-field in this register.                                                                                                */
  unsigned int reserved2      : BFW_NX90_dmac_chcfg_reserved2;      /* reserved                                                                                                                                                                          */
  unsigned int FlowCntrl      : BFW_NX90_dmac_chcfg_FlowCntrl;      /* Flow control and transfer type. This value is used to indicate the flow controller and transfer type.                                                                             */
                                                                    /* The flow controller can be the DMAC, the source peripheral, or the destination peripheral.                                                                                        */
                                                                    /* The transfer type can be either memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral.                                                        */
                                                                    /* _______________________________________________________________________                                                                                                           */
                                                                    /* bit_value     transfer_type                                  controller                                                                                                           */
                                                                    /* -----------------------------------------------------------------------                                                                                                           */
                                                                    /* 000           Memory-to-memory                               DMAC                                                                                                                 */
                                                                    /* 001           Memory-to-peripheral                           DMAC                                                                                                                 */
                                                                    /* 010           Peripheral-to-memorys                          DMAC                                                                                                                 */
                                                                    /* 011           Source peripheral-to-destination peripheral    DMAC (not supported in netX system)                                                                                  */
                                                                    /* 100           Source peripheral-to-destination peripheral    Destination peripheral (not supported in netX system)                                                                */
                                                                    /* 101           Memory-to-peripheral                           Peripheral                                                                                                           */
                                                                    /* 110           Peripheral-to-memory                           Peripheral                                                                                                           */
                                                                    /* 111           Source peripheral-to-destination peripheral    Source peripheral (not supported in netX system)                                                                     */
                                                                    /* ========================================================================                                                                                                          */
                                                                    /* Note: Peripheral-to-peripheral transfers are configurable, but not supported in the netX system. Don't use these                                                                  */
                                                                    /* three modes.                                                                                                                                                                      */
  unsigned int IE             : BFW_NX90_dmac_chcfg_IE;             /* Interrupt error mask. When cleared this bit masks out the error interrupt of the relevant channel.                                                                                */
  unsigned int ITC            : BFW_NX90_dmac_chcfg_ITC;            /* Terminal count interrupt mask. When cleared this bit masks out the terminal count interrupt of the relevant channel.                                                              */
  unsigned int L              : BFW_NX90_dmac_chcfg_L;              /* Lock. When set this bit enables locked transfers.                                                                                                                                 */
  unsigned int A              : BFW_NX90_dmac_chcfg_A;              /* Active: 0 = there is no data in the FIFO of the channel 1 = the FIFO of the channel has data. (ro)                                                                                */
                                                                    /* This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel.                                                                                    */
  unsigned int H              : BFW_NX90_dmac_chcfg_H;              /* Halt: 0 = allow DMA requests 1 = ignore further source DMA requests. The contents of the channels FIFO are drained.                                                               */
                                                                    /* This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.                                                                                  */
  unsigned int reserved3      : BFW_NX90_dmac_chcfg_reserved3;      /* reserved                                                                                                                                                                          */
} NX90_DMAC_CHCFG_BIT_T;

typedef union {
  uint32_t              val;
  NX90_DMAC_CHCFG_BIT_T bf;
} NX90_DMAC_CHCFG_T;


/* ===================================================================== */

/* AREA dmac_reg */
/* Area of dmac_app_reg */

/* ===================================================================== */

#define Addr_NX90_dmac_app_reg 0xFF800800U

/* --------------------------------------------------------------------- */
/* Register dmac_int_status */
/* => interrupt status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_int_status          0x00000000U
#define Adr_NX90_dmac_app_reg_dmac_int_status 0xFF800800U
#define Adr_NX90_dmac_int_status              0xFF800800U

#define MSK_NX90_dmac_int_status_DMACINT_ch0 0x00000001U
#define SRT_NX90_dmac_int_status_DMACINT_ch0 0
#define MSK_NX90_dmac_int_status_DMACINT_ch1 0x00000002U
#define SRT_NX90_dmac_int_status_DMACINT_ch1 1
#define MSK_NX90_dmac_int_status_DMACINT_ch2 0x00000004U
#define SRT_NX90_dmac_int_status_DMACINT_ch2 2

/* all used bits of 'NX90_dmac_int_status': */
#define MSK_USED_BITS_NX90_dmac_int_status 0x00000007U

enum {
  BFW_NX90_dmac_int_status_DMACINT_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_int_status_DMACINT_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_int_status_DMACINT_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_int_status_reserved1   = 29  /* [31:3] */
};

typedef struct NX90_DMAC_INT_STATUS_BIT_Ttag {
  unsigned int DMACINT_ch0 : BFW_NX90_dmac_int_status_DMACINT_ch0; /* Status of DMA channel 0 - interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACINT_ch1 : BFW_NX90_dmac_int_status_DMACINT_ch1; /* Status of DMA channel 1 - interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACINT_ch2 : BFW_NX90_dmac_int_status_DMACINT_ch2; /* Status of DMA channel 2 - interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int reserved1   : BFW_NX90_dmac_int_status_reserved1;   /* reserved                                                                                       */
} NX90_DMAC_INT_STATUS_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_DMAC_INT_STATUS_BIT_T bf;
} NX90_DMAC_INT_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_inttc_status */
/* => interrupt terminal count status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_inttc_status          0x00000004U
#define Adr_NX90_dmac_app_reg_dmac_inttc_status 0xFF800804U
#define Adr_NX90_dmac_inttc_status              0xFF800804U

#define MSK_NX90_dmac_inttc_status_DMACINTTC_ch0 0x00000001U
#define SRT_NX90_dmac_inttc_status_DMACINTTC_ch0 0
#define MSK_NX90_dmac_inttc_status_DMACINTTC_ch1 0x00000002U
#define SRT_NX90_dmac_inttc_status_DMACINTTC_ch1 1
#define MSK_NX90_dmac_inttc_status_DMACINTTC_ch2 0x00000004U
#define SRT_NX90_dmac_inttc_status_DMACINTTC_ch2 2

/* all used bits of 'NX90_dmac_inttc_status': */
#define MSK_USED_BITS_NX90_dmac_inttc_status 0x00000007U

enum {
  BFW_NX90_dmac_inttc_status_DMACINTTC_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_inttc_status_DMACINTTC_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_inttc_status_DMACINTTC_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_inttc_status_reserved1     = 29  /* [31:3] */
};

typedef struct NX90_DMAC_INTTC_STATUS_BIT_Ttag {
  unsigned int DMACINTTC_ch0 : BFW_NX90_dmac_inttc_status_DMACINTTC_ch0; /* Status of DMA channel 0 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACINTTC_ch1 : BFW_NX90_dmac_inttc_status_DMACINTTC_ch1; /* Status of DMA channel 1 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACINTTC_ch2 : BFW_NX90_dmac_inttc_status_DMACINTTC_ch2; /* Status of DMA channel 2 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int reserved1     : BFW_NX90_dmac_inttc_status_reserved1;     /* reserved                                                                                                      */
} NX90_DMAC_INTTC_STATUS_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_DMAC_INTTC_STATUS_BIT_T bf;
} NX90_DMAC_INTTC_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_inttc_clear */
/* => interrupt terminal count clear register */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_inttc_clear          0x00000008U
#define Adr_NX90_dmac_app_reg_dmac_inttc_clear 0xFF800808U
#define Adr_NX90_dmac_inttc_clear              0xFF800808U
#define DFLT_VAL_NX90_dmac_inttc_clear         0x00000000U

#define MSK_NX90_dmac_inttc_clear_DMACINTTCCLR_ch0         0x00000001U
#define SRT_NX90_dmac_inttc_clear_DMACINTTCCLR_ch0         0
#define DFLT_VAL_NX90_dmac_inttc_clear_DMACINTTCCLR_ch0    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_inttc_clear_DMACINTTCCLR_ch0 0x00000000U
#define MSK_NX90_dmac_inttc_clear_DMACINTTCCLR_ch1         0x00000002U
#define SRT_NX90_dmac_inttc_clear_DMACINTTCCLR_ch1         1
#define DFLT_VAL_NX90_dmac_inttc_clear_DMACINTTCCLR_ch1    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_inttc_clear_DMACINTTCCLR_ch1 0x00000000U
#define MSK_NX90_dmac_inttc_clear_DMACINTTCCLR_ch2         0x00000004U
#define SRT_NX90_dmac_inttc_clear_DMACINTTCCLR_ch2         2
#define DFLT_VAL_NX90_dmac_inttc_clear_DMACINTTCCLR_ch2    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_inttc_clear_DMACINTTCCLR_ch2 0x00000000U

/* all used bits of 'NX90_dmac_inttc_clear': */
#define MSK_USED_BITS_NX90_dmac_inttc_clear 0x00000007U

enum {
  BFW_NX90_dmac_inttc_clear_DMACINTTCCLR_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_inttc_clear_DMACINTTCCLR_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_inttc_clear_DMACINTTCCLR_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_inttc_clear_reserved1        = 29  /* [31:3] */
};

typedef struct NX90_DMAC_INTTC_CLEAR_BIT_Ttag {
  unsigned int DMACINTTCCLR_ch0 : BFW_NX90_dmac_inttc_clear_DMACINTTCCLR_ch0; /* Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 0 ,1'b0 have no effect. */
  unsigned int DMACINTTCCLR_ch1 : BFW_NX90_dmac_inttc_clear_DMACINTTCCLR_ch1; /* Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 1 ,1'b0 have no effect. */
  unsigned int DMACINTTCCLR_ch2 : BFW_NX90_dmac_inttc_clear_DMACINTTCCLR_ch2; /* Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 2 ,1'b0 have no effect. */
  unsigned int reserved1        : BFW_NX90_dmac_inttc_clear_reserved1;        /* reserved                                                                                               */
} NX90_DMAC_INTTC_CLEAR_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_DMAC_INTTC_CLEAR_BIT_T bf;
} NX90_DMAC_INTTC_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register dmac_interr_status */
/* => interrupt error status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_interr_status          0x0000000CU
#define Adr_NX90_dmac_app_reg_dmac_interr_status 0xFF80080CU
#define Adr_NX90_dmac_interr_status              0xFF80080CU

#define MSK_NX90_dmac_interr_status_DMACINTERR_ch0 0x00000001U
#define SRT_NX90_dmac_interr_status_DMACINTERR_ch0 0
#define MSK_NX90_dmac_interr_status_DMACINTERR_ch1 0x00000002U
#define SRT_NX90_dmac_interr_status_DMACINTERR_ch1 1
#define MSK_NX90_dmac_interr_status_DMACINTERR_ch2 0x00000004U
#define SRT_NX90_dmac_interr_status_DMACINTERR_ch2 2

/* all used bits of 'NX90_dmac_interr_status': */
#define MSK_USED_BITS_NX90_dmac_interr_status 0x00000007U

enum {
  BFW_NX90_dmac_interr_status_DMACINTERR_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_interr_status_DMACINTERR_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_interr_status_DMACINTERR_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_interr_status_reserved1      = 29  /* [31:3] */
};

typedef struct NX90_DMAC_INTERR_STATUS_BIT_Ttag {
  unsigned int DMACINTERR_ch0 : BFW_NX90_dmac_interr_status_DMACINTERR_ch0; /* Status of DMA channel 0 - error interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACINTERR_ch1 : BFW_NX90_dmac_interr_status_DMACINTERR_ch1; /* Status of DMA channel 1 - error interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACINTERR_ch2 : BFW_NX90_dmac_interr_status_DMACINTERR_ch2; /* Status of DMA channel 2 - error interrupt after masking. 1'b1 indicates an active interrupt request. */
  unsigned int reserved1      : BFW_NX90_dmac_interr_status_reserved1;      /* reserved                                                                                             */
} NX90_DMAC_INTERR_STATUS_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_DMAC_INTERR_STATUS_BIT_T bf;
} NX90_DMAC_INTERR_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_interr_clear */
/* => interrupt error clear register */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_interr_clear          0x00000010U
#define Adr_NX90_dmac_app_reg_dmac_interr_clear 0xFF800810U
#define Adr_NX90_dmac_interr_clear              0xFF800810U
#define DFLT_VAL_NX90_dmac_interr_clear         0x00000000U

#define MSK_NX90_dmac_interr_clear_DMACINTERRCLR_ch0         0x00000001U
#define SRT_NX90_dmac_interr_clear_DMACINTERRCLR_ch0         0
#define DFLT_VAL_NX90_dmac_interr_clear_DMACINTERRCLR_ch0    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_interr_clear_DMACINTERRCLR_ch0 0x00000000U
#define MSK_NX90_dmac_interr_clear_DMACINTERRCLR_ch1         0x00000002U
#define SRT_NX90_dmac_interr_clear_DMACINTERRCLR_ch1         1
#define DFLT_VAL_NX90_dmac_interr_clear_DMACINTERRCLR_ch1    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_interr_clear_DMACINTERRCLR_ch1 0x00000000U
#define MSK_NX90_dmac_interr_clear_DMACINTERRCLR_ch2         0x00000004U
#define SRT_NX90_dmac_interr_clear_DMACINTERRCLR_ch2         2
#define DFLT_VAL_NX90_dmac_interr_clear_DMACINTERRCLR_ch2    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_interr_clear_DMACINTERRCLR_ch2 0x00000000U

/* all used bits of 'NX90_dmac_interr_clear': */
#define MSK_USED_BITS_NX90_dmac_interr_clear 0x00000007U

enum {
  BFW_NX90_dmac_interr_clear_DMACINTERRCLR_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_interr_clear_DMACINTERRCLR_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_interr_clear_DMACINTERRCLR_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_interr_clear_reserved1         = 29  /* [31:3] */
};

typedef struct NX90_DMAC_INTERR_CLEAR_BIT_Ttag {
  unsigned int DMACINTERRCLR_ch0 : BFW_NX90_dmac_interr_clear_DMACINTERRCLR_ch0; /* Writing a 1'b1 Bit clears the error interrupt of the specific channel 0 ,1'b0 have no effect. */
  unsigned int DMACINTERRCLR_ch1 : BFW_NX90_dmac_interr_clear_DMACINTERRCLR_ch1; /* Writing a 1'b1 Bit clears the error interrupt of the specific channel 1 ,1'b0 have no effect. */
  unsigned int DMACINTERRCLR_ch2 : BFW_NX90_dmac_interr_clear_DMACINTERRCLR_ch2; /* Writing a 1'b1 Bit clears the error interrupt of the specific channel 2 ,1'b0 have no effect. */
  unsigned int reserved1         : BFW_NX90_dmac_interr_clear_reserved1;         /* reserved                                                                                      */
} NX90_DMAC_INTERR_CLEAR_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_DMAC_INTERR_CLEAR_BIT_T bf;
} NX90_DMAC_INTERR_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register dmac_rawinttc_status */
/* => raw interrupt terminal count status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_rawinttc_status          0x00000014U
#define Adr_NX90_dmac_app_reg_dmac_rawinttc_status 0xFF800814U
#define Adr_NX90_dmac_rawinttc_status              0xFF800814U

#define MSK_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch0 0x00000001U
#define SRT_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch0 0
#define MSK_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch1 0x00000002U
#define SRT_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch1 1
#define MSK_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch2 0x00000004U
#define SRT_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch2 2

/* all used bits of 'NX90_dmac_rawinttc_status': */
#define MSK_USED_BITS_NX90_dmac_rawinttc_status 0x00000007U

enum {
  BFW_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_rawinttc_status_reserved1        = 29  /* [31:3] */
};

typedef struct NX90_DMAC_RAWINTTC_STATUS_BIT_Ttag {
  unsigned int DMACRAWINTTC_ch0 : BFW_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch0; /* Status of DMA channel 0 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACRAWINTTC_ch1 : BFW_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch1; /* Status of DMA channel 1 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACRAWINTTC_ch2 : BFW_NX90_dmac_rawinttc_status_DMACRAWINTTC_ch2; /* Status of DMA channel 2 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. */
  unsigned int reserved1        : BFW_NX90_dmac_rawinttc_status_reserved1;        /* reserved                                                                                                         */
} NX90_DMAC_RAWINTTC_STATUS_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_DMAC_RAWINTTC_STATUS_BIT_T bf;
} NX90_DMAC_RAWINTTC_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_rawinterr_status */
/* => raw interrupt error status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_rawinterr_status          0x00000018U
#define Adr_NX90_dmac_app_reg_dmac_rawinterr_status 0xFF800818U
#define Adr_NX90_dmac_rawinterr_status              0xFF800818U

#define MSK_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch0 0x00000001U
#define SRT_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch0 0
#define MSK_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch1 0x00000002U
#define SRT_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch1 1
#define MSK_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch2 0x00000004U
#define SRT_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch2 2

/* all used bits of 'NX90_dmac_rawinterr_status': */
#define MSK_USED_BITS_NX90_dmac_rawinterr_status 0x00000007U

enum {
  BFW_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_rawinterr_status_reserved1         = 29  /* [31:3] */
};

typedef struct NX90_DMAC_RAWINTERR_STATUS_BIT_Ttag {
  unsigned int DMACRAWINTERR_ch0 : BFW_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch0; /* Status of DMA channel 0 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACRAWINTERR_ch1 : BFW_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch1; /* Status of DMA channel 1 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. */
  unsigned int DMACRAWINTERR_ch2 : BFW_NX90_dmac_rawinterr_status_DMACRAWINTERR_ch2; /* Status of DMA channel 2 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. */
  unsigned int reserved1         : BFW_NX90_dmac_rawinterr_status_reserved1;         /* reserved                                                                                                */
} NX90_DMAC_RAWINTERR_STATUS_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_DMAC_RAWINTERR_STATUS_BIT_T bf;
} NX90_DMAC_RAWINTERR_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_enabled_channel */
/* => channel enable register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_enabled_channel          0x0000001CU
#define Adr_NX90_dmac_app_reg_dmac_enabled_channel 0xFF80081CU
#define Adr_NX90_dmac_enabled_channel              0xFF80081CU

#define MSK_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch0 0x00000001U
#define SRT_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch0 0
#define MSK_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch1 0x00000002U
#define SRT_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch1 1
#define MSK_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch2 0x00000004U
#define SRT_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch2 2

/* all used bits of 'NX90_dmac_enabled_channel': */
#define MSK_USED_BITS_NX90_dmac_enabled_channel 0x00000007U

enum {
  BFW_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch0 = 1,  /* [0] */
  BFW_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch1 = 1,  /* [1] */
  BFW_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch2 = 1,  /* [2] */
  BFW_NX90_dmac_enabled_channel_reserved1           = 29  /* [31:3] */
};

typedef struct NX90_DMAC_ENABLED_CHANNEL_BIT_Ttag {
  unsigned int DMACENABLEDCHNS_ch0 : BFW_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch0; /* Status DMA channel 0 enable */
  unsigned int DMACENABLEDCHNS_ch1 : BFW_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch1; /* Status DMA channel 1 enable */
  unsigned int DMACENABLEDCHNS_ch2 : BFW_NX90_dmac_enabled_channel_DMACENABLEDCHNS_ch2; /* Status DMA channel 2 enable */
  unsigned int reserved1           : BFW_NX90_dmac_enabled_channel_reserved1;           /* reserved                    */
} NX90_DMAC_ENABLED_CHANNEL_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_DMAC_ENABLED_CHANNEL_BIT_T bf;
} NX90_DMAC_ENABLED_CHANNEL_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softb_req */
/* => software burst request register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_softb_req          0x00000020U
#define Adr_NX90_dmac_app_reg_dmac_softb_req 0xFF800820U
#define Adr_NX90_dmac_softb_req              0xFF800820U
#define DFLT_VAL_NX90_dmac_softb_req         0x00000000U

#define MSK_NX90_dmac_softb_req_DMACSoftBReq         0x0000ffffU
#define SRT_NX90_dmac_softb_req_DMACSoftBReq         0
#define DFLT_VAL_NX90_dmac_softb_req_DMACSoftBReq    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_softb_req_DMACSoftBReq 0x00000000U

/* all used bits of 'NX90_dmac_softb_req': */
#define MSK_USED_BITS_NX90_dmac_softb_req 0x0000ffffU

enum {
  BFW_NX90_dmac_softb_req_DMACSoftBReq = 16, /* [15:0] */
  BFW_NX90_dmac_softb_req_reserved1    = 16  /* [31:16] */
};

typedef struct NX90_DMAC_SOFTB_REQ_BIT_Ttag {
  unsigned int DMACSoftBReq : BFW_NX90_dmac_softb_req_DMACSoftBReq; /* Software burst request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
                                                                    /* Reading the register indicates which sources are requesting DMA burst transfers.                                            */
  unsigned int reserved1    : BFW_NX90_dmac_softb_req_reserved1;    /* reserved                                                                                                                    */
} NX90_DMAC_SOFTB_REQ_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_DMAC_SOFTB_REQ_BIT_T bf;
} NX90_DMAC_SOFTB_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softs_req */
/* => software single request register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_softs_req          0x00000024U
#define Adr_NX90_dmac_app_reg_dmac_softs_req 0xFF800824U
#define Adr_NX90_dmac_softs_req              0xFF800824U
#define DFLT_VAL_NX90_dmac_softs_req         0x00000000U

#define MSK_NX90_dmac_softs_req_DMACSoftSReq         0x0000ffffU
#define SRT_NX90_dmac_softs_req_DMACSoftSReq         0
#define DFLT_VAL_NX90_dmac_softs_req_DMACSoftSReq    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_softs_req_DMACSoftSReq 0x00000000U

/* all used bits of 'NX90_dmac_softs_req': */
#define MSK_USED_BITS_NX90_dmac_softs_req 0x0000ffffU

enum {
  BFW_NX90_dmac_softs_req_DMACSoftSReq = 16, /* [15:0] */
  BFW_NX90_dmac_softs_req_reserved1    = 16  /* [31:16] */
};

typedef struct NX90_DMAC_SOFTS_REQ_BIT_Ttag {
  unsigned int DMACSoftSReq : BFW_NX90_dmac_softs_req_DMACSoftSReq; /* Software single request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
                                                                    /* Reading the register indicates which sources are requesting DMA single transfers.                                            */
  unsigned int reserved1    : BFW_NX90_dmac_softs_req_reserved1;    /* reserved                                                                                                                     */
} NX90_DMAC_SOFTS_REQ_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_DMAC_SOFTS_REQ_BIT_T bf;
} NX90_DMAC_SOFTS_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softlb_req */
/* => software last burst request register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_softlb_req          0x00000028U
#define Adr_NX90_dmac_app_reg_dmac_softlb_req 0xFF800828U
#define Adr_NX90_dmac_softlb_req              0xFF800828U
#define DFLT_VAL_NX90_dmac_softlb_req         0x00000000U

#define MSK_NX90_dmac_softlb_req_DMACSoftLBReq         0x0000ffffU
#define SRT_NX90_dmac_softlb_req_DMACSoftLBReq         0
#define DFLT_VAL_NX90_dmac_softlb_req_DMACSoftLBReq    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_softlb_req_DMACSoftLBReq 0x00000000U

/* all used bits of 'NX90_dmac_softlb_req': */
#define MSK_USED_BITS_NX90_dmac_softlb_req 0x0000ffffU

enum {
  BFW_NX90_dmac_softlb_req_DMACSoftLBReq = 16, /* [15:0] */
  BFW_NX90_dmac_softlb_req_reserved1     = 16  /* [31:16] */
};

typedef struct NX90_DMAC_SOFTLB_REQ_BIT_Ttag {
  unsigned int DMACSoftLBReq : BFW_NX90_dmac_softlb_req_DMACSoftLBReq; /* Software last burst request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
                                                                       /* Reading the register indicates which sources are requesting DMA last burst transfers.                                            */
  unsigned int reserved1     : BFW_NX90_dmac_softlb_req_reserved1;     /* reserved                                                                                                                         */
} NX90_DMAC_SOFTLB_REQ_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_DMAC_SOFTLB_REQ_BIT_T bf;
} NX90_DMAC_SOFTLB_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softls_req */
/* => software last single request register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_softls_req          0x0000002CU
#define Adr_NX90_dmac_app_reg_dmac_softls_req 0xFF80082CU
#define Adr_NX90_dmac_softls_req              0xFF80082CU
#define DFLT_VAL_NX90_dmac_softls_req         0x00000000U

#define MSK_NX90_dmac_softls_req_DMACSoftLSReq         0x0000ffffU
#define SRT_NX90_dmac_softls_req_DMACSoftLSReq         0
#define DFLT_VAL_NX90_dmac_softls_req_DMACSoftLSReq    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_softls_req_DMACSoftLSReq 0x00000000U

/* all used bits of 'NX90_dmac_softls_req': */
#define MSK_USED_BITS_NX90_dmac_softls_req 0x0000ffffU

enum {
  BFW_NX90_dmac_softls_req_DMACSoftLSReq = 16, /* [15:0] */
  BFW_NX90_dmac_softls_req_reserved1     = 16  /* [31:16] */
};

typedef struct NX90_DMAC_SOFTLS_REQ_BIT_Ttag {
  unsigned int DMACSoftLSReq : BFW_NX90_dmac_softls_req_DMACSoftLSReq; /* Software last single request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
                                                                       /* Reading the register indicates which sources are requesting DMA last single transfers.                                            */
  unsigned int reserved1     : BFW_NX90_dmac_softls_req_reserved1;     /* reserved                                                                                                                          */
} NX90_DMAC_SOFTLS_REQ_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_DMAC_SOFTLS_REQ_BIT_T bf;
} NX90_DMAC_SOFTLS_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_config */
/* => configuration register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_config          0x00000030U
#define Adr_NX90_dmac_app_reg_dmac_config 0xFF800830U
#define Adr_NX90_dmac_config              0xFF800830U
#define DFLT_VAL_NX90_dmac_config         0x00000000U

#define MSK_NX90_dmac_config_DMACENABLE         0x00000001U
#define SRT_NX90_dmac_config_DMACENABLE         0
#define DFLT_VAL_NX90_dmac_config_DMACENABLE    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_config_DMACENABLE 0x00000000U

/* all used bits of 'NX90_dmac_config': */
#define MSK_USED_BITS_NX90_dmac_config 0x00000001U

enum {
  BFW_NX90_dmac_config_DMACENABLE = 1,  /* [0] */
  BFW_NX90_dmac_config_reserved1  = 31  /* [31:1] */
};

typedef struct NX90_DMAC_CONFIG_BIT_Ttag {
  unsigned int DMACENABLE : BFW_NX90_dmac_config_DMACENABLE; /* DMAC enable: 0 = disabled 1 = enabled. This bit is reset to 0. Disabling the DMAC reduces power consumption. */
  unsigned int reserved1  : BFW_NX90_dmac_config_reserved1;  /* reserved                                                                                                     */
} NX90_DMAC_CONFIG_BIT_T;

typedef union {
  uint32_t               val;
  NX90_DMAC_CONFIG_BIT_T bf;
} NX90_DMAC_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register dmac_sync */
/* => sync register */
/*    DMA synchronization logic for DMA request signals enabled or disabled */
/*    A 1'b0 bit indicates that the synchronization logic for */
/*    the DMACBREQ[15:0], DMACSREQ[15:0], DMACLBREQ[15:0], and DMACLSREQ[15:0] request signals is enabled. */
/*    A HIGH bit indicates that the synchronization logic is disabled. */
/*    Note: Within the netX system all peripherals and the DMAC are running in the same clock-domain. Therefore, */
/*    it is recommended to disable the synchronisation for all channels (i.e. write 0xffff). This results in a */
/*    performance gain. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_sync          0x00000034U
#define Adr_NX90_dmac_app_reg_dmac_sync 0xFF800834U
#define Adr_NX90_dmac_sync              0xFF800834U
#define DFLT_VAL_NX90_dmac_sync         0x00000000U

#define MSK_NX90_dmac_sync_DIS_SYNC         0x0000ffffU
#define SRT_NX90_dmac_sync_DIS_SYNC         0
#define DFLT_VAL_NX90_dmac_sync_DIS_SYNC    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_sync_DIS_SYNC 0x00000000U

/* all used bits of 'NX90_dmac_sync': */
#define MSK_USED_BITS_NX90_dmac_sync 0x0000ffffU

enum {
  BFW_NX90_dmac_sync_DIS_SYNC  = 16, /* [15:0] */
  BFW_NX90_dmac_sync_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_DMAC_SYNC_BIT_Ttag {
  unsigned int DIS_SYNC  : BFW_NX90_dmac_sync_DIS_SYNC;  /* Disable sync register peripheral requests. */
  unsigned int reserved1 : BFW_NX90_dmac_sync_reserved1; /* reserved                                   */
} NX90_DMAC_SYNC_BIT_T;

typedef union {
  uint32_t             val;
  NX90_DMAC_SYNC_BIT_T bf;
} NX90_DMAC_SYNC_T;


/* ===================================================================== */

/* AREA dmac_mux */
/* Area of dmac_mux_app */

/* ===================================================================== */

#define Addr_NX90_dmac_mux_app 0xFF801000U

/* --------------------------------------------------------------------- */
/* Register dmac_mux_peripheral_input_sel0 */
/* => Peripheral input select for DMAC input channel 0 */
/*    This register configures which peripheral should be connected to DMAC's input channel 0. */
/*    Note: This should not be changed while any of the DMA channels are performing DMA transfers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_mux_peripheral_input_sel0          0x00000000U
#define Adr_NX90_dmac_mux_app_dmac_mux_peripheral_input_sel0 0xFF801000U
#define Adr_NX90_dmac_mux_peripheral_input_sel0              0xFF801000U
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel0         0x00000000U

#define MSK_NX90_dmac_mux_peripheral_input_sel0_index         0x0000003fU
#define SRT_NX90_dmac_mux_peripheral_input_sel0_index         0
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel0_index    0x00000000U
#define DFLT_BF_VAL_NX90_dmac_mux_peripheral_input_sel0_index 0x00000000U

/* all used bits of 'NX90_dmac_mux_peripheral_input_sel0': */
#define MSK_USED_BITS_NX90_dmac_mux_peripheral_input_sel0 0x0000003fU

enum {
  BFW_NX90_dmac_mux_peripheral_input_sel0_index     = 6,  /* [5:0] */
  BFW_NX90_dmac_mux_peripheral_input_sel0_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL0_BIT_Ttag {
  unsigned int index     : BFW_NX90_dmac_mux_peripheral_input_sel0_index;     /* Index of the peripheral to be connected to DMAC's input channel 0. */
                                                                              /* Default connected peripheral: uart_app_rx                          */
                                                                              /* {        |                                                         */
                                                                              /*   Number   Peripheral                                              */
                                                                              /*    0       uart_app_rx (default on DMAC input channel 0)           */
                                                                              /*    1       uart_app_tx (default on DMAC input channel 1)           */
                                                                              /*    2       i2c_app_master (default on DMAC input channel 2)        */
                                                                              /*    3       i2c_app_slave (default on DMAC input channel 3)         */
                                                                              /*    4       spi0_app_rx (default on DMAC input channel 4)           */
                                                                              /*    5       spi0_app_tx (default on DMAC input channel 5)           */
                                                                              /*    6       spi1_app_rx                                             */
                                                                              /*    7       spi1_app_tx                                             */
                                                                              /*    8       spi2_app_rx                                             */
                                                                              /*    9       spi2_app_tx                                             */
                                                                              /*   10       uart_xpic_app_rx                                        */
                                                                              /*   11       uart_xpic_app_tx                                        */
                                                                              /*   12       i2c_xpic_app_master                                     */
                                                                              /*   13       i2c_xpic_app_slave                                      */
                                                                              /*   14       spi_xpic_app_rx                                         */
                                                                              /*   15       spi_xpic_app_tx                                         */
                                                                              /*   16       sqi_rx                                                  */
                                                                              /*   17       sqi_tx                                                  */
                                                                              /*   18       eth_rx                                                  */
                                                                              /*   19       eth_tx                                                  */
                                                                              /*   20       hash                                                    */
                                                                              /*   21       aes_in                                                  */
                                                                              /*   22       aes_out                                                 */
                                                                              /*   23       mtgy0                                                   */
                                                                              /*   24       mtgy1                                                   */
                                                                              /*   25       no connection                                           */
                                                                              /*   26 - 31  reserved                                                */
                                                                              /* }                                                                  */
  unsigned int reserved1 : BFW_NX90_dmac_mux_peripheral_input_sel0_reserved1; /* reserved                                                           */
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL0_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL0_BIT_T bf;
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL0_T;

/* --------------------------------------------------------------------- */
/* Register dmac_mux_peripheral_input_sel1 */
/* => Peripheral input select for DMAC input channel 1 */
/*    This register configures which peripheral should be connected to DMAC's input channel 1. */
/*    Note: This should not be changed while any of the DMA channels are performing DMA transfers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_mux_peripheral_input_sel1          0x00000004U
#define Adr_NX90_dmac_mux_app_dmac_mux_peripheral_input_sel1 0xFF801004U
#define Adr_NX90_dmac_mux_peripheral_input_sel1              0xFF801004U
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel1         0x00000001U

#define MSK_NX90_dmac_mux_peripheral_input_sel1_index         0x0000003fU
#define SRT_NX90_dmac_mux_peripheral_input_sel1_index         0
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel1_index    0x00000001U
#define DFLT_BF_VAL_NX90_dmac_mux_peripheral_input_sel1_index 0x00000001U

/* all used bits of 'NX90_dmac_mux_peripheral_input_sel1': */
#define MSK_USED_BITS_NX90_dmac_mux_peripheral_input_sel1 0x0000003fU

enum {
  BFW_NX90_dmac_mux_peripheral_input_sel1_index     = 6,  /* [5:0] */
  BFW_NX90_dmac_mux_peripheral_input_sel1_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL1_BIT_Ttag {
  unsigned int index     : BFW_NX90_dmac_mux_peripheral_input_sel1_index;     /* Index of the peripheral to be connected to DMAC's input channel 1.              */
                                                                              /* Default connected peripheral: uart_app_tx                                       */
                                                                              /* For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. */
  unsigned int reserved1 : BFW_NX90_dmac_mux_peripheral_input_sel1_reserved1; /* reserved                                                                        */
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL1_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL1_BIT_T bf;
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL1_T;

/* --------------------------------------------------------------------- */
/* Register dmac_mux_peripheral_input_sel2 */
/* => Peripheral input select for DMAC input channel 2 */
/*    This register configures which peripheral should be connected to DMAC's input channel 2. */
/*    Note: This should not be changed while any of the DMA channels are performing DMA transfers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_mux_peripheral_input_sel2          0x00000008U
#define Adr_NX90_dmac_mux_app_dmac_mux_peripheral_input_sel2 0xFF801008U
#define Adr_NX90_dmac_mux_peripheral_input_sel2              0xFF801008U
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel2         0x00000002U

#define MSK_NX90_dmac_mux_peripheral_input_sel2_index         0x0000003fU
#define SRT_NX90_dmac_mux_peripheral_input_sel2_index         0
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel2_index    0x00000002U
#define DFLT_BF_VAL_NX90_dmac_mux_peripheral_input_sel2_index 0x00000002U

/* all used bits of 'NX90_dmac_mux_peripheral_input_sel2': */
#define MSK_USED_BITS_NX90_dmac_mux_peripheral_input_sel2 0x0000003fU

enum {
  BFW_NX90_dmac_mux_peripheral_input_sel2_index     = 6,  /* [5:0] */
  BFW_NX90_dmac_mux_peripheral_input_sel2_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL2_BIT_Ttag {
  unsigned int index     : BFW_NX90_dmac_mux_peripheral_input_sel2_index;     /* Index of the peripheral to be connected to DMAC's input channel 2.              */
                                                                              /* Default connected peripheral: i2c_app_master                                    */
                                                                              /* For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. */
  unsigned int reserved1 : BFW_NX90_dmac_mux_peripheral_input_sel2_reserved1; /* reserved                                                                        */
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL2_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL2_BIT_T bf;
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL2_T;

/* --------------------------------------------------------------------- */
/* Register dmac_mux_peripheral_input_sel3 */
/* => Peripheral input select for DMAC input channel 3 */
/*    This register configures which peripheral should be connected to DMAC's input channel 3. */
/*    Note: This should not be changed while any of the DMA channels are performing DMA transfers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_mux_peripheral_input_sel3          0x0000000CU
#define Adr_NX90_dmac_mux_app_dmac_mux_peripheral_input_sel3 0xFF80100CU
#define Adr_NX90_dmac_mux_peripheral_input_sel3              0xFF80100CU
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel3         0x00000003U

#define MSK_NX90_dmac_mux_peripheral_input_sel3_index         0x0000003fU
#define SRT_NX90_dmac_mux_peripheral_input_sel3_index         0
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel3_index    0x00000003U
#define DFLT_BF_VAL_NX90_dmac_mux_peripheral_input_sel3_index 0x00000003U

/* all used bits of 'NX90_dmac_mux_peripheral_input_sel3': */
#define MSK_USED_BITS_NX90_dmac_mux_peripheral_input_sel3 0x0000003fU

enum {
  BFW_NX90_dmac_mux_peripheral_input_sel3_index     = 6,  /* [5:0] */
  BFW_NX90_dmac_mux_peripheral_input_sel3_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL3_BIT_Ttag {
  unsigned int index     : BFW_NX90_dmac_mux_peripheral_input_sel3_index;     /* Index of the peripheral to be connected to DMAC's input channel 3.              */
                                                                              /* Default connected peripheral: i2c_app_slave                                     */
                                                                              /* For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. */
  unsigned int reserved1 : BFW_NX90_dmac_mux_peripheral_input_sel3_reserved1; /* reserved                                                                        */
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL3_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL3_BIT_T bf;
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL3_T;

/* --------------------------------------------------------------------- */
/* Register dmac_mux_peripheral_input_sel4 */
/* => Peripheral input select for DMAC input channel 4 */
/*    This register configures which peripheral should be connected to DMAC's input channel 4. */
/*    Note: This should not be changed while any of the DMA channels are performing DMA transfers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_mux_peripheral_input_sel4          0x00000010U
#define Adr_NX90_dmac_mux_app_dmac_mux_peripheral_input_sel4 0xFF801010U
#define Adr_NX90_dmac_mux_peripheral_input_sel4              0xFF801010U
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel4         0x00000004U

#define MSK_NX90_dmac_mux_peripheral_input_sel4_index         0x0000003fU
#define SRT_NX90_dmac_mux_peripheral_input_sel4_index         0
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel4_index    0x00000004U
#define DFLT_BF_VAL_NX90_dmac_mux_peripheral_input_sel4_index 0x00000004U

/* all used bits of 'NX90_dmac_mux_peripheral_input_sel4': */
#define MSK_USED_BITS_NX90_dmac_mux_peripheral_input_sel4 0x0000003fU

enum {
  BFW_NX90_dmac_mux_peripheral_input_sel4_index     = 6,  /* [5:0] */
  BFW_NX90_dmac_mux_peripheral_input_sel4_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL4_BIT_Ttag {
  unsigned int index     : BFW_NX90_dmac_mux_peripheral_input_sel4_index;     /* Index of the peripheral to be connected to DMAC's input channel 4.              */
                                                                              /* Default connected peripheral: spi0_app_rx                                       */
                                                                              /* For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. */
  unsigned int reserved1 : BFW_NX90_dmac_mux_peripheral_input_sel4_reserved1; /* reserved                                                                        */
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL4_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL4_BIT_T bf;
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL4_T;

/* --------------------------------------------------------------------- */
/* Register dmac_mux_peripheral_input_sel5 */
/* => Peripheral input select for DMAC input channel 5 */
/*    This register configures which peripheral should be connected to DMAC's input channel 5. */
/*    Note: This should not be changed while any of the DMA channels are performing DMA transfers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_dmac_mux_peripheral_input_sel5          0x00000014U
#define Adr_NX90_dmac_mux_app_dmac_mux_peripheral_input_sel5 0xFF801014U
#define Adr_NX90_dmac_mux_peripheral_input_sel5              0xFF801014U
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel5         0x00000005U

#define MSK_NX90_dmac_mux_peripheral_input_sel5_index         0x0000003fU
#define SRT_NX90_dmac_mux_peripheral_input_sel5_index         0
#define DFLT_VAL_NX90_dmac_mux_peripheral_input_sel5_index    0x00000005U
#define DFLT_BF_VAL_NX90_dmac_mux_peripheral_input_sel5_index 0x00000005U

/* all used bits of 'NX90_dmac_mux_peripheral_input_sel5': */
#define MSK_USED_BITS_NX90_dmac_mux_peripheral_input_sel5 0x0000003fU

enum {
  BFW_NX90_dmac_mux_peripheral_input_sel5_index     = 6,  /* [5:0] */
  BFW_NX90_dmac_mux_peripheral_input_sel5_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL5_BIT_Ttag {
  unsigned int index     : BFW_NX90_dmac_mux_peripheral_input_sel5_index;     /* Index of the peripheral to be connected to DMAC's input channel 5.              */
                                                                              /* Default connected peripheral: spi0_app_tx                                       */
                                                                              /* For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. */
  unsigned int reserved1 : BFW_NX90_dmac_mux_peripheral_input_sel5_reserved1; /* reserved                                                                        */
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL5_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL5_BIT_T bf;
} NX90_DMAC_MUX_PERIPHERAL_INPUT_SEL5_T;


/* ===================================================================== */

/* AREA uart */
/* Area of uart_app, uart_xpic_app */

/* ===================================================================== */

#define Addr_NX90_uart_app      0xFF801040U
#define Addr_NX90_uart_xpic_app 0xFF900300U

/* --------------------------------------------------------------------- */
/* Register uartdr */
/* => data read or written from the interface */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartdr           0x00000000U
#define Adr_NX90_uart_app_uartdr      0xFF801040U
#define Adr_NX90_uart_xpic_app_uartdr 0xFF900300U
#define DFLT_VAL_NX90_uartdr          0x00000000U

#define MSK_NX90_uartdr_DATA         0x000000ffU
#define SRT_NX90_uartdr_DATA         0
#define DFLT_VAL_NX90_uartdr_DATA    0x00000000U
#define DFLT_BF_VAL_NX90_uartdr_DATA 0x00000000U
#define MSK_NX90_uartdr_FE           0x00000100U
#define SRT_NX90_uartdr_FE           8
#define DFLT_VAL_NX90_uartdr_FE      0x00000000U
#define DFLT_BF_VAL_NX90_uartdr_FE   0x00000000U
#define MSK_NX90_uartdr_PE           0x00000200U
#define SRT_NX90_uartdr_PE           9
#define DFLT_VAL_NX90_uartdr_PE      0x00000000U
#define DFLT_BF_VAL_NX90_uartdr_PE   0x00000000U
#define MSK_NX90_uartdr_BE           0x00000400U
#define SRT_NX90_uartdr_BE           10
#define DFLT_VAL_NX90_uartdr_BE      0x00000000U
#define DFLT_BF_VAL_NX90_uartdr_BE   0x00000000U

/* all used bits of 'NX90_uartdr': */
#define MSK_USED_BITS_NX90_uartdr 0x000007ffU

enum {
  BFW_NX90_uartdr_DATA      = 8,  /* [7:0] */
  BFW_NX90_uartdr_FE        = 1,  /* [8] */
  BFW_NX90_uartdr_PE        = 1,  /* [9] */
  BFW_NX90_uartdr_BE        = 1,  /* [10] */
  BFW_NX90_uartdr_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_UARTDR_BIT_Ttag {
  unsigned int DATA      : BFW_NX90_uartdr_DATA;      /* data read or written from the interface                                         */
  unsigned int FE        : BFW_NX90_uartdr_FE;        /* Framing Error, read only, mirrored from uartrsr, to handle in DMA-read-out data */
  unsigned int PE        : BFW_NX90_uartdr_PE;        /* Parity Error, read only, mirrored from uartrsr, to handle in DMA-read-out data  */
  unsigned int BE        : BFW_NX90_uartdr_BE;        /* Break Error, read only, mirrored from uartrsr, to handle in DMA-read-out data   */
  unsigned int reserved1 : BFW_NX90_uartdr_reserved1; /* reserved                                                                        */
} NX90_UARTDR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_UARTDR_BIT_T bf;
} NX90_UARTDR_T;

/* --------------------------------------------------------------------- */
/* Register uartrsr */
/* => receive status register (read) / Error Clear Register (write) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartrsr           0x00000004U
#define Adr_NX90_uart_app_uartrsr      0xFF801044U
#define Adr_NX90_uart_xpic_app_uartrsr 0xFF900304U
#define DFLT_VAL_NX90_uartrsr          0x00000000U

#define MSK_NX90_uartrsr_FE         0x00000001U
#define SRT_NX90_uartrsr_FE         0
#define DFLT_VAL_NX90_uartrsr_FE    0x00000000U
#define DFLT_BF_VAL_NX90_uartrsr_FE 0x00000000U
#define MSK_NX90_uartrsr_PE         0x00000002U
#define SRT_NX90_uartrsr_PE         1
#define DFLT_VAL_NX90_uartrsr_PE    0x00000000U
#define DFLT_BF_VAL_NX90_uartrsr_PE 0x00000000U
#define MSK_NX90_uartrsr_BE         0x00000004U
#define SRT_NX90_uartrsr_BE         2
#define DFLT_VAL_NX90_uartrsr_BE    0x00000000U
#define DFLT_BF_VAL_NX90_uartrsr_BE 0x00000000U
#define MSK_NX90_uartrsr_OE         0x00000008U
#define SRT_NX90_uartrsr_OE         3
#define DFLT_VAL_NX90_uartrsr_OE    0x00000000U
#define DFLT_BF_VAL_NX90_uartrsr_OE 0x00000000U

/* all used bits of 'NX90_uartrsr': */
#define MSK_USED_BITS_NX90_uartrsr 0x0000000fU

enum {
  BFW_NX90_uartrsr_FE        = 1,  /* [0] */
  BFW_NX90_uartrsr_PE        = 1,  /* [1] */
  BFW_NX90_uartrsr_BE        = 1,  /* [2] */
  BFW_NX90_uartrsr_OE        = 1,  /* [3] */
  BFW_NX90_uartrsr_reserved1 = 28  /* [31:4] */
};

typedef struct NX90_UARTRSR_BIT_Ttag {
  unsigned int FE        : BFW_NX90_uartrsr_FE;        /* Framing Error */
  unsigned int PE        : BFW_NX90_uartrsr_PE;        /* Parity Error  */
  unsigned int BE        : BFW_NX90_uartrsr_BE;        /* Break Error   */
  unsigned int OE        : BFW_NX90_uartrsr_OE;        /* Overrun Error */
  unsigned int reserved1 : BFW_NX90_uartrsr_reserved1; /* reserved      */
} NX90_UARTRSR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_UARTRSR_BIT_T bf;
} NX90_UARTRSR_T;

/* --------------------------------------------------------------------- */
/* Register uartlcr_h */
/* => Line control Register, high byte */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartlcr_h           0x00000008U
#define Adr_NX90_uart_app_uartlcr_h      0xFF801048U
#define Adr_NX90_uart_xpic_app_uartlcr_h 0xFF900308U
#define DFLT_VAL_NX90_uartlcr_h          0x00000000U

#define MSK_NX90_uartlcr_h_BRK          0x00000001U
#define SRT_NX90_uartlcr_h_BRK          0
#define DFLT_VAL_NX90_uartlcr_h_BRK     0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_h_BRK  0x00000000U
#define MSK_NX90_uartlcr_h_PEN          0x00000002U
#define SRT_NX90_uartlcr_h_PEN          1
#define DFLT_VAL_NX90_uartlcr_h_PEN     0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_h_PEN  0x00000000U
#define MSK_NX90_uartlcr_h_EPS          0x00000004U
#define SRT_NX90_uartlcr_h_EPS          2
#define DFLT_VAL_NX90_uartlcr_h_EPS     0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_h_EPS  0x00000000U
#define MSK_NX90_uartlcr_h_STP2         0x00000008U
#define SRT_NX90_uartlcr_h_STP2         3
#define DFLT_VAL_NX90_uartlcr_h_STP2    0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_h_STP2 0x00000000U
#define MSK_NX90_uartlcr_h_FEN          0x00000010U
#define SRT_NX90_uartlcr_h_FEN          4
#define DFLT_VAL_NX90_uartlcr_h_FEN     0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_h_FEN  0x00000000U
#define MSK_NX90_uartlcr_h_WLEN         0x00000060U
#define SRT_NX90_uartlcr_h_WLEN         5
#define DFLT_VAL_NX90_uartlcr_h_WLEN    0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_h_WLEN 0x00000000U

/* all used bits of 'NX90_uartlcr_h': */
#define MSK_USED_BITS_NX90_uartlcr_h 0x0000007fU

enum {
  BFW_NX90_uartlcr_h_BRK       = 1,  /* [0] */
  BFW_NX90_uartlcr_h_PEN       = 1,  /* [1] */
  BFW_NX90_uartlcr_h_EPS       = 1,  /* [2] */
  BFW_NX90_uartlcr_h_STP2      = 1,  /* [3] */
  BFW_NX90_uartlcr_h_FEN       = 1,  /* [4] */
  BFW_NX90_uartlcr_h_WLEN      = 2,  /* [6:5] */
  BFW_NX90_uartlcr_h_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_UARTLCR_H_BIT_Ttag {
  unsigned int BRK       : BFW_NX90_uartlcr_h_BRK;       /* Send Break         */
  unsigned int PEN       : BFW_NX90_uartlcr_h_PEN;       /* Parity Enalble     */
  unsigned int EPS       : BFW_NX90_uartlcr_h_EPS;       /* Even Parity Select */
  unsigned int STP2      : BFW_NX90_uartlcr_h_STP2;      /* 2 Stop Bits Select */
  unsigned int FEN       : BFW_NX90_uartlcr_h_FEN;       /* FIFO Enable        */
  unsigned int WLEN      : BFW_NX90_uartlcr_h_WLEN;      /*  Word Length       */
                                                         /* "00" 5 bits        */
                                                         /* "01" 6 bits        */
                                                         /* "10" 7 bits        */
                                                         /* "11" 8 bits        */
  unsigned int reserved1 : BFW_NX90_uartlcr_h_reserved1; /* reserved           */
} NX90_UARTLCR_H_BIT_T;

typedef union {
  uint32_t             val;
  NX90_UARTLCR_H_BIT_T bf;
} NX90_UARTLCR_H_T;

/* --------------------------------------------------------------------- */
/* Register uartlcr_m */
/* => Line control Register, middle byte */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartlcr_m           0x0000000CU
#define Adr_NX90_uart_app_uartlcr_m      0xFF80104CU
#define Adr_NX90_uart_xpic_app_uartlcr_m 0xFF90030CU
#define DFLT_VAL_NX90_uartlcr_m          0x00000000U

#define MSK_NX90_uartlcr_m_BAUDDIVMS         0x000000ffU
#define SRT_NX90_uartlcr_m_BAUDDIVMS         0
#define DFLT_VAL_NX90_uartlcr_m_BAUDDIVMS    0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_m_BAUDDIVMS 0x00000000U

/* all used bits of 'NX90_uartlcr_m': */
#define MSK_USED_BITS_NX90_uartlcr_m 0x000000ffU

enum {
  BFW_NX90_uartlcr_m_BAUDDIVMS = 8,  /* [7:0] */
  BFW_NX90_uartlcr_m_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_UARTLCR_M_BIT_Ttag {
  unsigned int BAUDDIVMS : BFW_NX90_uartlcr_m_BAUDDIVMS; /* bauddiv : Baud Divisor Most Significant Byte                     */
                                                         /* use higher byte of bauddiv = (system clk / (16 * baud rate)) - 1 */
                                                         /* if not alternative settings by register uartcr_2 are done        */
  unsigned int reserved1 : BFW_NX90_uartlcr_m_reserved1; /* reserved                                                         */
} NX90_UARTLCR_M_BIT_T;

typedef union {
  uint32_t             val;
  NX90_UARTLCR_M_BIT_T bf;
} NX90_UARTLCR_M_T;

/* --------------------------------------------------------------------- */
/* Register uartlcr_l */
/* => Line control Register, low byte */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartlcr_l           0x00000010U
#define Adr_NX90_uart_app_uartlcr_l      0xFF801050U
#define Adr_NX90_uart_xpic_app_uartlcr_l 0xFF900310U
#define DFLT_VAL_NX90_uartlcr_l          0x00000000U

#define MSK_NX90_uartlcr_l_BAUDDIVLS         0x000000ffU
#define SRT_NX90_uartlcr_l_BAUDDIVLS         0
#define DFLT_VAL_NX90_uartlcr_l_BAUDDIVLS    0x00000000U
#define DFLT_BF_VAL_NX90_uartlcr_l_BAUDDIVLS 0x00000000U

/* all used bits of 'NX90_uartlcr_l': */
#define MSK_USED_BITS_NX90_uartlcr_l 0x000000ffU

enum {
  BFW_NX90_uartlcr_l_BAUDDIVLS = 8,  /* [7:0] */
  BFW_NX90_uartlcr_l_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_UARTLCR_L_BIT_Ttag {
  unsigned int BAUDDIVLS : BFW_NX90_uartlcr_l_BAUDDIVLS; /* Baud Divisor Least Significant Byte                             */
                                                         /* use lower byte of bauddiv = (system clk / (16 * baud rate)) - 1 */
                                                         /* if not alternative settings by register uartcr_2 are done       */
  unsigned int reserved1 : BFW_NX90_uartlcr_l_reserved1; /* reserved                                                        */
} NX90_UARTLCR_L_BIT_T;

typedef union {
  uint32_t             val;
  NX90_UARTLCR_L_BIT_T bf;
} NX90_UARTLCR_L_T;

/* --------------------------------------------------------------------- */
/* Register uartcr */
/* => uart control Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartcr           0x00000014U
#define Adr_NX90_uart_app_uartcr      0xFF801054U
#define Adr_NX90_uart_xpic_app_uartcr 0xFF900314U
#define DFLT_VAL_NX90_uartcr          0x00000000U

#define MSK_NX90_uartcr_uartEN             0x00000001U
#define SRT_NX90_uartcr_uartEN             0
#define DFLT_VAL_NX90_uartcr_uartEN        0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_uartEN     0x00000000U
#define MSK_NX90_uartcr_SIREN              0x00000002U
#define SRT_NX90_uartcr_SIREN              1
#define DFLT_VAL_NX90_uartcr_SIREN         0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_SIREN      0x00000000U
#define MSK_NX90_uartcr_SIRLP              0x00000004U
#define SRT_NX90_uartcr_SIRLP              2
#define DFLT_VAL_NX90_uartcr_SIRLP         0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_SIRLP      0x00000000U
#define MSK_NX90_uartcr_MSIE               0x00000008U
#define SRT_NX90_uartcr_MSIE               3
#define DFLT_VAL_NX90_uartcr_MSIE          0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_MSIE       0x00000000U
#define MSK_NX90_uartcr_RIE                0x00000010U
#define SRT_NX90_uartcr_RIE                4
#define DFLT_VAL_NX90_uartcr_RIE           0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_RIE        0x00000000U
#define MSK_NX90_uartcr_TIE                0x00000020U
#define SRT_NX90_uartcr_TIE                5
#define DFLT_VAL_NX90_uartcr_TIE           0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_TIE        0x00000000U
#define MSK_NX90_uartcr_RTIE               0x00000040U
#define SRT_NX90_uartcr_RTIE               6
#define DFLT_VAL_NX90_uartcr_RTIE          0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_RTIE       0x00000000U
#define MSK_NX90_uartcr_LBE                0x00000080U
#define SRT_NX90_uartcr_LBE                7
#define DFLT_VAL_NX90_uartcr_LBE           0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_LBE        0x00000000U
#define MSK_NX90_uartcr_TX_RX_LOOP         0x00000100U
#define SRT_NX90_uartcr_TX_RX_LOOP         8
#define DFLT_VAL_NX90_uartcr_TX_RX_LOOP    0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_TX_RX_LOOP 0x00000000U

/* all used bits of 'NX90_uartcr': */
#define MSK_USED_BITS_NX90_uartcr 0x000001ffU

enum {
  BFW_NX90_uartcr_uartEN     = 1,  /* [0] */
  BFW_NX90_uartcr_SIREN      = 1,  /* [1] */
  BFW_NX90_uartcr_SIRLP      = 1,  /* [2] */
  BFW_NX90_uartcr_MSIE       = 1,  /* [3] */
  BFW_NX90_uartcr_RIE        = 1,  /* [4] */
  BFW_NX90_uartcr_TIE        = 1,  /* [5] */
  BFW_NX90_uartcr_RTIE       = 1,  /* [6] */
  BFW_NX90_uartcr_LBE        = 1,  /* [7] */
  BFW_NX90_uartcr_TX_RX_LOOP = 1,  /* [8] */
  BFW_NX90_uartcr_reserved1  = 23  /* [31:9] */
};

typedef struct NX90_UARTCR_BIT_Ttag {
  unsigned int uartEN     : BFW_NX90_uartcr_uartEN;     /* uart Enable                                  */
  unsigned int SIREN      : BFW_NX90_uartcr_SIREN;      /* SIR Enable                                   */
  unsigned int SIRLP      : BFW_NX90_uartcr_SIRLP;      /* IrDA SIR Low Power Mode                      */
  unsigned int MSIE       : BFW_NX90_uartcr_MSIE;       /* Modem Status Interrupt Enable                */
  unsigned int RIE        : BFW_NX90_uartcr_RIE;        /* Receive Interrupt Enable                     */
  unsigned int TIE        : BFW_NX90_uartcr_TIE;        /* Transmit Interrupt Enable                    */
  unsigned int RTIE       : BFW_NX90_uartcr_RTIE;       /* Receive Timeout Interrupt Enable             */
  unsigned int LBE        : BFW_NX90_uartcr_LBE;        /* Loop Back Enable for IrDA mode               */
  unsigned int TX_RX_LOOP : BFW_NX90_uartcr_TX_RX_LOOP; /* internal loop (TX -> RX) (test purpose only) */
  unsigned int reserved1  : BFW_NX90_uartcr_reserved1;  /* reserved                                     */
} NX90_UARTCR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_UARTCR_BIT_T bf;
} NX90_UARTCR_T;

/* --------------------------------------------------------------------- */
/* Register uartfr */
/* => uart Flag Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartfr           0x00000018U
#define Adr_NX90_uart_app_uartfr      0xFF801058U
#define Adr_NX90_uart_xpic_app_uartfr 0xFF900318U

#define MSK_NX90_uartfr_CTS  0x00000001U
#define SRT_NX90_uartfr_CTS  0
#define MSK_NX90_uartfr_DSR  0x00000002U
#define SRT_NX90_uartfr_DSR  1
#define MSK_NX90_uartfr_DCD  0x00000004U
#define SRT_NX90_uartfr_DCD  2
#define MSK_NX90_uartfr_BUSY 0x00000008U
#define SRT_NX90_uartfr_BUSY 3
#define MSK_NX90_uartfr_RXFE 0x00000010U
#define SRT_NX90_uartfr_RXFE 4
#define MSK_NX90_uartfr_TXFF 0x00000020U
#define SRT_NX90_uartfr_TXFF 5
#define MSK_NX90_uartfr_RXFF 0x00000040U
#define SRT_NX90_uartfr_RXFF 6
#define MSK_NX90_uartfr_TXFE 0x00000080U
#define SRT_NX90_uartfr_TXFE 7

/* all used bits of 'NX90_uartfr': */
#define MSK_USED_BITS_NX90_uartfr 0x000000ffU

enum {
  BFW_NX90_uartfr_CTS       = 1,  /* [0] */
  BFW_NX90_uartfr_DSR       = 1,  /* [1] */
  BFW_NX90_uartfr_DCD       = 1,  /* [2] */
  BFW_NX90_uartfr_BUSY      = 1,  /* [3] */
  BFW_NX90_uartfr_RXFE      = 1,  /* [4] */
  BFW_NX90_uartfr_TXFF      = 1,  /* [5] */
  BFW_NX90_uartfr_RXFF      = 1,  /* [6] */
  BFW_NX90_uartfr_TXFE      = 1,  /* [7] */
  BFW_NX90_uartfr_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_UARTFR_BIT_Ttag {
  unsigned int CTS       : BFW_NX90_uartfr_CTS;       /* Clear To Send       */
  unsigned int DSR       : BFW_NX90_uartfr_DSR;       /* Data Set Ready      */
  unsigned int DCD       : BFW_NX90_uartfr_DCD;       /* Data Carrier Detect */
  unsigned int BUSY      : BFW_NX90_uartfr_BUSY;      /* uart BUSY           */
  unsigned int RXFE      : BFW_NX90_uartfr_RXFE;      /* Receive FIFO Empty  */
  unsigned int TXFF      : BFW_NX90_uartfr_TXFF;      /* Transmit FIFO Full  */
  unsigned int RXFF      : BFW_NX90_uartfr_RXFF;      /* Receive FIFO Full   */
  unsigned int TXFE      : BFW_NX90_uartfr_TXFE;      /* Transmit FIFO Empty */
  unsigned int reserved1 : BFW_NX90_uartfr_reserved1; /* reserved            */
} NX90_UARTFR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_UARTFR_BIT_T bf;
} NX90_UARTFR_T;

/* --------------------------------------------------------------------- */
/* Register uartiir */
/* => Interrupt Identification (read) / interrupt clear (write) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartiir           0x0000001CU
#define Adr_NX90_uart_app_uartiir      0xFF80105CU
#define Adr_NX90_uart_xpic_app_uartiir 0xFF90031CU
#define DFLT_VAL_NX90_uartiir          0x00000000U

#define MSK_NX90_uartiir_MIS          0x00000001U
#define SRT_NX90_uartiir_MIS          0
#define DFLT_VAL_NX90_uartiir_MIS     0x00000000U
#define DFLT_BF_VAL_NX90_uartiir_MIS  0x00000000U
#define MSK_NX90_uartiir_RIS          0x00000002U
#define SRT_NX90_uartiir_RIS          1
#define DFLT_VAL_NX90_uartiir_RIS     0x00000000U
#define DFLT_BF_VAL_NX90_uartiir_RIS  0x00000000U
#define MSK_NX90_uartiir_TIS          0x00000004U
#define SRT_NX90_uartiir_TIS          2
#define DFLT_VAL_NX90_uartiir_TIS     0x00000000U
#define DFLT_BF_VAL_NX90_uartiir_TIS  0x00000000U
#define MSK_NX90_uartiir_RTIS         0x00000008U
#define SRT_NX90_uartiir_RTIS         3
#define DFLT_VAL_NX90_uartiir_RTIS    0x00000000U
#define DFLT_BF_VAL_NX90_uartiir_RTIS 0x00000000U

/* all used bits of 'NX90_uartiir': */
#define MSK_USED_BITS_NX90_uartiir 0x0000000fU

enum {
  BFW_NX90_uartiir_MIS       = 1,  /* [0] */
  BFW_NX90_uartiir_RIS       = 1,  /* [1] */
  BFW_NX90_uartiir_TIS       = 1,  /* [2] */
  BFW_NX90_uartiir_RTIS      = 1,  /* [3] */
  BFW_NX90_uartiir_reserved1 = 28  /* [31:4] */
};

typedef struct NX90_UARTIIR_BIT_Ttag {
  unsigned int MIS       : BFW_NX90_uartiir_MIS;       /* Modem Interrupt Status           */
  unsigned int RIS       : BFW_NX90_uartiir_RIS;       /* Receive Interrupt Status         */
  unsigned int TIS       : BFW_NX90_uartiir_TIS;       /* Transmit Interrupt Status        */
  unsigned int RTIS      : BFW_NX90_uartiir_RTIS;      /* Receive Timeout Interrupt Status */
  unsigned int reserved1 : BFW_NX90_uartiir_reserved1; /* reserved                         */
} NX90_UARTIIR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_UARTIIR_BIT_T bf;
} NX90_UARTIIR_T;

/* --------------------------------------------------------------------- */
/* Register uartilpr */
/* => IrDA Low Power Counter Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartilpr           0x00000020U
#define Adr_NX90_uart_app_uartilpr      0xFF801060U
#define Adr_NX90_uart_xpic_app_uartilpr 0xFF900320U
#define DFLT_VAL_NX90_uartilpr          0x00000000U

#define MSK_NX90_uartilpr_ILPDVSR         0x000000ffU
#define SRT_NX90_uartilpr_ILPDVSR         0
#define DFLT_VAL_NX90_uartilpr_ILPDVSR    0x00000000U
#define DFLT_BF_VAL_NX90_uartilpr_ILPDVSR 0x00000000U

/* all used bits of 'NX90_uartilpr': */
#define MSK_USED_BITS_NX90_uartilpr 0x000000ffU

enum {
  BFW_NX90_uartilpr_ILPDVSR   = 8,  /* [7:0] */
  BFW_NX90_uartilpr_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_UARTILPR_BIT_Ttag {
  unsigned int ILPDVSR   : BFW_NX90_uartilpr_ILPDVSR;   /* IrDA Low Power Divisor */
  unsigned int reserved1 : BFW_NX90_uartilpr_reserved1; /* reserved               */
} NX90_UARTILPR_BIT_T;

typedef union {
  uint32_t            val;
  NX90_UARTILPR_BIT_T bf;
} NX90_UARTILPR_T;

/* --------------------------------------------------------------------- */
/* Register uartrts */
/* => RTS Control Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartrts           0x00000024U
#define Adr_NX90_uart_app_uartrts      0xFF801064U
#define Adr_NX90_uart_xpic_app_uartrts 0xFF900324U
#define DFLT_VAL_NX90_uartrts          0x00000000U

#define MSK_NX90_uartrts_AUTO            0x00000001U
#define SRT_NX90_uartrts_AUTO            0
#define DFLT_VAL_NX90_uartrts_AUTO       0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_AUTO    0x00000000U
#define MSK_NX90_uartrts_RTS             0x00000002U
#define SRT_NX90_uartrts_RTS             1
#define DFLT_VAL_NX90_uartrts_RTS        0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_RTS     0x00000000U
#define MSK_NX90_uartrts_COUNT           0x00000004U
#define SRT_NX90_uartrts_COUNT           2
#define DFLT_VAL_NX90_uartrts_COUNT      0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_COUNT   0x00000000U
#define MSK_NX90_uartrts_MOD2            0x00000008U
#define SRT_NX90_uartrts_MOD2            3
#define DFLT_VAL_NX90_uartrts_MOD2       0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_MOD2    0x00000000U
#define MSK_NX90_uartrts_RTS_pol         0x00000010U
#define SRT_NX90_uartrts_RTS_pol         4
#define DFLT_VAL_NX90_uartrts_RTS_pol    0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_RTS_pol 0x00000000U
#define MSK_NX90_uartrts_CTS_ctr         0x00000020U
#define SRT_NX90_uartrts_CTS_ctr         5
#define DFLT_VAL_NX90_uartrts_CTS_ctr    0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_CTS_ctr 0x00000000U
#define MSK_NX90_uartrts_CTS_pol         0x00000040U
#define SRT_NX90_uartrts_CTS_pol         6
#define DFLT_VAL_NX90_uartrts_CTS_pol    0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_CTS_pol 0x00000000U
#define MSK_NX90_uartrts_STICK           0x00000080U
#define SRT_NX90_uartrts_STICK           7
#define DFLT_VAL_NX90_uartrts_STICK      0x00000000U
#define DFLT_BF_VAL_NX90_uartrts_STICK   0x00000000U

/* all used bits of 'NX90_uartrts': */
#define MSK_USED_BITS_NX90_uartrts 0x000000ffU

enum {
  BFW_NX90_uartrts_AUTO      = 1,  /* [0] */
  BFW_NX90_uartrts_RTS       = 1,  /* [1] */
  BFW_NX90_uartrts_COUNT     = 1,  /* [2] */
  BFW_NX90_uartrts_MOD2      = 1,  /* [3] */
  BFW_NX90_uartrts_RTS_pol   = 1,  /* [4] */
  BFW_NX90_uartrts_CTS_ctr   = 1,  /* [5] */
  BFW_NX90_uartrts_CTS_pol   = 1,  /* [6] */
  BFW_NX90_uartrts_STICK     = 1,  /* [7] */
  BFW_NX90_uartrts_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_UARTRTS_BIT_Ttag {
  unsigned int AUTO      : BFW_NX90_uartrts_AUTO;      /* automatic or controlled by the next bit (RTS) */
  unsigned int RTS       : BFW_NX90_uartrts_RTS;       /* if AUTO=0: controlled by this bit             */
  unsigned int COUNT     : BFW_NX90_uartrts_COUNT;     /* count base: 1=system clocks, 0=time in bauds  */
  unsigned int MOD2      : BFW_NX90_uartrts_MOD2;      /* mode1/mode2                                   */
  unsigned int RTS_pol   : BFW_NX90_uartrts_RTS_pol;   /* RTS polarity: 1=active high                   */
  unsigned int CTS_ctr   : BFW_NX90_uartrts_CTS_ctr;   /* nUARTCTS control                              */
  unsigned int CTS_pol   : BFW_NX90_uartrts_CTS_pol;   /* nUARTCTS polarity: 1=active high              */
  unsigned int STICK     : BFW_NX90_uartrts_STICK;     /* stick parity                                  */
  unsigned int reserved1 : BFW_NX90_uartrts_reserved1; /* reserved                                      */
} NX90_UARTRTS_BIT_T;

typedef union {
  uint32_t           val;
  NX90_UARTRTS_BIT_T bf;
} NX90_UARTRTS_T;

/* --------------------------------------------------------------------- */
/* Register uartforerun */
/* => RTS forerun cycles */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartforerun           0x00000028U
#define Adr_NX90_uart_app_uartforerun      0xFF801068U
#define Adr_NX90_uart_xpic_app_uartforerun 0xFF900328U
#define DFLT_VAL_NX90_uartforerun          0x00000000U

#define MSK_NX90_uartforerun_FORERUN         0x000000ffU
#define SRT_NX90_uartforerun_FORERUN         0
#define DFLT_VAL_NX90_uartforerun_FORERUN    0x00000000U
#define DFLT_BF_VAL_NX90_uartforerun_FORERUN 0x00000000U

/* all used bits of 'NX90_uartforerun': */
#define MSK_USED_BITS_NX90_uartforerun 0x000000ffU

enum {
  BFW_NX90_uartforerun_FORERUN   = 8,  /* [7:0] */
  BFW_NX90_uartforerun_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_UARTFORERUN_BIT_Ttag {
  unsigned int FORERUN   : BFW_NX90_uartforerun_FORERUN;   /* number of forerun cycles in system clocks or bauds */
  unsigned int reserved1 : BFW_NX90_uartforerun_reserved1; /* reserved                                           */
} NX90_UARTFORERUN_BIT_T;

typedef union {
  uint32_t               val;
  NX90_UARTFORERUN_BIT_T bf;
} NX90_UARTFORERUN_T;

/* --------------------------------------------------------------------- */
/* Register uarttrail */
/* => RTS trail cycles */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uarttrail           0x0000002CU
#define Adr_NX90_uart_app_uarttrail      0xFF80106CU
#define Adr_NX90_uart_xpic_app_uarttrail 0xFF90032CU
#define DFLT_VAL_NX90_uarttrail          0x00000000U

#define MSK_NX90_uarttrail_TRAIL         0x000000ffU
#define SRT_NX90_uarttrail_TRAIL         0
#define DFLT_VAL_NX90_uarttrail_TRAIL    0x00000000U
#define DFLT_BF_VAL_NX90_uarttrail_TRAIL 0x00000000U

/* all used bits of 'NX90_uarttrail': */
#define MSK_USED_BITS_NX90_uarttrail 0x000000ffU

enum {
  BFW_NX90_uarttrail_TRAIL     = 8,  /* [7:0] */
  BFW_NX90_uarttrail_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_UARTTRAIL_BIT_Ttag {
  unsigned int TRAIL     : BFW_NX90_uarttrail_TRAIL;     /* number of trail cycles in system clocks or bauds */
  unsigned int reserved1 : BFW_NX90_uarttrail_reserved1; /* reserved                                         */
} NX90_UARTTRAIL_BIT_T;

typedef union {
  uint32_t             val;
  NX90_UARTTRAIL_BIT_T bf;
} NX90_UARTTRAIL_T;

/* --------------------------------------------------------------------- */
/* Register uartdrvout */
/* => Drive Output */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartdrvout           0x00000030U
#define Adr_NX90_uart_app_uartdrvout      0xFF801070U
#define Adr_NX90_uart_xpic_app_uartdrvout 0xFF900330U
#define DFLT_VAL_NX90_uartdrvout          0x00000000U

#define MSK_NX90_uartdrvout_DRVTX          0x00000001U
#define SRT_NX90_uartdrvout_DRVTX          0
#define DFLT_VAL_NX90_uartdrvout_DRVTX     0x00000000U
#define DFLT_BF_VAL_NX90_uartdrvout_DRVTX  0x00000000U
#define MSK_NX90_uartdrvout_DRVRTS         0x00000002U
#define SRT_NX90_uartdrvout_DRVRTS         1
#define DFLT_VAL_NX90_uartdrvout_DRVRTS    0x00000000U
#define DFLT_BF_VAL_NX90_uartdrvout_DRVRTS 0x00000000U

/* all used bits of 'NX90_uartdrvout': */
#define MSK_USED_BITS_NX90_uartdrvout 0x00000003U

enum {
  BFW_NX90_uartdrvout_DRVTX     = 1,  /* [0] */
  BFW_NX90_uartdrvout_DRVRTS    = 1,  /* [1] */
  BFW_NX90_uartdrvout_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_UARTDRVOUT_BIT_Ttag {
  unsigned int DRVTX     : BFW_NX90_uartdrvout_DRVTX;     /* enable driver for TX  */
  unsigned int DRVRTS    : BFW_NX90_uartdrvout_DRVRTS;    /* enable driver for RTS */
  unsigned int reserved1 : BFW_NX90_uartdrvout_reserved1; /* reserved              */
} NX90_UARTDRVOUT_BIT_T;

typedef union {
  uint32_t              val;
  NX90_UARTDRVOUT_BIT_T bf;
} NX90_UARTDRVOUT_T;

/* --------------------------------------------------------------------- */
/* Register uartcr_2 */
/* => Control Register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartcr_2           0x00000034U
#define Adr_NX90_uart_app_uartcr_2      0xFF801074U
#define Adr_NX90_uart_xpic_app_uartcr_2 0xFF900334U
#define DFLT_VAL_NX90_uartcr_2          0x00000000U

#define MSK_NX90_uartcr_2_Baud_Rate_Mode         0x00000001U
#define SRT_NX90_uartcr_2_Baud_Rate_Mode         0
#define DFLT_VAL_NX90_uartcr_2_Baud_Rate_Mode    0x00000000U
#define DFLT_BF_VAL_NX90_uartcr_2_Baud_Rate_Mode 0x00000000U

/* all used bits of 'NX90_uartcr_2': */
#define MSK_USED_BITS_NX90_uartcr_2 0x00000001U

enum {
  BFW_NX90_uartcr_2_Baud_Rate_Mode = 1,  /* [0] */
  BFW_NX90_uartcr_2_reserved1      = 31  /* [31:1] */
};

typedef struct NX90_UARTCR_2_BIT_Ttag {
  unsigned int Baud_Rate_Mode : BFW_NX90_uartcr_2_Baud_Rate_Mode; /* If this bit is set the baud rate is generated more exactly by the following formula: */
                                                                  /* value = ( (Baud Rate * 16) / System Frequency ) * 2^16  .                            */
                                                                  /* You have to write this 16-bit value in register uartlcr_l and uartlcr_m.             */
  unsigned int reserved1      : BFW_NX90_uartcr_2_reserved1;      /* reserved                                                                             */
} NX90_UARTCR_2_BIT_T;

typedef union {
  uint32_t            val;
  NX90_UARTCR_2_BIT_T bf;
} NX90_UARTCR_2_T;

/* --------------------------------------------------------------------- */
/* Register uartrxiflsel */
/* => RX FIFO trigger level and RX-DMA enable */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uartrxiflsel           0x00000038U
#define Adr_NX90_uart_app_uartrxiflsel      0xFF801078U
#define Adr_NX90_uart_xpic_app_uartrxiflsel 0xFF900338U
#define DFLT_VAL_NX90_uartrxiflsel          0x00000008U

#define MSK_NX90_uartrxiflsel_RXIFLSEL         0x0000001fU
#define SRT_NX90_uartrxiflsel_RXIFLSEL         0
#define DFLT_VAL_NX90_uartrxiflsel_RXIFLSEL    0x00000008U
#define DFLT_BF_VAL_NX90_uartrxiflsel_RXIFLSEL 0x00000008U
#define MSK_NX90_uartrxiflsel_RXDMA            0x00000020U
#define SRT_NX90_uartrxiflsel_RXDMA            5
#define DFLT_VAL_NX90_uartrxiflsel_RXDMA       0x00000000U
#define DFLT_BF_VAL_NX90_uartrxiflsel_RXDMA    0x00000000U

/* all used bits of 'NX90_uartrxiflsel': */
#define MSK_USED_BITS_NX90_uartrxiflsel 0x0000003fU

enum {
  BFW_NX90_uartrxiflsel_RXIFLSEL  = 5,  /* [4:0] */
  BFW_NX90_uartrxiflsel_RXDMA     = 1,  /* [5] */
  BFW_NX90_uartrxiflsel_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_UARTRXIFLSEL_BIT_Ttag {
  unsigned int RXIFLSEL  : BFW_NX90_uartrxiflsel_RXIFLSEL;  /*   Choose a number between 1 and 16. It defines the IRQ trigger level of the receive fifo.                                  */
                                                            /*   The IRQ (UARTRXINTR) will be set if the number of received bytes in the receive fifo are greater than or equal RXIFLSEL. */
  unsigned int RXDMA     : BFW_NX90_uartrxiflsel_RXDMA;     /*   Enable DMA-requests for RX-fifo-data.                                                                                    */
                                                            /*   A request will be generated if RX-FIFO is not empty and uartcr.uartEN (module enable) is set.                            */
                                                            /*   Burst request to DMA-Ctrl will be done if the RX-FIFO contains at least 4 words (set DMA-burst-size to 4)                */
                                                            /*   If this bit is reset or the module is disabled, DMA-request will also be reset.                                          */
                                                            /*   single transfer request: RX-FIFO contains 1 byte or more, burst request: 4 bytes or more                                 */
                                                            /*   note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module                                              */
  unsigned int reserved1 : BFW_NX90_uartrxiflsel_reserved1; /* reserved                                                                                                                   */
} NX90_UARTRXIFLSEL_BIT_T;

typedef union {
  uint32_t                val;
  NX90_UARTRXIFLSEL_BIT_T bf;
} NX90_UARTRXIFLSEL_T;

/* --------------------------------------------------------------------- */
/* Register uarttxiflsel */
/* => TX FIFO trigger level and TX-DMA enable */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_uarttxiflsel           0x0000003CU
#define Adr_NX90_uart_app_uarttxiflsel      0xFF80107CU
#define Adr_NX90_uart_xpic_app_uarttxiflsel 0xFF90033CU
#define DFLT_VAL_NX90_uarttxiflsel          0x00000008U

#define MSK_NX90_uarttxiflsel_TXIFLSEL         0x0000001fU
#define SRT_NX90_uarttxiflsel_TXIFLSEL         0
#define DFLT_VAL_NX90_uarttxiflsel_TXIFLSEL    0x00000008U
#define DFLT_BF_VAL_NX90_uarttxiflsel_TXIFLSEL 0x00000008U
#define MSK_NX90_uarttxiflsel_TXDMA            0x00000020U
#define SRT_NX90_uarttxiflsel_TXDMA            5
#define DFLT_VAL_NX90_uarttxiflsel_TXDMA       0x00000000U
#define DFLT_BF_VAL_NX90_uarttxiflsel_TXDMA    0x00000000U

/* all used bits of 'NX90_uarttxiflsel': */
#define MSK_USED_BITS_NX90_uarttxiflsel 0x0000003fU

enum {
  BFW_NX90_uarttxiflsel_TXIFLSEL  = 5,  /* [4:0] */
  BFW_NX90_uarttxiflsel_TXDMA     = 1,  /* [5] */
  BFW_NX90_uarttxiflsel_reserved1 = 26  /* [31:6] */
};

typedef struct NX90_UARTTXIFLSEL_BIT_Ttag {
  unsigned int TXIFLSEL  : BFW_NX90_uarttxiflsel_TXIFLSEL;  /*   Choose a number between 1 and 16. It defines the IRQ trigger level of the transmit fifo.                         */
                                                            /*   The IRQ (UARTTXINTR) will be set if the number of transmitted bytes in the transmit fifo are less than TXIFLSEL. */
  unsigned int TXDMA     : BFW_NX90_uarttxiflsel_TXDMA;     /*   Enable DMA-requests for TX-fifo-data.                                                                            */
                                                            /*   A request will be generated if TX-FIFO is not full and uartcr.uartEN (module enable) is set.                     */
                                                            /*   Burst request to DMA-Ctrl will be done if at least 4 words are writable to the TX-FIFO (set DMA-burst-size to 4) */
                                                            /*   If this bit is reset or the module is disabled, DMA-request will also be reset.                                  */
                                                            /*   note: set adr_dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMA module                                      */
  unsigned int reserved1 : BFW_NX90_uarttxiflsel_reserved1; /* reserved                                                                                                           */
} NX90_UARTTXIFLSEL_BIT_T;

typedef union {
  uint32_t                val;
  NX90_UARTTXIFLSEL_BIT_T bf;
} NX90_UARTTXIFLSEL_T;


/* ===================================================================== */

/* AREA i2c */
/* Area of i2c_app, i2c_xpic_app */

/* ===================================================================== */

#define Addr_NX90_i2c_app      0xFF801080U
#define Addr_NX90_i2c_xpic_app 0xFF900340U

/* --------------------------------------------------------------------- */
/* Register i2c_mcr */
/* => I2C master control register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_mcr          0x00000000U
#define Adr_NX90_i2c_app_i2c_mcr      0xFF801080U
#define Adr_NX90_i2c_xpic_app_i2c_mcr 0xFF900340U
#define DFLT_VAL_NX90_i2c_mcr         0x00000000U

#define MSK_NX90_i2c_mcr_en_i2c             0x00000001U
#define SRT_NX90_i2c_mcr_en_i2c             0
#define DFLT_VAL_NX90_i2c_mcr_en_i2c        0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mcr_en_i2c     0x00000000U
#define MSK_NX90_i2c_mcr_mode               0x0000000eU
#define SRT_NX90_i2c_mcr_mode               1
#define DFLT_VAL_NX90_i2c_mcr_mode          0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mcr_mode       0x00000000U
#define MSK_NX90_i2c_mcr_sadr               0x000007f0U
#define SRT_NX90_i2c_mcr_sadr               4
#define DFLT_VAL_NX90_i2c_mcr_sadr          0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mcr_sadr       0x00000000U
#define MSK_NX90_i2c_mcr_pio_mode           0x00010000U
#define SRT_NX90_i2c_mcr_pio_mode           16
#define DFLT_VAL_NX90_i2c_mcr_pio_mode      0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mcr_pio_mode   0x00000000U
#define MSK_NX90_i2c_mcr_rst_i2c            0x00020000U
#define SRT_NX90_i2c_mcr_rst_i2c            17
#define DFLT_VAL_NX90_i2c_mcr_rst_i2c       0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mcr_rst_i2c    0x00000000U
#define MSK_NX90_i2c_mcr_en_timeout         0x00040000U
#define SRT_NX90_i2c_mcr_en_timeout         18
#define DFLT_VAL_NX90_i2c_mcr_en_timeout    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mcr_en_timeout 0x00000000U

/* all used bits of 'NX90_i2c_mcr': */
#define MSK_USED_BITS_NX90_i2c_mcr 0x000707ffU

enum {
  BFW_NX90_i2c_mcr_en_i2c     = 1,  /* [0] */
  BFW_NX90_i2c_mcr_mode       = 3,  /* [3:1] */
  BFW_NX90_i2c_mcr_sadr       = 7,  /* [10:4] */
  BFW_NX90_i2c_mcr_reserved1  = 5,  /* [15:11] */
  BFW_NX90_i2c_mcr_pio_mode   = 1,  /* [16] */
  BFW_NX90_i2c_mcr_rst_i2c    = 1,  /* [17] */
  BFW_NX90_i2c_mcr_en_timeout = 1,  /* [18] */
  BFW_NX90_i2c_mcr_reserved2  = 13  /* [31:19] */
};

typedef struct NX90_I2C_MCR_BIT_Ttag {
  unsigned int en_i2c     : BFW_NX90_i2c_mcr_en_i2c;     /* Global I2C controller enable                                                                                                                                   */
                                                         /* 1: Enable I2C controller                                                                                                                                       */
                                                         /* 0: Disable I2C controller                                                                                                                                      */
                                                         /* Disabling the I2C module during a transfer will immediately disconnect the I2C module                                                                          */
                                                         /* from the bus without generating a STOP. The internal I2C state machine will be set back to initial/idle state.                                                 */
                                                         /* The I2C bus-state-detection for the bits i2c_sr.bus_master and i2c_sr.started are performed even if the                                                        */
                                                         /* module is disabled. For details, see these bits.                                                                                                               */
  unsigned int mode       : BFW_NX90_i2c_mcr_mode;       /* I2C-speed-mode:                                                                                                                                                */
                                                         /* If this device is used as a slave only, the mode should be set to the data rate generated by the fastest master on the I2C-bus                                 */
                                                         /* for appropriate input filtering and spike suppression.                                                                                                         */
                                                         /* 000: Fast/Standard mode, 50 kbit/s                                                                                                                             */
                                                         /* 001: Fast/Standard mode, 100 kbit/s                                                                                                                            */
                                                         /* 010: Fast/Standard mode, 200 kbit/s                                                                                                                            */
                                                         /* 011: Fast/Standard mode, 400 kbit/s                                                                                                                            */
                                                         /* 100: High-speed mode, 800 kbit/s                                                                                                                               */
                                                         /* 101: High-speed mode, 1.2 Mbit/s                                                                                                                               */
                                                         /* 110: High-speed mode, 1.7 Mbit/s                                                                                                                               */
                                                         /* 111: High-speed mode, 3.4 Mbit/s)                                                                                                                              */
  unsigned int sadr       : BFW_NX90_i2c_mcr_sadr;       /* 7-bit slave address sent after (r)START:                                                                                                                       */
                                                         /* For 10-bit addressing, the first byte (10-bit start '11110', address bits[9:8] must be programmed here. The second start                                       */
                                                         /* byte (lower slave address bits) must be on top of the master FIFO (i2c_mdr).                                                                                   */
                                                         /* This register must be rewritten (even if the value does not change) to address another slave in the 10-bit mode (run 2-byte start sequence). The register must */
                                                         /* not be rewritten before a repeated START on the same 10-bit addressed slave (run 1-byte start sequence e.g. write to read change).                             */
  unsigned int reserved1  : BFW_NX90_i2c_mcr_reserved1;  /* reserved                                                                                                                                                       */
  unsigned int pio_mode   : BFW_NX90_i2c_mcr_pio_mode;   /* If this bit is set, SCL and SDA can be controlled directly by register i2c_pio (e.g. to access devices being incompatible with I2C).                           */
                                                         /* In PIO mode, the I2C controller state machine is disabled: FIFOs are not used, no IRQs will be set, and no DMA controlling is possible.                        */
  unsigned int rst_i2c    : BFW_NX90_i2c_mcr_rst_i2c;    /* Reset the I2C bus-state-detection logic.                                                                                                                       */
                                                         /* To avoid conflicts with other masters, some I2C bus states, which are important when there are multiple                                                        */
                                                         /* masters on the I2C bus, are always monitored, even if the I2C module is disabled.                                                                              */
                                                         /* For details, see bits i2c_sr.started and i2c.bus_master.                                                                                                       */
                                                         /* However, it may happen that bus states are detected which lock up the I2C module.                                                                              */
                                                         /* E.g. hazards during power-up or IO configuration or                                                                                                            */
                                                         /* sequences, which are not I2C compliant, can cause a lock-up.                                                                                                   */
                                                         /* This bit can be used to escape from such a situation.                                                                                                          */
                                                         /* Write a '1' here to reset the I2C bus-state-detection logic of register i2c_sr.                                                                                */
                                                         /* Note: This bit is new since netX51/52. It is always '0' when read.                                                                                             */
  unsigned int en_timeout : BFW_NX90_i2c_mcr_en_timeout; /* Enable I2C command timeout detection.                                                                                                                          */
                                                         /* Enabling the timeout detection is recommended to prevent the module from stalling if                                                                           */
                                                         /* another device holds the I2C signals permanently low.                                                                                                          */
                                                         /* For details, see the description of bit i2s_sr.timeout.                                                                                                        */
  unsigned int reserved2  : BFW_NX90_i2c_mcr_reserved2;  /* reserved                                                                                                                                                       */
} NX90_I2C_MCR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_I2C_MCR_BIT_T bf;
} NX90_I2C_MCR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_scr */
/* => I2C slave control register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_scr          0x00000004U
#define Adr_NX90_i2c_app_i2c_scr      0xFF801084U
#define Adr_NX90_i2c_xpic_app_i2c_scr 0xFF900344U
#define DFLT_VAL_NX90_i2c_scr         0x00000000U

#define MSK_NX90_i2c_scr_sid                        0x000003ffU
#define SRT_NX90_i2c_scr_sid                        0
#define DFLT_VAL_NX90_i2c_scr_sid                   0x00000000U
#define DFLT_BF_VAL_NX90_i2c_scr_sid                0x00000000U
#define MSK_NX90_i2c_scr_sid10                      0x00000400U
#define SRT_NX90_i2c_scr_sid10                      10
#define DFLT_VAL_NX90_i2c_scr_sid10                 0x00000000U
#define DFLT_BF_VAL_NX90_i2c_scr_sid10              0x00000000U
#define MSK_NX90_i2c_scr_ac_srx                     0x00010000U
#define SRT_NX90_i2c_scr_ac_srx                     16
#define DFLT_VAL_NX90_i2c_scr_ac_srx                0x00000000U
#define DFLT_BF_VAL_NX90_i2c_scr_ac_srx             0x00000000U
#define MSK_NX90_i2c_scr_ac_start                   0x00020000U
#define SRT_NX90_i2c_scr_ac_start                   17
#define DFLT_VAL_NX90_i2c_scr_ac_start              0x00000000U
#define DFLT_BF_VAL_NX90_i2c_scr_ac_start           0x00000000U
#define MSK_NX90_i2c_scr_ac_gcall                   0x00040000U
#define SRT_NX90_i2c_scr_ac_gcall                   18
#define DFLT_VAL_NX90_i2c_scr_ac_gcall              0x00000000U
#define DFLT_BF_VAL_NX90_i2c_scr_ac_gcall           0x00000000U
#define MSK_NX90_i2c_scr_autoreset_ac_start         0x00100000U
#define SRT_NX90_i2c_scr_autoreset_ac_start         20
#define DFLT_VAL_NX90_i2c_scr_autoreset_ac_start    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_scr_autoreset_ac_start 0x00000000U

/* all used bits of 'NX90_i2c_scr': */
#define MSK_USED_BITS_NX90_i2c_scr 0x001707ffU

enum {
  BFW_NX90_i2c_scr_sid                = 10, /* [9:0] */
  BFW_NX90_i2c_scr_sid10              = 1,  /* [10] */
  BFW_NX90_i2c_scr_reserved1          = 5,  /* [15:11] */
  BFW_NX90_i2c_scr_ac_srx             = 1,  /* [16] */
  BFW_NX90_i2c_scr_ac_start           = 1,  /* [17] */
  BFW_NX90_i2c_scr_ac_gcall           = 1,  /* [18] */
  BFW_NX90_i2c_scr_reserved2          = 1,  /* [19] */
  BFW_NX90_i2c_scr_autoreset_ac_start = 1,  /* [20] */
  BFW_NX90_i2c_scr_reserved3          = 11  /* [31:21] */
};

typedef struct NX90_I2C_SCR_BIT_Ttag {
  unsigned int sid                : BFW_NX90_i2c_scr_sid;                /* Slave device ID/address:                                                                                               */
                                                                         /* External masters can address this device (this I2C module in slave mode) by the ID/address                             */
                                                                         /* programmed here. If sid10 is not set, bits 9 to 7 will be ignored.                                                     */
  unsigned int sid10              : BFW_NX90_i2c_scr_sid10;              /* 10-bit slave device ID/address:                                                                                        */
                                                                         /* 0: Wait for 7-bit slave address after (r)START                                                                         */
                                                                         /* 1: Wait for 10-bit slave address after (r)START                                                                        */
  unsigned int reserved1          : BFW_NX90_i2c_scr_reserved1;          /* reserved                                                                                                               */
  unsigned int ac_srx             : BFW_NX90_i2c_scr_ac_srx;             /* Enable slave-receive-data acknowledge:                                                                                 */
                                                                         /* 0: Do not acknowledge receive bytes                                                                                    */
                                                                         /* 1: Acknowledge receive bytes                                                                                           */
                                                                         /* If the slave FIFO is full, receive data will not be acknowledged.                                                      */
  unsigned int ac_start           : BFW_NX90_i2c_scr_ac_start;           /* Enable start sequence acknowledge:                                                                                     */
                                                                         /* If the received address matches the sid-bits, the start-byte (2 bytes if sid10 is set) will be acknowledged.           */
                                                                         /* If the master requests a read transfer, a slave FIFO read access will be carried out immediately after the             */
                                                                         /* acknowledge, i.e. valid data must be present in the slave FIFO before enabling the acknowledge.                        */
                                                                         /* If autoreset_ac_start is enabled, the controller will automatically reset this bit. If it is not enabled,              */
                                                                         /* the software should reset this bit after the start sequence has been acknowledged to avoid acknowledge and FIFO errors */
                                                                         /* after the next (r)START.                                                                                               */
                                                                         /* 0: Do not generate an acknowledge after the start sequence                                                             */
                                                                         /* 1: Generate an acknowledge after the start sequence                                                                    */
                                                                         /* This bit is writable, but can also be changed by hardware.                                                             */
  unsigned int ac_gcall           : BFW_NX90_i2c_scr_ac_gcall;           /* General call acknowledge:                                                                                              */
                                                                         /* 0: Do not generate an acknowledge after a general call                                                                 */
                                                                         /* 1: Generate an acknowledge after a general call                                                                        */
  unsigned int reserved2          : BFW_NX90_i2c_scr_reserved2;          /* reserved                                                                                                               */
  unsigned int autoreset_ac_start : BFW_NX90_i2c_scr_autoreset_ac_start; /* Auto reset ac_start (ac_start must be set again after any (r)START):                                                   */
                                                                         /* 0: ac_start will not be reset automatically (netX 50-compatible, but not recommended)                                  */
                                                                         /* 1: Reset ac_start after this slave acknowledged a start sequence (recommended)                                         */
  unsigned int reserved3          : BFW_NX90_i2c_scr_reserved3;          /* reserved                                                                                                               */
} NX90_I2C_SCR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_I2C_SCR_BIT_T bf;
} NX90_I2C_SCR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_cmd */
/* => I2C master command register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_cmd          0x00000008U
#define Adr_NX90_i2c_app_i2c_cmd      0xFF801088U
#define Adr_NX90_i2c_xpic_app_i2c_cmd 0xFF900348U
#define DFLT_VAL_NX90_i2c_cmd         0x0000000eU

#define MSK_NX90_i2c_cmd_nwr               0x00000001U
#define SRT_NX90_i2c_cmd_nwr               0
#define DFLT_VAL_NX90_i2c_cmd_nwr          0x00000000U
#define DFLT_BF_VAL_NX90_i2c_cmd_nwr       0x00000000U
#define MSK_NX90_i2c_cmd_cmd               0x0000000eU
#define SRT_NX90_i2c_cmd_cmd               1
#define DFLT_VAL_NX90_i2c_cmd_cmd          0x0000000eU
#define DFLT_BF_VAL_NX90_i2c_cmd_cmd       0x00000007U
#define MSK_NX90_i2c_cmd_tsize             0x0003ff00U
#define SRT_NX90_i2c_cmd_tsize             8
#define DFLT_VAL_NX90_i2c_cmd_tsize        0x00000000U
#define DFLT_BF_VAL_NX90_i2c_cmd_tsize     0x00000000U
#define MSK_NX90_i2c_cmd_acpollmax         0x0ff00000U
#define SRT_NX90_i2c_cmd_acpollmax         20
#define DFLT_VAL_NX90_i2c_cmd_acpollmax    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_cmd_acpollmax 0x00000000U

/* all used bits of 'NX90_i2c_cmd': */
#define MSK_USED_BITS_NX90_i2c_cmd 0x0ff3ff0fU

enum {
  BFW_NX90_i2c_cmd_nwr       = 1,  /* [0] */
  BFW_NX90_i2c_cmd_cmd       = 3,  /* [3:1] */
  BFW_NX90_i2c_cmd_reserved1 = 4,  /* [7:4] */
  BFW_NX90_i2c_cmd_tsize     = 10, /* [17:8] */
  BFW_NX90_i2c_cmd_reserved2 = 2,  /* [19:18] */
  BFW_NX90_i2c_cmd_acpollmax = 8,  /* [27:20] */
  BFW_NX90_i2c_cmd_reserved3 = 4   /* [31:28] */
};

typedef struct NX90_I2C_CMD_BIT_Ttag {
  unsigned int nwr       : BFW_NX90_i2c_cmd_nwr;       /* Transfer direction (not-write/read):                                                                                                                */
                                                       /* 0: cmd will be executed as write                                                                                                                    */
                                                       /* 1: cmd will be executed as read                                                                                                                     */
                                                       /* Master FIFO-requests (IRQ and DMA) are generated depending on this direction flag.                                                                  */
  unsigned int cmd       : BFW_NX90_i2c_cmd_cmd;       /* I2C sequence command:                                                                                                                               */
                                                       /* All commands will generate IRQ cmd_ok or IRQ cmd_err. A successful command termination will always generate IRQ cmd_ok. In                          */
                                                       /* case of an unsuccessful command termination, IRQ cmd_err will be set.                                                                               */
                                                       /* {    |         |                                                                                                                                    */
                                                       /*  000  START     Generate (r)START-condition                                                                                                         */
                                                       /*  001  S_AC      Acknowledge-polling: generate up to acpollmax+1 START-sequences (until acknowledged by slave)                                       */
                                                       /*  010  S_AC_T    Run S_AC, then transfer tsize+1 bytes from/to master FIFO.                                                                          */
                                                       /*                 Not to be continued                                                                                                                 */
                                                       /*  011  S_AC_TC   Run S_AC, then transfer tsize+1 bytes from/to master FIFO.                                                                          */
                                                       /*                 To be continued                                                                                                                     */
                                                       /*  100  CT        Continued transfer not to be continued                                                                                              */
                                                       /*  101  CTC       Continued transfer to be continued                                                                                                  */
                                                       /*  110  STOP      Generate STOP-condition                                                                                                             */
                                                       /*  111  IDLE      Nothing to do, last command finished, break current command }                                                                       */
                                                       /* Sequences including read transfers that are not to be continued (S_AC_T, CT with 'nwr' bit set) will not generate an acknowledge after              */
                                                       /* the last received byte (read transfer ends).                                                                                                        */
                                                       /* Read transfers that are to be continued (S_AC_TC, CTC) will generate an acknowledge after the last received byte and must be                        */
                                                       /* followed by CT or CTC.                                                                                                                              */
                                                       /* Before continued transfers (CT, CTC), a command including START (START, S_AC, S_AC_T, S_AC_TC) must be executed to generate                         */
                                                       /* a valid I2C sequence.                                                                                                                               */
                                                       /* STOP must always be executed by software to free the bus after transfer end. STOP is not included in any command sequence and                       */
                                                       /* never executed automatically by this module.                                                                                                        */
                                                       /* Some commands are handled as sequences (i.e. after setting S_AC_T, first S_AC then CT will be seen when read).                                      */
                                                       /* You need not poll for IDLE here before setting up a new command, but you have to wait for cmd_ok or cmd_err status                                  */
                                                       /* flags of register i2c_irqsr to be set.                                                                                                              */
                                                       /* This bit is writable, but can also be changed by hardware.                                                                                          */
  unsigned int reserved1 : BFW_NX90_i2c_cmd_reserved1; /* reserved                                                                                                                                            */
  unsigned int tsize     : BFW_NX90_i2c_cmd_tsize;     /* Transfer tsize+1 bytes (1...1024):                                                                                                                  */
                                                       /* If no acknowledge is generated by the slave (receiver), write transfers will be terminated and IRQ cmd_err will be generated.                       */
                                                       /* For 10-bit-addressing, the second start-byte (lower address bits) must be on top of the master FIFO. For subsequent transfers,                      */
                                                       /* the value programmed here has to ignore this byte.                                                                                                  */
                                                       /* This value will count down during transfers after each byte.                                                                                        */
                                                       /* This bit is writable, but can also be changed by hardware.                                                                                          */
  unsigned int reserved2 : BFW_NX90_i2c_cmd_reserved2; /* reserved                                                                                                                                            */
  unsigned int acpollmax : BFW_NX90_i2c_cmd_acpollmax; /* Number of tries (acpollmax+1, i.e. 1 to 256) for start sequence acknowledge polling:                                                                */
                                                       /* For 7-bit addressing, acknowledge polling START and the first byte containing the slave address (i2c_mcr.sadr) will be repeated up                  */
                                                       /* to acpollmax+1 times until a slave generates an acknowledge. If no acknowledge is received within acpollmax+1 tries, IRQ cmd_err will be generated. */
                                                       /* For 10-bit-addressing, the 2-byte start sequence is performed. The second address byte (lower address bits) must be on top of the                   */
                                                       /* master FIFO (i2c_mdr). For subsequent transfers, the value programmed in tsize has to ignore this byte.                                             */
                                                       /* The programmed value of acpollmax will count down during acknowledge polling after each start sequence.                                             */
                                                       /* This bit is writable, but can also be changed by hardware.                                                                                          */
  unsigned int reserved3 : BFW_NX90_i2c_cmd_reserved3; /* reserved                                                                                                                                            */
} NX90_I2C_CMD_BIT_T;

typedef union {
  uint32_t           val;
  NX90_I2C_CMD_BIT_T bf;
} NX90_I2C_CMD_T;

/* --------------------------------------------------------------------- */
/* Register i2c_mdr */
/* => I2C master data register (master FIFO): */
/*    There is only one FIFO for both receive and transmit master data with a depth of 16 bytes. For master write access, data sent by the master */
/*    is delivered from the FIFO. For master read access, data received by the master is stored in the FIFO. */
/*    In case of imminent data transfer failure (read transfer and FIFO is full or write transfer and FIFO is empty), the transfer will be interrupted. */
/*    To continue the transfer, the FIFO must be handled first (filled for write transfer, read out for read transfer). */
/*    Note: The FIFO behavior has been changed: For netX 51/52/56 and older versions, the current command was aborted and the cmd_err was raised. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_mdr          0x0000000CU
#define Adr_NX90_i2c_app_i2c_mdr      0xFF80108CU
#define Adr_NX90_i2c_xpic_app_i2c_mdr 0xFF90034CU
#define DFLT_VAL_NX90_i2c_mdr         0x00000000U

#define MSK_NX90_i2c_mdr_mdata         0x000000ffU
#define SRT_NX90_i2c_mdr_mdata         0
#define DFLT_VAL_NX90_i2c_mdr_mdata    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mdr_mdata 0x00000000U

/* all used bits of 'NX90_i2c_mdr': */
#define MSK_USED_BITS_NX90_i2c_mdr 0x000000ffU

enum {
  BFW_NX90_i2c_mdr_mdata     = 8,  /* [7:0] */
  BFW_NX90_i2c_mdr_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_I2C_MDR_BIT_Ttag {
  unsigned int mdata     : BFW_NX90_i2c_mdr_mdata;     /* I2C master transmit or receive data:                                                                                  */
                                                       /* Write data will be removed from the FIFO after the receiving slave has generated the corresponding acknowledge. Write */
                                                       /* data that has not been acknowledged will not be removed from the FIFO.                                                */
  unsigned int reserved1 : BFW_NX90_i2c_mdr_reserved1; /* reserved                                                                                                              */
} NX90_I2C_MDR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_I2C_MDR_BIT_T bf;
} NX90_I2C_MDR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_sdr */
/* => I2C slave data register (slave FIFO): */
/*    There is only one FIFO for both receive and transmit slave data with a depth of 16 bytes. For master read access, data sent by the slave */
/*    is delivered from the FIFO. For master write access, data received by the slave is stored in the FIFO. */
/*    A transfer is initiated after the detection of I2C-start-sequence to the device address (i2c_scr.sid, sreq IRQ) which is acknowledged by this */
/*    device (i2c_scr.ac_start). For read transfers, sent data is read from the FIFO immediately after the detection of the acknowledge on */
/*    the I2C-bus. SDA will be driven with the next data MSB immediately after the acknowledge SCL high phase. */
/*    In case of a master read transfer and slave FIFO underrun, corrupted data will be sent to the master and the IRQ fifo_err will be set. */
/*    In case of a master write transfer and slave FIFO is full, no acknowledge will be generated for the last received byte. No FIFO overflow */
/*    will occur, but the last transferred byte (not acknowledged) will be lost and has to be sent again by the master. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_sdr          0x00000010U
#define Adr_NX90_i2c_app_i2c_sdr      0xFF801090U
#define Adr_NX90_i2c_xpic_app_i2c_sdr 0xFF900350U
#define DFLT_VAL_NX90_i2c_sdr         0x00000000U

#define MSK_NX90_i2c_sdr_sdata         0x000000ffU
#define SRT_NX90_i2c_sdr_sdata         0
#define DFLT_VAL_NX90_i2c_sdr_sdata    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sdr_sdata 0x00000000U

/* all used bits of 'NX90_i2c_sdr': */
#define MSK_USED_BITS_NX90_i2c_sdr 0x000000ffU

enum {
  BFW_NX90_i2c_sdr_sdata     = 8,  /* [7:0] */
  BFW_NX90_i2c_sdr_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_I2C_SDR_BIT_Ttag {
  unsigned int sdata     : BFW_NX90_i2c_sdr_sdata;     /* I2C slave transmit or receive data:                                                      */
                                                       /* The software must handle i2c_scr.ac_start correctly to avoid FIFO errors after (r)START. */
  unsigned int reserved1 : BFW_NX90_i2c_sdr_reserved1; /* reserved                                                                                 */
} NX90_I2C_SDR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_I2C_SDR_BIT_T bf;
} NX90_I2C_SDR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_mfifo_cr */
/* => I2C master FIFO control register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_mfifo_cr          0x00000014U
#define Adr_NX90_i2c_app_i2c_mfifo_cr      0xFF801094U
#define Adr_NX90_i2c_xpic_app_i2c_mfifo_cr 0xFF900354U
#define DFLT_VAL_NX90_i2c_mfifo_cr         0x00000000U

#define MSK_NX90_i2c_mfifo_cr_mfifo_wm          0x0000000fU
#define SRT_NX90_i2c_mfifo_cr_mfifo_wm          0
#define DFLT_VAL_NX90_i2c_mfifo_cr_mfifo_wm     0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mfifo_cr_mfifo_wm  0x00000000U
#define MSK_NX90_i2c_mfifo_cr_mfifo_clr         0x00000100U
#define SRT_NX90_i2c_mfifo_cr_mfifo_clr         8
#define DFLT_VAL_NX90_i2c_mfifo_cr_mfifo_clr    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_mfifo_cr_mfifo_clr 0x00000000U

/* all used bits of 'NX90_i2c_mfifo_cr': */
#define MSK_USED_BITS_NX90_i2c_mfifo_cr 0x0000010fU

enum {
  BFW_NX90_i2c_mfifo_cr_mfifo_wm  = 4,  /* [3:0] */
  BFW_NX90_i2c_mfifo_cr_reserved1 = 4,  /* [7:4] */
  BFW_NX90_i2c_mfifo_cr_mfifo_clr = 1,  /* [8] */
  BFW_NX90_i2c_mfifo_cr_reserved2 = 23  /* [31:9] */
};

typedef struct NX90_I2C_MFIFO_CR_BIT_Ttag {
  unsigned int mfifo_wm  : BFW_NX90_i2c_mfifo_cr_mfifo_wm;  /* Master FIFO watermark for the generation of IRQ mfifo_req:                                                           */
                                                            /* If the master is the transmitter (enabled and i2c_cmd.nwr is 0), IRQ mfifo_req is generated if mfifo_level<mfifo_wm. */
                                                            /* If the master is the receiver (enabled and i2c_cmd.nwr is 1), IRQ mfifo_req is generated if mfifo_level>mfifo_wm.    */
                                                            /* Note: Set the watermark to 0 at transfer end to avoid further IRQ generation.                                        */
  unsigned int reserved1 : BFW_NX90_i2c_mfifo_cr_reserved1; /* reserved                                                                                                             */
  unsigned int mfifo_clr : BFW_NX90_i2c_mfifo_cr_mfifo_clr; /* Clear master data FIFO, write only bit.                                                                              */
                                                            /* This bit is writable, but can also be changed by hardware.                                                           */
  unsigned int reserved2 : BFW_NX90_i2c_mfifo_cr_reserved2; /* reserved                                                                                                             */
} NX90_I2C_MFIFO_CR_BIT_T;

typedef union {
  uint32_t                val;
  NX90_I2C_MFIFO_CR_BIT_T bf;
} NX90_I2C_MFIFO_CR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_sfifo_cr */
/* => I2C slave FIFO control register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_sfifo_cr          0x00000018U
#define Adr_NX90_i2c_app_i2c_sfifo_cr      0xFF801098U
#define Adr_NX90_i2c_xpic_app_i2c_sfifo_cr 0xFF900358U
#define DFLT_VAL_NX90_i2c_sfifo_cr         0x00000000U

#define MSK_NX90_i2c_sfifo_cr_sfifo_wm          0x0000000fU
#define SRT_NX90_i2c_sfifo_cr_sfifo_wm          0
#define DFLT_VAL_NX90_i2c_sfifo_cr_sfifo_wm     0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sfifo_cr_sfifo_wm  0x00000000U
#define MSK_NX90_i2c_sfifo_cr_sfifo_clr         0x00000100U
#define SRT_NX90_i2c_sfifo_cr_sfifo_clr         8
#define DFLT_VAL_NX90_i2c_sfifo_cr_sfifo_clr    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sfifo_cr_sfifo_clr 0x00000000U

/* all used bits of 'NX90_i2c_sfifo_cr': */
#define MSK_USED_BITS_NX90_i2c_sfifo_cr 0x0000010fU

enum {
  BFW_NX90_i2c_sfifo_cr_sfifo_wm  = 4,  /* [3:0] */
  BFW_NX90_i2c_sfifo_cr_reserved1 = 4,  /* [7:4] */
  BFW_NX90_i2c_sfifo_cr_sfifo_clr = 1,  /* [8] */
  BFW_NX90_i2c_sfifo_cr_reserved2 = 23  /* [31:9] */
};

typedef struct NX90_I2C_SFIFO_CR_BIT_Ttag {
  unsigned int sfifo_wm  : BFW_NX90_i2c_sfifo_cr_sfifo_wm;  /* Slave FIFO watermark for the generation of IRQ sfifo_req:                                                                                              */
                                                            /* If the slave is the transmitter (start sequence with set read bit was acknowledged by this slave), IRQ sfifo_req is generated if sfifo_level<sfifo_wm. */
                                                            /* If the slave is not the transmitter (is receiver or not selected), IRQ sfifo_req is generated if sfifo_level>sfifo_wm.                                 */
  unsigned int reserved1 : BFW_NX90_i2c_sfifo_cr_reserved1; /* reserved                                                                                                                                               */
  unsigned int sfifo_clr : BFW_NX90_i2c_sfifo_cr_sfifo_clr; /* Clear slave data FIFO, write only bit.                                                                                                                 */
                                                            /* This bit is writable, but can also be changed by hardware.                                                                                             */
  unsigned int reserved2 : BFW_NX90_i2c_sfifo_cr_reserved2; /* reserved                                                                                                                                               */
} NX90_I2C_SFIFO_CR_BIT_T;

typedef union {
  uint32_t                val;
  NX90_I2C_SFIFO_CR_BIT_T bf;
} NX90_I2C_SFIFO_CR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_sr */
/* => I2C status register: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_sr          0x0000001CU
#define Adr_NX90_i2c_app_i2c_sr      0xFF80109CU
#define Adr_NX90_i2c_xpic_app_i2c_sr 0xFF90035CU
#define DFLT_VAL_NX90_i2c_sr         0xc0110040U

#define MSK_NX90_i2c_sr_mfifo_level            0x0000001fU
#define SRT_NX90_i2c_sr_mfifo_level            0
#define DFLT_VAL_NX90_i2c_sr_mfifo_level       0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_mfifo_level    0x00000000U
#define MSK_NX90_i2c_sr_mfifo_empty            0x00000040U
#define SRT_NX90_i2c_sr_mfifo_empty            6
#define DFLT_VAL_NX90_i2c_sr_mfifo_empty       0x00000040U
#define DFLT_BF_VAL_NX90_i2c_sr_mfifo_empty    0x00000001U
#define MSK_NX90_i2c_sr_mfifo_full             0x00000080U
#define SRT_NX90_i2c_sr_mfifo_full             7
#define DFLT_VAL_NX90_i2c_sr_mfifo_full        0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_mfifo_full     0x00000000U
#define MSK_NX90_i2c_sr_mfifo_err_ovfl         0x00000100U
#define SRT_NX90_i2c_sr_mfifo_err_ovfl         8
#define DFLT_VAL_NX90_i2c_sr_mfifo_err_ovfl    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_mfifo_err_ovfl 0x00000000U
#define MSK_NX90_i2c_sr_mfifo_err_undr         0x00000200U
#define SRT_NX90_i2c_sr_mfifo_err_undr         9
#define DFLT_VAL_NX90_i2c_sr_mfifo_err_undr    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_mfifo_err_undr 0x00000000U
#define MSK_NX90_i2c_sr_sfifo_level            0x00007c00U
#define SRT_NX90_i2c_sr_sfifo_level            10
#define DFLT_VAL_NX90_i2c_sr_sfifo_level       0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_sfifo_level    0x00000000U
#define MSK_NX90_i2c_sr_sfifo_empty            0x00010000U
#define SRT_NX90_i2c_sr_sfifo_empty            16
#define DFLT_VAL_NX90_i2c_sr_sfifo_empty       0x00010000U
#define DFLT_BF_VAL_NX90_i2c_sr_sfifo_empty    0x00000001U
#define MSK_NX90_i2c_sr_sfifo_full             0x00020000U
#define SRT_NX90_i2c_sr_sfifo_full             17
#define DFLT_VAL_NX90_i2c_sr_sfifo_full        0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_sfifo_full     0x00000000U
#define MSK_NX90_i2c_sr_sfifo_err_ovfl         0x00040000U
#define SRT_NX90_i2c_sr_sfifo_err_ovfl         18
#define DFLT_VAL_NX90_i2c_sr_sfifo_err_ovfl    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_sfifo_err_ovfl 0x00000000U
#define MSK_NX90_i2c_sr_sfifo_err_undr         0x00080000U
#define SRT_NX90_i2c_sr_sfifo_err_undr         19
#define DFLT_VAL_NX90_i2c_sr_sfifo_err_undr    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_sfifo_err_undr 0x00000000U
#define MSK_NX90_i2c_sr_bus_master             0x00100000U
#define SRT_NX90_i2c_sr_bus_master             20
#define DFLT_VAL_NX90_i2c_sr_bus_master        0x00100000U
#define DFLT_BF_VAL_NX90_i2c_sr_bus_master     0x00000001U
#define MSK_NX90_i2c_sr_nwr                    0x00200000U
#define SRT_NX90_i2c_sr_nwr                    21
#define DFLT_VAL_NX90_i2c_sr_nwr               0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_nwr            0x00000000U
#define MSK_NX90_i2c_sr_started                0x00400000U
#define SRT_NX90_i2c_sr_started                22
#define DFLT_VAL_NX90_i2c_sr_started           0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_started        0x00000000U
#define MSK_NX90_i2c_sr_slave_access           0x00800000U
#define SRT_NX90_i2c_sr_slave_access           23
#define DFLT_VAL_NX90_i2c_sr_slave_access      0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_slave_access   0x00000000U
#define MSK_NX90_i2c_sr_last_ac                0x01000000U
#define SRT_NX90_i2c_sr_last_ac                24
#define DFLT_VAL_NX90_i2c_sr_last_ac           0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_last_ac        0x00000000U
#define MSK_NX90_i2c_sr_nwr_aced               0x02000000U
#define SRT_NX90_i2c_sr_nwr_aced               25
#define DFLT_VAL_NX90_i2c_sr_nwr_aced          0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_nwr_aced       0x00000000U
#define MSK_NX90_i2c_sr_gcall_aced             0x04000000U
#define SRT_NX90_i2c_sr_gcall_aced             26
#define DFLT_VAL_NX90_i2c_sr_gcall_aced        0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_gcall_aced     0x00000000U
#define MSK_NX90_i2c_sr_sid10_aced             0x08000000U
#define SRT_NX90_i2c_sr_sid10_aced             27
#define DFLT_VAL_NX90_i2c_sr_sid10_aced        0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_sid10_aced     0x00000000U
#define MSK_NX90_i2c_sr_timeout                0x10000000U
#define SRT_NX90_i2c_sr_timeout                28
#define DFLT_VAL_NX90_i2c_sr_timeout           0x00000000U
#define DFLT_BF_VAL_NX90_i2c_sr_timeout        0x00000000U
#define MSK_NX90_i2c_sr_scl_state              0x40000000U
#define SRT_NX90_i2c_sr_scl_state              30
#define DFLT_VAL_NX90_i2c_sr_scl_state         0x40000000U
#define DFLT_BF_VAL_NX90_i2c_sr_scl_state      0x00000001U
#define MSK_NX90_i2c_sr_sda_state              0x80000000U
#define SRT_NX90_i2c_sr_sda_state              31
#define DFLT_VAL_NX90_i2c_sr_sda_state         0x80000000U
#define DFLT_BF_VAL_NX90_i2c_sr_sda_state      0x00000001U

/* all used bits of 'NX90_i2c_sr': */
#define MSK_USED_BITS_NX90_i2c_sr 0xdfff7fdfU

enum {
  BFW_NX90_i2c_sr_mfifo_level    = 5, /* [4:0] */
  BFW_NX90_i2c_sr_reserved1      = 1, /* [5] */
  BFW_NX90_i2c_sr_mfifo_empty    = 1, /* [6] */
  BFW_NX90_i2c_sr_mfifo_full     = 1, /* [7] */
  BFW_NX90_i2c_sr_mfifo_err_ovfl = 1, /* [8] */
  BFW_NX90_i2c_sr_mfifo_err_undr = 1, /* [9] */
  BFW_NX90_i2c_sr_sfifo_level    = 5, /* [14:10] */
  BFW_NX90_i2c_sr_reserved2      = 1, /* [15] */
  BFW_NX90_i2c_sr_sfifo_empty    = 1, /* [16] */
  BFW_NX90_i2c_sr_sfifo_full     = 1, /* [17] */
  BFW_NX90_i2c_sr_sfifo_err_ovfl = 1, /* [18] */
  BFW_NX90_i2c_sr_sfifo_err_undr = 1, /* [19] */
  BFW_NX90_i2c_sr_bus_master     = 1, /* [20] */
  BFW_NX90_i2c_sr_nwr            = 1, /* [21] */
  BFW_NX90_i2c_sr_started        = 1, /* [22] */
  BFW_NX90_i2c_sr_slave_access   = 1, /* [23] */
  BFW_NX90_i2c_sr_last_ac        = 1, /* [24] */
  BFW_NX90_i2c_sr_nwr_aced       = 1, /* [25] */
  BFW_NX90_i2c_sr_gcall_aced     = 1, /* [26] */
  BFW_NX90_i2c_sr_sid10_aced     = 1, /* [27] */
  BFW_NX90_i2c_sr_timeout        = 1, /* [28] */
  BFW_NX90_i2c_sr_reserved3      = 1, /* [29] */
  BFW_NX90_i2c_sr_scl_state      = 1, /* [30] */
  BFW_NX90_i2c_sr_sda_state      = 1  /* [31] */
};

typedef struct NX90_I2C_SR_BIT_Ttag {
  unsigned int mfifo_level    : BFW_NX90_i2c_sr_mfifo_level;    /* Master FIFO level (0..16)                                                                                              */
                                                                /* This is a read-only status bit field.                                                                                  */
  unsigned int reserved1      : BFW_NX90_i2c_sr_reserved1;      /* reserved                                                                                                               */
  unsigned int mfifo_empty    : BFW_NX90_i2c_sr_mfifo_empty;    /* Master FIFO is empty (1 if empty)                                                                                      */
                                                                /* This is a read-only status bit.                                                                                        */
  unsigned int mfifo_full     : BFW_NX90_i2c_sr_mfifo_full;     /* Master FIFO is full (1 if full)                                                                                        */
                                                                /* This is a read-only status bit.                                                                                        */
  unsigned int mfifo_err_ovfl : BFW_NX90_i2c_sr_mfifo_err_ovfl; /* Master FIFO overflow error occurred.                                                                                   */
                                                                /* Data is lost and the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr.                                        */
                                                                /* Clearing the master FIFO will also clear this read-only status bit.                                                    */
  unsigned int mfifo_err_undr : BFW_NX90_i2c_sr_mfifo_err_undr; /* Master FIFO underrun error occurred.                                                                                   */
                                                                /* Data is lost and the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr.                                        */
                                                                /* Clearing the master FIFO will also clear this read-only status bit.                                                    */
  unsigned int sfifo_level    : BFW_NX90_i2c_sr_sfifo_level;    /* Slave FIFO level (0..16)                                                                                               */
                                                                /* This is a read-only status bit field.                                                                                  */
  unsigned int reserved2      : BFW_NX90_i2c_sr_reserved2;      /* reserved                                                                                                               */
  unsigned int sfifo_empty    : BFW_NX90_i2c_sr_sfifo_empty;    /* Slave FIFO is empty (1 if empty)                                                                                       */
                                                                /* This is a read-only status bit.                                                                                        */
  unsigned int sfifo_full     : BFW_NX90_i2c_sr_sfifo_full;     /* Slave FIFO is full (1 if full)                                                                                         */
                                                                /* This is a read-only status bit.                                                                                        */
  unsigned int sfifo_err_ovfl : BFW_NX90_i2c_sr_sfifo_err_ovfl; /* Slave FIFO overflow error occurred.                                                                                    */
                                                                /* Data is lost and the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr.                                         */
                                                                /* Clearing the slave FIFO will also clear this read-only status bit.                                                     */
  unsigned int sfifo_err_undr : BFW_NX90_i2c_sr_sfifo_err_undr; /* Slave FIFO underrun error occurred.                                                                                    */
                                                                /* Data is lost and the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr.                                         */
                                                                /* Clearing the slave FIFO will also clear this read-only status bit.                                                     */
  unsigned int bus_master     : BFW_NX90_i2c_sr_bus_master;     /* Bus arbitration state.                                                                                                 */
                                                                /* 0: Master lost I2C bus arbitration, bus is busy by another master.                                                     */
                                                                /* 1: Master gains I2C bus arbitration or bus is idle.                                                                    */
                                                                /* This read-only status bit is set when the monitored bus state does not match the bus                                   */
                                                                /* state expected by the I2C module. The bit is reset, when a STOP is detected.                                           */
                                                                /* This detection will also take place while the module is disabled. This is important if there are multiple              */
                                                                /* I2C masters on the bus: If another master occupies the bus while the I2C module is disabled, the                       */
                                                                /* I2C module must not start a transfer, before the other master has released the bus.                                    */
                                                                /* Use bit i2c_mcr.rst_i2c to force this bit to '0', e.g. in order to escape from an arbitration loss                     */
                                                                /* not followed by a STOP.                                                                                                */
  unsigned int nwr            : BFW_NX90_i2c_sr_nwr;            /* Transfer direction detected after last (r)START.                                                                       */
                                                                /* 0: The last start-byte defined a write transfer.                                                                       */
                                                                /* 1: The last start-byte defined a read transfer.                                                                        */
                                                                /* This read-only status bit is always reset to 0 during (r)START.                                                        */
                                                                /* This bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic.                  */
                                                                /* Note: This bit does not depend on whether the start-byte has been acknowledged or not.                                 */
  unsigned int started        : BFW_NX90_i2c_sr_started;        /* START condition detection:                                                                                             */
                                                                /* 0: The bus is idle (STOP was detected, not started).                                                                   */
                                                                /* 1: (r)START was detected on the bus. The bus is occupied.                                                              */
                                                                /* This detection will also take place while the module is disabled. This is important if there are multiple              */
                                                                /* I2C masters on the bus: If another master occupies the bus while the I2C module is disabled, the                       */
                                                                /* I2C module must not start a transfer, before the other master has released the bus.                                    */
                                                                /* Use bit i2c_mcr.rst_i2c to force this read-only status bit to '0', e.g. in order to escape from an accidentally        */
                                                                /* detected START or a START that is not followed by a STOP.                                                              */
  unsigned int slave_access   : BFW_NX90_i2c_sr_slave_access;   /* Slave access state.                                                                                                    */
                                                                /* 0: No slave access to this device.                                                                                     */
                                                                /* 1: A master addressed this slave device.                                                                               */
                                                                /* This read-only status bit is set if a start-byte (2 bytes for 10-bit address) containing the                           */
                                                                /* address programmed in register i2c_scr.sid has been received.                                                          */
                                                                /* This bit is always reset to 0 during START or STOP.                                                                    */
                                                                /* This bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic.                  */
                                                                /* Note: This bit does not depend on whether the start-byte has been acknowledged or not.                                 */
  unsigned int last_ac        : BFW_NX90_i2c_sr_last_ac;        /* Last acknowledge detected on bus.                                                                                      */
                                                                /* 0: SDA was high at the last acknowledge, i.e. no acknowledge.                                                          */
                                                                /* 1: SDA was low at the last acknowledge, i.e. acknowledge.                                                              */
                                                                /* This read-only status bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. */
  unsigned int nwr_aced       : BFW_NX90_i2c_sr_nwr_aced;       /* Transfer direction (nwr-bit) of the last acknowledged start-byte (or 2-byte start sequence for 10-bit addressing).     */
                                                                /* 0: The last acknowledged start-byte defined a write transfer.                                                          */
                                                                /* 1: The last acknowledged start-byte defined a read transfer.                                                           */
                                                                /* Slave FIFO requests generating IRQ and DMA requests depend on this direction flag.                                     */
                                                                /* This read-only status bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. */
  unsigned int gcall_aced     : BFW_NX90_i2c_sr_gcall_aced;     /* General call acknowledge state.                                                                                        */
                                                                /* 0: No general call start-byte, or general call start-byte was not acknowledged.                                        */
                                                                /* 1: The slave side of the i2c module received and acknowledged a general call.                                          */
                                                                /* Bit i2c_scr.ac_gcall controls the acknowledging of a general call.                                                     */
                                                                /* This read-only status bit will be cleared automatically if the last start-byte is not a general                        */
                                                                /* call or if it is a general call but bit i2c_scr.ac_gcall is not set.                                                   */
                                                                /* This bit is forced to '0' when the bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic.              */
                                                                /* Note: The bit has no function for the master side of the i2c module                                                    */
  unsigned int sid10_aced     : BFW_NX90_i2c_sr_sid10_aced;     /* 10-bit slave address acknowledge state.                                                                                */
                                                                /* {  |                                                                                                                   */
                                                                /*  0: There was no 10-bit slave address or it was not acknowledged.                                                      */
                                                                /*  1: A 10-bit slave address was broadcasted and a slave acknowledged this broadcast.                                    */
                                                                /*     I.e. for the master side: A 10-bit slave was addressed and the slave acknowledged.                                 */
                                                                /*     I.e. for the slave side: A master broadcasted a start with the address programmed in register i2c_scr.sid          */
                                                                /*     and the i2c module acknowledged this broadcast as bit i2c_scr.ac_start is set.}                                    */
                                                                /* This read-only status bit is cleared automatically when the module detects a STOP or when register i2c_mcr             */
                                                                /* is written (e.g. to perform a module reset by bit i2c_mcr.rst_i2c or to address another                                */
                                                                /* slave by changing the bits i2c_mcr.sadr).                                                                              */
                                                                /* Remember that during rSTART, the master will generate only the first START-byte.                                       */
  unsigned int timeout        : BFW_NX90_i2c_sr_timeout;        /* I2C command timeout detection (for I2C master).                                                                        */
                                                                /* I2C slaves can stretch low SCL phases by holding the SCL line low. The master must detect this and                     */
                                                                /* wait until the SCL line is released before the current transfer can continue. In error cases,                          */
                                                                /* the I2C bus can be blocked permanently by a low signal state of SCL. The reason for the blocking can                   */
                                                                /* be e.g. a crashed I2C slave or a false I/O configuration. To escape from such a situation,                             */
                                                                /* a timeout watchdog is implemented:                                                                                     */
                                                                /* A timeout will be detected if the SCL line is held low for more than 256 SCL periods. In                               */
                                                                /* this case, the recent command will be terminated and IRQ cmd_err will be set. The                                      */
                                                                /* timeout detection must be enabled by bit i2c_mcr.en_timeout. It is                                                     */
                                                                /* disabled by default for backward compatibility. However, enabling is strongly recommended.                             */
                                                                /* If timeout is detected, the status bit must be cleared before a new command can be applied.                            */
                                                                /* This status bit can be cleared by writing a '1' to it or                                                               */
                                                                /* when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic.                                            */
  unsigned int reserved3      : BFW_NX90_i2c_sr_reserved3;      /* reserved                                                                                                               */
  unsigned int scl_state      : BFW_NX90_i2c_sr_scl_state;      /* SCL signal state sampled and filtered from bus (e.g. to detect bus blockings)                                          */
                                                                /* This is a read-only status bit.                                                                                        */
  unsigned int sda_state      : BFW_NX90_i2c_sr_sda_state;      /* SDA signal state sampled and filtered from bus (e.g. to detect bus blockings)                                          */
                                                                /* This is a read-only status bit.                                                                                        */
} NX90_I2C_SR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_I2C_SR_BIT_T bf;
} NX90_I2C_SR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_irqmsk */
/* => I2C interrupt mask set or clear register: */
/*    These bits have AND-mask character. The corresponding IRQ will generate the module IRQ only if the mask bit */
/*    is set. Changing a mask bit from '0' to '1' will clear the corresponding raw IRQ state. For a detailed IRQ */
/*    description, see i2c_irqraw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_irqmsk          0x00000020U
#define Adr_NX90_i2c_app_i2c_irqmsk      0xFF8010A0U
#define Adr_NX90_i2c_xpic_app_i2c_irqmsk 0xFF900360U
#define DFLT_VAL_NX90_i2c_irqmsk         0x00000000U

#define MSK_NX90_i2c_irqmsk_cmd_ok            0x00000001U
#define SRT_NX90_i2c_irqmsk_cmd_ok            0
#define DFLT_VAL_NX90_i2c_irqmsk_cmd_ok       0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqmsk_cmd_ok    0x00000000U
#define MSK_NX90_i2c_irqmsk_cmd_err           0x00000002U
#define SRT_NX90_i2c_irqmsk_cmd_err           1
#define DFLT_VAL_NX90_i2c_irqmsk_cmd_err      0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqmsk_cmd_err   0x00000000U
#define MSK_NX90_i2c_irqmsk_fifo_err          0x00000004U
#define SRT_NX90_i2c_irqmsk_fifo_err          2
#define DFLT_VAL_NX90_i2c_irqmsk_fifo_err     0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqmsk_fifo_err  0x00000000U
#define MSK_NX90_i2c_irqmsk_bus_busy          0x00000008U
#define SRT_NX90_i2c_irqmsk_bus_busy          3
#define DFLT_VAL_NX90_i2c_irqmsk_bus_busy     0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqmsk_bus_busy  0x00000000U
#define MSK_NX90_i2c_irqmsk_mfifo_req         0x00000010U
#define SRT_NX90_i2c_irqmsk_mfifo_req         4
#define DFLT_VAL_NX90_i2c_irqmsk_mfifo_req    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqmsk_mfifo_req 0x00000000U
#define MSK_NX90_i2c_irqmsk_sfifo_req         0x00000020U
#define SRT_NX90_i2c_irqmsk_sfifo_req         5
#define DFLT_VAL_NX90_i2c_irqmsk_sfifo_req    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqmsk_sfifo_req 0x00000000U
#define MSK_NX90_i2c_irqmsk_sreq              0x00000040U
#define SRT_NX90_i2c_irqmsk_sreq              6
#define DFLT_VAL_NX90_i2c_irqmsk_sreq         0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqmsk_sreq      0x00000000U

/* all used bits of 'NX90_i2c_irqmsk': */
#define MSK_USED_BITS_NX90_i2c_irqmsk 0x0000007fU

enum {
  BFW_NX90_i2c_irqmsk_cmd_ok    = 1,  /* [0] */
  BFW_NX90_i2c_irqmsk_cmd_err   = 1,  /* [1] */
  BFW_NX90_i2c_irqmsk_fifo_err  = 1,  /* [2] */
  BFW_NX90_i2c_irqmsk_bus_busy  = 1,  /* [3] */
  BFW_NX90_i2c_irqmsk_mfifo_req = 1,  /* [4] */
  BFW_NX90_i2c_irqmsk_sfifo_req = 1,  /* [5] */
  BFW_NX90_i2c_irqmsk_sreq      = 1,  /* [6] */
  BFW_NX90_i2c_irqmsk_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_I2C_IRQMSK_BIT_Ttag {
  unsigned int cmd_ok    : BFW_NX90_i2c_irqmsk_cmd_ok;    /* Command OK interrupt mask                 */
  unsigned int cmd_err   : BFW_NX90_i2c_irqmsk_cmd_err;   /* Command error interrupt mask              */
  unsigned int fifo_err  : BFW_NX90_i2c_irqmsk_fifo_err;  /* FIFO error interrupt mask                 */
  unsigned int bus_busy  : BFW_NX90_i2c_irqmsk_bus_busy;  /* External I2C-bus is busy interrupt mask   */
  unsigned int mfifo_req : BFW_NX90_i2c_irqmsk_mfifo_req; /* Master FIFO action request interrupt mask */
  unsigned int sfifo_req : BFW_NX90_i2c_irqmsk_sfifo_req; /* Slave FIFO action request interrupt mask  */
  unsigned int sreq      : BFW_NX90_i2c_irqmsk_sreq;      /* Slave request interrupt mask              */
  unsigned int reserved1 : BFW_NX90_i2c_irqmsk_reserved1; /* reserved                                  */
} NX90_I2C_IRQMSK_BIT_T;

typedef union {
  uint32_t              val;
  NX90_I2C_IRQMSK_BIT_T bf;
} NX90_I2C_IRQMSK_T;

/* --------------------------------------------------------------------- */
/* Register i2c_irqsr */
/* => I2C interrupt state register (raw interrupt before masking): */
/*    Writing '1' will clear the corresponding IRQ. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_irqsr          0x00000024U
#define Adr_NX90_i2c_app_i2c_irqsr      0xFF8010A4U
#define Adr_NX90_i2c_xpic_app_i2c_irqsr 0xFF900364U
#define DFLT_VAL_NX90_i2c_irqsr         0x00000000U

#define MSK_NX90_i2c_irqsr_cmd_ok            0x00000001U
#define SRT_NX90_i2c_irqsr_cmd_ok            0
#define DFLT_VAL_NX90_i2c_irqsr_cmd_ok       0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqsr_cmd_ok    0x00000000U
#define MSK_NX90_i2c_irqsr_cmd_err           0x00000002U
#define SRT_NX90_i2c_irqsr_cmd_err           1
#define DFLT_VAL_NX90_i2c_irqsr_cmd_err      0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqsr_cmd_err   0x00000000U
#define MSK_NX90_i2c_irqsr_fifo_err          0x00000004U
#define SRT_NX90_i2c_irqsr_fifo_err          2
#define DFLT_VAL_NX90_i2c_irqsr_fifo_err     0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqsr_fifo_err  0x00000000U
#define MSK_NX90_i2c_irqsr_bus_busy          0x00000008U
#define SRT_NX90_i2c_irqsr_bus_busy          3
#define DFLT_VAL_NX90_i2c_irqsr_bus_busy     0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqsr_bus_busy  0x00000000U
#define MSK_NX90_i2c_irqsr_mfifo_req         0x00000010U
#define SRT_NX90_i2c_irqsr_mfifo_req         4
#define DFLT_VAL_NX90_i2c_irqsr_mfifo_req    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqsr_mfifo_req 0x00000000U
#define MSK_NX90_i2c_irqsr_sfifo_req         0x00000020U
#define SRT_NX90_i2c_irqsr_sfifo_req         5
#define DFLT_VAL_NX90_i2c_irqsr_sfifo_req    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqsr_sfifo_req 0x00000000U
#define MSK_NX90_i2c_irqsr_sreq              0x00000040U
#define SRT_NX90_i2c_irqsr_sreq              6
#define DFLT_VAL_NX90_i2c_irqsr_sreq         0x00000000U
#define DFLT_BF_VAL_NX90_i2c_irqsr_sreq      0x00000000U

/* all used bits of 'NX90_i2c_irqsr': */
#define MSK_USED_BITS_NX90_i2c_irqsr 0x0000007fU

enum {
  BFW_NX90_i2c_irqsr_cmd_ok    = 1,  /* [0] */
  BFW_NX90_i2c_irqsr_cmd_err   = 1,  /* [1] */
  BFW_NX90_i2c_irqsr_fifo_err  = 1,  /* [2] */
  BFW_NX90_i2c_irqsr_bus_busy  = 1,  /* [3] */
  BFW_NX90_i2c_irqsr_mfifo_req = 1,  /* [4] */
  BFW_NX90_i2c_irqsr_sfifo_req = 1,  /* [5] */
  BFW_NX90_i2c_irqsr_sreq      = 1,  /* [6] */
  BFW_NX90_i2c_irqsr_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_I2C_IRQSR_BIT_Ttag {
  unsigned int cmd_ok    : BFW_NX90_i2c_irqsr_cmd_ok;    /* Unmasked command OK interrupt state:                                                                              */
                                                         /* Purpose: Check last command termination                                                                           */
                                                         /* 1: Last command finished successfully                                                                             */
                                                         /* 0: Command not finished, no command or command finished erroneously                                               */
  unsigned int cmd_err   : BFW_NX90_i2c_irqsr_cmd_err;   /* Unmasked command error interrupt state:                                                                           */
                                                         /* Purpose: Check last command termination                                                                           */
                                                         /* 1: Last command finished erroneously                                                                              */
                                                         /* 0: Command not finished, no command or command finished successfully                                              */
  unsigned int fifo_err  : BFW_NX90_i2c_irqsr_fifo_err;  /* Unmasked FIFO error interrupt state:                                                                              */
                                                         /* Purpose: Detect FIFO errors/transfer failures                                                                     */
                                                         /* 1: FIFO error occurred, check register i2c_sr                                                                     */
                                                         /* 0: FIFOs ok                                                                                                       */
  unsigned int bus_busy  : BFW_NX90_i2c_irqsr_bus_busy;  /* Unmasked external I2C-bus is busy interrupt state:                                                                */
                                                         /* Purpose: Detect I2C-bus arbitration loss                                                                          */
                                                         /* 1: Master did not gain the requested bus access because another master accessed the bus                           */
                                                         /* 0: Bus is idle or no transfer is requested by this master                                                         */
  unsigned int mfifo_req : BFW_NX90_i2c_irqsr_mfifo_req; /* Unmasked master FIFO action request interrupt state:                                                              */
                                                         /* Purpose: Master FIFO should be updated                                                                            */
                                                         /* 1: Master FIFO request: i2c_sr.mfifo_level is above or below i2c_mfifo_cr.mfifo_wm (see description i2c_mfifo_cr) */
                                                         /* 0: Master FIFO state not critical                                                                                 */
  unsigned int sfifo_req : BFW_NX90_i2c_irqsr_sfifo_req; /* Unmasked slave FIFO action request interrupt state:                                                               */
                                                         /* Purpose: Slave FIFO should be updated                                                                             */
                                                         /* 1: Slave FIFO request: i2c_sr.sfifo_level is above or below i2c_sfifo_cr.sfifo_wm (see description i2c_sfifo_cr)  */
                                                         /* 0: Slave FIFO state not critical                                                                                  */
  unsigned int sreq      : BFW_NX90_i2c_irqsr_sreq;      /* Unmasked slave request interrupt state:                                                                           */
                                                         /* Purpose: Set up slave FIFO                                                                                        */
                                                         /* 1: External master was running START-sequence and requested this slave                                            */
                                                         /* 0: Slave is not requested                                                                                         */
  unsigned int reserved1 : BFW_NX90_i2c_irqsr_reserved1; /* reserved                                                                                                          */
} NX90_I2C_IRQSR_BIT_T;

typedef union {
  uint32_t             val;
  NX90_I2C_IRQSR_BIT_T bf;
} NX90_I2C_IRQSR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_irqmsked */
/* => I2C masked interrupt state register: */
/*    If one of these bits is set, the I2C IRQ will be set to the interrupt controller. */
/*    For a detailed IRQ description, see i2c_irqraw. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_irqmsked          0x00000028U
#define Adr_NX90_i2c_app_i2c_irqmsked      0xFF8010A8U
#define Adr_NX90_i2c_xpic_app_i2c_irqmsked 0xFF900368U

#define MSK_NX90_i2c_irqmsked_cmd_ok    0x00000001U
#define SRT_NX90_i2c_irqmsked_cmd_ok    0
#define MSK_NX90_i2c_irqmsked_cmd_err   0x00000002U
#define SRT_NX90_i2c_irqmsked_cmd_err   1
#define MSK_NX90_i2c_irqmsked_fifo_err  0x00000004U
#define SRT_NX90_i2c_irqmsked_fifo_err  2
#define MSK_NX90_i2c_irqmsked_bus_busy  0x00000008U
#define SRT_NX90_i2c_irqmsked_bus_busy  3
#define MSK_NX90_i2c_irqmsked_mfifo_req 0x00000010U
#define SRT_NX90_i2c_irqmsked_mfifo_req 4
#define MSK_NX90_i2c_irqmsked_sfifo_req 0x00000020U
#define SRT_NX90_i2c_irqmsked_sfifo_req 5
#define MSK_NX90_i2c_irqmsked_sreq      0x00000040U
#define SRT_NX90_i2c_irqmsked_sreq      6

/* all used bits of 'NX90_i2c_irqmsked': */
#define MSK_USED_BITS_NX90_i2c_irqmsked 0x0000007fU

enum {
  BFW_NX90_i2c_irqmsked_cmd_ok    = 1,  /* [0] */
  BFW_NX90_i2c_irqmsked_cmd_err   = 1,  /* [1] */
  BFW_NX90_i2c_irqmsked_fifo_err  = 1,  /* [2] */
  BFW_NX90_i2c_irqmsked_bus_busy  = 1,  /* [3] */
  BFW_NX90_i2c_irqmsked_mfifo_req = 1,  /* [4] */
  BFW_NX90_i2c_irqmsked_sfifo_req = 1,  /* [5] */
  BFW_NX90_i2c_irqmsked_sreq      = 1,  /* [6] */
  BFW_NX90_i2c_irqmsked_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_I2C_IRQMSKED_BIT_Ttag {
  unsigned int cmd_ok    : BFW_NX90_i2c_irqmsked_cmd_ok;    /* Masked command OK interrupt state                 */
  unsigned int cmd_err   : BFW_NX90_i2c_irqmsked_cmd_err;   /* Masked command error interrupt state              */
  unsigned int fifo_err  : BFW_NX90_i2c_irqmsked_fifo_err;  /* Masked FIFO error interrupt state                 */
  unsigned int bus_busy  : BFW_NX90_i2c_irqmsked_bus_busy;  /* Masked external I2C-bus is busy interrupt state   */
  unsigned int mfifo_req : BFW_NX90_i2c_irqmsked_mfifo_req; /* Masked master FIFO action request interrupt state */
  unsigned int sfifo_req : BFW_NX90_i2c_irqmsked_sfifo_req; /* Masked slave FIFO action request interrupt state  */
  unsigned int sreq      : BFW_NX90_i2c_irqmsked_sreq;      /* Masked slave request interrupt state              */
  unsigned int reserved1 : BFW_NX90_i2c_irqmsked_reserved1; /* reserved                                          */
} NX90_I2C_IRQMSKED_BIT_T;

typedef union {
  uint32_t                val;
  NX90_I2C_IRQMSKED_BIT_T bf;
} NX90_I2C_IRQMSKED_T;

/* --------------------------------------------------------------------- */
/* Register i2c_dmacr */
/* => I2C DMA control register: */
/*    Required settings for the DMA controller: */
/*    - DMA transfer size to/from I2C module: Byte */
/*    - DMA burst length to/from I2C module: 4 */
/*    DMA burst requests will be generated if the corresponding FIFO contains more than 4 bytes (receive case) or if */
/*    more than 4 bytes are writable to the corresponding FIFO (transmit case). */
/*    DMA single transfer requests will be generated if the corresponding FIFO contains more than 1 byte (receive case) or if */
/*    more than 1 byte is writable to the corresponding FIFO (transmit case). */
/*    No further DMA requests will be generated if all transmit data is written to the master FIFO and the i2c module is */
/*    the DMA flow controller (for master data only). Once all data is written */
/*    to the master FIFO, the last burst/single request will be generated for the DMA controller. */
/*    If the DMA controller sets DMACTC (terminal count) to indicate the end of transfer, the corresponding bit will be cleared. */
/*    If one of the bits of this register is set to 0 by software and a DMA transfer has been requested before, the DMA controller */
/*    will perform one last transfer to reset DMA request signals. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_dmacr          0x0000002CU
#define Adr_NX90_i2c_app_i2c_dmacr      0xFF8010ACU
#define Adr_NX90_i2c_xpic_app_i2c_dmacr 0xFF90036CU
#define DFLT_VAL_NX90_i2c_dmacr         0x00000000U

#define MSK_NX90_i2c_dmacr_mdmas_en         0x00000001U
#define SRT_NX90_i2c_dmacr_mdmas_en         0
#define DFLT_VAL_NX90_i2c_dmacr_mdmas_en    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_dmacr_mdmas_en 0x00000000U
#define MSK_NX90_i2c_dmacr_mdmab_en         0x00000002U
#define SRT_NX90_i2c_dmacr_mdmab_en         1
#define DFLT_VAL_NX90_i2c_dmacr_mdmab_en    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_dmacr_mdmab_en 0x00000000U
#define MSK_NX90_i2c_dmacr_sdmas_en         0x00000004U
#define SRT_NX90_i2c_dmacr_sdmas_en         2
#define DFLT_VAL_NX90_i2c_dmacr_sdmas_en    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_dmacr_sdmas_en 0x00000000U
#define MSK_NX90_i2c_dmacr_sdmab_en         0x00000008U
#define SRT_NX90_i2c_dmacr_sdmab_en         3
#define DFLT_VAL_NX90_i2c_dmacr_sdmab_en    0x00000000U
#define DFLT_BF_VAL_NX90_i2c_dmacr_sdmab_en 0x00000000U

/* all used bits of 'NX90_i2c_dmacr': */
#define MSK_USED_BITS_NX90_i2c_dmacr 0x0000000fU

enum {
  BFW_NX90_i2c_dmacr_mdmas_en  = 1,  /* [0] */
  BFW_NX90_i2c_dmacr_mdmab_en  = 1,  /* [1] */
  BFW_NX90_i2c_dmacr_sdmas_en  = 1,  /* [2] */
  BFW_NX90_i2c_dmacr_sdmab_en  = 1,  /* [3] */
  BFW_NX90_i2c_dmacr_reserved1 = 28  /* [31:4] */
};

typedef struct NX90_I2C_DMACR_BIT_Ttag {
  unsigned int mdmas_en  : BFW_NX90_i2c_dmacr_mdmas_en;  /* Enable DMA single requests for I2C master data.                                  */
                                                         /* The I2C module is the flow controller (i.e. peripheral-controlled flow control). */
                                                         /* Both, single and burst requests must be enabled.                                 */
                                                         /* This bit is writable, but can also be changed by hardware.                       */
  unsigned int mdmab_en  : BFW_NX90_i2c_dmacr_mdmab_en;  /* Enable DMA burst requests for I2C master data.                                   */
                                                         /* The I2C module is the flow controller (i.e. peripheral-controlled flow control). */
                                                         /* Both, single and burst requests must be enabled.                                 */
                                                         /* This bit is writable, but can also be changed by hardware.                       */
  unsigned int sdmas_en  : BFW_NX90_i2c_dmacr_sdmas_en;  /* Enable DMA single requests for I2C slave data.                                   */
                                                         /* The DMA controller must be the flow controller.                                  */
                                                         /* This bit is writable, but can also be changed by hardware.                       */
  unsigned int sdmab_en  : BFW_NX90_i2c_dmacr_sdmab_en;  /* Enable DMA burst requests for I2C slave data.                                    */
                                                         /* The DMA controller must be the flow controller.                                  */
                                                         /* This bit is writable, but can also be changed by hardware.                       */
  unsigned int reserved1 : BFW_NX90_i2c_dmacr_reserved1; /* reserved                                                                         */
} NX90_I2C_DMACR_BIT_T;

typedef union {
  uint32_t             val;
  NX90_I2C_DMACR_BIT_T bf;
} NX90_I2C_DMACR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_pio */
/* => PIO mode register: */
/*    This register can directly control the I2C signals SCL and SDA if pio_mode is enabled in register i2c_mcr. In PIO mode, the */
/*    I2C controller state machine is disabled, thus, no FIFO action takes place, no IRQs will be set, and no DMA-controlling is possible. */
/*    Note: To avoid external driving conflicts, the I2C signals SCL and SDA are never driven active-high according to */
/*    the I2C bus specification. The high level of these signals is realized by a pull-up (of the pad or externally) \ */
/*    and by setting the appropriate output enable to 0 (scl_oe, sda_oe) instead of driving the level */
/*    active-high. Driving the signals directly by enabling the outputs (programming */
/*    the bits sda_oe or scl_oe to '1') can lead to driving conflicts and could cause damage. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_i2c_pio          0x00000030U
#define Adr_NX90_i2c_app_i2c_pio      0xFF8010B0U
#define Adr_NX90_i2c_xpic_app_i2c_pio 0xFF900370U
#define DFLT_VAL_NX90_i2c_pio         0x00000044U

#define MSK_NX90_i2c_pio_scl_out           0x00000001U
#define SRT_NX90_i2c_pio_scl_out           0
#define DFLT_VAL_NX90_i2c_pio_scl_out      0x00000000U
#define DFLT_BF_VAL_NX90_i2c_pio_scl_out   0x00000000U
#define MSK_NX90_i2c_pio_scl_oe            0x00000002U
#define SRT_NX90_i2c_pio_scl_oe            1
#define DFLT_VAL_NX90_i2c_pio_scl_oe       0x00000000U
#define DFLT_BF_VAL_NX90_i2c_pio_scl_oe    0x00000000U
#define MSK_NX90_i2c_pio_scl_in_ro         0x00000004U
#define SRT_NX90_i2c_pio_scl_in_ro         2
#define DFLT_VAL_NX90_i2c_pio_scl_in_ro    0x00000004U
#define DFLT_BF_VAL_NX90_i2c_pio_scl_in_ro 0x00000001U
#define MSK_NX90_i2c_pio_sda_out           0x00000010U
#define SRT_NX90_i2c_pio_sda_out           4
#define DFLT_VAL_NX90_i2c_pio_sda_out      0x00000000U
#define DFLT_BF_VAL_NX90_i2c_pio_sda_out   0x00000000U
#define MSK_NX90_i2c_pio_sda_oe            0x00000020U
#define SRT_NX90_i2c_pio_sda_oe            5
#define DFLT_VAL_NX90_i2c_pio_sda_oe       0x00000000U
#define DFLT_BF_VAL_NX90_i2c_pio_sda_oe    0x00000000U
#define MSK_NX90_i2c_pio_sda_in_ro         0x00000040U
#define SRT_NX90_i2c_pio_sda_in_ro         6
#define DFLT_VAL_NX90_i2c_pio_sda_in_ro    0x00000040U
#define DFLT_BF_VAL_NX90_i2c_pio_sda_in_ro 0x00000001U

/* all used bits of 'NX90_i2c_pio': */
#define MSK_USED_BITS_NX90_i2c_pio 0x00000077U

enum {
  BFW_NX90_i2c_pio_scl_out   = 1,  /* [0] */
  BFW_NX90_i2c_pio_scl_oe    = 1,  /* [1] */
  BFW_NX90_i2c_pio_scl_in_ro = 1,  /* [2] */
  BFW_NX90_i2c_pio_reserved1 = 1,  /* [3] */
  BFW_NX90_i2c_pio_sda_out   = 1,  /* [4] */
  BFW_NX90_i2c_pio_sda_oe    = 1,  /* [5] */
  BFW_NX90_i2c_pio_sda_in_ro = 1,  /* [6] */
  BFW_NX90_i2c_pio_reserved2 = 25  /* [31:7] */
};

typedef struct NX90_I2C_PIO_BIT_Ttag {
  unsigned int scl_out   : BFW_NX90_i2c_pio_scl_out;   /* Driving level of SCL (1: high, 0: low) if output is enabled (scl_oe is set) */
  unsigned int scl_oe    : BFW_NX90_i2c_pio_scl_oe;    /* SCL output enable                                                           */
                                                       /* 0: Do not drive SCL, switch pad to high-z.                                  */
                                                       /* 1: Drive SCL, switch pad to programmed scl_out-state                        */
  unsigned int scl_in_ro : BFW_NX90_i2c_pio_scl_in_ro; /* SCL input state (read-only)                                                 */
  unsigned int reserved1 : BFW_NX90_i2c_pio_reserved1; /* reserved                                                                    */
  unsigned int sda_out   : BFW_NX90_i2c_pio_sda_out;   /* Driving level of SDA (1: high, 0: low) if output is enabled (sda_oe is set) */
  unsigned int sda_oe    : BFW_NX90_i2c_pio_sda_oe;    /* SDA output enable                                                           */
                                                       /* 0: Do not drive SDA, switch pad to high-z.                                  */
                                                       /* 1: Drive SDA, switch pad to programmed sda_out-state                        */
  unsigned int sda_in_ro : BFW_NX90_i2c_pio_sda_in_ro; /* SDA input state (read-only)                                                 */
  unsigned int reserved2 : BFW_NX90_i2c_pio_reserved2; /* reserved                                                                    */
} NX90_I2C_PIO_BIT_T;

typedef union {
  uint32_t           val;
  NX90_I2C_PIO_BIT_T bf;
} NX90_I2C_PIO_T;


/* ===================================================================== */

/* Area of mled_ctrl_app */

/* ===================================================================== */

#define Addr_NX90_mled_ctrl_app 0xFF801100U

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_cfg */
/* => Global configuration register. */
/*    This register controls global configuration options for all Multi-LED outputs. */
/*    Description of Multi-LED control module operation: */
/*    a) Time-multiplexed PWM mode: */
/*    Each output drives two LEDs: Low-side and high-side LED. Three states of the output pin are possible: \ */
/*    High (i.e. the low-side LED is on), low (i.e. the high-side LED is on), or high-z (i.e. both LEDs are off). */
/*    The PWM period, determined by bit field prescale_counter_max, is the same for all outputs. The prescale \ */
/*    counter will be increased by the netX system clock (i.e. 100 MHz). A second counter (the PWM counter) will be */
/*    increased when the prescale counter reaches its configured max. value. The PWM counter is a \ */
/*    fixed-width counter and always counts from 0 to 511. */
/*    If the PWM counter is in the range of 0 - 255, the high-side LED will be driven depending on the configured \ */
/*    switch-on time (registers on_time[x], with x being an even number). The output pin will be driven low when the high-side \ */
/*    phase starts. If the PWM counter reaches on_time[x] - 1, the output pin will switch to high-z state. */
/*    If the PWM counter is in the range of 256 - 511, the low-side LED will be driven depending on the configured \ */
/*    switch-on time (registers on_time[y], with y being an odd number). The output pin will be driven high when the low-side \ */
/*    phase starts. If the PWM counter reaches 256 + on_time[y] - 1, the output pin will switch to high-z state. */
/*    The state of an LED depends on the input value selected by the input multiplexer. For a list of \ */
/*    selectable signals, see register mled_ctrl_output_sel[0]. When the selected input signal is off, the \ */
/*    output signal will be high-z during the entire corresponding PWM phase. */
/*     */
/*    b) Pass-through mode: */
/*    This mode disables the time-multiplexed PWM entirely and a configured signal will be output directly or \ */
/*    inverted (delayed by one netX system cycle). This mode will be used when all bits of bit field sel of the \ */
/*    output phase 0 configuration register (high-side LED) are set to '1'. The input signal (and inversion) \ */
/*    is selected by the corresponding phase 1 configuration register (low-side LED). The output can be configured \ */
/*    to high-z state if the corresponding phase 1 on_time register is set to '0', therefore it must be set != '0' for \ */
/*    regular pass-through operation (i.e. the output will be driven high or low depending on the input signal). */
/*     */
/*    c) Multi-LED internal blink generator: */
/*    The blink signal synchronizes the blinking of several LEDs. Bit field blink_counter_max determines the blink \ */
/*    frequency which is the same for all outputs configured to blink mode. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_cfg           0x00000000U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_cfg 0xFF801100U
#define Adr_NX90_mled_ctrl_app_cfg               0xFF801100U
#define DFLT_VAL_NX90_mled_ctrl_app_cfg          0x00018ffeU

#define MSK_NX90_mled_ctrl_app_cfg_enable                       0x00000001U
#define SRT_NX90_mled_ctrl_app_cfg_enable                       0
#define DFLT_VAL_NX90_mled_ctrl_app_cfg_enable                  0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_cfg_enable               0x00000000U
#define MSK_NX90_mled_ctrl_app_cfg_prescale_counter_max         0x000007feU
#define SRT_NX90_mled_ctrl_app_cfg_prescale_counter_max         1
#define DFLT_VAL_NX90_mled_ctrl_app_cfg_prescale_counter_max    0x000007feU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_cfg_prescale_counter_max 0x000003ffU
#define MSK_NX90_mled_ctrl_app_cfg_blink_counter_max            0x000ff800U
#define SRT_NX90_mled_ctrl_app_cfg_blink_counter_max            11
#define DFLT_VAL_NX90_mled_ctrl_app_cfg_blink_counter_max       0x00018800U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_cfg_blink_counter_max    0x00000031U

/* all used bits of 'NX90_mled_ctrl_app_cfg': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_cfg 0x000fffffU

enum {
  BFW_NX90_mled_ctrl_app_cfg_enable               = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_cfg_prescale_counter_max = 10, /* [10:1] */
  BFW_NX90_mled_ctrl_app_cfg_blink_counter_max    = 9,  /* [19:11] */
  BFW_NX90_mled_ctrl_app_cfg_reserved1            = 12  /* [31:20] */
};

typedef struct NX90_MLED_CTRL_APP_CFG_BIT_Ttag {
  unsigned int enable               : BFW_NX90_mled_ctrl_app_cfg_enable;               /* Writing a '1' to this bit will enable the MLED_CTRL_APP module.          */
                                                                                       /* When disabled, all counters will be stopped to save power and outputs    */
                                                                                       /* will be switched to high-z state.                                        */
  unsigned int prescale_counter_max : BFW_NX90_mled_ctrl_app_cfg_prescale_counter_max; /* Maximum value the prescale counter will count to.                        */
                                                                                       /* The prescale counter determines the PWM frequency of all outputs:        */
                                                                                       /* f_pwm = f_clk / (512 * (prescale_counter_max + 1))                       */
                                                                                       /* prescale_counter_max = (f_clk / (512 * f_pwm)) - 1                       */
                                                                                       /* with f_clk = 100 MHz (netX system frequency).                            */
                                                                                       /* The range of the PWM frequency is therefore within ~191 Hz and ~195 kHz. */
  unsigned int blink_counter_max    : BFW_NX90_mled_ctrl_app_cfg_blink_counter_max;    /* Maximum value the blink counter will count to.                           */
                                                                                       /* The blink counter determines the blink frequency:                        */
                                                                                       /* f_blink = 50 Hz / (blink_counter_max + 1)                                */
                                                                                       /* blink_counter_max = (50 Hz / f_blink) - 1.                               */
                                                                                       /* The range of the blink frequency is therefore within ~0.1 Hz and 50 Hz.  */
  unsigned int reserved1            : BFW_NX90_mled_ctrl_app_cfg_reserved1;            /* reserved                                                                 */
} NX90_MLED_CTRL_APP_CFG_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_MLED_CTRL_APP_CFG_BIT_T bf;
} NX90_MLED_CTRL_APP_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel0 */
/* => Output 0 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel0           0x00000004U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel0 0xFF801104U
#define Adr_NX90_mled_ctrl_app_output_sel0               0xFF801104U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel0          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel0_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel0_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel0_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel0_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel0_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel0_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel0_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel0_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel0': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel0 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel0_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel0_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel0_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL0_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel0_inv;       /* Invert input signal.                                                              */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel0_sel;       /* Selection of the signal connected to this output.                                 */
                                                                         /* {        |                                                                        */
                                                                         /*  Value    Input                                                                   */
                                                                         /*  0        always off                                                              */
                                                                         /*  1        line register                                                           */
                                                                         /*  2        MLED_CTRL blink                                                         */
                                                                         /*  3        pass-through (for phase 0 registers) / reserved (for phase 1 registers) */
                                                                         /* }                                                                                 */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel0_reserved1; /* reserved                                                                          */
} NX90_MLED_CTRL_APP_OUTPUT_SEL0_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL0_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL0_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel1 */
/* => Output 0 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel1           0x00000008U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel1 0xFF801108U
#define Adr_NX90_mled_ctrl_app_output_sel1               0xFF801108U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel1          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel1_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel1_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel1_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel1_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel1_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel1_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel1_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel1_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel1': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel1 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel1_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel1_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel1_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL1_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel1_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel1_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel1_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL1_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL1_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL1_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel2 */
/* => Output 1 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel2           0x0000000CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel2 0xFF80110CU
#define Adr_NX90_mled_ctrl_app_output_sel2               0xFF80110CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel2          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel2_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel2_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel2_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel2_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel2_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel2_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel2_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel2_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel2': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel2 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel2_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel2_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel2_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL2_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel2_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel2_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel2_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL2_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL2_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL2_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel3 */
/* => Output 1 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel3           0x00000010U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel3 0xFF801110U
#define Adr_NX90_mled_ctrl_app_output_sel3               0xFF801110U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel3          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel3_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel3_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel3_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel3_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel3_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel3_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel3_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel3_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel3': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel3 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel3_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel3_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel3_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL3_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel3_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel3_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel3_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL3_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL3_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL3_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel4 */
/* => Output 2 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel4           0x00000014U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel4 0xFF801114U
#define Adr_NX90_mled_ctrl_app_output_sel4               0xFF801114U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel4          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel4_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel4_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel4_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel4_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel4_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel4_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel4_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel4_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel4': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel4 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel4_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel4_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel4_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL4_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel4_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel4_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel4_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL4_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL4_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL4_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel5 */
/* => Output 2 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel5           0x00000018U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel5 0xFF801118U
#define Adr_NX90_mled_ctrl_app_output_sel5               0xFF801118U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel5          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel5_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel5_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel5_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel5_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel5_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel5_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel5_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel5_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel5': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel5 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel5_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel5_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel5_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL5_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel5_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel5_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel5_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL5_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL5_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL5_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel6 */
/* => Output 3 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel6           0x0000001CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel6 0xFF80111CU
#define Adr_NX90_mled_ctrl_app_output_sel6               0xFF80111CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel6          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel6_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel6_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel6_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel6_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel6_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel6_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel6_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel6_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel6': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel6 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel6_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel6_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel6_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL6_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel6_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel6_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel6_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL6_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL6_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL6_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel7 */
/* => Output 3 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel7           0x00000020U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel7 0xFF801120U
#define Adr_NX90_mled_ctrl_app_output_sel7               0xFF801120U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel7          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel7_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel7_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel7_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel7_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel7_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel7_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel7_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel7_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel7': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel7 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel7_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel7_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel7_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL7_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel7_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel7_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel7_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL7_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL7_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL7_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel8 */
/* => Output 4 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel8           0x00000024U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel8 0xFF801124U
#define Adr_NX90_mled_ctrl_app_output_sel8               0xFF801124U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel8          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel8_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel8_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel8_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel8_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel8_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel8_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel8_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel8_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel8': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel8 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel8_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel8_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel8_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL8_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel8_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel8_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel8_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL8_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL8_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL8_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel9 */
/* => Output 4 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel9           0x00000028U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel9 0xFF801128U
#define Adr_NX90_mled_ctrl_app_output_sel9               0xFF801128U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel9          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel9_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel9_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel9_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel9_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel9_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel9_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel9_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel9_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel9': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel9 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel9_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel9_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel9_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL9_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel9_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel9_sel;       /* Selection of the signal connected to this output.              */
                                                                         /* For signal to value mapping see 'sel' description of register  */
                                                                         /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel9_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL9_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL9_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL9_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel10 */
/* => Output 5 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel10           0x0000002CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel10 0xFF80112CU
#define Adr_NX90_mled_ctrl_app_output_sel10               0xFF80112CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel10          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel10_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel10_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel10_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel10_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel10_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel10_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel10_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel10_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel10': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel10 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel10_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel10_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel10_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL10_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel10_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel10_sel;       /* Selection of the signal connected to this output.              */
                                                                          /* For signal to value mapping see 'sel' description of register  */
                                                                          /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel10_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL10_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL10_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL10_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel11 */
/* => Output 5 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel11           0x00000030U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel11 0xFF801130U
#define Adr_NX90_mled_ctrl_app_output_sel11               0xFF801130U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel11          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel11_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel11_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel11_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel11_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel11_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel11_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel11_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel11_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel11': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel11 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel11_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel11_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel11_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL11_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel11_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel11_sel;       /* Selection of the signal connected to this output.              */
                                                                          /* For signal to value mapping see 'sel' description of register  */
                                                                          /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel11_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL11_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL11_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL11_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel12 */
/* => Output 6 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel12           0x00000034U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel12 0xFF801134U
#define Adr_NX90_mled_ctrl_app_output_sel12               0xFF801134U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel12          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel12_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel12_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel12_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel12_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel12_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel12_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel12_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel12_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel12': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel12 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel12_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel12_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel12_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL12_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel12_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel12_sel;       /* Selection of the signal connected to this output.              */
                                                                          /* For signal to value mapping see 'sel' description of register  */
                                                                          /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel12_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL12_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL12_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL12_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel13 */
/* => Output 6 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel13           0x00000038U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel13 0xFF801138U
#define Adr_NX90_mled_ctrl_app_output_sel13               0xFF801138U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel13          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel13_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel13_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel13_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel13_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel13_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel13_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel13_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel13_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel13': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel13 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel13_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel13_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel13_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL13_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel13_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel13_sel;       /* Selection of the signal connected to this output.              */
                                                                          /* For signal to value mapping see 'sel' description of register  */
                                                                          /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel13_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL13_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL13_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL13_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel14 */
/* => Output 7 phase 0 (high-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel14           0x0000003CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel14 0xFF80113CU
#define Adr_NX90_mled_ctrl_app_output_sel14               0xFF80113CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel14          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel14_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel14_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel14_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel14_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel14_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel14_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel14_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel14_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel14': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel14 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel14_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel14_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel14_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL14_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel14_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel14_sel;       /* Selection of the signal connected to this output.              */
                                                                          /* For signal to value mapping see 'sel' description of register  */
                                                                          /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel14_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL14_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL14_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL14_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_sel15 */
/* => Output 7 phase 1 (low-side LED) configuration. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_sel15           0x00000040U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_sel15 0xFF801140U
#define Adr_NX90_mled_ctrl_app_output_sel15               0xFF801140U
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel15          0x00000000U

#define MSK_NX90_mled_ctrl_app_output_sel15_inv         0x00000001U
#define SRT_NX90_mled_ctrl_app_output_sel15_inv         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel15_inv    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel15_inv 0x00000000U
#define MSK_NX90_mled_ctrl_app_output_sel15_sel         0x00000006U
#define SRT_NX90_mled_ctrl_app_output_sel15_sel         1
#define DFLT_VAL_NX90_mled_ctrl_app_output_sel15_sel    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_sel15_sel 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_output_sel15': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_sel15 0x00000007U

enum {
  BFW_NX90_mled_ctrl_app_output_sel15_inv       = 1,  /* [0] */
  BFW_NX90_mled_ctrl_app_output_sel15_sel       = 2,  /* [2:1] */
  BFW_NX90_mled_ctrl_app_output_sel15_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_SEL15_BIT_Ttag {
  unsigned int inv       : BFW_NX90_mled_ctrl_app_output_sel15_inv;       /* Invert input signal.                                           */
  unsigned int sel       : BFW_NX90_mled_ctrl_app_output_sel15_sel;       /* Selection of the signal connected to this output.              */
                                                                          /* For signal to value mapping see 'sel' description of register  */
                                                                          /* 'mled_ctrl_app_output_sel0'.                                   */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_sel15_reserved1; /* reserved                                                       */
} NX90_MLED_CTRL_APP_OUTPUT_SEL15_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_MLED_CTRL_APP_OUTPUT_SEL15_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_SEL15_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time0 */
/* => Output 0 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time0           0x00000044U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time0 0xFF801144U
#define Adr_NX90_mled_ctrl_app_output_on_time0               0xFF801144U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time0          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time0_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time0_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time0_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time0_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time0': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time0 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time0_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time0_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME0_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time0_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time0_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME0_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME0_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME0_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time1 */
/* => Output 0 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time1           0x00000048U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time1 0xFF801148U
#define Adr_NX90_mled_ctrl_app_output_on_time1               0xFF801148U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time1          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time1_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time1_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time1_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time1_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time1': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time1 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time1_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time1_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME1_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time1_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time1_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME1_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME1_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME1_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time2 */
/* => Output 1 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time2           0x0000004CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time2 0xFF80114CU
#define Adr_NX90_mled_ctrl_app_output_on_time2               0xFF80114CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time2          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time2_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time2_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time2_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time2_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time2': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time2 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time2_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time2_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME2_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time2_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time2_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME2_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME2_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME2_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time3 */
/* => Output 1 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time3           0x00000050U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time3 0xFF801150U
#define Adr_NX90_mled_ctrl_app_output_on_time3               0xFF801150U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time3          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time3_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time3_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time3_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time3_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time3': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time3 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time3_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time3_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME3_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time3_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time3_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME3_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME3_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME3_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time4 */
/* => Output 2 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time4           0x00000054U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time4 0xFF801154U
#define Adr_NX90_mled_ctrl_app_output_on_time4               0xFF801154U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time4          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time4_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time4_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time4_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time4_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time4': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time4 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time4_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time4_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME4_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time4_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time4_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME4_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME4_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME4_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time5 */
/* => Output 2 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time5           0x00000058U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time5 0xFF801158U
#define Adr_NX90_mled_ctrl_app_output_on_time5               0xFF801158U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time5          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time5_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time5_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time5_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time5_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time5': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time5 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time5_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time5_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME5_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time5_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time5_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME5_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME5_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME5_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time6 */
/* => Output 3 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time6           0x0000005CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time6 0xFF80115CU
#define Adr_NX90_mled_ctrl_app_output_on_time6               0xFF80115CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time6          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time6_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time6_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time6_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time6_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time6': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time6 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time6_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time6_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME6_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time6_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time6_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME6_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME6_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME6_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time7 */
/* => Output 3 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time7           0x00000060U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time7 0xFF801160U
#define Adr_NX90_mled_ctrl_app_output_on_time7               0xFF801160U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time7          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time7_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time7_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time7_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time7_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time7': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time7 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time7_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time7_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME7_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time7_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time7_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME7_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME7_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME7_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time8 */
/* => Output 4 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time8           0x00000064U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time8 0xFF801164U
#define Adr_NX90_mled_ctrl_app_output_on_time8               0xFF801164U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time8          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time8_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time8_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time8_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time8_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time8': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time8 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time8_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time8_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME8_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time8_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time8_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME8_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME8_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME8_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time9 */
/* => Output 4 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time9           0x00000068U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time9 0xFF801168U
#define Adr_NX90_mled_ctrl_app_output_on_time9               0xFF801168U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time9          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time9_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time9_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time9_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time9_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time9': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time9 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time9_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time9_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME9_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time9_val;       /* Switch-on time of this LED.                                          */
                                                                             /* This value determines the period during which the output is active.  */
                                                                             /* The value helps achieve a consistent brightness of                   */
                                                                             /* different LED types. Dimming individual LEDs is also possible.       */
                                                                             /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                             /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time9_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME9_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME9_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME9_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time10 */
/* => Output 5 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time10           0x0000006CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time10 0xFF80116CU
#define Adr_NX90_mled_ctrl_app_output_on_time10               0xFF80116CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time10          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time10_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time10_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time10_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time10_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time10': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time10 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time10_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time10_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME10_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time10_val;       /* Switch-on time of this LED.                                          */
                                                                              /* This value determines the period during which the output is active.  */
                                                                              /* The value helps achieve a consistent brightness of                   */
                                                                              /* different LED types. Dimming individual LEDs is also possible.       */
                                                                              /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                              /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time10_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME10_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME10_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME10_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time11 */
/* => Output 5 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time11           0x00000070U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time11 0xFF801170U
#define Adr_NX90_mled_ctrl_app_output_on_time11               0xFF801170U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time11          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time11_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time11_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time11_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time11_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time11': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time11 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time11_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time11_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME11_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time11_val;       /* Switch-on time of this LED.                                          */
                                                                              /* This value determines the period during which the output is active.  */
                                                                              /* The value helps achieve a consistent brightness of                   */
                                                                              /* different LED types. Dimming individual LEDs is also possible.       */
                                                                              /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                              /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time11_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME11_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME11_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME11_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time12 */
/* => Output 6 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time12           0x00000074U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time12 0xFF801174U
#define Adr_NX90_mled_ctrl_app_output_on_time12               0xFF801174U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time12          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time12_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time12_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time12_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time12_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time12': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time12 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time12_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time12_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME12_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time12_val;       /* Switch-on time of this LED.                                          */
                                                                              /* This value determines the period during which the output is active.  */
                                                                              /* The value helps achieve a consistent brightness of                   */
                                                                              /* different LED types. Dimming individual LEDs is also possible.       */
                                                                              /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                              /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time12_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME12_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME12_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME12_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time13 */
/* => Output 6 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time13           0x00000078U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time13 0xFF801178U
#define Adr_NX90_mled_ctrl_app_output_on_time13               0xFF801178U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time13          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time13_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time13_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time13_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time13_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time13': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time13 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time13_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time13_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME13_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time13_val;       /* Switch-on time of this LED.                                          */
                                                                              /* This value determines the period during which the output is active.  */
                                                                              /* The value helps achieve a consistent brightness of                   */
                                                                              /* different LED types. Dimming individual LEDs is also possible.       */
                                                                              /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                              /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time13_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME13_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME13_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME13_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time14 */
/* => Output 7 phase 0 (high-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time14           0x0000007CU
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time14 0xFF80117CU
#define Adr_NX90_mled_ctrl_app_output_on_time14               0xFF80117CU
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time14          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time14_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time14_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time14_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time14_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time14': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time14 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time14_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time14_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME14_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time14_val;       /* Switch-on time of this LED.                                          */
                                                                              /* This value determines the period during which the output is active.  */
                                                                              /* The value helps achieve a consistent brightness of                   */
                                                                              /* different LED types. Dimming individual LEDs is also possible.       */
                                                                              /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                              /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time14_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME14_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME14_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME14_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_output_on_time15 */
/* => Output 7 phase 1 (low-side LED) switch-on time. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_output_on_time15           0x00000080U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_output_on_time15 0xFF801180U
#define Adr_NX90_mled_ctrl_app_output_on_time15               0xFF801180U
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time15          0x000000ffU

#define MSK_NX90_mled_ctrl_app_output_on_time15_val         0x000000ffU
#define SRT_NX90_mled_ctrl_app_output_on_time15_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_output_on_time15_val    0x000000ffU
#define DFLT_BF_VAL_NX90_mled_ctrl_app_output_on_time15_val 0x000000ffU

/* all used bits of 'NX90_mled_ctrl_app_output_on_time15': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_output_on_time15 0x000000ffU

enum {
  BFW_NX90_mled_ctrl_app_output_on_time15_val       = 8,  /* [7:0] */
  BFW_NX90_mled_ctrl_app_output_on_time15_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_MLED_CTRL_APP_OUTPUT_ON_TIME15_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_output_on_time15_val;       /* Switch-on time of this LED.                                          */
                                                                              /* This value determines the period during which the output is active.  */
                                                                              /* The value helps achieve a consistent brightness of                   */
                                                                              /* different LED types. Dimming individual LEDs is also possible.       */
                                                                              /* Possible values are 0 (off) to 255 (on for the full phase minus      */
                                                                              /* one PWM tick).                                                       */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_output_on_time15_reserved1; /* reserved                                                             */
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME15_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_MLED_CTRL_APP_OUTPUT_ON_TIME15_BIT_T bf;
} NX90_MLED_CTRL_APP_OUTPUT_ON_TIME15_T;

/* --------------------------------------------------------------------- */
/* Register mled_ctrl_app_line0 */
/* => Line register. */
/*    The line register allows changing all LEDs (configured to line mode) at once to a new value. */
/*    Note: The change will take effect at the start of the next PWM period (when the output operates in \ */
/*    time-multiplexed PWM mode). In pass-through mode, the change will take effect immediately. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_mled_ctrl_app_line0           0x00000084U
#define Adr_NX90_mled_ctrl_app_mled_ctrl_app_line0 0xFF801184U
#define Adr_NX90_mled_ctrl_app_line0               0xFF801184U
#define DFLT_VAL_NX90_mled_ctrl_app_line0          0x00000000U

#define MSK_NX90_mled_ctrl_app_line0_val         0x0000ffffU
#define SRT_NX90_mled_ctrl_app_line0_val         0
#define DFLT_VAL_NX90_mled_ctrl_app_line0_val    0x00000000U
#define DFLT_BF_VAL_NX90_mled_ctrl_app_line0_val 0x00000000U

/* all used bits of 'NX90_mled_ctrl_app_line0': */
#define MSK_USED_BITS_NX90_mled_ctrl_app_line0 0x0000ffffU

enum {
  BFW_NX90_mled_ctrl_app_line0_val       = 16, /* [15:0] */
  BFW_NX90_mled_ctrl_app_line0_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_MLED_CTRL_APP_LINE0_BIT_Ttag {
  unsigned int val       : BFW_NX90_mled_ctrl_app_line0_val;       /* MLED output values 15..0 when line mode is selected in the corresponding  */
                                                                   /* 'sel' register.                                                           */
  unsigned int reserved1 : BFW_NX90_mled_ctrl_app_line0_reserved1; /* reserved                                                                  */
} NX90_MLED_CTRL_APP_LINE0_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_MLED_CTRL_APP_LINE0_BIT_T bf;
} NX90_MLED_CTRL_APP_LINE0_T;


/* ===================================================================== */

/* AREA ecc_ctrl */
/* Area of ecc_ctrl_app */

/* ===================================================================== */

#define Addr_NX90_ecc_ctrl_app 0xFF801200U

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram0_ctrl */
/* => INTRAM0 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram0_ctrl          0x00000000U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram0_ctrl 0xFF801200U
#define Adr_NX90_ecc_ctrl_intram0_ctrl              0xFF801200U
#define DFLT_VAL_NX90_ecc_ctrl_intram0_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram0_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram0_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram0_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram0_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram0_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_intram0_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram0_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram0_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram0_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram0_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_intram0_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram0_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_intram0_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_INTRAM0_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram0_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram0_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram0_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM0_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM0_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram1_ctrl */
/* => INTRAM1 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram1_ctrl          0x00000004U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram1_ctrl 0xFF801204U
#define Adr_NX90_ecc_ctrl_intram1_ctrl              0xFF801204U
#define DFLT_VAL_NX90_ecc_ctrl_intram1_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram1_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram1_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram1_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram1_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram1_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_intram1_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram1_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram1_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram1_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram1_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_intram1_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram1_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_intram1_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_INTRAM1_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram1_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram1_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram1_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM1_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM1_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram2_ctrl */
/* => INTRAM2 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram2_ctrl          0x00000008U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram2_ctrl 0xFF801208U
#define Adr_NX90_ecc_ctrl_intram2_ctrl              0xFF801208U
#define DFLT_VAL_NX90_ecc_ctrl_intram2_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram2_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram2_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram2_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram2_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram2_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_intram2_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram2_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram2_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram2_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram2_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_intram2_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram2_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_intram2_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_INTRAM2_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram2_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram2_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram2_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM2_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM2_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM2_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram3_ctrl */
/* => INTRAM3 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram3_ctrl          0x0000000CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram3_ctrl 0xFF80120CU
#define Adr_NX90_ecc_ctrl_intram3_ctrl              0xFF80120CU
#define DFLT_VAL_NX90_ecc_ctrl_intram3_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram3_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram3_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram3_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram3_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram3_ctrl_syndrome_inv         0x0000003eU
#define SRT_NX90_ecc_ctrl_intram3_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram3_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram3_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram3_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram3_ctrl 0x0000003fU

enum {
  BFW_NX90_ecc_ctrl_intram3_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram3_ctrl_syndrome_inv = 5,  /* [5:1] */
  BFW_NX90_ecc_ctrl_intram3_ctrl_reserved1    = 26  /* [31:6] */
};

typedef struct NX90_ECC_CTRL_INTRAM3_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram3_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram3_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram3_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM3_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM3_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM3_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram4_ctrl */
/* => INTRAM4 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram4_ctrl          0x00000010U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram4_ctrl 0xFF801210U
#define Adr_NX90_ecc_ctrl_intram4_ctrl              0xFF801210U
#define DFLT_VAL_NX90_ecc_ctrl_intram4_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram4_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram4_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram4_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram4_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram4_ctrl_syndrome_inv         0x0000003eU
#define SRT_NX90_ecc_ctrl_intram4_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram4_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram4_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram4_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram4_ctrl 0x0000003fU

enum {
  BFW_NX90_ecc_ctrl_intram4_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram4_ctrl_syndrome_inv = 5,  /* [5:1] */
  BFW_NX90_ecc_ctrl_intram4_ctrl_reserved1    = 26  /* [31:6] */
};

typedef struct NX90_ECC_CTRL_INTRAM4_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram4_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram4_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram4_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM4_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM4_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM4_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram5_ctrl */
/* => INTRAM5 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram5_ctrl          0x00000014U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram5_ctrl 0xFF801214U
#define Adr_NX90_ecc_ctrl_intram5_ctrl              0xFF801214U
#define DFLT_VAL_NX90_ecc_ctrl_intram5_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram5_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram5_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram5_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram5_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram5_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_intram5_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram5_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram5_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram5_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram5_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_intram5_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram5_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_intram5_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_INTRAM5_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram5_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram5_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram5_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM5_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM5_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM5_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram6_ctrl */
/* => INTRAM6 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram6_ctrl          0x00000018U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram6_ctrl 0xFF801218U
#define Adr_NX90_ecc_ctrl_intram6_ctrl              0xFF801218U
#define DFLT_VAL_NX90_ecc_ctrl_intram6_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram6_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram6_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram6_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram6_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram6_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_intram6_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram6_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram6_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram6_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram6_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_intram6_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram6_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_intram6_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_INTRAM6_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram6_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram6_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram6_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM6_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM6_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM6_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram7_ctrl */
/* => INTRAM7 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram7_ctrl          0x0000001CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram7_ctrl 0xFF80121CU
#define Adr_NX90_ecc_ctrl_intram7_ctrl              0xFF80121CU
#define DFLT_VAL_NX90_ecc_ctrl_intram7_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intram7_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intram7_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intram7_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram7_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intram7_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_intram7_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intram7_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intram7_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intram7_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram7_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_intram7_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intram7_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_intram7_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_INTRAM7_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intram7_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intram7_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intram7_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAM7_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_INTRAM7_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAM7_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intramhs_ctrl */
/* => INTRAMHS syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intramhs_ctrl          0x00000020U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intramhs_ctrl 0xFF801220U
#define Adr_NX90_ecc_ctrl_intramhs_ctrl              0xFF801220U
#define DFLT_VAL_NX90_ecc_ctrl_intramhs_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_intramhs_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_intramhs_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_intramhs_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intramhs_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_intramhs_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_intramhs_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_intramhs_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_intramhs_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_intramhs_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intramhs_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_intramhs_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_intramhs_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_intramhs_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_INTRAMHS_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_intramhs_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_intramhs_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_intramhs_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_INTRAMHS_CTRL_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_ECC_CTRL_INTRAMHS_CTRL_BIT_T bf;
} NX90_ECC_CTRL_INTRAMHS_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpec0_pram_ctrl */
/* => XC0_RPEC0_PRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl          0x00000024U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_ctrl 0xFF801224U
#define Adr_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl              0xFF801224U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_rpec0_pram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_XC0_RPEC0_PRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_rpec0_pram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_RPEC0_PRAM_CTRL_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XC0_RPEC0_PRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPEC0_PRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpec1_pram_ctrl */
/* => XC0_RPEC1_PRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl          0x00000028U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_ctrl 0xFF801228U
#define Adr_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl              0xFF801228U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_rpec1_pram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_XC0_RPEC1_PRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_rpec1_pram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_RPEC1_PRAM_CTRL_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XC0_RPEC1_PRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPEC1_PRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpec0_pram_ctrl */
/* => XC0_TPEC0_PRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl          0x0000002CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_ctrl 0xFF80122CU
#define Adr_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl              0xFF80122CU
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_tpec0_pram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_XC0_TPEC0_PRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_tpec0_pram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_TPEC0_PRAM_CTRL_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XC0_TPEC0_PRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPEC0_PRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpec1_pram_ctrl */
/* => XC0_TPEC1_PRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl          0x00000030U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_ctrl 0xFF801230U
#define Adr_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl              0xFF801230U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_tpec1_pram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_XC0_TPEC1_PRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_tpec1_pram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_TPEC1_PRAM_CTRL_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XC0_TPEC1_PRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPEC1_PRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_dpram0_ctrl */
/* => XC0_DPRAM0 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_dpram0_ctrl          0x00000034U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_dpram0_ctrl 0xFF801234U
#define Adr_NX90_ecc_ctrl_xc0_dpram0_ctrl              0xFF801234U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_dpram0_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_dpram0_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_dpram0_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_dpram0_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_dpram0_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv         0x0000003eU
#define SRT_NX90_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_dpram0_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_dpram0_ctrl 0x0000003fU

enum {
  BFW_NX90_ecc_ctrl_xc0_dpram0_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv = 5,  /* [5:1] */
  BFW_NX90_ecc_ctrl_xc0_dpram0_ctrl_reserved1    = 26  /* [31:6] */
};

typedef struct NX90_ECC_CTRL_XC0_DPRAM0_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_dpram0_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_dpram0_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_dpram0_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_DPRAM0_CTRL_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_ECC_CTRL_XC0_DPRAM0_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_DPRAM0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_dpram1_ctrl */
/* => XC0_DPRAM1 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_dpram1_ctrl          0x00000038U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_dpram1_ctrl 0xFF801238U
#define Adr_NX90_ecc_ctrl_xc0_dpram1_ctrl              0xFF801238U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_dpram1_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_dpram1_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_dpram1_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_dpram1_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_dpram1_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv         0x0000003eU
#define SRT_NX90_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_dpram1_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_dpram1_ctrl 0x0000003fU

enum {
  BFW_NX90_ecc_ctrl_xc0_dpram1_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv = 5,  /* [5:1] */
  BFW_NX90_ecc_ctrl_xc0_dpram1_ctrl_reserved1    = 26  /* [31:6] */
};

typedef struct NX90_ECC_CTRL_XC0_DPRAM1_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_dpram1_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_dpram1_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_dpram1_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_DPRAM1_CTRL_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_ECC_CTRL_XC0_DPRAM1_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_DPRAM1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpu0_ram_ctrl */
/* => XC0_RPU0_RAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl          0x0000003CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_ctrl 0xFF80123CU
#define Adr_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl              0xFF80123CU
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv         0x000001feU
#define SRT_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_rpu0_ram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl 0x000001ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv = 8,  /* [8:1] */
  BFW_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_ECC_CTRL_XC0_RPU0_RAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_rpu0_ram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_RPU0_RAM_CTRL_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_ECC_CTRL_XC0_RPU0_RAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPU0_RAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpu1_ram_ctrl */
/* => XC0_RPU1_RAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl          0x00000040U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_ctrl 0xFF801240U
#define Adr_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl              0xFF801240U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv         0x000001feU
#define SRT_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_rpu1_ram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl 0x000001ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv = 8,  /* [8:1] */
  BFW_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_ECC_CTRL_XC0_RPU1_RAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_rpu1_ram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_RPU1_RAM_CTRL_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_ECC_CTRL_XC0_RPU1_RAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPU1_RAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpu0_ram_ctrl */
/* => XC0_TPU0_RAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl          0x00000044U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_ctrl 0xFF801244U
#define Adr_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl              0xFF801244U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv         0x000001feU
#define SRT_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_tpu0_ram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl 0x000001ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv = 8,  /* [8:1] */
  BFW_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_ECC_CTRL_XC0_TPU0_RAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_tpu0_ram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_TPU0_RAM_CTRL_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_ECC_CTRL_XC0_TPU0_RAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPU0_RAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpu1_ram_ctrl */
/* => XC0_TPU1_RAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl          0x00000048U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_ctrl 0xFF801248U
#define Adr_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl              0xFF801248U
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv         0x000001feU
#define SRT_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_tpu1_ram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl 0x000001ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv = 8,  /* [8:1] */
  BFW_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_ECC_CTRL_XC0_TPU1_RAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_tpu1_ram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_TPU1_RAM_CTRL_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_ECC_CTRL_XC0_TPU1_RAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPU1_RAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_pfifo_ctrl */
/* => XC0_PFIFO syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_pfifo_ctrl          0x0000004CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_pfifo_ctrl 0xFF80124CU
#define Adr_NX90_ecc_ctrl_xc0_pfifo_ctrl              0xFF80124CU
#define DFLT_VAL_NX90_ecc_ctrl_xc0_pfifo_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xc0_pfifo_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xc0_pfifo_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xc0_pfifo_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_pfifo_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xc0_pfifo_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_pfifo_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_pfifo_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_xc0_pfifo_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_XC0_PFIFO_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xc0_pfifo_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xc0_pfifo_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xc0_pfifo_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XC0_PFIFO_CTRL_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_ECC_CTRL_XC0_PFIFO_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XC0_PFIFO_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic0_pram_ctrl */
/* => XPIC0_PRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic0_pram_ctrl          0x00000050U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic0_pram_ctrl 0xFF801250U
#define Adr_NX90_ecc_ctrl_xpic0_pram_ctrl              0xFF801250U
#define DFLT_VAL_NX90_ecc_ctrl_xpic0_pram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xpic0_pram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xpic0_pram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xpic0_pram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic0_pram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xpic0_pram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic0_pram_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_xpic0_pram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_xpic0_pram_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_XPIC0_PRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xpic0_pram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xpic0_pram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xpic0_pram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XPIC0_PRAM_CTRL_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_ECC_CTRL_XPIC0_PRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XPIC0_PRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic1_pram_ctrl */
/* => XPIC1_PRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic1_pram_ctrl          0x00000054U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic1_pram_ctrl 0xFF801254U
#define Adr_NX90_ecc_ctrl_xpic1_pram_ctrl              0xFF801254U
#define DFLT_VAL_NX90_ecc_ctrl_xpic1_pram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xpic1_pram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xpic1_pram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xpic1_pram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic1_pram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv         0x000000feU
#define SRT_NX90_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xpic1_pram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic1_pram_ctrl 0x000000ffU

enum {
  BFW_NX90_ecc_ctrl_xpic1_pram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv = 7,  /* [7:1] */
  BFW_NX90_ecc_ctrl_xpic1_pram_ctrl_reserved1    = 24  /* [31:8] */
};

typedef struct NX90_ECC_CTRL_XPIC1_PRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xpic1_pram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xpic1_pram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xpic1_pram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XPIC1_PRAM_CTRL_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_ECC_CTRL_XPIC1_PRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XPIC1_PRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic0_dram_ctrl */
/* => XPIC0_DRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic0_dram_ctrl          0x00000058U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic0_dram_ctrl 0xFF801258U
#define Adr_NX90_ecc_ctrl_xpic0_dram_ctrl              0xFF801258U
#define DFLT_VAL_NX90_ecc_ctrl_xpic0_dram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xpic0_dram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xpic0_dram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xpic0_dram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic0_dram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv         0x0000003eU
#define SRT_NX90_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xpic0_dram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic0_dram_ctrl 0x0000003fU

enum {
  BFW_NX90_ecc_ctrl_xpic0_dram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv = 5,  /* [5:1] */
  BFW_NX90_ecc_ctrl_xpic0_dram_ctrl_reserved1    = 26  /* [31:6] */
};

typedef struct NX90_ECC_CTRL_XPIC0_DRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xpic0_dram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xpic0_dram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xpic0_dram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XPIC0_DRAM_CTRL_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_ECC_CTRL_XPIC0_DRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XPIC0_DRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic1_dram_ctrl */
/* => XPIC1_DRAM syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic1_dram_ctrl          0x0000005CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic1_dram_ctrl 0xFF80125CU
#define Adr_NX90_ecc_ctrl_xpic1_dram_ctrl              0xFF80125CU
#define DFLT_VAL_NX90_ecc_ctrl_xpic1_dram_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_xpic1_dram_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_xpic1_dram_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_xpic1_dram_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic1_dram_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv         0x0000003eU
#define SRT_NX90_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_xpic1_dram_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic1_dram_ctrl 0x0000003fU

enum {
  BFW_NX90_ecc_ctrl_xpic1_dram_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv = 5,  /* [5:1] */
  BFW_NX90_ecc_ctrl_xpic1_dram_ctrl_reserved1    = 26  /* [31:6] */
};

typedef struct NX90_ECC_CTRL_XPIC1_DRAM_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_xpic1_dram_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_xpic1_dram_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_xpic1_dram_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_XPIC1_DRAM_CTRL_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_ECC_CTRL_XPIC1_DRAM_CTRL_BIT_T bf;
} NX90_ECC_CTRL_XPIC1_DRAM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash0_ctrl */
/* => IFLASH0 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash0_ctrl          0x00000060U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash0_ctrl 0xFF801260U
#define Adr_NX90_ecc_ctrl_iflash0_ctrl              0xFF801260U
#define DFLT_VAL_NX90_ecc_ctrl_iflash0_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_iflash0_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_iflash0_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_iflash0_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_iflash0_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_iflash0_ctrl_syndrome_inv         0x000001feU
#define SRT_NX90_ecc_ctrl_iflash0_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_iflash0_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_iflash0_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_iflash0_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash0_ctrl 0x000001ffU

enum {
  BFW_NX90_ecc_ctrl_iflash0_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_iflash0_ctrl_syndrome_inv = 8,  /* [8:1] */
  BFW_NX90_ecc_ctrl_iflash0_ctrl_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_ECC_CTRL_IFLASH0_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_iflash0_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_iflash0_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_iflash0_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_IFLASH0_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_IFLASH0_CTRL_BIT_T bf;
} NX90_ECC_CTRL_IFLASH0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash1_ctrl */
/* => IFLASH1 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash1_ctrl          0x00000064U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash1_ctrl 0xFF801264U
#define Adr_NX90_ecc_ctrl_iflash1_ctrl              0xFF801264U
#define DFLT_VAL_NX90_ecc_ctrl_iflash1_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_iflash1_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_iflash1_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_iflash1_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_iflash1_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_iflash1_ctrl_syndrome_inv         0x000001feU
#define SRT_NX90_ecc_ctrl_iflash1_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_iflash1_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_iflash1_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_iflash1_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash1_ctrl 0x000001ffU

enum {
  BFW_NX90_ecc_ctrl_iflash1_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_iflash1_ctrl_syndrome_inv = 8,  /* [8:1] */
  BFW_NX90_ecc_ctrl_iflash1_ctrl_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_ECC_CTRL_IFLASH1_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_iflash1_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_iflash1_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_iflash1_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_IFLASH1_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_IFLASH1_CTRL_BIT_T bf;
} NX90_ECC_CTRL_IFLASH1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash2_ctrl */
/* => IFLASH2 syndrome manipulation register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash2_ctrl          0x00000068U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash2_ctrl 0xFF801268U
#define Adr_NX90_ecc_ctrl_iflash2_ctrl              0xFF801268U
#define DFLT_VAL_NX90_ecc_ctrl_iflash2_ctrl         0x00000000U

#define MSK_NX90_ecc_ctrl_iflash2_ctrl_enable               0x00000001U
#define SRT_NX90_ecc_ctrl_iflash2_ctrl_enable               0
#define DFLT_VAL_NX90_ecc_ctrl_iflash2_ctrl_enable          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_iflash2_ctrl_enable       0x00000000U
#define MSK_NX90_ecc_ctrl_iflash2_ctrl_syndrome_inv         0x000001feU
#define SRT_NX90_ecc_ctrl_iflash2_ctrl_syndrome_inv         1
#define DFLT_VAL_NX90_ecc_ctrl_iflash2_ctrl_syndrome_inv    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_iflash2_ctrl_syndrome_inv 0x00000000U

/* all used bits of 'NX90_ecc_ctrl_iflash2_ctrl': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash2_ctrl 0x000001ffU

enum {
  BFW_NX90_ecc_ctrl_iflash2_ctrl_enable       = 1,  /* [0] */
  BFW_NX90_ecc_ctrl_iflash2_ctrl_syndrome_inv = 8,  /* [8:1] */
  BFW_NX90_ecc_ctrl_iflash2_ctrl_reserved1    = 23  /* [31:9] */
};

typedef struct NX90_ECC_CTRL_IFLASH2_CTRL_BIT_Ttag {
  unsigned int enable       : BFW_NX90_ecc_ctrl_iflash2_ctrl_enable;       /* enable ECC                            */
  unsigned int syndrome_inv : BFW_NX90_ecc_ctrl_iflash2_ctrl_syndrome_inv; /* Inverts syndrome bits for ECC testing */
  unsigned int reserved1    : BFW_NX90_ecc_ctrl_iflash2_ctrl_reserved1;    /* reserved                              */
} NX90_ECC_CTRL_IFLASH2_CTRL_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ECC_CTRL_IFLASH2_CTRL_BIT_T bf;
} NX90_ECC_CTRL_IFLASH2_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram0_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram0_addr_sbe          0x0000006CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram0_addr_sbe 0xFF80126CU
#define Adr_NX90_ecc_ctrl_intram0_addr_sbe              0xFF80126CU

#define MSK_NX90_ecc_ctrl_intram0_addr_sbe_address  0x00007fffU
#define SRT_NX90_ecc_ctrl_intram0_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram0_addr_sbe_add_addr 0x001f8000U
#define SRT_NX90_ecc_ctrl_intram0_addr_sbe_add_addr 15

/* all used bits of 'NX90_ecc_ctrl_intram0_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram0_addr_sbe 0x001fffffU

enum {
  BFW_NX90_ecc_ctrl_intram0_addr_sbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_intram0_addr_sbe_add_addr  = 6,  /* [20:15] */
  BFW_NX90_ecc_ctrl_intram0_addr_sbe_reserved1 = 11  /* [31:21] */
};

typedef struct NX90_ECC_CTRL_INTRAM0_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram0_addr_sbe_address;   /* Address of last ECC single bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram0_addr_sbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram0_addr_sbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM0_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM0_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM0_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram1_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram1_addr_sbe          0x00000070U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram1_addr_sbe 0xFF801270U
#define Adr_NX90_ecc_ctrl_intram1_addr_sbe              0xFF801270U

#define MSK_NX90_ecc_ctrl_intram1_addr_sbe_address  0x00007fffU
#define SRT_NX90_ecc_ctrl_intram1_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram1_addr_sbe_add_addr 0x001f8000U
#define SRT_NX90_ecc_ctrl_intram1_addr_sbe_add_addr 15

/* all used bits of 'NX90_ecc_ctrl_intram1_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram1_addr_sbe 0x001fffffU

enum {
  BFW_NX90_ecc_ctrl_intram1_addr_sbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_intram1_addr_sbe_add_addr  = 6,  /* [20:15] */
  BFW_NX90_ecc_ctrl_intram1_addr_sbe_reserved1 = 11  /* [31:21] */
};

typedef struct NX90_ECC_CTRL_INTRAM1_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram1_addr_sbe_address;   /* Address of last ECC single bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram1_addr_sbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram1_addr_sbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM1_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM1_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM1_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram2_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram2_addr_sbe          0x00000074U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram2_addr_sbe 0xFF801274U
#define Adr_NX90_ecc_ctrl_intram2_addr_sbe              0xFF801274U

#define MSK_NX90_ecc_ctrl_intram2_addr_sbe_address  0x00007fffU
#define SRT_NX90_ecc_ctrl_intram2_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram2_addr_sbe_add_addr 0x001f8000U
#define SRT_NX90_ecc_ctrl_intram2_addr_sbe_add_addr 15

/* all used bits of 'NX90_ecc_ctrl_intram2_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram2_addr_sbe 0x001fffffU

enum {
  BFW_NX90_ecc_ctrl_intram2_addr_sbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_intram2_addr_sbe_add_addr  = 6,  /* [20:15] */
  BFW_NX90_ecc_ctrl_intram2_addr_sbe_reserved1 = 11  /* [31:21] */
};

typedef struct NX90_ECC_CTRL_INTRAM2_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram2_addr_sbe_address;   /* Address of last ECC single bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram2_addr_sbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram2_addr_sbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM2_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM2_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM2_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram3_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram3_addr_sbe          0x00000078U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram3_addr_sbe 0xFF801278U
#define Adr_NX90_ecc_ctrl_intram3_addr_sbe              0xFF801278U

#define MSK_NX90_ecc_ctrl_intram3_addr_sbe_address  0x00003fffU
#define SRT_NX90_ecc_ctrl_intram3_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram3_addr_sbe_add_addr 0x0007c000U
#define SRT_NX90_ecc_ctrl_intram3_addr_sbe_add_addr 14

/* all used bits of 'NX90_ecc_ctrl_intram3_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram3_addr_sbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram3_addr_sbe_address   = 14, /* [13:0] */
  BFW_NX90_ecc_ctrl_intram3_addr_sbe_add_addr  = 5,  /* [18:14] */
  BFW_NX90_ecc_ctrl_intram3_addr_sbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM3_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram3_addr_sbe_address;   /* Address of last ECC single bit error                */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram3_addr_sbe_add_addr;  /* Number of master that started errorneous RAM access */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram3_addr_sbe_reserved1; /* reserved                                            */
} NX90_ECC_CTRL_INTRAM3_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM3_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM3_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram4_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram4_addr_sbe          0x0000007CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram4_addr_sbe 0xFF80127CU
#define Adr_NX90_ecc_ctrl_intram4_addr_sbe              0xFF80127CU

#define MSK_NX90_ecc_ctrl_intram4_addr_sbe_address  0x00003fffU
#define SRT_NX90_ecc_ctrl_intram4_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram4_addr_sbe_add_addr 0x0007c000U
#define SRT_NX90_ecc_ctrl_intram4_addr_sbe_add_addr 14

/* all used bits of 'NX90_ecc_ctrl_intram4_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram4_addr_sbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram4_addr_sbe_address   = 14, /* [13:0] */
  BFW_NX90_ecc_ctrl_intram4_addr_sbe_add_addr  = 5,  /* [18:14] */
  BFW_NX90_ecc_ctrl_intram4_addr_sbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM4_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram4_addr_sbe_address;   /* Address of last ECC single bit error                */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram4_addr_sbe_add_addr;  /* Number of master that started errorneous RAM access */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram4_addr_sbe_reserved1; /* reserved                                            */
} NX90_ECC_CTRL_INTRAM4_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM4_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM4_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram5_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram5_addr_sbe          0x00000080U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram5_addr_sbe 0xFF801280U
#define Adr_NX90_ecc_ctrl_intram5_addr_sbe              0xFF801280U

#define MSK_NX90_ecc_ctrl_intram5_addr_sbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intram5_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram5_addr_sbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intram5_addr_sbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intram5_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram5_addr_sbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram5_addr_sbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intram5_addr_sbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intram5_addr_sbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM5_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram5_addr_sbe_address;   /* Address of last ECC single bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram5_addr_sbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram5_addr_sbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM5_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM5_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM5_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram6_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram6_addr_sbe          0x00000084U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram6_addr_sbe 0xFF801284U
#define Adr_NX90_ecc_ctrl_intram6_addr_sbe              0xFF801284U

#define MSK_NX90_ecc_ctrl_intram6_addr_sbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intram6_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram6_addr_sbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intram6_addr_sbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intram6_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram6_addr_sbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram6_addr_sbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intram6_addr_sbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intram6_addr_sbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM6_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram6_addr_sbe_address;   /* Address of last ECC single bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram6_addr_sbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram6_addr_sbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM6_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM6_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM6_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram7_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram7_addr_sbe          0x00000088U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram7_addr_sbe 0xFF801288U
#define Adr_NX90_ecc_ctrl_intram7_addr_sbe              0xFF801288U

#define MSK_NX90_ecc_ctrl_intram7_addr_sbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intram7_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intram7_addr_sbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intram7_addr_sbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intram7_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram7_addr_sbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram7_addr_sbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intram7_addr_sbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intram7_addr_sbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM7_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram7_addr_sbe_address;   /* Address of last ECC single bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram7_addr_sbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram7_addr_sbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM7_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM7_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM7_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intramhs_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intramhs_addr_sbe          0x0000008CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intramhs_addr_sbe 0xFF80128CU
#define Adr_NX90_ecc_ctrl_intramhs_addr_sbe              0xFF80128CU

#define MSK_NX90_ecc_ctrl_intramhs_addr_sbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intramhs_addr_sbe_address  0
#define MSK_NX90_ecc_ctrl_intramhs_addr_sbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intramhs_addr_sbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intramhs_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intramhs_addr_sbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intramhs_addr_sbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intramhs_addr_sbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intramhs_addr_sbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAMHS_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intramhs_addr_sbe_address;   /* Address of last ECC single bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intramhs_addr_sbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intramhs_addr_sbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAMHS_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_ECC_CTRL_INTRAMHS_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAMHS_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpec0_pram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe          0x00000090U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_addr_sbe 0xFF801290U
#define Adr_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe              0xFF801290U

#define MSK_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpec1_pram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe          0x00000094U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_addr_sbe 0xFF801294U
#define Adr_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe              0xFF801294U

#define MSK_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpec0_pram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe          0x00000098U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_addr_sbe 0xFF801298U
#define Adr_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe              0xFF801298U

#define MSK_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpec1_pram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe          0x0000009CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_addr_sbe 0xFF80129CU
#define Adr_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe              0xFF80129CU

#define MSK_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpu0_ram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe          0x000000A0U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_addr_sbe 0xFF8012A0U
#define Adr_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe              0xFF8012A0U

#define MSK_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpu1_ram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe          0x000000A4U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_addr_sbe 0xFF8012A4U
#define Adr_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe              0xFF8012A4U

#define MSK_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpu0_ram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe          0x000000A8U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_addr_sbe 0xFF8012A8U
#define Adr_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe              0xFF8012A8U

#define MSK_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpu1_ram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe          0x000000ACU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_addr_sbe 0xFF8012ACU
#define Adr_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe              0xFF8012ACU

#define MSK_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic0_pram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic0_pram_addr_sbe          0x000000B0U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic0_pram_addr_sbe 0xFF8012B0U
#define Adr_NX90_ecc_ctrl_xpic0_pram_addr_sbe              0xFF8012B0U

#define MSK_NX90_ecc_ctrl_xpic0_pram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic0_pram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic0_pram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic0_pram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic0_pram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic0_pram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC0_PRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic0_pram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic0_pram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC0_PRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC0_PRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC0_PRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic1_pram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic1_pram_addr_sbe          0x000000B4U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic1_pram_addr_sbe 0xFF8012B4U
#define Adr_NX90_ecc_ctrl_xpic1_pram_addr_sbe              0xFF8012B4U

#define MSK_NX90_ecc_ctrl_xpic1_pram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic1_pram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic1_pram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic1_pram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic1_pram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic1_pram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC1_PRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic1_pram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic1_pram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC1_PRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC1_PRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC1_PRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic0_dram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic0_dram_addr_sbe          0x000000B8U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic0_dram_addr_sbe 0xFF8012B8U
#define Adr_NX90_ecc_ctrl_xpic0_dram_addr_sbe              0xFF8012B8U

#define MSK_NX90_ecc_ctrl_xpic0_dram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic0_dram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic0_dram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic0_dram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic0_dram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic0_dram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC0_DRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic0_dram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic0_dram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC0_DRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC0_DRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC0_DRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic1_dram_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic1_dram_addr_sbe          0x000000BCU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic1_dram_addr_sbe 0xFF8012BCU
#define Adr_NX90_ecc_ctrl_xpic1_dram_addr_sbe              0xFF8012BCU

#define MSK_NX90_ecc_ctrl_xpic1_dram_addr_sbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic1_dram_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic1_dram_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic1_dram_addr_sbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic1_dram_addr_sbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic1_dram_addr_sbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC1_DRAM_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic1_dram_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic1_dram_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC1_DRAM_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC1_DRAM_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC1_DRAM_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash0_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash0_addr_sbe          0x000000C0U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash0_addr_sbe 0xFF8012C0U
#define Adr_NX90_ecc_ctrl_iflash0_addr_sbe              0xFF8012C0U

#define MSK_NX90_ecc_ctrl_iflash0_addr_sbe_address 0x00007fffU
#define SRT_NX90_ecc_ctrl_iflash0_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_iflash0_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash0_addr_sbe 0x00007fffU

enum {
  BFW_NX90_ecc_ctrl_iflash0_addr_sbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_iflash0_addr_sbe_reserved1 = 17  /* [31:15] */
};

typedef struct NX90_ECC_CTRL_IFLASH0_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_iflash0_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_iflash0_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_IFLASH0_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_IFLASH0_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_IFLASH0_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash1_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash1_addr_sbe          0x000000C4U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash1_addr_sbe 0xFF8012C4U
#define Adr_NX90_ecc_ctrl_iflash1_addr_sbe              0xFF8012C4U

#define MSK_NX90_ecc_ctrl_iflash1_addr_sbe_address 0x00007fffU
#define SRT_NX90_ecc_ctrl_iflash1_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_iflash1_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash1_addr_sbe 0x00007fffU

enum {
  BFW_NX90_ecc_ctrl_iflash1_addr_sbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_iflash1_addr_sbe_reserved1 = 17  /* [31:15] */
};

typedef struct NX90_ECC_CTRL_IFLASH1_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_iflash1_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_iflash1_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_IFLASH1_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_IFLASH1_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_IFLASH1_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash2_addr_sbe */
/* => RAM Address of ECC single bit error (SBE): */
/*    This register logs the RAM address where first ECC SBE occured. */
/*    This first SBE address will be stored (even in case of further SBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash2_addr_sbe          0x000000C8U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash2_addr_sbe 0xFF8012C8U
#define Adr_NX90_ecc_ctrl_iflash2_addr_sbe              0xFF8012C8U

#define MSK_NX90_ecc_ctrl_iflash2_addr_sbe_address 0x00007fffU
#define SRT_NX90_ecc_ctrl_iflash2_addr_sbe_address 0

/* all used bits of 'NX90_ecc_ctrl_iflash2_addr_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash2_addr_sbe 0x00007fffU

enum {
  BFW_NX90_ecc_ctrl_iflash2_addr_sbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_iflash2_addr_sbe_reserved1 = 17  /* [31:15] */
};

typedef struct NX90_ECC_CTRL_IFLASH2_ADDR_SBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_iflash2_addr_sbe_address;   /* Address of last ECC single bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_iflash2_addr_sbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_IFLASH2_ADDR_SBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_IFLASH2_ADDR_SBE_BIT_T bf;
} NX90_ECC_CTRL_IFLASH2_ADDR_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram0_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram0_addr_dbe          0x000000CCU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram0_addr_dbe 0xFF8012CCU
#define Adr_NX90_ecc_ctrl_intram0_addr_dbe              0xFF8012CCU

#define MSK_NX90_ecc_ctrl_intram0_addr_dbe_address  0x00007fffU
#define SRT_NX90_ecc_ctrl_intram0_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram0_addr_dbe_add_addr 0x001f8000U
#define SRT_NX90_ecc_ctrl_intram0_addr_dbe_add_addr 15

/* all used bits of 'NX90_ecc_ctrl_intram0_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram0_addr_dbe 0x001fffffU

enum {
  BFW_NX90_ecc_ctrl_intram0_addr_dbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_intram0_addr_dbe_add_addr  = 6,  /* [20:15] */
  BFW_NX90_ecc_ctrl_intram0_addr_dbe_reserved1 = 11  /* [31:21] */
};

typedef struct NX90_ECC_CTRL_INTRAM0_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram0_addr_dbe_address;   /* Address of last ECC double bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram0_addr_dbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram0_addr_dbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM0_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM0_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM0_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram1_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram1_addr_dbe          0x000000D0U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram1_addr_dbe 0xFF8012D0U
#define Adr_NX90_ecc_ctrl_intram1_addr_dbe              0xFF8012D0U

#define MSK_NX90_ecc_ctrl_intram1_addr_dbe_address  0x00007fffU
#define SRT_NX90_ecc_ctrl_intram1_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram1_addr_dbe_add_addr 0x001f8000U
#define SRT_NX90_ecc_ctrl_intram1_addr_dbe_add_addr 15

/* all used bits of 'NX90_ecc_ctrl_intram1_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram1_addr_dbe 0x001fffffU

enum {
  BFW_NX90_ecc_ctrl_intram1_addr_dbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_intram1_addr_dbe_add_addr  = 6,  /* [20:15] */
  BFW_NX90_ecc_ctrl_intram1_addr_dbe_reserved1 = 11  /* [31:21] */
};

typedef struct NX90_ECC_CTRL_INTRAM1_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram1_addr_dbe_address;   /* Address of last ECC double bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram1_addr_dbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram1_addr_dbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM1_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM1_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM1_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram2_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram2_addr_dbe          0x000000D4U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram2_addr_dbe 0xFF8012D4U
#define Adr_NX90_ecc_ctrl_intram2_addr_dbe              0xFF8012D4U

#define MSK_NX90_ecc_ctrl_intram2_addr_dbe_address  0x00007fffU
#define SRT_NX90_ecc_ctrl_intram2_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram2_addr_dbe_add_addr 0x001f8000U
#define SRT_NX90_ecc_ctrl_intram2_addr_dbe_add_addr 15

/* all used bits of 'NX90_ecc_ctrl_intram2_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram2_addr_dbe 0x001fffffU

enum {
  BFW_NX90_ecc_ctrl_intram2_addr_dbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_intram2_addr_dbe_add_addr  = 6,  /* [20:15] */
  BFW_NX90_ecc_ctrl_intram2_addr_dbe_reserved1 = 11  /* [31:21] */
};

typedef struct NX90_ECC_CTRL_INTRAM2_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram2_addr_dbe_address;   /* Address of last ECC double bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram2_addr_dbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram2_addr_dbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM2_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM2_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM2_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram3_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram3_addr_dbe          0x000000D8U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram3_addr_dbe 0xFF8012D8U
#define Adr_NX90_ecc_ctrl_intram3_addr_dbe              0xFF8012D8U

#define MSK_NX90_ecc_ctrl_intram3_addr_dbe_address  0x00003fffU
#define SRT_NX90_ecc_ctrl_intram3_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram3_addr_dbe_add_addr 0x0007c000U
#define SRT_NX90_ecc_ctrl_intram3_addr_dbe_add_addr 14

/* all used bits of 'NX90_ecc_ctrl_intram3_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram3_addr_dbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram3_addr_dbe_address   = 14, /* [13:0] */
  BFW_NX90_ecc_ctrl_intram3_addr_dbe_add_addr  = 5,  /* [18:14] */
  BFW_NX90_ecc_ctrl_intram3_addr_dbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM3_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram3_addr_dbe_address;   /* Address of last ECC double bit error                */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram3_addr_dbe_add_addr;  /* Number of master that started errorneous RAM access */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram3_addr_dbe_reserved1; /* reserved                                            */
} NX90_ECC_CTRL_INTRAM3_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM3_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM3_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram4_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram4_addr_dbe          0x000000DCU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram4_addr_dbe 0xFF8012DCU
#define Adr_NX90_ecc_ctrl_intram4_addr_dbe              0xFF8012DCU

#define MSK_NX90_ecc_ctrl_intram4_addr_dbe_address  0x00003fffU
#define SRT_NX90_ecc_ctrl_intram4_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram4_addr_dbe_add_addr 0x0007c000U
#define SRT_NX90_ecc_ctrl_intram4_addr_dbe_add_addr 14

/* all used bits of 'NX90_ecc_ctrl_intram4_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram4_addr_dbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram4_addr_dbe_address   = 14, /* [13:0] */
  BFW_NX90_ecc_ctrl_intram4_addr_dbe_add_addr  = 5,  /* [18:14] */
  BFW_NX90_ecc_ctrl_intram4_addr_dbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM4_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram4_addr_dbe_address;   /* Address of last ECC double bit error                */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram4_addr_dbe_add_addr;  /* Number of master that started errorneous RAM access */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram4_addr_dbe_reserved1; /* reserved                                            */
} NX90_ECC_CTRL_INTRAM4_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM4_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM4_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram5_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram5_addr_dbe          0x000000E0U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram5_addr_dbe 0xFF8012E0U
#define Adr_NX90_ecc_ctrl_intram5_addr_dbe              0xFF8012E0U

#define MSK_NX90_ecc_ctrl_intram5_addr_dbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intram5_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram5_addr_dbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intram5_addr_dbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intram5_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram5_addr_dbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram5_addr_dbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intram5_addr_dbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intram5_addr_dbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM5_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram5_addr_dbe_address;   /* Address of last ECC double bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram5_addr_dbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram5_addr_dbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM5_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM5_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM5_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram6_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram6_addr_dbe          0x000000E4U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram6_addr_dbe 0xFF8012E4U
#define Adr_NX90_ecc_ctrl_intram6_addr_dbe              0xFF8012E4U

#define MSK_NX90_ecc_ctrl_intram6_addr_dbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intram6_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram6_addr_dbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intram6_addr_dbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intram6_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram6_addr_dbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram6_addr_dbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intram6_addr_dbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intram6_addr_dbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM6_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram6_addr_dbe_address;   /* Address of last ECC double bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram6_addr_dbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram6_addr_dbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM6_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM6_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM6_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intram7_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intram7_addr_dbe          0x000000E8U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intram7_addr_dbe 0xFF8012E8U
#define Adr_NX90_ecc_ctrl_intram7_addr_dbe              0xFF8012E8U

#define MSK_NX90_ecc_ctrl_intram7_addr_dbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intram7_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intram7_addr_dbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intram7_addr_dbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intram7_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intram7_addr_dbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intram7_addr_dbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intram7_addr_dbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intram7_addr_dbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAM7_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intram7_addr_dbe_address;   /* Address of last ECC double bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intram7_addr_dbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intram7_addr_dbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAM7_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_INTRAM7_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAM7_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_intramhs_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_intramhs_addr_dbe          0x000000ECU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_intramhs_addr_dbe 0xFF8012ECU
#define Adr_NX90_ecc_ctrl_intramhs_addr_dbe              0xFF8012ECU

#define MSK_NX90_ecc_ctrl_intramhs_addr_dbe_address  0x00001fffU
#define SRT_NX90_ecc_ctrl_intramhs_addr_dbe_address  0
#define MSK_NX90_ecc_ctrl_intramhs_addr_dbe_add_addr 0x0007e000U
#define SRT_NX90_ecc_ctrl_intramhs_addr_dbe_add_addr 13

/* all used bits of 'NX90_ecc_ctrl_intramhs_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_intramhs_addr_dbe 0x0007ffffU

enum {
  BFW_NX90_ecc_ctrl_intramhs_addr_dbe_address   = 13, /* [12:0] */
  BFW_NX90_ecc_ctrl_intramhs_addr_dbe_add_addr  = 6,  /* [18:13] */
  BFW_NX90_ecc_ctrl_intramhs_addr_dbe_reserved1 = 13  /* [31:19] */
};

typedef struct NX90_ECC_CTRL_INTRAMHS_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_intramhs_addr_dbe_address;   /* Address of last ECC double bit error                                           */
  unsigned int add_addr  : BFW_NX90_ecc_ctrl_intramhs_addr_dbe_add_addr;  /* RAM readmodwrite(1) and number of master that started errorneous RAM access(5) */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_intramhs_addr_dbe_reserved1; /* reserved                                                                       */
} NX90_ECC_CTRL_INTRAMHS_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_ECC_CTRL_INTRAMHS_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_INTRAMHS_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpec0_pram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe          0x000000F0U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpec0_pram_addr_dbe 0xFF8012F0U
#define Adr_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe              0xFF8012F0U

#define MSK_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpec0_pram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPEC0_PRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpec1_pram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe          0x000000F4U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpec1_pram_addr_dbe 0xFF8012F4U
#define Adr_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe              0xFF8012F4U

#define MSK_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpec1_pram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPEC1_PRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpec0_pram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe          0x000000F8U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpec0_pram_addr_dbe 0xFF8012F8U
#define Adr_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe              0xFF8012F8U

#define MSK_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpec0_pram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPEC0_PRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpec1_pram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe          0x000000FCU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpec1_pram_addr_dbe 0xFF8012FCU
#define Adr_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe              0xFF8012FCU

#define MSK_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpec1_pram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                    val;
  NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPEC1_PRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpu0_ram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe          0x00000100U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpu0_ram_addr_dbe 0xFF801300U
#define Adr_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe              0xFF801300U

#define MSK_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpu0_ram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPU0_RAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_rpu1_ram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe          0x00000104U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_rpu1_ram_addr_dbe 0xFF801304U
#define Adr_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe              0xFF801304U

#define MSK_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_rpu1_ram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_RPU1_RAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpu0_ram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe          0x00000108U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpu0_ram_addr_dbe 0xFF801308U
#define Adr_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe              0xFF801308U

#define MSK_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpu0_ram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPU0_RAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xc0_tpu1_ram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe          0x0000010CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xc0_tpu1_ram_addr_dbe 0xFF80130CU
#define Adr_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe              0xFF80130CU

#define MSK_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe_address 0x0000007fU
#define SRT_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe 0x0000007fU

enum {
  BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe_address   = 7,  /* [6:0] */
  BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xc0_tpu1_ram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XC0_TPU1_RAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic0_pram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic0_pram_addr_dbe          0x00000110U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic0_pram_addr_dbe 0xFF801310U
#define Adr_NX90_ecc_ctrl_xpic0_pram_addr_dbe              0xFF801310U

#define MSK_NX90_ecc_ctrl_xpic0_pram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic0_pram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic0_pram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic0_pram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic0_pram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic0_pram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC0_PRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic0_pram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic0_pram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC0_PRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC0_PRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC0_PRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic1_pram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic1_pram_addr_dbe          0x00000114U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic1_pram_addr_dbe 0xFF801314U
#define Adr_NX90_ecc_ctrl_xpic1_pram_addr_dbe              0xFF801314U

#define MSK_NX90_ecc_ctrl_xpic1_pram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic1_pram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic1_pram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic1_pram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic1_pram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic1_pram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC1_PRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic1_pram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic1_pram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC1_PRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC1_PRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC1_PRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic0_dram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic0_dram_addr_dbe          0x00000118U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic0_dram_addr_dbe 0xFF801318U
#define Adr_NX90_ecc_ctrl_xpic0_dram_addr_dbe              0xFF801318U

#define MSK_NX90_ecc_ctrl_xpic0_dram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic0_dram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic0_dram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic0_dram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic0_dram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic0_dram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC0_DRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic0_dram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic0_dram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC0_DRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC0_DRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC0_DRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_xpic1_dram_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_xpic1_dram_addr_dbe          0x0000011CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_xpic1_dram_addr_dbe 0xFF80131CU
#define Adr_NX90_ecc_ctrl_xpic1_dram_addr_dbe              0xFF80131CU

#define MSK_NX90_ecc_ctrl_xpic1_dram_addr_dbe_address 0x000007ffU
#define SRT_NX90_ecc_ctrl_xpic1_dram_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_xpic1_dram_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_xpic1_dram_addr_dbe 0x000007ffU

enum {
  BFW_NX90_ecc_ctrl_xpic1_dram_addr_dbe_address   = 11, /* [10:0] */
  BFW_NX90_ecc_ctrl_xpic1_dram_addr_dbe_reserved1 = 21  /* [31:11] */
};

typedef struct NX90_ECC_CTRL_XPIC1_DRAM_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_xpic1_dram_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_xpic1_dram_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_XPIC1_DRAM_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_ECC_CTRL_XPIC1_DRAM_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_XPIC1_DRAM_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash0_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash0_addr_dbe          0x00000120U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash0_addr_dbe 0xFF801320U
#define Adr_NX90_ecc_ctrl_iflash0_addr_dbe              0xFF801320U

#define MSK_NX90_ecc_ctrl_iflash0_addr_dbe_address 0x00007fffU
#define SRT_NX90_ecc_ctrl_iflash0_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_iflash0_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash0_addr_dbe 0x00007fffU

enum {
  BFW_NX90_ecc_ctrl_iflash0_addr_dbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_iflash0_addr_dbe_reserved1 = 17  /* [31:15] */
};

typedef struct NX90_ECC_CTRL_IFLASH0_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_iflash0_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_iflash0_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_IFLASH0_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_IFLASH0_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_IFLASH0_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash1_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash1_addr_dbe          0x00000124U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash1_addr_dbe 0xFF801324U
#define Adr_NX90_ecc_ctrl_iflash1_addr_dbe              0xFF801324U

#define MSK_NX90_ecc_ctrl_iflash1_addr_dbe_address 0x00007fffU
#define SRT_NX90_ecc_ctrl_iflash1_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_iflash1_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash1_addr_dbe 0x00007fffU

enum {
  BFW_NX90_ecc_ctrl_iflash1_addr_dbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_iflash1_addr_dbe_reserved1 = 17  /* [31:15] */
};

typedef struct NX90_ECC_CTRL_IFLASH1_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_iflash1_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_iflash1_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_IFLASH1_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_IFLASH1_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_IFLASH1_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_iflash2_addr_dbe */
/* => RAM Address of ECC single bit error (DBE): */
/*    This register logs the RAM address where first ECC DBE occured. */
/*    This first DBE address will be stored (even in case of further DBEs) */
/*    until the appropriate bit in status_sbe register was cleared. */
/*    Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs */
/*    Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs */
/*    or RAMs that are not directly accessible by CPU. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_iflash2_addr_dbe          0x00000128U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_iflash2_addr_dbe 0xFF801328U
#define Adr_NX90_ecc_ctrl_iflash2_addr_dbe              0xFF801328U

#define MSK_NX90_ecc_ctrl_iflash2_addr_dbe_address 0x00007fffU
#define SRT_NX90_ecc_ctrl_iflash2_addr_dbe_address 0

/* all used bits of 'NX90_ecc_ctrl_iflash2_addr_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_iflash2_addr_dbe 0x00007fffU

enum {
  BFW_NX90_ecc_ctrl_iflash2_addr_dbe_address   = 15, /* [14:0] */
  BFW_NX90_ecc_ctrl_iflash2_addr_dbe_reserved1 = 17  /* [31:15] */
};

typedef struct NX90_ECC_CTRL_IFLASH2_ADDR_DBE_BIT_Ttag {
  unsigned int address   : BFW_NX90_ecc_ctrl_iflash2_addr_dbe_address;   /* Address of last ECC double bit error */
  unsigned int reserved1 : BFW_NX90_ecc_ctrl_iflash2_addr_dbe_reserved1; /* reserved                             */
} NX90_ECC_CTRL_IFLASH2_ADDR_DBE_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_ECC_CTRL_IFLASH2_ADDR_DBE_BIT_T bf;
} NX90_ECC_CTRL_IFLASH2_ADDR_DBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_status_sbe */
/* => ECC status SBE: */
/*    This register collects single bit error (SBE) status information. */
/*    In case of ECC SBE, a bit in this register will be set. */
/*    Bits can be reset by writing '1' to the apprpriate bit position (write to clear). */
/*    If a SBE or DBE bit is set, IRQ signal will be asserted. */
/*    Note: No mask register is required, as error correction can be enabled for each RAM separately. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_status_sbe          0x0000012CU
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_status_sbe 0xFF80132CU
#define Adr_NX90_ecc_ctrl_status_sbe              0xFF80132CU
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe         0x00000000U

#define MSK_NX90_ecc_ctrl_status_sbe_intram0                0x00000001U
#define SRT_NX90_ecc_ctrl_status_sbe_intram0                0
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram0           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram0        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intram1                0x00000002U
#define SRT_NX90_ecc_ctrl_status_sbe_intram1                1
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram1           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram1        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intram2                0x00000004U
#define SRT_NX90_ecc_ctrl_status_sbe_intram2                2
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram2           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram2        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intram3                0x00000008U
#define SRT_NX90_ecc_ctrl_status_sbe_intram3                3
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram3           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram3        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intram4                0x00000010U
#define SRT_NX90_ecc_ctrl_status_sbe_intram4                4
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram4           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram4        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intram5                0x00000020U
#define SRT_NX90_ecc_ctrl_status_sbe_intram5                5
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram5           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram5        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intram6                0x00000040U
#define SRT_NX90_ecc_ctrl_status_sbe_intram6                6
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram6           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram6        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intram7                0x00000080U
#define SRT_NX90_ecc_ctrl_status_sbe_intram7                7
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intram7           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intram7        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_intramhs               0x00000100U
#define SRT_NX90_ecc_ctrl_status_sbe_intramhs               8
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_intramhs          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_intramhs       0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_rpec0_pram         0x00000200U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_rpec0_pram         9
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpec0_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpec0_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_rpec1_pram         0x00000400U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_rpec1_pram         10
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpec1_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpec1_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_tpec0_pram         0x00000800U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_tpec0_pram         11
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpec0_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpec0_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_tpec1_pram         0x00001000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_tpec1_pram         12
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpec1_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpec1_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_dpram0             0x00002000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_dpram0             13
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_dpram0        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_dpram0     0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_dpram1             0x00004000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_dpram1             14
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_dpram1        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_dpram1     0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_rpu0_ram           0x00008000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_rpu0_ram           15
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpu0_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpu0_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_rpu1_ram           0x00010000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_rpu1_ram           16
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpu1_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_rpu1_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_tpu0_ram           0x00020000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_tpu0_ram           17
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpu0_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpu0_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_tpu1_ram           0x00040000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_tpu1_ram           18
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpu1_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_tpu1_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xc0_pfifo              0x00080000U
#define SRT_NX90_ecc_ctrl_status_sbe_xc0_pfifo              19
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xc0_pfifo         0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xc0_pfifo      0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xpic0_pram             0x00100000U
#define SRT_NX90_ecc_ctrl_status_sbe_xpic0_pram             20
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xpic0_pram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xpic0_pram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xpic1_pram             0x00200000U
#define SRT_NX90_ecc_ctrl_status_sbe_xpic1_pram             21
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xpic1_pram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xpic1_pram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xpic0_dram             0x00400000U
#define SRT_NX90_ecc_ctrl_status_sbe_xpic0_dram             22
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xpic0_dram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xpic0_dram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_xpic1_dram             0x00800000U
#define SRT_NX90_ecc_ctrl_status_sbe_xpic1_dram             23
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_xpic1_dram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_xpic1_dram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_iflash0                0x01000000U
#define SRT_NX90_ecc_ctrl_status_sbe_iflash0                24
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_iflash0           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_iflash0        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_iflash1                0x02000000U
#define SRT_NX90_ecc_ctrl_status_sbe_iflash1                25
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_iflash1           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_iflash1        0x00000000U
#define MSK_NX90_ecc_ctrl_status_sbe_iflash2                0x04000000U
#define SRT_NX90_ecc_ctrl_status_sbe_iflash2                26
#define DFLT_VAL_NX90_ecc_ctrl_status_sbe_iflash2           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_sbe_iflash2        0x00000000U

/* all used bits of 'NX90_ecc_ctrl_status_sbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_status_sbe 0x07ffffffU

enum {
  BFW_NX90_ecc_ctrl_status_sbe_intram0        = 1, /* [0] */
  BFW_NX90_ecc_ctrl_status_sbe_intram1        = 1, /* [1] */
  BFW_NX90_ecc_ctrl_status_sbe_intram2        = 1, /* [2] */
  BFW_NX90_ecc_ctrl_status_sbe_intram3        = 1, /* [3] */
  BFW_NX90_ecc_ctrl_status_sbe_intram4        = 1, /* [4] */
  BFW_NX90_ecc_ctrl_status_sbe_intram5        = 1, /* [5] */
  BFW_NX90_ecc_ctrl_status_sbe_intram6        = 1, /* [6] */
  BFW_NX90_ecc_ctrl_status_sbe_intram7        = 1, /* [7] */
  BFW_NX90_ecc_ctrl_status_sbe_intramhs       = 1, /* [8] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_rpec0_pram = 1, /* [9] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_rpec1_pram = 1, /* [10] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_tpec0_pram = 1, /* [11] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_tpec1_pram = 1, /* [12] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_dpram0     = 1, /* [13] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_dpram1     = 1, /* [14] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_rpu0_ram   = 1, /* [15] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_rpu1_ram   = 1, /* [16] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_tpu0_ram   = 1, /* [17] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_tpu1_ram   = 1, /* [18] */
  BFW_NX90_ecc_ctrl_status_sbe_xc0_pfifo      = 1, /* [19] */
  BFW_NX90_ecc_ctrl_status_sbe_xpic0_pram     = 1, /* [20] */
  BFW_NX90_ecc_ctrl_status_sbe_xpic1_pram     = 1, /* [21] */
  BFW_NX90_ecc_ctrl_status_sbe_xpic0_dram     = 1, /* [22] */
  BFW_NX90_ecc_ctrl_status_sbe_xpic1_dram     = 1, /* [23] */
  BFW_NX90_ecc_ctrl_status_sbe_iflash0        = 1, /* [24] */
  BFW_NX90_ecc_ctrl_status_sbe_iflash1        = 1, /* [25] */
  BFW_NX90_ecc_ctrl_status_sbe_iflash2        = 1, /* [26] */
  BFW_NX90_ecc_ctrl_status_sbe_reserved1      = 5  /* [31:27] */
};

typedef struct NX90_ECC_CTRL_STATUS_SBE_BIT_Ttag {
  unsigned int intram0        : BFW_NX90_ecc_ctrl_status_sbe_intram0;        /* INTRAM0 Single Bit Error occured        */
  unsigned int intram1        : BFW_NX90_ecc_ctrl_status_sbe_intram1;        /* INTRAM1 Single Bit Error occured        */
  unsigned int intram2        : BFW_NX90_ecc_ctrl_status_sbe_intram2;        /* INTRAM2 Single Bit Error occured        */
  unsigned int intram3        : BFW_NX90_ecc_ctrl_status_sbe_intram3;        /* INTRAM3 Single Bit Error occured        */
  unsigned int intram4        : BFW_NX90_ecc_ctrl_status_sbe_intram4;        /* INTRAM4 Single Bit Error occured        */
  unsigned int intram5        : BFW_NX90_ecc_ctrl_status_sbe_intram5;        /* INTRAM5 Single Bit Error occured        */
  unsigned int intram6        : BFW_NX90_ecc_ctrl_status_sbe_intram6;        /* INTRAM6 Single Bit Error occured        */
  unsigned int intram7        : BFW_NX90_ecc_ctrl_status_sbe_intram7;        /* INTRAM7 Single Bit Error occured        */
  unsigned int intramhs       : BFW_NX90_ecc_ctrl_status_sbe_intramhs;       /* INTRAMHS Single Bit Error occured       */
  unsigned int xc0_rpec0_pram : BFW_NX90_ecc_ctrl_status_sbe_xc0_rpec0_pram; /* XC0_RPEC0_PRAM Single Bit Error occured */
  unsigned int xc0_rpec1_pram : BFW_NX90_ecc_ctrl_status_sbe_xc0_rpec1_pram; /* XC0_RPEC1_PRAM Single Bit Error occured */
  unsigned int xc0_tpec0_pram : BFW_NX90_ecc_ctrl_status_sbe_xc0_tpec0_pram; /* XC0_TPEC0_PRAM Single Bit Error occured */
  unsigned int xc0_tpec1_pram : BFW_NX90_ecc_ctrl_status_sbe_xc0_tpec1_pram; /* XC0_TPEC1_PRAM Single Bit Error occured */
  unsigned int xc0_dpram0     : BFW_NX90_ecc_ctrl_status_sbe_xc0_dpram0;     /* XC0_DPRAM0 Single Bit Error occured     */
  unsigned int xc0_dpram1     : BFW_NX90_ecc_ctrl_status_sbe_xc0_dpram1;     /* XC0_DPRAM1 Single Bit Error occured     */
  unsigned int xc0_rpu0_ram   : BFW_NX90_ecc_ctrl_status_sbe_xc0_rpu0_ram;   /* XC0_RPU0_RAM Single Bit Error occured   */
  unsigned int xc0_rpu1_ram   : BFW_NX90_ecc_ctrl_status_sbe_xc0_rpu1_ram;   /* XC0_RPU1_RAM Single Bit Error occured   */
  unsigned int xc0_tpu0_ram   : BFW_NX90_ecc_ctrl_status_sbe_xc0_tpu0_ram;   /* XC0_TPU0_RAM Single Bit Error occured   */
  unsigned int xc0_tpu1_ram   : BFW_NX90_ecc_ctrl_status_sbe_xc0_tpu1_ram;   /* XC0_TPU1_RAM Single Bit Error occured   */
  unsigned int xc0_pfifo      : BFW_NX90_ecc_ctrl_status_sbe_xc0_pfifo;      /* XC0_PFIFO Single Bit Error occured      */
  unsigned int xpic0_pram     : BFW_NX90_ecc_ctrl_status_sbe_xpic0_pram;     /* XPIC0_PRAM Single Bit Error occured     */
  unsigned int xpic1_pram     : BFW_NX90_ecc_ctrl_status_sbe_xpic1_pram;     /* XPIC1_PRAM Single Bit Error occured     */
  unsigned int xpic0_dram     : BFW_NX90_ecc_ctrl_status_sbe_xpic0_dram;     /* XPIC0_DRAM Single Bit Error occured     */
  unsigned int xpic1_dram     : BFW_NX90_ecc_ctrl_status_sbe_xpic1_dram;     /* XPIC1_DRAM Single Bit Error occured     */
  unsigned int iflash0        : BFW_NX90_ecc_ctrl_status_sbe_iflash0;        /* IFLASH0 Single Bit Error occured        */
  unsigned int iflash1        : BFW_NX90_ecc_ctrl_status_sbe_iflash1;        /* IFLASH1 Single Bit Error occured        */
  unsigned int iflash2        : BFW_NX90_ecc_ctrl_status_sbe_iflash2;        /* IFLASH2 Single Bit Error occured        */
  unsigned int reserved1      : BFW_NX90_ecc_ctrl_status_sbe_reserved1;      /* reserved                                */
} NX90_ECC_CTRL_STATUS_SBE_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_ECC_CTRL_STATUS_SBE_BIT_T bf;
} NX90_ECC_CTRL_STATUS_SBE_T;

/* --------------------------------------------------------------------- */
/* Register ecc_ctrl_status_dbe */
/* => ECC status DBE: */
/*    This register collects double bit error (DBE) status information. */
/*    In case of ECC DBE, a bit of the appropriate RAM in this register will be set. */
/*    Bits can be reset by writing '1' to the apprpriate bit position (write to clear). */
/*    If a SBE or DBE bit is set, IRQ signal will be asserted. */
/*    Note: No mask register is required, as error correction can be enabled for each RAM separately. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_ecc_ctrl_status_dbe          0x00000130U
#define Adr_NX90_ecc_ctrl_app_ecc_ctrl_status_dbe 0xFF801330U
#define Adr_NX90_ecc_ctrl_status_dbe              0xFF801330U
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe         0x00000000U

#define MSK_NX90_ecc_ctrl_status_dbe_intram0                0x00000001U
#define SRT_NX90_ecc_ctrl_status_dbe_intram0                0
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram0           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram0        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intram1                0x00000002U
#define SRT_NX90_ecc_ctrl_status_dbe_intram1                1
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram1           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram1        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intram2                0x00000004U
#define SRT_NX90_ecc_ctrl_status_dbe_intram2                2
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram2           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram2        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intram3                0x00000008U
#define SRT_NX90_ecc_ctrl_status_dbe_intram3                3
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram3           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram3        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intram4                0x00000010U
#define SRT_NX90_ecc_ctrl_status_dbe_intram4                4
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram4           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram4        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intram5                0x00000020U
#define SRT_NX90_ecc_ctrl_status_dbe_intram5                5
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram5           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram5        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intram6                0x00000040U
#define SRT_NX90_ecc_ctrl_status_dbe_intram6                6
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram6           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram6        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intram7                0x00000080U
#define SRT_NX90_ecc_ctrl_status_dbe_intram7                7
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intram7           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intram7        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_intramhs               0x00000100U
#define SRT_NX90_ecc_ctrl_status_dbe_intramhs               8
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_intramhs          0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_intramhs       0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_rpec0_pram         0x00000200U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_rpec0_pram         9
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpec0_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpec0_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_rpec1_pram         0x00000400U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_rpec1_pram         10
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpec1_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpec1_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_tpec0_pram         0x00000800U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_tpec0_pram         11
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpec0_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpec0_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_tpec1_pram         0x00001000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_tpec1_pram         12
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpec1_pram    0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpec1_pram 0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_dpram0             0x00002000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_dpram0             13
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_dpram0        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_dpram0     0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_dpram1             0x00004000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_dpram1             14
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_dpram1        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_dpram1     0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_rpu0_ram           0x00008000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_rpu0_ram           15
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpu0_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpu0_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_rpu1_ram           0x00010000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_rpu1_ram           16
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpu1_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_rpu1_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_tpu0_ram           0x00020000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_tpu0_ram           17
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpu0_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpu0_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_tpu1_ram           0x00040000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_tpu1_ram           18
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpu1_ram      0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_tpu1_ram   0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xc0_pfifo              0x00080000U
#define SRT_NX90_ecc_ctrl_status_dbe_xc0_pfifo              19
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xc0_pfifo         0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xc0_pfifo      0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xpic0_pram             0x00100000U
#define SRT_NX90_ecc_ctrl_status_dbe_xpic0_pram             20
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xpic0_pram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xpic0_pram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xpic1_pram             0x00200000U
#define SRT_NX90_ecc_ctrl_status_dbe_xpic1_pram             21
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xpic1_pram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xpic1_pram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xpic0_dram             0x00400000U
#define SRT_NX90_ecc_ctrl_status_dbe_xpic0_dram             22
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xpic0_dram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xpic0_dram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_xpic1_dram             0x00800000U
#define SRT_NX90_ecc_ctrl_status_dbe_xpic1_dram             23
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_xpic1_dram        0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_xpic1_dram     0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_iflash0                0x01000000U
#define SRT_NX90_ecc_ctrl_status_dbe_iflash0                24
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_iflash0           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_iflash0        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_iflash1                0x02000000U
#define SRT_NX90_ecc_ctrl_status_dbe_iflash1                25
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_iflash1           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_iflash1        0x00000000U
#define MSK_NX90_ecc_ctrl_status_dbe_iflash2                0x04000000U
#define SRT_NX90_ecc_ctrl_status_dbe_iflash2                26
#define DFLT_VAL_NX90_ecc_ctrl_status_dbe_iflash2           0x00000000U
#define DFLT_BF_VAL_NX90_ecc_ctrl_status_dbe_iflash2        0x00000000U

/* all used bits of 'NX90_ecc_ctrl_status_dbe': */
#define MSK_USED_BITS_NX90_ecc_ctrl_status_dbe 0x07ffffffU

enum {
  BFW_NX90_ecc_ctrl_status_dbe_intram0        = 1, /* [0] */
  BFW_NX90_ecc_ctrl_status_dbe_intram1        = 1, /* [1] */
  BFW_NX90_ecc_ctrl_status_dbe_intram2        = 1, /* [2] */
  BFW_NX90_ecc_ctrl_status_dbe_intram3        = 1, /* [3] */
  BFW_NX90_ecc_ctrl_status_dbe_intram4        = 1, /* [4] */
  BFW_NX90_ecc_ctrl_status_dbe_intram5        = 1, /* [5] */
  BFW_NX90_ecc_ctrl_status_dbe_intram6        = 1, /* [6] */
  BFW_NX90_ecc_ctrl_status_dbe_intram7        = 1, /* [7] */
  BFW_NX90_ecc_ctrl_status_dbe_intramhs       = 1, /* [8] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_rpec0_pram = 1, /* [9] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_rpec1_pram = 1, /* [10] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_tpec0_pram = 1, /* [11] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_tpec1_pram = 1, /* [12] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_dpram0     = 1, /* [13] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_dpram1     = 1, /* [14] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_rpu0_ram   = 1, /* [15] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_rpu1_ram   = 1, /* [16] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_tpu0_ram   = 1, /* [17] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_tpu1_ram   = 1, /* [18] */
  BFW_NX90_ecc_ctrl_status_dbe_xc0_pfifo      = 1, /* [19] */
  BFW_NX90_ecc_ctrl_status_dbe_xpic0_pram     = 1, /* [20] */
  BFW_NX90_ecc_ctrl_status_dbe_xpic1_pram     = 1, /* [21] */
  BFW_NX90_ecc_ctrl_status_dbe_xpic0_dram     = 1, /* [22] */
  BFW_NX90_ecc_ctrl_status_dbe_xpic1_dram     = 1, /* [23] */
  BFW_NX90_ecc_ctrl_status_dbe_iflash0        = 1, /* [24] */
  BFW_NX90_ecc_ctrl_status_dbe_iflash1        = 1, /* [25] */
  BFW_NX90_ecc_ctrl_status_dbe_iflash2        = 1, /* [26] */
  BFW_NX90_ecc_ctrl_status_dbe_reserved1      = 5  /* [31:27] */
};

typedef struct NX90_ECC_CTRL_STATUS_DBE_BIT_Ttag {
  unsigned int intram0        : BFW_NX90_ecc_ctrl_status_dbe_intram0;        /* INTRAM0 Double Bit Error occured        */
  unsigned int intram1        : BFW_NX90_ecc_ctrl_status_dbe_intram1;        /* INTRAM1 Double Bit Error occured        */
  unsigned int intram2        : BFW_NX90_ecc_ctrl_status_dbe_intram2;        /* INTRAM2 Double Bit Error occured        */
  unsigned int intram3        : BFW_NX90_ecc_ctrl_status_dbe_intram3;        /* INTRAM3 Double Bit Error occured        */
  unsigned int intram4        : BFW_NX90_ecc_ctrl_status_dbe_intram4;        /* INTRAM4 Double Bit Error occured        */
  unsigned int intram5        : BFW_NX90_ecc_ctrl_status_dbe_intram5;        /* INTRAM5 Double Bit Error occured        */
  unsigned int intram6        : BFW_NX90_ecc_ctrl_status_dbe_intram6;        /* INTRAM6 Double Bit Error occured        */
  unsigned int intram7        : BFW_NX90_ecc_ctrl_status_dbe_intram7;        /* INTRAM7 Double Bit Error occured        */
  unsigned int intramhs       : BFW_NX90_ecc_ctrl_status_dbe_intramhs;       /* INTRAMHS Double Bit Error occured       */
  unsigned int xc0_rpec0_pram : BFW_NX90_ecc_ctrl_status_dbe_xc0_rpec0_pram; /* XC0_RPEC0_PRAM Double Bit Error occured */
  unsigned int xc0_rpec1_pram : BFW_NX90_ecc_ctrl_status_dbe_xc0_rpec1_pram; /* XC0_RPEC1_PRAM Double Bit Error occured */
  unsigned int xc0_tpec0_pram : BFW_NX90_ecc_ctrl_status_dbe_xc0_tpec0_pram; /* XC0_TPEC0_PRAM Double Bit Error occured */
  unsigned int xc0_tpec1_pram : BFW_NX90_ecc_ctrl_status_dbe_xc0_tpec1_pram; /* XC0_TPEC1_PRAM Double Bit Error occured */
  unsigned int xc0_dpram0     : BFW_NX90_ecc_ctrl_status_dbe_xc0_dpram0;     /* XC0_DPRAM0 Double Bit Error occured     */
  unsigned int xc0_dpram1     : BFW_NX90_ecc_ctrl_status_dbe_xc0_dpram1;     /* XC0_DPRAM1 Double Bit Error occured     */
  unsigned int xc0_rpu0_ram   : BFW_NX90_ecc_ctrl_status_dbe_xc0_rpu0_ram;   /* XC0_RPU0_RAM Double Bit Error occured   */
  unsigned int xc0_rpu1_ram   : BFW_NX90_ecc_ctrl_status_dbe_xc0_rpu1_ram;   /* XC0_RPU1_RAM Double Bit Error occured   */
  unsigned int xc0_tpu0_ram   : BFW_NX90_ecc_ctrl_status_dbe_xc0_tpu0_ram;   /* XC0_TPU0_RAM Double Bit Error occured   */
  unsigned int xc0_tpu1_ram   : BFW_NX90_ecc_ctrl_status_dbe_xc0_tpu1_ram;   /* XC0_TPU1_RAM Double Bit Error occured   */
  unsigned int xc0_pfifo      : BFW_NX90_ecc_ctrl_status_dbe_xc0_pfifo;      /* XC0_PFIFO Double Bit Error occured      */
  unsigned int xpic0_pram     : BFW_NX90_ecc_ctrl_status_dbe_xpic0_pram;     /* XPIC0_PRAM Double Bit Error occured     */
  unsigned int xpic1_pram     : BFW_NX90_ecc_ctrl_status_dbe_xpic1_pram;     /* XPIC1_PRAM Double Bit Error occured     */
  unsigned int xpic0_dram     : BFW_NX90_ecc_ctrl_status_dbe_xpic0_dram;     /* XPIC0_DRAM Double Bit Error occured     */
  unsigned int xpic1_dram     : BFW_NX90_ecc_ctrl_status_dbe_xpic1_dram;     /* XPIC1_DRAM Double Bit Error occured     */
  unsigned int iflash0        : BFW_NX90_ecc_ctrl_status_dbe_iflash0;        /* IFLASH0 Double Bit Error occured        */
  unsigned int iflash1        : BFW_NX90_ecc_ctrl_status_dbe_iflash1;        /* IFLASH1 Double Bit Error occured        */
  unsigned int iflash2        : BFW_NX90_ecc_ctrl_status_dbe_iflash2;        /* IFLASH2 Double Bit Error occured        */
  unsigned int reserved1      : BFW_NX90_ecc_ctrl_status_dbe_reserved1;      /* reserved                                */
} NX90_ECC_CTRL_STATUS_DBE_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_ECC_CTRL_STATUS_DBE_BIT_T bf;
} NX90_ECC_CTRL_STATUS_DBE_T;


/* ===================================================================== */

/* AREA gpio_app */
/* Area of gpio_app, gpio_xpic_app */

/* ===================================================================== */

#define Addr_NX90_gpio_app      0xFF801400U
#define Addr_NX90_gpio_xpic_app 0xFF900200U

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg0 */
/* => GPIO_APP pin 0 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg0           0x00000000U
#define Adr_NX90_gpio_app_gpio_app_cfg0      0xFF801400U
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg0 0xFF900200U
#define DFLT_VAL_NX90_gpio_app_cfg0          0x00000000U

#define MSK_NX90_gpio_app_cfg0_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg0_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg0_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg0_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg0_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg0_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg0_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg0_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg0_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg0_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg0_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg0_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg0_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg0_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg0_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg0_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg0_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg0_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg0_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg0_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg0': */
#define MSK_USED_BITS_NX90_gpio_app_cfg0 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg0_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg0_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg0_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg0_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg0_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg0_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG0_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg0_mode;       /* defines the gp input or output mode - depends on io_cfg                                          */
                                                               /* Input modes:                                                                                     */
                                                               /*  0000: read mode                                                                                 */
                                                               /*  0001: capture continued at rising edge (allows gpio_app_irq on each capture)                    */
                                                               /*  0010: capture once at rising edge (reset gpio_app_irq to capture again)                         */
                                                               /*  0011: capture once at high level (reset gpio_app_irq to capture again)                          */
                                                               /* Output modes:                                                                                    */
                                                               /*  0100: set to 0                                                                                  */
                                                               /*  0101: set to 1                                                                                  */
                                                               /*  0110: set to gpio_app_line[0]                                                                   */
                                                               /*  0111: pwm mode, direct threshold update (might cause hazards on output)                         */
                                                               /*  1000: blink mode                                                                                */
                                                               /* Multi pin modes:                                                                                 */
                                                               /*  1111: pwm2-mode with threshold update at counter=0 from gpio_app_tc[n+1] register (hazard-free) */
  unsigned int inv        : BFW_NX90_gpio_app_cfg0_inv;        /* 1: invert input/output value                                                                     */
                                                               /* 0: do not invert input/output                                                                    */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg0_count_ref;  /* counter reference                                                                                */
                                                               /*  00: counter 0                                                                                   */
                                                               /*  01: counter 1                                                                                   */
                                                               /*  10: counter 2                                                                                   */
                                                               /*  11: sys_time (global system time)                                                               */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg0_blink_len;  /* Length of blink sequence minus 1 (blink mode only)                                               */
                                                               /*  00000: use bit 0 of gpio_app_tc                                                                 */
                                                               /*  00001: use bits 0..1 of gpio_app_tc                                                             */
                                                               /*  00010: use bits 0..2 of gpio_app_tc                                                             */
                                                               /*         ...                                                                                      */
                                                               /*  11111: use bits 0..31 of gpio_app_tc                                                            */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg0_blink_once; /* Run blink sequence only once (blink mode only)                                                   */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg0_reserved1;  /* reserved                                                                                         */
} NX90_GPIO_APP_CFG0_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG0_BIT_T bf;
} NX90_GPIO_APP_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg1 */
/* => GPIO_APP pin 1 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg1           0x00000004U
#define Adr_NX90_gpio_app_gpio_app_cfg1      0xFF801404U
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg1 0xFF900204U
#define DFLT_VAL_NX90_gpio_app_cfg1          0x00000000U

#define MSK_NX90_gpio_app_cfg1_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg1_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg1_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg1_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg1_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg1_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg1_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg1_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg1_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg1_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg1_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg1_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg1_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg1_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg1_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg1_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg1_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg1_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg1_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg1_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg1': */
#define MSK_USED_BITS_NX90_gpio_app_cfg1 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg1_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg1_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg1_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg1_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg1_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg1_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG1_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg1_mode;       /* analog to gpio_app_cfg0 */
  unsigned int inv        : BFW_NX90_gpio_app_cfg1_inv;        /* analog to gpio_app_cfg0 */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg1_count_ref;  /* analog to gpio_app_cfg0 */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg1_blink_len;  /* analog to gpio_app_cfg0 */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg1_blink_once; /* analog to gpio_app_cfg0 */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg1_reserved1;  /* reserved                */
} NX90_GPIO_APP_CFG1_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG1_BIT_T bf;
} NX90_GPIO_APP_CFG1_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg2 */
/* => GPIO_APP pin 2 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg2           0x00000008U
#define Adr_NX90_gpio_app_gpio_app_cfg2      0xFF801408U
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg2 0xFF900208U
#define DFLT_VAL_NX90_gpio_app_cfg2          0x00000000U

#define MSK_NX90_gpio_app_cfg2_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg2_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg2_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg2_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg2_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg2_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg2_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg2_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg2_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg2_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg2_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg2_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg2_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg2_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg2_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg2_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg2_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg2_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg2_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg2_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg2': */
#define MSK_USED_BITS_NX90_gpio_app_cfg2 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg2_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg2_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg2_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg2_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg2_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg2_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG2_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg2_mode;       /* analog to gpio_app_cfg0 */
  unsigned int inv        : BFW_NX90_gpio_app_cfg2_inv;        /* analog to gpio_app_cfg0 */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg2_count_ref;  /* analog to gpio_app_cfg0 */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg2_blink_len;  /* analog to gpio_app_cfg0 */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg2_blink_once; /* analog to gpio_app_cfg0 */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg2_reserved1;  /* reserved                */
} NX90_GPIO_APP_CFG2_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG2_BIT_T bf;
} NX90_GPIO_APP_CFG2_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg3 */
/* => GPIO_APP pin 3 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg3           0x0000000CU
#define Adr_NX90_gpio_app_gpio_app_cfg3      0xFF80140CU
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg3 0xFF90020CU
#define DFLT_VAL_NX90_gpio_app_cfg3          0x00000000U

#define MSK_NX90_gpio_app_cfg3_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg3_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg3_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg3_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg3_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg3_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg3_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg3_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg3_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg3_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg3_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg3_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg3_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg3_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg3_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg3_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg3_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg3_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg3_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg3_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg3': */
#define MSK_USED_BITS_NX90_gpio_app_cfg3 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg3_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg3_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg3_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg3_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg3_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg3_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG3_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg3_mode;       /* analog to gpio_app_cfg0 */
  unsigned int inv        : BFW_NX90_gpio_app_cfg3_inv;        /* analog to gpio_app_cfg0 */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg3_count_ref;  /* analog to gpio_app_cfg0 */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg3_blink_len;  /* analog to gpio_app_cfg0 */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg3_blink_once; /* analog to gpio_app_cfg0 */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg3_reserved1;  /* reserved                */
} NX90_GPIO_APP_CFG3_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG3_BIT_T bf;
} NX90_GPIO_APP_CFG3_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg4 */
/* => GPIO_APP pin 4 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg4           0x00000010U
#define Adr_NX90_gpio_app_gpio_app_cfg4      0xFF801410U
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg4 0xFF900210U
#define DFLT_VAL_NX90_gpio_app_cfg4          0x00000000U

#define MSK_NX90_gpio_app_cfg4_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg4_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg4_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg4_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg4_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg4_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg4_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg4_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg4_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg4_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg4_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg4_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg4_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg4_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg4_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg4_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg4_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg4_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg4_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg4_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg4': */
#define MSK_USED_BITS_NX90_gpio_app_cfg4 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg4_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg4_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg4_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg4_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg4_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg4_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG4_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg4_mode;       /* analog to gpio_app_cfg0 */
  unsigned int inv        : BFW_NX90_gpio_app_cfg4_inv;        /* analog to gpio_app_cfg0 */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg4_count_ref;  /* analog to gpio_app_cfg0 */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg4_blink_len;  /* analog to gpio_app_cfg0 */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg4_blink_once; /* analog to gpio_app_cfg0 */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg4_reserved1;  /* reserved                */
} NX90_GPIO_APP_CFG4_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG4_BIT_T bf;
} NX90_GPIO_APP_CFG4_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg5 */
/* => GPIO_APP pin 5 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg5           0x00000014U
#define Adr_NX90_gpio_app_gpio_app_cfg5      0xFF801414U
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg5 0xFF900214U
#define DFLT_VAL_NX90_gpio_app_cfg5          0x00000000U

#define MSK_NX90_gpio_app_cfg5_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg5_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg5_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg5_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg5_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg5_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg5_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg5_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg5_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg5_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg5_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg5_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg5_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg5_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg5_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg5_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg5_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg5_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg5_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg5_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg5': */
#define MSK_USED_BITS_NX90_gpio_app_cfg5 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg5_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg5_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg5_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg5_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg5_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg5_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG5_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg5_mode;       /* analog to gpio_app_cfg0 */
  unsigned int inv        : BFW_NX90_gpio_app_cfg5_inv;        /* analog to gpio_app_cfg0 */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg5_count_ref;  /* analog to gpio_app_cfg0 */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg5_blink_len;  /* analog to gpio_app_cfg0 */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg5_blink_once; /* analog to gpio_app_cfg0 */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg5_reserved1;  /* reserved                */
} NX90_GPIO_APP_CFG5_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG5_BIT_T bf;
} NX90_GPIO_APP_CFG5_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg6 */
/* => GPIO_APP pin 6 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg6           0x00000018U
#define Adr_NX90_gpio_app_gpio_app_cfg6      0xFF801418U
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg6 0xFF900218U
#define DFLT_VAL_NX90_gpio_app_cfg6          0x00000000U

#define MSK_NX90_gpio_app_cfg6_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg6_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg6_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg6_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg6_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg6_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg6_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg6_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg6_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg6_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg6_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg6_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg6_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg6_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg6_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg6_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg6_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg6_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg6_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg6_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg6': */
#define MSK_USED_BITS_NX90_gpio_app_cfg6 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg6_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg6_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg6_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg6_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg6_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg6_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG6_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg6_mode;       /* analog to gpio_app_cfg0 */
  unsigned int inv        : BFW_NX90_gpio_app_cfg6_inv;        /* analog to gpio_app_cfg0 */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg6_count_ref;  /* analog to gpio_app_cfg0 */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg6_blink_len;  /* analog to gpio_app_cfg0 */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg6_blink_once; /* analog to gpio_app_cfg0 */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg6_reserved1;  /* reserved                */
} NX90_GPIO_APP_CFG6_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG6_BIT_T bf;
} NX90_GPIO_APP_CFG6_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cfg7 */
/* => GPIO_APP pin 7 config register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cfg7           0x0000001CU
#define Adr_NX90_gpio_app_gpio_app_cfg7      0xFF80141CU
#define Adr_NX90_gpio_xpic_app_gpio_app_cfg7 0xFF90021CU
#define DFLT_VAL_NX90_gpio_app_cfg7          0x00000000U

#define MSK_NX90_gpio_app_cfg7_mode               0x0000000fU
#define SRT_NX90_gpio_app_cfg7_mode               0
#define DFLT_VAL_NX90_gpio_app_cfg7_mode          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg7_mode       0x00000000U
#define MSK_NX90_gpio_app_cfg7_inv                0x00000010U
#define SRT_NX90_gpio_app_cfg7_inv                4
#define DFLT_VAL_NX90_gpio_app_cfg7_inv           0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg7_inv        0x00000000U
#define MSK_NX90_gpio_app_cfg7_count_ref          0x00000060U
#define SRT_NX90_gpio_app_cfg7_count_ref          5
#define DFLT_VAL_NX90_gpio_app_cfg7_count_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg7_count_ref  0x00000000U
#define MSK_NX90_gpio_app_cfg7_blink_len          0x00000f80U
#define SRT_NX90_gpio_app_cfg7_blink_len          7
#define DFLT_VAL_NX90_gpio_app_cfg7_blink_len     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg7_blink_len  0x00000000U
#define MSK_NX90_gpio_app_cfg7_blink_once         0x00001000U
#define SRT_NX90_gpio_app_cfg7_blink_once         12
#define DFLT_VAL_NX90_gpio_app_cfg7_blink_once    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cfg7_blink_once 0x00000000U

/* all used bits of 'NX90_gpio_app_cfg7': */
#define MSK_USED_BITS_NX90_gpio_app_cfg7 0x00001fffU

enum {
  BFW_NX90_gpio_app_cfg7_mode       = 4,  /* [3:0] */
  BFW_NX90_gpio_app_cfg7_inv        = 1,  /* [4] */
  BFW_NX90_gpio_app_cfg7_count_ref  = 2,  /* [6:5] */
  BFW_NX90_gpio_app_cfg7_blink_len  = 5,  /* [11:7] */
  BFW_NX90_gpio_app_cfg7_blink_once = 1,  /* [12] */
  BFW_NX90_gpio_app_cfg7_reserved1  = 19  /* [31:13] */
};

typedef struct NX90_GPIO_APP_CFG7_BIT_Ttag {
  unsigned int mode       : BFW_NX90_gpio_app_cfg7_mode;       /* analog to gpio_app_cfg0 */
  unsigned int inv        : BFW_NX90_gpio_app_cfg7_inv;        /* analog to gpio_app_cfg0 */
  unsigned int count_ref  : BFW_NX90_gpio_app_cfg7_count_ref;  /* analog to gpio_app_cfg0 */
  unsigned int blink_len  : BFW_NX90_gpio_app_cfg7_blink_len;  /* analog to gpio_app_cfg0 */
  unsigned int blink_once : BFW_NX90_gpio_app_cfg7_blink_once; /* analog to gpio_app_cfg0 */
  unsigned int reserved1  : BFW_NX90_gpio_app_cfg7_reserved1;  /* reserved                */
} NX90_GPIO_APP_CFG7_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_CFG7_BIT_T bf;
} NX90_GPIO_APP_CFG7_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc0 */
/* => GPIO_APP pin 0 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc0           0x00000020U
#define Adr_NX90_gpio_app_gpio_app_tc0      0xFF801420U
#define Adr_NX90_gpio_xpic_app_gpio_app_tc0 0xFF900220U
#define DFLT_VAL_NX90_gpio_app_tc0          0x00000000U

#define MSK_NX90_gpio_app_tc0_val         0xffffffffU
#define SRT_NX90_gpio_app_tc0_val         0
#define DFLT_VAL_NX90_gpio_app_tc0_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc0_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc0': */
#define MSK_USED_BITS_NX90_gpio_app_tc0 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc0_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC0_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc0_val; /*  Threshold/Capture register:                                                                                           */
                                                /*  PWM mode (threshold):                                                                                                 */
                                                /* { |                                                                                                                    */
                                                /*    The counter threshold value equals the number of inactive clock cycles per period (cycles with pwm=0).              */
                                                /*    Therefore it is interpreted differently in symmetrical and asymmetrical counter mode:                               */
                                                /*    Asymmetrical mode (sawtooth): pwm = (counter >= gpio_app_tc)                                                        */
                                                /*    Symmetrical mode (triangle) : Counter is compared with gpio_app_tc[31:1], gpio_app_tc[0] extends the inactive phase */
                                                /*    by 1 clock cycle only while counting up. This allows running a 10 ns resolution even in symmetrical mode.}          */
                                                /*  Capture mode (capture register)                                                                                       */
                                                /* { |                                                                                                                    */
                                                /*    In the capture mode, this register holds the captured counter value.}                                               */
                                                /*  Blink mode (blink sequence)                                                                                           */
                                                /* { |                                                                                                                    */
                                                /*    In the blink mode, this register holds the blinking sequence starting from bit 0.}                                  */
} NX90_GPIO_APP_TC0_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC0_BIT_T bf;
} NX90_GPIO_APP_TC0_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc1 */
/* => GPIO_APP pin 1 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc1           0x00000024U
#define Adr_NX90_gpio_app_gpio_app_tc1      0xFF801424U
#define Adr_NX90_gpio_xpic_app_gpio_app_tc1 0xFF900224U
#define DFLT_VAL_NX90_gpio_app_tc1          0x00000000U

#define MSK_NX90_gpio_app_tc1_val         0xffffffffU
#define SRT_NX90_gpio_app_tc1_val         0
#define DFLT_VAL_NX90_gpio_app_tc1_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc1_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc1': */
#define MSK_USED_BITS_NX90_gpio_app_tc1 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc1_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC1_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc1_val; /* analog to gpio_app_tc0 */
} NX90_GPIO_APP_TC1_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC1_BIT_T bf;
} NX90_GPIO_APP_TC1_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc2 */
/* => GPIO_APP pin 2 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc2           0x00000028U
#define Adr_NX90_gpio_app_gpio_app_tc2      0xFF801428U
#define Adr_NX90_gpio_xpic_app_gpio_app_tc2 0xFF900228U
#define DFLT_VAL_NX90_gpio_app_tc2          0x00000000U

#define MSK_NX90_gpio_app_tc2_val         0xffffffffU
#define SRT_NX90_gpio_app_tc2_val         0
#define DFLT_VAL_NX90_gpio_app_tc2_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc2_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc2': */
#define MSK_USED_BITS_NX90_gpio_app_tc2 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc2_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC2_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc2_val; /* analog to gpio_app_tc0 */
} NX90_GPIO_APP_TC2_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC2_BIT_T bf;
} NX90_GPIO_APP_TC2_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc3 */
/* => GPIO_APP pin 3 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc3           0x0000002CU
#define Adr_NX90_gpio_app_gpio_app_tc3      0xFF80142CU
#define Adr_NX90_gpio_xpic_app_gpio_app_tc3 0xFF90022CU
#define DFLT_VAL_NX90_gpio_app_tc3          0x00000000U

#define MSK_NX90_gpio_app_tc3_val         0xffffffffU
#define SRT_NX90_gpio_app_tc3_val         0
#define DFLT_VAL_NX90_gpio_app_tc3_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc3_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc3': */
#define MSK_USED_BITS_NX90_gpio_app_tc3 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc3_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC3_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc3_val; /* analog to gpio_app_tc0 */
} NX90_GPIO_APP_TC3_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC3_BIT_T bf;
} NX90_GPIO_APP_TC3_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc4 */
/* => GPIO_APP pin 4 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc4           0x00000030U
#define Adr_NX90_gpio_app_gpio_app_tc4      0xFF801430U
#define Adr_NX90_gpio_xpic_app_gpio_app_tc4 0xFF900230U
#define DFLT_VAL_NX90_gpio_app_tc4          0x00000000U

#define MSK_NX90_gpio_app_tc4_val         0xffffffffU
#define SRT_NX90_gpio_app_tc4_val         0
#define DFLT_VAL_NX90_gpio_app_tc4_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc4_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc4': */
#define MSK_USED_BITS_NX90_gpio_app_tc4 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc4_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC4_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc4_val; /* analog to gpio_app_tc0 */
} NX90_GPIO_APP_TC4_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC4_BIT_T bf;
} NX90_GPIO_APP_TC4_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc5 */
/* => GPIO_APP pin 5 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc5           0x00000034U
#define Adr_NX90_gpio_app_gpio_app_tc5      0xFF801434U
#define Adr_NX90_gpio_xpic_app_gpio_app_tc5 0xFF900234U
#define DFLT_VAL_NX90_gpio_app_tc5          0x00000000U

#define MSK_NX90_gpio_app_tc5_val         0xffffffffU
#define SRT_NX90_gpio_app_tc5_val         0
#define DFLT_VAL_NX90_gpio_app_tc5_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc5_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc5': */
#define MSK_USED_BITS_NX90_gpio_app_tc5 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc5_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC5_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc5_val; /* analog to gpio_app_tc0 */
} NX90_GPIO_APP_TC5_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC5_BIT_T bf;
} NX90_GPIO_APP_TC5_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc6 */
/* => GPIO_APP pin 6 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc6           0x00000038U
#define Adr_NX90_gpio_app_gpio_app_tc6      0xFF801438U
#define Adr_NX90_gpio_xpic_app_gpio_app_tc6 0xFF900238U
#define DFLT_VAL_NX90_gpio_app_tc6          0x00000000U

#define MSK_NX90_gpio_app_tc6_val         0xffffffffU
#define SRT_NX90_gpio_app_tc6_val         0
#define DFLT_VAL_NX90_gpio_app_tc6_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc6_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc6': */
#define MSK_USED_BITS_NX90_gpio_app_tc6 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc6_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC6_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc6_val; /* analog to gpio_app_tc0 */
} NX90_GPIO_APP_TC6_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC6_BIT_T bf;
} NX90_GPIO_APP_TC6_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_tc7 */
/* => GPIO_APP pin 7 threshold or capture register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_tc7           0x0000003CU
#define Adr_NX90_gpio_app_gpio_app_tc7      0xFF80143CU
#define Adr_NX90_gpio_xpic_app_gpio_app_tc7 0xFF90023CU
#define DFLT_VAL_NX90_gpio_app_tc7          0x00000000U

#define MSK_NX90_gpio_app_tc7_val         0xffffffffU
#define SRT_NX90_gpio_app_tc7_val         0
#define DFLT_VAL_NX90_gpio_app_tc7_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_tc7_val 0x00000000U

/* all used bits of 'NX90_gpio_app_tc7': */
#define MSK_USED_BITS_NX90_gpio_app_tc7 0xffffffffU

enum {
  BFW_NX90_gpio_app_tc7_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_TC7_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_tc7_val; /* analog to gpio_app_tc0 */
} NX90_GPIO_APP_TC7_BIT_T;

typedef union {
  uint32_t                val;
  NX90_GPIO_APP_TC7_BIT_T bf;
} NX90_GPIO_APP_TC7_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter0_ctrl */
/* => GPIO_APP counter0 control register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter0_ctrl           0x00000040U
#define Adr_NX90_gpio_app_gpio_app_counter0_ctrl      0xFF801440U
#define Adr_NX90_gpio_xpic_app_gpio_app_counter0_ctrl 0xFF900240U
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl          0x00000000U

#define MSK_NX90_gpio_app_counter0_ctrl_run               0x00000001U
#define SRT_NX90_gpio_app_counter0_ctrl_run               0
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_ctrl_run       0x00000000U
#define MSK_NX90_gpio_app_counter0_ctrl_sym_nasym         0x00000002U
#define SRT_NX90_gpio_app_counter0_ctrl_sym_nasym         1
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_ctrl_sym_nasym 0x00000000U
#define MSK_NX90_gpio_app_counter0_ctrl_irq_en            0x00000004U
#define SRT_NX90_gpio_app_counter0_ctrl_irq_en            2
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_ctrl_irq_en    0x00000000U
#define MSK_NX90_gpio_app_counter0_ctrl_sel_event         0x00000008U
#define SRT_NX90_gpio_app_counter0_ctrl_sel_event         3
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_ctrl_sel_event 0x00000000U
#define MSK_NX90_gpio_app_counter0_ctrl_once              0x00000010U
#define SRT_NX90_gpio_app_counter0_ctrl_once              4
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_ctrl_once      0x00000000U
#define MSK_NX90_gpio_app_counter0_ctrl_event_act         0x00000060U
#define SRT_NX90_gpio_app_counter0_ctrl_event_act         5
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_ctrl_event_act 0x00000000U
#define MSK_NX90_gpio_app_counter0_ctrl_gpio_ref          0x00000380U
#define SRT_NX90_gpio_app_counter0_ctrl_gpio_ref          7
#define DFLT_VAL_NX90_gpio_app_counter0_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX90_gpio_app_counter0_ctrl': */
#define MSK_USED_BITS_NX90_gpio_app_counter0_ctrl 0x000003ffU

enum {
  BFW_NX90_gpio_app_counter0_ctrl_run       = 1,  /* [0] */
  BFW_NX90_gpio_app_counter0_ctrl_sym_nasym = 1,  /* [1] */
  BFW_NX90_gpio_app_counter0_ctrl_irq_en    = 1,  /* [2] */
  BFW_NX90_gpio_app_counter0_ctrl_sel_event = 1,  /* [3] */
  BFW_NX90_gpio_app_counter0_ctrl_once      = 1,  /* [4] */
  BFW_NX90_gpio_app_counter0_ctrl_event_act = 2,  /* [6:5] */
  BFW_NX90_gpio_app_counter0_ctrl_gpio_ref  = 3,  /* [9:7] */
  BFW_NX90_gpio_app_counter0_ctrl_reserved1 = 22  /* [31:10] */
};

typedef struct NX90_GPIO_APP_COUNTER0_CTRL_BIT_Ttag {
  unsigned int run       : BFW_NX90_gpio_app_counter0_ctrl_run;       /* 1: start counter, counter is running                                                                           */
                                                                      /* 0: stop counter                                                                                                */
  unsigned int sym_nasym : BFW_NX90_gpio_app_counter0_ctrl_sym_nasym; /* 1: symmetric mode (triangle)                                                                                   */
                                                                      /* 0: asymmetric mode (sawtooth)                                                                                  */
  unsigned int irq_en    : BFW_NX90_gpio_app_counter0_ctrl_irq_en;    /* 1: enable interrupt request on sel_event                                                                       */
                                                                      /* 0: disable interrupt request                                                                                   */
  unsigned int sel_event : BFW_NX90_gpio_app_counter0_ctrl_sel_event; /* select external event                                                                                          */
                                                                      /* 0: high level, invert gpio in register gpio_app_cfg to select low level                                        */
                                                                      /* 1: pos. edge, invert gpio in register gpio_app_cfg to select neg. edge                                         */
  unsigned int once      : BFW_NX90_gpio_app_counter0_ctrl_once;      /* 1: count once (reset run bit after 1 period)                                                                   */
                                                                      /* 0: count continuously                                                                                          */
  unsigned int event_act : BFW_NX90_gpio_app_counter0_ctrl_event_act; /* Define action of selected external event (dependent on sel_event, gpio_ref)                                    */
                                                                      /* 00: count every clock cycle, ignore external events                                                            */
                                                                      /* 01: count only external events (edge or level according to bit sel_event)                                      */
                                                                      /* 10: enable watchdog mode of counter (external event will be reset without IRQ, overflow generates IRQ).        */
                                                                      /* 11: enable automatic run mode (external event sets run bit, used for DC-DC PWM in combination with bit once=1) */
  unsigned int gpio_ref  : BFW_NX90_gpio_app_counter0_ctrl_gpio_ref;  /* gpio reference (0 - 7)                                                                                         */
  unsigned int reserved1 : BFW_NX90_gpio_app_counter0_ctrl_reserved1; /* reserved                                                                                                       */
} NX90_GPIO_APP_COUNTER0_CTRL_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_GPIO_APP_COUNTER0_CTRL_BIT_T bf;
} NX90_GPIO_APP_COUNTER0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter1_ctrl */
/* => GPIO_APP counter1 control register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter1_ctrl           0x00000044U
#define Adr_NX90_gpio_app_gpio_app_counter1_ctrl      0xFF801444U
#define Adr_NX90_gpio_xpic_app_gpio_app_counter1_ctrl 0xFF900244U
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl          0x00000000U

#define MSK_NX90_gpio_app_counter1_ctrl_run               0x00000001U
#define SRT_NX90_gpio_app_counter1_ctrl_run               0
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_ctrl_run       0x00000000U
#define MSK_NX90_gpio_app_counter1_ctrl_sym_nasym         0x00000002U
#define SRT_NX90_gpio_app_counter1_ctrl_sym_nasym         1
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_ctrl_sym_nasym 0x00000000U
#define MSK_NX90_gpio_app_counter1_ctrl_irq_en            0x00000004U
#define SRT_NX90_gpio_app_counter1_ctrl_irq_en            2
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_ctrl_irq_en    0x00000000U
#define MSK_NX90_gpio_app_counter1_ctrl_sel_event         0x00000008U
#define SRT_NX90_gpio_app_counter1_ctrl_sel_event         3
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_ctrl_sel_event 0x00000000U
#define MSK_NX90_gpio_app_counter1_ctrl_once              0x00000010U
#define SRT_NX90_gpio_app_counter1_ctrl_once              4
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_ctrl_once      0x00000000U
#define MSK_NX90_gpio_app_counter1_ctrl_event_act         0x00000060U
#define SRT_NX90_gpio_app_counter1_ctrl_event_act         5
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_ctrl_event_act 0x00000000U
#define MSK_NX90_gpio_app_counter1_ctrl_gpio_ref          0x00000380U
#define SRT_NX90_gpio_app_counter1_ctrl_gpio_ref          7
#define DFLT_VAL_NX90_gpio_app_counter1_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX90_gpio_app_counter1_ctrl': */
#define MSK_USED_BITS_NX90_gpio_app_counter1_ctrl 0x000003ffU

enum {
  BFW_NX90_gpio_app_counter1_ctrl_run       = 1,  /* [0] */
  BFW_NX90_gpio_app_counter1_ctrl_sym_nasym = 1,  /* [1] */
  BFW_NX90_gpio_app_counter1_ctrl_irq_en    = 1,  /* [2] */
  BFW_NX90_gpio_app_counter1_ctrl_sel_event = 1,  /* [3] */
  BFW_NX90_gpio_app_counter1_ctrl_once      = 1,  /* [4] */
  BFW_NX90_gpio_app_counter1_ctrl_event_act = 2,  /* [6:5] */
  BFW_NX90_gpio_app_counter1_ctrl_gpio_ref  = 3,  /* [9:7] */
  BFW_NX90_gpio_app_counter1_ctrl_reserved1 = 22  /* [31:10] */
};

typedef struct NX90_GPIO_APP_COUNTER1_CTRL_BIT_Ttag {
  unsigned int run       : BFW_NX90_gpio_app_counter1_ctrl_run;       /* analog to gpio_app_counter0_ctrl */
  unsigned int sym_nasym : BFW_NX90_gpio_app_counter1_ctrl_sym_nasym; /* analog to gpio_app_counter0_ctrl */
  unsigned int irq_en    : BFW_NX90_gpio_app_counter1_ctrl_irq_en;    /* analog to gpio_app_counter0_ctrl */
  unsigned int sel_event : BFW_NX90_gpio_app_counter1_ctrl_sel_event; /* analog to gpio_app_counter0_ctrl */
  unsigned int once      : BFW_NX90_gpio_app_counter1_ctrl_once;      /* analog to gpio_app_counter0_ctrl */
  unsigned int event_act : BFW_NX90_gpio_app_counter1_ctrl_event_act; /* analog to gpio_app_counter0_ctrl */
  unsigned int gpio_ref  : BFW_NX90_gpio_app_counter1_ctrl_gpio_ref;  /* analog to gpio_app_counter0_ctrl */
  unsigned int reserved1 : BFW_NX90_gpio_app_counter1_ctrl_reserved1; /* reserved                         */
} NX90_GPIO_APP_COUNTER1_CTRL_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_GPIO_APP_COUNTER1_CTRL_BIT_T bf;
} NX90_GPIO_APP_COUNTER1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter2_ctrl */
/* => GPIO_APP counter2 control register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter2_ctrl           0x00000048U
#define Adr_NX90_gpio_app_gpio_app_counter2_ctrl      0xFF801448U
#define Adr_NX90_gpio_xpic_app_gpio_app_counter2_ctrl 0xFF900248U
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl          0x00000000U

#define MSK_NX90_gpio_app_counter2_ctrl_run               0x00000001U
#define SRT_NX90_gpio_app_counter2_ctrl_run               0
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_ctrl_run       0x00000000U
#define MSK_NX90_gpio_app_counter2_ctrl_sym_nasym         0x00000002U
#define SRT_NX90_gpio_app_counter2_ctrl_sym_nasym         1
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_ctrl_sym_nasym 0x00000000U
#define MSK_NX90_gpio_app_counter2_ctrl_irq_en            0x00000004U
#define SRT_NX90_gpio_app_counter2_ctrl_irq_en            2
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_ctrl_irq_en    0x00000000U
#define MSK_NX90_gpio_app_counter2_ctrl_sel_event         0x00000008U
#define SRT_NX90_gpio_app_counter2_ctrl_sel_event         3
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_ctrl_sel_event 0x00000000U
#define MSK_NX90_gpio_app_counter2_ctrl_once              0x00000010U
#define SRT_NX90_gpio_app_counter2_ctrl_once              4
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_ctrl_once      0x00000000U
#define MSK_NX90_gpio_app_counter2_ctrl_event_act         0x00000060U
#define SRT_NX90_gpio_app_counter2_ctrl_event_act         5
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_ctrl_event_act 0x00000000U
#define MSK_NX90_gpio_app_counter2_ctrl_gpio_ref          0x00000380U
#define SRT_NX90_gpio_app_counter2_ctrl_gpio_ref          7
#define DFLT_VAL_NX90_gpio_app_counter2_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX90_gpio_app_counter2_ctrl': */
#define MSK_USED_BITS_NX90_gpio_app_counter2_ctrl 0x000003ffU

enum {
  BFW_NX90_gpio_app_counter2_ctrl_run       = 1,  /* [0] */
  BFW_NX90_gpio_app_counter2_ctrl_sym_nasym = 1,  /* [1] */
  BFW_NX90_gpio_app_counter2_ctrl_irq_en    = 1,  /* [2] */
  BFW_NX90_gpio_app_counter2_ctrl_sel_event = 1,  /* [3] */
  BFW_NX90_gpio_app_counter2_ctrl_once      = 1,  /* [4] */
  BFW_NX90_gpio_app_counter2_ctrl_event_act = 2,  /* [6:5] */
  BFW_NX90_gpio_app_counter2_ctrl_gpio_ref  = 3,  /* [9:7] */
  BFW_NX90_gpio_app_counter2_ctrl_reserved1 = 22  /* [31:10] */
};

typedef struct NX90_GPIO_APP_COUNTER2_CTRL_BIT_Ttag {
  unsigned int run       : BFW_NX90_gpio_app_counter2_ctrl_run;       /* analog to gpio_app_counter0_ctrl */
  unsigned int sym_nasym : BFW_NX90_gpio_app_counter2_ctrl_sym_nasym; /* analog to gpio_app_counter0_ctrl */
  unsigned int irq_en    : BFW_NX90_gpio_app_counter2_ctrl_irq_en;    /* analog to gpio_app_counter0_ctrl */
  unsigned int sel_event : BFW_NX90_gpio_app_counter2_ctrl_sel_event; /* analog to gpio_app_counter0_ctrl */
  unsigned int once      : BFW_NX90_gpio_app_counter2_ctrl_once;      /* analog to gpio_app_counter0_ctrl */
  unsigned int event_act : BFW_NX90_gpio_app_counter2_ctrl_event_act; /* analog to gpio_app_counter0_ctrl */
  unsigned int gpio_ref  : BFW_NX90_gpio_app_counter2_ctrl_gpio_ref;  /* analog to gpio_app_counter0_ctrl */
  unsigned int reserved1 : BFW_NX90_gpio_app_counter2_ctrl_reserved1; /* reserved                         */
} NX90_GPIO_APP_COUNTER2_CTRL_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_GPIO_APP_COUNTER2_CTRL_BIT_T bf;
} NX90_GPIO_APP_COUNTER2_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter0_max */
/* => GPIO_APP counter0 max value: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter0_max           0x0000004CU
#define Adr_NX90_gpio_app_gpio_app_counter0_max      0xFF80144CU
#define Adr_NX90_gpio_xpic_app_gpio_app_counter0_max 0xFF90024CU
#define DFLT_VAL_NX90_gpio_app_counter0_max          0x00000000U

#define MSK_NX90_gpio_app_counter0_max_val         0xffffffffU
#define SRT_NX90_gpio_app_counter0_max_val         0
#define DFLT_VAL_NX90_gpio_app_counter0_max_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_max_val 0x00000000U

/* all used bits of 'NX90_gpio_app_counter0_max': */
#define MSK_USED_BITS_NX90_gpio_app_counter0_max 0xffffffffU

enum {
  BFW_NX90_gpio_app_counter0_max_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_COUNTER0_MAX_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_counter0_max_val; /* Asymmetric mode: Counting period in cc + 1 */
                                                         /* Symmetric mode: Counting period in cc      */
} NX90_GPIO_APP_COUNTER0_MAX_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_COUNTER0_MAX_BIT_T bf;
} NX90_GPIO_APP_COUNTER0_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter1_max */
/* => GPIO_APP counter1 max value: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter1_max           0x00000050U
#define Adr_NX90_gpio_app_gpio_app_counter1_max      0xFF801450U
#define Adr_NX90_gpio_xpic_app_gpio_app_counter1_max 0xFF900250U
#define DFLT_VAL_NX90_gpio_app_counter1_max          0x00000000U

#define MSK_NX90_gpio_app_counter1_max_val         0xffffffffU
#define SRT_NX90_gpio_app_counter1_max_val         0
#define DFLT_VAL_NX90_gpio_app_counter1_max_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_max_val 0x00000000U

/* all used bits of 'NX90_gpio_app_counter1_max': */
#define MSK_USED_BITS_NX90_gpio_app_counter1_max 0xffffffffU

enum {
  BFW_NX90_gpio_app_counter1_max_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_COUNTER1_MAX_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_counter1_max_val; /* Asymmetric mode: Counting period in cc + 1 */
                                                         /* Symmetric mode: Counting period in cc      */
} NX90_GPIO_APP_COUNTER1_MAX_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_COUNTER1_MAX_BIT_T bf;
} NX90_GPIO_APP_COUNTER1_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter2_max */
/* => GPIO_APP counter2 max value: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter2_max           0x00000054U
#define Adr_NX90_gpio_app_gpio_app_counter2_max      0xFF801454U
#define Adr_NX90_gpio_xpic_app_gpio_app_counter2_max 0xFF900254U
#define DFLT_VAL_NX90_gpio_app_counter2_max          0x00000000U

#define MSK_NX90_gpio_app_counter2_max_val         0xffffffffU
#define SRT_NX90_gpio_app_counter2_max_val         0
#define DFLT_VAL_NX90_gpio_app_counter2_max_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_max_val 0x00000000U

/* all used bits of 'NX90_gpio_app_counter2_max': */
#define MSK_USED_BITS_NX90_gpio_app_counter2_max 0xffffffffU

enum {
  BFW_NX90_gpio_app_counter2_max_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_COUNTER2_MAX_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_counter2_max_val; /* Asymmetric mode: Counting period in cc + 1 */
                                                         /* Symmetric mode: Counting period in cc      */
} NX90_GPIO_APP_COUNTER2_MAX_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_COUNTER2_MAX_BIT_T bf;
} NX90_GPIO_APP_COUNTER2_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter0_cnt */
/* => GPIO_APP counter0 current value: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter0_cnt           0x00000058U
#define Adr_NX90_gpio_app_gpio_app_counter0_cnt      0xFF801458U
#define Adr_NX90_gpio_xpic_app_gpio_app_counter0_cnt 0xFF900258U
#define DFLT_VAL_NX90_gpio_app_counter0_cnt          0x00000000U

#define MSK_NX90_gpio_app_counter0_cnt_val         0xffffffffU
#define SRT_NX90_gpio_app_counter0_cnt_val         0
#define DFLT_VAL_NX90_gpio_app_counter0_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter0_cnt_val 0x00000000U

/* all used bits of 'NX90_gpio_app_counter0_cnt': */
#define MSK_USED_BITS_NX90_gpio_app_counter0_cnt 0xffffffffU

enum {
  BFW_NX90_gpio_app_counter0_cnt_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_COUNTER0_CNT_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_counter0_cnt_val; /* current counter value */
} NX90_GPIO_APP_COUNTER0_CNT_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_COUNTER0_CNT_BIT_T bf;
} NX90_GPIO_APP_COUNTER0_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter1_cnt */
/* => GPIO_APP counter1 current value: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter1_cnt           0x0000005CU
#define Adr_NX90_gpio_app_gpio_app_counter1_cnt      0xFF80145CU
#define Adr_NX90_gpio_xpic_app_gpio_app_counter1_cnt 0xFF90025CU
#define DFLT_VAL_NX90_gpio_app_counter1_cnt          0x00000000U

#define MSK_NX90_gpio_app_counter1_cnt_val         0xffffffffU
#define SRT_NX90_gpio_app_counter1_cnt_val         0
#define DFLT_VAL_NX90_gpio_app_counter1_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter1_cnt_val 0x00000000U

/* all used bits of 'NX90_gpio_app_counter1_cnt': */
#define MSK_USED_BITS_NX90_gpio_app_counter1_cnt 0xffffffffU

enum {
  BFW_NX90_gpio_app_counter1_cnt_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_COUNTER1_CNT_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_counter1_cnt_val; /* current counter value */
} NX90_GPIO_APP_COUNTER1_CNT_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_COUNTER1_CNT_BIT_T bf;
} NX90_GPIO_APP_COUNTER1_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_counter2_cnt */
/* => GPIO_APP counter2 current value: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_counter2_cnt           0x00000060U
#define Adr_NX90_gpio_app_gpio_app_counter2_cnt      0xFF801460U
#define Adr_NX90_gpio_xpic_app_gpio_app_counter2_cnt 0xFF900260U
#define DFLT_VAL_NX90_gpio_app_counter2_cnt          0x00000000U

#define MSK_NX90_gpio_app_counter2_cnt_val         0xffffffffU
#define SRT_NX90_gpio_app_counter2_cnt_val         0
#define DFLT_VAL_NX90_gpio_app_counter2_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_counter2_cnt_val 0x00000000U

/* all used bits of 'NX90_gpio_app_counter2_cnt': */
#define MSK_USED_BITS_NX90_gpio_app_counter2_cnt 0xffffffffU

enum {
  BFW_NX90_gpio_app_counter2_cnt_val = 32  /* [31:0] */
};

typedef struct NX90_GPIO_APP_COUNTER2_CNT_BIT_Ttag {
  unsigned int val : BFW_NX90_gpio_app_counter2_cnt_val; /* current counter value */
} NX90_GPIO_APP_COUNTER2_CNT_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_COUNTER2_CNT_BIT_T bf;
} NX90_GPIO_APP_COUNTER2_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_line */
/* => GPIO_APP line register */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_line           0x00000064U
#define Adr_NX90_gpio_app_gpio_app_line      0xFF801464U
#define Adr_NX90_gpio_xpic_app_gpio_app_line 0xFF900264U
#define DFLT_VAL_NX90_gpio_app_line          0x00000000U

#define MSK_NX90_gpio_app_line_val         0x000000ffU
#define SRT_NX90_gpio_app_line_val         0
#define DFLT_VAL_NX90_gpio_app_line_val    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_line_val 0x00000000U

/* all used bits of 'NX90_gpio_app_line': */
#define MSK_USED_BITS_NX90_gpio_app_line 0x000000ffU

enum {
  BFW_NX90_gpio_app_line_val       = 8,  /* [7:0] */
  BFW_NX90_gpio_app_line_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_GPIO_APP_LINE_BIT_Ttag {
  unsigned int val       : BFW_NX90_gpio_app_line_val;       /* gpio_app output values */
  unsigned int reserved1 : BFW_NX90_gpio_app_line_reserved1; /* reserved               */
} NX90_GPIO_APP_LINE_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_GPIO_APP_LINE_BIT_T bf;
} NX90_GPIO_APP_LINE_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_in */
/* => GPIO_APP latched inputs register: */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_in           0x00000068U
#define Adr_NX90_gpio_app_gpio_app_in      0xFF801468U
#define Adr_NX90_gpio_xpic_app_gpio_app_in 0xFF900268U

#define MSK_NX90_gpio_app_in_val 0x000000ffU
#define SRT_NX90_gpio_app_in_val 0

/* all used bits of 'NX90_gpio_app_in': */
#define MSK_USED_BITS_NX90_gpio_app_in 0x000000ffU

enum {
  BFW_NX90_gpio_app_in_val       = 8,  /* [7:0] */
  BFW_NX90_gpio_app_in_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_GPIO_APP_IN_BIT_Ttag {
  unsigned int val       : BFW_NX90_gpio_app_in_val;       /* gpio_app input values */
  unsigned int reserved1 : BFW_NX90_gpio_app_in_reserved1; /* reserved              */
} NX90_GPIO_APP_IN_BIT_T;

typedef union {
  uint32_t               val;
  NX90_GPIO_APP_IN_BIT_T bf;
} NX90_GPIO_APP_IN_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_irq_raw */
/* => GPIO_APP raw IRQ register: */
/*    Read access shows the status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the corresponding IRQ. */
/*    Write access with '0' does not influence this bit. */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_irq_raw           0x0000006CU
#define Adr_NX90_gpio_app_gpio_app_irq_raw      0xFF80146CU
#define Adr_NX90_gpio_xpic_app_gpio_app_irq_raw 0xFF90026CU
#define DFLT_VAL_NX90_gpio_app_irq_raw          0x00000000U

#define MSK_NX90_gpio_app_irq_raw_gpio_app0         0x00000001U
#define SRT_NX90_gpio_app_irq_raw_gpio_app0         0
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app0    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app0 0x00000000U
#define MSK_NX90_gpio_app_irq_raw_gpio_app1         0x00000002U
#define SRT_NX90_gpio_app_irq_raw_gpio_app1         1
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app1    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app1 0x00000000U
#define MSK_NX90_gpio_app_irq_raw_gpio_app2         0x00000004U
#define SRT_NX90_gpio_app_irq_raw_gpio_app2         2
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app2    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app2 0x00000000U
#define MSK_NX90_gpio_app_irq_raw_gpio_app3         0x00000008U
#define SRT_NX90_gpio_app_irq_raw_gpio_app3         3
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app3    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app3 0x00000000U
#define MSK_NX90_gpio_app_irq_raw_gpio_app4         0x00000010U
#define SRT_NX90_gpio_app_irq_raw_gpio_app4         4
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app4    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app4 0x00000000U
#define MSK_NX90_gpio_app_irq_raw_gpio_app5         0x00000020U
#define SRT_NX90_gpio_app_irq_raw_gpio_app5         5
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app5    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app5 0x00000000U
#define MSK_NX90_gpio_app_irq_raw_gpio_app6         0x00000040U
#define SRT_NX90_gpio_app_irq_raw_gpio_app6         6
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app6    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app6 0x00000000U
#define MSK_NX90_gpio_app_irq_raw_gpio_app7         0x00000080U
#define SRT_NX90_gpio_app_irq_raw_gpio_app7         7
#define DFLT_VAL_NX90_gpio_app_irq_raw_gpio_app7    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_raw_gpio_app7 0x00000000U

/* all used bits of 'NX90_gpio_app_irq_raw': */
#define MSK_USED_BITS_NX90_gpio_app_irq_raw 0x000000ffU

enum {
  BFW_NX90_gpio_app_irq_raw_gpio_app0 = 1,  /* [0] */
  BFW_NX90_gpio_app_irq_raw_gpio_app1 = 1,  /* [1] */
  BFW_NX90_gpio_app_irq_raw_gpio_app2 = 1,  /* [2] */
  BFW_NX90_gpio_app_irq_raw_gpio_app3 = 1,  /* [3] */
  BFW_NX90_gpio_app_irq_raw_gpio_app4 = 1,  /* [4] */
  BFW_NX90_gpio_app_irq_raw_gpio_app5 = 1,  /* [5] */
  BFW_NX90_gpio_app_irq_raw_gpio_app6 = 1,  /* [6] */
  BFW_NX90_gpio_app_irq_raw_gpio_app7 = 1,  /* [7] */
  BFW_NX90_gpio_app_irq_raw_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_GPIO_APP_IRQ_RAW_BIT_Ttag {
  unsigned int gpio_app0 : BFW_NX90_gpio_app_irq_raw_gpio_app0; /* Interrupt bit for GPIO_APP0 */
  unsigned int gpio_app1 : BFW_NX90_gpio_app_irq_raw_gpio_app1; /* Interrupt bit for GPIO_APP1 */
  unsigned int gpio_app2 : BFW_NX90_gpio_app_irq_raw_gpio_app2; /* Interrupt bit for GPIO_APP2 */
  unsigned int gpio_app3 : BFW_NX90_gpio_app_irq_raw_gpio_app3; /* Interrupt bit for GPIO_APP3 */
  unsigned int gpio_app4 : BFW_NX90_gpio_app_irq_raw_gpio_app4; /* Interrupt bit for GPIO_APP4 */
  unsigned int gpio_app5 : BFW_NX90_gpio_app_irq_raw_gpio_app5; /* Interrupt bit for GPIO_APP5 */
  unsigned int gpio_app6 : BFW_NX90_gpio_app_irq_raw_gpio_app6; /* Interrupt bit for GPIO_APP6 */
  unsigned int gpio_app7 : BFW_NX90_gpio_app_irq_raw_gpio_app7; /* Interrupt bit for GPIO_APP7 */
  unsigned int reserved1 : BFW_NX90_gpio_app_irq_raw_reserved1; /* reserved                    */
} NX90_GPIO_APP_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_GPIO_APP_IRQ_RAW_BIT_T bf;
} NX90_GPIO_APP_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_irq_masked */
/* => GPIO_APP masked IRQ register: */
/*    This register exists 2x for the different system busses (address areas) it is connected to. \ */
/*    This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_irq_masked           0x00000070U
#define Adr_NX90_gpio_app_gpio_app_irq_masked      0xFF801470U
#define Adr_NX90_gpio_xpic_app_gpio_app_irq_masked 0xFF900270U

#define MSK_NX90_gpio_app_irq_masked_gpio_app0 0x00000001U
#define SRT_NX90_gpio_app_irq_masked_gpio_app0 0
#define MSK_NX90_gpio_app_irq_masked_gpio_app1 0x00000002U
#define SRT_NX90_gpio_app_irq_masked_gpio_app1 1
#define MSK_NX90_gpio_app_irq_masked_gpio_app2 0x00000004U
#define SRT_NX90_gpio_app_irq_masked_gpio_app2 2
#define MSK_NX90_gpio_app_irq_masked_gpio_app3 0x00000008U
#define SRT_NX90_gpio_app_irq_masked_gpio_app3 3
#define MSK_NX90_gpio_app_irq_masked_gpio_app4 0x00000010U
#define SRT_NX90_gpio_app_irq_masked_gpio_app4 4
#define MSK_NX90_gpio_app_irq_masked_gpio_app5 0x00000020U
#define SRT_NX90_gpio_app_irq_masked_gpio_app5 5
#define MSK_NX90_gpio_app_irq_masked_gpio_app6 0x00000040U
#define SRT_NX90_gpio_app_irq_masked_gpio_app6 6
#define MSK_NX90_gpio_app_irq_masked_gpio_app7 0x00000080U
#define SRT_NX90_gpio_app_irq_masked_gpio_app7 7

/* all used bits of 'NX90_gpio_app_irq_masked': */
#define MSK_USED_BITS_NX90_gpio_app_irq_masked 0x000000ffU

enum {
  BFW_NX90_gpio_app_irq_masked_gpio_app0 = 1,  /* [0] */
  BFW_NX90_gpio_app_irq_masked_gpio_app1 = 1,  /* [1] */
  BFW_NX90_gpio_app_irq_masked_gpio_app2 = 1,  /* [2] */
  BFW_NX90_gpio_app_irq_masked_gpio_app3 = 1,  /* [3] */
  BFW_NX90_gpio_app_irq_masked_gpio_app4 = 1,  /* [4] */
  BFW_NX90_gpio_app_irq_masked_gpio_app5 = 1,  /* [5] */
  BFW_NX90_gpio_app_irq_masked_gpio_app6 = 1,  /* [6] */
  BFW_NX90_gpio_app_irq_masked_gpio_app7 = 1,  /* [7] */
  BFW_NX90_gpio_app_irq_masked_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_GPIO_APP_IRQ_MASKED_BIT_Ttag {
  unsigned int gpio_app0 : BFW_NX90_gpio_app_irq_masked_gpio_app0; /* Interrupt bit for GPIO_APP0 */
  unsigned int gpio_app1 : BFW_NX90_gpio_app_irq_masked_gpio_app1; /* Interrupt bit for GPIO_APP1 */
  unsigned int gpio_app2 : BFW_NX90_gpio_app_irq_masked_gpio_app2; /* Interrupt bit for GPIO_APP2 */
  unsigned int gpio_app3 : BFW_NX90_gpio_app_irq_masked_gpio_app3; /* Interrupt bit for GPIO_APP3 */
  unsigned int gpio_app4 : BFW_NX90_gpio_app_irq_masked_gpio_app4; /* Interrupt bit for GPIO_APP4 */
  unsigned int gpio_app5 : BFW_NX90_gpio_app_irq_masked_gpio_app5; /* Interrupt bit for GPIO_APP5 */
  unsigned int gpio_app6 : BFW_NX90_gpio_app_irq_masked_gpio_app6; /* Interrupt bit for GPIO_APP6 */
  unsigned int gpio_app7 : BFW_NX90_gpio_app_irq_masked_gpio_app7; /* Interrupt bit for GPIO_APP7 */
  unsigned int reserved1 : BFW_NX90_gpio_app_irq_masked_reserved1; /* reserved                    */
} NX90_GPIO_APP_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_GPIO_APP_IRQ_MASKED_BIT_T bf;
} NX90_GPIO_APP_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_irq_mask_set */
/* => GPIO_APP interrupt mask set: */
/*    The interrupt mask register exists 2x for the different system busses (address areas) it is connected to. \ */
/*    This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. */
/*    The inlogic_app IRQ mask enables interrupt requests for ARM_APP. \ */
/*    The xpic_app_system IRQ mask enables interrupt requests for xPIC_APP. \ */
/*    Since different software tasks might change its bits, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets the interrupt mask bit (enables the interrupt request for the corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows the current interrupt mask. */
/*    Note: Before activating the interrupt mask, delete old pending interrupts by writing the same value to gpio_app_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_irq_mask_set           0x00000074U
#define Adr_NX90_gpio_app_gpio_app_irq_mask_set      0xFF801474U
#define Adr_NX90_gpio_xpic_app_gpio_app_irq_mask_set 0xFF900274U
#define DFLT_VAL_NX90_gpio_app_irq_mask_set          0x00000000U

#define MSK_NX90_gpio_app_irq_mask_set_gpio_app0         0x00000001U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app0         0
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app0    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app0 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_set_gpio_app1         0x00000002U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app1         1
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app1    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app1 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_set_gpio_app2         0x00000004U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app2         2
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app2    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app2 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_set_gpio_app3         0x00000008U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app3         3
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app3    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app3 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_set_gpio_app4         0x00000010U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app4         4
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app4    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app4 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_set_gpio_app5         0x00000020U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app5         5
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app5    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app5 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_set_gpio_app6         0x00000040U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app6         6
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app6    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app6 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_set_gpio_app7         0x00000080U
#define SRT_NX90_gpio_app_irq_mask_set_gpio_app7         7
#define DFLT_VAL_NX90_gpio_app_irq_mask_set_gpio_app7    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_set_gpio_app7 0x00000000U

/* all used bits of 'NX90_gpio_app_irq_mask_set': */
#define MSK_USED_BITS_NX90_gpio_app_irq_mask_set 0x000000ffU

enum {
  BFW_NX90_gpio_app_irq_mask_set_gpio_app0 = 1,  /* [0] */
  BFW_NX90_gpio_app_irq_mask_set_gpio_app1 = 1,  /* [1] */
  BFW_NX90_gpio_app_irq_mask_set_gpio_app2 = 1,  /* [2] */
  BFW_NX90_gpio_app_irq_mask_set_gpio_app3 = 1,  /* [3] */
  BFW_NX90_gpio_app_irq_mask_set_gpio_app4 = 1,  /* [4] */
  BFW_NX90_gpio_app_irq_mask_set_gpio_app5 = 1,  /* [5] */
  BFW_NX90_gpio_app_irq_mask_set_gpio_app6 = 1,  /* [6] */
  BFW_NX90_gpio_app_irq_mask_set_gpio_app7 = 1,  /* [7] */
  BFW_NX90_gpio_app_irq_mask_set_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_GPIO_APP_IRQ_MASK_SET_BIT_Ttag {
  unsigned int gpio_app0 : BFW_NX90_gpio_app_irq_mask_set_gpio_app0; /* Interrupt bit for GPIO_APP0 */
  unsigned int gpio_app1 : BFW_NX90_gpio_app_irq_mask_set_gpio_app1; /* Interrupt bit for GPIO_APP1 */
  unsigned int gpio_app2 : BFW_NX90_gpio_app_irq_mask_set_gpio_app2; /* Interrupt bit for GPIO_APP2 */
  unsigned int gpio_app3 : BFW_NX90_gpio_app_irq_mask_set_gpio_app3; /* Interrupt bit for GPIO_APP3 */
  unsigned int gpio_app4 : BFW_NX90_gpio_app_irq_mask_set_gpio_app4; /* Interrupt bit for GPIO_APP4 */
  unsigned int gpio_app5 : BFW_NX90_gpio_app_irq_mask_set_gpio_app5; /* Interrupt bit for GPIO_APP5 */
  unsigned int gpio_app6 : BFW_NX90_gpio_app_irq_mask_set_gpio_app6; /* Interrupt bit for GPIO_APP6 */
  unsigned int gpio_app7 : BFW_NX90_gpio_app_irq_mask_set_gpio_app7; /* Interrupt bit for GPIO_APP7 */
  unsigned int reserved1 : BFW_NX90_gpio_app_irq_mask_set_reserved1; /* reserved                    */
} NX90_GPIO_APP_IRQ_MASK_SET_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_IRQ_MASK_SET_BIT_T bf;
} NX90_GPIO_APP_IRQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_irq_mask_rst */
/* => GPIO_APP interrupt mask reset: */
/*    This reset mask serves to disable the interrupt requests for the corresponding interrupt sources. \ */
/*    Like irq_msk_set, this address exists for the following address areas: inlogic_app, xpic_app_system. */
/*    Write access with '1' resets the interrupt mask bit (disables the interrupt request for the corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows the current interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_irq_mask_rst           0x00000078U
#define Adr_NX90_gpio_app_gpio_app_irq_mask_rst      0xFF801478U
#define Adr_NX90_gpio_xpic_app_gpio_app_irq_mask_rst 0xFF900278U
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst          0x00000000U

#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app0         0x00000001U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app0         0
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app0    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app0 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app1         0x00000002U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app1         1
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app1    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app1 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app2         0x00000004U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app2         2
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app2    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app2 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app3         0x00000008U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app3         3
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app3    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app3 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app4         0x00000010U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app4         4
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app4    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app4 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app5         0x00000020U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app5         5
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app5    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app5 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app6         0x00000040U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app6         6
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app6    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app6 0x00000000U
#define MSK_NX90_gpio_app_irq_mask_rst_gpio_app7         0x00000080U
#define SRT_NX90_gpio_app_irq_mask_rst_gpio_app7         7
#define DFLT_VAL_NX90_gpio_app_irq_mask_rst_gpio_app7    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_irq_mask_rst_gpio_app7 0x00000000U

/* all used bits of 'NX90_gpio_app_irq_mask_rst': */
#define MSK_USED_BITS_NX90_gpio_app_irq_mask_rst 0x000000ffU

enum {
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app0 = 1,  /* [0] */
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app1 = 1,  /* [1] */
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app2 = 1,  /* [2] */
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app3 = 1,  /* [3] */
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app4 = 1,  /* [4] */
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app5 = 1,  /* [5] */
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app6 = 1,  /* [6] */
  BFW_NX90_gpio_app_irq_mask_rst_gpio_app7 = 1,  /* [7] */
  BFW_NX90_gpio_app_irq_mask_rst_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_GPIO_APP_IRQ_MASK_RST_BIT_Ttag {
  unsigned int gpio_app0 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app0; /* Interrupt bit for GPIO_APP0 */
  unsigned int gpio_app1 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app1; /* Interrupt bit for GPIO_APP1 */
  unsigned int gpio_app2 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app2; /* Interrupt bit for GPIO_APP2 */
  unsigned int gpio_app3 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app3; /* Interrupt bit for GPIO_APP3 */
  unsigned int gpio_app4 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app4; /* Interrupt bit for GPIO_APP4 */
  unsigned int gpio_app5 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app5; /* Interrupt bit for GPIO_APP5 */
  unsigned int gpio_app6 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app6; /* Interrupt bit for GPIO_APP6 */
  unsigned int gpio_app7 : BFW_NX90_gpio_app_irq_mask_rst_gpio_app7; /* Interrupt bit for GPIO_APP7 */
  unsigned int reserved1 : BFW_NX90_gpio_app_irq_mask_rst_reserved1; /* reserved                    */
} NX90_GPIO_APP_IRQ_MASK_RST_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_GPIO_APP_IRQ_MASK_RST_BIT_T bf;
} NX90_GPIO_APP_IRQ_MASK_RST_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cnt_irq_raw */
/* => Counter raw IRQ register: */
/*    Read access shows the status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the corresponding IRQ. */
/*    Write access with '0' does not influence this bit. */
/*    This register is accessible via address areas inlogic_app and xpic_app_system. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cnt_irq_raw           0x0000007CU
#define Adr_NX90_gpio_app_gpio_app_cnt_irq_raw      0xFF80147CU
#define Adr_NX90_gpio_xpic_app_gpio_app_cnt_irq_raw 0xFF90027CU
#define DFLT_VAL_NX90_gpio_app_cnt_irq_raw          0x00000000U

#define MSK_NX90_gpio_app_cnt_irq_raw_cnt0         0x00000001U
#define SRT_NX90_gpio_app_cnt_irq_raw_cnt0         0
#define DFLT_VAL_NX90_gpio_app_cnt_irq_raw_cnt0    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_raw_cnt0 0x00000000U
#define MSK_NX90_gpio_app_cnt_irq_raw_cnt1         0x00000002U
#define SRT_NX90_gpio_app_cnt_irq_raw_cnt1         1
#define DFLT_VAL_NX90_gpio_app_cnt_irq_raw_cnt1    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_raw_cnt1 0x00000000U
#define MSK_NX90_gpio_app_cnt_irq_raw_cnt2         0x00000004U
#define SRT_NX90_gpio_app_cnt_irq_raw_cnt2         2
#define DFLT_VAL_NX90_gpio_app_cnt_irq_raw_cnt2    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_raw_cnt2 0x00000000U

/* all used bits of 'NX90_gpio_app_cnt_irq_raw': */
#define MSK_USED_BITS_NX90_gpio_app_cnt_irq_raw 0x00000007U

enum {
  BFW_NX90_gpio_app_cnt_irq_raw_cnt0      = 1,  /* [0] */
  BFW_NX90_gpio_app_cnt_irq_raw_cnt1      = 1,  /* [1] */
  BFW_NX90_gpio_app_cnt_irq_raw_cnt2      = 1,  /* [2] */
  BFW_NX90_gpio_app_cnt_irq_raw_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_GPIO_APP_CNT_IRQ_RAW_BIT_Ttag {
  unsigned int cnt0      : BFW_NX90_gpio_app_cnt_irq_raw_cnt0;      /* Interrupt bit for counter0 */
  unsigned int cnt1      : BFW_NX90_gpio_app_cnt_irq_raw_cnt1;      /* Interrupt bit for counter1 */
  unsigned int cnt2      : BFW_NX90_gpio_app_cnt_irq_raw_cnt2;      /* Interrupt bit for counter2 */
  unsigned int reserved1 : BFW_NX90_gpio_app_cnt_irq_raw_reserved1; /* reserved                   */
} NX90_GPIO_APP_CNT_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_GPIO_APP_CNT_IRQ_RAW_BIT_T bf;
} NX90_GPIO_APP_CNT_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cnt_irq_masked */
/* => Counter masked IRQ register: */
/*    Read access shows the status of masked IRQs (cnt_irq_raw AND cnt_irq_mask). */
/*    This register exists 2x for the different system busses (address areas) it is connected to. \ */
/*    This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cnt_irq_masked           0x00000080U
#define Adr_NX90_gpio_app_gpio_app_cnt_irq_masked      0xFF801480U
#define Adr_NX90_gpio_xpic_app_gpio_app_cnt_irq_masked 0xFF900280U

#define MSK_NX90_gpio_app_cnt_irq_masked_cnt0 0x00000001U
#define SRT_NX90_gpio_app_cnt_irq_masked_cnt0 0
#define MSK_NX90_gpio_app_cnt_irq_masked_cnt1 0x00000002U
#define SRT_NX90_gpio_app_cnt_irq_masked_cnt1 1
#define MSK_NX90_gpio_app_cnt_irq_masked_cnt2 0x00000004U
#define SRT_NX90_gpio_app_cnt_irq_masked_cnt2 2

/* all used bits of 'NX90_gpio_app_cnt_irq_masked': */
#define MSK_USED_BITS_NX90_gpio_app_cnt_irq_masked 0x00000007U

enum {
  BFW_NX90_gpio_app_cnt_irq_masked_cnt0      = 1,  /* [0] */
  BFW_NX90_gpio_app_cnt_irq_masked_cnt1      = 1,  /* [1] */
  BFW_NX90_gpio_app_cnt_irq_masked_cnt2      = 1,  /* [2] */
  BFW_NX90_gpio_app_cnt_irq_masked_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_GPIO_APP_CNT_IRQ_MASKED_BIT_Ttag {
  unsigned int cnt0      : BFW_NX90_gpio_app_cnt_irq_masked_cnt0;      /* Interrupt bit for counter0 */
  unsigned int cnt1      : BFW_NX90_gpio_app_cnt_irq_masked_cnt1;      /* Interrupt bit for counter1 */
  unsigned int cnt2      : BFW_NX90_gpio_app_cnt_irq_masked_cnt2;      /* Interrupt bit for counter2 */
  unsigned int reserved1 : BFW_NX90_gpio_app_cnt_irq_masked_reserved1; /* reserved                   */
} NX90_GPIO_APP_CNT_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_GPIO_APP_CNT_IRQ_MASKED_BIT_T bf;
} NX90_GPIO_APP_CNT_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cnt_irq_mask_set */
/* => Counter interrupt mask set: */
/*    The interrupt mask register exists 2x for the different system busses (address areas) it is connected to. \ */
/*    This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. */
/*    The inlogic_app IRQ mask enables interrupt requests for ARM_APP. \ */
/*    The xpic_app_system IRQ mask enables interrupt requests for xPIC_APP. \ */
/*    Since different software tasks might change its bits, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets the interrupt mask bit (enables the interrupt request for the corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows the current interrupt mask. */
/*    Note: Before activating the interrupt mask, delete old pending interrupts by writing the same value to cnt_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cnt_irq_mask_set           0x00000084U
#define Adr_NX90_gpio_app_gpio_app_cnt_irq_mask_set      0xFF801484U
#define Adr_NX90_gpio_xpic_app_gpio_app_cnt_irq_mask_set 0xFF900284U
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_set          0x00000000U

#define MSK_NX90_gpio_app_cnt_irq_mask_set_cnt0         0x00000001U
#define SRT_NX90_gpio_app_cnt_irq_mask_set_cnt0         0
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_set_cnt0    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_mask_set_cnt0 0x00000000U
#define MSK_NX90_gpio_app_cnt_irq_mask_set_cnt1         0x00000002U
#define SRT_NX90_gpio_app_cnt_irq_mask_set_cnt1         1
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_set_cnt1    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_mask_set_cnt1 0x00000000U
#define MSK_NX90_gpio_app_cnt_irq_mask_set_cnt2         0x00000004U
#define SRT_NX90_gpio_app_cnt_irq_mask_set_cnt2         2
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_set_cnt2    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_mask_set_cnt2 0x00000000U

/* all used bits of 'NX90_gpio_app_cnt_irq_mask_set': */
#define MSK_USED_BITS_NX90_gpio_app_cnt_irq_mask_set 0x00000007U

enum {
  BFW_NX90_gpio_app_cnt_irq_mask_set_cnt0      = 1,  /* [0] */
  BFW_NX90_gpio_app_cnt_irq_mask_set_cnt1      = 1,  /* [1] */
  BFW_NX90_gpio_app_cnt_irq_mask_set_cnt2      = 1,  /* [2] */
  BFW_NX90_gpio_app_cnt_irq_mask_set_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_GPIO_APP_CNT_IRQ_MASK_SET_BIT_Ttag {
  unsigned int cnt0      : BFW_NX90_gpio_app_cnt_irq_mask_set_cnt0;      /* Interrupt bit for counter0 */
  unsigned int cnt1      : BFW_NX90_gpio_app_cnt_irq_mask_set_cnt1;      /* Interrupt bit for counter1 */
  unsigned int cnt2      : BFW_NX90_gpio_app_cnt_irq_mask_set_cnt2;      /* Interrupt bit for counter2 */
  unsigned int reserved1 : BFW_NX90_gpio_app_cnt_irq_mask_set_reserved1; /* reserved                   */
} NX90_GPIO_APP_CNT_IRQ_MASK_SET_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_GPIO_APP_CNT_IRQ_MASK_SET_BIT_T bf;
} NX90_GPIO_APP_CNT_IRQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register gpio_app_cnt_irq_mask_rst */
/* => Counter interrupt mask reset: */
/*    This reset mask serves to disable the interrupt requests for the corresponding interrupt sources. \ */
/*    Like cnt_irq_msk_set, this address exists for the following address areas: inlogic_app, xpic_app_system. */
/*    Write access with '1' resets the interrupt mask bit (disables the interrupt request for the corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows the current interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_gpio_app_cnt_irq_mask_rst           0x00000088U
#define Adr_NX90_gpio_app_gpio_app_cnt_irq_mask_rst      0xFF801488U
#define Adr_NX90_gpio_xpic_app_gpio_app_cnt_irq_mask_rst 0xFF900288U
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_rst          0x00000000U

#define MSK_NX90_gpio_app_cnt_irq_mask_rst_cnt0         0x00000001U
#define SRT_NX90_gpio_app_cnt_irq_mask_rst_cnt0         0
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_rst_cnt0    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_mask_rst_cnt0 0x00000000U
#define MSK_NX90_gpio_app_cnt_irq_mask_rst_cnt1         0x00000002U
#define SRT_NX90_gpio_app_cnt_irq_mask_rst_cnt1         1
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_rst_cnt1    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_mask_rst_cnt1 0x00000000U
#define MSK_NX90_gpio_app_cnt_irq_mask_rst_cnt2         0x00000004U
#define SRT_NX90_gpio_app_cnt_irq_mask_rst_cnt2         2
#define DFLT_VAL_NX90_gpio_app_cnt_irq_mask_rst_cnt2    0x00000000U
#define DFLT_BF_VAL_NX90_gpio_app_cnt_irq_mask_rst_cnt2 0x00000000U

/* all used bits of 'NX90_gpio_app_cnt_irq_mask_rst': */
#define MSK_USED_BITS_NX90_gpio_app_cnt_irq_mask_rst 0x00000007U

enum {
  BFW_NX90_gpio_app_cnt_irq_mask_rst_cnt0      = 1,  /* [0] */
  BFW_NX90_gpio_app_cnt_irq_mask_rst_cnt1      = 1,  /* [1] */
  BFW_NX90_gpio_app_cnt_irq_mask_rst_cnt2      = 1,  /* [2] */
  BFW_NX90_gpio_app_cnt_irq_mask_rst_reserved1 = 29  /* [31:3] */
};

typedef struct NX90_GPIO_APP_CNT_IRQ_MASK_RST_BIT_Ttag {
  unsigned int cnt0      : BFW_NX90_gpio_app_cnt_irq_mask_rst_cnt0;      /* Interrupt bit for counter0 */
  unsigned int cnt1      : BFW_NX90_gpio_app_cnt_irq_mask_rst_cnt1;      /* Interrupt bit for counter1 */
  unsigned int cnt2      : BFW_NX90_gpio_app_cnt_irq_mask_rst_cnt2;      /* Interrupt bit for counter2 */
  unsigned int reserved1 : BFW_NX90_gpio_app_cnt_irq_mask_rst_reserved1; /* reserved                   */
} NX90_GPIO_APP_CNT_IRQ_MASK_RST_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_GPIO_APP_CNT_IRQ_MASK_RST_BIT_T bf;
} NX90_GPIO_APP_CNT_IRQ_MASK_RST_T;


/* ===================================================================== */

/* AREA intlogic_systime_lt */
/* Area of systime_lt_app, systime_lt_xpic_app */

/* ===================================================================== */

#define Addr_NX90_systime_lt_app      0xFF801540U
#define Addr_NX90_systime_lt_xpic_app 0xFF9001C0U

/* --------------------------------------------------------------------- */
/* Register intlogic_lt_systime_com_ns */
/* => systime_com_ns last latched value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intlogic_lt_systime_com_ns                 0x00000000U
#define Adr_NX90_systime_lt_app_intlogic_lt_systime_com_ns      0xFF801540U
#define Adr_NX90_systime_lt_xpic_app_intlogic_lt_systime_com_ns 0xFF9001C0U

#define MSK_NX90_intlogic_lt_systime_com_ns_val 0xffffffffU
#define SRT_NX90_intlogic_lt_systime_com_ns_val 0

/* all used bits of 'NX90_intlogic_lt_systime_com_ns': */
#define MSK_USED_BITS_NX90_intlogic_lt_systime_com_ns 0xffffffffU

enum {
  BFW_NX90_intlogic_lt_systime_com_ns_val = 32  /* [31:0] */
};

typedef struct NX90_INTLOGIC_LT_SYSTIME_COM_NS_BIT_Ttag {
  unsigned int val : BFW_NX90_intlogic_lt_systime_com_ns_val; /* systime_com_ns last latched value */
} NX90_INTLOGIC_LT_SYSTIME_COM_NS_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_INTLOGIC_LT_SYSTIME_COM_NS_BIT_T bf;
} NX90_INTLOGIC_LT_SYSTIME_COM_NS_T;

/* --------------------------------------------------------------------- */
/* Register intlogic_lt_systime_com_s */
/* => systime_com_s last latched value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intlogic_lt_systime_com_s                 0x00000004U
#define Adr_NX90_systime_lt_app_intlogic_lt_systime_com_s      0xFF801544U
#define Adr_NX90_systime_lt_xpic_app_intlogic_lt_systime_com_s 0xFF9001C4U

#define MSK_NX90_intlogic_lt_systime_com_s_val 0xffffffffU
#define SRT_NX90_intlogic_lt_systime_com_s_val 0

/* all used bits of 'NX90_intlogic_lt_systime_com_s': */
#define MSK_USED_BITS_NX90_intlogic_lt_systime_com_s 0xffffffffU

enum {
  BFW_NX90_intlogic_lt_systime_com_s_val = 32  /* [31:0] */
};

typedef struct NX90_INTLOGIC_LT_SYSTIME_COM_S_BIT_Ttag {
  unsigned int val : BFW_NX90_intlogic_lt_systime_com_s_val; /* systime_com_s last latched value */
} NX90_INTLOGIC_LT_SYSTIME_COM_S_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_INTLOGIC_LT_SYSTIME_COM_S_BIT_T bf;
} NX90_INTLOGIC_LT_SYSTIME_COM_S_T;

/* --------------------------------------------------------------------- */
/* Register intlogic_lt_systime_com_uc_ns */
/* => systime_com_uc_ns last latched value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intlogic_lt_systime_com_uc_ns                 0x00000008U
#define Adr_NX90_systime_lt_app_intlogic_lt_systime_com_uc_ns      0xFF801548U
#define Adr_NX90_systime_lt_xpic_app_intlogic_lt_systime_com_uc_ns 0xFF9001C8U

#define MSK_NX90_intlogic_lt_systime_com_uc_ns_val 0xffffffffU
#define SRT_NX90_intlogic_lt_systime_com_uc_ns_val 0

/* all used bits of 'NX90_intlogic_lt_systime_com_uc_ns': */
#define MSK_USED_BITS_NX90_intlogic_lt_systime_com_uc_ns 0xffffffffU

enum {
  BFW_NX90_intlogic_lt_systime_com_uc_ns_val = 32  /* [31:0] */
};

typedef struct NX90_INTLOGIC_LT_SYSTIME_COM_UC_NS_BIT_Ttag {
  unsigned int val : BFW_NX90_intlogic_lt_systime_com_uc_ns_val; /* systime_com_uc_ns last latched value */
} NX90_INTLOGIC_LT_SYSTIME_COM_UC_NS_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_INTLOGIC_LT_SYSTIME_COM_UC_NS_BIT_T bf;
} NX90_INTLOGIC_LT_SYSTIME_COM_UC_NS_T;

/* --------------------------------------------------------------------- */
/* Register intlogic_lt_systime_com_uc_s */
/* => systime_com_uc_s last latched value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intlogic_lt_systime_com_uc_s                 0x0000000CU
#define Adr_NX90_systime_lt_app_intlogic_lt_systime_com_uc_s      0xFF80154CU
#define Adr_NX90_systime_lt_xpic_app_intlogic_lt_systime_com_uc_s 0xFF9001CCU

#define MSK_NX90_intlogic_lt_systime_com_uc_s_val 0xffffffffU
#define SRT_NX90_intlogic_lt_systime_com_uc_s_val 0

/* all used bits of 'NX90_intlogic_lt_systime_com_uc_s': */
#define MSK_USED_BITS_NX90_intlogic_lt_systime_com_uc_s 0xffffffffU

enum {
  BFW_NX90_intlogic_lt_systime_com_uc_s_val = 32  /* [31:0] */
};

typedef struct NX90_INTLOGIC_LT_SYSTIME_COM_UC_S_BIT_Ttag {
  unsigned int val : BFW_NX90_intlogic_lt_systime_com_uc_s_val; /* systime_com_uc_s last latched value */
} NX90_INTLOGIC_LT_SYSTIME_COM_UC_S_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_INTLOGIC_LT_SYSTIME_COM_UC_S_BIT_T bf;
} NX90_INTLOGIC_LT_SYSTIME_COM_UC_S_T;

/* --------------------------------------------------------------------- */
/* Register intlogic_lt_systime_app_ns */
/* => systime_app_ns last latched value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intlogic_lt_systime_app_ns                 0x00000010U
#define Adr_NX90_systime_lt_app_intlogic_lt_systime_app_ns      0xFF801550U
#define Adr_NX90_systime_lt_xpic_app_intlogic_lt_systime_app_ns 0xFF9001D0U

#define MSK_NX90_intlogic_lt_systime_app_ns_val 0xffffffffU
#define SRT_NX90_intlogic_lt_systime_app_ns_val 0

/* all used bits of 'NX90_intlogic_lt_systime_app_ns': */
#define MSK_USED_BITS_NX90_intlogic_lt_systime_app_ns 0xffffffffU

enum {
  BFW_NX90_intlogic_lt_systime_app_ns_val = 32  /* [31:0] */
};

typedef struct NX90_INTLOGIC_LT_SYSTIME_APP_NS_BIT_Ttag {
  unsigned int val : BFW_NX90_intlogic_lt_systime_app_ns_val; /* systime_app_ns last latched value */
} NX90_INTLOGIC_LT_SYSTIME_APP_NS_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_INTLOGIC_LT_SYSTIME_APP_NS_BIT_T bf;
} NX90_INTLOGIC_LT_SYSTIME_APP_NS_T;

/* --------------------------------------------------------------------- */
/* Register intlogic_lt_systime_app_s */
/* => systime_app_s last latched value */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intlogic_lt_systime_app_s                 0x00000014U
#define Adr_NX90_systime_lt_app_intlogic_lt_systime_app_s      0xFF801554U
#define Adr_NX90_systime_lt_xpic_app_intlogic_lt_systime_app_s 0xFF9001D4U

#define MSK_NX90_intlogic_lt_systime_app_s_val 0xffffffffU
#define SRT_NX90_intlogic_lt_systime_app_s_val 0

/* all used bits of 'NX90_intlogic_lt_systime_app_s': */
#define MSK_USED_BITS_NX90_intlogic_lt_systime_app_s 0xffffffffU

enum {
  BFW_NX90_intlogic_lt_systime_app_s_val = 32  /* [31:0] */
};

typedef struct NX90_INTLOGIC_LT_SYSTIME_APP_S_BIT_Ttag {
  unsigned int val : BFW_NX90_intlogic_lt_systime_app_s_val; /* systime_app_s last latched value */
} NX90_INTLOGIC_LT_SYSTIME_APP_S_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_INTLOGIC_LT_SYSTIME_APP_S_BIT_T bf;
} NX90_INTLOGIC_LT_SYSTIME_APP_S_T;

/* --------------------------------------------------------------------- */
/* Register intlogic_lt_systimes_latch */
/* => latch systimes by writing 1'b1 to the assigned bit */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_intlogic_lt_systimes_latch                 0x00000018U
#define Adr_NX90_systime_lt_app_intlogic_lt_systimes_latch      0xFF801558U
#define Adr_NX90_systime_lt_xpic_app_intlogic_lt_systimes_latch 0xFF9001D8U
#define DFLT_VAL_NX90_intlogic_lt_systimes_latch                0x00000000U

#define MSK_NX90_intlogic_lt_systimes_latch_systime_com_ns            0x00000001U
#define SRT_NX90_intlogic_lt_systimes_latch_systime_com_ns            0
#define DFLT_VAL_NX90_intlogic_lt_systimes_latch_systime_com_ns       0x00000000U
#define DFLT_BF_VAL_NX90_intlogic_lt_systimes_latch_systime_com_ns    0x00000000U
#define MSK_NX90_intlogic_lt_systimes_latch_systime_com_s             0x00000002U
#define SRT_NX90_intlogic_lt_systimes_latch_systime_com_s             1
#define DFLT_VAL_NX90_intlogic_lt_systimes_latch_systime_com_s        0x00000000U
#define DFLT_BF_VAL_NX90_intlogic_lt_systimes_latch_systime_com_s     0x00000000U
#define MSK_NX90_intlogic_lt_systimes_latch_systime_com_uc_ns         0x00000004U
#define SRT_NX90_intlogic_lt_systimes_latch_systime_com_uc_ns         2
#define DFLT_VAL_NX90_intlogic_lt_systimes_latch_systime_com_uc_ns    0x00000000U
#define DFLT_BF_VAL_NX90_intlogic_lt_systimes_latch_systime_com_uc_ns 0x00000000U
#define MSK_NX90_intlogic_lt_systimes_latch_systime_com_uc_s          0x00000008U
#define SRT_NX90_intlogic_lt_systimes_latch_systime_com_uc_s          3
#define DFLT_VAL_NX90_intlogic_lt_systimes_latch_systime_com_uc_s     0x00000000U
#define DFLT_BF_VAL_NX90_intlogic_lt_systimes_latch_systime_com_uc_s  0x00000000U
#define MSK_NX90_intlogic_lt_systimes_latch_systime_app_ns            0x00000010U
#define SRT_NX90_intlogic_lt_systimes_latch_systime_app_ns            4
#define DFLT_VAL_NX90_intlogic_lt_systimes_latch_systime_app_ns       0x00000000U
#define DFLT_BF_VAL_NX90_intlogic_lt_systimes_latch_systime_app_ns    0x00000000U
#define MSK_NX90_intlogic_lt_systimes_latch_systime_app_s             0x00000020U
#define SRT_NX90_intlogic_lt_systimes_latch_systime_app_s             5
#define DFLT_VAL_NX90_intlogic_lt_systimes_latch_systime_app_s        0x00000000U
#define DFLT_BF_VAL_NX90_intlogic_lt_systimes_latch_systime_app_s     0x00000000U

/* all used bits of 'NX90_intlogic_lt_systimes_latch': */
#define MSK_USED_BITS_NX90_intlogic_lt_systimes_latch 0x0000003fU

enum {
  BFW_NX90_intlogic_lt_systimes_latch_systime_com_ns    = 1,  /* [0] */
  BFW_NX90_intlogic_lt_systimes_latch_systime_com_s     = 1,  /* [1] */
  BFW_NX90_intlogic_lt_systimes_latch_systime_com_uc_ns = 1,  /* [2] */
  BFW_NX90_intlogic_lt_systimes_latch_systime_com_uc_s  = 1,  /* [3] */
  BFW_NX90_intlogic_lt_systimes_latch_systime_app_ns    = 1,  /* [4] */
  BFW_NX90_intlogic_lt_systimes_latch_systime_app_s     = 1,  /* [5] */
  BFW_NX90_intlogic_lt_systimes_latch_reserved1         = 26  /* [31:6] */
};

typedef struct NX90_INTLOGIC_LT_SYSTIMES_LATCH_BIT_Ttag {
  unsigned int systime_com_ns    : BFW_NX90_intlogic_lt_systimes_latch_systime_com_ns;    /*          */
  unsigned int systime_com_s     : BFW_NX90_intlogic_lt_systimes_latch_systime_com_s;     /*          */
  unsigned int systime_com_uc_ns : BFW_NX90_intlogic_lt_systimes_latch_systime_com_uc_ns; /*          */
  unsigned int systime_com_uc_s  : BFW_NX90_intlogic_lt_systimes_latch_systime_com_uc_s;  /*          */
  unsigned int systime_app_ns    : BFW_NX90_intlogic_lt_systimes_latch_systime_app_ns;    /*          */
  unsigned int systime_app_s     : BFW_NX90_intlogic_lt_systimes_latch_systime_app_s;     /*          */
  unsigned int reserved1         : BFW_NX90_intlogic_lt_systimes_latch_reserved1;         /* reserved */
} NX90_INTLOGIC_LT_SYSTIMES_LATCH_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_INTLOGIC_LT_SYSTIMES_LATCH_BIT_T bf;
} NX90_INTLOGIC_LT_SYSTIMES_LATCH_T;


/* ===================================================================== */

/* AREA arm_timer */
/* Area of timer_app, timer_xpic_app */

/* ===================================================================== */

#define Addr_NX90_timer_app      0xFF801580U
#define Addr_NX90_timer_xpic_app 0xFF900100U

/* --------------------------------------------------------------------- */
/* Register timer_config_timer0 */
/* => ARM TIMER Config register0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_config_timer0            0x00000000U
#define Adr_NX90_timer_app_timer_config_timer0      0xFF801580U
#define Adr_NX90_timer_xpic_app_timer_config_timer0 0xFF900100U
#define DFLT_VAL_NX90_timer_config_timer0           0x00000000U

#define MSK_NX90_timer_config_timer0_mode                   0x00000003U
#define SRT_NX90_timer_config_timer0_mode                   0
#define DFLT_VAL_NX90_timer_config_timer0_mode              0x00000000U
#define DFLT_BF_VAL_NX90_timer_config_timer0_mode           0x00000000U
#define MSK_NX90_timer_config_timer0_systime_config         0x0000000cU
#define SRT_NX90_timer_config_timer0_systime_config         2
#define DFLT_VAL_NX90_timer_config_timer0_systime_config    0x00000000U
#define DFLT_BF_VAL_NX90_timer_config_timer0_systime_config 0x00000000U

/* all used bits of 'NX90_timer_config_timer0': */
#define MSK_USED_BITS_NX90_timer_config_timer0 0x0000000fU

enum {
  BFW_NX90_timer_config_timer0_mode           = 2,  /* [1:0] */
  BFW_NX90_timer_config_timer0_systime_config = 2,  /* [3:2] */
  BFW_NX90_timer_config_timer0_reserved1      = 28  /* [31:4] */
};

typedef struct NX90_TIMER_CONFIG_TIMER0_BIT_Ttag {
  unsigned int mode           : BFW_NX90_timer_config_timer0_mode;           /* Timer0                                                                                 */
                                                                             /*       2'b00 : Timer stops at 0                                                         */
                                                                             /*       2'b01 : Timer is preload with value from preload register at 0                   */
                                                                             /*       2'b10 : Timer (value) compare with systime (once)                                */
                                                                             /*       2'b11 : reserved                                                                 */
  unsigned int systime_config : BFW_NX90_timer_config_timer0_systime_config; /* systime  for timer  (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) */
  unsigned int reserved1      : BFW_NX90_timer_config_timer0_reserved1;      /* reserved                                                                               */
} NX90_TIMER_CONFIG_TIMER0_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_TIMER_CONFIG_TIMER0_BIT_T bf;
} NX90_TIMER_CONFIG_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register timer_config_timer1 */
/* => ARM TIMER Config register1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_config_timer1            0x00000004U
#define Adr_NX90_timer_app_timer_config_timer1      0xFF801584U
#define Adr_NX90_timer_xpic_app_timer_config_timer1 0xFF900104U
#define DFLT_VAL_NX90_timer_config_timer1           0x00000000U

#define MSK_NX90_timer_config_timer1_mode                   0x00000003U
#define SRT_NX90_timer_config_timer1_mode                   0
#define DFLT_VAL_NX90_timer_config_timer1_mode              0x00000000U
#define DFLT_BF_VAL_NX90_timer_config_timer1_mode           0x00000000U
#define MSK_NX90_timer_config_timer1_systime_config         0x0000000cU
#define SRT_NX90_timer_config_timer1_systime_config         2
#define DFLT_VAL_NX90_timer_config_timer1_systime_config    0x00000000U
#define DFLT_BF_VAL_NX90_timer_config_timer1_systime_config 0x00000000U

/* all used bits of 'NX90_timer_config_timer1': */
#define MSK_USED_BITS_NX90_timer_config_timer1 0x0000000fU

enum {
  BFW_NX90_timer_config_timer1_mode           = 2,  /* [1:0] */
  BFW_NX90_timer_config_timer1_systime_config = 2,  /* [3:2] */
  BFW_NX90_timer_config_timer1_reserved1      = 28  /* [31:4] */
};

typedef struct NX90_TIMER_CONFIG_TIMER1_BIT_Ttag {
  unsigned int mode           : BFW_NX90_timer_config_timer1_mode;           /* Timer1                                                                                 */
                                                                             /*       2'b00 : Timer stops at 0                                                         */
                                                                             /*       2'b01 : Timer is preload with value from preload register at 0                   */
                                                                             /*       2'b10 : Timer (value) compare with systime (once)                                */
                                                                             /*       2'b11 : reserved                                                                 */
  unsigned int systime_config : BFW_NX90_timer_config_timer1_systime_config; /* systime  for timer  (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) */
  unsigned int reserved1      : BFW_NX90_timer_config_timer1_reserved1;      /* reserved                                                                               */
} NX90_TIMER_CONFIG_TIMER1_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_TIMER_CONFIG_TIMER1_BIT_T bf;
} NX90_TIMER_CONFIG_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register timer_config_timer2 */
/* => ARM TIMER Config register2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_config_timer2            0x00000008U
#define Adr_NX90_timer_app_timer_config_timer2      0xFF801588U
#define Adr_NX90_timer_xpic_app_timer_config_timer2 0xFF900108U
#define DFLT_VAL_NX90_timer_config_timer2           0x00000000U

#define MSK_NX90_timer_config_timer2_mode                   0x00000003U
#define SRT_NX90_timer_config_timer2_mode                   0
#define DFLT_VAL_NX90_timer_config_timer2_mode              0x00000000U
#define DFLT_BF_VAL_NX90_timer_config_timer2_mode           0x00000000U
#define MSK_NX90_timer_config_timer2_systime_config         0x0000000cU
#define SRT_NX90_timer_config_timer2_systime_config         2
#define DFLT_VAL_NX90_timer_config_timer2_systime_config    0x00000000U
#define DFLT_BF_VAL_NX90_timer_config_timer2_systime_config 0x00000000U

/* all used bits of 'NX90_timer_config_timer2': */
#define MSK_USED_BITS_NX90_timer_config_timer2 0x0000000fU

enum {
  BFW_NX90_timer_config_timer2_mode           = 2,  /* [1:0] */
  BFW_NX90_timer_config_timer2_systime_config = 2,  /* [3:2] */
  BFW_NX90_timer_config_timer2_reserved1      = 28  /* [31:4] */
};

typedef struct NX90_TIMER_CONFIG_TIMER2_BIT_Ttag {
  unsigned int mode           : BFW_NX90_timer_config_timer2_mode;           /* Timer2                                                                                 */
                                                                             /*       2'b00 : Timer stops at 0                                                         */
                                                                             /*       2'b01 : Timer is preload with value from preload register at 0                   */
                                                                             /*       2'b10 : Timer (value) compare with systime (once)                                */
                                                                             /*       2'b11 : reserved                                                                 */
  unsigned int systime_config : BFW_NX90_timer_config_timer2_systime_config; /* systime  for timer  (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) */
  unsigned int reserved1      : BFW_NX90_timer_config_timer2_reserved1;      /* reserved                                                                               */
} NX90_TIMER_CONFIG_TIMER2_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_TIMER_CONFIG_TIMER2_BIT_T bf;
} NX90_TIMER_CONFIG_TIMER2_T;

/* --------------------------------------------------------------------- */
/* Register timer_preload_timer0 */
/* => ARM TIMER Timer 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_preload_timer0            0x0000000CU
#define Adr_NX90_timer_app_timer_preload_timer0      0xFF80158CU
#define Adr_NX90_timer_xpic_app_timer_preload_timer0 0xFF90010CU
#define DFLT_VAL_NX90_timer_preload_timer0           0x00000000U

#define MSK_NX90_timer_preload_timer0_val         0xffffffffU
#define SRT_NX90_timer_preload_timer0_val         0
#define DFLT_VAL_NX90_timer_preload_timer0_val    0x00000000U
#define DFLT_BF_VAL_NX90_timer_preload_timer0_val 0x00000000U

/* all used bits of 'NX90_timer_preload_timer0': */
#define MSK_USED_BITS_NX90_timer_preload_timer0 0xffffffffU

enum {
  BFW_NX90_timer_preload_timer0_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_PRELOAD_TIMER0_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_preload_timer0_val; /* preload value */
} NX90_TIMER_PRELOAD_TIMER0_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_TIMER_PRELOAD_TIMER0_BIT_T bf;
} NX90_TIMER_PRELOAD_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register timer_preload_timer1 */
/* => ARM TIMER Timer 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_preload_timer1            0x00000010U
#define Adr_NX90_timer_app_timer_preload_timer1      0xFF801590U
#define Adr_NX90_timer_xpic_app_timer_preload_timer1 0xFF900110U
#define DFLT_VAL_NX90_timer_preload_timer1           0x00000000U

#define MSK_NX90_timer_preload_timer1_val         0xffffffffU
#define SRT_NX90_timer_preload_timer1_val         0
#define DFLT_VAL_NX90_timer_preload_timer1_val    0x00000000U
#define DFLT_BF_VAL_NX90_timer_preload_timer1_val 0x00000000U

/* all used bits of 'NX90_timer_preload_timer1': */
#define MSK_USED_BITS_NX90_timer_preload_timer1 0xffffffffU

enum {
  BFW_NX90_timer_preload_timer1_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_PRELOAD_TIMER1_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_preload_timer1_val; /* preload value */
} NX90_TIMER_PRELOAD_TIMER1_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_TIMER_PRELOAD_TIMER1_BIT_T bf;
} NX90_TIMER_PRELOAD_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register timer_preload_timer2 */
/* => ARM TIMER Timer 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_preload_timer2            0x00000014U
#define Adr_NX90_timer_app_timer_preload_timer2      0xFF801594U
#define Adr_NX90_timer_xpic_app_timer_preload_timer2 0xFF900114U
#define DFLT_VAL_NX90_timer_preload_timer2           0x00000000U

#define MSK_NX90_timer_preload_timer2_val         0xffffffffU
#define SRT_NX90_timer_preload_timer2_val         0
#define DFLT_VAL_NX90_timer_preload_timer2_val    0x00000000U
#define DFLT_BF_VAL_NX90_timer_preload_timer2_val 0x00000000U

/* all used bits of 'NX90_timer_preload_timer2': */
#define MSK_USED_BITS_NX90_timer_preload_timer2 0xffffffffU

enum {
  BFW_NX90_timer_preload_timer2_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_PRELOAD_TIMER2_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_preload_timer2_val; /* preload value */
} NX90_TIMER_PRELOAD_TIMER2_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_TIMER_PRELOAD_TIMER2_BIT_T bf;
} NX90_TIMER_PRELOAD_TIMER2_T;

/* --------------------------------------------------------------------- */
/* Register timer_timer0 */
/* => ARM TIMER Timer 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_timer0            0x00000018U
#define Adr_NX90_timer_app_timer_timer0      0xFF801598U
#define Adr_NX90_timer_xpic_app_timer_timer0 0xFF900118U
#define DFLT_VAL_NX90_timer_timer0           0x00000000U

#define MSK_NX90_timer_timer0_val         0xffffffffU
#define SRT_NX90_timer_timer0_val         0
#define DFLT_VAL_NX90_timer_timer0_val    0x00000000U
#define DFLT_BF_VAL_NX90_timer_timer0_val 0x00000000U

/* all used bits of 'NX90_timer_timer0': */
#define MSK_USED_BITS_NX90_timer_timer0 0xffffffffU

enum {
  BFW_NX90_timer_timer0_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_TIMER0_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_timer0_val; /* actual value of timer / systime compare value */
} NX90_TIMER_TIMER0_BIT_T;

typedef union {
  uint32_t                val;
  NX90_TIMER_TIMER0_BIT_T bf;
} NX90_TIMER_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register timer_timer1 */
/* => ARM TIMER Timer 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_timer1            0x0000001CU
#define Adr_NX90_timer_app_timer_timer1      0xFF80159CU
#define Adr_NX90_timer_xpic_app_timer_timer1 0xFF90011CU
#define DFLT_VAL_NX90_timer_timer1           0x00000000U

#define MSK_NX90_timer_timer1_val         0xffffffffU
#define SRT_NX90_timer_timer1_val         0
#define DFLT_VAL_NX90_timer_timer1_val    0x00000000U
#define DFLT_BF_VAL_NX90_timer_timer1_val 0x00000000U

/* all used bits of 'NX90_timer_timer1': */
#define MSK_USED_BITS_NX90_timer_timer1 0xffffffffU

enum {
  BFW_NX90_timer_timer1_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_TIMER1_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_timer1_val; /* actual value of timer / systime compare value */
} NX90_TIMER_TIMER1_BIT_T;

typedef union {
  uint32_t                val;
  NX90_TIMER_TIMER1_BIT_T bf;
} NX90_TIMER_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register timer_timer2 */
/* => ARM TIMER Timer 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_timer2            0x00000020U
#define Adr_NX90_timer_app_timer_timer2      0xFF8015A0U
#define Adr_NX90_timer_xpic_app_timer_timer2 0xFF900120U
#define DFLT_VAL_NX90_timer_timer2           0x00000000U

#define MSK_NX90_timer_timer2_val         0xffffffffU
#define SRT_NX90_timer_timer2_val         0
#define DFLT_VAL_NX90_timer_timer2_val    0x00000000U
#define DFLT_BF_VAL_NX90_timer_timer2_val 0x00000000U

/* all used bits of 'NX90_timer_timer2': */
#define MSK_USED_BITS_NX90_timer_timer2 0xffffffffU

enum {
  BFW_NX90_timer_timer2_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_TIMER2_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_timer2_val; /* actual value of timer / systime compare value */
} NX90_TIMER_TIMER2_BIT_T;

typedef union {
  uint32_t                val;
  NX90_TIMER_TIMER2_BIT_T bf;
} NX90_TIMER_TIMER2_T;

/* --------------------------------------------------------------------- */
/* Register timer_systime_s */
/* => ARM_TIMER upper SYSTIME register */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    This register should be dedicated to accesses via ARM. */
/*    xPIC software should access systime via xpic_timer_systime_s. */
/*    Host software should access systime via DPM at systime_s. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_systime_s            0x00000024U
#define Adr_NX90_timer_app_timer_systime_s      0xFF8015A4U
#define Adr_NX90_timer_xpic_app_timer_systime_s 0xFF900124U

#define MSK_NX90_timer_systime_s_val 0xffffffffU
#define SRT_NX90_timer_systime_s_val 0

/* all used bits of 'NX90_timer_systime_s': */
#define MSK_USED_BITS_NX90_timer_systime_s 0xffffffffU

enum {
  BFW_NX90_timer_systime_s_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_SYSTIME_S_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_systime_s_val; /* Systime high:                                               */
                                                   /* Sample systime_ns at read access to systime_s.              */
                                                   /* Value is incremented, if systime_ns reaches systime_border. */
} NX90_TIMER_SYSTIME_S_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_TIMER_SYSTIME_S_BIT_T bf;
} NX90_TIMER_SYSTIME_S_T;

/* --------------------------------------------------------------------- */
/* Register timer_systime_ns */
/* => ARM_TIMER lower SYSTIME register */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    If no systime_s is read before (e.g. at 2nd read access of systime_ns), the actual value of systime_ns is read. */
/*    This register should be dedicated to accesses via ARM. */
/*    xPIC software should access systime via xpic_timer_systime_ns. */
/*    Host software should access systime via DPM at systime_ns. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_systime_ns            0x00000028U
#define Adr_NX90_timer_app_timer_systime_ns      0xFF8015A8U
#define Adr_NX90_timer_xpic_app_timer_systime_ns 0xFF900128U

#define MSK_NX90_timer_systime_ns_val 0xffffffffU
#define SRT_NX90_timer_systime_ns_val 0

/* all used bits of 'NX90_timer_systime_ns': */
#define MSK_USED_BITS_NX90_timer_systime_ns 0xffffffffU

enum {
  BFW_NX90_timer_systime_ns_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_SYSTIME_NS_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_systime_ns_val; /* Systime low:                                                        */
                                                    /* Sample systime_ns at read access to systime_s.                      */
                                                    /* Without sample read systime_s, read the actual value of systime_ns. */
} NX90_TIMER_SYSTIME_NS_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_TIMER_SYSTIME_NS_BIT_T bf;
} NX90_TIMER_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register timer_compare_systime_s_value */
/* => SYSTIME sec compare value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_compare_systime_s_value            0x0000002CU
#define Adr_NX90_timer_app_timer_compare_systime_s_value      0xFF8015ACU
#define Adr_NX90_timer_xpic_app_timer_compare_systime_s_value 0xFF90012CU
#define DFLT_VAL_NX90_timer_compare_systime_s_value           0x00000000U

#define MSK_NX90_timer_compare_systime_s_value_val         0xffffffffU
#define SRT_NX90_timer_compare_systime_s_value_val         0
#define DFLT_VAL_NX90_timer_compare_systime_s_value_val    0x00000000U
#define DFLT_BF_VAL_NX90_timer_compare_systime_s_value_val 0x00000000U

/* all used bits of 'NX90_timer_compare_systime_s_value': */
#define MSK_USED_BITS_NX90_timer_compare_systime_s_value 0xffffffffU

enum {
  BFW_NX90_timer_compare_systime_s_value_val = 32  /* [31:0] */
};

typedef struct NX90_TIMER_COMPARE_SYSTIME_S_VALUE_BIT_Ttag {
  unsigned int val : BFW_NX90_timer_compare_systime_s_value_val; /* Compare value with systime_s (seconds):             */
                                                                 /* Systime_s_compare_irq is set, if systime_s matches. */
} NX90_TIMER_COMPARE_SYSTIME_S_VALUE_BIT_T;

typedef union {
  uint32_t                                 val;
  NX90_TIMER_COMPARE_SYSTIME_S_VALUE_BIT_T bf;
} NX90_TIMER_COMPARE_SYSTIME_S_VALUE_T;

/* --------------------------------------------------------------------- */
/* Register timer_irq_raw */
/* => ARM_TIMER Raw IRQ register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_irq_raw            0x00000030U
#define Adr_NX90_timer_app_timer_irq_raw      0xFF8015B0U
#define Adr_NX90_timer_xpic_app_timer_irq_raw 0xFF900130U
#define DFLT_VAL_NX90_timer_irq_raw           0x00000000U

#define MSK_NX90_timer_irq_raw_timer0_irq            0x00000001U
#define SRT_NX90_timer_irq_raw_timer0_irq            0
#define DFLT_VAL_NX90_timer_irq_raw_timer0_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_raw_timer0_irq    0x00000000U
#define MSK_NX90_timer_irq_raw_timer1_irq            0x00000002U
#define SRT_NX90_timer_irq_raw_timer1_irq            1
#define DFLT_VAL_NX90_timer_irq_raw_timer1_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_raw_timer1_irq    0x00000000U
#define MSK_NX90_timer_irq_raw_timer2_irq            0x00000004U
#define SRT_NX90_timer_irq_raw_timer2_irq            2
#define DFLT_VAL_NX90_timer_irq_raw_timer2_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_raw_timer2_irq    0x00000000U
#define MSK_NX90_timer_irq_raw_systime_s_irq         0x00000008U
#define SRT_NX90_timer_irq_raw_systime_s_irq         3
#define DFLT_VAL_NX90_timer_irq_raw_systime_s_irq    0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_raw_systime_s_irq 0x00000000U

/* all used bits of 'NX90_timer_irq_raw': */
#define MSK_USED_BITS_NX90_timer_irq_raw 0x0000000fU

enum {
  BFW_NX90_timer_irq_raw_timer0_irq    = 1,  /* [0] */
  BFW_NX90_timer_irq_raw_timer1_irq    = 1,  /* [1] */
  BFW_NX90_timer_irq_raw_timer2_irq    = 1,  /* [2] */
  BFW_NX90_timer_irq_raw_systime_s_irq = 1,  /* [3] */
  BFW_NX90_timer_irq_raw_reserved1     = 28  /* [31:4] */
};

typedef struct NX90_TIMER_IRQ_RAW_BIT_Ttag {
  unsigned int timer0_irq    : BFW_NX90_timer_irq_raw_timer0_irq;    /* Timer 0 Interrupt     */
  unsigned int timer1_irq    : BFW_NX90_timer_irq_raw_timer1_irq;    /* Timer 1 Interrupt     */
  unsigned int timer2_irq    : BFW_NX90_timer_irq_raw_timer2_irq;    /* Timer 2 Interrupt     */
  unsigned int systime_s_irq : BFW_NX90_timer_irq_raw_systime_s_irq; /* Systime sec Interrupt */
  unsigned int reserved1     : BFW_NX90_timer_irq_raw_reserved1;     /* reserved              */
} NX90_TIMER_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_TIMER_IRQ_RAW_BIT_T bf;
} NX90_TIMER_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register timer_irq_masked */
/* => ARM_TIMER Masked IRQ register: */
/*    Shows status of masked IRQs (as connected to ARM/xPIC) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_irq_masked            0x00000034U
#define Adr_NX90_timer_app_timer_irq_masked      0xFF8015B4U
#define Adr_NX90_timer_xpic_app_timer_irq_masked 0xFF900134U

#define MSK_NX90_timer_irq_masked_timer0_irq    0x00000001U
#define SRT_NX90_timer_irq_masked_timer0_irq    0
#define MSK_NX90_timer_irq_masked_timer1_irq    0x00000002U
#define SRT_NX90_timer_irq_masked_timer1_irq    1
#define MSK_NX90_timer_irq_masked_timer2_irq    0x00000004U
#define SRT_NX90_timer_irq_masked_timer2_irq    2
#define MSK_NX90_timer_irq_masked_systime_s_irq 0x00000008U
#define SRT_NX90_timer_irq_masked_systime_s_irq 3

/* all used bits of 'NX90_timer_irq_masked': */
#define MSK_USED_BITS_NX90_timer_irq_masked 0x0000000fU

enum {
  BFW_NX90_timer_irq_masked_timer0_irq    = 1,  /* [0] */
  BFW_NX90_timer_irq_masked_timer1_irq    = 1,  /* [1] */
  BFW_NX90_timer_irq_masked_timer2_irq    = 1,  /* [2] */
  BFW_NX90_timer_irq_masked_systime_s_irq = 1,  /* [3] */
  BFW_NX90_timer_irq_masked_reserved1     = 28  /* [31:4] */
};

typedef struct NX90_TIMER_IRQ_MASKED_BIT_Ttag {
  unsigned int timer0_irq    : BFW_NX90_timer_irq_masked_timer0_irq;    /* Timer 0 Interrupt     */
  unsigned int timer1_irq    : BFW_NX90_timer_irq_masked_timer1_irq;    /* Timer 1 Interrupt     */
  unsigned int timer2_irq    : BFW_NX90_timer_irq_masked_timer2_irq;    /* Timer 2 Interrupt     */
  unsigned int systime_s_irq : BFW_NX90_timer_irq_masked_systime_s_irq; /* Systime sec Interrupt */
  unsigned int reserved1     : BFW_NX90_timer_irq_masked_reserved1;     /* reserved              */
} NX90_TIMER_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_TIMER_IRQ_MASKED_BIT_T bf;
} NX90_TIMER_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register timer_irq_msk_set */
/* => ARM_TIMER interrupt mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to arm_timer_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_irq_msk_set            0x00000038U
#define Adr_NX90_timer_app_timer_irq_msk_set      0xFF8015B8U
#define Adr_NX90_timer_xpic_app_timer_irq_msk_set 0xFF900138U
#define DFLT_VAL_NX90_timer_irq_msk_set           0x00000000U

#define MSK_NX90_timer_irq_msk_set_timer0_irq            0x00000001U
#define SRT_NX90_timer_irq_msk_set_timer0_irq            0
#define DFLT_VAL_NX90_timer_irq_msk_set_timer0_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_set_timer0_irq    0x00000000U
#define MSK_NX90_timer_irq_msk_set_timer1_irq            0x00000002U
#define SRT_NX90_timer_irq_msk_set_timer1_irq            1
#define DFLT_VAL_NX90_timer_irq_msk_set_timer1_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_set_timer1_irq    0x00000000U
#define MSK_NX90_timer_irq_msk_set_timer2_irq            0x00000004U
#define SRT_NX90_timer_irq_msk_set_timer2_irq            2
#define DFLT_VAL_NX90_timer_irq_msk_set_timer2_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_set_timer2_irq    0x00000000U
#define MSK_NX90_timer_irq_msk_set_systime_s_irq         0x00000008U
#define SRT_NX90_timer_irq_msk_set_systime_s_irq         3
#define DFLT_VAL_NX90_timer_irq_msk_set_systime_s_irq    0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_set_systime_s_irq 0x00000000U

/* all used bits of 'NX90_timer_irq_msk_set': */
#define MSK_USED_BITS_NX90_timer_irq_msk_set 0x0000000fU

enum {
  BFW_NX90_timer_irq_msk_set_timer0_irq    = 1,  /* [0] */
  BFW_NX90_timer_irq_msk_set_timer1_irq    = 1,  /* [1] */
  BFW_NX90_timer_irq_msk_set_timer2_irq    = 1,  /* [2] */
  BFW_NX90_timer_irq_msk_set_systime_s_irq = 1,  /* [3] */
  BFW_NX90_timer_irq_msk_set_reserved1     = 28  /* [31:4] */
};

typedef struct NX90_TIMER_IRQ_MSK_SET_BIT_Ttag {
  unsigned int timer0_irq    : BFW_NX90_timer_irq_msk_set_timer0_irq;    /* Timer 0 Interrupt     */
  unsigned int timer1_irq    : BFW_NX90_timer_irq_msk_set_timer1_irq;    /* Timer 1 Interrupt     */
  unsigned int timer2_irq    : BFW_NX90_timer_irq_msk_set_timer2_irq;    /* Timer 2 Interrupt     */
  unsigned int systime_s_irq : BFW_NX90_timer_irq_msk_set_systime_s_irq; /* Systime sec Interrupt */
  unsigned int reserved1     : BFW_NX90_timer_irq_msk_set_reserved1;     /* reserved              */
} NX90_TIMER_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_TIMER_IRQ_MSK_SET_BIT_T bf;
} NX90_TIMER_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register timer_irq_msk_reset */
/* => ARM_TIMER interrupt mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_irq_msk_reset            0x0000003CU
#define Adr_NX90_timer_app_timer_irq_msk_reset      0xFF8015BCU
#define Adr_NX90_timer_xpic_app_timer_irq_msk_reset 0xFF90013CU
#define DFLT_VAL_NX90_timer_irq_msk_reset           0x00000000U

#define MSK_NX90_timer_irq_msk_reset_timer0_irq            0x00000001U
#define SRT_NX90_timer_irq_msk_reset_timer0_irq            0
#define DFLT_VAL_NX90_timer_irq_msk_reset_timer0_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_reset_timer0_irq    0x00000000U
#define MSK_NX90_timer_irq_msk_reset_timer1_irq            0x00000002U
#define SRT_NX90_timer_irq_msk_reset_timer1_irq            1
#define DFLT_VAL_NX90_timer_irq_msk_reset_timer1_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_reset_timer1_irq    0x00000000U
#define MSK_NX90_timer_irq_msk_reset_timer2_irq            0x00000004U
#define SRT_NX90_timer_irq_msk_reset_timer2_irq            2
#define DFLT_VAL_NX90_timer_irq_msk_reset_timer2_irq       0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_reset_timer2_irq    0x00000000U
#define MSK_NX90_timer_irq_msk_reset_systime_s_irq         0x00000008U
#define SRT_NX90_timer_irq_msk_reset_systime_s_irq         3
#define DFLT_VAL_NX90_timer_irq_msk_reset_systime_s_irq    0x00000000U
#define DFLT_BF_VAL_NX90_timer_irq_msk_reset_systime_s_irq 0x00000000U

/* all used bits of 'NX90_timer_irq_msk_reset': */
#define MSK_USED_BITS_NX90_timer_irq_msk_reset 0x0000000fU

enum {
  BFW_NX90_timer_irq_msk_reset_timer0_irq    = 1,  /* [0] */
  BFW_NX90_timer_irq_msk_reset_timer1_irq    = 1,  /* [1] */
  BFW_NX90_timer_irq_msk_reset_timer2_irq    = 1,  /* [2] */
  BFW_NX90_timer_irq_msk_reset_systime_s_irq = 1,  /* [3] */
  BFW_NX90_timer_irq_msk_reset_reserved1     = 28  /* [31:4] */
};

typedef struct NX90_TIMER_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int timer0_irq    : BFW_NX90_timer_irq_msk_reset_timer0_irq;    /* Timer 0 Interrupt     */
  unsigned int timer1_irq    : BFW_NX90_timer_irq_msk_reset_timer1_irq;    /* Timer 1 Interrupt     */
  unsigned int timer2_irq    : BFW_NX90_timer_irq_msk_reset_timer2_irq;    /* Timer 2 Interrupt     */
  unsigned int systime_s_irq : BFW_NX90_timer_irq_msk_reset_systime_s_irq; /* Systime sec Interrupt */
  unsigned int reserved1     : BFW_NX90_timer_irq_msk_reset_reserved1;     /* reserved              */
} NX90_TIMER_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_TIMER_IRQ_MSK_RESET_BIT_T bf;
} NX90_TIMER_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register timer_systime_config */
/* => Select systime  for arm_timer_systime_(ns)s functions */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_timer_systime_config            0x00000040U
#define Adr_NX90_timer_app_timer_systime_config      0xFF8015C0U
#define Adr_NX90_timer_xpic_app_timer_systime_config 0xFF900140U
#define DFLT_VAL_NX90_timer_systime_config           0x00000000U

#define MSK_NX90_timer_systime_config_systime_config         0x00000003U
#define SRT_NX90_timer_systime_config_systime_config         0
#define DFLT_VAL_NX90_timer_systime_config_systime_config    0x00000000U
#define DFLT_BF_VAL_NX90_timer_systime_config_systime_config 0x00000000U

/* all used bits of 'NX90_timer_systime_config': */
#define MSK_USED_BITS_NX90_timer_systime_config 0x00000003U

enum {
  BFW_NX90_timer_systime_config_systime_config = 2,  /* [1:0] */
  BFW_NX90_timer_systime_config_reserved1      = 30  /* [31:2] */
};

typedef struct NX90_TIMER_SYSTIME_CONFIG_BIT_Ttag {
  unsigned int systime_config : BFW_NX90_timer_systime_config_systime_config; /* systime  for timer (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) */
  unsigned int reserved1      : BFW_NX90_timer_systime_config_reserved1;      /* reserved                                                                              */
} NX90_TIMER_SYSTIME_CONFIG_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_TIMER_SYSTIME_CONFIG_BIT_T bf;
} NX90_TIMER_SYSTIME_CONFIG_T;


/* ===================================================================== */

/* AREA systime */
/* Area of systime_app */

/* ===================================================================== */

#define Addr_NX90_systime_app 0xFF801600U

/* --------------------------------------------------------------------- */
/* Register systime_s */
/* => Upper SYSTIME register: */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    This register should be dedicated to accesses via DPM. */
/*    ARM software should access systime via arm_timer_systime_s. */
/*    xPIC software should access systime via xpic_timer_systime_s. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_systime_s         0x00000000U
#define Adr_NX90_systime_app_systime_s 0xFF801600U
#define Adr_NX90_systime_s             0xFF801600U
#define DFLT_VAL_NX90_systime_s        0x00000000U

#define MSK_NX90_systime_s_systime_s         0xffffffffU
#define SRT_NX90_systime_s_systime_s         0
#define DFLT_VAL_NX90_systime_s_systime_s    0x00000000U
#define DFLT_BF_VAL_NX90_systime_s_systime_s 0x00000000U

/* all used bits of 'NX90_systime_s': */
#define MSK_USED_BITS_NX90_systime_s 0xffffffffU

enum {
  BFW_NX90_systime_s_systime_s = 32  /* [31:0] */
};

typedef struct NX90_SYSTIME_S_BIT_Ttag {
  unsigned int systime_s : BFW_NX90_systime_s_systime_s; /* systime high                                               */
                                                         /* value is incremented, if systime_ns reaches systime_border */
                                                         /* Sample systime_ns at read access to systime_s.             */
} NX90_SYSTIME_S_BIT_T;

typedef union {
  uint32_t             val;
  NX90_SYSTIME_S_BIT_T bf;
} NX90_SYSTIME_S_T;

/* --------------------------------------------------------------------- */
/* Register systime_ns */
/* => Lower SYSTIME register: */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    If no systime_s is read before (or at 2nd read access of systime_ns), the actual value of systime_ns is read. */
/*    This register should be dedicated to accesses via DPM. */
/*    ARM software should access systime via arm_timer_systime_ns. */
/*    xPIC software should access systime via xpic_timer_systime_ns. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_systime_ns         0x00000004U
#define Adr_NX90_systime_app_systime_ns 0xFF801604U
#define Adr_NX90_systime_ns             0xFF801604U
#define DFLT_VAL_NX90_systime_ns        0x00000000U

#define MSK_NX90_systime_ns_systime_ns         0xffffffffU
#define SRT_NX90_systime_ns_systime_ns         0
#define DFLT_VAL_NX90_systime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX90_systime_ns_systime_ns 0x00000000U

/* all used bits of 'NX90_systime_ns': */
#define MSK_USED_BITS_NX90_systime_ns 0xffffffffU

enum {
  BFW_NX90_systime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX90_SYSTIME_NS_BIT_Ttag {
  unsigned int systime_ns : BFW_NX90_systime_ns_systime_ns; /* Systime low:                                                        */
                                                            /* Sample systime_ns at read access to systime_s.                      */
                                                            /* Without sample read systime_s, read the actual value of systime_ns. */
} NX90_SYSTIME_NS_BIT_T;

typedef union {
  uint32_t              val;
  NX90_SYSTIME_NS_BIT_T bf;
} NX90_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register systime_border */
/* => SYSTIME border register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_systime_border         0x00000008U
#define Adr_NX90_systime_app_systime_border 0xFF801608U
#define Adr_NX90_systime_border             0xFF801608U
#define DFLT_VAL_NX90_systime_border        0x3b9ac9ffU

#define MSK_NX90_systime_border_systime_border         0xffffffffU
#define SRT_NX90_systime_border_systime_border         0
#define DFLT_VAL_NX90_systime_border_systime_border    0x3b9ac9ffU
#define DFLT_BF_VAL_NX90_systime_border_systime_border 0x3b9ac9ffU

/* all used bits of 'NX90_systime_border': */
#define MSK_USED_BITS_NX90_systime_border 0xffffffffU

enum {
  BFW_NX90_systime_border_systime_border = 32  /* [31:0] */
};

typedef struct NX90_SYSTIME_BORDER_BIT_Ttag {
  unsigned int systime_border : BFW_NX90_systime_border_systime_border; /* Systime border for lower systime:                                                                    */
                                                                        /* systime_ns counts from 0 to this value (inlcuded),                                                   */
                                                                        /* i.e. systime_ns counts modulo (systime_border + 1)                                                   */
                                                                        /* Attention: the border value Bit 3 to 1 must be b'1111 (hex f) for all netX systime - match functions */
} NX90_SYSTIME_BORDER_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_SYSTIME_BORDER_BIT_T bf;
} NX90_SYSTIME_BORDER_T;

/* --------------------------------------------------------------------- */
/* Register systime_count_value */
/* => SYSTIME count register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_systime_count_value         0x0000000CU
#define Adr_NX90_systime_app_systime_count_value 0xFF80160CU
#define Adr_NX90_systime_count_value             0xFF80160CU
#define DFLT_VAL_NX90_systime_count_value        0xa0000000U

#define MSK_NX90_systime_count_value_systime_count_value         0xffffffffU
#define SRT_NX90_systime_count_value_systime_count_value         0
#define DFLT_VAL_NX90_systime_count_value_systime_count_value    0xa0000000U
#define DFLT_BF_VAL_NX90_systime_count_value_systime_count_value 0xa0000000U

/* all used bits of 'NX90_systime_count_value': */
#define MSK_USED_BITS_NX90_systime_count_value 0xffffffffU

enum {
  BFW_NX90_systime_count_value_systime_count_value = 32  /* [31:0] */
};

typedef struct NX90_SYSTIME_COUNT_VALUE_BIT_Ttag {
  unsigned int systime_count_value : BFW_NX90_systime_count_value_systime_count_value; /* Each clock cycle (systime_count_value >> 28)                              */
                                                                                       /* will be added to systime (rate multiplier for IEEE1588).                  */
                                                                                       /* Value 0x10000000 can be used for counting in 10ns (ethernet clock) steps. */
} NX90_SYSTIME_COUNT_VALUE_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_SYSTIME_COUNT_VALUE_BIT_T bf;
} NX90_SYSTIME_COUNT_VALUE_T;


/* ===================================================================== */

/* AREA hs_irq_reg */
/* Area of mcp_app, mcp_xpic_app */

/* ===================================================================== */

#define Addr_NX90_mcp_app      0xFF801620U
#define Addr_NX90_mcp_xpic_app 0xFF9001A0U

/* --------------------------------------------------------------------- */
/* Register hs_irq_set_raw */
/* => read: hs_iq_reg value */
/*    write: hs_iq_reg set bit(s) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hs_irq_set_raw          0x00000000U
#define Adr_NX90_mcp_app_hs_irq_set_raw      0xFF801620U
#define Adr_NX90_mcp_xpic_app_hs_irq_set_raw 0xFF9001A0U
#define DFLT_VAL_NX90_hs_irq_set_raw         0x00000000U

#define MSK_NX90_hs_irq_set_raw_hs_irq_set_bits         0xffffffffU
#define SRT_NX90_hs_irq_set_raw_hs_irq_set_bits         0
#define DFLT_VAL_NX90_hs_irq_set_raw_hs_irq_set_bits    0x00000000U
#define DFLT_BF_VAL_NX90_hs_irq_set_raw_hs_irq_set_bits 0x00000000U

/* all used bits of 'NX90_hs_irq_set_raw': */
#define MSK_USED_BITS_NX90_hs_irq_set_raw 0xffffffffU

enum {
  BFW_NX90_hs_irq_set_raw_hs_irq_set_bits = 32  /* [31:0] */
};

typedef struct NX90_HS_IRQ_SET_RAW_BIT_Ttag {
  unsigned int hs_irq_set_bits : BFW_NX90_hs_irq_set_raw_hs_irq_set_bits; /* IRQs for Inter-CPU-Communication */
} NX90_HS_IRQ_SET_RAW_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_HS_IRQ_SET_RAW_BIT_T bf;
} NX90_HS_IRQ_SET_RAW_T;

/* --------------------------------------------------------------------- */
/* Register hs_irq_reset_raw */
/* => read: hs_iq_reg value */
/*    write: hs_iq_reg reset bit(s) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hs_irq_reset_raw          0x00000004U
#define Adr_NX90_mcp_app_hs_irq_reset_raw      0xFF801624U
#define Adr_NX90_mcp_xpic_app_hs_irq_reset_raw 0xFF9001A4U
#define DFLT_VAL_NX90_hs_irq_reset_raw         0x00000000U

#define MSK_NX90_hs_irq_reset_raw_hs_irq_reset_bits         0xffffffffU
#define SRT_NX90_hs_irq_reset_raw_hs_irq_reset_bits         0
#define DFLT_VAL_NX90_hs_irq_reset_raw_hs_irq_reset_bits    0x00000000U
#define DFLT_BF_VAL_NX90_hs_irq_reset_raw_hs_irq_reset_bits 0x00000000U

/* all used bits of 'NX90_hs_irq_reset_raw': */
#define MSK_USED_BITS_NX90_hs_irq_reset_raw 0xffffffffU

enum {
  BFW_NX90_hs_irq_reset_raw_hs_irq_reset_bits = 32  /* [31:0] */
};

typedef struct NX90_HS_IRQ_RESET_RAW_BIT_Ttag {
  unsigned int hs_irq_reset_bits : BFW_NX90_hs_irq_reset_raw_hs_irq_reset_bits; /* IRQs for Inter-CPU-Communication */
} NX90_HS_IRQ_RESET_RAW_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_HS_IRQ_RESET_RAW_BIT_T bf;
} NX90_HS_IRQ_RESET_RAW_T;

/* --------------------------------------------------------------------- */
/* Register hs_irq_set_mask */
/* => read: mask value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hs_irq_set_mask          0x00000008U
#define Adr_NX90_mcp_app_hs_irq_set_mask      0xFF801628U
#define Adr_NX90_mcp_xpic_app_hs_irq_set_mask 0xFF9001A8U
#define DFLT_VAL_NX90_hs_irq_set_mask         0x00000000U

#define MSK_NX90_hs_irq_set_mask_hs_irq_set_mask         0xffffffffU
#define SRT_NX90_hs_irq_set_mask_hs_irq_set_mask         0
#define DFLT_VAL_NX90_hs_irq_set_mask_hs_irq_set_mask    0x00000000U
#define DFLT_BF_VAL_NX90_hs_irq_set_mask_hs_irq_set_mask 0x00000000U

/* all used bits of 'NX90_hs_irq_set_mask': */
#define MSK_USED_BITS_NX90_hs_irq_set_mask 0xffffffffU

enum {
  BFW_NX90_hs_irq_set_mask_hs_irq_set_mask = 32  /* [31:0] */
};

typedef struct NX90_HS_IRQ_SET_MASK_BIT_Ttag {
  unsigned int hs_irq_set_mask : BFW_NX90_hs_irq_set_mask_hs_irq_set_mask; /* IRQs for Inter-CPU-Communication */
} NX90_HS_IRQ_SET_MASK_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_HS_IRQ_SET_MASK_BIT_T bf;
} NX90_HS_IRQ_SET_MASK_T;

/* --------------------------------------------------------------------- */
/* Register hs_irq_reset_mask */
/* => read: mask value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hs_irq_reset_mask          0x0000000CU
#define Adr_NX90_mcp_app_hs_irq_reset_mask      0xFF80162CU
#define Adr_NX90_mcp_xpic_app_hs_irq_reset_mask 0xFF9001ACU
#define DFLT_VAL_NX90_hs_irq_reset_mask         0x00000000U

#define MSK_NX90_hs_irq_reset_mask_hs_irq_reset_mask         0xffffffffU
#define SRT_NX90_hs_irq_reset_mask_hs_irq_reset_mask         0
#define DFLT_VAL_NX90_hs_irq_reset_mask_hs_irq_reset_mask    0x00000000U
#define DFLT_BF_VAL_NX90_hs_irq_reset_mask_hs_irq_reset_mask 0x00000000U

/* all used bits of 'NX90_hs_irq_reset_mask': */
#define MSK_USED_BITS_NX90_hs_irq_reset_mask 0xffffffffU

enum {
  BFW_NX90_hs_irq_reset_mask_hs_irq_reset_mask = 32  /* [31:0] */
};

typedef struct NX90_HS_IRQ_RESET_MASK_BIT_Ttag {
  unsigned int hs_irq_reset_mask : BFW_NX90_hs_irq_reset_mask_hs_irq_reset_mask; /* reset IRQs for Inter-CPU-Communication */
} NX90_HS_IRQ_RESET_MASK_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_HS_IRQ_RESET_MASK_BIT_T bf;
} NX90_HS_IRQ_RESET_MASK_T;

/* --------------------------------------------------------------------- */
/* Register hs_irq_masked */
/* => read: hs_iq_reg masked value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_hs_irq_masked          0x00000010U
#define Adr_NX90_mcp_app_hs_irq_masked      0xFF801630U
#define Adr_NX90_mcp_xpic_app_hs_irq_masked 0xFF9001B0U
#define DFLT_VAL_NX90_hs_irq_masked         0x00000000U

#define MSK_NX90_hs_irq_masked_hs_irq_masked         0xffffffffU
#define SRT_NX90_hs_irq_masked_hs_irq_masked         0
#define DFLT_VAL_NX90_hs_irq_masked_hs_irq_masked    0x00000000U
#define DFLT_BF_VAL_NX90_hs_irq_masked_hs_irq_masked 0x00000000U

/* all used bits of 'NX90_hs_irq_masked': */
#define MSK_USED_BITS_NX90_hs_irq_masked 0xffffffffU

enum {
  BFW_NX90_hs_irq_masked_hs_irq_masked = 32  /* [31:0] */
};

typedef struct NX90_HS_IRQ_MASKED_BIT_Ttag {
  unsigned int hs_irq_masked : BFW_NX90_hs_irq_masked_hs_irq_masked; /* mask IRQs for Inter-CPU-Communication */
} NX90_HS_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_HS_IRQ_MASKED_BIT_T bf;
} NX90_HS_IRQ_MASKED_T;


/* ===================================================================== */

/* AREA watchdog */
/* Area of wdg_app */

/* ===================================================================== */

#define Addr_NX90_wdg_app 0xFF801640U

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_ctrl */
/* => netX System Watchdog Trigger Register. */
/*    The watchdog access code is generated by a pseudo random generator. It must be written correctly */
/*    for a valid write access to this register (not only for triggering e.g. also for IRQ clearing). */
/*    Note: */
/*       WDGACT signal is available as MMIO function.. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg_ctrl     0x00000000U
#define Adr_NX90_wdg_app_netx_sys_wdg_ctrl 0xFF801640U
#define Adr_NX90_netx_sys_wdg_ctrl         0xFF801640U
#define DFLT_VAL_NX90_netx_sys_wdg_ctrl    0x00000000U

#define MSK_NX90_netx_sys_wdg_ctrl_wdg_access_code               0x000fffffU
#define SRT_NX90_netx_sys_wdg_ctrl_wdg_access_code               0
#define DFLT_VAL_NX90_netx_sys_wdg_ctrl_wdg_access_code          0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_ctrl_wdg_access_code       0x00000000U
#define MSK_NX90_netx_sys_wdg_ctrl_irq_req_watchdog              0x01000000U
#define SRT_NX90_netx_sys_wdg_ctrl_irq_req_watchdog              24
#define DFLT_VAL_NX90_netx_sys_wdg_ctrl_irq_req_watchdog         0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_ctrl_irq_req_watchdog      0x00000000U
#define MSK_NX90_netx_sys_wdg_ctrl_wdg_counter_trigger_w         0x10000000U
#define SRT_NX90_netx_sys_wdg_ctrl_wdg_counter_trigger_w         28
#define DFLT_VAL_NX90_netx_sys_wdg_ctrl_wdg_counter_trigger_w    0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_ctrl_wdg_counter_trigger_w 0x00000000U
#define MSK_NX90_netx_sys_wdg_ctrl_write_enable                  0x80000000U
#define SRT_NX90_netx_sys_wdg_ctrl_write_enable                  31
#define DFLT_VAL_NX90_netx_sys_wdg_ctrl_write_enable             0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_ctrl_write_enable          0x00000000U

/* all used bits of 'NX90_netx_sys_wdg_ctrl': */
#define MSK_USED_BITS_NX90_netx_sys_wdg_ctrl 0x910fffffU

enum {
  BFW_NX90_netx_sys_wdg_ctrl_wdg_access_code       = 20, /* [19:0] */
  BFW_NX90_netx_sys_wdg_ctrl_reserved1             = 4,  /* [23:20] */
  BFW_NX90_netx_sys_wdg_ctrl_irq_req_watchdog      = 1,  /* [24] */
  BFW_NX90_netx_sys_wdg_ctrl_reserved2             = 3,  /* [27:25] */
  BFW_NX90_netx_sys_wdg_ctrl_wdg_counter_trigger_w = 1,  /* [28] */
  BFW_NX90_netx_sys_wdg_ctrl_reserved3             = 2,  /* [30:29] */
  BFW_NX90_netx_sys_wdg_ctrl_write_enable          = 1   /* [31] */
};

typedef struct NX90_NETX_SYS_WDG_CTRL_BIT_Ttag {
  unsigned int wdg_access_code       : BFW_NX90_netx_sys_wdg_ctrl_wdg_access_code;       /* Watchdog trigger and control register access code.                                     */
                                                                                         /* A read access gives the next 16 bit code for writing the 'netx_sys_wdg_ctrl' register. */
                                                                                         /* A write access with correct access code will trigger the watchdog counter.             */
  unsigned int reserved1             : BFW_NX90_netx_sys_wdg_ctrl_reserved1;             /* reserved                                                                               */
  unsigned int irq_req_watchdog      : BFW_NX90_netx_sys_wdg_ctrl_irq_req_watchdog;      /* IRQ request of watchdog, writing 1 deletes IRQ                                         */
  unsigned int reserved2             : BFW_NX90_netx_sys_wdg_ctrl_reserved2;             /* reserved                                                                               */
  unsigned int wdg_counter_trigger_w : BFW_NX90_netx_sys_wdg_ctrl_wdg_counter_trigger_w; /* Watchdog trigger bit:                                                                  */
                                                                                         /* Bit must be set to trigger the watchdog counter.                                       */
                                                                                         /* When read, this bit is always '0'                                                      */
  unsigned int reserved3             : BFW_NX90_netx_sys_wdg_ctrl_reserved3;             /* reserved                                                                               */
  unsigned int write_enable          : BFW_NX90_netx_sys_wdg_ctrl_write_enable;          /* Write enable bit for timeout register:                                                 */
                                                                                         /* As long as this bit is not set all write accesses to the timeout register are ignored. */
} NX90_NETX_SYS_WDG_CTRL_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_NETX_SYS_WDG_CTRL_BIT_T bf;
} NX90_NETX_SYS_WDG_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg */
/* => netX System Watchdog Register */
/*    The counter value is decremented each 10000 system clock cycles. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg     0x00000004U
#define Adr_NX90_wdg_app_netx_sys_wdg 0xFF801644U
#define Adr_NX90_netx_sys_wdg         0xFF801644U

#define MSK_NX90_netx_sys_wdg_wdg_counter 0x0001ffffU
#define SRT_NX90_netx_sys_wdg_wdg_counter 0

/* all used bits of 'NX90_netx_sys_wdg': */
#define MSK_USED_BITS_NX90_netx_sys_wdg 0x0001ffffU

enum {
  BFW_NX90_netx_sys_wdg_wdg_counter = 17, /* [16:0] */
  BFW_NX90_netx_sys_wdg_reserved1   = 15  /* [31:17] */
};

typedef struct NX90_NETX_SYS_WDG_BIT_Ttag {
  unsigned int wdg_counter : BFW_NX90_netx_sys_wdg_wdg_counter; /* Actual watchdog counter value */
  unsigned int reserved1   : BFW_NX90_netx_sys_wdg_reserved1;   /* reserved                      */
} NX90_NETX_SYS_WDG_BIT_T;

typedef union {
  uint32_t                val;
  NX90_NETX_SYS_WDG_BIT_T bf;
} NX90_NETX_SYS_WDG_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_irq_timeout */
/* => netX System Wachtdog Interrupt Timout Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg_irq_timeout     0x00000008U
#define Adr_NX90_wdg_app_netx_sys_wdg_irq_timeout 0xFF801648U
#define Adr_NX90_netx_sys_wdg_irq_timeout         0xFF801648U
#define DFLT_VAL_NX90_netx_sys_wdg_irq_timeout    0x00000000U

#define MSK_NX90_netx_sys_wdg_irq_timeout_wdg_irq_timeout         0x0000ffffU
#define SRT_NX90_netx_sys_wdg_irq_timeout_wdg_irq_timeout         0
#define DFLT_VAL_NX90_netx_sys_wdg_irq_timeout_wdg_irq_timeout    0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_irq_timeout_wdg_irq_timeout 0x00000000U

/* all used bits of 'NX90_netx_sys_wdg_irq_timeout': */
#define MSK_USED_BITS_NX90_netx_sys_wdg_irq_timeout 0x0000ffffU

enum {
  BFW_NX90_netx_sys_wdg_irq_timeout_wdg_irq_timeout = 16, /* [15:0] */
  BFW_NX90_netx_sys_wdg_irq_timeout_reserved1       = 16  /* [31:16] */
};

typedef struct NX90_NETX_SYS_WDG_IRQ_TIMEOUT_BIT_Ttag {
  unsigned int wdg_irq_timeout : BFW_NX90_netx_sys_wdg_irq_timeout_wdg_irq_timeout; /* Watchdog interrupt timeout                                                            */
                                                                                    /* The total netx_sys_irq timeout for a netX clock of 100MHz is: wdg_irq_timeout * 100s */
                                                                                    /* Note: The watchdog can be stopped by programming a 0.                                 */
  unsigned int reserved1       : BFW_NX90_netx_sys_wdg_irq_timeout_reserved1;       /* reserved                                                                              */
} NX90_NETX_SYS_WDG_IRQ_TIMEOUT_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_NETX_SYS_WDG_IRQ_TIMEOUT_BIT_T bf;
} NX90_NETX_SYS_WDG_IRQ_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_res_timeout */
/* => netX System Watchdog Reset Timeout Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg_res_timeout     0x0000000CU
#define Adr_NX90_wdg_app_netx_sys_wdg_res_timeout 0xFF80164CU
#define Adr_NX90_netx_sys_wdg_res_timeout         0xFF80164CU
#define DFLT_VAL_NX90_netx_sys_wdg_res_timeout    0x00000000U

#define MSK_NX90_netx_sys_wdg_res_timeout_wdg_res_timeout         0x0000ffffU
#define SRT_NX90_netx_sys_wdg_res_timeout_wdg_res_timeout         0
#define DFLT_VAL_NX90_netx_sys_wdg_res_timeout_wdg_res_timeout    0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_res_timeout_wdg_res_timeout 0x00000000U

/* all used bits of 'NX90_netx_sys_wdg_res_timeout': */
#define MSK_USED_BITS_NX90_netx_sys_wdg_res_timeout 0x0000ffffU

enum {
  BFW_NX90_netx_sys_wdg_res_timeout_wdg_res_timeout = 16, /* [15:0] */
  BFW_NX90_netx_sys_wdg_res_timeout_reserved1       = 16  /* [31:16] */
};

typedef struct NX90_NETX_SYS_WDG_RES_TIMEOUT_BIT_Ttag {
  unsigned int wdg_res_timeout : BFW_NX90_netx_sys_wdg_res_timeout_wdg_res_timeout; /* Watchdog reset request timeout                                                                     */
                                                                                    /* The total reset timeout for a netX clock of 100MHz is: (wdg_irq_timeout + wdg_res_timeout) * 100s */
                                                                                    /* Note: The watchdog can be stopped by programming a 0.                                              */
  unsigned int reserved1       : BFW_NX90_netx_sys_wdg_res_timeout_reserved1;       /* reserved                                                                                           */
} NX90_NETX_SYS_WDG_RES_TIMEOUT_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_NETX_SYS_WDG_RES_TIMEOUT_BIT_T bf;
} NX90_NETX_SYS_WDG_RES_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_irq_raw */
/* => netX System Wachtdog IRQ raw register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg_irq_raw     0x00000010U
#define Adr_NX90_wdg_app_netx_sys_wdg_irq_raw 0xFF801650U
#define Adr_NX90_netx_sys_wdg_irq_raw         0xFF801650U
#define DFLT_VAL_NX90_netx_sys_wdg_irq_raw    0x00000000U

#define MSK_NX90_netx_sys_wdg_irq_raw_wdg_res_irq         0x00000001U
#define SRT_NX90_netx_sys_wdg_irq_raw_wdg_res_irq         0
#define DFLT_VAL_NX90_netx_sys_wdg_irq_raw_wdg_res_irq    0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_irq_raw_wdg_res_irq 0x00000000U

/* all used bits of 'NX90_netx_sys_wdg_irq_raw': */
#define MSK_USED_BITS_NX90_netx_sys_wdg_irq_raw 0x00000001U

enum {
  BFW_NX90_netx_sys_wdg_irq_raw_wdg_res_irq = 1,  /* [0] */
  BFW_NX90_netx_sys_wdg_irq_raw_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_NETX_SYS_WDG_IRQ_RAW_BIT_Ttag {
  unsigned int wdg_res_irq : BFW_NX90_netx_sys_wdg_irq_raw_wdg_res_irq; /* Watchdog reset request timeout interrupt */
  unsigned int reserved1   : BFW_NX90_netx_sys_wdg_irq_raw_reserved1;   /* reserved                                 */
} NX90_NETX_SYS_WDG_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_NETX_SYS_WDG_IRQ_RAW_BIT_T bf;
} NX90_NETX_SYS_WDG_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_irq_masked */
/* => netX System Wachtdog Masked IRQ register: */
/*    Read access shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg_irq_masked     0x00000014U
#define Adr_NX90_wdg_app_netx_sys_wdg_irq_masked 0xFF801654U
#define Adr_NX90_netx_sys_wdg_irq_masked         0xFF801654U

#define MSK_NX90_netx_sys_wdg_irq_masked_wdg_res_irq 0x00000001U
#define SRT_NX90_netx_sys_wdg_irq_masked_wdg_res_irq 0

/* all used bits of 'NX90_netx_sys_wdg_irq_masked': */
#define MSK_USED_BITS_NX90_netx_sys_wdg_irq_masked 0x00000001U

enum {
  BFW_NX90_netx_sys_wdg_irq_masked_wdg_res_irq = 1,  /* [0] */
  BFW_NX90_netx_sys_wdg_irq_masked_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_NETX_SYS_WDG_IRQ_MASKED_BIT_Ttag {
  unsigned int wdg_res_irq : BFW_NX90_netx_sys_wdg_irq_masked_wdg_res_irq; /* Watchdog reset request timeout interrupt */
  unsigned int reserved1   : BFW_NX90_netx_sys_wdg_irq_masked_reserved1;   /* reserved                                 */
} NX90_NETX_SYS_WDG_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_NETX_SYS_WDG_IRQ_MASKED_BIT_T bf;
} NX90_NETX_SYS_WDG_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_irq_msk_set */
/* => netX System Wachtdog interrupt mask enable: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg_irq_msk_set     0x00000018U
#define Adr_NX90_wdg_app_netx_sys_wdg_irq_msk_set 0xFF801658U
#define Adr_NX90_netx_sys_wdg_irq_msk_set         0xFF801658U
#define DFLT_VAL_NX90_netx_sys_wdg_irq_msk_set    0x00000000U

#define MSK_NX90_netx_sys_wdg_irq_msk_set_wdg_res_irq         0x00000001U
#define SRT_NX90_netx_sys_wdg_irq_msk_set_wdg_res_irq         0
#define DFLT_VAL_NX90_netx_sys_wdg_irq_msk_set_wdg_res_irq    0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_irq_msk_set_wdg_res_irq 0x00000000U

/* all used bits of 'NX90_netx_sys_wdg_irq_msk_set': */
#define MSK_USED_BITS_NX90_netx_sys_wdg_irq_msk_set 0x00000001U

enum {
  BFW_NX90_netx_sys_wdg_irq_msk_set_wdg_res_irq = 1,  /* [0] */
  BFW_NX90_netx_sys_wdg_irq_msk_set_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_NETX_SYS_WDG_IRQ_MSK_SET_BIT_Ttag {
  unsigned int wdg_res_irq : BFW_NX90_netx_sys_wdg_irq_msk_set_wdg_res_irq; /* Watchdog reset request timeout interrupt */
  unsigned int reserved1   : BFW_NX90_netx_sys_wdg_irq_msk_set_reserved1;   /* reserved                                 */
} NX90_NETX_SYS_WDG_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_NETX_SYS_WDG_IRQ_MSK_SET_BIT_T bf;
} NX90_NETX_SYS_WDG_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_irq_msk_reset */
/* => netX System Wachtdog interrupt mask disable: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_netx_sys_wdg_irq_msk_reset     0x0000001CU
#define Adr_NX90_wdg_app_netx_sys_wdg_irq_msk_reset 0xFF80165CU
#define Adr_NX90_netx_sys_wdg_irq_msk_reset         0xFF80165CU
#define DFLT_VAL_NX90_netx_sys_wdg_irq_msk_reset    0x00000000U

#define MSK_NX90_netx_sys_wdg_irq_msk_reset_wdg_res_irq         0x00000001U
#define SRT_NX90_netx_sys_wdg_irq_msk_reset_wdg_res_irq         0
#define DFLT_VAL_NX90_netx_sys_wdg_irq_msk_reset_wdg_res_irq    0x00000000U
#define DFLT_BF_VAL_NX90_netx_sys_wdg_irq_msk_reset_wdg_res_irq 0x00000000U

/* all used bits of 'NX90_netx_sys_wdg_irq_msk_reset': */
#define MSK_USED_BITS_NX90_netx_sys_wdg_irq_msk_reset 0x00000001U

enum {
  BFW_NX90_netx_sys_wdg_irq_msk_reset_wdg_res_irq = 1,  /* [0] */
  BFW_NX90_netx_sys_wdg_irq_msk_reset_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_NETX_SYS_WDG_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int wdg_res_irq : BFW_NX90_netx_sys_wdg_irq_msk_reset_wdg_res_irq; /* Watchdog reset request timeout interrupt */
  unsigned int reserved1   : BFW_NX90_netx_sys_wdg_irq_msk_reset_reserved1;   /* reserved                                 */
} NX90_NETX_SYS_WDG_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_NETX_SYS_WDG_IRQ_MSK_RESET_BIT_T bf;
} NX90_NETX_SYS_WDG_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* AREA trigger_irq */
/* Area of trigger_irq_app */

/* ===================================================================== */

#define Addr_NX90_trigger_irq_app 0xFF801660U

/* --------------------------------------------------------------------- */
/* Register trigger_irq_cfg */
/* => Trigger IRQ configuration register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_trigger_irq_cfg             0x00000000U
#define Adr_NX90_trigger_irq_app_trigger_irq_cfg 0xFF801660U
#define Adr_NX90_trigger_irq_cfg                 0xFF801660U
#define DFLT_VAL_NX90_trigger_irq_cfg            0x00000000U

#define MSK_NX90_trigger_irq_cfg_xc_trigger_out_polarity         0x00000003U
#define SRT_NX90_trigger_irq_cfg_xc_trigger_out_polarity         0
#define DFLT_VAL_NX90_trigger_irq_cfg_xc_trigger_out_polarity    0x00000000U
#define DFLT_BF_VAL_NX90_trigger_irq_cfg_xc_trigger_out_polarity 0x00000000U

/* all used bits of 'NX90_trigger_irq_cfg': */
#define MSK_USED_BITS_NX90_trigger_irq_cfg 0x00000003U

enum {
  BFW_NX90_trigger_irq_cfg_xc_trigger_out_polarity = 2,  /* [1:0] */
  BFW_NX90_trigger_irq_cfg_reserved1               = 30  /* [31:2] */
};

typedef struct NX90_TRIGGER_IRQ_CFG_BIT_Ttag {
  unsigned int xc_trigger_out_polarity : BFW_NX90_trigger_irq_cfg_xc_trigger_out_polarity; /* Polarity of xc_trigger_out signals for edge detection.                   */
                                                                                           /* 0: Use pos-edge on xc_trigger_out signals to trigger an IRQ.             */
                                                                                           /* 1: Use neg-edge on xc_trigger_out signals to trigger an IRQ.             */
                                                                                           /* Note: Changing the polarity will trigger set an IRQ in the raw register  */
                                                                                           /* (and when the mask is set also the IRQ signal to the CPU) due to the     */
                                                                                           /* edge detection logic.                                                    */
  unsigned int reserved1               : BFW_NX90_trigger_irq_cfg_reserved1;               /* reserved                                                                 */
} NX90_TRIGGER_IRQ_CFG_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_TRIGGER_IRQ_CFG_BIT_T bf;
} NX90_TRIGGER_IRQ_CFG_T;

/* --------------------------------------------------------------------- */
/* Register trigger_irq_raw */
/* => Trigger raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_trigger_irq_raw             0x00000004U
#define Adr_NX90_trigger_irq_app_trigger_irq_raw 0xFF801664U
#define Adr_NX90_trigger_irq_raw                 0xFF801664U
#define DFLT_VAL_NX90_trigger_irq_raw            0x00000000U

#define MSK_NX90_trigger_irq_raw_xc_trigger_out_edge         0x00000003U
#define SRT_NX90_trigger_irq_raw_xc_trigger_out_edge         0
#define DFLT_VAL_NX90_trigger_irq_raw_xc_trigger_out_edge    0x00000000U
#define DFLT_BF_VAL_NX90_trigger_irq_raw_xc_trigger_out_edge 0x00000000U

/* all used bits of 'NX90_trigger_irq_raw': */
#define MSK_USED_BITS_NX90_trigger_irq_raw 0x00000003U

enum {
  BFW_NX90_trigger_irq_raw_xc_trigger_out_edge = 2,  /* [1:0] */
  BFW_NX90_trigger_irq_raw_reserved1           = 30  /* [31:2] */
};

typedef struct NX90_TRIGGER_IRQ_RAW_BIT_Ttag {
  unsigned int xc_trigger_out_edge : BFW_NX90_trigger_irq_raw_xc_trigger_out_edge; /* Edge detected on xc_trigger_out. */
  unsigned int reserved1           : BFW_NX90_trigger_irq_raw_reserved1;           /* reserved                         */
} NX90_TRIGGER_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_TRIGGER_IRQ_RAW_BIT_T bf;
} NX90_TRIGGER_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register trigger_irq_masked */
/* => Trigger masked IRQ: */
/*    Shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_trigger_irq_masked             0x00000008U
#define Adr_NX90_trigger_irq_app_trigger_irq_masked 0xFF801668U
#define Adr_NX90_trigger_irq_masked                 0xFF801668U

#define MSK_NX90_trigger_irq_masked_xc_trigger_out_edge 0x00000003U
#define SRT_NX90_trigger_irq_masked_xc_trigger_out_edge 0

/* all used bits of 'NX90_trigger_irq_masked': */
#define MSK_USED_BITS_NX90_trigger_irq_masked 0x00000003U

enum {
  BFW_NX90_trigger_irq_masked_xc_trigger_out_edge = 2,  /* [1:0] */
  BFW_NX90_trigger_irq_masked_reserved1           = 30  /* [31:2] */
};

typedef struct NX90_TRIGGER_IRQ_MASKED_BIT_Ttag {
  unsigned int xc_trigger_out_edge : BFW_NX90_trigger_irq_masked_xc_trigger_out_edge; /* Edge detected on xc_trigger_out. */
  unsigned int reserved1           : BFW_NX90_trigger_irq_masked_reserved1;           /* reserved                         */
} NX90_TRIGGER_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_TRIGGER_IRQ_MASKED_BIT_T bf;
} NX90_TRIGGER_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register trigger_irq_msk_set */
/* => Trigger IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to bod_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_trigger_irq_msk_set             0x0000000CU
#define Adr_NX90_trigger_irq_app_trigger_irq_msk_set 0xFF80166CU
#define Adr_NX90_trigger_irq_msk_set                 0xFF80166CU
#define DFLT_VAL_NX90_trigger_irq_msk_set            0x00000000U

#define MSK_NX90_trigger_irq_msk_set_xc_trigger_out_edge         0x00000003U
#define SRT_NX90_trigger_irq_msk_set_xc_trigger_out_edge         0
#define DFLT_VAL_NX90_trigger_irq_msk_set_xc_trigger_out_edge    0x00000000U
#define DFLT_BF_VAL_NX90_trigger_irq_msk_set_xc_trigger_out_edge 0x00000000U

/* all used bits of 'NX90_trigger_irq_msk_set': */
#define MSK_USED_BITS_NX90_trigger_irq_msk_set 0x00000003U

enum {
  BFW_NX90_trigger_irq_msk_set_xc_trigger_out_edge = 2,  /* [1:0] */
  BFW_NX90_trigger_irq_msk_set_reserved1           = 30  /* [31:2] */
};

typedef struct NX90_TRIGGER_IRQ_MSK_SET_BIT_Ttag {
  unsigned int xc_trigger_out_edge : BFW_NX90_trigger_irq_msk_set_xc_trigger_out_edge; /* Edge detected on xc_trigger_out. */
  unsigned int reserved1           : BFW_NX90_trigger_irq_msk_set_reserved1;           /* reserved                         */
} NX90_TRIGGER_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_TRIGGER_IRQ_MSK_SET_BIT_T bf;
} NX90_TRIGGER_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register trigger_irq_msk_reset */
/* => Trigger IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_trigger_irq_msk_reset             0x00000010U
#define Adr_NX90_trigger_irq_app_trigger_irq_msk_reset 0xFF801670U
#define Adr_NX90_trigger_irq_msk_reset                 0xFF801670U
#define DFLT_VAL_NX90_trigger_irq_msk_reset            0x00000000U

#define MSK_NX90_trigger_irq_msk_reset_xc_trigger_out_edge         0x00000003U
#define SRT_NX90_trigger_irq_msk_reset_xc_trigger_out_edge         0
#define DFLT_VAL_NX90_trigger_irq_msk_reset_xc_trigger_out_edge    0x00000000U
#define DFLT_BF_VAL_NX90_trigger_irq_msk_reset_xc_trigger_out_edge 0x00000000U

/* all used bits of 'NX90_trigger_irq_msk_reset': */
#define MSK_USED_BITS_NX90_trigger_irq_msk_reset 0x00000003U

enum {
  BFW_NX90_trigger_irq_msk_reset_xc_trigger_out_edge = 2,  /* [1:0] */
  BFW_NX90_trigger_irq_msk_reset_reserved1           = 30  /* [31:2] */
};

typedef struct NX90_TRIGGER_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int xc_trigger_out_edge : BFW_NX90_trigger_irq_msk_reset_xc_trigger_out_edge; /* Edge detected on xc_trigger_out. */
  unsigned int reserved1           : BFW_NX90_trigger_irq_msk_reset_reserved1;           /* reserved                         */
} NX90_TRIGGER_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_TRIGGER_IRQ_MSK_RESET_BIT_T bf;
} NX90_TRIGGER_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* AREA endat */
/* Area of endat0_app, endat1_app */

/* ===================================================================== */

#define Addr_NX90_endat0_app 0xFF801700U
#define Addr_NX90_endat1_app 0xFF801740U

/* --------------------------------------------------------------------- */
/* Register endat_send */
/* => Send register */
/*    The send register contains data to be transmitted to the EnDat encoder. */
/*    Mode command */
/*    MRS code/address/port address (depends on the mode command) */
/*    Parameters/instructions (depends on the mode command) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_send        0x00000000U
#define Adr_NX90_endat0_app_endat_send 0xFF801700U
#define Adr_NX90_endat1_app_endat_send 0xFF801740U
#define DFLT_VAL_NX90_endat_send       0x07000000U

#define MSK_NX90_endat_send_byte1         0x000000ffU
#define SRT_NX90_endat_send_byte1         0
#define DFLT_VAL_NX90_endat_send_byte1    0x00000000U
#define DFLT_BF_VAL_NX90_endat_send_byte1 0x00000000U
#define MSK_NX90_endat_send_byte2         0x0000ff00U
#define SRT_NX90_endat_send_byte2         8
#define DFLT_VAL_NX90_endat_send_byte2    0x00000000U
#define DFLT_BF_VAL_NX90_endat_send_byte2 0x00000000U
#define MSK_NX90_endat_send_byte3         0x00ff0000U
#define SRT_NX90_endat_send_byte3         16
#define DFLT_VAL_NX90_endat_send_byte3    0x00000000U
#define DFLT_BF_VAL_NX90_endat_send_byte3 0x00000000U
#define MSK_NX90_endat_send_byte4         0x3f000000U
#define SRT_NX90_endat_send_byte4         24
#define DFLT_VAL_NX90_endat_send_byte4    0x07000000U
#define DFLT_BF_VAL_NX90_endat_send_byte4 0x00000007U

/* all used bits of 'NX90_endat_send': */
#define MSK_USED_BITS_NX90_endat_send 0x3fffffffU

enum {
  BFW_NX90_endat_send_byte1     = 8, /* [7:0] */
  BFW_NX90_endat_send_byte2     = 8, /* [15:8] */
  BFW_NX90_endat_send_byte3     = 8, /* [23:16] */
  BFW_NX90_endat_send_byte4     = 6, /* [29:24] */
  BFW_NX90_endat_send_reserved1 = 2  /* [31:30] */
};

typedef struct NX90_ENDAT_SEND_BIT_Ttag {
  unsigned int byte1     : BFW_NX90_endat_send_byte1;     /* Parameters / Instructions D[7:0]         */
  unsigned int byte2     : BFW_NX90_endat_send_byte2;     /* Parameters / Instructions D[15:0]        */
  unsigned int byte3     : BFW_NX90_endat_send_byte3;     /* MRS code / Address / Port address A[7:0] */
  unsigned int byte4     : BFW_NX90_endat_send_byte4;     /* Mode bits M[5:0]                         */
  unsigned int reserved1 : BFW_NX90_endat_send_reserved1; /* reserved                                 */
} NX90_ENDAT_SEND_BIT_T;

typedef union {
  uint32_t              val;
  NX90_ENDAT_SEND_BIT_T bf;
} NX90_ENDAT_SEND_T;

/* --------------------------------------------------------------------- */
/* Register endat_receive1_0 */
/* => Receive register 1 */
/*    Depending on the transmitted type 2.1 mode command, receive register 1 contains different data. */
/*    With EnDat type 2.2 mode commands and with SSI, the position value is always entered into receive-Reg 1. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_receive1_0        0x00000004U
#define Adr_NX90_endat0_app_endat_receive1_0 0xFF801704U
#define Adr_NX90_endat1_app_endat_receive1_0 0xFF801744U

#define MSK_NX90_endat_receive1_0_byte1 0x000000ffU
#define SRT_NX90_endat_receive1_0_byte1 0
#define MSK_NX90_endat_receive1_0_byte2 0x0000ff00U
#define SRT_NX90_endat_receive1_0_byte2 8
#define MSK_NX90_endat_receive1_0_byte3 0x00ff0000U
#define SRT_NX90_endat_receive1_0_byte3 16
#define MSK_NX90_endat_receive1_0_byte4 0xff000000U
#define SRT_NX90_endat_receive1_0_byte4 24

/* all used bits of 'NX90_endat_receive1_0': */
#define MSK_USED_BITS_NX90_endat_receive1_0 0xffffffffU

enum {
  BFW_NX90_endat_receive1_0_byte1 = 8, /* [7:0] */
  BFW_NX90_endat_receive1_0_byte2 = 8, /* [15:8] */
  BFW_NX90_endat_receive1_0_byte3 = 8, /* [23:16] */
  BFW_NX90_endat_receive1_0_byte4 = 8  /* [31:24] */
};

typedef struct NX90_ENDAT_RECEIVE1_0_BIT_Ttag {
  unsigned int byte1 : BFW_NX90_endat_receive1_0_byte1; /* ... */
  unsigned int byte2 : BFW_NX90_endat_receive1_0_byte2; /* ... */
  unsigned int byte3 : BFW_NX90_endat_receive1_0_byte3; /* ... */
  unsigned int byte4 : BFW_NX90_endat_receive1_0_byte4; /* ... */
} NX90_ENDAT_RECEIVE1_0_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_ENDAT_RECEIVE1_0_BIT_T bf;
} NX90_ENDAT_RECEIVE1_0_T;

/* --------------------------------------------------------------------- */
/* Register endat_receive1_1 */
/* => Receive register 1 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_receive1_1        0x00000008U
#define Adr_NX90_endat0_app_endat_receive1_1 0xFF801708U
#define Adr_NX90_endat1_app_endat_receive1_1 0xFF801748U

#define MSK_NX90_endat_receive1_1_byte5 0x000000ffU
#define SRT_NX90_endat_receive1_1_byte5 0
#define MSK_NX90_endat_receive1_1_byte6 0x0000ff00U
#define SRT_NX90_endat_receive1_1_byte6 8
#define MSK_NX90_endat_receive1_1_byte7 0x00ff0000U
#define SRT_NX90_endat_receive1_1_byte7 16

/* all used bits of 'NX90_endat_receive1_1': */
#define MSK_USED_BITS_NX90_endat_receive1_1 0x00ffffffU

enum {
  BFW_NX90_endat_receive1_1_byte5     = 8, /* [7:0] */
  BFW_NX90_endat_receive1_1_byte6     = 8, /* [15:8] */
  BFW_NX90_endat_receive1_1_byte7     = 8, /* [23:16] */
  BFW_NX90_endat_receive1_1_reserved1 = 8  /* [31:24] */
};

typedef struct NX90_ENDAT_RECEIVE1_1_BIT_Ttag {
  unsigned int byte5     : BFW_NX90_endat_receive1_1_byte5;     /* ...      */
  unsigned int byte6     : BFW_NX90_endat_receive1_1_byte6;     /* ...      */
  unsigned int byte7     : BFW_NX90_endat_receive1_1_byte7;     /* ...      */
  unsigned int reserved1 : BFW_NX90_endat_receive1_1_reserved1; /* reserved */
} NX90_ENDAT_RECEIVE1_1_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_ENDAT_RECEIVE1_1_BIT_T bf;
} NX90_ENDAT_RECEIVE1_1_T;

/* --------------------------------------------------------------------- */
/* Register endat_receive2 */
/* => Receive register 2 */
/*    If a type 2.2 mode command was sent, receive register 2 will contain the contents of additional information 2 and its CRC. */
/*    This data is to be interpreted in accordance with the EnDat Interface Description. */
/*    In SSI protocol mode with double-word transmission, the redundant position value is stored here (right-aligned). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_receive2        0x0000000CU
#define Adr_NX90_endat0_app_endat_receive2 0xFF80170CU
#define Adr_NX90_endat1_app_endat_receive2 0xFF80174CU

#define MSK_NX90_endat_receive2_byte1 0x000000ffU
#define SRT_NX90_endat_receive2_byte1 0
#define MSK_NX90_endat_receive2_byte2 0x0000ff00U
#define SRT_NX90_endat_receive2_byte2 8
#define MSK_NX90_endat_receive2_byte3 0x00ff0000U
#define SRT_NX90_endat_receive2_byte3 16
#define MSK_NX90_endat_receive2_byte4 0xff000000U
#define SRT_NX90_endat_receive2_byte4 24

/* all used bits of 'NX90_endat_receive2': */
#define MSK_USED_BITS_NX90_endat_receive2 0xffffffffU

enum {
  BFW_NX90_endat_receive2_byte1 = 8, /* [7:0] */
  BFW_NX90_endat_receive2_byte2 = 8, /* [15:8] */
  BFW_NX90_endat_receive2_byte3 = 8, /* [23:16] */
  BFW_NX90_endat_receive2_byte4 = 8  /* [31:24] */
};

typedef struct NX90_ENDAT_RECEIVE2_BIT_Ttag {
  unsigned int byte1 : BFW_NX90_endat_receive2_byte1; /* ... */
  unsigned int byte2 : BFW_NX90_endat_receive2_byte2; /* ... */
  unsigned int byte3 : BFW_NX90_endat_receive2_byte3; /* ... */
  unsigned int byte4 : BFW_NX90_endat_receive2_byte4; /* ... */
} NX90_ENDAT_RECEIVE2_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_ENDAT_RECEIVE2_BIT_T bf;
} NX90_ENDAT_RECEIVE2_T;

/* --------------------------------------------------------------------- */
/* Register endat_receive3 */
/* => Receive register 3 */
/*    If a type 2.2 mode command was sent, receive register 3 will contain the contents of additional information 1 and its CRC. */
/*    This data is to be interpreted in accordance with the EnDat Interface Description. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_receive3        0x00000010U
#define Adr_NX90_endat0_app_endat_receive3 0xFF801710U
#define Adr_NX90_endat1_app_endat_receive3 0xFF801750U

#define MSK_NX90_endat_receive3_byte1 0x000000ffU
#define SRT_NX90_endat_receive3_byte1 0
#define MSK_NX90_endat_receive3_byte2 0x0000ff00U
#define SRT_NX90_endat_receive3_byte2 8
#define MSK_NX90_endat_receive3_byte3 0x00ff0000U
#define SRT_NX90_endat_receive3_byte3 16
#define MSK_NX90_endat_receive3_byte4 0xff000000U
#define SRT_NX90_endat_receive3_byte4 24

/* all used bits of 'NX90_endat_receive3': */
#define MSK_USED_BITS_NX90_endat_receive3 0xffffffffU

enum {
  BFW_NX90_endat_receive3_byte1 = 8, /* [7:0] */
  BFW_NX90_endat_receive3_byte2 = 8, /* [15:8] */
  BFW_NX90_endat_receive3_byte3 = 8, /* [23:16] */
  BFW_NX90_endat_receive3_byte4 = 8  /* [31:24] */
};

typedef struct NX90_ENDAT_RECEIVE3_BIT_Ttag {
  unsigned int byte1 : BFW_NX90_endat_receive3_byte1; /* ... */
  unsigned int byte2 : BFW_NX90_endat_receive3_byte2; /* ... */
  unsigned int byte3 : BFW_NX90_endat_receive3_byte3; /* ... */
  unsigned int byte4 : BFW_NX90_endat_receive3_byte4; /* ... */
} NX90_ENDAT_RECEIVE3_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_ENDAT_RECEIVE3_BIT_T bf;
} NX90_ENDAT_RECEIVE3_T;

/* --------------------------------------------------------------------- */
/* Register endat_conf1 */
/* => Configuration register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_conf1        0x00000014U
#define Adr_NX90_endat0_app_endat_conf1 0xFF801714U
#define Adr_NX90_endat1_app_endat_conf1 0xFF801754U
#define DFLT_VAL_NX90_endat_conf1       0x00000df0U

#define MSK_NX90_endat_conf1_hw_strobe                   0x00000001U
#define SRT_NX90_endat_conf1_hw_strobe                   0
#define DFLT_VAL_NX90_endat_conf1_hw_strobe              0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_hw_strobe           0x00000000U
#define MSK_NX90_endat_conf1_uncond_transfer             0x00000002U
#define SRT_NX90_endat_conf1_uncond_transfer             1
#define DFLT_VAL_NX90_endat_conf1_uncond_transfer        0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_uncond_transfer     0x00000000U
#define MSK_NX90_endat_conf1_endat_cont_clk_mode         0x00000004U
#define SRT_NX90_endat_conf1_endat_cont_clk_mode         2
#define DFLT_VAL_NX90_endat_conf1_endat_cont_clk_mode    0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_endat_cont_clk_mode 0x00000000U
#define MSK_NX90_endat_conf1_f_tclk                      0x000000f0U
#define SRT_NX90_endat_conf1_f_tclk                      4
#define DFLT_VAL_NX90_endat_conf1_f_tclk                 0x000000f0U
#define DFLT_BF_VAL_NX90_endat_conf1_f_tclk              0x0000000fU
#define MSK_NX90_endat_conf1_data_word_len               0x00003f00U
#define SRT_NX90_endat_conf1_data_word_len               8
#define DFLT_VAL_NX90_endat_conf1_data_word_len          0x00000d00U
#define DFLT_BF_VAL_NX90_endat_conf1_data_word_len       0x0000000dU
#define MSK_NX90_endat_conf1_reset_window                0x00004000U
#define SRT_NX90_endat_conf1_reset_window                14
#define DFLT_VAL_NX90_endat_conf1_reset_window           0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_reset_window        0x00000000U
#define MSK_NX90_endat_conf1_auto_reset                  0x00008000U
#define SRT_NX90_endat_conf1_auto_reset                  15
#define DFLT_VAL_NX90_endat_conf1_auto_reset             0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_auto_reset          0x00000000U
#define MSK_NX90_endat_conf1_cable_prop_time             0x00ff0000U
#define SRT_NX90_endat_conf1_cable_prop_time             16
#define DFLT_VAL_NX90_endat_conf1_cable_prop_time        0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_cable_prop_time     0x00000000U
#define MSK_NX90_endat_conf1_delay_comp                  0x01000000U
#define SRT_NX90_endat_conf1_delay_comp                  24
#define DFLT_VAL_NX90_endat_conf1_delay_comp             0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_delay_comp          0x00000000U
#define MSK_NX90_endat_conf1_f_sys                       0x1c000000U
#define SRT_NX90_endat_conf1_f_sys                       26
#define DFLT_VAL_NX90_endat_conf1_f_sys                  0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_f_sys               0x00000000U
#define MSK_NX90_endat_conf1_ic_reset                    0x20000000U
#define SRT_NX90_endat_conf1_ic_reset                    29
#define DFLT_VAL_NX90_endat_conf1_ic_reset               0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_ic_reset            0x00000000U
#define MSK_NX90_endat_conf1_endat_ssi                   0xc0000000U
#define SRT_NX90_endat_conf1_endat_ssi                   30
#define DFLT_VAL_NX90_endat_conf1_endat_ssi              0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf1_endat_ssi           0x00000000U

/* all used bits of 'NX90_endat_conf1': */
#define MSK_USED_BITS_NX90_endat_conf1 0xfdfffff7U

enum {
  BFW_NX90_endat_conf1_hw_strobe           = 1, /* [0] */
  BFW_NX90_endat_conf1_uncond_transfer     = 1, /* [1] */
  BFW_NX90_endat_conf1_endat_cont_clk_mode = 1, /* [2] */
  BFW_NX90_endat_conf1_reserved1           = 1, /* [3] */
  BFW_NX90_endat_conf1_f_tclk              = 4, /* [7:4] */
  BFW_NX90_endat_conf1_data_word_len       = 6, /* [13:8] */
  BFW_NX90_endat_conf1_reset_window        = 1, /* [14] */
  BFW_NX90_endat_conf1_auto_reset          = 1, /* [15] */
  BFW_NX90_endat_conf1_cable_prop_time     = 8, /* [23:16] */
  BFW_NX90_endat_conf1_delay_comp          = 1, /* [24] */
  BFW_NX90_endat_conf1_reserved2           = 1, /* [25] */
  BFW_NX90_endat_conf1_f_sys               = 3, /* [28:26] */
  BFW_NX90_endat_conf1_ic_reset            = 1, /* [29] */
  BFW_NX90_endat_conf1_endat_ssi           = 2  /* [31:30] */
};

typedef struct NX90_ENDAT_CONF1_BIT_Ttag {
  unsigned int hw_strobe           : BFW_NX90_endat_conf1_hw_strobe;           /* 1: Enables external /STR signal as strobe signal                                                                                   */
  unsigned int uncond_transfer     : BFW_NX90_endat_conf1_uncond_transfer;     /* This bit defines the unconditional data transfer to receive registers 1, 2, 3, 4 on completion of a data transmission process,     */
                                                                               /* despite a flag being set in the status register.                                                                                   */
                                                                               /* Data transfer according to flag set in the status register = 0                                                                     */
                                                                               /* Data transfer despite the flag in the status register = 1                                                                          */
                                                                               /* For safety applications uncond_transfer = 1 must be set.                                                                           */
  unsigned int endat_cont_clk_mode : BFW_NX90_endat_conf1_endat_cont_clk_mode; /* This bit is used to select the EnDat continuous clock mode.                                                                        */
                                                                               /* Continuous clock off = 0                                                                                                           */
                                                                               /* Continuous clock on = 1                                                                                                            */
  unsigned int reserved1           : BFW_NX90_endat_conf1_reserved1;           /* reserved                                                                                                                           */
  unsigned int f_tclk              : BFW_NX90_endat_conf1_f_tclk;              /* Setting (4 bit) of transmission rate for EnDat and SSI from 100 kHz to 1 MHz (SSI) or 16 MHz (EnDat).                              */
                                                                               /* Transmission frequency = 100kHz   = 1111                                                                                           */
                                                                               /* Transmission frequency = 200kHz   = 1110                                                                                           */
                                                                               /* Transmission frequency = 1MHz     = 1101                                                                                           */
                                                                               /* Transmission frequency = 2MHz     = 1100                                                                                           */
                                                                               /* Transmission frequency = 4.16MHz  = 1011                                                                                           */
                                                                               /* Transmission frequency = 8.33MHz  = 0110                                                                                           */
                                                                               /* Transmission frequency = 16.67MHz = 0000..0011                                                                                     */
  unsigned int data_word_len       : BFW_NX90_endat_conf1_data_word_len;       /* Here the data word length is set binary with 6 bits for EnDat or SSI.                                                              */
                                                                               /* The permissible setting range for EnDat is from 8 bits to 48 bits.                                                                 */
                                                                               /* The permissible setting range for SSI is from 8 bits to 48 bits.                                                                   */
                                                                               /* Data word length = 0 bits = 00 1000                                                                                                */
                                                                               /* :                                                                                                                                  */
                                                                               /* Data word length = 13 bits = 00 1101                                                                                               */
                                                                               /* :                                                                                                                                  */
                                                                               /* Data word length = 48 bits = 11 0000                                                                                               */
                                                                               /* Note: The Data word length has to set to 40/d bit while using mode command "encoder transmit test values".                         */
                                                                               /* Note: In SSI mode the additionally required clock cycle for the parity bit is generated automatically by the circuit.              */
  unsigned int reset_window        : BFW_NX90_endat_conf1_reset_window;        /* The set bit allows resetting of the status and error register only within a defined time period.                                   */
                                                                               /* Reset window = 0 Resetting of the registers mentioned above can be performed                                                       */
                                                                               /*                  anytime (i.e. without considering malfunctions).                                                                  */
                                                                               /* Reset Window = 1 Resetting of the registers mentioned above must be performed within                                               */
                                                                               /*                  a defined time period for acceptance by the protocol engine.                                                      */
                                                                               /* For safety applications: reset window = 1                                                                                          */
  unsigned int auto_reset          : BFW_NX90_endat_conf1_auto_reset;          /* Autom. reset (automatic reset). If this bit is set, resetting of the status register and error register is performed automatically */
                                                                               /* Autom. reset = 0 Resetting of the above-mentioned registers must be                                                                */
                                                                               /*                  performed by the application.                                                                                     */
                                                                               /* Autom. reset = 1 Resetting of the above-mentioned registers is done automatically.                                                 */
                                                                               /*                  However, this resetting only occurs in the next EnDat transmission with the start of data reception.              */
                                                                               /* For safety applications: autom. reset = 0                                                                                          */
  unsigned int cable_prop_time     : BFW_NX90_endat_conf1_cable_prop_time;     /* The cable propagation time determined by the interface component is stored here.                                                   */
                                                                               /* (The application may change this value.                                                                                            */
                                                                               /* If that is the case the status registers propagation time measurement (LZM) bit will automatically be reset).                      */
                                                                               /* The binary value has a step width of one system clock.                                                                             */
                                                                               /* At a system clock of 64 MHz, this corresponds to a setting range from 0 us to 3.98 us in steps of 15.6 ns.                         */
                                                                               /* The basic setting is 00 hex                                                                                                        */
  unsigned int delay_comp          : BFW_NX90_endat_conf1_delay_comp;          /* Delay compensation.                                                                                                                */
                                                                               /* This bit switches propagation delay compensation on.                                                                               */
                                                                               /* When this bit is set, propagation time measurement is performed with the next data transmission to the EnDat encoder.              */
                                                                               /* The interface component determines the cable propagation time and saves this in conf_reg1.                                         */
                                                                               /* This value is used to determine propagation delay compensation.                                                                    */
                                                                               /* To measure the propagation time again, the delay compensation bit must be reset and set again.                                     */
                                                                               /* For 16-bit access it must be considered that the measured cable propagation time value is overwritten with 00/h.                   */
                                                                               /* Delay compensation off = 0                                                                                                         */
                                                                               /* Delay compensation on = 1                                                                                                          */
                                                                               /* In SSI mode, this bit is always on:                                                                                                */
                                                                               /* Delay compensation off = 0 (SSI mode)                                                                                              */
  unsigned int reserved2           : BFW_NX90_endat_conf1_reserved2;           /* reserved                                                                                                                           */
  unsigned int f_sys               : BFW_NX90_endat_conf1_f_sys;               /* The system frequency actually used must be selected here.                                                                          */
                                                                               /* 64/48/32/50/100 MHz = 000/010/100/101/110                                                                                          */
  unsigned int ic_reset            : BFW_NX90_endat_conf1_ic_reset;            /* Setting of this bit has the effect that the entire interface component is reset to its initial state.                              */
                                                                               /* IC reset inactive = 0                                                                                                              */
                                                                               /* IC reset active = 1                                                                                                                */
  unsigned int endat_ssi           : BFW_NX90_endat_conf1_endat_ssi;           /* These two bits set either the EnDat (0x2) or the SSI (0x1) transmission mode.                                                      */
                                                                               /* Values 0x0 and 0x3 are not permitted.                                                                                              */
                                                                               /* Note: For debugging purposes, this function may also be used to perform an internal status                                         */
                                                                               /* engine software reset without clearing of the other internal registers.                                                            */
} NX90_ENDAT_CONF1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ENDAT_CONF1_BIT_T bf;
} NX90_ENDAT_CONF1_T;

/* --------------------------------------------------------------------- */
/* Register endat_conf2 */
/* => Configuration register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_conf2        0x00000018U
#define Adr_NX90_endat0_app_endat_conf2 0xFF801718U
#define Adr_NX90_endat1_app_endat_conf2 0xFF801758U
#define DFLT_VAL_NX90_endat_conf2       0x00040000U

#define MSK_NX90_endat_conf2_timer_for_sampling_rate         0x000000ffU
#define SRT_NX90_endat_conf2_timer_for_sampling_rate         0
#define DFLT_VAL_NX90_endat_conf2_timer_for_sampling_rate    0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf2_timer_for_sampling_rate 0x00000000U
#define MSK_NX90_endat_conf2_watchdog                        0x0000ff00U
#define SRT_NX90_endat_conf2_watchdog                        8
#define DFLT_VAL_NX90_endat_conf2_watchdog                   0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf2_watchdog                0x00000000U
#define MSK_NX90_endat_conf2_t_st                            0x00070000U
#define SRT_NX90_endat_conf2_t_st                            16
#define DFLT_VAL_NX90_endat_conf2_t_st                       0x00040000U
#define DFLT_BF_VAL_NX90_endat_conf2_t_st                    0x00000004U
#define MSK_NX90_endat_conf2_filter                          0x00380000U
#define SRT_NX90_endat_conf2_filter                          19
#define DFLT_VAL_NX90_endat_conf2_filter                     0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf2_filter                  0x00000000U
#define MSK_NX90_endat_conf2_rtm                             0x00400000U
#define SRT_NX90_endat_conf2_rtm                             22
#define DFLT_VAL_NX90_endat_conf2_rtm                        0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf2_rtm                     0x00000000U
#define MSK_NX90_endat_conf2_hw_strobe_delay                 0xff000000U
#define SRT_NX90_endat_conf2_hw_strobe_delay                 24
#define DFLT_VAL_NX90_endat_conf2_hw_strobe_delay            0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf2_hw_strobe_delay         0x00000000U

/* all used bits of 'NX90_endat_conf2': */
#define MSK_USED_BITS_NX90_endat_conf2 0xff7fffffU

enum {
  BFW_NX90_endat_conf2_timer_for_sampling_rate = 8, /* [7:0] */
  BFW_NX90_endat_conf2_watchdog                = 8, /* [15:8] */
  BFW_NX90_endat_conf2_t_st                    = 3, /* [18:16] */
  BFW_NX90_endat_conf2_filter                  = 3, /* [21:19] */
  BFW_NX90_endat_conf2_rtm                     = 1, /* [22] */
  BFW_NX90_endat_conf2_reserved1               = 1, /* [23] */
  BFW_NX90_endat_conf2_hw_strobe_delay         = 8  /* [31:24] */
};

typedef struct NX90_ENDAT_CONF2_BIT_Ttag {
  unsigned int timer_for_sampling_rate : BFW_NX90_endat_conf2_timer_for_sampling_rate; /* 256 different sampling rates can be set.                                                                                                          */
                                                                                       /* In the default setting 00 hex or 80 hex the timer is off.                                                                                         */
  unsigned int watchdog                : BFW_NX90_endat_conf2_watchdog;                /* 256 different watchdog time values can be set.                                                                                                    */
                                                                                       /* In the default setting 00 hex or 80 hex the watchdog is off.                                                                                      */
  unsigned int t_st                    : BFW_NX90_endat_conf2_t_st;                    /* This time is to be set in accordance with EnDat specification.                                                                                    */
                                                                                       /* The set time has an accuracy of 0.1 us.                                                                                                           */
                                                                                       /* Setting 000 = 0.5 * TCLK                                                                                                                          */
                                                                                       /* Setting 001 = 0.5 us                                                                                                                              */
                                                                                       /* Setting 010 = 1 us                                                                                                                                */
                                                                                       /* Setting 011 = 1.5 us                                                                                                                              */
                                                                                       /* Setting 100 = 2 us                                                                                                                                */
                                                                                       /* Setting 101 = 4 us                                                                                                                                */
                                                                                       /* Setting 110 = 8 us                                                                                                                                */
                                                                                       /* Setting 111 = 10 us                                                                                                                               */
  unsigned int filter                  : BFW_NX90_endat_conf2_filter;                  /* The digital filter for the Data_RC data input can be adjusted in eight steps (3 bits) as shown in the table below.                                */
                                                                                       /* The filter setting value corresponds to system clock cycles.                                                                                      */
                                                                                       /* Setting 000 = Off                                                                                                                                 */
                                                                                       /* Setting 001 = 3                                                                                                                                   */
                                                                                       /* Setting 010 = 4                                                                                                                                   */
                                                                                       /* Setting 011 = 5                                                                                                                                   */
                                                                                       /* Setting 100 = 6                                                                                                                                   */
                                                                                       /* Setting 101 = 10                                                                                                                                  */
                                                                                       /* Setting 110 = 20                                                                                                                                  */
                                                                                       /* Setting 111 = 40                                                                                                                                  */
                                                                                       /* Setting             000     001     010     011     100     101     110     111                                                                   */
                                                                                       /* Note on the application:                                                                                                                          */
                                                                                       /* The filter must be set according to the transmission rate of the serial interface to the encoder.                                                 */
                                                                                       /* Example: fTCLK = 1 MHz (corresponds to 64 system clock cycles with CLK = 64 MHz)                                                                  */
                                                                                       /* For the filter, 1/10 of the fTCLK must be set. That means 6 system clock cycles leads to setting: 100                                             */
  unsigned int rtm                     : BFW_NX90_endat_conf2_rtm;                     /* Activates the recovery time measurement that is then performed after each EnDat                                                                   */
                                                                                       /* transmission with the mode command 1-1 "Encoder transmit position value and selection of                                                          */
                                                                                       /* memory area" with MRS code 0x43 (selection of 2nd word of position value 2).                                                                      */
                                                                                       /* RTM=0 Recovery time measurement is deactivated (default setting after reset)                                                                      */
                                                                                       /* RTM=1 Recovery time measurement is activated                                                                                                      */
  unsigned int reserved1               : BFW_NX90_endat_conf2_reserved1;               /* reserved                                                                                                                                          */
  unsigned int hw_strobe_delay         : BFW_NX90_endat_conf2_hw_strobe_delay;         /* Here the application can enter a value for the HW strobe delay. The binary value has a step width of one system clock.                            */
                                                                                       /*  Setting 00 = Off, 3..255=3..255 system clock cycles                                                                                              */
                                                                                       /* The values 1, 2 are not permissible. At a system clock of 64 MHz, this corresponds to a value range from 46.88 ns to 3.98 us in steps of 15.6 ns. */
} NX90_ENDAT_CONF2_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ENDAT_CONF2_BIT_T bf;
} NX90_ENDAT_CONF2_T;

/* --------------------------------------------------------------------- */
/* Register endat_conf3 */
/* => Configuration register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_conf3        0x0000001CU
#define Adr_NX90_endat0_app_endat_conf3 0xFF80171CU
#define Adr_NX90_endat1_app_endat_conf3 0xFF80175CU
#define DFLT_VAL_NX90_endat_conf3       0x000000ccU

#define MSK_NX90_endat_conf3_parity                 0x00000001U
#define SRT_NX90_endat_conf3_parity                 0
#define DFLT_VAL_NX90_endat_conf3_parity            0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf3_parity         0x00000000U
#define MSK_NX90_endat_conf3_format                 0x00000002U
#define SRT_NX90_endat_conf3_format                 1
#define DFLT_VAL_NX90_endat_conf3_format            0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf3_format         0x00000000U
#define MSK_NX90_endat_conf3_gray_to_binary         0x00000004U
#define SRT_NX90_endat_conf3_gray_to_binary         2
#define DFLT_VAL_NX90_endat_conf3_gray_to_binary    0x00000004U
#define DFLT_BF_VAL_NX90_endat_conf3_gray_to_binary 0x00000001U
#define MSK_NX90_endat_conf3_singleturn_res         0x000000f8U
#define SRT_NX90_endat_conf3_singleturn_res         3
#define DFLT_VAL_NX90_endat_conf3_singleturn_res    0x000000c8U
#define DFLT_BF_VAL_NX90_endat_conf3_singleturn_res 0x00000019U
#define MSK_NX90_endat_conf3_dw                     0x00000100U
#define SRT_NX90_endat_conf3_dw                     8
#define DFLT_VAL_NX90_endat_conf3_dw                0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf3_dw             0x00000000U
#define MSK_NX90_endat_conf3_speed                  0x00008000U
#define SRT_NX90_endat_conf3_speed                  15
#define DFLT_VAL_NX90_endat_conf3_speed             0x00000000U
#define DFLT_BF_VAL_NX90_endat_conf3_speed          0x00000000U

/* all used bits of 'NX90_endat_conf3': */
#define MSK_USED_BITS_NX90_endat_conf3 0x000081ffU

enum {
  BFW_NX90_endat_conf3_parity         = 1,  /* [0] */
  BFW_NX90_endat_conf3_format         = 1,  /* [1] */
  BFW_NX90_endat_conf3_gray_to_binary = 1,  /* [2] */
  BFW_NX90_endat_conf3_singleturn_res = 5,  /* [7:3] */
  BFW_NX90_endat_conf3_dw             = 1,  /* [8] */
  BFW_NX90_endat_conf3_reserved1      = 6,  /* [14:9] */
  BFW_NX90_endat_conf3_speed          = 1,  /* [15] */
  BFW_NX90_endat_conf3_reserved2      = 16  /* [31:16] */
};

typedef struct NX90_ENDAT_CONF3_BIT_Ttag {
  unsigned int parity         : BFW_NX90_endat_conf3_parity;         /* Here the parity check for SSI transmission is selected.                                 */
                                                                     /* Parity off = 0                                                                          */
                                                                     /* Parity on  = 1                                                                          */
  unsigned int format         : BFW_NX90_endat_conf3_format;         /* Here the transmission format for SSI transmission is selected.                          */
                                                                     /* Fir tree: 0                                                                             */
                                                                     /* Serial, right-aligned = 1                                                               */
  unsigned int gray_to_binary : BFW_NX90_endat_conf3_gray_to_binary; /* In SSI transmission mode, Gray code values can be converted here to binary code values. */
                                                                     /* Gray-to-binary conversion inactive = 0                                                  */
                                                                     /* Gray-to-binary conversion inactive = 1                                                  */
  unsigned int singleturn_res : BFW_NX90_endat_conf3_singleturn_res; /* Here the number of steps per revolution is set to binary with 5 bits.                   */
                                                                     /* This setting is only required for the fir tree format.                                  */
                                                                     /* Singleturn resolution = 13 bits = 0 1101                                                */
  unsigned int dw             : BFW_NX90_endat_conf3_dw;             /* This bit allows a double-word query to be selected with SSI transmission.               */
                                                                     /* Double-word query off = 0                                                               */
                                                                     /* Double word query on  = 1                                                               */
  unsigned int reserved1      : BFW_NX90_endat_conf3_reserved1;      /* reserved                                                                                */
  unsigned int speed          : BFW_NX90_endat_conf3_speed;          /* (optional) This bit allows selection of the register width for velocity.                */
                                                                     /* 64-bit = 0                                                                              */
                                                                     /* 32-Bit = 1                                                                              */
  unsigned int reserved2      : BFW_NX90_endat_conf3_reserved2;      /* reserved                                                                                */
} NX90_ENDAT_CONF3_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ENDAT_CONF3_BIT_T bf;
} NX90_ENDAT_CONF3_T;

/* --------------------------------------------------------------------- */
/* Register endat_stat */
/* => Status register */
/*    The status bits are created by the sequencing controller of the interface component, as required. */
/*    Status information remains set until it is reset by the application. */
/*    The application can selectively reset status information with a write command. */
/*    This occurs by writing 1 to the selected bits. In the event of concurrent access, the internal sequencing controller has priority. */
/*    This ensures that status information is not 'lost'. */
/*    The status bits (15:11) are only valid when additional information 1 or 2 has been received. */
/*    Note on the application: */
/*    The status register should be read after each data transmission. It provides information about validity of the data contained in the receive registers. */
/*    The status bits must be reset in order that the internal sequencing controller can recognize a renewed setting of the status bits. */
/*    Note: Each bit (except for LZM, LZK, Ready for Strobe) can trigger an interrupt (output: INT1). */
/*    Masking is performed with the interrupt mask register. */
/*    If a bit that has been set (and thus has triggered an interrupt) is reset, the INT1 output changes from low to three-state if no other bit has triggered an interrupt. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_stat        0x00000020U
#define Adr_NX90_endat0_app_endat_stat 0xFF801720U
#define Adr_NX90_endat1_app_endat_stat 0xFF801760U
#define DFLT_VAL_NX90_endat_stat       0x40000400U

#define MSK_NX90_endat_stat_receive1_reg                  0x00000001U
#define SRT_NX90_endat_stat_receive1_reg                  0
#define DFLT_VAL_NX90_endat_stat_receive1_reg             0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_receive1_reg          0x00000000U
#define MSK_NX90_endat_stat_error1                        0x00000002U
#define SRT_NX90_endat_stat_error1                        1
#define DFLT_VAL_NX90_endat_stat_error1                   0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_error1                0x00000000U
#define MSK_NX90_endat_stat_crcpw_parity                  0x00000004U
#define SRT_NX90_endat_stat_crcpw_parity                  2
#define DFLT_VAL_NX90_endat_stat_crcpw_parity             0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_crcpw_parity          0x00000000U
#define MSK_NX90_endat_stat_f_type1                       0x00000008U
#define SRT_NX90_endat_stat_f_type1                       3
#define DFLT_VAL_NX90_endat_stat_f_type1                  0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_f_type1               0x00000000U
#define MSK_NX90_endat_stat_f_type2                       0x00000010U
#define SRT_NX90_endat_stat_f_type2                       4
#define DFLT_VAL_NX90_endat_stat_f_type2                  0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_f_type2               0x00000000U
#define MSK_NX90_endat_stat_mrs_adr                       0x00000020U
#define SRT_NX90_endat_stat_mrs_adr                       5
#define DFLT_VAL_NX90_endat_stat_mrs_adr                  0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_mrs_adr               0x00000000U
#define MSK_NX90_endat_stat_ir6                           0x00000040U
#define SRT_NX90_endat_stat_ir6                           6
#define DFLT_VAL_NX90_endat_stat_ir6                      0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_ir6                   0x00000000U
#define MSK_NX90_endat_stat_ir7                           0x00000080U
#define SRT_NX90_endat_stat_ir7                           7
#define DFLT_VAL_NX90_endat_stat_ir7                      0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_ir7                   0x00000000U
#define MSK_NX90_endat_stat_receive2_reg                  0x00000100U
#define SRT_NX90_endat_stat_receive2_reg                  8
#define DFLT_VAL_NX90_endat_stat_receive2_reg             0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_receive2_reg          0x00000000U
#define MSK_NX90_endat_stat_receive3_reg                  0x00000200U
#define SRT_NX90_endat_stat_receive3_reg                  9
#define DFLT_VAL_NX90_endat_stat_receive3_reg             0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_receive3_reg          0x00000000U
#define MSK_NX90_endat_stat_error2                        0x00000400U
#define SRT_NX90_endat_stat_error2                        10
#define DFLT_VAL_NX90_endat_stat_error2                   0x00000400U
#define DFLT_BF_VAL_NX90_endat_stat_error2                0x00000001U
#define MSK_NX90_endat_stat_crc_zi1                       0x00000800U
#define SRT_NX90_endat_stat_crc_zi1                       11
#define DFLT_VAL_NX90_endat_stat_crc_zi1                  0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_crc_zi1               0x00000000U
#define MSK_NX90_endat_stat_crc_zi2                       0x00001000U
#define SRT_NX90_endat_stat_crc_zi2                       12
#define DFLT_VAL_NX90_endat_stat_crc_zi2                  0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_crc_zi2               0x00000000U
#define MSK_NX90_endat_stat_busy                          0x00002000U
#define SRT_NX90_endat_stat_busy                          13
#define DFLT_VAL_NX90_endat_stat_busy                     0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_busy                  0x00000000U
#define MSK_NX90_endat_stat_rm                            0x00004000U
#define SRT_NX90_endat_stat_rm                            14
#define DFLT_VAL_NX90_endat_stat_rm                       0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_rm                    0x00000000U
#define MSK_NX90_endat_stat_wrn                           0x00008000U
#define SRT_NX90_endat_stat_wrn                           15
#define DFLT_VAL_NX90_endat_stat_wrn                      0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_wrn                   0x00000000U
#define MSK_NX90_endat_stat_spike                         0x00010000U
#define SRT_NX90_endat_stat_spike                         16
#define DFLT_VAL_NX90_endat_stat_spike                    0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_spike                 0x00000000U
#define MSK_NX90_endat_stat_watchdog                      0x00020000U
#define SRT_NX90_endat_stat_watchdog                      17
#define DFLT_VAL_NX90_endat_stat_watchdog                 0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_watchdog              0x00000000U
#define MSK_NX90_endat_stat_f_type3                       0x00040000U
#define SRT_NX90_endat_stat_f_type3                       18
#define DFLT_VAL_NX90_endat_stat_f_type3                  0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_f_type3               0x00000000U
#define MSK_NX90_endat_stat_delay_comp                    0x00400000U
#define SRT_NX90_endat_stat_delay_comp                    22
#define DFLT_VAL_NX90_endat_stat_delay_comp               0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_delay_comp            0x00000000U
#define MSK_NX90_endat_stat_prop_time_measurement         0x00800000U
#define SRT_NX90_endat_stat_prop_time_measurement         23
#define DFLT_VAL_NX90_endat_stat_prop_time_measurement    0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_prop_time_measurement 0x00000000U
#define MSK_NX90_endat_stat_rtm_start                     0x08000000U
#define SRT_NX90_endat_stat_rtm_start                     27
#define DFLT_VAL_NX90_endat_stat_rtm_start                0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_rtm_start             0x00000000U
#define MSK_NX90_endat_stat_rtm_stop                      0x10000000U
#define SRT_NX90_endat_stat_rtm_stop                      28
#define DFLT_VAL_NX90_endat_stat_rtm_stop                 0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_rtm_stop              0x00000000U
#define MSK_NX90_endat_stat_speed_ready                   0x20000000U
#define SRT_NX90_endat_stat_speed_ready                   29
#define DFLT_VAL_NX90_endat_stat_speed_ready              0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_speed_ready           0x00000000U
#define MSK_NX90_endat_stat_ready_for_strobe              0x40000000U
#define SRT_NX90_endat_stat_ready_for_strobe              30
#define DFLT_VAL_NX90_endat_stat_ready_for_strobe         0x40000000U
#define DFLT_BF_VAL_NX90_endat_stat_ready_for_strobe      0x00000001U
#define MSK_NX90_endat_stat_ready                         0x80000000U
#define SRT_NX90_endat_stat_ready                         31
#define DFLT_VAL_NX90_endat_stat_ready                    0x00000000U
#define DFLT_BF_VAL_NX90_endat_stat_ready                 0x00000000U

/* all used bits of 'NX90_endat_stat': */
#define MSK_USED_BITS_NX90_endat_stat 0xf8c7ffffU

enum {
  BFW_NX90_endat_stat_receive1_reg          = 1, /* [0] */
  BFW_NX90_endat_stat_error1                = 1, /* [1] */
  BFW_NX90_endat_stat_crcpw_parity          = 1, /* [2] */
  BFW_NX90_endat_stat_f_type1               = 1, /* [3] */
  BFW_NX90_endat_stat_f_type2               = 1, /* [4] */
  BFW_NX90_endat_stat_mrs_adr               = 1, /* [5] */
  BFW_NX90_endat_stat_ir6                   = 1, /* [6] */
  BFW_NX90_endat_stat_ir7                   = 1, /* [7] */
  BFW_NX90_endat_stat_receive2_reg          = 1, /* [8] */
  BFW_NX90_endat_stat_receive3_reg          = 1, /* [9] */
  BFW_NX90_endat_stat_error2                = 1, /* [10] */
  BFW_NX90_endat_stat_crc_zi1               = 1, /* [11] */
  BFW_NX90_endat_stat_crc_zi2               = 1, /* [12] */
  BFW_NX90_endat_stat_busy                  = 1, /* [13] */
  BFW_NX90_endat_stat_rm                    = 1, /* [14] */
  BFW_NX90_endat_stat_wrn                   = 1, /* [15] */
  BFW_NX90_endat_stat_spike                 = 1, /* [16] */
  BFW_NX90_endat_stat_watchdog              = 1, /* [17] */
  BFW_NX90_endat_stat_f_type3               = 1, /* [18] */
  BFW_NX90_endat_stat_reserved1             = 3, /* [21:19] */
  BFW_NX90_endat_stat_delay_comp            = 1, /* [22] */
  BFW_NX90_endat_stat_prop_time_measurement = 1, /* [23] */
  BFW_NX90_endat_stat_reserved2             = 3, /* [26:24] */
  BFW_NX90_endat_stat_rtm_start             = 1, /* [27] */
  BFW_NX90_endat_stat_rtm_stop              = 1, /* [28] */
  BFW_NX90_endat_stat_speed_ready           = 1, /* [29] */
  BFW_NX90_endat_stat_ready_for_strobe      = 1, /* [30] */
  BFW_NX90_endat_stat_ready                 = 1  /* [31] */
};

typedef struct NX90_ENDAT_STAT_BIT_Ttag {
  unsigned int receive1_reg          : BFW_NX90_endat_stat_receive1_reg;          /* This status flag indicates that the data in Receive-Reg 1 has been updated.                                                                                             */
                                                                                  /* It must be cleared after Receive-Reg1 has been read to allow the interface component to rewrite data there.                                                             */
                                                                                  /* Receive-Reg1 not updated = 0                                                                                                                                            */
                                                                                  /* Receive-Reg1 updated     = 1                                                                                                                                            */
                                                                                  /* Note: This flag is ignored if the uncond_transfer bit is enabled in conf-Reg 1.                                                                                         */
  unsigned int error1                : BFW_NX90_endat_stat_error1;                /* The status bit error1 from the EnDat protocol is entered here.                                                                                                          */
                                                                                  /* Error1 did not occur = 0                                                                                                                                                */
                                                                                  /* Error1 occurred = 1                                                                                                                                                     */
  unsigned int crcpw_parity          : BFW_NX90_endat_stat_crcpw_parity;          /* This bit has two meanings.                                                                                                                                              */
                                                                                  /* With EnDat transmission it represents the result of the CRC check of the received value (position value, parameter or test value).                                      */
                                                                                  /* With SSI transmission it shows the result of the parity check. Condition: parity check in conf-Reg1 is switched on.                                                     */
                                                                                  /* CRC check or parity check okay = 0                                                                                                                                      */
                                                                                  /* CRC and parity check faulty    = 1                                                                                                                                      */
  unsigned int f_type1               : BFW_NX90_endat_stat_f_type1;               /* Shows type I error handling in accordance with the EnDat specification at Annex A2.                                                                                     */
                                                                                  /* A type I error did not occur = 0                                                                                                                                        */
                                                                                  /* A type I error occurred      = 1                                                                                                                                        */
  unsigned int f_type2               : BFW_NX90_endat_stat_f_type2;               /* Shows type II error handling in accordance with the EnDat specification at Annex A2.                                                                                    */
                                                                                  /* A type II error did not occur = 0                                                                                                                                       */
                                                                                  /* A type II error occurred = 1                                                                                                                                            */
  unsigned int mrs_adr               : BFW_NX90_endat_stat_mrs_adr;               /* The occurrence of an addressing or acknowledgement error is shown here as described in the EnDat Interface specification.                                               */
                                                                                  /* The errors (F type I / II) are special cases of MRS/address errors, i.e. they are a sub-quantity of these.                                                              */
                                                                                  /* Accordingly, whenever a type I or type II error is identified, the MRS/Adr bit is set.                                                                                  */
                                                                                  /* For example, if an MRS/address bit is recognized incorrectly due to a disturbance, only the MRS/Adr status bit will be set, not the F TYP I/II bits.                    */
                                                                                  /* No acknowledgement or addressing error has occurred = 0                                                                                                                 */
                                                                                  /* An acknowledgement or addressing error has occurred = 1                                                                                                                 */
  unsigned int ir6                   : BFW_NX90_endat_stat_ir6;                   /* This bit indicates an H/L edge at input pin /IR6.                                                                                                                       */
                                                                                  /* No H/L edge transition at input /IR6 = 0                                                                                                                                */
                                                                                  /* H/L edge transition has occurred at input /IR6R6 = 1                                                                                                                    */
  unsigned int ir7                   : BFW_NX90_endat_stat_ir7;                   /* This bit indicates the state of input pin /IR7.                                                                                                                         */
                                                                                  /* Input /IR7 is at high level = 0                                                                                                                                         */
                                                                                  /* Input /IR7 is at low level  = 1                                                                                                                                         */
  unsigned int receive2_reg          : BFW_NX90_endat_stat_receive2_reg;          /* This status flag indicates that the data in Receive-Reg 2 (3) has been updated.                                                                                         */
                                                                                  /* It must be cleared after Receive-Reg2 (3) has been read to allow the interface component to rewrite data.                                                               */
                                                                                  /* Receive-Reg2 (3) not updated = 0                                                                                                                                        */
                                                                                  /* Receive-Reg2 (3) updated     = 1                                                                                                                                        */
  unsigned int receive3_reg          : BFW_NX90_endat_stat_receive3_reg;          /* This status flag indicates that the data in Receive-Reg3 has been updated.                                                                                              */
                                                                                  /* It must be cleared after Receive-Reg3 has been read to allow the interface component to rewrite data.                                                                   */
                                                                                  /* Receive-Reg3 not updated = 0                                                                                                                                            */
                                                                                  /* Receive-Reg3 updated     = 1                                                                                                                                            */
  unsigned int error2                : BFW_NX90_endat_stat_error2;                /* Contains the /Error 2 status bit from the EnDat protocol (only with EnDat2.2 commands).                                                                                 */
                                                                                  /* /Error2 occurred      = 0                                                                                                                                               */
                                                                                  /* /Error2 did not occur = 1                                                                                                                                               */
  unsigned int crc_zi1               : BFW_NX90_endat_stat_crc_zi1;               /* During EnDat transmissions, this bit indicates the result of the CRC checking of additional information (ZI1).                                                          */
                                                                                  /* CRC check of ZI2 okay   = 0                                                                                                                                             */
                                                                                  /* CRC check of ZI2 faulty = 1                                                                                                                                             */
  unsigned int crc_zi2               : BFW_NX90_endat_stat_crc_zi2;               /* During EnDat transmissions, this bit indicates the result of the CRC checking of additional information (ZI2).                                                          */
                                                                                  /* CRC check of ZI2 okay   = 0                                                                                                                                             */
                                                                                  /* CRC check of ZI2 faulty = 1                                                                                                                                             */
  unsigned int busy                  : BFW_NX90_endat_stat_busy;                  /* Contains the Busy status bit as transmitted in the EnDat protocol.                                                                                                      */
                                                                                  /* Busy = 0                                                                                                                                                                */
                                                                                  /* Busy = 1                                                                                                                                                                */
  unsigned int rm                    : BFW_NX90_endat_stat_rm;                    /* Contains the RM status bit as transmitted in the EnDat protocol.                                                                                                        */
                                                                                  /* RM = 0                                                                                                                                                                  */
                                                                                  /* RM = 1                                                                                                                                                                  */
  unsigned int wrn                   : BFW_NX90_endat_stat_wrn;                   /* Contains the WRN status bit as transmitted in the EnDat protocol.                                                                                                       */
                                                                                  /* WRN = 0                                                                                                                                                                 */
                                                                                  /* WRN = 1                                                                                                                                                                 */
  unsigned int spike                 : BFW_NX90_endat_stat_spike;                 /* Reports that a Spike was detected at the data input port.                                                                                                               */
                                                                                  /* Condition: filter in conf_reg1 is set.                                                                                                                                  */
                                                                                  /* No spike       = 0                                                                                                                                                      */
                                                                                  /* Spike occurred = 1                                                                                                                                                      */
  unsigned int watchdog              : BFW_NX90_endat_stat_watchdog;              /* Reports triggering of the watchdog.                                                                                                                                     */
                                                                                  /* Condition: watchdog in conf_reg2 is set.                                                                                                                                */
                                                                                  /* Watchdog not triggered = 0                                                                                                                                              */
                                                                                  /* Watchdog triggered     = 1                                                                                                                                              */
  unsigned int f_type3               : BFW_NX90_endat_stat_f_type3;               /* Type II error (transmission layer) triggers F type III. Error recognition occurs in the EnDat master.                                                                   */
                                                                                  /* The error did not occur = 0                                                                                                                                             */
                                                                                  /* The error occurred      = 1                                                                                                                                             */
  unsigned int reserved1             : BFW_NX90_endat_stat_reserved1;             /* reserved                                                                                                                                                                */
  unsigned int delay_comp            : BFW_NX90_endat_stat_delay_comp;            /* (LZK). This bit reports if propagation delay compensation is active.                                                                                                    */
                                                                                  /* If propagation delay compensation in configuration register 1 is switched off, this bit and propagation time measurement will automatically be reset.                   */
                                                                                  /* LZK inactive = 0                                                                                                                                                        */
                                                                                  /* LZK active   = 1                                                                                                                                                        */
                                                                                  /* Neither the LZM nor the LZK bit can be reset by writing a 1 to the respective bit as this is a status display of the current conditions of internal automation engines. */
                                                                                  /* Neither of the two bits can cause an interrupt.                                                                                                                         */
  unsigned int prop_time_measurement : BFW_NX90_endat_stat_prop_time_measurement; /* (LZM). This bit reports that propagation time measurement was successfully completed.                                                                                   */
                                                                                  /* Condition: propagation delay compensation LZK in conf_reg1 is set.                                                                                                      */
                                                                                  /* If the value for propagation delay compensation in configuration register 1 is corrected by the application, this bit will automatically be reset.                      */
                                                                                  /* LZM incomplete = 0                                                                                                                                                      */
                                                                                  /* LZM complete   = 1                                                                                                                                                      */
  unsigned int reserved2             : BFW_NX90_endat_stat_reserved2;             /* reserved                                                                                                                                                                */
  unsigned int rtm_start             : BFW_NX90_endat_stat_rtm_start;             /* This bit indicates the beginning of the recovery time, if conf2(22)=1 during EnDat                                                                                      */
                                                                                  /* transmission with mode command 1-1 "Encoder transmit position value and selection of memory                                                                             */
                                                                                  /* area" with MRS code 0x43 (selection of 2nd word of position value 2)                                                                                                    */
  unsigned int rtm_stop              : BFW_NX90_endat_stat_rtm_stop;              /* This bit indicates the end of the recovery time, if conf2(22)=1 during EnDat                                                                                            */
                                                                                  /* transmission with mode command 1-1 "Encoder transmit position value and selection of memory                                                                             */
                                                                                  /* area" with MRS code 0x43 (selection of 2nd word of position value 2)                                                                                                    */
  unsigned int speed_ready           : BFW_NX90_endat_stat_speed_ready;           /* (optional). This bit reports that a new velocity value has been calculated.                                                                                             */
                                                                                  /* No new velocity value calculated = 0                                                                                                                                    */
                                                                                  /* New velocity value calculated    = 1                                                                                                                                    */
  unsigned int ready_for_strobe      : BFW_NX90_endat_stat_ready_for_strobe;      /* This bit reports that data transmission has ended and that the EnDat protocol automation machine is ready for the next transmission.                                    */
                                                                                  /* The time values Recovery time 1 (tm) and Recovery time 2 (tR) as specified in the EnDat specification are completed.                                                    */
                                                                                  /* No Ready = 0                                                                                                                                                            */
                                                                                  /* Ready    = 1                                                                                                                                                            */
                                                                                  /* This bit cannot be reset by writing a 1 to the respective bit as this is a status display of the current conditions of internal automation engines.                     */
                                                                                  /* The bit cannot cause an interrupt.                                                                                                                                      */
  unsigned int ready                 : BFW_NX90_endat_stat_ready;                 /* If the ready bit is set, the status register is completely updated. All checks have been performed.                                                                     */
                                                                                  /* Data transmission is not yet completed, however, meaning that the EnDat protocol automation machine is not yet ready again.                                             */
                                                                                  /* No Ready = 0                                                                                                                                                            */
                                                                                  /* Ready    = 1                                                                                                                                                            */
} NX90_ENDAT_STAT_BIT_T;

typedef union {
  uint32_t              val;
  NX90_ENDAT_STAT_BIT_T bf;
} NX90_ENDAT_STAT_T;

/* --------------------------------------------------------------------- */
/* Register endat_int */
/* => Interrupt mask */
/*    The interrupt mask register is for the masking of the status registers interrupt sources. */
/*    All bits shown in the status register (except for LZM, LZK, Ready for Strobe) can generate an interrupt. */
/*    The bit assignments of the interrupt mask register are identical to those of the status register. */
/*    An interrupt is allowed by setting the corresponding bit to 1. */
/*    The INT output changes from three-state to low. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_int        0x00000024U
#define Adr_NX90_endat0_app_endat_int 0xFF801724U
#define Adr_NX90_endat1_app_endat_int 0xFF801764U
#define DFLT_VAL_NX90_endat_int       0x00000000U

#define MSK_NX90_endat_int_receive1_reg         0x00000001U
#define SRT_NX90_endat_int_receive1_reg         0
#define DFLT_VAL_NX90_endat_int_receive1_reg    0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_receive1_reg 0x00000000U
#define MSK_NX90_endat_int_error1               0x00000002U
#define SRT_NX90_endat_int_error1               1
#define DFLT_VAL_NX90_endat_int_error1          0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_error1       0x00000000U
#define MSK_NX90_endat_int_crcpw_parity         0x00000004U
#define SRT_NX90_endat_int_crcpw_parity         2
#define DFLT_VAL_NX90_endat_int_crcpw_parity    0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_crcpw_parity 0x00000000U
#define MSK_NX90_endat_int_f_type1              0x00000008U
#define SRT_NX90_endat_int_f_type1              3
#define DFLT_VAL_NX90_endat_int_f_type1         0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_f_type1      0x00000000U
#define MSK_NX90_endat_int_f_type2              0x00000010U
#define SRT_NX90_endat_int_f_type2              4
#define DFLT_VAL_NX90_endat_int_f_type2         0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_f_type2      0x00000000U
#define MSK_NX90_endat_int_mrs_adr              0x00000020U
#define SRT_NX90_endat_int_mrs_adr              5
#define DFLT_VAL_NX90_endat_int_mrs_adr         0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_mrs_adr      0x00000000U
#define MSK_NX90_endat_int_ir6                  0x00000040U
#define SRT_NX90_endat_int_ir6                  6
#define DFLT_VAL_NX90_endat_int_ir6             0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_ir6          0x00000000U
#define MSK_NX90_endat_int_ir7                  0x00000080U
#define SRT_NX90_endat_int_ir7                  7
#define DFLT_VAL_NX90_endat_int_ir7             0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_ir7          0x00000000U
#define MSK_NX90_endat_int_receive2_reg         0x00000100U
#define SRT_NX90_endat_int_receive2_reg         8
#define DFLT_VAL_NX90_endat_int_receive2_reg    0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_receive2_reg 0x00000000U
#define MSK_NX90_endat_int_receive3_reg         0x00000200U
#define SRT_NX90_endat_int_receive3_reg         9
#define DFLT_VAL_NX90_endat_int_receive3_reg    0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_receive3_reg 0x00000000U
#define MSK_NX90_endat_int_error2               0x00000400U
#define SRT_NX90_endat_int_error2               10
#define DFLT_VAL_NX90_endat_int_error2          0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_error2       0x00000000U
#define MSK_NX90_endat_int_crc_zi1              0x00000800U
#define SRT_NX90_endat_int_crc_zi1              11
#define DFLT_VAL_NX90_endat_int_crc_zi1         0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_crc_zi1      0x00000000U
#define MSK_NX90_endat_int_crc_zi2              0x00001000U
#define SRT_NX90_endat_int_crc_zi2              12
#define DFLT_VAL_NX90_endat_int_crc_zi2         0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_crc_zi2      0x00000000U
#define MSK_NX90_endat_int_busy                 0x00002000U
#define SRT_NX90_endat_int_busy                 13
#define DFLT_VAL_NX90_endat_int_busy            0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_busy         0x00000000U
#define MSK_NX90_endat_int_RM                   0x00004000U
#define SRT_NX90_endat_int_RM                   14
#define DFLT_VAL_NX90_endat_int_RM              0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_RM           0x00000000U
#define MSK_NX90_endat_int_wrn                  0x00008000U
#define SRT_NX90_endat_int_wrn                  15
#define DFLT_VAL_NX90_endat_int_wrn             0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_wrn          0x00000000U
#define MSK_NX90_endat_int_spike                0x00010000U
#define SRT_NX90_endat_int_spike                16
#define DFLT_VAL_NX90_endat_int_spike           0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_spike        0x00000000U
#define MSK_NX90_endat_int_watchdog             0x00020000U
#define SRT_NX90_endat_int_watchdog             17
#define DFLT_VAL_NX90_endat_int_watchdog        0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_watchdog     0x00000000U
#define MSK_NX90_endat_int_f_type3              0x00040000U
#define SRT_NX90_endat_int_f_type3              18
#define DFLT_VAL_NX90_endat_int_f_type3         0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_f_type3      0x00000000U
#define MSK_NX90_endat_int_speed_ready          0x20000000U
#define SRT_NX90_endat_int_speed_ready          29
#define DFLT_VAL_NX90_endat_int_speed_ready     0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_speed_ready  0x00000000U
#define MSK_NX90_endat_int_ready                0x80000000U
#define SRT_NX90_endat_int_ready                31
#define DFLT_VAL_NX90_endat_int_ready           0x00000000U
#define DFLT_BF_VAL_NX90_endat_int_ready        0x00000000U

/* all used bits of 'NX90_endat_int': */
#define MSK_USED_BITS_NX90_endat_int 0xa007ffffU

enum {
  BFW_NX90_endat_int_receive1_reg = 1,  /* [0] */
  BFW_NX90_endat_int_error1       = 1,  /* [1] */
  BFW_NX90_endat_int_crcpw_parity = 1,  /* [2] */
  BFW_NX90_endat_int_f_type1      = 1,  /* [3] */
  BFW_NX90_endat_int_f_type2      = 1,  /* [4] */
  BFW_NX90_endat_int_mrs_adr      = 1,  /* [5] */
  BFW_NX90_endat_int_ir6          = 1,  /* [6] */
  BFW_NX90_endat_int_ir7          = 1,  /* [7] */
  BFW_NX90_endat_int_receive2_reg = 1,  /* [8] */
  BFW_NX90_endat_int_receive3_reg = 1,  /* [9] */
  BFW_NX90_endat_int_error2       = 1,  /* [10] */
  BFW_NX90_endat_int_crc_zi1      = 1,  /* [11] */
  BFW_NX90_endat_int_crc_zi2      = 1,  /* [12] */
  BFW_NX90_endat_int_busy         = 1,  /* [13] */
  BFW_NX90_endat_int_RM           = 1,  /* [14] */
  BFW_NX90_endat_int_wrn          = 1,  /* [15] */
  BFW_NX90_endat_int_spike        = 1,  /* [16] */
  BFW_NX90_endat_int_watchdog     = 1,  /* [17] */
  BFW_NX90_endat_int_f_type3      = 1,  /* [18] */
  BFW_NX90_endat_int_reserved1    = 10, /* [28:19] */
  BFW_NX90_endat_int_speed_ready  = 1,  /* [29] */
  BFW_NX90_endat_int_reserved2    = 1,  /* [30] */
  BFW_NX90_endat_int_ready        = 1   /* [31] */
};

typedef struct NX90_ENDAT_INT_BIT_Ttag {
  unsigned int receive1_reg : BFW_NX90_endat_int_receive1_reg; /* ...      */
  unsigned int error1       : BFW_NX90_endat_int_error1;       /* ...      */
  unsigned int crcpw_parity : BFW_NX90_endat_int_crcpw_parity; /* ...      */
  unsigned int f_type1      : BFW_NX90_endat_int_f_type1;      /* ...      */
  unsigned int f_type2      : BFW_NX90_endat_int_f_type2;      /* ...      */
  unsigned int mrs_adr      : BFW_NX90_endat_int_mrs_adr;      /* ...      */
  unsigned int ir6          : BFW_NX90_endat_int_ir6;          /* ...      */
  unsigned int ir7          : BFW_NX90_endat_int_ir7;          /* ...      */
  unsigned int receive2_reg : BFW_NX90_endat_int_receive2_reg; /* ...      */
  unsigned int receive3_reg : BFW_NX90_endat_int_receive3_reg; /* ...      */
  unsigned int error2       : BFW_NX90_endat_int_error2;       /* ...      */
  unsigned int crc_zi1      : BFW_NX90_endat_int_crc_zi1;      /* ...      */
  unsigned int crc_zi2      : BFW_NX90_endat_int_crc_zi2;      /* ...      */
  unsigned int busy         : BFW_NX90_endat_int_busy;         /* ...      */
  unsigned int RM           : BFW_NX90_endat_int_RM;           /* ...      */
  unsigned int wrn          : BFW_NX90_endat_int_wrn;          /* ...      */
  unsigned int spike        : BFW_NX90_endat_int_spike;        /* ...      */
  unsigned int watchdog     : BFW_NX90_endat_int_watchdog;     /* ...      */
  unsigned int f_type3      : BFW_NX90_endat_int_f_type3;      /* ...      */
  unsigned int reserved1    : BFW_NX90_endat_int_reserved1;    /* reserved */
  unsigned int speed_ready  : BFW_NX90_endat_int_speed_ready;  /* ...      */
  unsigned int reserved2    : BFW_NX90_endat_int_reserved2;    /* reserved */
  unsigned int ready        : BFW_NX90_endat_int_ready;        /* ...      */
} NX90_ENDAT_INT_BIT_T;

typedef union {
  uint32_t             val;
  NX90_ENDAT_INT_BIT_T bf;
} NX90_ENDAT_INT_T;

/* --------------------------------------------------------------------- */
/* Register endat_test1 */
/* => Test register 1 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_test1        0x00000028U
#define Adr_NX90_endat0_app_endat_test1 0xFF801728U
#define Adr_NX90_endat1_app_endat_test1 0xFF801768U

#define MSK_NX90_endat_test1_dl_high                 0x00000001U
#define SRT_NX90_endat_test1_dl_high                 0
#define MSK_NX90_endat_test1_status_zi               0x00000006U
#define SRT_NX90_endat_test1_status_zi               1
#define MSK_NX90_endat_test1_enDat_automation_engine 0x000003f0U
#define SRT_NX90_endat_test1_enDat_automation_engine 4
#define MSK_NX90_endat_test1_ic_test_values          0xfffffc00U
#define SRT_NX90_endat_test1_ic_test_values          10

/* all used bits of 'NX90_endat_test1': */
#define MSK_USED_BITS_NX90_endat_test1 0xfffffff7U

enum {
  BFW_NX90_endat_test1_dl_high                 = 1,  /* [0] */
  BFW_NX90_endat_test1_status_zi               = 2,  /* [2:1] */
  BFW_NX90_endat_test1_reserved1               = 1,  /* [3] */
  BFW_NX90_endat_test1_enDat_automation_engine = 6,  /* [9:4] */
  BFW_NX90_endat_test1_ic_test_values          = 22  /* [31:10] */
};

typedef struct NX90_ENDAT_TEST1_BIT_Ttag {
  unsigned int dl_high                 : BFW_NX90_endat_test1_dl_high;                 /* For control of the EnDat automation machine.                       */
  unsigned int status_zi               : BFW_NX90_endat_test1_status_zi;               /* Allows testing of the IC-internal automation machine.              */
                                                                                       /* IC sends no clocks for additional information = 00                 */
                                                                                       /* IC sends clocks for one unit of additional information 1 = 01      */
                                                                                       /* IC sends clocks for one unit of additional information 2 = 10      */
                                                                                       /* IC sends clocks for two units of additional information (1+2) = 11 */
  unsigned int reserved1               : BFW_NX90_endat_test1_reserved1;               /* reserved                                                           */
  unsigned int enDat_automation_engine : BFW_NX90_endat_test1_enDat_automation_engine; /* ...                                                                */
  unsigned int ic_test_values          : BFW_NX90_endat_test1_ic_test_values;          /* ...                                                                */
} NX90_ENDAT_TEST1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ENDAT_TEST1_BIT_T bf;
} NX90_ENDAT_TEST1_T;

/* --------------------------------------------------------------------- */
/* Register endat_test2 */
/* => Test register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_test2        0x0000002CU
#define Adr_NX90_endat0_app_endat_test2 0xFF80172CU
#define Adr_NX90_endat1_app_endat_test2 0xFF80176CU
#define DFLT_VAL_NX90_endat_test2       0x00000000U

#define MSK_NX90_endat_test2_selection_tst_out          0x00000004U
#define SRT_NX90_endat_test2_selection_tst_out          2
#define DFLT_VAL_NX90_endat_test2_selection_tst_out     0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_selection_tst_out  0x00000000U
#define MSK_NX90_endat_test2_test_receive_reg           0x00000008U
#define SRT_NX90_endat_test2_test_receive_reg           3
#define DFLT_VAL_NX90_endat_test2_test_receive_reg      0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_test_receive_reg   0x00000000U
#define MSK_NX90_endat_test2_sel_test_mux               0x00000030U
#define SRT_NX90_endat_test2_sel_test_mux               4
#define DFLT_VAL_NX90_endat_test2_sel_test_mux          0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_sel_test_mux       0x00000000U
#define MSK_NX90_endat_test2_ic_test_mode               0x00000080U
#define SRT_NX90_endat_test2_ic_test_mode               7
#define DFLT_VAL_NX90_endat_test2_ic_test_mode          0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_ic_test_mode       0x00000000U
#define MSK_NX90_endat_test2_selection_add_info         0x00000700U
#define SRT_NX90_endat_test2_selection_add_info         8
#define DFLT_VAL_NX90_endat_test2_selection_add_info    0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_selection_add_info 0x00000000U
#define MSK_NX90_endat_test2_test_mode_divider          0x00000800U
#define SRT_NX90_endat_test2_test_mode_divider          11
#define DFLT_VAL_NX90_endat_test2_test_mode_divider     0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_test_mode_divider  0x00000000U
#define MSK_NX90_endat_test2_sel_test_mux2              0x00003000U
#define SRT_NX90_endat_test2_sel_test_mux2              12
#define DFLT_VAL_NX90_endat_test2_sel_test_mux2         0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_sel_test_mux2      0x00000000U
#define MSK_NX90_endat_test2_sel_test_mux3              0x0000c000U
#define SRT_NX90_endat_test2_sel_test_mux3              14
#define DFLT_VAL_NX90_endat_test2_sel_test_mux3         0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_sel_test_mux3      0x00000000U
#define MSK_NX90_endat_test2_ic_test_data               0xffff0000U
#define SRT_NX90_endat_test2_ic_test_data               16
#define DFLT_VAL_NX90_endat_test2_ic_test_data          0x00000000U
#define DFLT_BF_VAL_NX90_endat_test2_ic_test_data       0x00000000U

/* all used bits of 'NX90_endat_test2': */
#define MSK_USED_BITS_NX90_endat_test2 0xffffffbcU

enum {
  BFW_NX90_endat_test2_reserved1          = 2,  /* [1:0] */
  BFW_NX90_endat_test2_selection_tst_out  = 1,  /* [2] */
  BFW_NX90_endat_test2_test_receive_reg   = 1,  /* [3] */
  BFW_NX90_endat_test2_sel_test_mux       = 2,  /* [5:4] */
  BFW_NX90_endat_test2_reserved2          = 1,  /* [6] */
  BFW_NX90_endat_test2_ic_test_mode       = 1,  /* [7] */
  BFW_NX90_endat_test2_selection_add_info = 3,  /* [10:8] */
  BFW_NX90_endat_test2_test_mode_divider  = 1,  /* [11] */
  BFW_NX90_endat_test2_sel_test_mux2      = 2,  /* [13:12] */
  BFW_NX90_endat_test2_sel_test_mux3      = 2,  /* [15:14] */
  BFW_NX90_endat_test2_ic_test_data       = 16  /* [31:16] */
};

typedef struct NX90_ENDAT_TEST2_BIT_Ttag {
  unsigned int reserved1          : BFW_NX90_endat_test2_reserved1;          /* reserved                                                                                                                                     */
  unsigned int selection_tst_out  : BFW_NX90_endat_test2_selection_tst_out;  /* For testing, the TST_OUT_PIN pin is assigned as follows:                                                                                     */
                                                                             /* Internal (delayed by synchronization) DATA_RC_INT = 0                                                                                        */
                                                                             /* This signal is the signal that belongs to data strobe pulse.                                                                                 */
  unsigned int test_receive_reg   : BFW_NX90_endat_test2_test_receive_reg;   /* Standard operating mode        = TST receive_reg = 0                                                                                         */
                                                                             /* Test mode for receive register = TST receive_reg = 1                                                                                         */
                                                                             /* By writing to the address of the receive registers, the content of test register 2 (bits (31:16) is transferred them.                        */
                                                                             /* It is not possible to directly write to a receive register via the parallel port.                                                            */
  unsigned int sel_test_mux       : BFW_NX90_endat_test2_sel_test_mux;       /* (for testing at IC manufacturing site, internal resources can be read)                                                                       */
                                                                             /* Standard operating mode = 00                                                                                                                 */
                                                                             /* Central pre-dividers    = 01                                                                                                                 */
                                                                             /* Start bit counter       = 10                                                                                                                 */
                                                                             /* Delay counter and register, additional information bit = 11                                                                                  */
  unsigned int reserved2          : BFW_NX90_endat_test2_reserved2;          /* reserved                                                                                                                                     */
  unsigned int ic_test_mode       : BFW_NX90_endat_test2_ic_test_mode;       /* The IC can be switched to a special test mode, allowing the testing of internal modules                                                      */
                                                                             /* Standard application mode = 0                                                                                                                */
                                                                             /* Special test mode         = 1                                                                                                                */
  unsigned int selection_add_info : BFW_NX90_endat_test2_selection_add_info; /* The number of required additional information units (ZI) can also be selected manually(alternatively to implemented ZI automation resources) */
                                                                             /* Automated resources active = 0 00                                                                                                            */
                                                                             /* IC sends clocks for one unit of additional information 1      = 0 01                                                                         */
                                                                             /* IC sends clocks for one unit of additional information 2      = 0 10                                                                         */
                                                                             /* IC sends clocks for two units of additional information (1+2) = 0 11                                                                         */
                                                                             /* IC sends no clocks for additional information                 = 1 xx                                                                         */
  unsigned int test_mode_divider  : BFW_NX90_endat_test2_test_mode_divider;  /* (For testing at IC manufacturing site, internal resources can be read via test register 4)                                                   */
                                                                             /* Standard operating mode = 0                                                                                                                  */
                                                                             /* Test mode active = 1                                                                                                                         */
  unsigned int sel_test_mux2      : BFW_NX90_endat_test2_sel_test_mux2;      /* (For testing at IC manufacturing site, internal resources can be read via test register 4)                                                   */
                                                                             /* Test_Mode_Divider = 0:                                                                                                                       */
                                                                             /*   Selection of test multiplexer 2:                                                                                                           */
                                                                             /*     Test value Pos1b (Pos1 - Off2)      = 00                                                                                                 */
                                                                             /*     Test value Pos1c (Pos1 DIV nsrPos1) = 01                                                                                                 */
                                                                             /*     Test value Pos1d (Pos1 MOD srM)     = 10                                                                                                 */
                                                                             /*     Test value Pos2                     = 11                                                                                                 */
                                                                             /*     Test_Mode_Divider                   = 1                                                                                                  */
                                                                             /*   Selection of test multiplexer 2:                                                                                                           */
                                                                             /*     Test value quotient (divider)  = 00                                                                                                      */
                                                                             /*     Test value remainder (divider) = 01                                                                                                      */
  unsigned int sel_test_mux3      : BFW_NX90_endat_test2_sel_test_mux3;      /* (For testing at IC manufacturing site, internal resources can be read via test register 3)                                                   */
                                                                             /* Write value test register 3        = 00 (Content written to test register 3 via the I/O port.)                                               */
                                                                             /* Test values counter TM measurement = 01 TM_High_Err & TM_low_Err & F_TM & TM_CT2 &TM_CT1                                                     */
                                                                             /* Limit values for TM measurement    = 10 C_WT_HIGH & C_WT_LOW & C_HIGH & C_LOW                                                                */
                                                                             /* Test values internal OEM Reg       = 11 (only available in customer-specific versions)                                                       */
  unsigned int ic_test_data       : BFW_NX90_endat_test2_ic_test_data;       /* RTM value - Counter value of the recovery time measurement if conf2(22)=1.                                                                   */
                                                                             /* Updated after the completion of the recovery time tm measurement during the EnDat transmission                                               */
                                                                             /* with mode command 1-1 "Encoder transmit position value and selection of memory area" with MRS                                                */
                                                                             /* code 0x43 (selection of 2nd word of position value 2).                                                                                       */
                                                                             /* With conf2(22)=0, data for the recovery time measurement tm are not valid. Writing to the test                                               */
                                                                             /* register sets the internal counter of the recovery time measurement to the value of the "write                                               */
                                                                             /* data" (31:16) - Init word or start value of the recovery time measurement. The value of the                                                  */
                                                                             /* internal measuring counter is incremented with the system frequency during the time tm, and the                                              */
                                                                             /* carry is discarded.                                                                                                                          */
} NX90_ENDAT_TEST2_BIT_T;

typedef union {
  uint32_t               val;
  NX90_ENDAT_TEST2_BIT_T bf;
} NX90_ENDAT_TEST2_T;

/* --------------------------------------------------------------------- */
/* Register endat_receive4_0 */
/* => Receive register 4 */
/*    Receive register 4 contains position value 2 (Pos2), which is put together from the additional information 1 of Cycles 2, 3 and 4. */
/*    Test function: with the test register 2 bits (13:12), internal test values can be read */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_receive4_0        0x00000030U
#define Adr_NX90_endat0_app_endat_receive4_0 0xFF801730U
#define Adr_NX90_endat1_app_endat_receive4_0 0xFF801770U

#define MSK_NX90_endat_receive4_0_byte1 0x000000ffU
#define SRT_NX90_endat_receive4_0_byte1 0
#define MSK_NX90_endat_receive4_0_byte2 0x0000ff00U
#define SRT_NX90_endat_receive4_0_byte2 8
#define MSK_NX90_endat_receive4_0_byte3 0x00ff0000U
#define SRT_NX90_endat_receive4_0_byte3 16
#define MSK_NX90_endat_receive4_0_byte4 0xff000000U
#define SRT_NX90_endat_receive4_0_byte4 24

/* all used bits of 'NX90_endat_receive4_0': */
#define MSK_USED_BITS_NX90_endat_receive4_0 0xffffffffU

enum {
  BFW_NX90_endat_receive4_0_byte1 = 8, /* [7:0] */
  BFW_NX90_endat_receive4_0_byte2 = 8, /* [15:8] */
  BFW_NX90_endat_receive4_0_byte3 = 8, /* [23:16] */
  BFW_NX90_endat_receive4_0_byte4 = 8  /* [31:24] */
};

typedef struct NX90_ENDAT_RECEIVE4_0_BIT_Ttag {
  unsigned int byte1 : BFW_NX90_endat_receive4_0_byte1; /* ... */
  unsigned int byte2 : BFW_NX90_endat_receive4_0_byte2; /* ... */
  unsigned int byte3 : BFW_NX90_endat_receive4_0_byte3; /* ... */
  unsigned int byte4 : BFW_NX90_endat_receive4_0_byte4; /* ... */
} NX90_ENDAT_RECEIVE4_0_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_ENDAT_RECEIVE4_0_BIT_T bf;
} NX90_ENDAT_RECEIVE4_0_T;

/* --------------------------------------------------------------------- */
/* Register endat_receive4_1 */
/* => Receive register 4 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_receive4_1        0x00000034U
#define Adr_NX90_endat0_app_endat_receive4_1 0xFF801734U
#define Adr_NX90_endat1_app_endat_receive4_1 0xFF801774U

#define MSK_NX90_endat_receive4_1_byte5 0x000000ffU
#define SRT_NX90_endat_receive4_1_byte5 0
#define MSK_NX90_endat_receive4_1_byte6 0x0000ff00U
#define SRT_NX90_endat_receive4_1_byte6 8

/* all used bits of 'NX90_endat_receive4_1': */
#define MSK_USED_BITS_NX90_endat_receive4_1 0x0000ffffU

enum {
  BFW_NX90_endat_receive4_1_byte5     = 8,  /* [7:0] */
  BFW_NX90_endat_receive4_1_byte6     = 8,  /* [15:8] */
  BFW_NX90_endat_receive4_1_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_ENDAT_RECEIVE4_1_BIT_Ttag {
  unsigned int byte5     : BFW_NX90_endat_receive4_1_byte5;     /* ...      */
  unsigned int byte6     : BFW_NX90_endat_receive4_1_byte6;     /* ...      */
  unsigned int reserved1 : BFW_NX90_endat_receive4_1_reserved1; /* reserved */
} NX90_ENDAT_RECEIVE4_1_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_ENDAT_RECEIVE4_1_BIT_T bf;
} NX90_ENDAT_RECEIVE4_1_T;

/* --------------------------------------------------------------------- */
/* Register endat_sw_strobe */
/* => SW strobe */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_sw_strobe        0x00000038U
#define Adr_NX90_endat0_app_endat_sw_strobe 0xFF801738U
#define Adr_NX90_endat1_app_endat_sw_strobe 0xFF801778U
#define DFLT_VAL_NX90_endat_sw_strobe       0x00000000U

#define MSK_NX90_endat_sw_strobe_sw_strobe         0xffffffffU
#define SRT_NX90_endat_sw_strobe_sw_strobe         0
#define DFLT_VAL_NX90_endat_sw_strobe_sw_strobe    0x00000000U
#define DFLT_BF_VAL_NX90_endat_sw_strobe_sw_strobe 0x00000000U

/* all used bits of 'NX90_endat_sw_strobe': */
#define MSK_USED_BITS_NX90_endat_sw_strobe 0xffffffffU

enum {
  BFW_NX90_endat_sw_strobe_sw_strobe = 32  /* [31:0] */
};

typedef struct NX90_ENDAT_SW_STROBE_BIT_Ttag {
  unsigned int sw_strobe : BFW_NX90_endat_sw_strobe_sw_strobe; /* Writing this register will in each case cause the first H/L transition of the TCLK transmission clock signal. */
} NX90_ENDAT_SW_STROBE_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_ENDAT_SW_STROBE_BIT_T bf;
} NX90_ENDAT_SW_STROBE_T;

/* --------------------------------------------------------------------- */
/* Register endat_id */
/* => Identification register */
/*    The soft-macro specification (ID) is stored here. This information is helpful for automated configuration by higher-level user software. */
/*    E22:  Designates the latest EnDat 2.2 protocol generation */
/*    6:    MAZeT-internal designation (E6) */
/*    xxxx: Consecutive version number (this document is valid for all versions as of xx13.) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_id        0x0000003CU
#define Adr_NX90_endat0_app_endat_id 0xFF80173CU
#define Adr_NX90_endat1_app_endat_id 0xFF80177CU

#define MSK_NX90_endat_id_id 0xffffffffU
#define SRT_NX90_endat_id_id 0

/* all used bits of 'NX90_endat_id': */
#define MSK_USED_BITS_NX90_endat_id 0xffffffffU

enum {
  BFW_NX90_endat_id_id = 32  /* [31:0] */
};

typedef struct NX90_ENDAT_ID_BIT_Ttag {
  unsigned int id : BFW_NX90_endat_id_id; /* ... */
} NX90_ENDAT_ID_BIT_T;

typedef union {
  uint32_t            val;
  NX90_ENDAT_ID_BIT_T bf;
} NX90_ENDAT_ID_T;


/* ===================================================================== */

/* AREA endat_ctrl */
/* Area of endat_ctrl0_app, endat_ctrl1_app */

/* ===================================================================== */

#define Addr_NX90_endat_ctrl0_app 0xFF801780U
#define Addr_NX90_endat_ctrl1_app 0xFF801790U

/* --------------------------------------------------------------------- */
/* Register endat_ctrl_trigger_cfg */
/* => EnDat trigger configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_ctrl_trigger_cfg             0x00000000U
#define Adr_NX90_endat_ctrl0_app_endat_ctrl_trigger_cfg 0xFF801780U
#define Adr_NX90_endat_ctrl1_app_endat_ctrl_trigger_cfg 0xFF801790U
#define DFLT_VAL_NX90_endat_ctrl_trigger_cfg            0x00000000U

#define MSK_NX90_endat_ctrl_trigger_cfg_sel         0x0000000fU
#define SRT_NX90_endat_ctrl_trigger_cfg_sel         0
#define DFLT_VAL_NX90_endat_ctrl_trigger_cfg_sel    0x00000000U
#define DFLT_BF_VAL_NX90_endat_ctrl_trigger_cfg_sel 0x00000000U

/* all used bits of 'NX90_endat_ctrl_trigger_cfg': */
#define MSK_USED_BITS_NX90_endat_ctrl_trigger_cfg 0x0000000fU

enum {
  BFW_NX90_endat_ctrl_trigger_cfg_sel       = 4,  /* [3:0] */
  BFW_NX90_endat_ctrl_trigger_cfg_reserved1 = 28  /* [31:4] */
};

typedef struct NX90_ENDAT_CTRL_TRIGGER_CFG_BIT_Ttag {
  unsigned int sel       : BFW_NX90_endat_ctrl_trigger_cfg_sel;       /* Trigger source select                                                               */
                                                                      /* This bit field configures which event is connected to the strobe signal             */
                                                                      /* of the EnDat core. A rising edge of the selected event will generate an event       */
                                                                      /* to the core according to the configuration in the strobe_cfg register.              */
                                                                      /* Note: When ntimer or n_si are selected, they are routed directly to the EnDat core  */
                                                                      /* (i.e. they are not connected to the pulse former).                                  */
                                                                      /* {       |                                                                           */
                                                                      /*  Value   trigger event                                                              */
                                                                      /*  0       none                                                                       */
                                                                      /*  1       manual                                                                     */
                                                                      /*  2       xc_trigger_out0                                                            */
                                                                      /*  3       xc_trigger_out0 (inverted)                                                 */
                                                                      /*  4       xc_trigger_out1                                                            */
                                                                      /*  5       xc_trigger_out1 (inverted)                                                 */
                                                                      /*  6       xc_sample_in0                                                              */
                                                                      /*  7       xc_sample_in0 (inverted)                                                   */
                                                                      /*  8       xc_sample_in1                                                              */
                                                                      /*  9       xc_sample_in1 (inverted)                                                   */
                                                                      /*  10      gpio_app_counter_zero0                                                     */
                                                                      /*  11      gpio_app_counter_zero1                                                     */
                                                                      /*  12      gpio_app_counter_zero2                                                     */
                                                                      /*  13      ntimer signal of other EnDat instance                                      */
                                                                      /*  14      n_si signal of other EnDat instance                                        */
                                                                      /*  15      reserved }                                                                 */
  unsigned int reserved1 : BFW_NX90_endat_ctrl_trigger_cfg_reserved1; /* reserved                                                                            */
} NX90_ENDAT_CTRL_TRIGGER_CFG_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_ENDAT_CTRL_TRIGGER_CFG_BIT_T bf;
} NX90_ENDAT_CTRL_TRIGGER_CFG_T;

/* --------------------------------------------------------------------- */
/* Register endat_ctrl_trigger */
/* => EnDat trigger */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_ctrl_trigger             0x00000004U
#define Adr_NX90_endat_ctrl0_app_endat_ctrl_trigger 0xFF801784U
#define Adr_NX90_endat_ctrl1_app_endat_ctrl_trigger 0xFF801794U
#define DFLT_VAL_NX90_endat_ctrl_trigger            0x00000000U

#define MSK_NX90_endat_ctrl_trigger_manual         0x00000001U
#define SRT_NX90_endat_ctrl_trigger_manual         0
#define DFLT_VAL_NX90_endat_ctrl_trigger_manual    0x00000000U
#define DFLT_BF_VAL_NX90_endat_ctrl_trigger_manual 0x00000000U

/* all used bits of 'NX90_endat_ctrl_trigger': */
#define MSK_USED_BITS_NX90_endat_ctrl_trigger 0x00000001U

enum {
  BFW_NX90_endat_ctrl_trigger_manual    = 1,  /* [0] */
  BFW_NX90_endat_ctrl_trigger_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_ENDAT_CTRL_TRIGGER_BIT_Ttag {
  unsigned int manual    : BFW_NX90_endat_ctrl_trigger_manual;    /* Manual trigger.                                                            */
                                                                  /* Writing '1' to this bit will trigger the EnDat core immediately in case    */
                                                                  /* the trigger_cfg.sel bit field is set to manual mode and the EnDat core is  */
                                                                  /* setup for external triggering by the strobe signal.                        */
  unsigned int reserved1 : BFW_NX90_endat_ctrl_trigger_reserved1; /* reserved                                                                   */
} NX90_ENDAT_CTRL_TRIGGER_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_ENDAT_CTRL_TRIGGER_BIT_T bf;
} NX90_ENDAT_CTRL_TRIGGER_T;

/* --------------------------------------------------------------------- */
/* Register endat_ctrl_strobe_cfg */
/* => EnDat strobe pulse form configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_endat_ctrl_strobe_cfg             0x00000008U
#define Adr_NX90_endat_ctrl0_app_endat_ctrl_strobe_cfg 0xFF801788U
#define Adr_NX90_endat_ctrl1_app_endat_ctrl_strobe_cfg 0xFF801798U
#define DFLT_VAL_NX90_endat_ctrl_strobe_cfg            0x00000303U

#define MSK_NX90_endat_ctrl_strobe_cfg_low_len          0x000000ffU
#define SRT_NX90_endat_ctrl_strobe_cfg_low_len          0
#define DFLT_VAL_NX90_endat_ctrl_strobe_cfg_low_len     0x00000003U
#define DFLT_BF_VAL_NX90_endat_ctrl_strobe_cfg_low_len  0x00000003U
#define MSK_NX90_endat_ctrl_strobe_cfg_high_len         0x0000ff00U
#define SRT_NX90_endat_ctrl_strobe_cfg_high_len         8
#define DFLT_VAL_NX90_endat_ctrl_strobe_cfg_high_len    0x00000300U
#define DFLT_BF_VAL_NX90_endat_ctrl_strobe_cfg_high_len 0x00000003U

/* all used bits of 'NX90_endat_ctrl_strobe_cfg': */
#define MSK_USED_BITS_NX90_endat_ctrl_strobe_cfg 0x0000ffffU

enum {
  BFW_NX90_endat_ctrl_strobe_cfg_low_len   = 8,  /* [7:0] */
  BFW_NX90_endat_ctrl_strobe_cfg_high_len  = 8,  /* [15:8] */
  BFW_NX90_endat_ctrl_strobe_cfg_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_ENDAT_CTRL_STROBE_CFG_BIT_Ttag {
  unsigned int low_len   : BFW_NX90_endat_ctrl_strobe_cfg_low_len;   /* Length of the low phase (i.e. active phase) of the strobe signal        */
                                                                     /* The low phase will be the programmed value + 1 clock cycle.             */
                                                                     /* Note: EnDat spec requires the low phase to be at least 4 clock cycles   */
                                                                     /* long, therefore 0 - 2 are illegal settings.                             */
                                                                     /* Note: If a strobe delay is configured in the EnDat core, the minimum    */
                                                                     /* length is strobe delay + 1 (i.e. program low_len = strobe delay).       */
  unsigned int high_len  : BFW_NX90_endat_ctrl_strobe_cfg_high_len;  /* Length of the high phase (i.e. inactive phase) of the strobe signal     */
                                                                     /* The high phase will be the programmed value + 1 clock cycle.            */
                                                                     /* Note: EnDat spec requires the high phase to be at least 4 clock cycles  */
                                                                     /* long, therefore 0 - 2 are illegal settings.                             */
                                                                     /* Note: There is no other requirement on the high phase. This bit field   */
                                                                     /* is for debug and test only and should be kept at its default setting.   */
  unsigned int reserved1 : BFW_NX90_endat_ctrl_strobe_cfg_reserved1; /* reserved                                                                */
} NX90_ENDAT_CTRL_STROBE_CFG_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_ENDAT_CTRL_STROBE_CFG_BIT_T bf;
} NX90_ENDAT_CTRL_STROBE_CFG_T;


/* ===================================================================== */

/* AREA canctrl */
/* Area of can_ctrl0_app, can_ctrl1_app */

/* ===================================================================== */

#define Addr_NX90_can_ctrl0_app 0xFF801900U
#define Addr_NX90_can_ctrl1_app 0xFF801980U

/* --------------------------------------------------------------------- */
/* Register canctrl_mode */
/* => CAN mode register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_mode           0x00000000U
#define Adr_NX90_can_ctrl0_app_canctrl_mode 0xFF801900U
#define Adr_NX90_can_ctrl1_app_canctrl_mode 0xFF801980U
#define DFLT_VAL_NX90_canctrl_mode          0x00000001U

#define MSK_NX90_canctrl_mode_reset_mode              0x00000001U
#define SRT_NX90_canctrl_mode_reset_mode              0
#define DFLT_VAL_NX90_canctrl_mode_reset_mode         0x00000001U
#define DFLT_BF_VAL_NX90_canctrl_mode_reset_mode      0x00000001U
#define MSK_NX90_canctrl_mode_listen_mode             0x00000002U
#define SRT_NX90_canctrl_mode_listen_mode             1
#define DFLT_VAL_NX90_canctrl_mode_listen_mode        0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_mode_listen_mode     0x00000000U
#define MSK_NX90_canctrl_mode_selftest                0x00000004U
#define SRT_NX90_canctrl_mode_selftest                2
#define DFLT_VAL_NX90_canctrl_mode_selftest           0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_mode_selftest        0x00000000U
#define MSK_NX90_canctrl_mode_acceptance_mode         0x00000008U
#define SRT_NX90_canctrl_mode_acceptance_mode         3
#define DFLT_VAL_NX90_canctrl_mode_acceptance_mode    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_mode_acceptance_mode 0x00000000U

/* all used bits of 'NX90_canctrl_mode': */
#define MSK_USED_BITS_NX90_canctrl_mode 0x0000000fU

enum {
  BFW_NX90_canctrl_mode_reset_mode      = 1,  /* [0] */
  BFW_NX90_canctrl_mode_listen_mode     = 1,  /* [1] */
  BFW_NX90_canctrl_mode_selftest        = 1,  /* [2] */
  BFW_NX90_canctrl_mode_acceptance_mode = 1,  /* [3] */
  BFW_NX90_canctrl_mode_reserved1       = 28  /* [31:4] */
};

typedef struct NX90_CANCTRL_MODE_BIT_Ttag {
  unsigned int reset_mode      : BFW_NX90_canctrl_mode_reset_mode;      /* Reset Mode                                             */
                                                                        /* 1 reset; detection of a set reset mode bit results in  */
                                                                        /* aborting the current transmission/reception of a       */
                                                                        /* message and entering the reset mode                    */
                                                                        /* 0 normal; on the `1-to-0' transition of the reset mode */
                                                                        /* bit, the CAN controller returns to the operating       */
                                                                        /* mode                                                   */
  unsigned int listen_mode     : BFW_NX90_canctrl_mode_listen_mode;     /* Listen Only Mode                                       */
                                                                        /* 1 listen only; in this mode the CAN controller would   */
                                                                        /*   give no acknowledge to the CAN-bus, even if a        */
                                                                        /*   message is received successfully; the error          */
                                                                        /*   counters are stopped at the current value            */
                                                                        /* 0 normal                                               */
  unsigned int selftest        : BFW_NX90_canctrl_mode_selftest;        /* Self Test Mode                                         */
                                                                        /* 1 self test; in this mode a full node test is possible */
                                                                        /*   without any other active node on the bus using the   */
                                                                        /*   self reception request command; the                  */
                                                                        /*   CAN controller will perform a successful             */
                                                                        /*   transmission, even if there is no acknowledge        */
                                                                        /*   received                                             */
                                                                        /* 0 normal; an acknowledge is required for successful    */
                                                                        /*   transmission                                         */
  unsigned int acceptance_mode : BFW_NX90_canctrl_mode_acceptance_mode; /* Acceptance Filter Mode                                 */
                                                                        /* 1 single; the single acceptance filter option is       */
                                                                        /*   enabled (one filter with the length of 32 bit is     */
                                                                        /*   active)                                              */
                                                                        /* 0 dual; the dual acceptance filter option is enabled   */
                                                                        /*   (two filters, each with the length of 16 bit are     */
                                                                        /*   active)                                              */
  unsigned int reserved1       : BFW_NX90_canctrl_mode_reserved1;       /* reserved                                               */
} NX90_CANCTRL_MODE_BIT_T;

typedef union {
  uint32_t                val;
  NX90_CANCTRL_MODE_BIT_T bf;
} NX90_CANCTRL_MODE_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_command */
/* => CAN command register */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_command           0x00000004U
#define Adr_NX90_can_ctrl0_app_canctrl_command 0xFF801904U
#define Adr_NX90_can_ctrl1_app_canctrl_command 0xFF801984U
#define DFLT_VAL_NX90_canctrl_command          0x00000000U

#define MSK_NX90_canctrl_command_tx_request              0x00000001U
#define SRT_NX90_canctrl_command_tx_request              0
#define DFLT_VAL_NX90_canctrl_command_tx_request         0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_command_tx_request      0x00000000U
#define MSK_NX90_canctrl_command_abort_tx                0x00000002U
#define SRT_NX90_canctrl_command_abort_tx                1
#define DFLT_VAL_NX90_canctrl_command_abort_tx           0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_command_abort_tx        0x00000000U
#define MSK_NX90_canctrl_command_release_rx_buf          0x00000004U
#define SRT_NX90_canctrl_command_release_rx_buf          2
#define DFLT_VAL_NX90_canctrl_command_release_rx_buf     0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_command_release_rx_buf  0x00000000U
#define MSK_NX90_canctrl_command_clr_overrun             0x00000008U
#define SRT_NX90_canctrl_command_clr_overrun             3
#define DFLT_VAL_NX90_canctrl_command_clr_overrun        0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_command_clr_overrun     0x00000000U
#define MSK_NX90_canctrl_command_self_rx_request         0x00000010U
#define SRT_NX90_canctrl_command_self_rx_request         4
#define DFLT_VAL_NX90_canctrl_command_self_rx_request    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_command_self_rx_request 0x00000000U

/* all used bits of 'NX90_canctrl_command': */
#define MSK_USED_BITS_NX90_canctrl_command 0x0000001fU

enum {
  BFW_NX90_canctrl_command_tx_request      = 1,  /* [0] */
  BFW_NX90_canctrl_command_abort_tx        = 1,  /* [1] */
  BFW_NX90_canctrl_command_release_rx_buf  = 1,  /* [2] */
  BFW_NX90_canctrl_command_clr_overrun     = 1,  /* [3] */
  BFW_NX90_canctrl_command_self_rx_request = 1,  /* [4] */
  BFW_NX90_canctrl_command_reserved1       = 27  /* [31:5] */
};

typedef struct NX90_CANCTRL_COMMAND_BIT_Ttag {
  unsigned int tx_request      : BFW_NX90_canctrl_command_tx_request;      /* Transmission Request, self-clearing                                  */
                                                                           /* 1 present; a message shall be transmitted                            */
  unsigned int abort_tx        : BFW_NX90_canctrl_command_abort_tx;        /* Abort Transmission, self-clearing                                    */
                                                                           /* 1 present; if not already in progress, a pending                     */
                                                                           /*   transmission request is cancelled                                  */
                                                                           /* Setting the command bits tx_request and abort_tx simultaneously      */
                                                                           /* results in sending the transmit message once.                        */
                                                                           /* No re-transmission will be performed in the event                    */
                                                                           /* of an error or arbitration lost (single-shot transmission).          */
  unsigned int release_rx_buf  : BFW_NX90_canctrl_command_release_rx_buf;  /* Release Receive Buffer, self-clearing                                */
                                                                           /* 1 released; the receive buffer, representing the                     */
                                                                           /*   message memory space in the RXFIFO is                              */
                                                                           /*   released                                                           */
  unsigned int clr_overrun     : BFW_NX90_canctrl_command_clr_overrun;     /* Clear Data Overrun, self-clearing                                    */
                                                                           /* 1 clear; the data overrun status bit is cleared,                     */
                                                                           /* shall be used together with release_rx_buf to release invalid buffer */
  unsigned int self_rx_request : BFW_NX90_canctrl_command_self_rx_request; /* Self Reception Request, self-clearing                                */
                                                                           /* 1 present; a message shall be transmitted and                        */
                                                                           /*   received simultaneously                                            */
                                                                           /* Setting tx_request and self_rx_request simultaneously                */
                                                                           /* will ignore the set self_rx_request bit.                             */
  unsigned int reserved1       : BFW_NX90_canctrl_command_reserved1;       /* reserved                                                             */
} NX90_CANCTRL_COMMAND_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_CANCTRL_COMMAND_BIT_T bf;
} NX90_CANCTRL_COMMAND_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_status */
/* => CAN status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_status           0x00000008U
#define Adr_NX90_can_ctrl0_app_canctrl_status 0xFF801908U
#define Adr_NX90_can_ctrl1_app_canctrl_status 0xFF801988U

#define MSK_NX90_canctrl_status_rx_buf_status 0x00000001U
#define SRT_NX90_canctrl_status_rx_buf_status 0
#define MSK_NX90_canctrl_status_overrun       0x00000002U
#define SRT_NX90_canctrl_status_overrun       1
#define MSK_NX90_canctrl_status_tx_buf_status 0x00000004U
#define SRT_NX90_canctrl_status_tx_buf_status 2
#define MSK_NX90_canctrl_status_tx_complete   0x00000008U
#define SRT_NX90_canctrl_status_tx_complete   3
#define MSK_NX90_canctrl_status_rx_status     0x00000010U
#define SRT_NX90_canctrl_status_rx_status     4
#define MSK_NX90_canctrl_status_tx_status     0x00000020U
#define SRT_NX90_canctrl_status_tx_status     5
#define MSK_NX90_canctrl_status_error_status  0x00000040U
#define SRT_NX90_canctrl_status_error_status  6
#define MSK_NX90_canctrl_status_bus_status    0x00000080U
#define SRT_NX90_canctrl_status_bus_status    7

/* all used bits of 'NX90_canctrl_status': */
#define MSK_USED_BITS_NX90_canctrl_status 0x000000ffU

enum {
  BFW_NX90_canctrl_status_rx_buf_status = 1,  /* [0] */
  BFW_NX90_canctrl_status_overrun       = 1,  /* [1] */
  BFW_NX90_canctrl_status_tx_buf_status = 1,  /* [2] */
  BFW_NX90_canctrl_status_tx_complete   = 1,  /* [3] */
  BFW_NX90_canctrl_status_rx_status     = 1,  /* [4] */
  BFW_NX90_canctrl_status_tx_status     = 1,  /* [5] */
  BFW_NX90_canctrl_status_error_status  = 1,  /* [6] */
  BFW_NX90_canctrl_status_bus_status    = 1,  /* [7] */
  BFW_NX90_canctrl_status_reserved1     = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_STATUS_BIT_Ttag {
  unsigned int rx_buf_status : BFW_NX90_canctrl_status_rx_buf_status; /* Receive Buffer Status                                 */
                                                                      /* 1 full; one or more complete messages are available   */
                                                                      /*   in the RXFIFO                                       */
                                                                      /* 0 empty; no message is available                      */
  unsigned int overrun       : BFW_NX90_canctrl_status_overrun;       /* Data Overrun Status                                   */
                                                                      /* 1 overrun; a message was lost because there was       */
                                                                      /*   not enough space for that message in the RXFIFO     */
                                                                      /* 0 absent; no data overrun has occurred since the      */
                                                                      /*   last clear data overrun command was given           */
  unsigned int tx_buf_status : BFW_NX90_canctrl_status_tx_buf_status; /* Transmit Buffer Status                                */
                                                                      /* 1 released; the CPU may write a message into the      */
                                                                      /*   transmit buffer                                     */
                                                                      /* 0 locked; the CPU cannot access the transmit          */
                                                                      /*   buffer ; a message is either waiting for            */
                                                                      /*   transmission or is in the process of being          */
                                                                      /*   transmitted                                         */
  unsigned int tx_complete   : BFW_NX90_canctrl_status_tx_complete;   /* Transmission Complete                                 */
                                                                      /* 1 complete; last requested transmission has been      */
                                                                      /*   successfully completed                              */
                                                                      /* 0 incomplete; previously requested transmission is    */
                                                                      /*   not yet completed                                   */
  unsigned int rx_status     : BFW_NX90_canctrl_status_rx_status;     /* Receive Status                                        */
                                                                      /* 1 receive; the CAN controller is receiving a          */
                                                                      /*   message                                             */
                                                                      /* 0 idle                                                */
  unsigned int tx_status     : BFW_NX90_canctrl_status_tx_status;     /* Transmit Status                                       */
                                                                      /* 1 transmit; the CAN controller is transmitting a      */
                                                                      /*   message                                             */
                                                                      /* 0 idle                                                */
  unsigned int error_status  : BFW_NX90_canctrl_status_error_status;  /* Error Status                                          */
                                                                      /* 1 error; at least one of the error counters has       */
                                                                      /*   reached or exceeded the CPU warning limit           */
                                                                      /*   defined by the Error Warning Limit Register         */
                                                                      /*   (EWLR)                                              */
                                                                      /* 0 ok; both error counters are below the warning limit */
  unsigned int bus_status    : BFW_NX90_canctrl_status_bus_status;    /* Bus Status                                            */
                                                                      /* 1 bus-off; the CAN controller is not involved in bus  */
                                                                      /*   activities                                          */
                                                                      /* 0 bus-on; the CAN controller is involved in bus       */
                                                                      /*   activities                                          */
  unsigned int reserved1     : BFW_NX90_canctrl_status_reserved1;     /* reserved                                              */
} NX90_CANCTRL_STATUS_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_CANCTRL_STATUS_BIT_T bf;
} NX90_CANCTRL_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_irq */
/* => CAN interrupt register */
/*    reading the register will clear all bits except rx_irq */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_irq           0x0000000CU
#define Adr_NX90_can_ctrl0_app_canctrl_irq 0xFF80190CU
#define Adr_NX90_can_ctrl1_app_canctrl_irq 0xFF80198CU

#define MSK_NX90_canctrl_irq_rx_irq          0x00000001U
#define SRT_NX90_canctrl_irq_rx_irq          0
#define MSK_NX90_canctrl_irq_tx_irq          0x00000002U
#define SRT_NX90_canctrl_irq_tx_irq          1
#define MSK_NX90_canctrl_irq_warning_irq     0x00000004U
#define SRT_NX90_canctrl_irq_warning_irq     2
#define MSK_NX90_canctrl_irq_overrun_irq     0x00000008U
#define SRT_NX90_canctrl_irq_overrun_irq     3
#define MSK_NX90_canctrl_irq_err_passive_irq 0x00000020U
#define SRT_NX90_canctrl_irq_err_passive_irq 5
#define MSK_NX90_canctrl_irq_arb_lost_irq    0x00000040U
#define SRT_NX90_canctrl_irq_arb_lost_irq    6
#define MSK_NX90_canctrl_irq_bus_error_irq   0x00000080U
#define SRT_NX90_canctrl_irq_bus_error_irq   7

/* all used bits of 'NX90_canctrl_irq': */
#define MSK_USED_BITS_NX90_canctrl_irq 0x000000efU

enum {
  BFW_NX90_canctrl_irq_rx_irq          = 1,  /* [0] */
  BFW_NX90_canctrl_irq_tx_irq          = 1,  /* [1] */
  BFW_NX90_canctrl_irq_warning_irq     = 1,  /* [2] */
  BFW_NX90_canctrl_irq_overrun_irq     = 1,  /* [3] */
  BFW_NX90_canctrl_irq_reserved1       = 1,  /* [4] */
  BFW_NX90_canctrl_irq_err_passive_irq = 1,  /* [5] */
  BFW_NX90_canctrl_irq_arb_lost_irq    = 1,  /* [6] */
  BFW_NX90_canctrl_irq_bus_error_irq   = 1,  /* [7] */
  BFW_NX90_canctrl_irq_reserved2       = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_IRQ_BIT_Ttag {
  unsigned int rx_irq          : BFW_NX90_canctrl_irq_rx_irq;          /* Receive Interrupt                                                */
                                                                       /* 1 set; this bit is set while the receive FIFO is not             */
                                                                       /*   empty and the rx_irq_en bit is set within the interrupt        */
                                                                       /*   enable register                                                */
                                                                       /* 0 reset; no more message is available within the                 */
                                                                       /*   RXFIFO                                                         */
  unsigned int tx_irq          : BFW_NX90_canctrl_irq_tx_irq;          /* Transmit Interrupt                                               */
                                                                       /* 1 set; this bit is set whenever the transmit buffer              */
                                                                       /*   status changes from `0-to-1' (released) and the                */
                                                                       /*   tx_irq_en bit is set within the interrupt enable register      */
                                                                       /* 0 reset                                                          */
  unsigned int warning_irq     : BFW_NX90_canctrl_irq_warning_irq;     /* Error Warning Interrupt                                          */
                                                                       /* 1 set; this bit is set on every change (set and clear)           */
                                                                       /*   of either the error status or bus status bits and the          */
                                                                       /*   warning_irq_en bit is set within the interrupt enable register */
                                                                       /* 0 reset                                                          */
  unsigned int overrun_irq     : BFW_NX90_canctrl_irq_overrun_irq;     /* Data Overrun Interrup                                            */
                                                                       /* 1 set; this bit is set on a `0-to-1' transition of the data      */
                                                                       /*   overrun status bit and the overrun_irq_en bit is set within    */
                                                                       /*   the interrupt enable register                                  */
                                                                       /* 0 reset                                                          */
  unsigned int reserved1       : BFW_NX90_canctrl_irq_reserved1;       /* reserved                                                         */
  unsigned int err_passive_irq : BFW_NX90_canctrl_irq_err_passive_irq; /* Error Passive Interrupt                                          */
                                                                       /* 1 set; this bit is set whenever the CAN controller has           */
                                                                       /*   reached the error passive status (at least one                 */
                                                                       /*   error counter exceeds the protocol-defined level of            */
                                                                       /*   127) or if the CAN controller is in the error passive          */
                                                                       /*   status and enters the error active status again and            */
                                                                       /*   the err_passive_irq_en bit is set within the interrupt enable  */
                                                                       /*   register                                                       */
                                                                       /* 0 reset                                                          */
  unsigned int arb_lost_irq    : BFW_NX90_canctrl_irq_arb_lost_irq;    /* Arbitration Lost Interrupt                                       */
                                                                       /* 1 set; this bit is set when the CAN controller lost the          */
                                                                       /*   arbitration and becomes a receiver and the arb_lost_irq_en     */
                                                                       /*   bit is set within the interrupt enable register, will only     */
                                                                       /*   get active again if canctrl_arb_lost_capture register is read  */
                                                                       /* 0 reset                                                          */
  unsigned int bus_error_irq   : BFW_NX90_canctrl_irq_bus_error_irq;   /* Bus Error Interrupt                                              */
                                                                       /* 1 set; this bit is set when the CAN controller detects           */
                                                                       /*   an error on the CAN-bus and the bus_error_irq_en bit is set    */
                                                                       /*   within the interrupt enable register, will only                */
                                                                       /*   get active again if canctrl_err_code_capture register is read  */
                                                                       /* 0 reset                                                          */
  unsigned int reserved2       : BFW_NX90_canctrl_irq_reserved2;       /* reserved                                                         */
} NX90_CANCTRL_IRQ_BIT_T;

typedef union {
  uint32_t               val;
  NX90_CANCTRL_IRQ_BIT_T bf;
} NX90_CANCTRL_IRQ_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_irq_en */
/* => CAN interrupt enable register */
/*    in not extended mode: acceptance_code_0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_irq_en           0x00000010U
#define Adr_NX90_can_ctrl0_app_canctrl_irq_en 0xFF801910U
#define Adr_NX90_can_ctrl1_app_canctrl_irq_en 0xFF801990U
#define DFLT_VAL_NX90_canctrl_irq_en          0x00000000U

#define MSK_NX90_canctrl_irq_en_rx_irq_en                  0x00000001U
#define SRT_NX90_canctrl_irq_en_rx_irq_en                  0
#define DFLT_VAL_NX90_canctrl_irq_en_rx_irq_en             0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_irq_en_rx_irq_en          0x00000000U
#define MSK_NX90_canctrl_irq_en_tx_irq_en                  0x00000002U
#define SRT_NX90_canctrl_irq_en_tx_irq_en                  1
#define DFLT_VAL_NX90_canctrl_irq_en_tx_irq_en             0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_irq_en_tx_irq_en          0x00000000U
#define MSK_NX90_canctrl_irq_en_warning_irq_en             0x00000004U
#define SRT_NX90_canctrl_irq_en_warning_irq_en             2
#define DFLT_VAL_NX90_canctrl_irq_en_warning_irq_en        0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_irq_en_warning_irq_en     0x00000000U
#define MSK_NX90_canctrl_irq_en_overrun_irq_en             0x00000008U
#define SRT_NX90_canctrl_irq_en_overrun_irq_en             3
#define DFLT_VAL_NX90_canctrl_irq_en_overrun_irq_en        0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_irq_en_overrun_irq_en     0x00000000U
#define MSK_NX90_canctrl_irq_en_err_passive_irq_en         0x00000020U
#define SRT_NX90_canctrl_irq_en_err_passive_irq_en         5
#define DFLT_VAL_NX90_canctrl_irq_en_err_passive_irq_en    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_irq_en_err_passive_irq_en 0x00000000U
#define MSK_NX90_canctrl_irq_en_arb_lost_irq_en            0x00000040U
#define SRT_NX90_canctrl_irq_en_arb_lost_irq_en            6
#define DFLT_VAL_NX90_canctrl_irq_en_arb_lost_irq_en       0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_irq_en_arb_lost_irq_en    0x00000000U
#define MSK_NX90_canctrl_irq_en_bus_error_irq_en           0x00000080U
#define SRT_NX90_canctrl_irq_en_bus_error_irq_en           7
#define DFLT_VAL_NX90_canctrl_irq_en_bus_error_irq_en      0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_irq_en_bus_error_irq_en   0x00000000U

/* all used bits of 'NX90_canctrl_irq_en': */
#define MSK_USED_BITS_NX90_canctrl_irq_en 0x000000efU

enum {
  BFW_NX90_canctrl_irq_en_rx_irq_en          = 1,  /* [0] */
  BFW_NX90_canctrl_irq_en_tx_irq_en          = 1,  /* [1] */
  BFW_NX90_canctrl_irq_en_warning_irq_en     = 1,  /* [2] */
  BFW_NX90_canctrl_irq_en_overrun_irq_en     = 1,  /* [3] */
  BFW_NX90_canctrl_irq_en_reserved1          = 1,  /* [4] */
  BFW_NX90_canctrl_irq_en_err_passive_irq_en = 1,  /* [5] */
  BFW_NX90_canctrl_irq_en_arb_lost_irq_en    = 1,  /* [6] */
  BFW_NX90_canctrl_irq_en_bus_error_irq_en   = 1,  /* [7] */
  BFW_NX90_canctrl_irq_en_reserved2          = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_IRQ_EN_BIT_Ttag {
  unsigned int rx_irq_en          : BFW_NX90_canctrl_irq_en_rx_irq_en;          /* Receive Interrupt Enable                                */
                                                                                /* 1 enabled; when the receive buffer status is `full' the */
                                                                                /*   CAN controller requests the respective interrupt      */
                                                                                /* 0 disabled                                              */
  unsigned int tx_irq_en          : BFW_NX90_canctrl_irq_en_tx_irq_en;          /* Transmit Interrupt Enable                               */
                                                                                /* 1 enabled; when a message has been successfully         */
                                                                                /*   transmitted or the transmit buffer is accessible      */
                                                                                /*   again (e.g. after an abort transmission command),     */
                                                                                /*   the CAN controller requests the respective            */
                                                                                /*   interrupt                                             */
                                                                                /* 0 disabled                                              */
  unsigned int warning_irq_en     : BFW_NX90_canctrl_irq_en_warning_irq_en;     /* Error Warning Interrupt Enable                          */
                                                                                /* 1 enabled; if the error or bus status change (see       */
                                                                                /*   status register), the CAN controller                  */
                                                                                /*   requests the respective interrupt                     */
                                                                                /* 0 disabled                                              */
  unsigned int overrun_irq_en     : BFW_NX90_canctrl_irq_en_overrun_irq_en;     /* Data Overrun Interrupt Enable                           */
                                                                                /* 1 enabled; if the data overrun status bit is set (see   */
                                                                                /*   status register; Table 14), the CAN controller        */
                                                                                /*   requests the respective interrupt                     */
                                                                                /* 0 disabled                                              */
  unsigned int reserved1          : BFW_NX90_canctrl_irq_en_reserved1;          /* reserved                                                */
  unsigned int err_passive_irq_en : BFW_NX90_canctrl_irq_en_err_passive_irq_en; /* Error Passive Interrupt Enable                          */
                                                                                /* 1 enabled; if the error status of the CAN controller    */
                                                                                /*   changes from error active to error passive or vice    */
                                                                                /*   versa, the respective interrupt is requested          */
                                                                                /* 0 disabled                                              */
  unsigned int arb_lost_irq_en    : BFW_NX90_canctrl_irq_en_arb_lost_irq_en;    /* Arbitration Lost Interrupt Enable                       */
                                                                                /* 1 enabled; if the CAN controller has lost arbitration,  */
                                                                                /*   the respective interrupt is requested                 */
                                                                                /* 0 disabled                                              */
  unsigned int bus_error_irq_en   : BFW_NX90_canctrl_irq_en_bus_error_irq_en;   /* Bus Error Interrupt Enable                              */
                                                                                /* 1 enabled; if an bus error has been detected, the       */
                                                                                /*   CAN controller requests the respective interrupt      */
                                                                                /* 0 disabled                                              */
  unsigned int reserved2          : BFW_NX90_canctrl_irq_en_reserved2;          /* reserved                                                */
} NX90_CANCTRL_IRQ_EN_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_CANCTRL_IRQ_EN_BIT_T bf;
} NX90_CANCTRL_IRQ_EN_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_not_extended_acceptance_mask0 */
/* => CAN not extended acceptance mask register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_not_extended_acceptance_mask0           0x00000014U
#define Adr_NX90_can_ctrl0_app_canctrl_not_extended_acceptance_mask0 0xFF801914U
#define Adr_NX90_can_ctrl1_app_canctrl_not_extended_acceptance_mask0 0xFF801994U

/* --------------------------------------------------------------------- */
/* Register canctrl_bus_timing0 */
/* => CAN bus timing register 0, only writable in reset mode */
/*    in not extended mode: acceptance_mask_0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_bus_timing0           0x00000018U
#define Adr_NX90_can_ctrl0_app_canctrl_bus_timing0 0xFF801918U
#define Adr_NX90_can_ctrl1_app_canctrl_bus_timing0 0xFF801998U
#define DFLT_VAL_NX90_canctrl_bus_timing0          0x00000000U

#define MSK_NX90_canctrl_bus_timing0_prescaler               0x000001ffU
#define SRT_NX90_canctrl_bus_timing0_prescaler               0
#define DFLT_VAL_NX90_canctrl_bus_timing0_prescaler          0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_bus_timing0_prescaler       0x00000000U
#define MSK_NX90_canctrl_bus_timing0_sync_jump_width         0x00000600U
#define SRT_NX90_canctrl_bus_timing0_sync_jump_width         9
#define DFLT_VAL_NX90_canctrl_bus_timing0_sync_jump_width    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_bus_timing0_sync_jump_width 0x00000000U

/* all used bits of 'NX90_canctrl_bus_timing0': */
#define MSK_USED_BITS_NX90_canctrl_bus_timing0 0x000007ffU

enum {
  BFW_NX90_canctrl_bus_timing0_prescaler       = 9,  /* [8:0] */
  BFW_NX90_canctrl_bus_timing0_sync_jump_width = 2,  /* [10:9] */
  BFW_NX90_canctrl_bus_timing0_reserved1       = 21  /* [31:11] */
};

typedef struct NX90_CANCTRL_BUS_TIMING0_BIT_Ttag {
  unsigned int prescaler       : BFW_NX90_canctrl_bus_timing0_prescaler;       /* Baud Rate Prescaler                                            */
                                                                               /* The period of the CAN system clock tscl is programmable        */
                                                                               /* and determines the individual bit timing. The CAN system clock */
                                                                               /* is calculated using the following equation:                    */
                                                                               /* tscl = tCLK * prescaler                                        */
                                                                               /* with tCLK = 10 ns                                              */
  unsigned int sync_jump_width : BFW_NX90_canctrl_bus_timing0_sync_jump_width; /* Synchronization Jump Width                                     */
                                                                               /* To compensate for phase shifts between clock oscillators       */
                                                                               /* of different bus controllers, any bus controller must          */
                                                                               /* re-synchronize on any relevant signal edge of the current      */
                                                                               /* transmission. The synchronization jump width defines the       */
                                                                               /* maximum number of clock cycles a bit period may be shortened   */
                                                                               /* or lengthened by one re-synchronization:                       */
                                                                               /* tSJW = tscl * (sync_jump_width + 1)                            */
  unsigned int reserved1       : BFW_NX90_canctrl_bus_timing0_reserved1;       /* reserved                                                       */
} NX90_CANCTRL_BUS_TIMING0_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_CANCTRL_BUS_TIMING0_BIT_T bf;
} NX90_CANCTRL_BUS_TIMING0_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_bus_timing1 */
/* => CAN bus timing register 1, only writable in reset mode */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_bus_timing1           0x0000001CU
#define Adr_NX90_can_ctrl0_app_canctrl_bus_timing1 0xFF80191CU
#define Adr_NX90_can_ctrl1_app_canctrl_bus_timing1 0xFF80199CU
#define DFLT_VAL_NX90_canctrl_bus_timing1          0x00000000U

#define MSK_NX90_canctrl_bus_timing1_tseg1                0x0000003fU
#define SRT_NX90_canctrl_bus_timing1_tseg1                0
#define DFLT_VAL_NX90_canctrl_bus_timing1_tseg1           0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_bus_timing1_tseg1        0x00000000U
#define MSK_NX90_canctrl_bus_timing1_oversampling         0x00000080U
#define SRT_NX90_canctrl_bus_timing1_oversampling         7
#define DFLT_VAL_NX90_canctrl_bus_timing1_oversampling    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_bus_timing1_oversampling 0x00000000U
#define MSK_NX90_canctrl_bus_timing1_tseg2                0x00001f00U
#define SRT_NX90_canctrl_bus_timing1_tseg2                8
#define DFLT_VAL_NX90_canctrl_bus_timing1_tseg2           0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_bus_timing1_tseg2        0x00000000U

/* all used bits of 'NX90_canctrl_bus_timing1': */
#define MSK_USED_BITS_NX90_canctrl_bus_timing1 0x00001fbfU

enum {
  BFW_NX90_canctrl_bus_timing1_tseg1        = 6,  /* [5:0] */
  BFW_NX90_canctrl_bus_timing1_reserved1    = 1,  /* [6] */
  BFW_NX90_canctrl_bus_timing1_oversampling = 1,  /* [7] */
  BFW_NX90_canctrl_bus_timing1_tseg2        = 5,  /* [12:8] */
  BFW_NX90_canctrl_bus_timing1_reserved2    = 19  /* [31:13] */
};

typedef struct NX90_CANCTRL_BUS_TIMING1_BIT_Ttag {
  unsigned int tseg1        : BFW_NX90_canctrl_bus_timing1_tseg1;        /* Time Segment 1 (TSEG1)                                                            */
                                                                         /* TSEG1 determine the number of clock cycles per bit                                */
                                                                         /* period and the location of the sample point, where:                               */
                                                                         /* tSYNCSEG = 1 * tscl                                                               */
                                                                         /* tTSEG1 = tscl * (tseg1 + 1)                                                       */
  unsigned int reserved1    : BFW_NX90_canctrl_bus_timing1_reserved1;    /* reserved                                                                          */
  unsigned int oversampling : BFW_NX90_canctrl_bus_timing1_oversampling; /* Sampling                                                                          */
                                                                         /* 1 triple; the bus is sampled three times; recommended for low/medium speed buses  */
                                                                         /*   (class A and B) where filtering spikes on the bus line is beneficial            */
                                                                         /* 0 single; the bus is sampled once; recommended for high speed buses (SAE class C) */
  unsigned int tseg2        : BFW_NX90_canctrl_bus_timing1_tseg2;        /* Time Segment 2 (TSEG2)                                                            */
                                                                         /* TSEG2 determine the number of clock cycles per bit                                */
                                                                         /* period and the location of the sample point, where:                               */
                                                                         /* tTSEG2 = tscl * (tseg2 + 1)                                                       */
  unsigned int reserved2    : BFW_NX90_canctrl_bus_timing1_reserved2;    /* reserved                                                                          */
} NX90_CANCTRL_BUS_TIMING1_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_CANCTRL_BUS_TIMING1_BIT_T bf;
} NX90_CANCTRL_BUS_TIMING1_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_not_extended_data0 */
/* => CAN not extended data register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_not_extended_data0           0x00000028U
#define Adr_NX90_can_ctrl0_app_canctrl_not_extended_data0 0xFF801928U
#define Adr_NX90_can_ctrl1_app_canctrl_not_extended_data0 0xFF8019A8U

/* --------------------------------------------------------------------- */
/* Register canctrl_arb_lost_capture */
/* => CAN arbitration lost capture register */
/*    This register contains information about the bit position of losing arbitration. */
/*    reading the register will clear all bits */
/*    in not extended mode: data1 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_arb_lost_capture           0x0000002CU
#define Adr_NX90_can_ctrl0_app_canctrl_arb_lost_capture 0xFF80192CU
#define Adr_NX90_can_ctrl1_app_canctrl_arb_lost_capture 0xFF8019ACU

#define MSK_NX90_canctrl_arb_lost_capture_position 0x0000001fU
#define SRT_NX90_canctrl_arb_lost_capture_position 0

/* all used bits of 'NX90_canctrl_arb_lost_capture': */
#define MSK_USED_BITS_NX90_canctrl_arb_lost_capture 0x0000001fU

enum {
  BFW_NX90_canctrl_arb_lost_capture_position  = 5,  /* [4:0] */
  BFW_NX90_canctrl_arb_lost_capture_reserved1 = 27  /* [31:5] */
};

typedef struct NX90_CANCTRL_ARB_LOST_CAPTURE_BIT_Ttag {
  unsigned int position  : BFW_NX90_canctrl_arb_lost_capture_position;  /* Positon where arbitration was lost                                                       */
                                                                        /* {              |                                                                         */
                                                                        /*  Decimal value    Position                                                               */
                                                                        /*        00         arbitration lost in bit 1 of identifier                                */
                                                                        /*        01         arbitration lost in bit 2 of identifier                                */
                                                                        /*        02         arbitration lost in bit 3 of identifier                                */
                                                                        /*        03         arbitration lost in bit 4 of identifier                                */
                                                                        /*        04         arbitration lost in bit 5 of identifier                                */
                                                                        /*        05         arbitration lost in bit 6 of identifier                                */
                                                                        /*        06         arbitration lost in bit 7 of identifier                                */
                                                                        /*        07         arbitration lost in bit 8 of identifier                                */
                                                                        /*        08         arbitration lost in bit 9 of identifier                                */
                                                                        /*        09         arbitration lost in bit 10 of identifier                               */
                                                                        /*        10         arbitration lost in bit 11 of identifier                               */
                                                                        /*        11         arbitration lost in bit SRTR; (bit RTR for standard frame messages)    */
                                                                        /*        12         arbitration lost in bit IDE                                            */
                                                                        /*        13         arbitration lost in bit 12 of identifier; extended frame messages only */
                                                                        /*        14         arbitration lost in bit 13 of identifier; extended frame messages only */
                                                                        /*        15         arbitration lost in bit 14 of identifier; extended frame messages only */
                                                                        /*        16         arbitration lost in bit 15 of identifier; extended frame messages only */
                                                                        /*        17         arbitration lost in bit 16 of identifier; extended frame messages only */
                                                                        /*        18         arbitration lost in bit 17 of identifier; extended frame messages only */
                                                                        /*        19         arbitration lost in bit 18 of identifier; extended frame messages only */
                                                                        /*        20         arbitration lost in bit 19 of identifier; extended frame messages only */
                                                                        /*        21         arbitration lost in bit 20 of identifier; extended frame messages only */
                                                                        /*        22         arbitration lost in bit 21 of identifier; extended frame messages only */
                                                                        /*        23         arbitration lost in bit 22 of identifier; extended frame messages only */
                                                                        /*        24         arbitration lost in bit 23 of identifier; extended frame messages only */
                                                                        /*        25         arbitration lost in bit 24 of identifier; extended frame messages only */
                                                                        /*        26         arbitration lost in bit 25 of identifier; extended frame messages only */
                                                                        /*        27         arbitration lost in bit 26 of identifier; extended frame messages only */
                                                                        /*        28         arbitration lost in bit 27 of identifier; extended frame messages only */
                                                                        /*        29         arbitration lost in bit 28 of identifier; extended frame messages only */
                                                                        /*        30         arbitration lost in bit 29 of identifier; extended frame messages only */
                                                                        /*        31         arbitration lost in bit RTR; extended frame messages only  }           */
  unsigned int reserved1 : BFW_NX90_canctrl_arb_lost_capture_reserved1; /* reserved                                                                                 */
} NX90_CANCTRL_ARB_LOST_CAPTURE_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_CANCTRL_ARB_LOST_CAPTURE_BIT_T bf;
} NX90_CANCTRL_ARB_LOST_CAPTURE_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_err_code_capture */
/* => CAN error code capture register */
/*    This register contains information about the type and location of errors on the bus. */
/*    reading the register will clear all bits */
/*    in not extended mode: data2 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_err_code_capture           0x00000030U
#define Adr_NX90_can_ctrl0_app_canctrl_err_code_capture 0xFF801930U
#define Adr_NX90_can_ctrl1_app_canctrl_err_code_capture 0xFF8019B0U

#define MSK_NX90_canctrl_err_code_capture_segment   0x0000001fU
#define SRT_NX90_canctrl_err_code_capture_segment   0
#define MSK_NX90_canctrl_err_code_capture_direction 0x00000020U
#define SRT_NX90_canctrl_err_code_capture_direction 5
#define MSK_NX90_canctrl_err_code_capture_err_code  0x000000c0U
#define SRT_NX90_canctrl_err_code_capture_err_code  6

/* all used bits of 'NX90_canctrl_err_code_capture': */
#define MSK_USED_BITS_NX90_canctrl_err_code_capture 0x000000ffU

enum {
  BFW_NX90_canctrl_err_code_capture_segment   = 5,  /* [4:0] */
  BFW_NX90_canctrl_err_code_capture_direction = 1,  /* [5] */
  BFW_NX90_canctrl_err_code_capture_err_code  = 2,  /* [7:6] */
  BFW_NX90_canctrl_err_code_capture_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_ERR_CODE_CAPTURE_BIT_Ttag {
  unsigned int segment   : BFW_NX90_canctrl_err_code_capture_segment;   /* Frame segment where error was detected        */
                                                                        /* {                  |                          */
                                                                        /*     Binary value       Segment                */
                                                                        /*        00011           start of frame         */
                                                                        /*        00010           ID.28 to ID.21         */
                                                                        /*        00110           ID.20 to ID.18         */
                                                                        /*        00100           bit SRTR               */
                                                                        /*        00101           bit IDE                */
                                                                        /*        00111           ID.17 to ID.13         */
                                                                        /*        01111           ID.12 to ID.5          */
                                                                        /*        01110           ID.4 to ID.0           */
                                                                        /*        01100           bit RTR                */
                                                                        /*        01101           reser ved bit 1        */
                                                                        /*        01001           reser ved bit 0        */
                                                                        /*        01011           data length code       */
                                                                        /*        01010           data field             */
                                                                        /*        01000           CRC sequence           */
                                                                        /*        11000           CRC delimiter          */
                                                                        /*        11001           acknowledge slot       */
                                                                        /*        11011           acknowledge delimiter  */
                                                                        /*        11010           end of frame           */
                                                                        /*        10010           intermission           */
                                                                        /*        10001           active error flag      */
                                                                        /*        10110           passive error flag     */
                                                                        /*        10011           tolerate dominant bits */
                                                                        /*        10111           error delimiter        */
                                                                        /*        11100           overload flag }        */
  unsigned int direction : BFW_NX90_canctrl_err_code_capture_direction; /* Direction                                     */
                                                                        /* 1 RX; error occurred during reception         */
                                                                        /* 0 TX; error occurred during transmission      */
  unsigned int err_code  : BFW_NX90_canctrl_err_code_capture_err_code;  /* Error code                                    */
                                                                        /* {                  |                          */
                                                                        /*     Binary value      Code                    */
                                                                        /*         00            bit error               */
                                                                        /*         01            form error              */
                                                                        /*         10            stuff error             */
                                                                        /*         11            other type of error }   */
  unsigned int reserved1 : BFW_NX90_canctrl_err_code_capture_reserved1; /* reserved                                      */
} NX90_CANCTRL_ERR_CODE_CAPTURE_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_CANCTRL_ERR_CODE_CAPTURE_BIT_T bf;
} NX90_CANCTRL_ERR_CODE_CAPTURE_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_err_warning_limit */
/* => CAN error warning limit register, only writable in reset mode */
/*    in not extended mode: data3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_err_warning_limit           0x00000034U
#define Adr_NX90_can_ctrl0_app_canctrl_err_warning_limit 0xFF801934U
#define Adr_NX90_can_ctrl1_app_canctrl_err_warning_limit 0xFF8019B4U
#define DFLT_VAL_NX90_canctrl_err_warning_limit          0x00000060U

#define MSK_NX90_canctrl_err_warning_limit_limit         0x000000ffU
#define SRT_NX90_canctrl_err_warning_limit_limit         0
#define DFLT_VAL_NX90_canctrl_err_warning_limit_limit    0x00000060U
#define DFLT_BF_VAL_NX90_canctrl_err_warning_limit_limit 0x00000060U

/* all used bits of 'NX90_canctrl_err_warning_limit': */
#define MSK_USED_BITS_NX90_canctrl_err_warning_limit 0x000000ffU

enum {
  BFW_NX90_canctrl_err_warning_limit_limit     = 8,  /* [7:0] */
  BFW_NX90_canctrl_err_warning_limit_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_ERR_WARNING_LIMIT_BIT_Ttag {
  unsigned int limit     : BFW_NX90_canctrl_err_warning_limit_limit;     /* error warning limit */
  unsigned int reserved1 : BFW_NX90_canctrl_err_warning_limit_reserved1; /* reserved            */
} NX90_CANCTRL_ERR_WARNING_LIMIT_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_CANCTRL_ERR_WARNING_LIMIT_BIT_T bf;
} NX90_CANCTRL_ERR_WARNING_LIMIT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_rx_error_cnt */
/* => CAN RX error counter register, only writable in reset mode */
/*    The RX error counter register reflects the current value of the receive error counter. */
/*    If a bus-off event occurs, the RX error counter is initialized to logic 0. The time bus-off is valid, writing to this register has */
/*    no effect. */
/*    Note, that a CPU-forced content change of the RX error counter is only possible, if the reset mode was entered */
/*    previously. An error status change (see status register), an error warning or an error passive interrupt forced */
/*    by the new register content will not occur, until the reset mode is cancelled again. */
/*    in not extended mode: data4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_rx_error_cnt           0x00000038U
#define Adr_NX90_can_ctrl0_app_canctrl_rx_error_cnt 0xFF801938U
#define Adr_NX90_can_ctrl1_app_canctrl_rx_error_cnt 0xFF8019B8U
#define DFLT_VAL_NX90_canctrl_rx_error_cnt          0x00000000U

#define MSK_NX90_canctrl_rx_error_cnt_rx_err         0x000000ffU
#define SRT_NX90_canctrl_rx_error_cnt_rx_err         0
#define DFLT_VAL_NX90_canctrl_rx_error_cnt_rx_err    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_rx_error_cnt_rx_err 0x00000000U

/* all used bits of 'NX90_canctrl_rx_error_cnt': */
#define MSK_USED_BITS_NX90_canctrl_rx_error_cnt 0x000000ffU

enum {
  BFW_NX90_canctrl_rx_error_cnt_rx_err    = 8,  /* [7:0] */
  BFW_NX90_canctrl_rx_error_cnt_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_RX_ERROR_CNT_BIT_Ttag {
  unsigned int rx_err    : BFW_NX90_canctrl_rx_error_cnt_rx_err;    /* rx error counter */
  unsigned int reserved1 : BFW_NX90_canctrl_rx_error_cnt_reserved1; /* reserved         */
} NX90_CANCTRL_RX_ERROR_CNT_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_CANCTRL_RX_ERROR_CNT_BIT_T bf;
} NX90_CANCTRL_RX_ERROR_CNT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_tx_error_cnt */
/* => CAN TX error counter register, only writable in reset mode */
/*    The TX error counter register reflects the current value of the transmit error counter. */
/*    If a bus-off event occurs, the TX error counter is initialized to 127 to count the minimum */
/*    protocol-defined time (128 occurrences of the bus-free signal). Reading */
/*    the TX error counter during this time gives information about the status of the bus-off recovery. */
/*    If bus-off is active, a write access to TXERR in the range from 0 to 254 clears the bus-off flag and the controller will wait */
/*    for one occurrence of 11 consecutive recessive bits (bus-free) after the reset mode has been cleared. */
/*    Writing 255 to TXERR allows to initiate a CPU-driven bus-off event. It should be noted that a CPU-forced content change */
/*    of the TX error counter is only possible, if the reset mode was entered previously. An error or bus status change (see */
/*    status register), an error warning or an error passive interrupt forced by the new register content will not occur */
/*    until the reset mode is cancelled again. After leaving the reset mode, the new TX counter content is interpreted and the */
/*    bus-off event is performed in the same way, as if it was forced by a bus error event. That means, that the reset mode is */
/*    entered again, the TX error counter is initialized to 127, the RX counter is cleared and all concerned status and interrupt */
/*    register bits are set. */
/*    Clearing of reset mode now will perform the protocol-defined bus-off recovery sequence (waiting for 128 occurrences of */
/*    the bus-free signal). */
/*    If the reset mode is entered again before the end of bus-off recovery (TXERR > 0), bus-off keeps active and TXERR is */
/*    frozen. */
/*    in not extended mode: data5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_tx_error_cnt           0x0000003CU
#define Adr_NX90_can_ctrl0_app_canctrl_tx_error_cnt 0xFF80193CU
#define Adr_NX90_can_ctrl1_app_canctrl_tx_error_cnt 0xFF8019BCU
#define DFLT_VAL_NX90_canctrl_tx_error_cnt          0x00000000U

#define MSK_NX90_canctrl_tx_error_cnt_tx_err         0x000000ffU
#define SRT_NX90_canctrl_tx_error_cnt_tx_err         0
#define DFLT_VAL_NX90_canctrl_tx_error_cnt_tx_err    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_tx_error_cnt_tx_err 0x00000000U

/* all used bits of 'NX90_canctrl_tx_error_cnt': */
#define MSK_USED_BITS_NX90_canctrl_tx_error_cnt 0x000000ffU

enum {
  BFW_NX90_canctrl_tx_error_cnt_tx_err    = 8,  /* [7:0] */
  BFW_NX90_canctrl_tx_error_cnt_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_TX_ERROR_CNT_BIT_Ttag {
  unsigned int tx_err    : BFW_NX90_canctrl_tx_error_cnt_tx_err;    /* tx error counter */
  unsigned int reserved1 : BFW_NX90_canctrl_tx_error_cnt_reserved1; /* reserved         */
} NX90_CANCTRL_TX_ERROR_CNT_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_CANCTRL_TX_ERROR_CNT_BIT_T bf;
} NX90_CANCTRL_TX_ERROR_CNT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data0 */
/* => CAN data register 0 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 0 */
/*     Operating mode:   R:  Standard frame: Read RX frame information */
/*                           Extended frame: Read RX frame information */
/*                       W:  Standard frame: Write TX frame information */
/*                           Extended frame: Write TX frame information } */
/*    in not extended mode: data6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data0           0x00000040U
#define Adr_NX90_can_ctrl0_app_canctrl_data0 0xFF801940U
#define Adr_NX90_can_ctrl1_app_canctrl_data0 0xFF8019C0U
#define DFLT_VAL_NX90_canctrl_data0          0x00000000U

#define MSK_NX90_canctrl_data0_data         0x000000ffU
#define SRT_NX90_canctrl_data0_data         0
#define DFLT_VAL_NX90_canctrl_data0_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data0_data 0x00000000U

/* all used bits of 'NX90_canctrl_data0': */
#define MSK_USED_BITS_NX90_canctrl_data0 0x000000ffU

enum {
  BFW_NX90_canctrl_data0_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data0_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA0_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data0_data;      /* register content (rx data, tx data or acceptance code) */
  unsigned int reserved1 : BFW_NX90_canctrl_data0_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA0_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA0_BIT_T bf;
} NX90_CANCTRL_DATA0_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data1 */
/* => CAN data register 1 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 1 */
/*     Operating mode:   R:  Standard frame: Read RX identifier 1 */
/*                           Extended frame: Read RX identifier 1 */
/*                       W:  Standard frame: Write TX identifier 1 */
/*                           Extended frame: Write TX identifier 1 } */
/*    in not extended mode: data7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data1           0x00000044U
#define Adr_NX90_can_ctrl0_app_canctrl_data1 0xFF801944U
#define Adr_NX90_can_ctrl1_app_canctrl_data1 0xFF8019C4U
#define DFLT_VAL_NX90_canctrl_data1          0x00000000U

#define MSK_NX90_canctrl_data1_data         0x000000ffU
#define SRT_NX90_canctrl_data1_data         0
#define DFLT_VAL_NX90_canctrl_data1_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data1_data 0x00000000U

/* all used bits of 'NX90_canctrl_data1': */
#define MSK_USED_BITS_NX90_canctrl_data1 0x000000ffU

enum {
  BFW_NX90_canctrl_data1_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data1_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA1_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data1_data;      /* register content (rx data, tx data or acceptance code) */
  unsigned int reserved1 : BFW_NX90_canctrl_data1_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA1_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA1_BIT_T bf;
} NX90_CANCTRL_DATA1_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data2 */
/* => CAN data register 2 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 2 */
/*     Operating mode:   R:  Standard frame: Read RX identifier 2 */
/*                           Extended frame: Read RX identifier 2 */
/*                       W:  Standard frame: Write TX identifier 2 */
/*                           Extended frame: Write TX identifier 2 } */
/*    in not extended mode: data8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data2           0x00000048U
#define Adr_NX90_can_ctrl0_app_canctrl_data2 0xFF801948U
#define Adr_NX90_can_ctrl1_app_canctrl_data2 0xFF8019C8U
#define DFLT_VAL_NX90_canctrl_data2          0x00000000U

#define MSK_NX90_canctrl_data2_data         0x000000ffU
#define SRT_NX90_canctrl_data2_data         0
#define DFLT_VAL_NX90_canctrl_data2_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data2_data 0x00000000U

/* all used bits of 'NX90_canctrl_data2': */
#define MSK_USED_BITS_NX90_canctrl_data2 0x000000ffU

enum {
  BFW_NX90_canctrl_data2_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data2_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA2_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data2_data;      /* register content (rx data, tx data or acceptance code) */
  unsigned int reserved1 : BFW_NX90_canctrl_data2_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA2_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA2_BIT_T bf;
} NX90_CANCTRL_DATA2_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data3 */
/* => CAN data register 3 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 3 */
/*     Operating mode:   R:  Standard frame: Read RX data 1 */
/*                           Extended frame: Read RX identifier 3 */
/*                       W:  Standard frame: Write TX data 1 */
/*                           Extended frame: Write TX identifier 3 } */
/*    in not extended mode: data9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data3           0x0000004CU
#define Adr_NX90_can_ctrl0_app_canctrl_data3 0xFF80194CU
#define Adr_NX90_can_ctrl1_app_canctrl_data3 0xFF8019CCU
#define DFLT_VAL_NX90_canctrl_data3          0x00000000U

#define MSK_NX90_canctrl_data3_data         0x000000ffU
#define SRT_NX90_canctrl_data3_data         0
#define DFLT_VAL_NX90_canctrl_data3_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data3_data 0x00000000U

/* all used bits of 'NX90_canctrl_data3': */
#define MSK_USED_BITS_NX90_canctrl_data3 0x000000ffU

enum {
  BFW_NX90_canctrl_data3_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data3_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA3_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data3_data;      /* register content (rx data, tx data or acceptance code) */
  unsigned int reserved1 : BFW_NX90_canctrl_data3_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA3_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA3_BIT_T bf;
} NX90_CANCTRL_DATA3_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data4 */
/* => CAN data register 4 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 0 */
/*     Operating mode:   R:  Standard frame: Read RX data 2 */
/*                           Extended frame: Read RX identifier 4 */
/*                       W:  Standard frame: Write TX data 2 */
/*                           Extended frame: Write TX identifier 4 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data4           0x00000050U
#define Adr_NX90_can_ctrl0_app_canctrl_data4 0xFF801950U
#define Adr_NX90_can_ctrl1_app_canctrl_data4 0xFF8019D0U
#define DFLT_VAL_NX90_canctrl_data4          0x00000000U

#define MSK_NX90_canctrl_data4_data         0x000000ffU
#define SRT_NX90_canctrl_data4_data         0
#define DFLT_VAL_NX90_canctrl_data4_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data4_data 0x00000000U

/* all used bits of 'NX90_canctrl_data4': */
#define MSK_USED_BITS_NX90_canctrl_data4 0x000000ffU

enum {
  BFW_NX90_canctrl_data4_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data4_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA4_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data4_data;      /* register content (rx data, tx data or acceptance mask) */
  unsigned int reserved1 : BFW_NX90_canctrl_data4_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA4_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA4_BIT_T bf;
} NX90_CANCTRL_DATA4_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data5 */
/* => CAN data register 5 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 1 */
/*     Operating mode:   R:  Standard frame: Read RX data 3 */
/*                           Extended frame: Read RX data 1 */
/*                       W:  Standard frame: Write TX data 3 */
/*                           Extended frame: Write TX data 1 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data5           0x00000054U
#define Adr_NX90_can_ctrl0_app_canctrl_data5 0xFF801954U
#define Adr_NX90_can_ctrl1_app_canctrl_data5 0xFF8019D4U
#define DFLT_VAL_NX90_canctrl_data5          0x00000000U

#define MSK_NX90_canctrl_data5_data         0x000000ffU
#define SRT_NX90_canctrl_data5_data         0
#define DFLT_VAL_NX90_canctrl_data5_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data5_data 0x00000000U

/* all used bits of 'NX90_canctrl_data5': */
#define MSK_USED_BITS_NX90_canctrl_data5 0x000000ffU

enum {
  BFW_NX90_canctrl_data5_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data5_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA5_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data5_data;      /* register content (rx data, tx data or acceptance mask) */
  unsigned int reserved1 : BFW_NX90_canctrl_data5_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA5_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA5_BIT_T bf;
} NX90_CANCTRL_DATA5_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data6 */
/* => CAN data register 6 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 2 */
/*     Operating mode:   R:  Standard frame: Read RX data 4 */
/*                           Extended frame: Read RX data 2 */
/*                       W:  Standard frame: Write TX data 4 */
/*                           Extended frame: Write TX data 2 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data6           0x00000058U
#define Adr_NX90_can_ctrl0_app_canctrl_data6 0xFF801958U
#define Adr_NX90_can_ctrl1_app_canctrl_data6 0xFF8019D8U
#define DFLT_VAL_NX90_canctrl_data6          0x00000000U

#define MSK_NX90_canctrl_data6_data         0x000000ffU
#define SRT_NX90_canctrl_data6_data         0
#define DFLT_VAL_NX90_canctrl_data6_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data6_data 0x00000000U

/* all used bits of 'NX90_canctrl_data6': */
#define MSK_USED_BITS_NX90_canctrl_data6 0x000000ffU

enum {
  BFW_NX90_canctrl_data6_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data6_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA6_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data6_data;      /* register content (rx data, tx data or acceptance mask) */
  unsigned int reserved1 : BFW_NX90_canctrl_data6_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA6_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA6_BIT_T bf;
} NX90_CANCTRL_DATA6_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data7 */
/* => CAN data register 7 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 3 */
/*     Operating mode:   R:  Standard frame: Read RX data 5 */
/*                           Extended frame: Read RX data 3 */
/*                       W:  Standard frame: Write TX data 5 */
/*                           Extended frame: Write TX data 3 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data7           0x0000005CU
#define Adr_NX90_can_ctrl0_app_canctrl_data7 0xFF80195CU
#define Adr_NX90_can_ctrl1_app_canctrl_data7 0xFF8019DCU
#define DFLT_VAL_NX90_canctrl_data7          0x00000000U

#define MSK_NX90_canctrl_data7_data         0x000000ffU
#define SRT_NX90_canctrl_data7_data         0
#define DFLT_VAL_NX90_canctrl_data7_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data7_data 0x00000000U

/* all used bits of 'NX90_canctrl_data7': */
#define MSK_USED_BITS_NX90_canctrl_data7 0x000000ffU

enum {
  BFW_NX90_canctrl_data7_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data7_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA7_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data7_data;      /* register content (rx data, tx data or acceptance mask) */
  unsigned int reserved1 : BFW_NX90_canctrl_data7_reserved1; /* reserved                                               */
} NX90_CANCTRL_DATA7_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA7_BIT_T bf;
} NX90_CANCTRL_DATA7_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data8 */
/* => CAN data register 8 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: Read RX data 6 */
/*                           Extended frame: Read RX data 4 */
/*                       W:  Standard frame: Write TX data 6 */
/*                           Extended frame: Write TX data 4 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data8           0x00000060U
#define Adr_NX90_can_ctrl0_app_canctrl_data8 0xFF801960U
#define Adr_NX90_can_ctrl1_app_canctrl_data8 0xFF8019E0U
#define DFLT_VAL_NX90_canctrl_data8          0x00000000U

#define MSK_NX90_canctrl_data8_data         0x000000ffU
#define SRT_NX90_canctrl_data8_data         0
#define DFLT_VAL_NX90_canctrl_data8_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data8_data 0x00000000U

/* all used bits of 'NX90_canctrl_data8': */
#define MSK_USED_BITS_NX90_canctrl_data8 0x000000ffU

enum {
  BFW_NX90_canctrl_data8_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data8_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA8_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data8_data;      /* register content (rx data or tx data) */
  unsigned int reserved1 : BFW_NX90_canctrl_data8_reserved1; /* reserved                              */
} NX90_CANCTRL_DATA8_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA8_BIT_T bf;
} NX90_CANCTRL_DATA8_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data9 */
/* => CAN data register 9 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: Read RX data 7 */
/*                           Extended frame: Read RX data 5 */
/*                       W:  Standard frame: Write TX data 7 */
/*                           Extended frame: Write TX data 5 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data9           0x00000064U
#define Adr_NX90_can_ctrl0_app_canctrl_data9 0xFF801964U
#define Adr_NX90_can_ctrl1_app_canctrl_data9 0xFF8019E4U
#define DFLT_VAL_NX90_canctrl_data9          0x00000000U

#define MSK_NX90_canctrl_data9_data         0x000000ffU
#define SRT_NX90_canctrl_data9_data         0
#define DFLT_VAL_NX90_canctrl_data9_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data9_data 0x00000000U

/* all used bits of 'NX90_canctrl_data9': */
#define MSK_USED_BITS_NX90_canctrl_data9 0x000000ffU

enum {
  BFW_NX90_canctrl_data9_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data9_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA9_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data9_data;      /* register content (rx data or tx data) */
  unsigned int reserved1 : BFW_NX90_canctrl_data9_reserved1; /* reserved                              */
} NX90_CANCTRL_DATA9_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_CANCTRL_DATA9_BIT_T bf;
} NX90_CANCTRL_DATA9_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data10 */
/* => CAN data register 10 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: Read RX data 8 */
/*                           Extended frame: Read RX data 6 */
/*                       W:  Standard frame: Write TX data 8 */
/*                           Extended frame: Write TX data 6 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data10           0x00000068U
#define Adr_NX90_can_ctrl0_app_canctrl_data10 0xFF801968U
#define Adr_NX90_can_ctrl1_app_canctrl_data10 0xFF8019E8U
#define DFLT_VAL_NX90_canctrl_data10          0x00000000U

#define MSK_NX90_canctrl_data10_data         0x000000ffU
#define SRT_NX90_canctrl_data10_data         0
#define DFLT_VAL_NX90_canctrl_data10_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data10_data 0x00000000U

/* all used bits of 'NX90_canctrl_data10': */
#define MSK_USED_BITS_NX90_canctrl_data10 0x000000ffU

enum {
  BFW_NX90_canctrl_data10_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data10_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA10_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data10_data;      /* register content (rx data or tx data) */
  unsigned int reserved1 : BFW_NX90_canctrl_data10_reserved1; /* reserved                              */
} NX90_CANCTRL_DATA10_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_CANCTRL_DATA10_BIT_T bf;
} NX90_CANCTRL_DATA10_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data11 */
/* => CAN data register 11 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: reserved */
/*                           Extended frame: Read RX data 7 */
/*                       W:  Standard frame: reserved */
/*                           Extended frame: Write TX data 7 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data11           0x0000006CU
#define Adr_NX90_can_ctrl0_app_canctrl_data11 0xFF80196CU
#define Adr_NX90_can_ctrl1_app_canctrl_data11 0xFF8019ECU
#define DFLT_VAL_NX90_canctrl_data11          0x00000000U

#define MSK_NX90_canctrl_data11_data         0x000000ffU
#define SRT_NX90_canctrl_data11_data         0
#define DFLT_VAL_NX90_canctrl_data11_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data11_data 0x00000000U

/* all used bits of 'NX90_canctrl_data11': */
#define MSK_USED_BITS_NX90_canctrl_data11 0x000000ffU

enum {
  BFW_NX90_canctrl_data11_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data11_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA11_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data11_data;      /* register content (rx data or tx data) */
  unsigned int reserved1 : BFW_NX90_canctrl_data11_reserved1; /* reserved                              */
} NX90_CANCTRL_DATA11_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_CANCTRL_DATA11_BIT_T bf;
} NX90_CANCTRL_DATA11_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data12 */
/* => CAN data register 12 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: reserved */
/*                           Extended frame: Read RX data 8 */
/*                       W:  Standard frame: reserved */
/*                           Extended frame: Write TX data 8 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_data12           0x00000070U
#define Adr_NX90_can_ctrl0_app_canctrl_data12 0xFF801970U
#define Adr_NX90_can_ctrl1_app_canctrl_data12 0xFF8019F0U
#define DFLT_VAL_NX90_canctrl_data12          0x00000000U

#define MSK_NX90_canctrl_data12_data         0x000000ffU
#define SRT_NX90_canctrl_data12_data         0
#define DFLT_VAL_NX90_canctrl_data12_data    0x00000000U
#define DFLT_BF_VAL_NX90_canctrl_data12_data 0x00000000U

/* all used bits of 'NX90_canctrl_data12': */
#define MSK_USED_BITS_NX90_canctrl_data12 0x000000ffU

enum {
  BFW_NX90_canctrl_data12_data      = 8,  /* [7:0] */
  BFW_NX90_canctrl_data12_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_DATA12_BIT_Ttag {
  unsigned int data      : BFW_NX90_canctrl_data12_data;      /* register content (rx data or tx data) */
  unsigned int reserved1 : BFW_NX90_canctrl_data12_reserved1; /* reserved                              */
} NX90_CANCTRL_DATA12_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_CANCTRL_DATA12_BIT_T bf;
} NX90_CANCTRL_DATA12_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_rx_message_cnt */
/* => CAN RX message counter register */
/*    Reflects the number of messages available within the RXFIFO. The value is */
/*    incremented with each receive event and decremented by the release receive */
/*    buffer command. After any reset event, this register is cleared. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_rx_message_cnt           0x00000074U
#define Adr_NX90_can_ctrl0_app_canctrl_rx_message_cnt 0xFF801974U
#define Adr_NX90_can_ctrl1_app_canctrl_rx_message_cnt 0xFF8019F4U

#define MSK_NX90_canctrl_rx_message_cnt_rx_msg_cnt 0x0000007fU
#define SRT_NX90_canctrl_rx_message_cnt_rx_msg_cnt 0

/* all used bits of 'NX90_canctrl_rx_message_cnt': */
#define MSK_USED_BITS_NX90_canctrl_rx_message_cnt 0x0000007fU

enum {
  BFW_NX90_canctrl_rx_message_cnt_rx_msg_cnt = 7,  /* [6:0] */
  BFW_NX90_canctrl_rx_message_cnt_reserved1  = 25  /* [31:7] */
};

typedef struct NX90_CANCTRL_RX_MESSAGE_CNT_BIT_Ttag {
  unsigned int rx_msg_cnt : BFW_NX90_canctrl_rx_message_cnt_rx_msg_cnt; /* rx message counter */
  unsigned int reserved1  : BFW_NX90_canctrl_rx_message_cnt_reserved1;  /* reserved           */
} NX90_CANCTRL_RX_MESSAGE_CNT_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_CANCTRL_RX_MESSAGE_CNT_BIT_T bf;
} NX90_CANCTRL_RX_MESSAGE_CNT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_mode_control */
/* => CAN mode control register, only writable in reset mode */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_canctrl_mode_control           0x0000007CU
#define Adr_NX90_can_ctrl0_app_canctrl_mode_control 0xFF80197CU
#define Adr_NX90_can_ctrl1_app_canctrl_mode_control 0xFF8019FCU

#define MSK_NX90_canctrl_mode_control_mode 0x00000080U
#define SRT_NX90_canctrl_mode_control_mode 7

/* all used bits of 'NX90_canctrl_mode_control': */
#define MSK_USED_BITS_NX90_canctrl_mode_control 0x00000080U

enum {
  BFW_NX90_canctrl_mode_control_reserved1 = 7,  /* [6:0] */
  BFW_NX90_canctrl_mode_control_mode      = 1,  /* [7] */
  BFW_NX90_canctrl_mode_control_reserved2 = 24  /* [31:8] */
};

typedef struct NX90_CANCTRL_MODE_CONTROL_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_canctrl_mode_control_reserved1; /* reserved                                                                                      */
  unsigned int mode      : BFW_NX90_canctrl_mode_control_mode;      /* 0: BasicCAN mode, 1: PeliCAN mode                                                             */
                                                                    /* recommended value is 1 (PeliCAN mode),                                                        */
                                                                    /* The here given register map of all registers of the CAN controller is valid for PeliCAN only. */
  unsigned int reserved2 : BFW_NX90_canctrl_mode_control_reserved2; /* reserved                                                                                      */
} NX90_CANCTRL_MODE_CONTROL_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_CANCTRL_MODE_CONTROL_BIT_T bf;
} NX90_CANCTRL_MODE_CONTROL_T;


/* ===================================================================== */

/* AREA spi */
/* Area of spi0_app, spi1_app, spi2_app, spi_xpic_app */

/* ===================================================================== */

#define Addr_NX90_spi0_app     0xFF801A00U
#define Addr_NX90_spi1_app     0xFF801A40U
#define Addr_NX90_spi2_app     0xFF801A80U
#define Addr_NX90_spi_xpic_app 0xFF900380U

/* --------------------------------------------------------------------- */
/* Register spi_cr0 */
/* => SPI control register 0 */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_cr0          0x00000000U
#define Adr_NX90_spi0_app_spi_cr0     0xFF801A00U
#define Adr_NX90_spi1_app_spi_cr0     0xFF801A40U
#define Adr_NX90_spi2_app_spi_cr0     0xFF801A80U
#define Adr_NX90_spi_xpic_app_spi_cr0 0xFF900380U
#define DFLT_VAL_NX90_spi_cr0         0x80080007U

#define MSK_NX90_spi_cr0_datasize                0x0000000fU
#define SRT_NX90_spi_cr0_datasize                0
#define DFLT_VAL_NX90_spi_cr0_datasize           0x00000007U
#define DFLT_BF_VAL_NX90_spi_cr0_datasize        0x00000007U
#define MSK_NX90_spi_cr0_SPO                     0x00000040U
#define SRT_NX90_spi_cr0_SPO                     6
#define DFLT_VAL_NX90_spi_cr0_SPO                0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr0_SPO             0x00000000U
#define MSK_NX90_spi_cr0_SPH                     0x00000080U
#define SRT_NX90_spi_cr0_SPH                     7
#define DFLT_VAL_NX90_spi_cr0_SPH                0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr0_SPH             0x00000000U
#define MSK_NX90_spi_cr0_sck_muladd              0x000fff00U
#define SRT_NX90_spi_cr0_sck_muladd              8
#define DFLT_VAL_NX90_spi_cr0_sck_muladd         0x00080000U
#define DFLT_BF_VAL_NX90_spi_cr0_sck_muladd      0x00000800U
#define MSK_NX90_spi_cr0_format                  0x03000000U
#define SRT_NX90_spi_cr0_format                  24
#define DFLT_VAL_NX90_spi_cr0_format             0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr0_format          0x00000000U
#define MSK_NX90_spi_cr0_filter_in               0x08000000U
#define SRT_NX90_spi_cr0_filter_in               27
#define DFLT_VAL_NX90_spi_cr0_filter_in          0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr0_filter_in       0x00000000U
#define MSK_NX90_spi_cr0_slave_sig_early         0x10000000U
#define SRT_NX90_spi_cr0_slave_sig_early         28
#define DFLT_VAL_NX90_spi_cr0_slave_sig_early    0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr0_slave_sig_early 0x00000000U
#define MSK_NX90_spi_cr0_netx100_comp            0x80000000U
#define SRT_NX90_spi_cr0_netx100_comp            31
#define DFLT_VAL_NX90_spi_cr0_netx100_comp       0x80000000U
#define DFLT_BF_VAL_NX90_spi_cr0_netx100_comp    0x00000001U

/* all used bits of 'NX90_spi_cr0': */
#define MSK_USED_BITS_NX90_spi_cr0 0x9b0fffcfU

enum {
  BFW_NX90_spi_cr0_datasize        = 4,  /* [3:0] */
  BFW_NX90_spi_cr0_reserved1       = 2,  /* [5:4] */
  BFW_NX90_spi_cr0_SPO             = 1,  /* [6] */
  BFW_NX90_spi_cr0_SPH             = 1,  /* [7] */
  BFW_NX90_spi_cr0_sck_muladd      = 12, /* [19:8] */
  BFW_NX90_spi_cr0_reserved2       = 4,  /* [23:20] */
  BFW_NX90_spi_cr0_format          = 2,  /* [25:24] */
  BFW_NX90_spi_cr0_reserved3       = 1,  /* [26] */
  BFW_NX90_spi_cr0_filter_in       = 1,  /* [27] */
  BFW_NX90_spi_cr0_slave_sig_early = 1,  /* [28] */
  BFW_NX90_spi_cr0_reserved4       = 2,  /* [30:29] */
  BFW_NX90_spi_cr0_netx100_comp    = 1   /* [31] */
};

typedef struct NX90_SPI_CR0_BIT_Ttag {
  unsigned int datasize        : BFW_NX90_spi_cr0_datasize;        /* DSS: data size select (transfer size = datasize + 1 bits):                                                              */
                                                                   /* {            |                                                                                                          */
                                                                   /* 0000...0010: reserved                                                                                                   */
                                                                   /* 0011:        4 bit                                                                                                      */
                                                                   /* 0100:        5 bit                                                                                                      */
                                                                   /* ...                                                                                                                     */
                                                                   /* 0111:        8 bit                                                                                                      */
                                                                   /* ...                                                                                                                     */
                                                                   /* 1111:        16 bit }                                                                                                   */
                                                                   /* Note: 16 bit TX-data-loss bug of netX50/netX5 is fixed since netX10.                                                    */
  unsigned int reserved1       : BFW_NX90_spi_cr0_reserved1;       /* reserved                                                                                                                */
  unsigned int SPO             : BFW_NX90_spi_cr0_SPO;             /* Serial clock polarity (netx500: CR_cpol):                                                                               */
                                                                   /* 0: idle: clock is low, first edge is rising                                                                             */
                                                                   /* 1: idle: clock is high, first edge is falling                                                                           */
  unsigned int SPH             : BFW_NX90_spi_cr0_SPH;             /* Serial clock phase (netx500: CR_ncpha):                                                                                 */
                                                                   /* 1: sample data at second clock edge, data is generated half a clock phase before sampling                               */
                                                                   /* 0: sample data at first clock edge, data is generated half a clock phase before sampling                                */
  unsigned int sck_muladd      : BFW_NX90_spi_cr0_sck_muladd;      /* Serial clock rate multiply add value for master SCK generation.                                                         */
                                                                   /* The SPI clock frequency is: f_spi_sck = (sck_muladd * 100)/4096 [MHz].                                                  */
                                                                   /* Default value 0x800 equals 50MHz SPI clock rate.                                                                        */
                                                                   /* All serial clock rates are derived from 100MHz netX system clock. Hence, all serial clock phases are multiples          */
                                                                   /* of 10ns. This leads to non-constant serial clock phases when a clock rate is programmed which cannot be generated       */
                                                                   /* by 100MHz/(2*n) without remainder. E.g. programming 0x4CC here will lead to a mean clock-rate of 30MHz. However,        */
                                                                   /* single clock high and low phases of 10ns and clock periods of 30ns will occur. This must be considered for              */
                                                                   /* serial device selection. E.g. using a 30MHz device which requires 33ns minimum clock period and a duty cycle            */
                                                                   /* of 50% will fail.                                                                                                       */
                                                                   /* Note: If sck_muladd is set to zero, SPI transfer will freeze.                                                           */
                                                                   /* The SPI clock must not exceed (system frequency/4) in slave mode, if correct data sampling should always be guaranteed. */
                                                                   /* Note: The value programmed here has no impact in slave mode.                                                            */
  unsigned int reserved2       : BFW_NX90_spi_cr0_reserved2;       /* reserved                                                                                                                */
  unsigned int format          : BFW_NX90_spi_cr0_format;          /* Frame format:                                                                                                           */
                                                                   /* 00:     Motorola SPI frame format                                                                                       */
                                                                   /* 01..11: reserved                                                                                                        */
  unsigned int reserved3       : BFW_NX90_spi_cr0_reserved3;       /* reserved                                                                                                                */
  unsigned int filter_in       : BFW_NX90_spi_cr0_filter_in;       /* Receive data is sampled every 10ns (100MHz system clock). If this bit is set, the                                       */
                                                                   /* stored receive value will be the result of a majority decision of the three sampling points                             */
                                                                   /* around a SPI-clock edge (if two or more '1s! were sampled a '1' will be stored, else a '0' will                         */
                                                                   /* be stored. In slave mode chip-select and SCK edges will also be detected by oversampling if this bit is set:            */
                                                                   /* An edge will be detected if the majority-result of 3 subsequent sampled values toggles.                                 */
                                                                   /* Input filtering should be used for sck_muladd<=0x200 (i.e. below 12.5MHz). Stable signal phases are too                 */
                                                                   /* short with higher frequencies and input filtering cannot be used.                                                       */
  unsigned int slave_sig_early : BFW_NX90_spi_cr0_slave_sig_early; /* Generate MISO in slave mode 1 SCK clock edge earlier than defined in the SPI specification.                             */
                                                                   /* This is to compensate pad or sampling delays on fast data rates. However, hold timing problems could                    */
                                                                   /* come up as MISO is generated very fast after the sampling SPI clock edge.                                               */
                                                                   /* If filter_in is enabled, it takes at least 3 system clocks to generate MISO after SCK.                                  */
                                                                   /* If filter_in is disabled, it takes at least 2 system clocks to generate MISO after SCK.                                 */
  unsigned int reserved4       : BFW_NX90_spi_cr0_reserved4;       /* reserved                                                                                                                */
  unsigned int netx100_comp    : BFW_NX90_spi_cr0_netx100_comp;    /* Use netx100/500-compatible SPI mode:                                                                                    */
                                                                   /* 0: start transfer after writing data                                                                                    */
                                                                   /* 1: start transfer after setting CR_write or CR_read                                                                     */
} NX90_SPI_CR0_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SPI_CR0_BIT_T bf;
} NX90_SPI_CR0_T;

/* --------------------------------------------------------------------- */
/* Register spi_cr1 */
/* => SPI control register 1 */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_cr1          0x00000004U
#define Adr_NX90_spi0_app_spi_cr1     0xFF801A04U
#define Adr_NX90_spi1_app_spi_cr1     0xFF801A44U
#define Adr_NX90_spi2_app_spi_cr1     0xFF801A84U
#define Adr_NX90_spi_xpic_app_spi_cr1 0xFF900384U
#define DFLT_VAL_NX90_spi_cr1         0x08080000U

#define MSK_NX90_spi_cr1_LBM                 0x00000001U
#define SRT_NX90_spi_cr1_LBM                 0
#define DFLT_VAL_NX90_spi_cr1_LBM            0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_LBM         0x00000000U
#define MSK_NX90_spi_cr1_SSE                 0x00000002U
#define SRT_NX90_spi_cr1_SSE                 1
#define DFLT_VAL_NX90_spi_cr1_SSE            0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_SSE         0x00000000U
#define MSK_NX90_spi_cr1_MS                  0x00000004U
#define SRT_NX90_spi_cr1_MS                  2
#define DFLT_VAL_NX90_spi_cr1_MS             0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_MS          0x00000000U
#define MSK_NX90_spi_cr1_SOD                 0x00000008U
#define SRT_NX90_spi_cr1_SOD                 3
#define DFLT_VAL_NX90_spi_cr1_SOD            0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_SOD         0x00000000U
#define MSK_NX90_spi_cr1_fss                 0x00000700U
#define SRT_NX90_spi_cr1_fss                 8
#define DFLT_VAL_NX90_spi_cr1_fss            0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_fss         0x00000000U
#define MSK_NX90_spi_cr1_fss_static          0x00000800U
#define SRT_NX90_spi_cr1_fss_static          11
#define DFLT_VAL_NX90_spi_cr1_fss_static     0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_fss_static  0x00000000U
#define MSK_NX90_spi_cr1_tx_fifo_wm          0x000f0000U
#define SRT_NX90_spi_cr1_tx_fifo_wm          16
#define DFLT_VAL_NX90_spi_cr1_tx_fifo_wm     0x00080000U
#define DFLT_BF_VAL_NX90_spi_cr1_tx_fifo_wm  0x00000008U
#define MSK_NX90_spi_cr1_tx_fifo_clr         0x00100000U
#define SRT_NX90_spi_cr1_tx_fifo_clr         20
#define DFLT_VAL_NX90_spi_cr1_tx_fifo_clr    0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_tx_fifo_clr 0x00000000U
#define MSK_NX90_spi_cr1_rx_fifo_wm          0x0f000000U
#define SRT_NX90_spi_cr1_rx_fifo_wm          24
#define DFLT_VAL_NX90_spi_cr1_rx_fifo_wm     0x08000000U
#define DFLT_BF_VAL_NX90_spi_cr1_rx_fifo_wm  0x00000008U
#define MSK_NX90_spi_cr1_rx_fifo_clr         0x10000000U
#define SRT_NX90_spi_cr1_rx_fifo_clr         28
#define DFLT_VAL_NX90_spi_cr1_rx_fifo_clr    0x00000000U
#define DFLT_BF_VAL_NX90_spi_cr1_rx_fifo_clr 0x00000000U

/* all used bits of 'NX90_spi_cr1': */
#define MSK_USED_BITS_NX90_spi_cr1 0x1f1f0f0fU

enum {
  BFW_NX90_spi_cr1_LBM         = 1, /* [0] */
  BFW_NX90_spi_cr1_SSE         = 1, /* [1] */
  BFW_NX90_spi_cr1_MS          = 1, /* [2] */
  BFW_NX90_spi_cr1_SOD         = 1, /* [3] */
  BFW_NX90_spi_cr1_reserved1   = 4, /* [7:4] */
  BFW_NX90_spi_cr1_fss         = 3, /* [10:8] */
  BFW_NX90_spi_cr1_fss_static  = 1, /* [11] */
  BFW_NX90_spi_cr1_reserved2   = 4, /* [15:12] */
  BFW_NX90_spi_cr1_tx_fifo_wm  = 4, /* [19:16] */
  BFW_NX90_spi_cr1_tx_fifo_clr = 1, /* [20] */
  BFW_NX90_spi_cr1_reserved3   = 3, /* [23:21] */
  BFW_NX90_spi_cr1_rx_fifo_wm  = 4, /* [27:24] */
  BFW_NX90_spi_cr1_rx_fifo_clr = 1, /* [28] */
  BFW_NX90_spi_cr1_reserved4   = 3  /* [31:29] */
};

typedef struct NX90_SPI_CR1_BIT_Ttag {
  unsigned int LBM         : BFW_NX90_spi_cr1_LBM;         /* Loop back mode:                                                                                         */
                                                           /* 0: Internal loop back disabled                                                                          */
                                                           /* 1: Internal loop back enabled, spi_cr0.filter_in must be set for loopback function                      */
  unsigned int SSE         : BFW_NX90_spi_cr1_SSE;         /* SPI enable:                                                                                             */
                                                           /* 0: Module disabled                                                                                      */
                                                           /* 1: Module enabled                                                                                       */
  unsigned int MS          : BFW_NX90_spi_cr1_MS;          /* Mode select:                                                                                            */
                                                           /* 0: Module is configured as master                                                                       */
                                                           /* 1: Module is configured as slave                                                                        */
  unsigned int SOD         : BFW_NX90_spi_cr1_SOD;         /* Slave mode output disable (to connect multiple slaves to one master):                                   */
                                                           /* 0: MISO can be driven in slave mode                                                                     */
                                                           /* 1: MISO is not driven in slave mode                                                                     */
  unsigned int reserved1   : BFW_NX90_spi_cr1_reserved1;   /* reserved                                                                                                */
  unsigned int fss         : BFW_NX90_spi_cr1_fss;         /* Frame or slave select.                                                                                  */
                                                           /* There are up to 3 external SPI chip-select signals.                                                     */
                                                           /* In master mode, the fss bits define the states of the chip-select signals.                              */
                                                           /* The inversion for low-active chip-selects (e.g. for Motorola SPI frame format) is done automatically    */
                                                           /* depending on the value programmed to the 'format' bits.                                                 */
                                                           /* Example: To use the netX IO CS1 as chip-select, program '010' here, regardless whether the external     */
                                                           /* chip-select is low or high active.                                                                      */
                                                           /* In slave mode, the fss bits are a mask to select which netX input should be used as chip-select.        */
                                                           /* Example: To use the netX IO CS0 as chip-select, program '001' here.                                     */
  unsigned int fss_static  : BFW_NX90_spi_cr1_fss_static;  /* SPI static chip-select:                                                                                 */
                                                           /* {  |                                                                                                    */
                                                           /* 0: SPI chip-select will be toggled automatically before and after each transferred word                 */
                                                           /*     according to fss and datasize.                                                                      */
                                                           /* 1: SPI chip-select will be set statically according to the fss bits. }                                  */
  unsigned int reserved2   : BFW_NX90_spi_cr1_reserved2;   /* reserved                                                                                                */
  unsigned int tx_fifo_wm  : BFW_NX90_spi_cr1_tx_fifo_wm;  /* Transmit FIFO watermark for IRQ generation                                                              */
  unsigned int tx_fifo_clr : BFW_NX90_spi_cr1_tx_fifo_clr; /* Writing "1" to this bit will clear the transmit FIFOs.                                                  */
                                                           /* Note: There must be at least 1 system clock idle after clear before writing new data to the             */
                                                           /* FIFO. This is guaranteed by the netX internal bus structure and needs not being considered by software. */
  unsigned int reserved3   : BFW_NX90_spi_cr1_reserved3;   /* reserved                                                                                                */
  unsigned int rx_fifo_wm  : BFW_NX90_spi_cr1_rx_fifo_wm;  /* Receive FIFO watermark for IRQ generation                                                               */
  unsigned int rx_fifo_clr : BFW_NX90_spi_cr1_rx_fifo_clr; /* Writing "1" to this bit will clear the receive FIFOs.                                                   */
  unsigned int reserved4   : BFW_NX90_spi_cr1_reserved4;   /* reserved                                                                                                */
} NX90_SPI_CR1_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SPI_CR1_BIT_T bf;
} NX90_SPI_CR1_T;

/* --------------------------------------------------------------------- */
/* Register spi_dr */
/* => SPI data register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/*    The SPI module has 2 FIFOs: One for transmit data and one for receive data. */
/*    Read access: Received data byte is delivered from receive FIFO. */
/*    Write access: Transmit data byte is written to send FIFO. */
/*    Both FIFOs (receive and transmit) have a depth of 16. */
/*    SPI master mode: MISO input data will be stored in the receive FIFO; transmit FIFO generates MOSI output data. */
/*    SPI slave mode: MOSI input data will be stored in the receive FIFO; transmit FIFO generates MISO output data. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_dr          0x00000008U
#define Adr_NX90_spi0_app_spi_dr     0xFF801A08U
#define Adr_NX90_spi1_app_spi_dr     0xFF801A48U
#define Adr_NX90_spi2_app_spi_dr     0xFF801A88U
#define Adr_NX90_spi_xpic_app_spi_dr 0xFF900388U
#define DFLT_VAL_NX90_spi_dr         0x00000000U

#define MSK_NX90_spi_dr_data         0x0001ffffU
#define SRT_NX90_spi_dr_data         0
#define DFLT_VAL_NX90_spi_dr_data    0x00000000U
#define DFLT_BF_VAL_NX90_spi_dr_data 0x00000000U

/* all used bits of 'NX90_spi_dr': */
#define MSK_USED_BITS_NX90_spi_dr 0x0001ffffU

enum {
  BFW_NX90_spi_dr_data      = 17, /* [16:0] */
  BFW_NX90_spi_dr_reserved1 = 15  /* [31:17] */
};

typedef struct NX90_SPI_DR_BIT_Ttag {
  unsigned int data      : BFW_NX90_spi_dr_data;      /* Transmit data: Only lowest bits according to spi_cr0.datasize will be sent.                             */
                                                      /* Receive data will be delivered on the lowest bits, unused bits (above spi_cr0.datasize) will be "0".    */
                                                      /* In slave mode transmit data is requested from the FIFO when the last bit of the currently               */
                                                      /* transferred word is set to the MISO signal.                                                             */
                                                      /* If no next transmit data can be read from the FIFO until the current word's last bit was transferred, a */
                                                      /* FIFO underrun will occur in case chip-select does not go inactive at the next detected SCK edge.        */
  unsigned int reserved1 : BFW_NX90_spi_dr_reserved1; /* reserved                                                                                                */
} NX90_SPI_DR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_SPI_DR_BIT_T bf;
} NX90_SPI_DR_T;

/* --------------------------------------------------------------------- */
/* Register spi_sr */
/* => SPI status register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/*    Note: Both FIFOs (receive and transmit) have a depth of 16. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_sr          0x0000000CU
#define Adr_NX90_spi0_app_spi_sr     0xFF801A0CU
#define Adr_NX90_spi1_app_spi_sr     0xFF801A4CU
#define Adr_NX90_spi2_app_spi_sr     0xFF801A8CU
#define Adr_NX90_spi_xpic_app_spi_sr 0xFF90038CU

#define MSK_NX90_spi_sr_TFE              0x00000001U
#define SRT_NX90_spi_sr_TFE              0
#define MSK_NX90_spi_sr_TNF              0x00000002U
#define SRT_NX90_spi_sr_TNF              1
#define MSK_NX90_spi_sr_RNE              0x00000004U
#define SRT_NX90_spi_sr_RNE              2
#define MSK_NX90_spi_sr_RFF              0x00000008U
#define SRT_NX90_spi_sr_RFF              3
#define MSK_NX90_spi_sr_BSY              0x00000010U
#define SRT_NX90_spi_sr_BSY              4
#define MSK_NX90_spi_sr_tx_fifo_level    0x001f0000U
#define SRT_NX90_spi_sr_tx_fifo_level    16
#define MSK_NX90_spi_sr_tx_fifo_err_ovfl 0x00400000U
#define SRT_NX90_spi_sr_tx_fifo_err_ovfl 22
#define MSK_NX90_spi_sr_tx_fifo_err_undr 0x00800000U
#define SRT_NX90_spi_sr_tx_fifo_err_undr 23
#define MSK_NX90_spi_sr_rx_fifo_level    0x1f000000U
#define SRT_NX90_spi_sr_rx_fifo_level    24
#define MSK_NX90_spi_sr_rx_fifo_err_ovfl 0x40000000U
#define SRT_NX90_spi_sr_rx_fifo_err_ovfl 30
#define MSK_NX90_spi_sr_rx_fifo_err_undr 0x80000000U
#define SRT_NX90_spi_sr_rx_fifo_err_undr 31

/* all used bits of 'NX90_spi_sr': */
#define MSK_USED_BITS_NX90_spi_sr 0xdfdf001fU

enum {
  BFW_NX90_spi_sr_TFE              = 1,  /* [0] */
  BFW_NX90_spi_sr_TNF              = 1,  /* [1] */
  BFW_NX90_spi_sr_RNE              = 1,  /* [2] */
  BFW_NX90_spi_sr_RFF              = 1,  /* [3] */
  BFW_NX90_spi_sr_BSY              = 1,  /* [4] */
  BFW_NX90_spi_sr_reserved1        = 11, /* [15:5] */
  BFW_NX90_spi_sr_tx_fifo_level    = 5,  /* [20:16] */
  BFW_NX90_spi_sr_reserved2        = 1,  /* [21] */
  BFW_NX90_spi_sr_tx_fifo_err_ovfl = 1,  /* [22] */
  BFW_NX90_spi_sr_tx_fifo_err_undr = 1,  /* [23] */
  BFW_NX90_spi_sr_rx_fifo_level    = 5,  /* [28:24] */
  BFW_NX90_spi_sr_reserved3        = 1,  /* [29] */
  BFW_NX90_spi_sr_rx_fifo_err_ovfl = 1,  /* [30] */
  BFW_NX90_spi_sr_rx_fifo_err_undr = 1   /* [31] */
};

typedef struct NX90_SPI_SR_BIT_Ttag {
  unsigned int TFE              : BFW_NX90_spi_sr_TFE;              /* Transmit FIFO is empty (1 if empty)                                                         */
  unsigned int TNF              : BFW_NX90_spi_sr_TNF;              /* Transmit FIFO is not full (0 if full)                                                       */
  unsigned int RNE              : BFW_NX90_spi_sr_RNE;              /* Receive FIFO is not empty (0 if empty)                                                      */
  unsigned int RFF              : BFW_NX90_spi_sr_RFF;              /* Receive FIFO is full (1 if full)                                                            */
  unsigned int BSY              : BFW_NX90_spi_sr_BSY;              /* Device busy (1 if data is currently transmitted/received or the transmit FIFO is not empty) */
  unsigned int reserved1        : BFW_NX90_spi_sr_reserved1;        /* reserved                                                                                    */
  unsigned int tx_fifo_level    : BFW_NX90_spi_sr_tx_fifo_level;    /* Transmit FIFO level (number of words to transmit are left in FIFO)                          */
  unsigned int reserved2        : BFW_NX90_spi_sr_reserved2;        /* reserved                                                                                    */
  unsigned int tx_fifo_err_ovfl : BFW_NX90_spi_sr_tx_fifo_err_ovfl; /* Transmit FIFO overflow error occurred, data is lost                                         */
  unsigned int tx_fifo_err_undr : BFW_NX90_spi_sr_tx_fifo_err_undr; /* Transmit FIFO underrun error occurred, data is lost                                         */
  unsigned int rx_fifo_level    : BFW_NX90_spi_sr_rx_fifo_level;    /* Receive FIFO level (number of received words to read out are left in FIFO)                  */
  unsigned int reserved3        : BFW_NX90_spi_sr_reserved3;        /* reserved                                                                                    */
  unsigned int rx_fifo_err_ovfl : BFW_NX90_spi_sr_rx_fifo_err_ovfl; /* Receive FIFO overflow error occurred, data is lost                                          */
  unsigned int rx_fifo_err_undr : BFW_NX90_spi_sr_rx_fifo_err_undr; /* Receive FIFO underrun error occurred, data is lost                                          */
} NX90_SPI_SR_BIT_T;

typedef union {
  uint32_t          val;
  NX90_SPI_SR_BIT_T bf;
} NX90_SPI_SR_T;

/* --------------------------------------------------------------------- */
/* Register spi_imsc */
/* => SPI Interrupt Mask Set and Clear register: */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/*    IRQ mask is an AND-mask: only raw interrupts with mask bit set can generate a module IRQ. */
/*    When writing this register, the corresponding interrupt is cleared similar to writing the register spi_icr. */
/*     */
/*    Note: The functionality of this register is similar to the corresponding SQI register sqi_irq_mask. */
/*          However, in contrast to this register, setting bits in sqi_irq_mask does not clear the corresponding interrupts. */
/*     */
/*    Note: Both FIFOs (receive and transmit) have a depth of 16. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_imsc          0x00000014U
#define Adr_NX90_spi0_app_spi_imsc     0xFF801A14U
#define Adr_NX90_spi1_app_spi_imsc     0xFF801A54U
#define Adr_NX90_spi2_app_spi_imsc     0xFF801A94U
#define Adr_NX90_spi_xpic_app_spi_imsc 0xFF900394U
#define DFLT_VAL_NX90_spi_imsc         0x00000000U

#define MSK_NX90_spi_imsc_RORIM          0x00000001U
#define SRT_NX90_spi_imsc_RORIM          0
#define DFLT_VAL_NX90_spi_imsc_RORIM     0x00000000U
#define DFLT_BF_VAL_NX90_spi_imsc_RORIM  0x00000000U
#define MSK_NX90_spi_imsc_RTIM           0x00000002U
#define SRT_NX90_spi_imsc_RTIM           1
#define DFLT_VAL_NX90_spi_imsc_RTIM      0x00000000U
#define DFLT_BF_VAL_NX90_spi_imsc_RTIM   0x00000000U
#define MSK_NX90_spi_imsc_RXIM           0x00000004U
#define SRT_NX90_spi_imsc_RXIM           2
#define DFLT_VAL_NX90_spi_imsc_RXIM      0x00000000U
#define DFLT_BF_VAL_NX90_spi_imsc_RXIM   0x00000000U
#define MSK_NX90_spi_imsc_TXIM           0x00000008U
#define SRT_NX90_spi_imsc_TXIM           3
#define DFLT_VAL_NX90_spi_imsc_TXIM      0x00000000U
#define DFLT_BF_VAL_NX90_spi_imsc_TXIM   0x00000000U
#define MSK_NX90_spi_imsc_rxneim         0x00000010U
#define SRT_NX90_spi_imsc_rxneim         4
#define DFLT_VAL_NX90_spi_imsc_rxneim    0x00000000U
#define DFLT_BF_VAL_NX90_spi_imsc_rxneim 0x00000000U
#define MSK_NX90_spi_imsc_rxfim          0x00000020U
#define SRT_NX90_spi_imsc_rxfim          5
#define DFLT_VAL_NX90_spi_imsc_rxfim     0x00000000U
#define DFLT_BF_VAL_NX90_spi_imsc_rxfim  0x00000000U
#define MSK_NX90_spi_imsc_txeim          0x00000040U
#define SRT_NX90_spi_imsc_txeim          6
#define DFLT_VAL_NX90_spi_imsc_txeim     0x00000000U
#define DFLT_BF_VAL_NX90_spi_imsc_txeim  0x00000000U

/* all used bits of 'NX90_spi_imsc': */
#define MSK_USED_BITS_NX90_spi_imsc 0x0000007fU

enum {
  BFW_NX90_spi_imsc_RORIM     = 1,  /* [0] */
  BFW_NX90_spi_imsc_RTIM      = 1,  /* [1] */
  BFW_NX90_spi_imsc_RXIM      = 1,  /* [2] */
  BFW_NX90_spi_imsc_TXIM      = 1,  /* [3] */
  BFW_NX90_spi_imsc_rxneim    = 1,  /* [4] */
  BFW_NX90_spi_imsc_rxfim     = 1,  /* [5] */
  BFW_NX90_spi_imsc_txeim     = 1,  /* [6] */
  BFW_NX90_spi_imsc_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_SPI_IMSC_BIT_Ttag {
  unsigned int RORIM     : BFW_NX90_spi_imsc_RORIM;     /* Receive FIFO overrun interrupt mask                                */
  unsigned int RTIM      : BFW_NX90_spi_imsc_RTIM;      /* Receive timeout interrupt mask                                     */
  unsigned int RXIM      : BFW_NX90_spi_imsc_RXIM;      /* Receive FIFO interrupt mask                                        */
  unsigned int TXIM      : BFW_NX90_spi_imsc_TXIM;      /* Transmit FIFO interrupt mask                                       */
  unsigned int rxneim    : BFW_NX90_spi_imsc_rxneim;    /* Receive FIFO not empty interrupt mask (for netx100/500 compliance) */
  unsigned int rxfim     : BFW_NX90_spi_imsc_rxfim;     /* Receive FIFO full interrupt mask (for netx100/500 compliance)      */
  unsigned int txeim     : BFW_NX90_spi_imsc_txeim;     /* Transmit FIFO empty interrupt mask (for netx100/500 compliance)    */
  unsigned int reserved1 : BFW_NX90_spi_imsc_reserved1; /* reserved                                                           */
} NX90_SPI_IMSC_BIT_T;

typedef union {
  uint32_t            val;
  NX90_SPI_IMSC_BIT_T bf;
} NX90_SPI_IMSC_T;

/* --------------------------------------------------------------------- */
/* Register spi_ris */
/* => SPI interrupt state before masking register (raw interrupt) */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/*    Note: Both FIFOs (receive and transmit) have a depth of 16. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_ris          0x00000018U
#define Adr_NX90_spi0_app_spi_ris     0xFF801A18U
#define Adr_NX90_spi1_app_spi_ris     0xFF801A58U
#define Adr_NX90_spi2_app_spi_ris     0xFF801A98U
#define Adr_NX90_spi_xpic_app_spi_ris 0xFF900398U

#define MSK_NX90_spi_ris_RORRIS  0x00000001U
#define SRT_NX90_spi_ris_RORRIS  0
#define MSK_NX90_spi_ris_RTRIS   0x00000002U
#define SRT_NX90_spi_ris_RTRIS   1
#define MSK_NX90_spi_ris_RXRIS   0x00000004U
#define SRT_NX90_spi_ris_RXRIS   2
#define MSK_NX90_spi_ris_TXRIS   0x00000008U
#define SRT_NX90_spi_ris_TXRIS   3
#define MSK_NX90_spi_ris_rxneris 0x00000010U
#define SRT_NX90_spi_ris_rxneris 4
#define MSK_NX90_spi_ris_rxfris  0x00000020U
#define SRT_NX90_spi_ris_rxfris  5
#define MSK_NX90_spi_ris_txeris  0x00000040U
#define SRT_NX90_spi_ris_txeris  6

/* all used bits of 'NX90_spi_ris': */
#define MSK_USED_BITS_NX90_spi_ris 0x0000007fU

enum {
  BFW_NX90_spi_ris_RORRIS    = 1,  /* [0] */
  BFW_NX90_spi_ris_RTRIS     = 1,  /* [1] */
  BFW_NX90_spi_ris_RXRIS     = 1,  /* [2] */
  BFW_NX90_spi_ris_TXRIS     = 1,  /* [3] */
  BFW_NX90_spi_ris_rxneris   = 1,  /* [4] */
  BFW_NX90_spi_ris_rxfris    = 1,  /* [5] */
  BFW_NX90_spi_ris_txeris    = 1,  /* [6] */
  BFW_NX90_spi_ris_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_SPI_RIS_BIT_Ttag {
  unsigned int RORRIS    : BFW_NX90_spi_ris_RORRIS;    /* Unmasked receive FIFO overrun interrupt state                                */
                                                       /* 1: receive FIFO overrun error occurred                                       */
                                                       /* 0: no receive FIFO overrun error occurred                                    */
  unsigned int RTRIS     : BFW_NX90_spi_ris_RTRIS;     /* Unmasked receive timeout interrupt state                                     */
                                                       /* Timeout period are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd  */
                                                       /* 1: receive FIFO is not empty and not read out in the passed timeout period   */
                                                       /* 0: receive FIFO is empty or read during the last timeout period              */
  unsigned int RXRIS     : BFW_NX90_spi_ris_RXRIS;     /* Unmasked receive FIFO interrupt state                                        */
                                                       /* 1: receive FIFO is higher than spi_cr1.rx_fifo_wm                            */
                                                       /* 0: receive FIFO is equals or is below spi_cr1.rx_fifo_wm                     */
  unsigned int TXRIS     : BFW_NX90_spi_ris_TXRIS;     /* Unmasked transmit FIFO interrupt state                                       */
                                                       /* 1: transmit FIFO level is below spi_cr1.tx_fifo_wm                           */
                                                       /* 0: transmit FIFO equals or is higher than spi_cr1.tx_fifo_wm                 */
  unsigned int rxneris   : BFW_NX90_spi_ris_rxneris;   /* Unmasked receive FIFO not empty interrupt state (for netx100/500 compliance) */
                                                       /* 1: receive FIFO is not empty                                                 */
                                                       /* 0: receive FIFO is empty                                                     */
  unsigned int rxfris    : BFW_NX90_spi_ris_rxfris;    /* Unmasked receive FIFO full interrupt state (for netx100/500 compliance)      */
                                                       /* 1: receive FIFO is full                                                      */
                                                       /* 0: receive FIFO is not full                                                  */
  unsigned int txeris    : BFW_NX90_spi_ris_txeris;    /* Unmasked transmit FIFO empty interrupt state (for netx100/500 compliance)    */
                                                       /* 1: transmit FIFO is empty                                                    */
                                                       /* 0: transmit FIFO is not empty                                                */
  unsigned int reserved1 : BFW_NX90_spi_ris_reserved1; /* reserved                                                                     */
} NX90_SPI_RIS_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SPI_RIS_BIT_T bf;
} NX90_SPI_RIS_T;

/* --------------------------------------------------------------------- */
/* Register spi_mis */
/* => SPI interrupt status register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/*    Note: Both FIFOs (receive and transmit) have a depth of 16. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_mis          0x0000001CU
#define Adr_NX90_spi0_app_spi_mis     0xFF801A1CU
#define Adr_NX90_spi1_app_spi_mis     0xFF801A5CU
#define Adr_NX90_spi2_app_spi_mis     0xFF801A9CU
#define Adr_NX90_spi_xpic_app_spi_mis 0xFF90039CU

#define MSK_NX90_spi_mis_RORMIS  0x00000001U
#define SRT_NX90_spi_mis_RORMIS  0
#define MSK_NX90_spi_mis_RTMIS   0x00000002U
#define SRT_NX90_spi_mis_RTMIS   1
#define MSK_NX90_spi_mis_RXMIS   0x00000004U
#define SRT_NX90_spi_mis_RXMIS   2
#define MSK_NX90_spi_mis_TXMIS   0x00000008U
#define SRT_NX90_spi_mis_TXMIS   3
#define MSK_NX90_spi_mis_rxnemis 0x00000010U
#define SRT_NX90_spi_mis_rxnemis 4
#define MSK_NX90_spi_mis_rxfmis  0x00000020U
#define SRT_NX90_spi_mis_rxfmis  5
#define MSK_NX90_spi_mis_txemis  0x00000040U
#define SRT_NX90_spi_mis_txemis  6

/* all used bits of 'NX90_spi_mis': */
#define MSK_USED_BITS_NX90_spi_mis 0x0000007fU

enum {
  BFW_NX90_spi_mis_RORMIS    = 1,  /* [0] */
  BFW_NX90_spi_mis_RTMIS     = 1,  /* [1] */
  BFW_NX90_spi_mis_RXMIS     = 1,  /* [2] */
  BFW_NX90_spi_mis_TXMIS     = 1,  /* [3] */
  BFW_NX90_spi_mis_rxnemis   = 1,  /* [4] */
  BFW_NX90_spi_mis_rxfmis    = 1,  /* [5] */
  BFW_NX90_spi_mis_txemis    = 1,  /* [6] */
  BFW_NX90_spi_mis_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_SPI_MIS_BIT_Ttag {
  unsigned int RORMIS    : BFW_NX90_spi_mis_RORMIS;    /* Masked receive FIFO overrun interrupt state                                */
  unsigned int RTMIS     : BFW_NX90_spi_mis_RTMIS;     /* Masked receive timeout interrupt state                                     */
  unsigned int RXMIS     : BFW_NX90_spi_mis_RXMIS;     /* Masked receive FIFO interrupt state                                        */
  unsigned int TXMIS     : BFW_NX90_spi_mis_TXMIS;     /* Masked transmit FIFO interrupt state                                       */
  unsigned int rxnemis   : BFW_NX90_spi_mis_rxnemis;   /* Masked receive FIFO not empty interrupt state (for netx100/500 compliance) */
  unsigned int rxfmis    : BFW_NX90_spi_mis_rxfmis;    /* Masked receive FIFO full interrupt state (for netx100/500 compliance)      */
  unsigned int txemis    : BFW_NX90_spi_mis_txemis;    /* Masked transmit FIFO empty interrupt state (for netx100/500 compliance)    */
  unsigned int reserved1 : BFW_NX90_spi_mis_reserved1; /* reserved                                                                   */
} NX90_SPI_MIS_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SPI_MIS_BIT_T bf;
} NX90_SPI_MIS_T;

/* --------------------------------------------------------------------- */
/* Register spi_icr */
/* => SPI interrupt clear register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/*    An interrupt is cleared by writing "1" to the according bit. */
/*    Note: Both FIFOs (receive and transmit) have a depth of 16. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_icr          0x00000020U
#define Adr_NX90_spi0_app_spi_icr     0xFF801A20U
#define Adr_NX90_spi1_app_spi_icr     0xFF801A60U
#define Adr_NX90_spi2_app_spi_icr     0xFF801AA0U
#define Adr_NX90_spi_xpic_app_spi_icr 0xFF9003A0U
#define DFLT_VAL_NX90_spi_icr         0x00000000U

#define MSK_NX90_spi_icr_RORIC          0x00000001U
#define SRT_NX90_spi_icr_RORIC          0
#define DFLT_VAL_NX90_spi_icr_RORIC     0x00000000U
#define DFLT_BF_VAL_NX90_spi_icr_RORIC  0x00000000U
#define MSK_NX90_spi_icr_RTIC           0x00000002U
#define SRT_NX90_spi_icr_RTIC           1
#define DFLT_VAL_NX90_spi_icr_RTIC      0x00000000U
#define DFLT_BF_VAL_NX90_spi_icr_RTIC   0x00000000U
#define MSK_NX90_spi_icr_RXIC           0x00000004U
#define SRT_NX90_spi_icr_RXIC           2
#define DFLT_VAL_NX90_spi_icr_RXIC      0x00000000U
#define DFLT_BF_VAL_NX90_spi_icr_RXIC   0x00000000U
#define MSK_NX90_spi_icr_TXIC           0x00000008U
#define SRT_NX90_spi_icr_TXIC           3
#define DFLT_VAL_NX90_spi_icr_TXIC      0x00000000U
#define DFLT_BF_VAL_NX90_spi_icr_TXIC   0x00000000U
#define MSK_NX90_spi_icr_rxneic         0x00000010U
#define SRT_NX90_spi_icr_rxneic         4
#define DFLT_VAL_NX90_spi_icr_rxneic    0x00000000U
#define DFLT_BF_VAL_NX90_spi_icr_rxneic 0x00000000U
#define MSK_NX90_spi_icr_rxfic          0x00000020U
#define SRT_NX90_spi_icr_rxfic          5
#define DFLT_VAL_NX90_spi_icr_rxfic     0x00000000U
#define DFLT_BF_VAL_NX90_spi_icr_rxfic  0x00000000U
#define MSK_NX90_spi_icr_txeic          0x00000040U
#define SRT_NX90_spi_icr_txeic          6
#define DFLT_VAL_NX90_spi_icr_txeic     0x00000000U
#define DFLT_BF_VAL_NX90_spi_icr_txeic  0x00000000U

/* all used bits of 'NX90_spi_icr': */
#define MSK_USED_BITS_NX90_spi_icr 0x0000007fU

enum {
  BFW_NX90_spi_icr_RORIC     = 1,  /* [0] */
  BFW_NX90_spi_icr_RTIC      = 1,  /* [1] */
  BFW_NX90_spi_icr_RXIC      = 1,  /* [2] */
  BFW_NX90_spi_icr_TXIC      = 1,  /* [3] */
  BFW_NX90_spi_icr_rxneic    = 1,  /* [4] */
  BFW_NX90_spi_icr_rxfic     = 1,  /* [5] */
  BFW_NX90_spi_icr_txeic     = 1,  /* [6] */
  BFW_NX90_spi_icr_reserved1 = 25  /* [31:7] */
};

typedef struct NX90_SPI_ICR_BIT_Ttag {
  unsigned int RORIC     : BFW_NX90_spi_icr_RORIC;     /* Clear receive FIFO overrun interrupt                                */
                                                       /* Writing '1' here will clear the receive FIFO                        */
  unsigned int RTIC      : BFW_NX90_spi_icr_RTIC;      /* Clear receive FIFO overrun interrupt                                */
  unsigned int RXIC      : BFW_NX90_spi_icr_RXIC;      /* PL022 extension: clear receive FIFO interrupt                       */
  unsigned int TXIC      : BFW_NX90_spi_icr_TXIC;      /* PL022 extension: clear transmit FIFO interrupt                      */
  unsigned int rxneic    : BFW_NX90_spi_icr_rxneic;    /* Clear receive FIFO not empty interrupt (for netx100/500 compliance) */
  unsigned int rxfic     : BFW_NX90_spi_icr_rxfic;     /* Clear receive FIFO full interrupt (for netx100/500 compliance)      */
  unsigned int txeic     : BFW_NX90_spi_icr_txeic;     /* Clear transmit FIFO empty interrupt (for netx100/500 compliance)    */
  unsigned int reserved1 : BFW_NX90_spi_icr_reserved1; /* reserved                                                            */
} NX90_SPI_ICR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_SPI_ICR_BIT_T bf;
} NX90_SPI_ICR_T;

/* --------------------------------------------------------------------- */
/* Register spi_dmacr */
/* => SPI DMA control register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_dmacr          0x00000028U
#define Adr_NX90_spi0_app_spi_dmacr     0xFF801A28U
#define Adr_NX90_spi1_app_spi_dmacr     0xFF801A68U
#define Adr_NX90_spi2_app_spi_dmacr     0xFF801AA8U
#define Adr_NX90_spi_xpic_app_spi_dmacr 0xFF9003A8U
#define DFLT_VAL_NX90_spi_dmacr         0x00000000U

#define MSK_NX90_spi_dmacr_RXDMAE         0x00000001U
#define SRT_NX90_spi_dmacr_RXDMAE         0
#define DFLT_VAL_NX90_spi_dmacr_RXDMAE    0x00000000U
#define DFLT_BF_VAL_NX90_spi_dmacr_RXDMAE 0x00000000U
#define MSK_NX90_spi_dmacr_TXDMAE         0x00000002U
#define SRT_NX90_spi_dmacr_TXDMAE         1
#define DFLT_VAL_NX90_spi_dmacr_TXDMAE    0x00000000U
#define DFLT_BF_VAL_NX90_spi_dmacr_TXDMAE 0x00000000U

/* all used bits of 'NX90_spi_dmacr': */
#define MSK_USED_BITS_NX90_spi_dmacr 0x00000003U

enum {
  BFW_NX90_spi_dmacr_RXDMAE    = 1,  /* [0] */
  BFW_NX90_spi_dmacr_TXDMAE    = 1,  /* [1] */
  BFW_NX90_spi_dmacr_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_SPI_DMACR_BIT_Ttag {
  unsigned int RXDMAE    : BFW_NX90_spi_dmacr_RXDMAE;    /* Enable DMA for SPI receive data.                                                            */
                                                         /* A single request will be generated if the receive FIFO is not empty and spi_cr1.SSE (module */
                                                         /* enable) is set. Burst request to the DMA controller will be generated if the receive FIFO   */
                                                         /* contains at least 4 words (set DMA burst size to 4).                                        */
                                                         /* If this bit is reset or the module is disabled, the DMA request signals will also be reset. */
                                                         /* Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller.                */
  unsigned int TXDMAE    : BFW_NX90_spi_dmacr_TXDMAE;    /* Enable DMA for SPI transmit data.                                                           */
                                                         /* A single request will be generated if the transmit FIFO is not full and spi_cr1.SSE (module */
                                                         /* enable) is set. Burst requests to the DMA controller will be generated if at least 4 words  */
                                                         /* are writable to the transmit FIFO (set DMA burst size to 4).                                */
                                                         /* If this bit is reset or the module is disabled, the DMA request signals will also be reset. */
                                                         /* Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller.                */
  unsigned int reserved1 : BFW_NX90_spi_dmacr_reserved1; /* reserved                                                                                    */
} NX90_SPI_DMACR_BIT_T;

typedef union {
  uint32_t             val;
  NX90_SPI_DMACR_BIT_T bf;
} NX90_SPI_DMACR_T;

/* --------------------------------------------------------------------- */
/* Register spi_data_register */
/* => netx100/500 compliant SPI data register (DR) */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. */
/*    2 data bytes with valid bits. */
/*    During a write access data_byte_1 and dr_valid1 must not be used. dr_valid0 must be set. */
/*    In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software */
/*    compatible, not more than 8 bytes should be in netx100/500 FIFOs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_data_register          0x00000030U
#define Adr_NX90_spi0_app_spi_data_register     0xFF801A30U
#define Adr_NX90_spi1_app_spi_data_register     0xFF801A70U
#define Adr_NX90_spi2_app_spi_data_register     0xFF801AB0U
#define Adr_NX90_spi_xpic_app_spi_data_register 0xFF9003B0U
#define DFLT_VAL_NX90_spi_data_register         0x00000000U

#define MSK_NX90_spi_data_register_data_byte_0         0x000000ffU
#define SRT_NX90_spi_data_register_data_byte_0         0
#define DFLT_VAL_NX90_spi_data_register_data_byte_0    0x00000000U
#define DFLT_BF_VAL_NX90_spi_data_register_data_byte_0 0x00000000U
#define MSK_NX90_spi_data_register_data_byte_1         0x0000ff00U
#define SRT_NX90_spi_data_register_data_byte_1         8
#define DFLT_VAL_NX90_spi_data_register_data_byte_1    0x00000000U
#define DFLT_BF_VAL_NX90_spi_data_register_data_byte_1 0x00000000U
#define MSK_NX90_spi_data_register_dr_valid0           0x00010000U
#define SRT_NX90_spi_data_register_dr_valid0           16
#define DFLT_VAL_NX90_spi_data_register_dr_valid0      0x00000000U
#define DFLT_BF_VAL_NX90_spi_data_register_dr_valid0   0x00000000U
#define MSK_NX90_spi_data_register_dr_valid1           0x00020000U
#define SRT_NX90_spi_data_register_dr_valid1           17
#define DFLT_VAL_NX90_spi_data_register_dr_valid1      0x00000000U
#define DFLT_BF_VAL_NX90_spi_data_register_dr_valid1   0x00000000U

/* all used bits of 'NX90_spi_data_register': */
#define MSK_USED_BITS_NX90_spi_data_register 0x0003ffffU

enum {
  BFW_NX90_spi_data_register_data_byte_0 = 8,  /* [7:0] */
  BFW_NX90_spi_data_register_data_byte_1 = 8,  /* [15:8] */
  BFW_NX90_spi_data_register_dr_valid0   = 1,  /* [16] */
  BFW_NX90_spi_data_register_dr_valid1   = 1,  /* [17] */
  BFW_NX90_spi_data_register_reserved1   = 14  /* [31:18] */
};

typedef struct NX90_SPI_DATA_REGISTER_BIT_Ttag {
  unsigned int data_byte_0 : BFW_NX90_spi_data_register_data_byte_0; /* Data byte 0                                                                        */
  unsigned int data_byte_1 : BFW_NX90_spi_data_register_data_byte_1; /* Obsolete, don't use                                                                */
  unsigned int dr_valid0   : BFW_NX90_spi_data_register_dr_valid0;   /* Valid bit for data_byte_0                                                          */
                                                                     /* This bit shows if data_byte_0 is valid and must be set during a FIFO write access. */
  unsigned int dr_valid1   : BFW_NX90_spi_data_register_dr_valid1;   /* Obsolete, always 0                                                                 */
  unsigned int reserved1   : BFW_NX90_spi_data_register_reserved1;   /* reserved                                                                           */
} NX90_SPI_DATA_REGISTER_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_SPI_DATA_REGISTER_BIT_T bf;
} NX90_SPI_DATA_REGISTER_T;

/* --------------------------------------------------------------------- */
/* Register spi_status_register */
/* => netx100/500 compliant SPI status register (SR): */
/*    Shows the actual status of the SPI interface. */
/*    Bits 24..18 show occurred interrupts; writing ones into these bits clears the interrupts. */
/*    Writing into other bits has no effect. */
/*    In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software */
/*    compatible, not more than 8 bytes should be in netx100/500 FIFOs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_status_register          0x00000034U
#define Adr_NX90_spi0_app_spi_status_register     0xFF801A34U
#define Adr_NX90_spi1_app_spi_status_register     0xFF801A74U
#define Adr_NX90_spi2_app_spi_status_register     0xFF801AB4U
#define Adr_NX90_spi_xpic_app_spi_status_register 0xFF9003B4U

#define MSK_NX90_spi_status_register_SR_in_fuel_val  0x000001ffU
#define SRT_NX90_spi_status_register_SR_in_fuel_val  0
#define MSK_NX90_spi_status_register_SR_out_fuel_val 0x0003fe00U
#define SRT_NX90_spi_status_register_SR_out_fuel_val 9
#define MSK_NX90_spi_status_register_SR_in_fuel      0x00040000U
#define SRT_NX90_spi_status_register_SR_in_fuel      18
#define MSK_NX90_spi_status_register_SR_in_recdata   0x00080000U
#define SRT_NX90_spi_status_register_SR_in_recdata   19
#define MSK_NX90_spi_status_register_SR_in_full      0x00100000U
#define SRT_NX90_spi_status_register_SR_in_full      20
#define MSK_NX90_spi_status_register_SR_out_fuel     0x00200000U
#define SRT_NX90_spi_status_register_SR_out_fuel     21
#define MSK_NX90_spi_status_register_SR_out_fw       0x00400000U
#define SRT_NX90_spi_status_register_SR_out_fw       22
#define MSK_NX90_spi_status_register_SR_out_empty    0x00800000U
#define SRT_NX90_spi_status_register_SR_out_empty    23
#define MSK_NX90_spi_status_register_SR_out_full     0x01000000U
#define SRT_NX90_spi_status_register_SR_out_full     24
#define MSK_NX90_spi_status_register_SR_selected     0x02000000U
#define SRT_NX90_spi_status_register_SR_selected     25

/* all used bits of 'NX90_spi_status_register': */
#define MSK_USED_BITS_NX90_spi_status_register 0x03ffffffU

enum {
  BFW_NX90_spi_status_register_SR_in_fuel_val  = 9, /* [8:0] */
  BFW_NX90_spi_status_register_SR_out_fuel_val = 9, /* [17:9] */
  BFW_NX90_spi_status_register_SR_in_fuel      = 1, /* [18] */
  BFW_NX90_spi_status_register_SR_in_recdata   = 1, /* [19] */
  BFW_NX90_spi_status_register_SR_in_full      = 1, /* [20] */
  BFW_NX90_spi_status_register_SR_out_fuel     = 1, /* [21] */
  BFW_NX90_spi_status_register_SR_out_fw       = 1, /* [22] */
  BFW_NX90_spi_status_register_SR_out_empty    = 1, /* [23] */
  BFW_NX90_spi_status_register_SR_out_full     = 1, /* [24] */
  BFW_NX90_spi_status_register_SR_selected     = 1, /* [25] */
  BFW_NX90_spi_status_register_reserved1       = 6  /* [31:26] */
};

typedef struct NX90_SPI_STATUS_REGISTER_BIT_Ttag {
  unsigned int SR_in_fuel_val  : BFW_NX90_spi_status_register_SR_in_fuel_val;  /* Input FIFO fill value (number of bytes)                                                          */
  unsigned int SR_out_fuel_val : BFW_NX90_spi_status_register_SR_out_fuel_val; /* Output FIFO fill value (number of bytes)                                                         */
  unsigned int SR_in_fuel      : BFW_NX90_spi_status_register_SR_in_fuel;      /* Adjustable fill value of input FIFO reached (equals spi_ris.RXRIS in netx50 and later versions)  */
  unsigned int SR_in_recdata   : BFW_NX90_spi_status_register_SR_in_recdata;   /* Valid data bytes in input FIFO (equals spi_ris.rxneris in netx50 and later versions)             */
  unsigned int SR_in_full      : BFW_NX90_spi_status_register_SR_in_full;      /* Input FIFO is full (equals spi_ris.rxfris in netx50 and later versions)                          */
  unsigned int SR_out_fuel     : BFW_NX90_spi_status_register_SR_out_fuel;     /* Adjustable fill value of output FIFO reached (equals spi_ris.TXRIS in netx50 and later versions) */
  unsigned int SR_out_fw       : BFW_NX90_spi_status_register_SR_out_fw;       /* netX is writing data too fast into output FIFO. Available as an IRQ only on netx100/500          */
                                                                               /* (equals spi_sr.tx_fifo_err_ovfl in netx50 and later versions).                                   */
  unsigned int SR_out_empty    : BFW_NX90_spi_status_register_SR_out_empty;    /* Output FIFO is empty in slave mode (equals spi_ris.txeris in netx50 and later versions)          */
  unsigned int SR_out_full     : BFW_NX90_spi_status_register_SR_out_full;     /* Output FIFO is full. This is only with netx100/500 an IRQ.                                       */
  unsigned int SR_selected     : BFW_NX90_spi_status_register_SR_selected;     /* External master has access to SPI interface                                                      */
  unsigned int reserved1       : BFW_NX90_spi_status_register_reserved1;       /* reserved                                                                                         */
} NX90_SPI_STATUS_REGISTER_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_SPI_STATUS_REGISTER_BIT_T bf;
} NX90_SPI_STATUS_REGISTER_T;

/* --------------------------------------------------------------------- */
/* Register spi_control_register */
/* => netx100/500 compliant SPI control register (CR) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_control_register          0x00000038U
#define Adr_NX90_spi0_app_spi_control_register     0xFF801A38U
#define Adr_NX90_spi1_app_spi_control_register     0xFF801A78U
#define Adr_NX90_spi2_app_spi_control_register     0xFF801AB8U
#define Adr_NX90_spi_xpic_app_spi_control_register 0xFF9003B8U
#define DFLT_VAL_NX90_spi_control_register         0x00000000U

#define MSK_NX90_spi_control_register_CR_softreset           0x00000001U
#define SRT_NX90_spi_control_register_CR_softreset           0
#define DFLT_VAL_NX90_spi_control_register_CR_softreset      0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_softreset   0x00000000U
#define MSK_NX90_spi_control_register_CR_speed               0x0000001eU
#define SRT_NX90_spi_control_register_CR_speed               1
#define DFLT_VAL_NX90_spi_control_register_CR_speed          0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_speed       0x00000000U
#define MSK_NX90_spi_control_register_CR_read                0x00000040U
#define SRT_NX90_spi_control_register_CR_read                6
#define DFLT_VAL_NX90_spi_control_register_CR_read           0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_read        0x00000000U
#define MSK_NX90_spi_control_register_CR_write               0x00000080U
#define SRT_NX90_spi_control_register_CR_write               7
#define DFLT_VAL_NX90_spi_control_register_CR_write          0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_write       0x00000000U
#define MSK_NX90_spi_control_register_CR_ss                  0x00000700U
#define SRT_NX90_spi_control_register_CR_ss                  8
#define DFLT_VAL_NX90_spi_control_register_CR_ss             0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_ss          0x00000000U
#define MSK_NX90_spi_control_register_CS_mode                0x00000800U
#define SRT_NX90_spi_control_register_CS_mode                11
#define DFLT_VAL_NX90_spi_control_register_CS_mode           0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CS_mode        0x00000000U
#define MSK_NX90_spi_control_register_CR_clr_infifo          0x00100000U
#define SRT_NX90_spi_control_register_CR_clr_infifo          20
#define DFLT_VAL_NX90_spi_control_register_CR_clr_infifo     0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_clr_infifo  0x00000000U
#define MSK_NX90_spi_control_register_CR_clr_outfifo         0x00200000U
#define SRT_NX90_spi_control_register_CR_clr_outfifo         21
#define DFLT_VAL_NX90_spi_control_register_CR_clr_outfifo    0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_clr_outfifo 0x00000000U
#define MSK_NX90_spi_control_register_CR_burstdelay          0x01c00000U
#define SRT_NX90_spi_control_register_CR_burstdelay          22
#define DFLT_VAL_NX90_spi_control_register_CR_burstdelay     0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_burstdelay  0x00000000U
#define MSK_NX90_spi_control_register_CR_burst               0x0e000000U
#define SRT_NX90_spi_control_register_CR_burst               25
#define DFLT_VAL_NX90_spi_control_register_CR_burst          0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_burst       0x00000000U
#define MSK_NX90_spi_control_register_CR_ncpha               0x10000000U
#define SRT_NX90_spi_control_register_CR_ncpha               28
#define DFLT_VAL_NX90_spi_control_register_CR_ncpha          0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_ncpha       0x00000000U
#define MSK_NX90_spi_control_register_CR_cpol                0x20000000U
#define SRT_NX90_spi_control_register_CR_cpol                29
#define DFLT_VAL_NX90_spi_control_register_CR_cpol           0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_cpol        0x00000000U
#define MSK_NX90_spi_control_register_CR_ms                  0x40000000U
#define SRT_NX90_spi_control_register_CR_ms                  30
#define DFLT_VAL_NX90_spi_control_register_CR_ms             0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_ms          0x00000000U
#define MSK_NX90_spi_control_register_CR_en                  0x80000000U
#define SRT_NX90_spi_control_register_CR_en                  31
#define DFLT_VAL_NX90_spi_control_register_CR_en             0x00000000U
#define DFLT_BF_VAL_NX90_spi_control_register_CR_en          0x00000000U

/* all used bits of 'NX90_spi_control_register': */
#define MSK_USED_BITS_NX90_spi_control_register 0xfff00fdfU

enum {
  BFW_NX90_spi_control_register_CR_softreset   = 1, /* [0] */
  BFW_NX90_spi_control_register_CR_speed       = 4, /* [4:1] */
  BFW_NX90_spi_control_register_reserved1      = 1, /* [5] */
  BFW_NX90_spi_control_register_CR_read        = 1, /* [6] */
  BFW_NX90_spi_control_register_CR_write       = 1, /* [7] */
  BFW_NX90_spi_control_register_CR_ss          = 3, /* [10:8] */
  BFW_NX90_spi_control_register_CS_mode        = 1, /* [11] */
  BFW_NX90_spi_control_register_reserved2      = 8, /* [19:12] */
  BFW_NX90_spi_control_register_CR_clr_infifo  = 1, /* [20] */
  BFW_NX90_spi_control_register_CR_clr_outfifo = 1, /* [21] */
  BFW_NX90_spi_control_register_CR_burstdelay  = 3, /* [24:22] */
  BFW_NX90_spi_control_register_CR_burst       = 3, /* [27:25] */
  BFW_NX90_spi_control_register_CR_ncpha       = 1, /* [28] */
  BFW_NX90_spi_control_register_CR_cpol        = 1, /* [29] */
  BFW_NX90_spi_control_register_CR_ms          = 1, /* [30] */
  BFW_NX90_spi_control_register_CR_en          = 1  /* [31] */
};

typedef struct NX90_SPI_CONTROL_REGISTER_BIT_Ttag {
  unsigned int CR_softreset   : BFW_NX90_spi_control_register_CR_softreset;   /* write only: no function in netx100/netx500; later versions: clears IRQs and FIFOs                          */
  unsigned int CR_speed       : BFW_NX90_spi_control_register_CR_speed;       /* Clock divider for SPI clock (2 - 2^16)                                                                     */
                                                                              /* If SPI clock rate is changed using spi_cr0.sck_muladd, this value will not be updated and may be incorrect */
                                                                              /* There are 16 different SPI clocks frequencies to choose:                                                   */
                                                                              /* 0000: 0.025 MHz (Note: Not compatible to netx100/500. "0000" freezes SCK in netx100/500.)                  */
                                                                              /* 0001: 0.05 MHz                                                                                             */
                                                                              /* 0010: 0.1 MHz                                                                                              */
                                                                              /* 0011: 0.2 MHz                                                                                              */
                                                                              /* 0100: 0.5 MHz                                                                                              */
                                                                              /* 0101: 1 MHz                                                                                                */
                                                                              /* 0110: 1.25 MHz                                                                                             */
                                                                              /* 0111: 2 MHz                                                                                                */
                                                                              /* 1000: 2.5 MHz                                                                                              */
                                                                              /* 1001: 3.3333 MHz                                                                                           */
                                                                              /* 1010: 5 MHz                                                                                                */
                                                                              /* 1011: 10 MHz                                                                                               */
                                                                              /* 1100: 12.5 MHz                                                                                             */
                                                                              /* 1101: 16.6666 MHz                                                                                          */
                                                                              /* 1110: 25 MHz                                                                                               */
                                                                              /* 1111: 50 MHz                                                                                               */
  unsigned int reserved1      : BFW_NX90_spi_control_register_reserved1;      /* reserved                                                                                                   */
  unsigned int CR_read        : BFW_NX90_spi_control_register_CR_read;        /* netx100/netx500 only, in later versions always "1":  1: enable SPI interface read data                     */
  unsigned int CR_write       : BFW_NX90_spi_control_register_CR_write;       /* netx100/netx500 only, in later versions always "1":  1: enable SPI interface write data                    */
  unsigned int CR_ss          : BFW_NX90_spi_control_register_CR_ss;          /* External slave select                                                                                      */
  unsigned int CS_mode        : BFW_NX90_spi_control_register_CS_mode;        /* 1: chip select is generated automatically by the internal state machine                                    */
                                                                              /* 0: chip select is directly controlled by software (see bits CR_ss).                                        */
  unsigned int reserved2      : BFW_NX90_spi_control_register_reserved2;      /* reserved                                                                                                   */
  unsigned int CR_clr_infifo  : BFW_NX90_spi_control_register_CR_clr_infifo;  /* Clear input FIFO                                                                                           */
  unsigned int CR_clr_outfifo : BFW_NX90_spi_control_register_CR_clr_outfifo; /* Clear output FIFO                                                                                          */
  unsigned int CR_burstdelay  : BFW_NX90_spi_control_register_CR_burstdelay;  /* netx100/netx500 only, obsolete in later versions: delay between transmission of 2 data bytes               */
                                                                              /* (0 to 7 SCK cycles)                                                                                        */
  unsigned int CR_burst       : BFW_NX90_spi_control_register_CR_burst;       /* netx100/netx500 only, obsolete in later versions: burst length = 2^CR_burst                                */
  unsigned int CR_ncpha       : BFW_NX90_spi_control_register_CR_ncpha;       /* SPI clock phase mode (Note: meaning of this bit is inverted to functionality of bit spi_cr0.SPH):          */
                                                                              /* {  |                                                                                                       */
                                                                              /* 0: change data on secondary SCK edge                                                                       */
                                                                              /*     data is active on primary SCK edge                                                                     */
                                                                              /* 1: change data on primary SCK edge                                                                         */
                                                                              /*     data is active on secondary SCK edge }                                                                 */
  unsigned int CR_cpol        : BFW_NX90_spi_control_register_CR_cpol;        /* 1: falling edge of SCK is primary                                                                          */
                                                                              /* 0: rising edge of SCK is primary                                                                           */
  unsigned int CR_ms          : BFW_NX90_spi_control_register_CR_ms;          /* 1: master mode                                                                                             */
                                                                              /* 0:slave mode                                                                                               */
  unsigned int CR_en          : BFW_NX90_spi_control_register_CR_en;          /* 1: enable                                                                                                  */
                                                                              /* 0: disable SPI interface                                                                                   */
} NX90_SPI_CONTROL_REGISTER_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_SPI_CONTROL_REGISTER_BIT_T bf;
} NX90_SPI_CONTROL_REGISTER_T;

/* --------------------------------------------------------------------- */
/* Register spi_interrupt_control_register */
/* => netx100/500 compliant SPI interrupt control register (IR) */
/*    In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software */
/*    compatible, not more than 8 bytes should be in netx100/500 FIFOs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_spi_interrupt_control_register          0x0000003CU
#define Adr_NX90_spi0_app_spi_interrupt_control_register     0xFF801A3CU
#define Adr_NX90_spi1_app_spi_interrupt_control_register     0xFF801A7CU
#define Adr_NX90_spi2_app_spi_interrupt_control_register     0xFF801ABCU
#define Adr_NX90_spi_xpic_app_spi_interrupt_control_register 0xFF9003BCU
#define DFLT_VAL_NX90_spi_interrupt_control_register         0x00000000U

#define MSK_NX90_spi_interrupt_control_register_IR_in_fuel               0x000001ffU
#define SRT_NX90_spi_interrupt_control_register_IR_in_fuel               0
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_in_fuel          0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_in_fuel       0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_out_fuel              0x0003fe00U
#define SRT_NX90_spi_interrupt_control_register_IR_out_fuel              9
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_out_fuel         0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_out_fuel      0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_in_fuel_en            0x00040000U
#define SRT_NX90_spi_interrupt_control_register_IR_in_fuel_en            18
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_in_fuel_en       0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_in_fuel_en    0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_in_recdata_en         0x00080000U
#define SRT_NX90_spi_interrupt_control_register_IR_in_recdata_en         19
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_in_recdata_en    0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_in_recdata_en 0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_in_full_en            0x00100000U
#define SRT_NX90_spi_interrupt_control_register_IR_in_full_en            20
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_in_full_en       0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_in_full_en    0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_out_fuel_en           0x00200000U
#define SRT_NX90_spi_interrupt_control_register_IR_out_fuel_en           21
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_out_fuel_en      0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_out_fuel_en   0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_out_fw_en             0x00400000U
#define SRT_NX90_spi_interrupt_control_register_IR_out_fw_en             22
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_out_fw_en        0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_out_fw_en     0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_out_empty_en          0x00800000U
#define SRT_NX90_spi_interrupt_control_register_IR_out_empty_en          23
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_out_empty_en     0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_out_empty_en  0x00000000U
#define MSK_NX90_spi_interrupt_control_register_IR_out_full_en           0x01000000U
#define SRT_NX90_spi_interrupt_control_register_IR_out_full_en           24
#define DFLT_VAL_NX90_spi_interrupt_control_register_IR_out_full_en      0x00000000U
#define DFLT_BF_VAL_NX90_spi_interrupt_control_register_IR_out_full_en   0x00000000U

/* all used bits of 'NX90_spi_interrupt_control_register': */
#define MSK_USED_BITS_NX90_spi_interrupt_control_register 0x01ffffffU

enum {
  BFW_NX90_spi_interrupt_control_register_IR_in_fuel       = 9, /* [8:0] */
  BFW_NX90_spi_interrupt_control_register_IR_out_fuel      = 9, /* [17:9] */
  BFW_NX90_spi_interrupt_control_register_IR_in_fuel_en    = 1, /* [18] */
  BFW_NX90_spi_interrupt_control_register_IR_in_recdata_en = 1, /* [19] */
  BFW_NX90_spi_interrupt_control_register_IR_in_full_en    = 1, /* [20] */
  BFW_NX90_spi_interrupt_control_register_IR_out_fuel_en   = 1, /* [21] */
  BFW_NX90_spi_interrupt_control_register_IR_out_fw_en     = 1, /* [22] */
  BFW_NX90_spi_interrupt_control_register_IR_out_empty_en  = 1, /* [23] */
  BFW_NX90_spi_interrupt_control_register_IR_out_full_en   = 1, /* [24] */
  BFW_NX90_spi_interrupt_control_register_reserved1        = 7  /* [31:25] */
};

typedef struct NX90_SPI_INTERRUPT_CONTROL_REGISTER_BIT_Ttag {
  unsigned int IR_in_fuel       : BFW_NX90_spi_interrupt_control_register_IR_in_fuel;       /* Adjustable watermark level of input FIFO                                         */
  unsigned int IR_out_fuel      : BFW_NX90_spi_interrupt_control_register_IR_out_fuel;      /* Adjustable watermark level of output FIFO                                        */
  unsigned int IR_in_fuel_en    : BFW_NX90_spi_interrupt_control_register_IR_in_fuel_en;    /* IRQ enable for irq_spi(0)  (equals spi_imsc.RXIM in netx50 and later versions)   */
  unsigned int IR_in_recdata_en : BFW_NX90_spi_interrupt_control_register_IR_in_recdata_en; /* IRQ enable for irq_spi(1)  (equals spi_imsc.txneim in netx50 and later versions) */
  unsigned int IR_in_full_en    : BFW_NX90_spi_interrupt_control_register_IR_in_full_en;    /* IRQ enable for irq_spi(2)  (equals spi_imsc.txfim in netx50 and later versions)  */
  unsigned int IR_out_fuel_en   : BFW_NX90_spi_interrupt_control_register_IR_out_fuel_en;   /* IRQ enable for irq_spi(3)  (equals spi_imsc.TXIM in netx50 and later versions)   */
  unsigned int IR_out_fw_en     : BFW_NX90_spi_interrupt_control_register_IR_out_fw_en;     /* IRQ enable for irq_spi(4), netx100/netx500 only, always "0" in later versions    */
  unsigned int IR_out_empty_en  : BFW_NX90_spi_interrupt_control_register_IR_out_empty_en;  /* IRQ enable for irq_spi(5)  (equals spi_imsc.rxeim in netx50 and later versions)  */
  unsigned int IR_out_full_en   : BFW_NX90_spi_interrupt_control_register_IR_out_full_en;   /* IRQ enable for irq_spi(6), netx100/netx500 only, always "0" in later versions    */
  unsigned int reserved1        : BFW_NX90_spi_interrupt_control_register_reserved1;        /* reserved                                                                         */
} NX90_SPI_INTERRUPT_CONTROL_REGISTER_BIT_T;

typedef union {
  uint32_t                                  val;
  NX90_SPI_INTERRUPT_CONTROL_REGISTER_BIT_T bf;
} NX90_SPI_INTERRUPT_CONTROL_REGISTER_T;


/* ===================================================================== */

/* AREA pio */
/* Area of pio_app */

/* ===================================================================== */

#define Addr_NX90_pio_app 0xFF801AC0U

/* --------------------------------------------------------------------- */
/* Register pio_in */
/* => PIO input line status register. */
/*    Each PIO input status can also be read from dedicated PIOx input state register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pio_in     0x00000000U
#define Adr_NX90_pio_app_pio_in 0xFF801AC0U
#define Adr_NX90_pio_in         0xFF801AC0U

#define MSK_NX90_pio_in_val 0x000000ffU
#define SRT_NX90_pio_in_val 0

/* all used bits of 'NX90_pio_in': */
#define MSK_USED_BITS_NX90_pio_in 0x000000ffU

enum {
  BFW_NX90_pio_in_val       = 8,  /* [7:0] */
  BFW_NX90_pio_in_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_PIO_IN_BIT_Ttag {
  unsigned int val       : BFW_NX90_pio_in_val;       /* PIO input states (LSB: PIO0). */
  unsigned int reserved1 : BFW_NX90_pio_in_reserved1; /* reserved                      */
} NX90_PIO_IN_BIT_T;

typedef union {
  uint32_t          val;
  NX90_PIO_IN_BIT_T bf;
} NX90_PIO_IN_T;

/* --------------------------------------------------------------------- */
/* Register pio_out */
/* => PIO output drive level line register. */
/*    Each PIOs output drive level can also be programmed by dedicated PIOx output drive level register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pio_out     0x00000004U
#define Adr_NX90_pio_app_pio_out 0xFF801AC4U
#define Adr_NX90_pio_out         0xFF801AC4U
#define DFLT_VAL_NX90_pio_out    0x00000000U

#define MSK_NX90_pio_out_val         0x000000ffU
#define SRT_NX90_pio_out_val         0
#define DFLT_VAL_NX90_pio_out_val    0x00000000U
#define DFLT_BF_VAL_NX90_pio_out_val 0x00000000U

/* all used bits of 'NX90_pio_out': */
#define MSK_USED_BITS_NX90_pio_out 0x000000ffU

enum {
  BFW_NX90_pio_out_val       = 8,  /* [7:0] */
  BFW_NX90_pio_out_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_PIO_OUT_BIT_Ttag {
  unsigned int val       : BFW_NX90_pio_out_val;       /* PIO output drive levels (LSB: PIO0). */
  unsigned int reserved1 : BFW_NX90_pio_out_reserved1; /* reserved                             */
} NX90_PIO_OUT_BIT_T;

typedef union {
  uint32_t           val;
  NX90_PIO_OUT_BIT_T bf;
} NX90_PIO_OUT_T;

/* --------------------------------------------------------------------- */
/* Register pio_oe */
/* => PIO output enable line register. */
/*    Each PIOs output enable can also be programmed by dedicated PIOx output enable register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_pio_oe     0x00000008U
#define Adr_NX90_pio_app_pio_oe 0xFF801AC8U
#define Adr_NX90_pio_oe         0xFF801AC8U
#define DFLT_VAL_NX90_pio_oe    0x00000000U

#define MSK_NX90_pio_oe_val         0x000000ffU
#define SRT_NX90_pio_oe_val         0
#define DFLT_VAL_NX90_pio_oe_val    0x00000000U
#define DFLT_BF_VAL_NX90_pio_oe_val 0x00000000U

/* all used bits of 'NX90_pio_oe': */
#define MSK_USED_BITS_NX90_pio_oe 0x000000ffU

enum {
  BFW_NX90_pio_oe_val       = 8,  /* [7:0] */
  BFW_NX90_pio_oe_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_PIO_OE_BIT_Ttag {
  unsigned int val       : BFW_NX90_pio_oe_val;       /* PIO output enables (LSB: PIO0). */
  unsigned int reserved1 : BFW_NX90_pio_oe_reserved1; /* reserved                        */
} NX90_PIO_OE_BIT_T;

typedef union {
  uint32_t          val;
  NX90_PIO_OE_BIT_T bf;
} NX90_PIO_OE_T;


/* ===================================================================== */

/* AREA biss */
/* Area of biss0_app, biss1_app */

/* ===================================================================== */

#define Addr_NX90_biss0_app 0xFF801B00U
#define Addr_NX90_biss1_app 0xFF801C00U

/* --------------------------------------------------------------------- */
/* Register biss_scdata0_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata0_0       0x00000000U
#define Adr_NX90_biss0_app_biss_scdata0_0 0xFF801B00U
#define Adr_NX90_biss1_app_biss_scdata0_0 0xFF801C00U
#define DFLT_VAL_NX90_biss_scdata0_0      0x00000000U

#define MSK_NX90_biss_scdata0_0_SCDATA0_0         0xffffffffU
#define SRT_NX90_biss_scdata0_0_SCDATA0_0         0
#define DFLT_VAL_NX90_biss_scdata0_0_SCDATA0_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata0_0_SCDATA0_0 0x00000000U

/* all used bits of 'NX90_biss_scdata0_0': */
#define MSK_USED_BITS_NX90_biss_scdata0_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata0_0_SCDATA0_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA0_0_BIT_Ttag {
  unsigned int SCDATA0_0 : BFW_NX90_biss_scdata0_0_SCDATA0_0; /* Slave0 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA0_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA0_0_BIT_T bf;
} NX90_BISS_SCDATA0_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata0_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata0_1       0x00000004U
#define Adr_NX90_biss0_app_biss_scdata0_1 0xFF801B04U
#define Adr_NX90_biss1_app_biss_scdata0_1 0xFF801C04U
#define DFLT_VAL_NX90_biss_scdata0_1      0x00000000U

#define MSK_NX90_biss_scdata0_1_SCDATA0_1         0xffffffffU
#define SRT_NX90_biss_scdata0_1_SCDATA0_1         0
#define DFLT_VAL_NX90_biss_scdata0_1_SCDATA0_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata0_1_SCDATA0_1 0x00000000U

/* all used bits of 'NX90_biss_scdata0_1': */
#define MSK_USED_BITS_NX90_biss_scdata0_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata0_1_SCDATA0_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA0_1_BIT_Ttag {
  unsigned int SCDATA0_1 : BFW_NX90_biss_scdata0_1_SCDATA0_1; /* Slave0 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA0_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA0_1_BIT_T bf;
} NX90_BISS_SCDATA0_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata1_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata1_0       0x00000008U
#define Adr_NX90_biss0_app_biss_scdata1_0 0xFF801B08U
#define Adr_NX90_biss1_app_biss_scdata1_0 0xFF801C08U
#define DFLT_VAL_NX90_biss_scdata1_0      0x00000000U

#define MSK_NX90_biss_scdata1_0_SCDATA1_0         0xffffffffU
#define SRT_NX90_biss_scdata1_0_SCDATA1_0         0
#define DFLT_VAL_NX90_biss_scdata1_0_SCDATA1_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata1_0_SCDATA1_0 0x00000000U

/* all used bits of 'NX90_biss_scdata1_0': */
#define MSK_USED_BITS_NX90_biss_scdata1_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata1_0_SCDATA1_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA1_0_BIT_Ttag {
  unsigned int SCDATA1_0 : BFW_NX90_biss_scdata1_0_SCDATA1_0; /* Slave1 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA1_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA1_0_BIT_T bf;
} NX90_BISS_SCDATA1_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata1_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata1_1       0x0000000CU
#define Adr_NX90_biss0_app_biss_scdata1_1 0xFF801B0CU
#define Adr_NX90_biss1_app_biss_scdata1_1 0xFF801C0CU
#define DFLT_VAL_NX90_biss_scdata1_1      0x00000000U

#define MSK_NX90_biss_scdata1_1_SCDATA1_1         0xffffffffU
#define SRT_NX90_biss_scdata1_1_SCDATA1_1         0
#define DFLT_VAL_NX90_biss_scdata1_1_SCDATA1_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata1_1_SCDATA1_1 0x00000000U

/* all used bits of 'NX90_biss_scdata1_1': */
#define MSK_USED_BITS_NX90_biss_scdata1_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata1_1_SCDATA1_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA1_1_BIT_Ttag {
  unsigned int SCDATA1_1 : BFW_NX90_biss_scdata1_1_SCDATA1_1; /* Slave1 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA1_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA1_1_BIT_T bf;
} NX90_BISS_SCDATA1_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata2_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata2_0       0x00000010U
#define Adr_NX90_biss0_app_biss_scdata2_0 0xFF801B10U
#define Adr_NX90_biss1_app_biss_scdata2_0 0xFF801C10U
#define DFLT_VAL_NX90_biss_scdata2_0      0x00000000U

#define MSK_NX90_biss_scdata2_0_SCDATA2_0         0xffffffffU
#define SRT_NX90_biss_scdata2_0_SCDATA2_0         0
#define DFLT_VAL_NX90_biss_scdata2_0_SCDATA2_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata2_0_SCDATA2_0 0x00000000U

/* all used bits of 'NX90_biss_scdata2_0': */
#define MSK_USED_BITS_NX90_biss_scdata2_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata2_0_SCDATA2_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA2_0_BIT_Ttag {
  unsigned int SCDATA2_0 : BFW_NX90_biss_scdata2_0_SCDATA2_0; /* Slave2 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA2_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA2_0_BIT_T bf;
} NX90_BISS_SCDATA2_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata2_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata2_1       0x00000014U
#define Adr_NX90_biss0_app_biss_scdata2_1 0xFF801B14U
#define Adr_NX90_biss1_app_biss_scdata2_1 0xFF801C14U
#define DFLT_VAL_NX90_biss_scdata2_1      0x00000000U

#define MSK_NX90_biss_scdata2_1_SCDATA2_1         0xffffffffU
#define SRT_NX90_biss_scdata2_1_SCDATA2_1         0
#define DFLT_VAL_NX90_biss_scdata2_1_SCDATA2_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata2_1_SCDATA2_1 0x00000000U

/* all used bits of 'NX90_biss_scdata2_1': */
#define MSK_USED_BITS_NX90_biss_scdata2_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata2_1_SCDATA2_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA2_1_BIT_Ttag {
  unsigned int SCDATA2_1 : BFW_NX90_biss_scdata2_1_SCDATA2_1; /* Slave2 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA2_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA2_1_BIT_T bf;
} NX90_BISS_SCDATA2_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata3_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata3_0       0x00000018U
#define Adr_NX90_biss0_app_biss_scdata3_0 0xFF801B18U
#define Adr_NX90_biss1_app_biss_scdata3_0 0xFF801C18U
#define DFLT_VAL_NX90_biss_scdata3_0      0x00000000U

#define MSK_NX90_biss_scdata3_0_SCDATA3_0         0xffffffffU
#define SRT_NX90_biss_scdata3_0_SCDATA3_0         0
#define DFLT_VAL_NX90_biss_scdata3_0_SCDATA3_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata3_0_SCDATA3_0 0x00000000U

/* all used bits of 'NX90_biss_scdata3_0': */
#define MSK_USED_BITS_NX90_biss_scdata3_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata3_0_SCDATA3_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA3_0_BIT_Ttag {
  unsigned int SCDATA3_0 : BFW_NX90_biss_scdata3_0_SCDATA3_0; /* Slave3 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA3_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA3_0_BIT_T bf;
} NX90_BISS_SCDATA3_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata3_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata3_1       0x0000001CU
#define Adr_NX90_biss0_app_biss_scdata3_1 0xFF801B1CU
#define Adr_NX90_biss1_app_biss_scdata3_1 0xFF801C1CU
#define DFLT_VAL_NX90_biss_scdata3_1      0x00000000U

#define MSK_NX90_biss_scdata3_1_SCDATA3_1         0xffffffffU
#define SRT_NX90_biss_scdata3_1_SCDATA3_1         0
#define DFLT_VAL_NX90_biss_scdata3_1_SCDATA3_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata3_1_SCDATA3_1 0x00000000U

/* all used bits of 'NX90_biss_scdata3_1': */
#define MSK_USED_BITS_NX90_biss_scdata3_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata3_1_SCDATA3_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA3_1_BIT_Ttag {
  unsigned int SCDATA3_1 : BFW_NX90_biss_scdata3_1_SCDATA3_1; /* Slave3 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA3_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA3_1_BIT_T bf;
} NX90_BISS_SCDATA3_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata4_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata4_0       0x00000020U
#define Adr_NX90_biss0_app_biss_scdata4_0 0xFF801B20U
#define Adr_NX90_biss1_app_biss_scdata4_0 0xFF801C20U
#define DFLT_VAL_NX90_biss_scdata4_0      0x00000000U

#define MSK_NX90_biss_scdata4_0_SCDATA4_0         0xffffffffU
#define SRT_NX90_biss_scdata4_0_SCDATA4_0         0
#define DFLT_VAL_NX90_biss_scdata4_0_SCDATA4_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata4_0_SCDATA4_0 0x00000000U

/* all used bits of 'NX90_biss_scdata4_0': */
#define MSK_USED_BITS_NX90_biss_scdata4_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata4_0_SCDATA4_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA4_0_BIT_Ttag {
  unsigned int SCDATA4_0 : BFW_NX90_biss_scdata4_0_SCDATA4_0; /* Slave4 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA4_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA4_0_BIT_T bf;
} NX90_BISS_SCDATA4_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata4_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata4_1       0x00000024U
#define Adr_NX90_biss0_app_biss_scdata4_1 0xFF801B24U
#define Adr_NX90_biss1_app_biss_scdata4_1 0xFF801C24U
#define DFLT_VAL_NX90_biss_scdata4_1      0x00000000U

#define MSK_NX90_biss_scdata4_1_SCDATA4_1         0xffffffffU
#define SRT_NX90_biss_scdata4_1_SCDATA4_1         0
#define DFLT_VAL_NX90_biss_scdata4_1_SCDATA4_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata4_1_SCDATA4_1 0x00000000U

/* all used bits of 'NX90_biss_scdata4_1': */
#define MSK_USED_BITS_NX90_biss_scdata4_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata4_1_SCDATA4_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA4_1_BIT_Ttag {
  unsigned int SCDATA4_1 : BFW_NX90_biss_scdata4_1_SCDATA4_1; /* Slave4 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA4_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA4_1_BIT_T bf;
} NX90_BISS_SCDATA4_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata5_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata5_0       0x00000028U
#define Adr_NX90_biss0_app_biss_scdata5_0 0xFF801B28U
#define Adr_NX90_biss1_app_biss_scdata5_0 0xFF801C28U
#define DFLT_VAL_NX90_biss_scdata5_0      0x00000000U

#define MSK_NX90_biss_scdata5_0_SCDATA5_0         0xffffffffU
#define SRT_NX90_biss_scdata5_0_SCDATA5_0         0
#define DFLT_VAL_NX90_biss_scdata5_0_SCDATA5_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata5_0_SCDATA5_0 0x00000000U

/* all used bits of 'NX90_biss_scdata5_0': */
#define MSK_USED_BITS_NX90_biss_scdata5_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata5_0_SCDATA5_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA5_0_BIT_Ttag {
  unsigned int SCDATA5_0 : BFW_NX90_biss_scdata5_0_SCDATA5_0; /* Slave5 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA5_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA5_0_BIT_T bf;
} NX90_BISS_SCDATA5_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata5_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata5_1       0x0000002CU
#define Adr_NX90_biss0_app_biss_scdata5_1 0xFF801B2CU
#define Adr_NX90_biss1_app_biss_scdata5_1 0xFF801C2CU
#define DFLT_VAL_NX90_biss_scdata5_1      0x00000000U

#define MSK_NX90_biss_scdata5_1_SCDATA5_1         0xffffffffU
#define SRT_NX90_biss_scdata5_1_SCDATA5_1         0
#define DFLT_VAL_NX90_biss_scdata5_1_SCDATA5_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata5_1_SCDATA5_1 0x00000000U

/* all used bits of 'NX90_biss_scdata5_1': */
#define MSK_USED_BITS_NX90_biss_scdata5_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata5_1_SCDATA5_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA5_1_BIT_Ttag {
  unsigned int SCDATA5_1 : BFW_NX90_biss_scdata5_1_SCDATA5_1; /* Slave5 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA5_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA5_1_BIT_T bf;
} NX90_BISS_SCDATA5_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata6_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata6_0       0x00000030U
#define Adr_NX90_biss0_app_biss_scdata6_0 0xFF801B30U
#define Adr_NX90_biss1_app_biss_scdata6_0 0xFF801C30U
#define DFLT_VAL_NX90_biss_scdata6_0      0x00000000U

#define MSK_NX90_biss_scdata6_0_SCDATA6_0         0xffffffffU
#define SRT_NX90_biss_scdata6_0_SCDATA6_0         0
#define DFLT_VAL_NX90_biss_scdata6_0_SCDATA6_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata6_0_SCDATA6_0 0x00000000U

/* all used bits of 'NX90_biss_scdata6_0': */
#define MSK_USED_BITS_NX90_biss_scdata6_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata6_0_SCDATA6_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA6_0_BIT_Ttag {
  unsigned int SCDATA6_0 : BFW_NX90_biss_scdata6_0_SCDATA6_0; /* Slave6 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA6_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA6_0_BIT_T bf;
} NX90_BISS_SCDATA6_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata6_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata6_1       0x00000034U
#define Adr_NX90_biss0_app_biss_scdata6_1 0xFF801B34U
#define Adr_NX90_biss1_app_biss_scdata6_1 0xFF801C34U
#define DFLT_VAL_NX90_biss_scdata6_1      0x00000000U

#define MSK_NX90_biss_scdata6_1_SCDATA6_1         0xffffffffU
#define SRT_NX90_biss_scdata6_1_SCDATA6_1         0
#define DFLT_VAL_NX90_biss_scdata6_1_SCDATA6_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata6_1_SCDATA6_1 0x00000000U

/* all used bits of 'NX90_biss_scdata6_1': */
#define MSK_USED_BITS_NX90_biss_scdata6_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata6_1_SCDATA6_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA6_1_BIT_Ttag {
  unsigned int SCDATA6_1 : BFW_NX90_biss_scdata6_1_SCDATA6_1; /* Slave6 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA6_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA6_1_BIT_T bf;
} NX90_BISS_SCDATA6_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata7_0 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata7_0       0x00000038U
#define Adr_NX90_biss0_app_biss_scdata7_0 0xFF801B38U
#define Adr_NX90_biss1_app_biss_scdata7_0 0xFF801C38U
#define DFLT_VAL_NX90_biss_scdata7_0      0x00000000U

#define MSK_NX90_biss_scdata7_0_SCDATA7_0         0xffffffffU
#define SRT_NX90_biss_scdata7_0_SCDATA7_0         0
#define DFLT_VAL_NX90_biss_scdata7_0_SCDATA7_0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata7_0_SCDATA7_0 0x00000000U

/* all used bits of 'NX90_biss_scdata7_0': */
#define MSK_USED_BITS_NX90_biss_scdata7_0 0xffffffffU

enum {
  BFW_NX90_biss_scdata7_0_SCDATA7_0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA7_0_BIT_Ttag {
  unsigned int SCDATA7_0 : BFW_NX90_biss_scdata7_0_SCDATA7_0; /* Slave0 (SCD)single cycle data[31:0] */
} NX90_BISS_SCDATA7_0_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA7_0_BIT_T bf;
} NX90_BISS_SCDATA7_0_T;

/* --------------------------------------------------------------------- */
/* Register biss_scdata7_1 */
/* => Sensor and Actuator Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_scdata7_1       0x0000003CU
#define Adr_NX90_biss0_app_biss_scdata7_1 0xFF801B3CU
#define Adr_NX90_biss1_app_biss_scdata7_1 0xFF801C3CU
#define DFLT_VAL_NX90_biss_scdata7_1      0x00000000U

#define MSK_NX90_biss_scdata7_1_SCDATA7_1         0xffffffffU
#define SRT_NX90_biss_scdata7_1_SCDATA7_1         0
#define DFLT_VAL_NX90_biss_scdata7_1_SCDATA7_1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_scdata7_1_SCDATA7_1 0x00000000U

/* all used bits of 'NX90_biss_scdata7_1': */
#define MSK_USED_BITS_NX90_biss_scdata7_1 0xffffffffU

enum {
  BFW_NX90_biss_scdata7_1_SCDATA7_1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_SCDATA7_1_BIT_Ttag {
  unsigned int SCDATA7_1 : BFW_NX90_biss_scdata7_1_SCDATA7_1; /* Slave7 (SCD)single cycle data[63:32] */
} NX90_BISS_SCDATA7_1_BIT_T;

typedef union {
  uint32_t                  val;
  NX90_BISS_SCDATA7_1_BIT_T bf;
} NX90_BISS_SCDATA7_1_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata0 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata0       0x00000080U
#define Adr_NX90_biss0_app_biss_rdata0 0xFF801B80U
#define Adr_NX90_biss1_app_biss_rdata0 0xFF801C80U
#define DFLT_VAL_NX90_biss_rdata0      0x00000000U

#define MSK_NX90_biss_rdata0_RDATA0         0xffffffffU
#define SRT_NX90_biss_rdata0_RDATA0         0
#define DFLT_VAL_NX90_biss_rdata0_RDATA0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata0_RDATA0 0x00000000U

/* all used bits of 'NX90_biss_rdata0': */
#define MSK_USED_BITS_NX90_biss_rdata0 0xffffffffU

enum {
  BFW_NX90_biss_rdata0_RDATA0 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA0_BIT_Ttag {
  unsigned int RDATA0 : BFW_NX90_biss_rdata0_RDATA0; /* - Using register access in control communication            */
                                                     /*   RDATA0: register data DWord0                              */
                                                     /* - Using command/instructions in control communication       */
                                                     /*   IDS: ID-Select, command/instruction addressing combinable */
} NX90_BISS_RDATA0_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA0_BIT_T bf;
} NX90_BISS_RDATA0_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata1 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata1       0x00000084U
#define Adr_NX90_biss0_app_biss_rdata1 0xFF801B84U
#define Adr_NX90_biss1_app_biss_rdata1 0xFF801C84U
#define DFLT_VAL_NX90_biss_rdata1      0x00000000U

#define MSK_NX90_biss_rdata1_RDATA1         0xffffffffU
#define SRT_NX90_biss_rdata1_RDATA1         0
#define DFLT_VAL_NX90_biss_rdata1_RDATA1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata1_RDATA1 0x00000000U

/* all used bits of 'NX90_biss_rdata1': */
#define MSK_USED_BITS_NX90_biss_rdata1 0xffffffffU

enum {
  BFW_NX90_biss_rdata1_RDATA1 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA1_BIT_Ttag {
  unsigned int RDATA1 : BFW_NX90_biss_rdata1_RDATA1; /* register data DWord1 */
} NX90_BISS_RDATA1_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA1_BIT_T bf;
} NX90_BISS_RDATA1_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata2 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata2       0x00000088U
#define Adr_NX90_biss0_app_biss_rdata2 0xFF801B88U
#define Adr_NX90_biss1_app_biss_rdata2 0xFF801C88U
#define DFLT_VAL_NX90_biss_rdata2      0x00000000U

#define MSK_NX90_biss_rdata2_RDATA2         0xffffffffU
#define SRT_NX90_biss_rdata2_RDATA2         0
#define DFLT_VAL_NX90_biss_rdata2_RDATA2    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata2_RDATA2 0x00000000U

/* all used bits of 'NX90_biss_rdata2': */
#define MSK_USED_BITS_NX90_biss_rdata2 0xffffffffU

enum {
  BFW_NX90_biss_rdata2_RDATA2 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA2_BIT_Ttag {
  unsigned int RDATA2 : BFW_NX90_biss_rdata2_RDATA2; /* register data DWord2 */
} NX90_BISS_RDATA2_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA2_BIT_T bf;
} NX90_BISS_RDATA2_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata3 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata3       0x0000008CU
#define Adr_NX90_biss0_app_biss_rdata3 0xFF801B8CU
#define Adr_NX90_biss1_app_biss_rdata3 0xFF801C8CU
#define DFLT_VAL_NX90_biss_rdata3      0x00000000U

#define MSK_NX90_biss_rdata3_RDATA3         0xffffffffU
#define SRT_NX90_biss_rdata3_RDATA3         0
#define DFLT_VAL_NX90_biss_rdata3_RDATA3    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata3_RDATA3 0x00000000U

/* all used bits of 'NX90_biss_rdata3': */
#define MSK_USED_BITS_NX90_biss_rdata3 0xffffffffU

enum {
  BFW_NX90_biss_rdata3_RDATA3 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA3_BIT_Ttag {
  unsigned int RDATA3 : BFW_NX90_biss_rdata3_RDATA3; /* register data DWord3 */
} NX90_BISS_RDATA3_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA3_BIT_T bf;
} NX90_BISS_RDATA3_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata4 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata4       0x00000090U
#define Adr_NX90_biss0_app_biss_rdata4 0xFF801B90U
#define Adr_NX90_biss1_app_biss_rdata4 0xFF801C90U
#define DFLT_VAL_NX90_biss_rdata4      0x00000000U

#define MSK_NX90_biss_rdata4_RDATA4         0xffffffffU
#define SRT_NX90_biss_rdata4_RDATA4         0
#define DFLT_VAL_NX90_biss_rdata4_RDATA4    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata4_RDATA4 0x00000000U

/* all used bits of 'NX90_biss_rdata4': */
#define MSK_USED_BITS_NX90_biss_rdata4 0xffffffffU

enum {
  BFW_NX90_biss_rdata4_RDATA4 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA4_BIT_Ttag {
  unsigned int RDATA4 : BFW_NX90_biss_rdata4_RDATA4; /* register data DWord4 */
} NX90_BISS_RDATA4_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA4_BIT_T bf;
} NX90_BISS_RDATA4_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata5 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata5       0x00000094U
#define Adr_NX90_biss0_app_biss_rdata5 0xFF801B94U
#define Adr_NX90_biss1_app_biss_rdata5 0xFF801C94U
#define DFLT_VAL_NX90_biss_rdata5      0x00000000U

#define MSK_NX90_biss_rdata5_RDATA5         0xffffffffU
#define SRT_NX90_biss_rdata5_RDATA5         0
#define DFLT_VAL_NX90_biss_rdata5_RDATA5    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata5_RDATA5 0x00000000U

/* all used bits of 'NX90_biss_rdata5': */
#define MSK_USED_BITS_NX90_biss_rdata5 0xffffffffU

enum {
  BFW_NX90_biss_rdata5_RDATA5 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA5_BIT_Ttag {
  unsigned int RDATA5 : BFW_NX90_biss_rdata5_RDATA5; /* register data DWord5 */
} NX90_BISS_RDATA5_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA5_BIT_T bf;
} NX90_BISS_RDATA5_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata6 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata6       0x00000098U
#define Adr_NX90_biss0_app_biss_rdata6 0xFF801B98U
#define Adr_NX90_biss1_app_biss_rdata6 0xFF801C98U
#define DFLT_VAL_NX90_biss_rdata6      0x00000000U

#define MSK_NX90_biss_rdata6_RDATA6         0xffffffffU
#define SRT_NX90_biss_rdata6_RDATA6         0
#define DFLT_VAL_NX90_biss_rdata6_RDATA6    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata6_RDATA6 0x00000000U

/* all used bits of 'NX90_biss_rdata6': */
#define MSK_USED_BITS_NX90_biss_rdata6 0xffffffffU

enum {
  BFW_NX90_biss_rdata6_RDATA6 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA6_BIT_Ttag {
  unsigned int RDATA6 : BFW_NX90_biss_rdata6_RDATA6; /* register data DWord6 */
} NX90_BISS_RDATA6_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA6_BIT_T bf;
} NX90_BISS_RDATA6_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata7 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata7       0x0000009CU
#define Adr_NX90_biss0_app_biss_rdata7 0xFF801B9CU
#define Adr_NX90_biss1_app_biss_rdata7 0xFF801C9CU
#define DFLT_VAL_NX90_biss_rdata7      0x00000000U

#define MSK_NX90_biss_rdata7_RDATA7         0xffffffffU
#define SRT_NX90_biss_rdata7_RDATA7         0
#define DFLT_VAL_NX90_biss_rdata7_RDATA7    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata7_RDATA7 0x00000000U

/* all used bits of 'NX90_biss_rdata7': */
#define MSK_USED_BITS_NX90_biss_rdata7 0xffffffffU

enum {
  BFW_NX90_biss_rdata7_RDATA7 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA7_BIT_Ttag {
  unsigned int RDATA7 : BFW_NX90_biss_rdata7_RDATA7; /* register data DWord7 */
} NX90_BISS_RDATA7_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA7_BIT_T bf;
} NX90_BISS_RDATA7_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata8 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata8       0x000000A0U
#define Adr_NX90_biss0_app_biss_rdata8 0xFF801BA0U
#define Adr_NX90_biss1_app_biss_rdata8 0xFF801CA0U
#define DFLT_VAL_NX90_biss_rdata8      0x00000000U

#define MSK_NX90_biss_rdata8_RDATA8         0xffffffffU
#define SRT_NX90_biss_rdata8_RDATA8         0
#define DFLT_VAL_NX90_biss_rdata8_RDATA8    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata8_RDATA8 0x00000000U

/* all used bits of 'NX90_biss_rdata8': */
#define MSK_USED_BITS_NX90_biss_rdata8 0xffffffffU

enum {
  BFW_NX90_biss_rdata8_RDATA8 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA8_BIT_Ttag {
  unsigned int RDATA8 : BFW_NX90_biss_rdata8_RDATA8; /* register data DWord8 */
} NX90_BISS_RDATA8_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA8_BIT_T bf;
} NX90_BISS_RDATA8_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata9 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata9       0x000000A4U
#define Adr_NX90_biss0_app_biss_rdata9 0xFF801BA4U
#define Adr_NX90_biss1_app_biss_rdata9 0xFF801CA4U
#define DFLT_VAL_NX90_biss_rdata9      0x00000000U

#define MSK_NX90_biss_rdata9_RDATA9         0xffffffffU
#define SRT_NX90_biss_rdata9_RDATA9         0
#define DFLT_VAL_NX90_biss_rdata9_RDATA9    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata9_RDATA9 0x00000000U

/* all used bits of 'NX90_biss_rdata9': */
#define MSK_USED_BITS_NX90_biss_rdata9 0xffffffffU

enum {
  BFW_NX90_biss_rdata9_RDATA9 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA9_BIT_Ttag {
  unsigned int RDATA9 : BFW_NX90_biss_rdata9_RDATA9; /* register data DWord9 */
} NX90_BISS_RDATA9_BIT_T;

typedef union {
  uint32_t               val;
  NX90_BISS_RDATA9_BIT_T bf;
} NX90_BISS_RDATA9_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata10 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata10       0x000000A8U
#define Adr_NX90_biss0_app_biss_rdata10 0xFF801BA8U
#define Adr_NX90_biss1_app_biss_rdata10 0xFF801CA8U
#define DFLT_VAL_NX90_biss_rdata10      0x00000000U

#define MSK_NX90_biss_rdata10_RDATA10         0xffffffffU
#define SRT_NX90_biss_rdata10_RDATA10         0
#define DFLT_VAL_NX90_biss_rdata10_RDATA10    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata10_RDATA10 0x00000000U

/* all used bits of 'NX90_biss_rdata10': */
#define MSK_USED_BITS_NX90_biss_rdata10 0xffffffffU

enum {
  BFW_NX90_biss_rdata10_RDATA10 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA10_BIT_Ttag {
  unsigned int RDATA10 : BFW_NX90_biss_rdata10_RDATA10; /* register data DWord10 */
} NX90_BISS_RDATA10_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_RDATA10_BIT_T bf;
} NX90_BISS_RDATA10_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata11 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata11       0x000000ACU
#define Adr_NX90_biss0_app_biss_rdata11 0xFF801BACU
#define Adr_NX90_biss1_app_biss_rdata11 0xFF801CACU
#define DFLT_VAL_NX90_biss_rdata11      0x00000000U

#define MSK_NX90_biss_rdata11_RDATA11         0xffffffffU
#define SRT_NX90_biss_rdata11_RDATA11         0
#define DFLT_VAL_NX90_biss_rdata11_RDATA11    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata11_RDATA11 0x00000000U

/* all used bits of 'NX90_biss_rdata11': */
#define MSK_USED_BITS_NX90_biss_rdata11 0xffffffffU

enum {
  BFW_NX90_biss_rdata11_RDATA11 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA11_BIT_Ttag {
  unsigned int RDATA11 : BFW_NX90_biss_rdata11_RDATA11; /* register data DWord11 */
} NX90_BISS_RDATA11_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_RDATA11_BIT_T bf;
} NX90_BISS_RDATA11_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata12 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata12       0x000000B0U
#define Adr_NX90_biss0_app_biss_rdata12 0xFF801BB0U
#define Adr_NX90_biss1_app_biss_rdata12 0xFF801CB0U
#define DFLT_VAL_NX90_biss_rdata12      0x00000000U

#define MSK_NX90_biss_rdata12_RDATA12         0xffffffffU
#define SRT_NX90_biss_rdata12_RDATA12         0
#define DFLT_VAL_NX90_biss_rdata12_RDATA12    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata12_RDATA12 0x00000000U

/* all used bits of 'NX90_biss_rdata12': */
#define MSK_USED_BITS_NX90_biss_rdata12 0xffffffffU

enum {
  BFW_NX90_biss_rdata12_RDATA12 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA12_BIT_Ttag {
  unsigned int RDATA12 : BFW_NX90_biss_rdata12_RDATA12; /* register data DWord12 */
} NX90_BISS_RDATA12_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_RDATA12_BIT_T bf;
} NX90_BISS_RDATA12_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata13 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata13       0x000000B4U
#define Adr_NX90_biss0_app_biss_rdata13 0xFF801BB4U
#define Adr_NX90_biss1_app_biss_rdata13 0xFF801CB4U
#define DFLT_VAL_NX90_biss_rdata13      0x00000000U

#define MSK_NX90_biss_rdata13_RDATA13         0xffffffffU
#define SRT_NX90_biss_rdata13_RDATA13         0
#define DFLT_VAL_NX90_biss_rdata13_RDATA13    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata13_RDATA13 0x00000000U

/* all used bits of 'NX90_biss_rdata13': */
#define MSK_USED_BITS_NX90_biss_rdata13 0xffffffffU

enum {
  BFW_NX90_biss_rdata13_RDATA13 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA13_BIT_Ttag {
  unsigned int RDATA13 : BFW_NX90_biss_rdata13_RDATA13; /* register data DWord13 */
} NX90_BISS_RDATA13_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_RDATA13_BIT_T bf;
} NX90_BISS_RDATA13_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata14 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata14       0x000000B8U
#define Adr_NX90_biss0_app_biss_rdata14 0xFF801BB8U
#define Adr_NX90_biss1_app_biss_rdata14 0xFF801CB8U
#define DFLT_VAL_NX90_biss_rdata14      0x00000000U

#define MSK_NX90_biss_rdata14_RDATA14         0xffffffffU
#define SRT_NX90_biss_rdata14_RDATA14         0
#define DFLT_VAL_NX90_biss_rdata14_RDATA14    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata14_RDATA14 0x00000000U

/* all used bits of 'NX90_biss_rdata14': */
#define MSK_USED_BITS_NX90_biss_rdata14 0xffffffffU

enum {
  BFW_NX90_biss_rdata14_RDATA14 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA14_BIT_Ttag {
  unsigned int RDATA14 : BFW_NX90_biss_rdata14_RDATA14; /* register data DWord14 */
} NX90_BISS_RDATA14_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_RDATA14_BIT_T bf;
} NX90_BISS_RDATA14_T;

/* --------------------------------------------------------------------- */
/* Register biss_rdata15 */
/* => Register Data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_rdata15       0x000000BCU
#define Adr_NX90_biss0_app_biss_rdata15 0xFF801BBCU
#define Adr_NX90_biss1_app_biss_rdata15 0xFF801CBCU
#define DFLT_VAL_NX90_biss_rdata15      0x00000000U

#define MSK_NX90_biss_rdata15_RDATA15         0xffffffffU
#define SRT_NX90_biss_rdata15_RDATA15         0
#define DFLT_VAL_NX90_biss_rdata15_RDATA15    0x00000000U
#define DFLT_BF_VAL_NX90_biss_rdata15_RDATA15 0x00000000U

/* all used bits of 'NX90_biss_rdata15': */
#define MSK_USED_BITS_NX90_biss_rdata15 0xffffffffU

enum {
  BFW_NX90_biss_rdata15_RDATA15 = 32  /* [31:0] */
};

typedef struct NX90_BISS_RDATA15_BIT_Ttag {
  unsigned int RDATA15 : BFW_NX90_biss_rdata15_RDATA15; /* register data DWord15 */
} NX90_BISS_RDATA15_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_RDATA15_BIT_T bf;
} NX90_BISS_RDATA15_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc0 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc0       0x000000C0U
#define Adr_NX90_biss0_app_biss_sc0 0xFF801BC0U
#define Adr_NX90_biss1_app_biss_sc0 0xFF801CC0U
#define DFLT_VAL_NX90_biss_sc0      0x00000000U

#define MSK_NX90_biss_sc0_SCDLEN0            0x0000003fU
#define SRT_NX90_biss_sc0_SCDLEN0            0
#define DFLT_VAL_NX90_biss_sc0_SCDLEN0       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc0_SCDLEN0    0x00000000U
#define MSK_NX90_biss_sc0_ENSCD0             0x00000040U
#define SRT_NX90_biss_sc0_ENSCD0             6
#define DFLT_VAL_NX90_biss_sc0_ENSCD0        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc0_ENSCD0     0x00000000U
#define MSK_NX90_biss_sc0_LSTOP0             0x00000080U
#define SRT_NX90_biss_sc0_LSTOP0             7
#define DFLT_VAL_NX90_biss_sc0_LSTOP0        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc0_LSTOP0     0x00000000U
#define MSK_NX90_biss_sc0_SCRCPOLY0          0x00007f00U
#define SRT_NX90_biss_sc0_SCRCPOLY0          8
#define DFLT_VAL_NX90_biss_sc0_SCRCPOLY0     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc0_SCRCPOLY0  0x00000000U
#define MSK_NX90_biss_sc0_SELCRCS0           0x00008000U
#define SRT_NX90_biss_sc0_SELCRCS0           15
#define DFLT_VAL_NX90_biss_sc0_SELCRCS0      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc0_SELCRCS0   0x00000000U
#define MSK_NX90_biss_sc0_SCRCSTART0         0xffff0000U
#define SRT_NX90_biss_sc0_SCRCSTART0         16
#define DFLT_VAL_NX90_biss_sc0_SCRCSTART0    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc0_SCRCSTART0 0x00000000U

/* all used bits of 'NX90_biss_sc0': */
#define MSK_USED_BITS_NX90_biss_sc0 0xffffffffU

enum {
  BFW_NX90_biss_sc0_SCDLEN0    = 6,  /* [5:0] */
  BFW_NX90_biss_sc0_ENSCD0     = 1,  /* [6] */
  BFW_NX90_biss_sc0_LSTOP0     = 1,  /* [7] */
  BFW_NX90_biss_sc0_SCRCPOLY0  = 7,  /* [14:8] */
  BFW_NX90_biss_sc0_SELCRCS0   = 1,  /* [15] */
  BFW_NX90_biss_sc0_SCRCSTART0 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC0_BIT_Ttag {
  unsigned int SCDLEN0    : BFW_NX90_biss_sc0_SCDLEN0;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSCD0     : BFW_NX90_biss_sc0_ENSCD0;     /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP0     : BFW_NX90_biss_sc0_LSTOP0;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY0  : BFW_NX90_biss_sc0_SCRCPOLY0;  /* - SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check)                               */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS0   : BFW_NX90_biss_sc0_SELCRCS0;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART0 : BFW_NX90_biss_sc0_SCRCSTART0; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC0_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC0_BIT_T bf;
} NX90_BISS_SC0_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc1 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc1       0x000000C4U
#define Adr_NX90_biss0_app_biss_sc1 0xFF801BC4U
#define Adr_NX90_biss1_app_biss_sc1 0xFF801CC4U
#define DFLT_VAL_NX90_biss_sc1      0x00000000U

#define MSK_NX90_biss_sc1_SCDLEN1            0x0000003fU
#define SRT_NX90_biss_sc1_SCDLEN1            0
#define DFLT_VAL_NX90_biss_sc1_SCDLEN1       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc1_SCDLEN1    0x00000000U
#define MSK_NX90_biss_sc1_ENSCD1             0x00000040U
#define SRT_NX90_biss_sc1_ENSCD1             6
#define DFLT_VAL_NX90_biss_sc1_ENSCD1        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc1_ENSCD1     0x00000000U
#define MSK_NX90_biss_sc1_LSTOP1             0x00000080U
#define SRT_NX90_biss_sc1_LSTOP1             7
#define DFLT_VAL_NX90_biss_sc1_LSTOP1        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc1_LSTOP1     0x00000000U
#define MSK_NX90_biss_sc1_SCRCPOLY1          0x00007f00U
#define SRT_NX90_biss_sc1_SCRCPOLY1          8
#define DFLT_VAL_NX90_biss_sc1_SCRCPOLY1     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc1_SCRCPOLY1  0x00000000U
#define MSK_NX90_biss_sc1_SELCRCS1           0x00008000U
#define SRT_NX90_biss_sc1_SELCRCS1           15
#define DFLT_VAL_NX90_biss_sc1_SELCRCS1      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc1_SELCRCS1   0x00000000U
#define MSK_NX90_biss_sc1_SCRCSTART1         0xffff0000U
#define SRT_NX90_biss_sc1_SCRCSTART1         16
#define DFLT_VAL_NX90_biss_sc1_SCRCSTART1    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc1_SCRCSTART1 0x00000000U

/* all used bits of 'NX90_biss_sc1': */
#define MSK_USED_BITS_NX90_biss_sc1 0xffffffffU

enum {
  BFW_NX90_biss_sc1_SCDLEN1    = 6,  /* [5:0] */
  BFW_NX90_biss_sc1_ENSCD1     = 1,  /* [6] */
  BFW_NX90_biss_sc1_LSTOP1     = 1,  /* [7] */
  BFW_NX90_biss_sc1_SCRCPOLY1  = 7,  /* [14:8] */
  BFW_NX90_biss_sc1_SELCRCS1   = 1,  /* [15] */
  BFW_NX90_biss_sc1_SCRCSTART1 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC1_BIT_Ttag {
  unsigned int SCDLEN1    : BFW_NX90_biss_sc1_SCDLEN1;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSCD1     : BFW_NX90_biss_sc1_ENSCD1;     /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP1     : BFW_NX90_biss_sc1_LSTOP1;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY1  : BFW_NX90_biss_sc1_SCRCPOLY1;  /* - SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check)                               */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS1   : BFW_NX90_biss_sc1_SELCRCS1;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART1 : BFW_NX90_biss_sc1_SCRCSTART1; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC1_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC1_BIT_T bf;
} NX90_BISS_SC1_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc2 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc2       0x000000C8U
#define Adr_NX90_biss0_app_biss_sc2 0xFF801BC8U
#define Adr_NX90_biss1_app_biss_sc2 0xFF801CC8U
#define DFLT_VAL_NX90_biss_sc2      0x00000000U

#define MSK_NX90_biss_sc2_SCDLEN2            0x0000003fU
#define SRT_NX90_biss_sc2_SCDLEN2            0
#define DFLT_VAL_NX90_biss_sc2_SCDLEN2       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc2_SCDLEN2    0x00000000U
#define MSK_NX90_biss_sc2_ENSCD2             0x00000040U
#define SRT_NX90_biss_sc2_ENSCD2             6
#define DFLT_VAL_NX90_biss_sc2_ENSCD2        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc2_ENSCD2     0x00000000U
#define MSK_NX90_biss_sc2_LSTOP2             0x00000080U
#define SRT_NX90_biss_sc2_LSTOP2             7
#define DFLT_VAL_NX90_biss_sc2_LSTOP2        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc2_LSTOP2     0x00000000U
#define MSK_NX90_biss_sc2_SCRCPOLY2          0x00007f00U
#define SRT_NX90_biss_sc2_SCRCPOLY2          8
#define DFLT_VAL_NX90_biss_sc2_SCRCPOLY2     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc2_SCRCPOLY2  0x00000000U
#define MSK_NX90_biss_sc2_SELCRCS2           0x00008000U
#define SRT_NX90_biss_sc2_SELCRCS2           15
#define DFLT_VAL_NX90_biss_sc2_SELCRCS2      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc2_SELCRCS2   0x00000000U
#define MSK_NX90_biss_sc2_SCRCSTART2         0xffff0000U
#define SRT_NX90_biss_sc2_SCRCSTART2         16
#define DFLT_VAL_NX90_biss_sc2_SCRCSTART2    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc2_SCRCSTART2 0x00000000U

/* all used bits of 'NX90_biss_sc2': */
#define MSK_USED_BITS_NX90_biss_sc2 0xffffffffU

enum {
  BFW_NX90_biss_sc2_SCDLEN2    = 6,  /* [5:0] */
  BFW_NX90_biss_sc2_ENSCD2     = 1,  /* [6] */
  BFW_NX90_biss_sc2_LSTOP2     = 1,  /* [7] */
  BFW_NX90_biss_sc2_SCRCPOLY2  = 7,  /* [14:8] */
  BFW_NX90_biss_sc2_SELCRCS2   = 1,  /* [15] */
  BFW_NX90_biss_sc2_SCRCSTART2 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC2_BIT_Ttag {
  unsigned int SCDLEN2    : BFW_NX90_biss_sc2_SCDLEN2;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSCD2     : BFW_NX90_biss_sc2_ENSCD2;     /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP2     : BFW_NX90_biss_sc2_LSTOP2;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY2  : BFW_NX90_biss_sc2_SCRCPOLY2;  /* - SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check)                               */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS2   : BFW_NX90_biss_sc2_SELCRCS2;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART2 : BFW_NX90_biss_sc2_SCRCSTART2; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC2_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC2_BIT_T bf;
} NX90_BISS_SC2_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc3 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc3       0x000000CCU
#define Adr_NX90_biss0_app_biss_sc3 0xFF801BCCU
#define Adr_NX90_biss1_app_biss_sc3 0xFF801CCCU
#define DFLT_VAL_NX90_biss_sc3      0x00000000U

#define MSK_NX90_biss_sc3_SCDLEN3            0x0000003fU
#define SRT_NX90_biss_sc3_SCDLEN3            0
#define DFLT_VAL_NX90_biss_sc3_SCDLEN3       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc3_SCDLEN3    0x00000000U
#define MSK_NX90_biss_sc3_ENSCD3             0x00000040U
#define SRT_NX90_biss_sc3_ENSCD3             6
#define DFLT_VAL_NX90_biss_sc3_ENSCD3        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc3_ENSCD3     0x00000000U
#define MSK_NX90_biss_sc3_LSTOP3             0x00000080U
#define SRT_NX90_biss_sc3_LSTOP3             7
#define DFLT_VAL_NX90_biss_sc3_LSTOP3        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc3_LSTOP3     0x00000000U
#define MSK_NX90_biss_sc3_SCRCPOLY3          0x00007f00U
#define SRT_NX90_biss_sc3_SCRCPOLY3          8
#define DFLT_VAL_NX90_biss_sc3_SCRCPOLY3     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc3_SCRCPOLY3  0x00000000U
#define MSK_NX90_biss_sc3_SELCRCS3           0x00008000U
#define SRT_NX90_biss_sc3_SELCRCS3           15
#define DFLT_VAL_NX90_biss_sc3_SELCRCS3      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc3_SELCRCS3   0x00000000U
#define MSK_NX90_biss_sc3_SCRCSTART3         0xffff0000U
#define SRT_NX90_biss_sc3_SCRCSTART3         16
#define DFLT_VAL_NX90_biss_sc3_SCRCSTART3    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc3_SCRCSTART3 0x00000000U

/* all used bits of 'NX90_biss_sc3': */
#define MSK_USED_BITS_NX90_biss_sc3 0xffffffffU

enum {
  BFW_NX90_biss_sc3_SCDLEN3    = 6,  /* [5:0] */
  BFW_NX90_biss_sc3_ENSCD3     = 1,  /* [6] */
  BFW_NX90_biss_sc3_LSTOP3     = 1,  /* [7] */
  BFW_NX90_biss_sc3_SCRCPOLY3  = 7,  /* [14:8] */
  BFW_NX90_biss_sc3_SELCRCS3   = 1,  /* [15] */
  BFW_NX90_biss_sc3_SCRCSTART3 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC3_BIT_Ttag {
  unsigned int SCDLEN3    : BFW_NX90_biss_sc3_SCDLEN3;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSCD3     : BFW_NX90_biss_sc3_ENSCD3;     /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP3     : BFW_NX90_biss_sc3_LSTOP3;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY3  : BFW_NX90_biss_sc3_SCRCPOLY3;  /* - SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check)                               */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS3   : BFW_NX90_biss_sc3_SELCRCS3;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART3 : BFW_NX90_biss_sc3_SCRCSTART3; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC3_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC3_BIT_T bf;
} NX90_BISS_SC3_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc4 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc4       0x000000D0U
#define Adr_NX90_biss0_app_biss_sc4 0xFF801BD0U
#define Adr_NX90_biss1_app_biss_sc4 0xFF801CD0U
#define DFLT_VAL_NX90_biss_sc4      0x00000000U

#define MSK_NX90_biss_sc4_SCDLEN4            0x0000003fU
#define SRT_NX90_biss_sc4_SCDLEN4            0
#define DFLT_VAL_NX90_biss_sc4_SCDLEN4       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc4_SCDLEN4    0x00000000U
#define MSK_NX90_biss_sc4_ENSCD4             0x00000040U
#define SRT_NX90_biss_sc4_ENSCD4             6
#define DFLT_VAL_NX90_biss_sc4_ENSCD4        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc4_ENSCD4     0x00000000U
#define MSK_NX90_biss_sc4_LSTOP4             0x00000080U
#define SRT_NX90_biss_sc4_LSTOP4             7
#define DFLT_VAL_NX90_biss_sc4_LSTOP4        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc4_LSTOP4     0x00000000U
#define MSK_NX90_biss_sc4_SCRCPOLY4          0x00007f00U
#define SRT_NX90_biss_sc4_SCRCPOLY4          8
#define DFLT_VAL_NX90_biss_sc4_SCRCPOLY4     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc4_SCRCPOLY4  0x00000000U
#define MSK_NX90_biss_sc4_SELCRCS4           0x00008000U
#define SRT_NX90_biss_sc4_SELCRCS4           15
#define DFLT_VAL_NX90_biss_sc4_SELCRCS4      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc4_SELCRCS4   0x00000000U
#define MSK_NX90_biss_sc4_SCRCSTART4         0xffff0000U
#define SRT_NX90_biss_sc4_SCRCSTART4         16
#define DFLT_VAL_NX90_biss_sc4_SCRCSTART4    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc4_SCRCSTART4 0x00000000U

/* all used bits of 'NX90_biss_sc4': */
#define MSK_USED_BITS_NX90_biss_sc4 0xffffffffU

enum {
  BFW_NX90_biss_sc4_SCDLEN4    = 6,  /* [5:0] */
  BFW_NX90_biss_sc4_ENSCD4     = 1,  /* [6] */
  BFW_NX90_biss_sc4_LSTOP4     = 1,  /* [7] */
  BFW_NX90_biss_sc4_SCRCPOLY4  = 7,  /* [14:8] */
  BFW_NX90_biss_sc4_SELCRCS4   = 1,  /* [15] */
  BFW_NX90_biss_sc4_SCRCSTART4 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC4_BIT_Ttag {
  unsigned int SCDLEN4    : BFW_NX90_biss_sc4_SCDLEN4;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSCD4     : BFW_NX90_biss_sc4_ENSCD4;     /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP4     : BFW_NX90_biss_sc4_LSTOP4;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY4  : BFW_NX90_biss_sc4_SCRCPOLY4;  /* - SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check)                               */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS4   : BFW_NX90_biss_sc4_SELCRCS4;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART4 : BFW_NX90_biss_sc4_SCRCSTART4; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC4_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC4_BIT_T bf;
} NX90_BISS_SC4_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc5 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc5       0x000000D4U
#define Adr_NX90_biss0_app_biss_sc5 0xFF801BD4U
#define Adr_NX90_biss1_app_biss_sc5 0xFF801CD4U
#define DFLT_VAL_NX90_biss_sc5      0x00000000U

#define MSK_NX90_biss_sc5_SCDLEN5            0x0000003fU
#define SRT_NX90_biss_sc5_SCDLEN5            0
#define DFLT_VAL_NX90_biss_sc5_SCDLEN5       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc5_SCDLEN5    0x00000000U
#define MSK_NX90_biss_sc5_ENSCD5             0x00000040U
#define SRT_NX90_biss_sc5_ENSCD5             6
#define DFLT_VAL_NX90_biss_sc5_ENSCD5        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc5_ENSCD5     0x00000000U
#define MSK_NX90_biss_sc5_LSTOP5             0x00000080U
#define SRT_NX90_biss_sc5_LSTOP5             7
#define DFLT_VAL_NX90_biss_sc5_LSTOP5        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc5_LSTOP5     0x00000000U
#define MSK_NX90_biss_sc5_SCRCPOLY5          0x00007f00U
#define SRT_NX90_biss_sc5_SCRCPOLY5          8
#define DFLT_VAL_NX90_biss_sc5_SCRCPOLY5     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc5_SCRCPOLY5  0x00000000U
#define MSK_NX90_biss_sc5_SELCRCS5           0x00008000U
#define SRT_NX90_biss_sc5_SELCRCS5           15
#define DFLT_VAL_NX90_biss_sc5_SELCRCS5      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc5_SELCRCS5   0x00000000U
#define MSK_NX90_biss_sc5_SCRCSTART5         0xffff0000U
#define SRT_NX90_biss_sc5_SCRCSTART5         16
#define DFLT_VAL_NX90_biss_sc5_SCRCSTART5    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc5_SCRCSTART5 0x00000000U

/* all used bits of 'NX90_biss_sc5': */
#define MSK_USED_BITS_NX90_biss_sc5 0xffffffffU

enum {
  BFW_NX90_biss_sc5_SCDLEN5    = 6,  /* [5:0] */
  BFW_NX90_biss_sc5_ENSCD5     = 1,  /* [6] */
  BFW_NX90_biss_sc5_LSTOP5     = 1,  /* [7] */
  BFW_NX90_biss_sc5_SCRCPOLY5  = 7,  /* [14:8] */
  BFW_NX90_biss_sc5_SELCRCS5   = 1,  /* [15] */
  BFW_NX90_biss_sc5_SCRCSTART5 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC5_BIT_Ttag {
  unsigned int SCDLEN5    : BFW_NX90_biss_sc5_SCDLEN5;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSCD5     : BFW_NX90_biss_sc5_ENSCD5;     /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP5     : BFW_NX90_biss_sc5_LSTOP5;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY5  : BFW_NX90_biss_sc5_SCRCPOLY5;  /* - SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check)                               */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS5   : BFW_NX90_biss_sc5_SELCRCS5;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART5 : BFW_NX90_biss_sc5_SCRCSTART5; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC5_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC5_BIT_T bf;
} NX90_BISS_SC5_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc6 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc6       0x000000D8U
#define Adr_NX90_biss0_app_biss_sc6 0xFF801BD8U
#define Adr_NX90_biss1_app_biss_sc6 0xFF801CD8U
#define DFLT_VAL_NX90_biss_sc6      0x00000000U

#define MSK_NX90_biss_sc6_SCDLEN6            0x0000003fU
#define SRT_NX90_biss_sc6_SCDLEN6            0
#define DFLT_VAL_NX90_biss_sc6_SCDLEN6       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc6_SCDLEN6    0x00000000U
#define MSK_NX90_biss_sc6_ENSCD6             0x00000040U
#define SRT_NX90_biss_sc6_ENSCD6             6
#define DFLT_VAL_NX90_biss_sc6_ENSCD6        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc6_ENSCD6     0x00000000U
#define MSK_NX90_biss_sc6_LSTOP6             0x00000080U
#define SRT_NX90_biss_sc6_LSTOP6             7
#define DFLT_VAL_NX90_biss_sc6_LSTOP6        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc6_LSTOP6     0x00000000U
#define MSK_NX90_biss_sc6_SCRCPOLY6          0x00007f00U
#define SRT_NX90_biss_sc6_SCRCPOLY6          8
#define DFLT_VAL_NX90_biss_sc6_SCRCPOLY6     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc6_SCRCPOLY6  0x00000000U
#define MSK_NX90_biss_sc6_SELCRCS6           0x00008000U
#define SRT_NX90_biss_sc6_SELCRCS6           15
#define DFLT_VAL_NX90_biss_sc6_SELCRCS6      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc6_SELCRCS6   0x00000000U
#define MSK_NX90_biss_sc6_SCRCSTART6         0xffff0000U
#define SRT_NX90_biss_sc6_SCRCSTART6         16
#define DFLT_VAL_NX90_biss_sc6_SCRCSTART6    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc6_SCRCSTART6 0x00000000U

/* all used bits of 'NX90_biss_sc6': */
#define MSK_USED_BITS_NX90_biss_sc6 0xffffffffU

enum {
  BFW_NX90_biss_sc6_SCDLEN6    = 6,  /* [5:0] */
  BFW_NX90_biss_sc6_ENSCD6     = 1,  /* [6] */
  BFW_NX90_biss_sc6_LSTOP6     = 1,  /* [7] */
  BFW_NX90_biss_sc6_SCRCPOLY6  = 7,  /* [14:8] */
  BFW_NX90_biss_sc6_SELCRCS6   = 1,  /* [15] */
  BFW_NX90_biss_sc6_SCRCSTART6 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC6_BIT_Ttag {
  unsigned int SCDLEN6    : BFW_NX90_biss_sc6_SCDLEN6;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSCD6     : BFW_NX90_biss_sc6_ENSCD6;     /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP6     : BFW_NX90_biss_sc6_LSTOP6;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY6  : BFW_NX90_biss_sc6_SCRCPOLY6;  /* - SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check)                               */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS6   : BFW_NX90_biss_sc6_SELCRCS6;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART6 : BFW_NX90_biss_sc6_SCRCSTART6; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC6_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC6_BIT_T bf;
} NX90_BISS_SC6_T;

/* --------------------------------------------------------------------- */
/* Register biss_sc7 */
/* => Slave Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_sc7       0x000000DCU
#define Adr_NX90_biss0_app_biss_sc7 0xFF801BDCU
#define Adr_NX90_biss1_app_biss_sc7 0xFF801CDCU
#define DFLT_VAL_NX90_biss_sc7      0x00000000U

#define MSK_NX90_biss_sc7_SCDLEN7            0x0000003fU
#define SRT_NX90_biss_sc7_SCDLEN7            0
#define DFLT_VAL_NX90_biss_sc7_SCDLEN7       0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc7_SCDLEN7    0x00000000U
#define MSK_NX90_biss_sc7_ENSC7              0x00000040U
#define SRT_NX90_biss_sc7_ENSC7              6
#define DFLT_VAL_NX90_biss_sc7_ENSC7         0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc7_ENSC7      0x00000000U
#define MSK_NX90_biss_sc7_LSTOP7             0x00000080U
#define SRT_NX90_biss_sc7_LSTOP7             7
#define DFLT_VAL_NX90_biss_sc7_LSTOP7        0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc7_LSTOP7     0x00000000U
#define MSK_NX90_biss_sc7_SCRCPOLY7          0x00007f00U
#define SRT_NX90_biss_sc7_SCRCPOLY7          8
#define DFLT_VAL_NX90_biss_sc7_SCRCPOLY7     0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc7_SCRCPOLY7  0x00000000U
#define MSK_NX90_biss_sc7_SELCRCS7           0x00008000U
#define SRT_NX90_biss_sc7_SELCRCS7           15
#define DFLT_VAL_NX90_biss_sc7_SELCRCS7      0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc7_SELCRCS7   0x00000000U
#define MSK_NX90_biss_sc7_SCRCSTART7         0xffff0000U
#define SRT_NX90_biss_sc7_SCRCSTART7         16
#define DFLT_VAL_NX90_biss_sc7_SCRCSTART7    0x00000000U
#define DFLT_BF_VAL_NX90_biss_sc7_SCRCSTART7 0x00000000U

/* all used bits of 'NX90_biss_sc7': */
#define MSK_USED_BITS_NX90_biss_sc7 0xffffffffU

enum {
  BFW_NX90_biss_sc7_SCDLEN7    = 6,  /* [5:0] */
  BFW_NX90_biss_sc7_ENSC7      = 1,  /* [6] */
  BFW_NX90_biss_sc7_LSTOP7     = 1,  /* [7] */
  BFW_NX90_biss_sc7_SCRCPOLY7  = 7,  /* [14:8] */
  BFW_NX90_biss_sc7_SELCRCS7   = 1,  /* [15] */
  BFW_NX90_biss_sc7_SCRCSTART7 = 16  /* [31:16] */
};

typedef struct NX90_BISS_SC7_BIT_Ttag {
  unsigned int SCDLEN7    : BFW_NX90_biss_sc7_SCDLEN7;    /* Single cycle data length                                                                                   */
                                                          /* 0 : single cycle data length = 1                                                                           */
                                                          /* 1 : single cycle data length = 2                                                                           */
                                                          /* ... single cycle data length = SCDLENx + 1                                                                 */
                                                          /* 62: single cycle data length = 63                                                                          */
                                                          /* 63: single cycle data length = 64                                                                          */
  unsigned int ENSC7      : BFW_NX90_biss_sc7_ENSC7;      /* Enable single cycle data                                                                                   */
                                                          /* 0: single cycle data not available                                                                         */
                                                          /* 1: single cycle data available                                                                             */
  unsigned int LSTOP7     : BFW_NX90_biss_sc7_LSTOP7;     /* - BISS mode(LSTOPx = Actuator stop bit control)                                                            */
                                                          /*   0: no leading STOP bit on single cycle actuator data                                                     */
                                                          /*   1: leading STOP bit on single cycle actuator data                                                        */
                                                          /* - SSI mode(GRAYSx = Enable SCD gray to binary conversion)                                                  */
                                                          /*   0: SSI single cycle data binary coded                                                                    */
                                                          /*   1: SSI single cycle data gray coded                                                                      */
  unsigned int SCRCPOLY7  : BFW_NX90_biss_sc7_SCRCPOLY7;  /* - SELCRCx == 0 (SCRCLENx: polynomial selection by length for SCD CRC check)                                */
                                                          /*    0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0                  */
                                                          /*    3: CRC polynomial = 0x0b                                                                                */
                                                          /*    4: CRC polynomial = 0x13                                                                                */
                                                          /*    5: CRC polynomial = 0x25                                                                                */
                                                          /*    6: CRC polynomial = 0x43                                                                                */
                                                          /*    7: CRC polynomial = 0x89                                                                                */
                                                          /*    8: CRC polynomial = 0x12f                                                                               */
                                                          /*   16: CRC polynomial = 0x190d9                                                                             */
                                                          /*   ..: other CRC length are not permitted with SELCRCSx = 0                                                 */
                                                          /* - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check)                                                   */
                                                          /*   0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1                                        */
                                                          /*   0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01                                */
  unsigned int SELCRCS7   : BFW_NX90_biss_sc7_SELCRCS7;   /* Selection between polynomial or length for SCD CRC polynomial                                              */
                                                          /* 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials                              */
                                                          /* 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 */
  unsigned int SCRCSTART7 : BFW_NX90_biss_sc7_SCRCSTART7; /* Start value for polynomial SCD CRC calculation                                                             */
} NX90_BISS_SC7_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_SC7_BIT_T bf;
} NX90_BISS_SC7_T;

/* --------------------------------------------------------------------- */
/* Register biss_ccc0 */
/* => Register Communication Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ccc0       0x000000E0U
#define Adr_NX90_biss0_app_biss_ccc0 0xFF801BE0U
#define Adr_NX90_biss1_app_biss_ccc0 0xFF801CE0U
#define DFLT_VAL_NX90_biss_ccc0      0x00000000U

#define MSK_NX90_biss_ccc0_REGADR         0x007f0000U
#define SRT_NX90_biss_ccc0_REGADR         16
#define DFLT_VAL_NX90_biss_ccc0_REGADR    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc0_REGADR 0x00000000U
#define MSK_NX90_biss_ccc0_WNR            0x00800000U
#define SRT_NX90_biss_ccc0_WNR            23
#define DFLT_VAL_NX90_biss_ccc0_WNR       0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc0_WNR    0x00000000U
#define MSK_NX90_biss_ccc0_REGNUM         0x3f000000U
#define SRT_NX90_biss_ccc0_REGNUM         24
#define DFLT_VAL_NX90_biss_ccc0_REGNUM    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc0_REGNUM 0x00000000U

/* all used bits of 'NX90_biss_ccc0': */
#define MSK_USED_BITS_NX90_biss_ccc0 0x3fff0000U

enum {
  BFW_NX90_biss_ccc0_reserved1 = 16, /* [15:0] */
  BFW_NX90_biss_ccc0_REGADR    = 7,  /* [22:16] */
  BFW_NX90_biss_ccc0_WNR       = 1,  /* [23] */
  BFW_NX90_biss_ccc0_REGNUM    = 6,  /* [29:24] */
  BFW_NX90_biss_ccc0_reserved2 = 2   /* [31:30] */
};

typedef struct NX90_BISS_CCC0_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_biss_ccc0_reserved1; /* reserved                                    */
  unsigned int REGADR    : BFW_NX90_biss_ccc0_REGADR;    /* Register access start address 0x00 .. 0x7f  */
  unsigned int WNR       : BFW_NX90_biss_ccc0_WNR;       /* Register access read/write selector         */
                                                         /* 0: read register data                       */
                                                         /* 1: write register data                      */
  unsigned int REGNUM    : BFW_NX90_biss_ccc0_REGNUM;    /* Register data count                         */
                                                         /* 0x00       : register count = 1             */
                                                         /* 0x01 ..0x3f: register count = REGNUM(5:0)+1 */
  unsigned int reserved2 : BFW_NX90_biss_ccc0_reserved2; /* reserved                                    */
} NX90_BISS_CCC0_BIT_T;

typedef union {
  uint32_t             val;
  NX90_BISS_CCC0_BIT_T bf;
} NX90_BISS_CCC0_T;

/* --------------------------------------------------------------------- */
/* Register biss_ccc1_mc0 */
/* => Register Communication Configuration / Master Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ccc1_mc0       0x000000E4U
#define Adr_NX90_biss0_app_biss_ccc1_mc0 0xFF801BE4U
#define Adr_NX90_biss1_app_biss_ccc1_mc0 0xFF801CE4U
#define DFLT_VAL_NX90_biss_ccc1_mc0      0x00000000U

#define MSK_NX90_biss_ccc1_mc0_CHSEL              0x00000003U
#define SRT_NX90_biss_ccc1_mc0_CHSEL              0
#define DFLT_VAL_NX90_biss_ccc1_mc0_CHSEL         0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_CHSEL      0x00000000U
#define MSK_NX90_biss_ccc1_mc0_HOLDCDM            0x00000100U
#define SRT_NX90_biss_ccc1_mc0_HOLDCDM            8
#define DFLT_VAL_NX90_biss_ccc1_mc0_HOLDCDM       0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_HOLDCDM    0x00000000U
#define MSK_NX90_biss_ccc1_mc0_EN_MO              0x00000200U
#define SRT_NX90_biss_ccc1_mc0_EN_MO              9
#define DFLT_VAL_NX90_biss_ccc1_mc0_EN_MO         0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_EN_MO      0x00000000U
#define MSK_NX90_biss_ccc1_mc0_IDA_TEST           0x00000800U
#define SRT_NX90_biss_ccc1_mc0_IDA_TEST           11
#define DFLT_VAL_NX90_biss_ccc1_mc0_IDA_TEST      0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_IDA_TEST   0x00000000U
#define MSK_NX90_biss_ccc1_mc0_CMD                0x00003000U
#define SRT_NX90_biss_ccc1_mc0_CMD                12
#define DFLT_VAL_NX90_biss_ccc1_mc0_CMD           0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_CMD        0x00000000U
#define MSK_NX90_biss_ccc1_mc0_REGVERS            0x00004000U
#define SRT_NX90_biss_ccc1_mc0_REGVERS            14
#define DFLT_VAL_NX90_biss_ccc1_mc0_REGVERS       0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_REGVERS    0x00000000U
#define MSK_NX90_biss_ccc1_mc0_CTS                0x00008000U
#define SRT_NX90_biss_ccc1_mc0_CTS                15
#define DFLT_VAL_NX90_biss_ccc1_mc0_CTS           0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_CTS        0x00000000U
#define MSK_NX90_biss_ccc1_mc0_FREQS              0x001f0000U
#define SRT_NX90_biss_ccc1_mc0_FREQS              16
#define DFLT_VAL_NX90_biss_ccc1_mc0_FREQS         0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_FREQS      0x00000000U
#define MSK_NX90_biss_ccc1_mc0_FREQR              0x00e00000U
#define SRT_NX90_biss_ccc1_mc0_FREQR              21
#define DFLT_VAL_NX90_biss_ccc1_mc0_FREQR         0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_FREQR      0x00000000U
#define MSK_NX90_biss_ccc1_mc0_SINGLEBANK         0x01000000U
#define SRT_NX90_biss_ccc1_mc0_SINGLEBANK         24
#define DFLT_VAL_NX90_biss_ccc1_mc0_SINGLEBANK    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_SINGLEBANK 0x00000000U
#define MSK_NX90_biss_ccc1_mc0_NOCRC              0x02000000U
#define SRT_NX90_biss_ccc1_mc0_NOCRC              25
#define DFLT_VAL_NX90_biss_ccc1_mc0_NOCRC         0x00000000U
#define DFLT_BF_VAL_NX90_biss_ccc1_mc0_NOCRC      0x00000000U

/* all used bits of 'NX90_biss_ccc1_mc0': */
#define MSK_USED_BITS_NX90_biss_ccc1_mc0 0x03fffb03U

enum {
  BFW_NX90_biss_ccc1_mc0_CHSEL      = 2, /* [1:0] */
  BFW_NX90_biss_ccc1_mc0_reserved1  = 6, /* [7:2] */
  BFW_NX90_biss_ccc1_mc0_HOLDCDM    = 1, /* [8] */
  BFW_NX90_biss_ccc1_mc0_EN_MO      = 1, /* [9] */
  BFW_NX90_biss_ccc1_mc0_reserved2  = 1, /* [10] */
  BFW_NX90_biss_ccc1_mc0_IDA_TEST   = 1, /* [11] */
  BFW_NX90_biss_ccc1_mc0_CMD        = 2, /* [13:12] */
  BFW_NX90_biss_ccc1_mc0_REGVERS    = 1, /* [14] */
  BFW_NX90_biss_ccc1_mc0_CTS        = 1, /* [15] */
  BFW_NX90_biss_ccc1_mc0_FREQS      = 5, /* [20:16] */
  BFW_NX90_biss_ccc1_mc0_FREQR      = 3, /* [23:21] */
  BFW_NX90_biss_ccc1_mc0_SINGLEBANK = 1, /* [24] */
  BFW_NX90_biss_ccc1_mc0_NOCRC      = 1, /* [25] */
  BFW_NX90_biss_ccc1_mc0_reserved3  = 6  /* [31:26] */
};

typedef struct NX90_BISS_CCC1_MC0_BIT_Ttag {
  unsigned int CHSEL      : BFW_NX90_biss_ccc1_mc0_CHSEL;      /* Channel selector                                                                                                      */
                                                               /* 0: channel 1 used for control communication, channel 2 not used                                                       */
                                                               /* 1: channel 1 used for control communication, channel 2 not used                                                       */
                                                               /* 2: channel 2 used for control communication, channel 1 not used. Note: Channel 2 is not available with IC-MB4 TSSOP24 */
                                                               /* 3: channel 1,2 used for control communication. Note: Channel 2 is not available with IC-MB4 TSSOP24                   */
  unsigned int reserved1  : BFW_NX90_biss_ccc1_mc0_reserved1;  /* reserved                                                                                                              */
  unsigned int HOLDCDM    : BFW_NX90_biss_ccc1_mc0_HOLDCDM;    /* Hold CDM(control data master)                                                                                         */
                                                               /* 0: clock line high at end of cycle                                                                                    */
                                                               /* 1: clock line constant with CDM bit until start of next cycle                                                         */
  unsigned int EN_MO      : BFW_NX90_biss_ccc1_mc0_EN_MO;      /* Enable output at MOx for actuator data or delayed start bit                                                           */
                                                               /* 0: MO forced to low                                                                                                   */
                                                               /* 1: Parameterized processing time by master on MO signal active (length: MO_BUSY)                                      */
  unsigned int reserved2  : BFW_NX90_biss_ccc1_mc0_reserved2;  /* reserved                                                                                                              */
  unsigned int IDA_TEST   : BFW_NX90_biss_ccc1_mc0_IDA_TEST;   /* - Using register access in control communication                                                                      */
                                                               /*   SLAVEID[0]: slave selector bit0                                                                                     */
                                                               /* - Using command/instructions in control communication                                                                 */
                                                               /*   IDA_TEST: command/instruction execution control                                                                     */
                                                               /*   0: the slaves feedback (IDA) is tested before execution (EX bit after IDA)                                          */
                                                               /*   1: immediate execution                                                                                              */
  unsigned int CMD        : BFW_NX90_biss_ccc1_mc0_CMD;        /* - Using register access in control communication                                                                      */
                                                               /*   SLAVEID[2:1]: slave selector bit2_1                                                                                 */
                                                               /* - Using command/instructions in control communication                                                                 */
                                                               /*   Command of access slave     # default 0x00                                                                          */
                                                               /*   0x00 .. 0x03: command/instruction 0b00 .. 0b11                                                                      */
  unsigned int REGVERS    : BFW_NX90_biss_ccc1_mc0_REGVERS;    /* BiSS model A/B or C selector                                                                                          */
                                                               /* - Using register access in control communication                                                                      */
                                                               /*   0: register communication BiSS A/B                                                                                  */
                                                               /*   1: register communication BiSS C                                                                                    */
                                                               /* - Using command/instructions in control communication                                                                 */
                                                               /*   0: not applicable with command/instruction communication                                                            */
                                                               /*   1: command communication BiSS C                                                                                     */
  unsigned int CTS        : BFW_NX90_biss_ccc1_mc0_CTS;        /* Register transmission or instruction selector                                                                         */
                                                               /* 0: command/instruction communication                                                                                  */
                                                               /* 1: register communication                                                                                             */
  unsigned int FREQS      : BFW_NX90_biss_ccc1_mc0_FREQS;      /* Frequency division                                                                                                    */
                                                               /* 0x00: fCLK/2                                                                                                          */
                                                               /* 0x01: fCLK/4                                                                                                          */
                                                               /* 0x02: fCLK/6                                                                                                          */
                                                               /* 0x03: fCLK/8                                                                                                          */
                                                               /* ...                                                                                                                   */
                                                               /* 0x09: fCLK/20                                                                                                         */
                                                               /* ...                                                                                                                   */
                                                               /* 0x0d: fCLK/28                                                                                                         */
                                                               /* 0x0e: fCLK/30                                                                                                         */
                                                               /* 0x0f: fCLK/32                                                                                                         */
                                                               /* 0x10: not permitted                                                                                                   */
                                                               /* 0x11: fCLK/40                                                                                                         */
                                                               /* 0x12: fCLK/60                                                                                                         */
                                                               /* 0x13: fCLK/80                                                                                                         */
                                                               /* ...                                                                                                                   */
                                                               /* 0x1d: fCLK/280                                                                                                        */
                                                               /* 0x1e: fCLK/300                                                                                                        */
                                                               /* 0x1f: fCLK/320                                                                                                        */
  unsigned int FREQR      : BFW_NX90_biss_ccc1_mc0_FREQR;      /* Frequency division register communication BiSS B                                                                      */
                                                               /* 0 .. 7: freqSens/(2*(FREQ(7:5)+1))                                                                                    */
                                                               /* 0: FreqSens/2                                                                                                         */
                                                               /* 1: FreqSens/4                                                                                                         */
                                                               /* 2: FreqSens/8                                                                                                         */
                                                               /* 3: FreqSens/16                                                                                                        */
                                                               /* 4: FreqSens/32                                                                                                        */
                                                               /* 5: FreqSens/64                                                                                                        */
                                                               /* 6: FreqSens/128                                                                                                       */
                                                               /* 7: FreqSens/256                                                                                                       */
  unsigned int SINGLEBANK : BFW_NX90_biss_ccc1_mc0_SINGLEBANK; /* Use of only one RAM bank for SCD                                                                                      */
                                                               /* 0: two RAM banks are used for SCD                                                                                     */
                                                               /* 1: one RAM bank is used for SCD                                                                                       */
  unsigned int NOCRC      : BFW_NX90_biss_ccc1_mc0_NOCRC;      /* CRC for SCD not to be stored in RAM                                                                                   */
                                                               /* 0: CRC of SCD is stored RAM (only applicable with active CRC verification and CRC polynome > 0)                       */
                                                               /* 1: CRC of SCD not to be stored in RAM                                                                                 */
  unsigned int reserved3  : BFW_NX90_biss_ccc1_mc0_reserved3;  /* reserved                                                                                                              */
} NX90_BISS_CCC1_MC0_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_BISS_CCC1_MC0_BIT_T bf;
} NX90_BISS_CCC1_MC0_T;

/* --------------------------------------------------------------------- */
/* Register biss_mc1 */
/* => Master Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_mc1       0x000000E8U
#define Adr_NX90_biss0_app_biss_mc1 0xFF801BE8U
#define Adr_NX90_biss1_app_biss_mc1 0xFF801CE8U
#define DFLT_VAL_NX90_biss_mc1      0x00000000U

#define MSK_NX90_biss_mc1_FREQAGS          0x000000ffU
#define SRT_NX90_biss_mc1_FREQAGS          0
#define DFLT_VAL_NX90_biss_mc1_FREQAGS     0x00000000U
#define DFLT_BF_VAL_NX90_biss_mc1_FREQAGS  0x00000000U
#define MSK_NX90_biss_mc1_MO_BUSY          0x0000ff00U
#define SRT_NX90_biss_mc1_MO_BUSY          8
#define DFLT_VAL_NX90_biss_mc1_MO_BUSY     0x00000000U
#define DFLT_BF_VAL_NX90_biss_mc1_MO_BUSY  0x00000000U
#define MSK_NX90_biss_mc1_REVISION         0x00ff0000U
#define SRT_NX90_biss_mc1_REVISION         16
#define DFLT_VAL_NX90_biss_mc1_REVISION    0x00000000U
#define DFLT_BF_VAL_NX90_biss_mc1_REVISION 0x00000000U
#define MSK_NX90_biss_mc1_VERSION          0xff000000U
#define SRT_NX90_biss_mc1_VERSION          24
#define DFLT_VAL_NX90_biss_mc1_VERSION     0x00000000U
#define DFLT_BF_VAL_NX90_biss_mc1_VERSION  0x00000000U

/* all used bits of 'NX90_biss_mc1': */
#define MSK_USED_BITS_NX90_biss_mc1 0xffffffffU

enum {
  BFW_NX90_biss_mc1_FREQAGS  = 8, /* [7:0] */
  BFW_NX90_biss_mc1_MO_BUSY  = 8, /* [15:8] */
  BFW_NX90_biss_mc1_REVISION = 8, /* [23:16] */
  BFW_NX90_biss_mc1_VERSION  = 8  /* [31:24] */
};

typedef struct NX90_BISS_MC1_BIT_Ttag {
  unsigned int FREQAGS  : BFW_NX90_biss_mc1_FREQAGS;  /* AutoGetSens Frequency division                                                                                                                                                           */
                                                      /* 0x00.. 0x7b: fCLK/(20*(FREQAGS(6:0)+1))                                                                                                                                                  */
                                                      /* 0x7c       : AGSMIN( the master automatically restarts the next cycle after the prior was finished. AGSMIN is the fastest SCD rate with complete SCD cycles. )                           */
                                                      /* 0x7d.. 0x7f: AGSINFINITE( the master does not automatically restart the next cycle after the prior one was finished. AGSINFINITE requires a trigger event to start the next SCD cycle. ) */
                                                      /* 0x80.. 0xff: fCLK/(625*(FREQAGS(6:0)+1))                                                                                                                                                 */
  unsigned int MO_BUSY  : BFW_NX90_biss_mc1_MO_BUSY;  /* Delay of start bit at output MOx                                                                                                                                                         */
                                                      /* 0x00 .. 0xff: count of MA clocks as the parameterized processing time by master on MO signal                                                                                             */
                                                      /* Premise: EN_MO = 1                                                                                                                                                                       */
  unsigned int REVISION : BFW_NX90_biss_mc1_REVISION; /* Revision                                                                                                                                                                                 */
                                                      /* 0x10: Z(first revision)                                                                                                                                                                  */
                                                      /* 0x11: Z1                                                                                                                                                                                 */
                                                      /* 0x12: Y                                                                                                                                                                                  */
                                                      /* .. 0xff                                                                                                                                                                                  */
  unsigned int VERSION  : BFW_NX90_biss_mc1_VERSION;  /* Device identifier                                                                                                                                                                        */
                                                      /* 0x83: iC-MB3                                                                                                                                                                             */
                                                      /* 0x84: iC-MB4                                                                                                                                                                             */
                                                      /* .. 0xff                                                                                                                                                                                  */
} NX90_BISS_MC1_BIT_T;

typedef union {
  uint32_t            val;
  NX90_BISS_MC1_BIT_T bf;
} NX90_BISS_MC1_T;

/* --------------------------------------------------------------------- */
/* Register biss_cc_sl */
/* => Channel Configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_cc_sl       0x000000ECU
#define Adr_NX90_biss0_app_biss_cc_sl 0xFF801BECU
#define Adr_NX90_biss1_app_biss_cc_sl 0xFF801CECU
#define DFLT_VAL_NX90_biss_cc_sl      0x00000001U

#define MSK_NX90_biss_cc_sl_cc_sl_reserved1         0x0000000fU
#define SRT_NX90_biss_cc_sl_cc_sl_reserved1         0
#define DFLT_VAL_NX90_biss_cc_sl_cc_sl_reserved1    0x00000001U
#define DFLT_BF_VAL_NX90_biss_cc_sl_cc_sl_reserved1 0x00000001U
#define MSK_NX90_biss_cc_sl_SLAVELOC5               0x00000010U
#define SRT_NX90_biss_cc_sl_SLAVELOC5               4
#define DFLT_VAL_NX90_biss_cc_sl_SLAVELOC5          0x00000000U
#define DFLT_BF_VAL_NX90_biss_cc_sl_SLAVELOC5       0x00000000U
#define MSK_NX90_biss_cc_sl_CFGCH1                  0x00000300U
#define SRT_NX90_biss_cc_sl_CFGCH1                  8
#define DFLT_VAL_NX90_biss_cc_sl_CFGCH1             0x00000000U
#define DFLT_BF_VAL_NX90_biss_cc_sl_CFGCH1          0x00000000U
#define MSK_NX90_biss_cc_sl_CFGCH2                  0x00000c00U
#define SRT_NX90_biss_cc_sl_CFGCH2                  10
#define DFLT_VAL_NX90_biss_cc_sl_CFGCH2             0x00000000U
#define DFLT_BF_VAL_NX90_biss_cc_sl_CFGCH2          0x00000000U
#define MSK_NX90_biss_cc_sl_ACTnSENS                0xff000000U
#define SRT_NX90_biss_cc_sl_ACTnSENS                24
#define DFLT_VAL_NX90_biss_cc_sl_ACTnSENS           0x00000000U
#define DFLT_BF_VAL_NX90_biss_cc_sl_ACTnSENS        0x00000000U

/* all used bits of 'NX90_biss_cc_sl': */
#define MSK_USED_BITS_NX90_biss_cc_sl 0xff000f1fU

enum {
  BFW_NX90_biss_cc_sl_cc_sl_reserved1 = 4,  /* [3:0] */
  BFW_NX90_biss_cc_sl_SLAVELOC5       = 1,  /* [4] */
  BFW_NX90_biss_cc_sl_reserved1       = 3,  /* [7:5] */
  BFW_NX90_biss_cc_sl_CFGCH1          = 2,  /* [9:8] */
  BFW_NX90_biss_cc_sl_CFGCH2          = 2,  /* [11:10] */
  BFW_NX90_biss_cc_sl_reserved2       = 12, /* [23:12] */
  BFW_NX90_biss_cc_sl_ACTnSENS        = 8   /* [31:24] */
};

typedef struct NX90_BISS_CC_SL_BIT_Ttag {
  unsigned int cc_sl_reserved1 : BFW_NX90_biss_cc_sl_cc_sl_reserved1; /*                                                                            */
  unsigned int SLAVELOC5       : BFW_NX90_biss_cc_sl_SLAVELOC5;       /* Slave location                                                             */
                                                                      /* 0: slaves 4-7 are connected to channel 1                                   */
                                                                      /* 1: slaves 4-7 are connected to channel 2(only available with iC-MB4 QFN28) */
  unsigned int reserved1       : BFW_NX90_biss_cc_sl_reserved1;       /* reserved                                                                   */
  unsigned int CFGCH1          : BFW_NX90_biss_cc_sl_CFGCH1;          /* Channel 1 configuration                                                    */
                                                                      /* 0x00: BiSS B                                                               */
                                                                      /* 0x01: BiSS C                                                               */
                                                                      /* 0x02: SSI                                                                  */
                                                                      /* 0x03: channel is not used                                                  */
  unsigned int CFGCH2          : BFW_NX90_biss_cc_sl_CFGCH2;          /* Channel 2 configuration                                                    */
                                                                      /* 0x00: BiSS B                                                               */
                                                                      /* 0x01: BiSS C                                                               */
                                                                      /* 0x02: SSI                                                                  */
                                                                      /* 0x03: channel is not used                                                  */
  unsigned int reserved2       : BFW_NX90_biss_cc_sl_reserved2;       /* reserved                                                                   */
  unsigned int ACTnSENS        : BFW_NX90_biss_cc_sl_ACTnSENS;        /* Sensor or actuator data selector                                           */
                                                                      /* 0x00: all slaves are sensors                                               */
                                                                      /* 0x01: slave 0 is actuator                                                  */
                                                                      /* 0x02: slave 1 is actuator                                                  */
                                                                      /* 0x04: slave 2 is actuator                                                  */
                                                                      /* 0x08: slave 3 is actuator                                                  */
                                                                      /* 0x10: slave 4 is actuator                                                  */
                                                                      /* 0x20: slave 5 is actuator                                                  */
                                                                      /* 0x40: slave 6 is actuator                                                  */
                                                                      /* 0x80: slave 7 is actuator                                                  */
                                                                      /* 0xff: all slaves are actuators                                             */
} NX90_BISS_CC_SL_BIT_T;

typedef union {
  uint32_t              val;
  NX90_BISS_CC_SL_BIT_T bf;
} NX90_BISS_CC_SL_T;

/* --------------------------------------------------------------------- */
/* Register biss_status0 */
/* => Status Information */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_status0       0x000000F0U
#define Adr_NX90_biss0_app_biss_status0 0xFF801BF0U
#define Adr_NX90_biss1_app_biss_status0 0xFF801CF0U

#define MSK_NX90_biss_status0_EOT               0x00000001U
#define SRT_NX90_biss_status0_EOT               0
#define MSK_NX90_biss_status0_status0_reserved1 0x00000002U
#define SRT_NX90_biss_status0_status0_reserved1 1
#define MSK_NX90_biss_status0_REGEND            0x00000004U
#define SRT_NX90_biss_status0_REGEND            2
#define MSK_NX90_biss_status0_nREGERR           0x00000008U
#define SRT_NX90_biss_status0_nREGERR           3
#define MSK_NX90_biss_status0_nSCDERR           0x00000010U
#define SRT_NX90_biss_status0_nSCDERR           4
#define MSK_NX90_biss_status0_nDELAYERR         0x00000020U
#define SRT_NX90_biss_status0_nDELAYERR         5
#define MSK_NX90_biss_status0_nAGSERR           0x00000040U
#define SRT_NX90_biss_status0_nAGSERR           6
#define MSK_NX90_biss_status0_nERR              0x00000080U
#define SRT_NX90_biss_status0_nERR              7
#define MSK_NX90_biss_status0_SVALID0           0x00000200U
#define SRT_NX90_biss_status0_SVALID0           9
#define MSK_NX90_biss_status0_SVALID1           0x00000800U
#define SRT_NX90_biss_status0_SVALID1           11
#define MSK_NX90_biss_status0_SVALID2           0x00002000U
#define SRT_NX90_biss_status0_SVALID2           13
#define MSK_NX90_biss_status0_SVALID3           0x00008000U
#define SRT_NX90_biss_status0_SVALID3           15
#define MSK_NX90_biss_status0_SVALID4           0x00020000U
#define SRT_NX90_biss_status0_SVALID4           17
#define MSK_NX90_biss_status0_SVALID5           0x00080000U
#define SRT_NX90_biss_status0_SVALID5           19
#define MSK_NX90_biss_status0_SVALID6           0x00200000U
#define SRT_NX90_biss_status0_SVALID6           21
#define MSK_NX90_biss_status0_SVALID7           0x00800000U
#define SRT_NX90_biss_status0_SVALID7           23
#define MSK_NX90_biss_status0_REGBYTES          0x3f000000U
#define SRT_NX90_biss_status0_REGBYTES          24
#define MSK_NX90_biss_status0_CDSSEL            0x40000000U
#define SRT_NX90_biss_status0_CDSSEL            30
#define MSK_NX90_biss_status0_CDMTIMEOUT        0x80000000U
#define SRT_NX90_biss_status0_CDMTIMEOUT        31

/* all used bits of 'NX90_biss_status0': */
#define MSK_USED_BITS_NX90_biss_status0 0xffaaaaffU

enum {
  BFW_NX90_biss_status0_EOT               = 1, /* [0] */
  BFW_NX90_biss_status0_status0_reserved1 = 1, /* [1] */
  BFW_NX90_biss_status0_REGEND            = 1, /* [2] */
  BFW_NX90_biss_status0_nREGERR           = 1, /* [3] */
  BFW_NX90_biss_status0_nSCDERR           = 1, /* [4] */
  BFW_NX90_biss_status0_nDELAYERR         = 1, /* [5] */
  BFW_NX90_biss_status0_nAGSERR           = 1, /* [6] */
  BFW_NX90_biss_status0_nERR              = 1, /* [7] */
  BFW_NX90_biss_status0_reserved1         = 1, /* [8] */
  BFW_NX90_biss_status0_SVALID0           = 1, /* [9] */
  BFW_NX90_biss_status0_reserved2         = 1, /* [10] */
  BFW_NX90_biss_status0_SVALID1           = 1, /* [11] */
  BFW_NX90_biss_status0_reserved3         = 1, /* [12] */
  BFW_NX90_biss_status0_SVALID2           = 1, /* [13] */
  BFW_NX90_biss_status0_reserved4         = 1, /* [14] */
  BFW_NX90_biss_status0_SVALID3           = 1, /* [15] */
  BFW_NX90_biss_status0_reserved5         = 1, /* [16] */
  BFW_NX90_biss_status0_SVALID4           = 1, /* [17] */
  BFW_NX90_biss_status0_reserved6         = 1, /* [18] */
  BFW_NX90_biss_status0_SVALID5           = 1, /* [19] */
  BFW_NX90_biss_status0_reserved7         = 1, /* [20] */
  BFW_NX90_biss_status0_SVALID6           = 1, /* [21] */
  BFW_NX90_biss_status0_reserved8         = 1, /* [22] */
  BFW_NX90_biss_status0_SVALID7           = 1, /* [23] */
  BFW_NX90_biss_status0_REGBYTES          = 6, /* [29:24] */
  BFW_NX90_biss_status0_CDSSEL            = 1, /* [30] */
  BFW_NX90_biss_status0_CDMTIMEOUT        = 1  /* [31] */
};

typedef struct NX90_BISS_STATUS0_BIT_Ttag {
  unsigned int EOT               : BFW_NX90_biss_status0_EOT;               /* Data transmission completed                                                                                                                                                                                  */
                                                                            /* 0: data transmission active                                                                                                                                                                                  */
                                                                            /* 1: data transmission finished                                                                                                                                                                                */
  unsigned int status0_reserved1 : BFW_NX90_biss_status0_status0_reserved1; /* reserved                                                                                                                                                                                                     */
  unsigned int REGEND            : BFW_NX90_biss_status0_REGEND;            /* Register data transmission completed                                                                                                                                                                         */
                                                                            /* 0: no valid register data available                                                                                                                                                                          */
                                                                            /* 1: register data transmission completed                                                                                                                                                                      */
  unsigned int nREGERR           : BFW_NX90_biss_status0_nREGERR;           /* Error in register data transmission                                                                                                                                                                          */
                                                                            /* 0: error in last register data transmission                                                                                                                                                                  */
                                                                            /* 1: no error in last register data transmission                                                                                                                                                               */
  unsigned int nSCDERR           : BFW_NX90_biss_status0_nSCDERR;           /* Error in single cycle data transmission                                                                                                                                                                      */
                                                                            /* 0: error in last single cycle data transmission                                                                                                                                                              */
                                                                            /* 1: no error in last single cycle data transmission                                                                                                                                                           */
  unsigned int nDELAYERR         : BFW_NX90_biss_status0_nDELAYERR;         /* Missing start bit during register communication                                                                                                                                                              */
                                                                            /* 0: delay error                                                                                                                                                                                               */
                                                                            /* 1: no delay error                                                                                                                                                                                            */
  unsigned int nAGSERR           : BFW_NX90_biss_status0_nAGSERR;           /* AGS error                                                                                                                                                                                                    */
                                                                            /* 0: AGS(Automatic Get Sensor data) watchdog error                                                                                                                                                             */
                                                                            /* 1: no AGS watchdog error                                                                                                                                                                                     */
                                                                            /* An AGS watchdog error is set during the automatic transmission of sensor data if no new cycle could be initiated; bit AGS in the command register is reset and the automatic request of sensor data aborted. */
  unsigned int nERR              : BFW_NX90_biss_status0_nERR;              /* Transmission error (error at NER pin)                                                                                                                                                                        */
                                                                            /* 0: error                                                                                                                                                                                                     */
                                                                            /* 1: no error                                                                                                                                                                                                  */
                                                                            /* It is possible to connect other components to pin NER which can also generate an error message; this can then be read out via this bit.                                                                      */
  unsigned int reserved1         : BFW_NX90_biss_status0_reserved1;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID0           : BFW_NX90_biss_status0_SVALID0;           /* SCDATA0 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int reserved2         : BFW_NX90_biss_status0_reserved2;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID1           : BFW_NX90_biss_status0_SVALID1;           /* SCDATA1 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int reserved3         : BFW_NX90_biss_status0_reserved3;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID2           : BFW_NX90_biss_status0_SVALID2;           /* SCDATA2 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int reserved4         : BFW_NX90_biss_status0_reserved4;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID3           : BFW_NX90_biss_status0_SVALID3;           /* SCDATA3 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int reserved5         : BFW_NX90_biss_status0_reserved5;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID4           : BFW_NX90_biss_status0_SVALID4;           /* SCDATA4 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int reserved6         : BFW_NX90_biss_status0_reserved6;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID5           : BFW_NX90_biss_status0_SVALID5;           /* SCDATA5 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int reserved7         : BFW_NX90_biss_status0_reserved7;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID6           : BFW_NX90_biss_status0_SVALID6;           /* SCDATA6 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int reserved8         : BFW_NX90_biss_status0_reserved8;         /* reserved                                                                                                                                                                                                     */
  unsigned int SVALID7           : BFW_NX90_biss_status0_SVALID7;           /* SCDATA7 validity indication                                                                                                                                                                                  */
                                                                            /* 0: SCD invalid                                                                                                                                                                                               */
                                                                            /* 1: SCD valid                                                                                                                                                                                                 */
                                                                            /* The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register.                                                             */
  unsigned int REGBYTES          : BFW_NX90_biss_status0_REGBYTES;          /* Number of valid register data transmission in case of error                                                                                                                                                  */
                                                                            /* 0x00       : after transfer: no register communication error                                                                                                                                                 */
                                                                            /* 0x01 . 0x3f: after transfer: number of successfully transferred registers before register communication error                                                                                                */
  unsigned int CDSSEL            : BFW_NX90_biss_status0_CDSSEL;            /* CDS(Control Data Slave) bit from the selected channel                                                                                                                                                        */
  unsigned int CDMTIMEOUT        : BFW_NX90_biss_status0_CDMTIMEOUT;        /* CDM(Control Data Master) timeout reached                                                                                                                                                                     */
                                                                            /* 0: CDMTIMEOUT not reached                                                                                                                                                                                    */
                                                                            /* 1: CDMTIMEOUT reached                                                                                                                                                                                        */
} NX90_BISS_STATUS0_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_STATUS0_BIT_T bf;
} NX90_BISS_STATUS0_T;

/* --------------------------------------------------------------------- */
/* Register biss_ir */
/* => Instruction Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ir       0x000000F4U
#define Adr_NX90_biss0_app_biss_ir 0xFF801BF4U
#define Adr_NX90_biss1_app_biss_ir 0xFF801CF4U
#define DFLT_VAL_NX90_biss_ir      0x00000000U

#define MSK_NX90_biss_ir_AGS              0x00000001U
#define SRT_NX90_biss_ir_AGS              0
#define DFLT_VAL_NX90_biss_ir_AGS         0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_AGS      0x00000000U
#define MSK_NX90_biss_ir_INSTR            0x0000000eU
#define SRT_NX90_biss_ir_INSTR            1
#define DFLT_VAL_NX90_biss_ir_INSTR       0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_INSTR    0x00000000U
#define MSK_NX90_biss_ir_INIT             0x00000010U
#define SRT_NX90_biss_ir_INIT             4
#define DFLT_VAL_NX90_biss_ir_INIT        0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_INIT     0x00000000U
#define MSK_NX90_biss_ir_SWBANK           0x00000020U
#define SRT_NX90_biss_ir_SWBANK           5
#define DFLT_VAL_NX90_biss_ir_SWBANK      0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_SWBANK   0x00000000U
#define MSK_NX90_biss_ir_HOLDBANK         0x00000040U
#define SRT_NX90_biss_ir_HOLDBANK         6
#define DFLT_VAL_NX90_biss_ir_HOLDBANK    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_HOLDBANK 0x00000000U
#define MSK_NX90_biss_ir_BREAK            0x00000080U
#define SRT_NX90_biss_ir_BREAK            7
#define DFLT_VAL_NX90_biss_ir_BREAK       0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_BREAK    0x00000000U
#define MSK_NX90_biss_ir_CLKENI           0x00000100U
#define SRT_NX90_biss_ir_CLKENI           8
#define DFLT_VAL_NX90_biss_ir_CLKENI      0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_CLKENI   0x00000000U
#define MSK_NX90_biss_ir_ENTEST           0x00000200U
#define SRT_NX90_biss_ir_ENTEST           9
#define DFLT_VAL_NX90_biss_ir_ENTEST      0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_ENTEST   0x00000000U
#define MSK_NX90_biss_ir_CFGIF            0x00000c00U
#define SRT_NX90_biss_ir_CFGIF            10
#define DFLT_VAL_NX90_biss_ir_CFGIF       0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_CFGIF    0x00000000U
#define MSK_NX90_biss_ir_MAFS             0x00001000U
#define SRT_NX90_biss_ir_MAFS             12
#define DFLT_VAL_NX90_biss_ir_MAFS        0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_MAFS     0x00000000U
#define MSK_NX90_biss_ir_MAVS             0x00002000U
#define SRT_NX90_biss_ir_MAVS             13
#define DFLT_VAL_NX90_biss_ir_MAVS        0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_MAVS     0x00000000U
#define MSK_NX90_biss_ir_MAFO             0x00004000U
#define SRT_NX90_biss_ir_MAFO             14
#define DFLT_VAL_NX90_biss_ir_MAFO        0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_MAFO     0x00000000U
#define MSK_NX90_biss_ir_MAVO             0x00008000U
#define SRT_NX90_biss_ir_MAVO             15
#define DFLT_VAL_NX90_biss_ir_MAVO        0x00000000U
#define DFLT_BF_VAL_NX90_biss_ir_MAVO     0x00000000U

/* all used bits of 'NX90_biss_ir': */
#define MSK_USED_BITS_NX90_biss_ir 0x0000ffffU

enum {
  BFW_NX90_biss_ir_AGS       = 1,  /* [0] */
  BFW_NX90_biss_ir_INSTR     = 3,  /* [3:1] */
  BFW_NX90_biss_ir_INIT      = 1,  /* [4] */
  BFW_NX90_biss_ir_SWBANK    = 1,  /* [5] */
  BFW_NX90_biss_ir_HOLDBANK  = 1,  /* [6] */
  BFW_NX90_biss_ir_BREAK     = 1,  /* [7] */
  BFW_NX90_biss_ir_CLKENI    = 1,  /* [8] */
  BFW_NX90_biss_ir_ENTEST    = 1,  /* [9] */
  BFW_NX90_biss_ir_CFGIF     = 2,  /* [11:10] */
  BFW_NX90_biss_ir_MAFS      = 1,  /* [12] */
  BFW_NX90_biss_ir_MAVS      = 1,  /* [13] */
  BFW_NX90_biss_ir_MAFO      = 1,  /* [14] */
  BFW_NX90_biss_ir_MAVO      = 1,  /* [15] */
  BFW_NX90_biss_ir_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_BISS_IR_BIT_Ttag {
  unsigned int AGS       : BFW_NX90_biss_ir_AGS;       /* AutoGetSens(Automatic Get Sensordata)                                                                                                                                                          */
                                                       /* 0: no automatic data transmission                                                                                                                                                              */
                                                       /* 1: - start of data transmission after TIMEOUTSENS                                                                                                                                              */
                                                       /*      condition: FREQAGS = AGSMIN                                                                                                                                                               */
                                                       /*    - start of data transmission triggered by pin                                                                                                                                               */
                                                       /*      condition: FREQAGS = AGSINFINITE                                                                                                                                                          */
                                                       /*    - start of data transmission after timeout                                                                                                                                                  */
                                                       /* With AGS = 0 the master starts the data transmission after finishing writing the instruction register(rising edge of NWR).                                                                     */
                                                       /* A nAGSERR error will be generated if the SL line is low, TIMEOUTSENS has not exceeded. If an AGS bit has been set sensor data is read in                                                       */
                                                       /* cyclically according to the cycle frequency set in FREQAGS.                                                                                                                                    */
  unsigned int INSTR     : BFW_NX90_biss_ir_INSTR;     /* SCD control instruction                                                                                                                                                                        */
                                                       /* 0b010       : CDM = 0                                                                                                                                                                          */
                                                       /* 0b001       : CDM = 1                                                                                                                                                                          */
                                                       /* 0b100, 0b110: register communication                                                                                                                                                           */
                                                       /*               condition: CDMTIMEOUT = 1                                                                                                                                                        */
                                                       /* 0b111       : register communication(reduced protocol)                                                                                                                                         */
                                                       /*               condition: CDMTIMEOUT = 1                                                                                                                                                        */
                                                       /* The transmission of sensor data can be triggered via INSTR. With INSTR=0b010 the ccle finishes with a CDM=0.                                                                                   */
                                                       /* With INSTR= 0b001 the cycle finishes with a CDM=1. A BiSS C register access to a slave can be operated by INSTR=0b100.                                                                         */
                                                       /* A reduced protocol for a shorter BiSS C register access to a slave can be operated by INST=0b111.                                                                                              */
  unsigned int INIT      : BFW_NX90_biss_ir_INIT;      /* Start INIT sequence                                                                                                                                                                            */
                                                       /* 0: no changes on the data channel                                                                                                                                                              */
                                                       /* 1: initialize data channel                                                                                                                                                                     */
  unsigned int SWBANK    : BFW_NX90_biss_ir_SWBANK;    /* Switch RAM banks                                                                                                                                                                               */
                                                       /* 0: RAM banks are not switched                                                                                                                                                                  */
                                                       /* 1: RAM banks are switched                                                                                                                                                                      */
  unsigned int HOLDBANK  : BFW_NX90_biss_ir_HOLDBANK;  /* RAM bank control                                                                                                                                                                               */
                                                       /* 0: no bank switching lock permitted                                                                                                                                                            */
                                                       /* 1: bank switching lock permitted                                                                                                                                                               */
                                                       /* During the readout of more than one sensor data register by the controller it is possible that the RAM banks in the master could be swapped over once a sensor data transmission is completed. */
                                                       /* So that the controller only reads related values bit HOLDBANK should be set at the start of the readout and reset at the end; this suppresses the RAM swap.                                    */
                                                       /* With the start of a new sensor data cycle previous values are then overwritten by the new sensor data.                                                                                         */
  unsigned int BREAK     : BFW_NX90_biss_ir_BREAK;     /* Data transmission interrupt                                                                                                                                                                    */
                                                       /* 0: no change                                                                                                                                                                                   */
                                                       /* 1: abort data transmission                                                                                                                                                                     */
                                                       /*    nSCDERR, nREGERR, nDELAYERR, nAGSERR = 1,                                                                                                                                                   */
                                                       /*    REGEND = 0                                                                                                                                                                                  */
                                                       /* All current actions can be aborted using the BREAK command so that a defined state can be resumed if one of the sensors proves faulty, for example.                                            */
                                                       /* BREAK= 1 aborts the active data transmission and all status information will be reset.                                                                                                         */
  unsigned int CLKENI    : BFW_NX90_biss_ir_CLKENI;    /* Enable internal clock                                                                                                                                                                          */
                                                       /* 0: the master clock is generated by an external clock oscillator                                                                                                                               */
                                                       /* 1: the master clock is generated by the basic clock of the internal 20MHz oscillator                                                                                                           */
  unsigned int ENTEST    : BFW_NX90_biss_ir_ENTEST;    /* Enable test interface                                                                                                                                                                          */
                                                       /* 0: device in normal operation mode                                                                                                                                                             */
                                                       /* 1: device in test mode                                                                                                                                                                         */
  unsigned int CFGIF     : BFW_NX90_biss_ir_CFGIF;     /* Configure physical interface                                                                                                                                                                   */
                                                       /* 0x00: TTL                                                                                                                                                                                      */
                                                       /* 0x01: CMOS                                                                                                                                                                                     */
                                                       /* 0x02: RS422                                                                                                                                                                                    */
                                                       /* 0x03: LVDS                                                                                                                                                                                     */
  unsigned int MAFS      : BFW_NX90_biss_ir_MAFS;      /* Selected MA line control selection                                                                                                                                                             */
                                                       /* 0: controlling selected/CHSEL) MA clock line: using MA signal                                                                                                                                  */
                                                       /* 1: controlling selected(CHSEL) MA clock line: using MAVS level                                                                                                                                 */
  unsigned int MAVS      : BFW_NX90_biss_ir_MAVS;      /* Selected MA line control level                                                                                                                                                                 */
                                                       /* 0: low definition of selected(CHSEL) MA clock lines                                                                                                                                            */
                                                       /* 1: high definition of selected(CHSEL) MA clock lines                                                                                                                                           */
  unsigned int MAFO      : BFW_NX90_biss_ir_MAFO;      /* Not selected MA line control selection                                                                                                                                                         */
                                                       /* 0: controlling unselected(CHSEL) MA clock line: using MA signal                                                                                                                                */
                                                       /* 1: controlling unselected(CHSEL) MA clock line: using MAVS level                                                                                                                               */
  unsigned int MAVO      : BFW_NX90_biss_ir_MAVO;      /* Not selected MA line control level                                                                                                                                                             */
                                                       /* 0: low definition of unselected(CHSEL) MA clock lines                                                                                                                                          */
                                                       /* 1: high definition of unselected(CHSEL) MA clock lines                                                                                                                                         */
  unsigned int reserved1 : BFW_NX90_biss_ir_reserved1; /* reserved                                                                                                                                                                                       */
} NX90_BISS_IR_BIT_T;

typedef union {
  uint32_t           val;
  NX90_BISS_IR_BIT_T bf;
} NX90_BISS_IR_T;

/* --------------------------------------------------------------------- */
/* Register biss_status1 */
/* => Status Information */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_status1       0x000000F8U
#define Adr_NX90_biss0_app_biss_status1 0xFF801BF8U
#define Adr_NX90_biss1_app_biss_status1 0xFF801CF8U

#define MSK_NX90_biss_status1_SL1         0x00000001U
#define SRT_NX90_biss_status1_SL1         0
#define MSK_NX90_biss_status1_CDS1        0x00000002U
#define SRT_NX90_biss_status1_CDS1        1
#define MSK_NX90_biss_status1_SWBANKFAILS 0x01000000U
#define SRT_NX90_biss_status1_SWBANKFAILS 24

/* all used bits of 'NX90_biss_status1': */
#define MSK_USED_BITS_NX90_biss_status1 0x01000003U

enum {
  BFW_NX90_biss_status1_SL1         = 1,  /* [0] */
  BFW_NX90_biss_status1_CDS1        = 1,  /* [1] */
  BFW_NX90_biss_status1_reserved1   = 22, /* [23:2] */
  BFW_NX90_biss_status1_SWBANKFAILS = 1,  /* [24] */
  BFW_NX90_biss_status1_reserved2   = 7   /* [31:25] */
};

typedef struct NX90_BISS_STATUS1_BIT_Ttag {
  unsigned int SL1         : BFW_NX90_biss_status1_SL1;         /* Current SL line level of channel 1    */
                                                                /* 0: SL line level low                  */
                                                                /* 1: SL line level high                 */
  unsigned int CDS1        : BFW_NX90_biss_status1_CDS1;        /* CDS bit of channel 1                  */
                                                                /* 0: CDS = 0                            */
                                                                /* 1: CDS = 1                            */
  unsigned int reserved1   : BFW_NX90_biss_status1_reserved1;   /* reserved                              */
  unsigned int SWBANKFAILS : BFW_NX90_biss_status1_SWBANKFAILS; /* Bank switching status                 */
                                                                /* 0: bank switching(SCD) successful     */
                                                                /* 1: bank switching(SCD) not successful */
  unsigned int reserved2   : BFW_NX90_biss_status1_reserved2;   /* reserved                              */
} NX90_BISS_STATUS1_BIT_T;

typedef union {
  uint32_t                val;
  NX90_BISS_STATUS1_BIT_T bf;
} NX90_BISS_STATUS1_T;


/* ===================================================================== */

/* AREA biss_ctrl */
/* Area of biss_ctrl0_app, biss_ctrl1_app */

/* ===================================================================== */

#define Addr_NX90_biss_ctrl0_app 0xFF801D00U
#define Addr_NX90_biss_ctrl1_app 0xFF801D20U

/* --------------------------------------------------------------------- */
/* Register biss_ctrl_trigger_cfg */
/* => BiSS trigger configuration */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ctrl_trigger_cfg            0x00000000U
#define Adr_NX90_biss_ctrl0_app_biss_ctrl_trigger_cfg 0xFF801D00U
#define Adr_NX90_biss_ctrl1_app_biss_ctrl_trigger_cfg 0xFF801D20U
#define DFLT_VAL_NX90_biss_ctrl_trigger_cfg           0x00000000U

#define MSK_NX90_biss_ctrl_trigger_cfg_sel         0x0000000fU
#define SRT_NX90_biss_ctrl_trigger_cfg_sel         0
#define DFLT_VAL_NX90_biss_ctrl_trigger_cfg_sel    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_trigger_cfg_sel 0x00000000U

/* all used bits of 'NX90_biss_ctrl_trigger_cfg': */
#define MSK_USED_BITS_NX90_biss_ctrl_trigger_cfg 0x0000000fU

enum {
  BFW_NX90_biss_ctrl_trigger_cfg_sel       = 4,  /* [3:0] */
  BFW_NX90_biss_ctrl_trigger_cfg_reserved1 = 28  /* [31:4] */
};

typedef struct NX90_BISS_CTRL_TRIGGER_CFG_BIT_Ttag {
  unsigned int sel       : BFW_NX90_biss_ctrl_trigger_cfg_sel;       /* Trigger source select                                                         */
                                                                     /* This bit field configures which event is connected to the GETSENS signal      */
                                                                     /* of the BiSS core. A rising edge of the selected event will generate an event  */
                                                                     /* to the core.                                                                  */
                                                                     /* {       |                                                                     */
                                                                     /*  Value   trigger event                                                        */
                                                                     /*  0       none                                                                 */
                                                                     /*  1       manual                                                               */
                                                                     /*  2       xc_trigger_out0                                                      */
                                                                     /*  3       xc_trigger_out0 (inverted)                                           */
                                                                     /*  4       xc_trigger_out1                                                      */
                                                                     /*  5       xc_trigger_out1 (inverted)                                           */
                                                                     /*  6       xc_sample_in0                                                        */
                                                                     /*  7       xc_sample_in0 (inverted)                                             */
                                                                     /*  8       xc_sample_in1                                                        */
                                                                     /*  9       xc_sample_in1 (inverted)                                             */
                                                                     /*  10      gpio_app_counter_zero0                                               */
                                                                     /*  11      gpio_app_counter_zero1                                               */
                                                                     /*  12      gpio_app_counter_zero2                                               */
                                                                     /*  13-15   reserved }                                                           */
  unsigned int reserved1 : BFW_NX90_biss_ctrl_trigger_cfg_reserved1; /* reserved                                                                      */
} NX90_BISS_CTRL_TRIGGER_CFG_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_BISS_CTRL_TRIGGER_CFG_BIT_T bf;
} NX90_BISS_CTRL_TRIGGER_CFG_T;

/* --------------------------------------------------------------------- */
/* Register biss_ctrl_trigger */
/* => BiSS trigger */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ctrl_trigger            0x00000004U
#define Adr_NX90_biss_ctrl0_app_biss_ctrl_trigger 0xFF801D04U
#define Adr_NX90_biss_ctrl1_app_biss_ctrl_trigger 0xFF801D24U
#define DFLT_VAL_NX90_biss_ctrl_trigger           0x00000000U

#define MSK_NX90_biss_ctrl_trigger_manual         0x00000001U
#define SRT_NX90_biss_ctrl_trigger_manual         0
#define DFLT_VAL_NX90_biss_ctrl_trigger_manual    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_trigger_manual 0x00000000U

/* all used bits of 'NX90_biss_ctrl_trigger': */
#define MSK_USED_BITS_NX90_biss_ctrl_trigger 0x00000001U

enum {
  BFW_NX90_biss_ctrl_trigger_manual    = 1,  /* [0] */
  BFW_NX90_biss_ctrl_trigger_reserved1 = 31  /* [31:1] */
};

typedef struct NX90_BISS_CTRL_TRIGGER_BIT_Ttag {
  unsigned int manual    : BFW_NX90_biss_ctrl_trigger_manual;    /* Manual trigger.                                                           */
                                                                 /* Writing '1' to this bit will trigger the BiSS core immediately in case    */
                                                                 /* the trigger_cfg.sel bit field is set to manual mode and the BiSS core is  */
                                                                 /* setup for external triggering by the GETSENS signal.                      */
  unsigned int reserved1 : BFW_NX90_biss_ctrl_trigger_reserved1; /* reserved                                                                  */
} NX90_BISS_CTRL_TRIGGER_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_BISS_CTRL_TRIGGER_BIT_T bf;
} NX90_BISS_CTRL_TRIGGER_T;

/* --------------------------------------------------------------------- */
/* Register biss_ctrl_irq_raw */
/* => BiSS raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ctrl_irq_raw            0x00000008U
#define Adr_NX90_biss_ctrl0_app_biss_ctrl_irq_raw 0xFF801D08U
#define Adr_NX90_biss_ctrl1_app_biss_ctrl_irq_raw 0xFF801D28U
#define DFLT_VAL_NX90_biss_ctrl_irq_raw           0x00000000U

#define MSK_NX90_biss_ctrl_irq_raw_eot         0x00000001U
#define SRT_NX90_biss_ctrl_irq_raw_eot         0
#define DFLT_VAL_NX90_biss_ctrl_irq_raw_eot    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_irq_raw_eot 0x00000000U
#define MSK_NX90_biss_ctrl_irq_raw_err         0x00000002U
#define SRT_NX90_biss_ctrl_irq_raw_err         1
#define DFLT_VAL_NX90_biss_ctrl_irq_raw_err    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_irq_raw_err 0x00000000U

/* all used bits of 'NX90_biss_ctrl_irq_raw': */
#define MSK_USED_BITS_NX90_biss_ctrl_irq_raw 0x00000003U

enum {
  BFW_NX90_biss_ctrl_irq_raw_eot       = 1,  /* [0] */
  BFW_NX90_biss_ctrl_irq_raw_err       = 1,  /* [1] */
  BFW_NX90_biss_ctrl_irq_raw_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_BISS_CTRL_IRQ_RAW_BIT_Ttag {
  unsigned int eot       : BFW_NX90_biss_ctrl_irq_raw_eot;       /* End-Of-Transmission signal from the BiSS core. Only a rising edge on the EOT signal  */
                                                                 /* will set the interrupt.                                                              */
  unsigned int err       : BFW_NX90_biss_ctrl_irq_raw_err;       /* Error signal from the BiSS core. Only a falling edge on the NER signal will set      */
                                                                 /* the interrupt.                                                                       */
  unsigned int reserved1 : BFW_NX90_biss_ctrl_irq_raw_reserved1; /* reserved                                                                             */
} NX90_BISS_CTRL_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_BISS_CTRL_IRQ_RAW_BIT_T bf;
} NX90_BISS_CTRL_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register biss_ctrl_irq_masked */
/* => BiSS masked IRQ: */
/*    Shows status of masked IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ctrl_irq_masked            0x0000000CU
#define Adr_NX90_biss_ctrl0_app_biss_ctrl_irq_masked 0xFF801D0CU
#define Adr_NX90_biss_ctrl1_app_biss_ctrl_irq_masked 0xFF801D2CU

#define MSK_NX90_biss_ctrl_irq_masked_eot 0x00000001U
#define SRT_NX90_biss_ctrl_irq_masked_eot 0
#define MSK_NX90_biss_ctrl_irq_masked_err 0x00000002U
#define SRT_NX90_biss_ctrl_irq_masked_err 1

/* all used bits of 'NX90_biss_ctrl_irq_masked': */
#define MSK_USED_BITS_NX90_biss_ctrl_irq_masked 0x00000003U

enum {
  BFW_NX90_biss_ctrl_irq_masked_eot       = 1,  /* [0] */
  BFW_NX90_biss_ctrl_irq_masked_err       = 1,  /* [1] */
  BFW_NX90_biss_ctrl_irq_masked_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_BISS_CTRL_IRQ_MASKED_BIT_Ttag {
  unsigned int eot       : BFW_NX90_biss_ctrl_irq_masked_eot;       /* End-Of-Transmission signal from the BiSS core. */
  unsigned int err       : BFW_NX90_biss_ctrl_irq_masked_err;       /* Error signal from the BiSS core.               */
  unsigned int reserved1 : BFW_NX90_biss_ctrl_irq_masked_reserved1; /* reserved                                       */
} NX90_BISS_CTRL_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_BISS_CTRL_IRQ_MASKED_BIT_T bf;
} NX90_BISS_CTRL_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register biss_ctrl_irq_msk_set */
/* => BiSS IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to mtgy_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ctrl_irq_msk_set            0x00000010U
#define Adr_NX90_biss_ctrl0_app_biss_ctrl_irq_msk_set 0xFF801D10U
#define Adr_NX90_biss_ctrl1_app_biss_ctrl_irq_msk_set 0xFF801D30U
#define DFLT_VAL_NX90_biss_ctrl_irq_msk_set           0x00000000U

#define MSK_NX90_biss_ctrl_irq_msk_set_eot         0x00000001U
#define SRT_NX90_biss_ctrl_irq_msk_set_eot         0
#define DFLT_VAL_NX90_biss_ctrl_irq_msk_set_eot    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_irq_msk_set_eot 0x00000000U
#define MSK_NX90_biss_ctrl_irq_msk_set_err         0x00000002U
#define SRT_NX90_biss_ctrl_irq_msk_set_err         1
#define DFLT_VAL_NX90_biss_ctrl_irq_msk_set_err    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_irq_msk_set_err 0x00000000U

/* all used bits of 'NX90_biss_ctrl_irq_msk_set': */
#define MSK_USED_BITS_NX90_biss_ctrl_irq_msk_set 0x00000003U

enum {
  BFW_NX90_biss_ctrl_irq_msk_set_eot       = 1,  /* [0] */
  BFW_NX90_biss_ctrl_irq_msk_set_err       = 1,  /* [1] */
  BFW_NX90_biss_ctrl_irq_msk_set_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_BISS_CTRL_IRQ_MSK_SET_BIT_Ttag {
  unsigned int eot       : BFW_NX90_biss_ctrl_irq_msk_set_eot;       /* End-Of-Transmission signal from the BiSS core. */
  unsigned int err       : BFW_NX90_biss_ctrl_irq_msk_set_err;       /* Error signal from the BiSS core.               */
  unsigned int reserved1 : BFW_NX90_biss_ctrl_irq_msk_set_reserved1; /* reserved                                       */
} NX90_BISS_CTRL_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_BISS_CTRL_IRQ_MSK_SET_BIT_T bf;
} NX90_BISS_CTRL_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register biss_ctrl_irq_msk_reset */
/* => BiSS IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_biss_ctrl_irq_msk_reset            0x00000014U
#define Adr_NX90_biss_ctrl0_app_biss_ctrl_irq_msk_reset 0xFF801D14U
#define Adr_NX90_biss_ctrl1_app_biss_ctrl_irq_msk_reset 0xFF801D34U
#define DFLT_VAL_NX90_biss_ctrl_irq_msk_reset           0x00000000U

#define MSK_NX90_biss_ctrl_irq_msk_reset_eot         0x00000001U
#define SRT_NX90_biss_ctrl_irq_msk_reset_eot         0
#define DFLT_VAL_NX90_biss_ctrl_irq_msk_reset_eot    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_irq_msk_reset_eot 0x00000000U
#define MSK_NX90_biss_ctrl_irq_msk_reset_err         0x00000002U
#define SRT_NX90_biss_ctrl_irq_msk_reset_err         1
#define DFLT_VAL_NX90_biss_ctrl_irq_msk_reset_err    0x00000000U
#define DFLT_BF_VAL_NX90_biss_ctrl_irq_msk_reset_err 0x00000000U

/* all used bits of 'NX90_biss_ctrl_irq_msk_reset': */
#define MSK_USED_BITS_NX90_biss_ctrl_irq_msk_reset 0x00000003U

enum {
  BFW_NX90_biss_ctrl_irq_msk_reset_eot       = 1,  /* [0] */
  BFW_NX90_biss_ctrl_irq_msk_reset_err       = 1,  /* [1] */
  BFW_NX90_biss_ctrl_irq_msk_reset_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_BISS_CTRL_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int eot       : BFW_NX90_biss_ctrl_irq_msk_reset_eot;       /* End-Of-Transmission signal from the BiSS core. */
  unsigned int err       : BFW_NX90_biss_ctrl_irq_msk_reset_err;       /* Error signal from the BiSS core.               */
  unsigned int reserved1 : BFW_NX90_biss_ctrl_irq_msk_reset_reserved1; /* reserved                                       */
} NX90_BISS_CTRL_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_BISS_CTRL_IRQ_MSK_RESET_BIT_T bf;
} NX90_BISS_CTRL_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* AREA xpic_config */
/* Area of xpic_app_config */

/* ===================================================================== */

#define Addr_NX90_xpic_app_config 0xFF880000U

/* ===================================================================== */

/* AREA xpic_ram */
/* Area of xpic_app_dram, xpic_app_pram */

/* ===================================================================== */

#define Addr_NX90_xpic_app_dram 0xFF880000U
#define Addr_NX90_xpic_app_pram 0xFF882000U

/* --------------------------------------------------------------------- */
/* Register xpic_ram_start */
/* => xPIC program or data RAM (xPIC TCM) start address: */
/*    Both xPIC TCMs (program and data) are only accessible by other system masters, \ */
/*    if xPIC is not running (xpic_debug-xpic_hold_pc-hold=0). */
/*    xPIC TCMs are only accessible for configuration and setup of xPIC processor. */
/*    xPIC TCMs should never be used for data exchange between xPIC and other system-masters. */
/*    Attention: Accessing xPIC_dram (data-TCM) while xPIC is running might seem to work but \ */
/*    influences communication tasks and HIF acesses and leads to instable system behaviour! */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_ram_start           0x00000000U
#define Adr_NX90_xpic_app_dram_xpic_ram_start 0xFF880000U
#define Adr_NX90_xpic_app_pram_xpic_ram_start 0xFF882000U

/* --------------------------------------------------------------------- */
/* Register xpic_ram_end */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_ram_end           0x00001FFCU
#define Adr_NX90_xpic_app_dram_xpic_ram_end 0xFF881FFCU
#define Adr_NX90_xpic_app_pram_xpic_ram_end 0xFF883FFCU


/* ===================================================================== */

/* AREA xpic */
/* Area of xpic_app_regs */

/* ===================================================================== */

#define Addr_NX90_xpic_app_regs 0xFF884000U

/* --------------------------------------------------------------------- */
/* Register xpic_r0 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r0           0x00000000U
#define Adr_NX90_xpic_app_regs_xpic_r0 0xFF884000U
#define Adr_NX90_xpic_r0               0xFF884000U
#define DFLT_VAL_NX90_xpic_r0          0x00000000U

#define MSK_NX90_xpic_r0_r0         0xffffffffU
#define SRT_NX90_xpic_r0_r0         0
#define DFLT_VAL_NX90_xpic_r0_r0    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r0_r0 0x00000000U

/* all used bits of 'NX90_xpic_r0': */
#define MSK_USED_BITS_NX90_xpic_r0 0xffffffffU

enum {
  BFW_NX90_xpic_r0_r0 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R0_BIT_Ttag {
  unsigned int r0 : BFW_NX90_xpic_r0_r0; /* Work Register 0 */
} NX90_XPIC_R0_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R0_BIT_T bf;
} NX90_XPIC_R0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r1 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r1           0x00000004U
#define Adr_NX90_xpic_app_regs_xpic_r1 0xFF884004U
#define Adr_NX90_xpic_r1               0xFF884004U
#define DFLT_VAL_NX90_xpic_r1          0x00000000U

#define MSK_NX90_xpic_r1_r1         0xffffffffU
#define SRT_NX90_xpic_r1_r1         0
#define DFLT_VAL_NX90_xpic_r1_r1    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r1_r1 0x00000000U

/* all used bits of 'NX90_xpic_r1': */
#define MSK_USED_BITS_NX90_xpic_r1 0xffffffffU

enum {
  BFW_NX90_xpic_r1_r1 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R1_BIT_Ttag {
  unsigned int r1 : BFW_NX90_xpic_r1_r1; /* Work Register 1 */
} NX90_XPIC_R1_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R1_BIT_T bf;
} NX90_XPIC_R1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r2 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r2           0x00000008U
#define Adr_NX90_xpic_app_regs_xpic_r2 0xFF884008U
#define Adr_NX90_xpic_r2               0xFF884008U
#define DFLT_VAL_NX90_xpic_r2          0x00000000U

#define MSK_NX90_xpic_r2_r2         0xffffffffU
#define SRT_NX90_xpic_r2_r2         0
#define DFLT_VAL_NX90_xpic_r2_r2    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r2_r2 0x00000000U

/* all used bits of 'NX90_xpic_r2': */
#define MSK_USED_BITS_NX90_xpic_r2 0xffffffffU

enum {
  BFW_NX90_xpic_r2_r2 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R2_BIT_Ttag {
  unsigned int r2 : BFW_NX90_xpic_r2_r2; /* Work Register 2 */
} NX90_XPIC_R2_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R2_BIT_T bf;
} NX90_XPIC_R2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r3 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r3           0x0000000CU
#define Adr_NX90_xpic_app_regs_xpic_r3 0xFF88400CU
#define Adr_NX90_xpic_r3               0xFF88400CU
#define DFLT_VAL_NX90_xpic_r3          0x00000000U

#define MSK_NX90_xpic_r3_r3         0xffffffffU
#define SRT_NX90_xpic_r3_r3         0
#define DFLT_VAL_NX90_xpic_r3_r3    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r3_r3 0x00000000U

/* all used bits of 'NX90_xpic_r3': */
#define MSK_USED_BITS_NX90_xpic_r3 0xffffffffU

enum {
  BFW_NX90_xpic_r3_r3 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R3_BIT_Ttag {
  unsigned int r3 : BFW_NX90_xpic_r3_r3; /* Work Register 3 */
} NX90_XPIC_R3_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R3_BIT_T bf;
} NX90_XPIC_R3_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r4 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r4           0x00000010U
#define Adr_NX90_xpic_app_regs_xpic_r4 0xFF884010U
#define Adr_NX90_xpic_r4               0xFF884010U
#define DFLT_VAL_NX90_xpic_r4          0x00000000U

#define MSK_NX90_xpic_r4_r4         0xffffffffU
#define SRT_NX90_xpic_r4_r4         0
#define DFLT_VAL_NX90_xpic_r4_r4    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r4_r4 0x00000000U

/* all used bits of 'NX90_xpic_r4': */
#define MSK_USED_BITS_NX90_xpic_r4 0xffffffffU

enum {
  BFW_NX90_xpic_r4_r4 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R4_BIT_Ttag {
  unsigned int r4 : BFW_NX90_xpic_r4_r4; /* Work Register 4 */
} NX90_XPIC_R4_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R4_BIT_T bf;
} NX90_XPIC_R4_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r5 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r5           0x00000014U
#define Adr_NX90_xpic_app_regs_xpic_r5 0xFF884014U
#define Adr_NX90_xpic_r5               0xFF884014U
#define DFLT_VAL_NX90_xpic_r5          0x00000000U

#define MSK_NX90_xpic_r5_r5         0xffffffffU
#define SRT_NX90_xpic_r5_r5         0
#define DFLT_VAL_NX90_xpic_r5_r5    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r5_r5 0x00000000U

/* all used bits of 'NX90_xpic_r5': */
#define MSK_USED_BITS_NX90_xpic_r5 0xffffffffU

enum {
  BFW_NX90_xpic_r5_r5 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R5_BIT_Ttag {
  unsigned int r5 : BFW_NX90_xpic_r5_r5; /* Work Register 5 */
} NX90_XPIC_R5_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R5_BIT_T bf;
} NX90_XPIC_R5_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r6 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r6           0x00000018U
#define Adr_NX90_xpic_app_regs_xpic_r6 0xFF884018U
#define Adr_NX90_xpic_r6               0xFF884018U
#define DFLT_VAL_NX90_xpic_r6          0x00000000U

#define MSK_NX90_xpic_r6_r6         0xffffffffU
#define SRT_NX90_xpic_r6_r6         0
#define DFLT_VAL_NX90_xpic_r6_r6    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r6_r6 0x00000000U

/* all used bits of 'NX90_xpic_r6': */
#define MSK_USED_BITS_NX90_xpic_r6 0xffffffffU

enum {
  BFW_NX90_xpic_r6_r6 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R6_BIT_Ttag {
  unsigned int r6 : BFW_NX90_xpic_r6_r6; /* Work Register 6 */
} NX90_XPIC_R6_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R6_BIT_T bf;
} NX90_XPIC_R6_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r7 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_r7           0x0000001CU
#define Adr_NX90_xpic_app_regs_xpic_r7 0xFF88401CU
#define Adr_NX90_xpic_r7               0xFF88401CU
#define DFLT_VAL_NX90_xpic_r7          0x00000000U

#define MSK_NX90_xpic_r7_r7         0xffffffffU
#define SRT_NX90_xpic_r7_r7         0
#define DFLT_VAL_NX90_xpic_r7_r7    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_r7_r7 0x00000000U

/* all used bits of 'NX90_xpic_r7': */
#define MSK_USED_BITS_NX90_xpic_r7 0xffffffffU

enum {
  BFW_NX90_xpic_r7_r7 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_R7_BIT_Ttag {
  unsigned int r7 : BFW_NX90_xpic_r7_r7; /* Work Register 7 */
} NX90_XPIC_R7_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_R7_BIT_T bf;
} NX90_XPIC_R7_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr0 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_usr0           0x00000020U
#define Adr_NX90_xpic_app_regs_xpic_usr0 0xFF884020U
#define Adr_NX90_xpic_usr0               0xFF884020U
#define DFLT_VAL_NX90_xpic_usr0          0x00000000U

#define MSK_NX90_xpic_usr0_usr0         0xffffffffU
#define SRT_NX90_xpic_usr0_usr0         0
#define DFLT_VAL_NX90_xpic_usr0_usr0    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_usr0_usr0 0x00000000U

/* all used bits of 'NX90_xpic_usr0': */
#define MSK_USED_BITS_NX90_xpic_usr0 0xffffffffU

enum {
  BFW_NX90_xpic_usr0_usr0 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_USR0_BIT_Ttag {
  unsigned int usr0 : BFW_NX90_xpic_usr0_usr0; /* User Register 0 */
} NX90_XPIC_USR0_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XPIC_USR0_BIT_T bf;
} NX90_XPIC_USR0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr1 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_usr1           0x00000024U
#define Adr_NX90_xpic_app_regs_xpic_usr1 0xFF884024U
#define Adr_NX90_xpic_usr1               0xFF884024U
#define DFLT_VAL_NX90_xpic_usr1          0x00000000U

#define MSK_NX90_xpic_usr1_usr1         0xffffffffU
#define SRT_NX90_xpic_usr1_usr1         0
#define DFLT_VAL_NX90_xpic_usr1_usr1    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_usr1_usr1 0x00000000U

/* all used bits of 'NX90_xpic_usr1': */
#define MSK_USED_BITS_NX90_xpic_usr1 0xffffffffU

enum {
  BFW_NX90_xpic_usr1_usr1 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_USR1_BIT_Ttag {
  unsigned int usr1 : BFW_NX90_xpic_usr1_usr1; /* User Register 1 */
} NX90_XPIC_USR1_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XPIC_USR1_BIT_T bf;
} NX90_XPIC_USR1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr2 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_usr2           0x00000028U
#define Adr_NX90_xpic_app_regs_xpic_usr2 0xFF884028U
#define Adr_NX90_xpic_usr2               0xFF884028U
#define DFLT_VAL_NX90_xpic_usr2          0x00000000U

#define MSK_NX90_xpic_usr2_usr2         0xffffffffU
#define SRT_NX90_xpic_usr2_usr2         0
#define DFLT_VAL_NX90_xpic_usr2_usr2    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_usr2_usr2 0x00000000U

/* all used bits of 'NX90_xpic_usr2': */
#define MSK_USED_BITS_NX90_xpic_usr2 0xffffffffU

enum {
  BFW_NX90_xpic_usr2_usr2 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_USR2_BIT_Ttag {
  unsigned int usr2 : BFW_NX90_xpic_usr2_usr2; /* User Register 2 */
} NX90_XPIC_USR2_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XPIC_USR2_BIT_T bf;
} NX90_XPIC_USR2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr3 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_usr3           0x0000002CU
#define Adr_NX90_xpic_app_regs_xpic_usr3 0xFF88402CU
#define Adr_NX90_xpic_usr3               0xFF88402CU
#define DFLT_VAL_NX90_xpic_usr3          0x00000000U

#define MSK_NX90_xpic_usr3_usr3         0xffffffffU
#define SRT_NX90_xpic_usr3_usr3         0
#define DFLT_VAL_NX90_xpic_usr3_usr3    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_usr3_usr3 0x00000000U

/* all used bits of 'NX90_xpic_usr3': */
#define MSK_USED_BITS_NX90_xpic_usr3 0xffffffffU

enum {
  BFW_NX90_xpic_usr3_usr3 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_USR3_BIT_Ttag {
  unsigned int usr3 : BFW_NX90_xpic_usr3_usr3; /* User Register 3 */
} NX90_XPIC_USR3_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XPIC_USR3_BIT_T bf;
} NX90_XPIC_USR3_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr4 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_usr4           0x00000030U
#define Adr_NX90_xpic_app_regs_xpic_usr4 0xFF884030U
#define Adr_NX90_xpic_usr4               0xFF884030U
#define DFLT_VAL_NX90_xpic_usr4          0x00000000U

#define MSK_NX90_xpic_usr4_usr4         0xffffffffU
#define SRT_NX90_xpic_usr4_usr4         0
#define DFLT_VAL_NX90_xpic_usr4_usr4    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_usr4_usr4 0x00000000U

/* all used bits of 'NX90_xpic_usr4': */
#define MSK_USED_BITS_NX90_xpic_usr4 0xffffffffU

enum {
  BFW_NX90_xpic_usr4_usr4 = 32  /* [31:0] */
};

typedef struct NX90_XPIC_USR4_BIT_Ttag {
  unsigned int usr4 : BFW_NX90_xpic_usr4_usr4; /* User Register 4 */
} NX90_XPIC_USR4_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XPIC_USR4_BIT_T bf;
} NX90_XPIC_USR4_T;

/* --------------------------------------------------------------------- */
/* Register xpic_pc */
/* => xPIC Program Counter */
/*    Shared in xPIC 64_BIT_MUL_TARGET mode with usr32 (w mode) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_pc           0x00000034U
#define Adr_NX90_xpic_app_regs_xpic_pc 0xFF884034U
#define Adr_NX90_xpic_pc               0xFF884034U
#define DFLT_VAL_NX90_xpic_pc          0xfffffffcU

#define MSK_NX90_xpic_pc_pc         0xffffffffU
#define SRT_NX90_xpic_pc_pc         0
#define DFLT_VAL_NX90_xpic_pc_pc    0xfffffffcU
#define DFLT_BF_VAL_NX90_xpic_pc_pc 0xfffffffcU

/* all used bits of 'NX90_xpic_pc': */
#define MSK_USED_BITS_NX90_xpic_pc 0xffffffffU

enum {
  BFW_NX90_xpic_pc_pc = 32  /* [31:0] */
};

typedef struct NX90_XPIC_PC_BIT_Ttag {
  unsigned int pc : BFW_NX90_xpic_pc_pc; /* Program Counter (dword address inside DPRAM) */
} NX90_XPIC_PC_BIT_T;

typedef union {
  uint32_t           val;
  NX90_XPIC_PC_BIT_T bf;
} NX90_XPIC_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_stat */
/* => Processor Status Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_stat           0x00000038U
#define Adr_NX90_xpic_app_regs_xpic_stat 0xFF884038U
#define Adr_NX90_xpic_stat               0xFF884038U
#define DFLT_VAL_NX90_xpic_stat          0x00000000U

#define MSK_NX90_xpic_stat_stat         0xffffffffU
#define SRT_NX90_xpic_stat_stat         0
#define DFLT_VAL_NX90_xpic_stat_stat    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_stat_stat 0x00000000U

/* all used bits of 'NX90_xpic_stat': */
#define MSK_USED_BITS_NX90_xpic_stat 0xffffffffU

enum {
  BFW_NX90_xpic_stat_stat = 32  /* [31:0] */
};

typedef struct NX90_XPIC_STAT_BIT_Ttag {
  unsigned int stat : BFW_NX90_xpic_stat_stat; /*  */
} NX90_XPIC_STAT_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XPIC_STAT_BIT_T bf;
} NX90_XPIC_STAT_T;

/* --------------------------------------------------------------------- */
/* Register xpic_zero */
/* => Zero Register */
/*    Shared in xPIC 64_BIT_MUL_TARGET mode with usr10 (w mode) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_zero           0x0000003CU
#define Adr_NX90_xpic_app_regs_xpic_zero 0xFF88403CU
#define Adr_NX90_xpic_zero               0xFF88403CU
#define DFLT_VAL_NX90_xpic_zero          0x00000000U

#define MSK_NX90_xpic_zero_zero         0xffffffffU
#define SRT_NX90_xpic_zero_zero         0
#define DFLT_VAL_NX90_xpic_zero_zero    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_zero_zero 0x00000000U

/* all used bits of 'NX90_xpic_zero': */
#define MSK_USED_BITS_NX90_xpic_zero 0xffffffffU

enum {
  BFW_NX90_xpic_zero_zero = 32  /* [31:0] */
};

typedef struct NX90_XPIC_ZERO_BIT_Ttag {
  unsigned int zero : BFW_NX90_xpic_zero_zero; /* Always Zero */
} NX90_XPIC_ZERO_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XPIC_ZERO_BIT_T bf;
} NX90_XPIC_ZERO_T;


/* ===================================================================== */

/* AREA xpic_debug */
/* Area of xpic_app_debug */

/* ===================================================================== */

#define Addr_NX90_xpic_app_debug 0xFF884080U

/* --------------------------------------------------------------------- */
/* Register xpic_hold_pc */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_hold_pc            0x00000000U
#define Adr_NX90_xpic_app_debug_xpic_hold_pc 0xFF884080U
#define Adr_NX90_xpic_hold_pc                0xFF884080U
#define DFLT_VAL_NX90_xpic_hold_pc           0x00000001U

#define MSK_NX90_xpic_hold_pc_hold                      0x00000001U
#define SRT_NX90_xpic_hold_pc_hold                      0
#define DFLT_VAL_NX90_xpic_hold_pc_hold                 0x00000001U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_hold              0x00000001U
#define MSK_NX90_xpic_hold_pc_single_step               0x00000002U
#define SRT_NX90_xpic_hold_pc_single_step               1
#define DFLT_VAL_NX90_xpic_hold_pc_single_step          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_single_step       0x00000000U
#define MSK_NX90_xpic_hold_pc_monitor_mode              0x00000004U
#define SRT_NX90_xpic_hold_pc_monitor_mode              2
#define DFLT_VAL_NX90_xpic_hold_pc_monitor_mode         0x00000000U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_monitor_mode      0x00000000U
#define MSK_NX90_xpic_hold_pc_disable_int               0x00000008U
#define SRT_NX90_xpic_hold_pc_disable_int               3
#define DFLT_VAL_NX90_xpic_hold_pc_disable_int          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_disable_int       0x00000000U
#define MSK_NX90_xpic_hold_pc_misalignment_hold         0x00000010U
#define SRT_NX90_xpic_hold_pc_misalignment_hold         4
#define DFLT_VAL_NX90_xpic_hold_pc_misalignment_hold    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_misalignment_hold 0x00000000U
#define MSK_NX90_xpic_hold_pc_bank_select               0x00000020U
#define SRT_NX90_xpic_hold_pc_bank_select               5
#define DFLT_VAL_NX90_xpic_hold_pc_bank_select          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_bank_select       0x00000000U
#define MSK_NX90_xpic_hold_pc_bank_control              0x00000040U
#define SRT_NX90_xpic_hold_pc_bank_control              6
#define DFLT_VAL_NX90_xpic_hold_pc_bank_control         0x00000000U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_bank_control      0x00000000U
#define MSK_NX90_xpic_hold_pc_reset_xpic                0x00000080U
#define SRT_NX90_xpic_hold_pc_reset_xpic                7
#define DFLT_VAL_NX90_xpic_hold_pc_reset_xpic           0x00000000U
#define DFLT_BF_VAL_NX90_xpic_hold_pc_reset_xpic        0x00000000U

/* all used bits of 'NX90_xpic_hold_pc': */
#define MSK_USED_BITS_NX90_xpic_hold_pc 0x000000ffU

enum {
  BFW_NX90_xpic_hold_pc_hold              = 1,  /* [0] */
  BFW_NX90_xpic_hold_pc_single_step       = 1,  /* [1] */
  BFW_NX90_xpic_hold_pc_monitor_mode      = 1,  /* [2] */
  BFW_NX90_xpic_hold_pc_disable_int       = 1,  /* [3] */
  BFW_NX90_xpic_hold_pc_misalignment_hold = 1,  /* [4] */
  BFW_NX90_xpic_hold_pc_bank_select       = 1,  /* [5] */
  BFW_NX90_xpic_hold_pc_bank_control      = 1,  /* [6] */
  BFW_NX90_xpic_hold_pc_reset_xpic        = 1,  /* [7] */
  BFW_NX90_xpic_hold_pc_reserved1         = 24  /* [31:8] */
};

typedef struct NX90_XPIC_HOLD_PC_BIT_Ttag {
  unsigned int hold              : BFW_NX90_xpic_hold_pc_hold;              /* 0: Start xPIC                                                                                                                                        */
                                                                            /* 1: Hold xPIC                                                                                                                                         */
  unsigned int single_step       : BFW_NX90_xpic_hold_pc_single_step;       /* 0: Disable single step mode                                                                                                                          */
                                                                            /* 1: xPIC processes a single pipeline step then stops and triggers the single_step_irq. Write '1' into xpic_break_irq_raw.single_step_irq to continue. */
  unsigned int monitor_mode      : BFW_NX90_xpic_hold_pc_monitor_mode;      /* 0: xPIC stops when hardware breakpoint is triggered. Write '1' into xpic_break_irq_raw.break0_irq or break1_irq to continue.                         */
                                                                            /* 1: Hardware breakpoints still generate irqs but do not stop the xPIC.                                                                                */
  unsigned int disable_int       : BFW_NX90_xpic_hold_pc_disable_int;       /* disable interrupts                                                                                                                                   */
  unsigned int misalignment_hold : BFW_NX90_xpic_hold_pc_misalignment_hold; /* 0: xPIC triggers misalignment_irq on misaligned memory accesses but does not stop.                                                                   */
                                                                            /* 1: xPIC stops after a misaligned memory accesses and triggers misalignment_irq. Write '1' into xpic_break_irq_raw.misalignment_irq to continue.      */
  unsigned int bank_select       : BFW_NX90_xpic_hold_pc_bank_select;       /* Select register bank (0: default bank, 1: fiq bank)                                                                                                  */
                                                                            /* Access registers in xpic_regs area (xpic_r0 .. xpic_r7, xpic_stat)                                                                                   */
  unsigned int bank_control      : BFW_NX90_xpic_hold_pc_bank_control;      /* control over the register bank selection                                                                                                             */
                                                                            /* WARNING: reset this BIT to 0 BEFORE start xPIC (clear hold bits)                                                                                     */
  unsigned int reset_xpic        : BFW_NX90_xpic_hold_pc_reset_xpic;        /* REQUEST reset all internal internal states and the pipeline                                                                                          */
                                                                            /* EXCEPT: the internal register (r0-r7, usr0-4), bank0 and bank1 reset this registers manually                                                         */
                                                                            /* EXCEPT: xpic hard_breaker/debug registers                                                                                                            */
                                                                            /* 1 - xPIC reset request                                                                                                                               */
  unsigned int reserved1         : BFW_NX90_xpic_hold_pc_reserved1;         /* reserved                                                                                                                                             */
} NX90_XPIC_HOLD_PC_BIT_T;

typedef union {
  uint32_t                val;
  NX90_XPIC_HOLD_PC_BIT_T bf;
} NX90_XPIC_HOLD_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_addr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break0_addr            0x00000004U
#define Adr_NX90_xpic_app_debug_xpic_break0_addr 0xFF884084U
#define Adr_NX90_xpic_break0_addr                0xFF884084U
#define DFLT_VAL_NX90_xpic_break0_addr           0x00000000U

#define MSK_NX90_xpic_break0_addr_val         0xffffffffU
#define SRT_NX90_xpic_break0_addr_val         0
#define DFLT_VAL_NX90_xpic_break0_addr_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_addr_val 0x00000000U

/* all used bits of 'NX90_xpic_break0_addr': */
#define MSK_USED_BITS_NX90_xpic_break0_addr 0xffffffffU

enum {
  BFW_NX90_xpic_break0_addr_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK0_ADDR_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break0_addr_val; /* Breakpoint 0 address value */
} NX90_XPIC_BREAK0_ADDR_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_XPIC_BREAK0_ADDR_BIT_T bf;
} NX90_XPIC_BREAK0_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_addr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break0_addr_mask            0x00000008U
#define Adr_NX90_xpic_app_debug_xpic_break0_addr_mask 0xFF884088U
#define Adr_NX90_xpic_break0_addr_mask                0xFF884088U
#define DFLT_VAL_NX90_xpic_break0_addr_mask           0x00000000U

#define MSK_NX90_xpic_break0_addr_mask_val         0xffffffffU
#define SRT_NX90_xpic_break0_addr_mask_val         0
#define DFLT_VAL_NX90_xpic_break0_addr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_addr_mask_val 0x00000000U

/* all used bits of 'NX90_xpic_break0_addr_mask': */
#define MSK_USED_BITS_NX90_xpic_break0_addr_mask 0xffffffffU

enum {
  BFW_NX90_xpic_break0_addr_mask_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK0_ADDR_MASK_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break0_addr_mask_val; /* Breakpoint 0 address mask */
} NX90_XPIC_BREAK0_ADDR_MASK_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_BREAK0_ADDR_MASK_BIT_T bf;
} NX90_XPIC_BREAK0_ADDR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_data */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break0_data            0x0000000CU
#define Adr_NX90_xpic_app_debug_xpic_break0_data 0xFF88408CU
#define Adr_NX90_xpic_break0_data                0xFF88408CU
#define DFLT_VAL_NX90_xpic_break0_data           0x00000000U

#define MSK_NX90_xpic_break0_data_val         0xffffffffU
#define SRT_NX90_xpic_break0_data_val         0
#define DFLT_VAL_NX90_xpic_break0_data_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_data_val 0x00000000U

/* all used bits of 'NX90_xpic_break0_data': */
#define MSK_USED_BITS_NX90_xpic_break0_data 0xffffffffU

enum {
  BFW_NX90_xpic_break0_data_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK0_DATA_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break0_data_val; /* Breakpoint 0 data value   (for data access only) */
} NX90_XPIC_BREAK0_DATA_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_XPIC_BREAK0_DATA_BIT_T bf;
} NX90_XPIC_BREAK0_DATA_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_data_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break0_data_mask            0x00000010U
#define Adr_NX90_xpic_app_debug_xpic_break0_data_mask 0xFF884090U
#define Adr_NX90_xpic_break0_data_mask                0xFF884090U
#define DFLT_VAL_NX90_xpic_break0_data_mask           0x00000000U

#define MSK_NX90_xpic_break0_data_mask_val         0xffffffffU
#define SRT_NX90_xpic_break0_data_mask_val         0
#define DFLT_VAL_NX90_xpic_break0_data_mask_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_data_mask_val 0x00000000U

/* all used bits of 'NX90_xpic_break0_data_mask': */
#define MSK_USED_BITS_NX90_xpic_break0_data_mask 0xffffffffU

enum {
  BFW_NX90_xpic_break0_data_mask_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK0_DATA_MASK_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break0_data_mask_val; /* Breakpoint 0 data mask    (for data access only) */
} NX90_XPIC_BREAK0_DATA_MASK_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_BREAK0_DATA_MASK_BIT_T bf;
} NX90_XPIC_BREAK0_DATA_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_contr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break0_contr            0x00000014U
#define Adr_NX90_xpic_app_debug_xpic_break0_contr 0xFF884094U
#define Adr_NX90_xpic_break0_contr                0xFF884094U
#define DFLT_VAL_NX90_xpic_break0_contr           0x00000000U

#define MSK_NX90_xpic_break0_contr_write               0x00000001U
#define SRT_NX90_xpic_break0_contr_write               0
#define DFLT_VAL_NX90_xpic_break0_contr_write          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_write       0x00000000U
#define MSK_NX90_xpic_break0_contr_mas                 0x00000006U
#define SRT_NX90_xpic_break0_contr_mas                 1
#define DFLT_VAL_NX90_xpic_break0_contr_mas            0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_mas         0x00000000U
#define MSK_NX90_xpic_break0_contr_data_access         0x00000008U
#define SRT_NX90_xpic_break0_contr_data_access         3
#define DFLT_VAL_NX90_xpic_break0_contr_data_access    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_data_access 0x00000000U
#define MSK_NX90_xpic_break0_contr_fiq_mode            0x00000010U
#define SRT_NX90_xpic_break0_contr_fiq_mode            4
#define DFLT_VAL_NX90_xpic_break0_contr_fiq_mode       0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_fiq_mode    0x00000000U
#define MSK_NX90_xpic_break0_contr_irq_mode            0x00000020U
#define SRT_NX90_xpic_break0_contr_irq_mode            5
#define DFLT_VAL_NX90_xpic_break0_contr_irq_mode       0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_irq_mode    0x00000000U
#define MSK_NX90_xpic_break0_contr_chain               0x00000040U
#define SRT_NX90_xpic_break0_contr_chain               6
#define DFLT_VAL_NX90_xpic_break0_contr_chain          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_chain       0x00000000U
#define MSK_NX90_xpic_break0_contr_range               0x00000080U
#define SRT_NX90_xpic_break0_contr_range               7
#define DFLT_VAL_NX90_xpic_break0_contr_range          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_range       0x00000000U
#define MSK_NX90_xpic_break0_contr_enable              0x00000100U
#define SRT_NX90_xpic_break0_contr_enable              8
#define DFLT_VAL_NX90_xpic_break0_contr_enable         0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_enable      0x00000000U

/* all used bits of 'NX90_xpic_break0_contr': */
#define MSK_USED_BITS_NX90_xpic_break0_contr 0x000001ffU

enum {
  BFW_NX90_xpic_break0_contr_write       = 1,  /* [0] */
  BFW_NX90_xpic_break0_contr_mas         = 2,  /* [2:1] */
  BFW_NX90_xpic_break0_contr_data_access = 1,  /* [3] */
  BFW_NX90_xpic_break0_contr_fiq_mode    = 1,  /* [4] */
  BFW_NX90_xpic_break0_contr_irq_mode    = 1,  /* [5] */
  BFW_NX90_xpic_break0_contr_chain       = 1,  /* [6] */
  BFW_NX90_xpic_break0_contr_range       = 1,  /* [7] */
  BFW_NX90_xpic_break0_contr_enable      = 1,  /* [8] */
  BFW_NX90_xpic_break0_contr_reserved1   = 23  /* [31:9] */
};

typedef struct NX90_XPIC_BREAK0_CONTR_BIT_Ttag {
  unsigned int write       : BFW_NX90_xpic_break0_contr_write;       /* Breakpoint 0  write/read access                                              */
  unsigned int mas         : BFW_NX90_xpic_break0_contr_mas;         /* Breakpoint 0  memory access size (00: byte. 01: word, 10 dword, 11 reserved) */
  unsigned int data_access : BFW_NX90_xpic_break0_contr_data_access; /* Breakpoint 0  (1: data access, 0: instruction fetch)                         */
  unsigned int fiq_mode    : BFW_NX90_xpic_break0_contr_fiq_mode;    /* Breakpoint 0  xPIC in FIQ Mode                                               */
  unsigned int irq_mode    : BFW_NX90_xpic_break0_contr_irq_mode;    /* Breakpoint 0  xPIC in IRQ Mode                                               */
  unsigned int chain       : BFW_NX90_xpic_break0_contr_chain;       /* Breakpoint 0 input from Breakpoint 1                                         */
  unsigned int range       : BFW_NX90_xpic_break0_contr_range;       /* Breakpoint 0 input from Breakpoint 1                                         */
  unsigned int enable      : BFW_NX90_xpic_break0_contr_enable;      /* Breakpoint 0                                                                 */
  unsigned int reserved1   : BFW_NX90_xpic_break0_contr_reserved1;   /* reserved                                                                     */
} NX90_XPIC_BREAK0_CONTR_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_BREAK0_CONTR_BIT_T bf;
} NX90_XPIC_BREAK0_CONTR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_contr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break0_contr_mask            0x00000018U
#define Adr_NX90_xpic_app_debug_xpic_break0_contr_mask 0xFF884098U
#define Adr_NX90_xpic_break0_contr_mask                0xFF884098U
#define DFLT_VAL_NX90_xpic_break0_contr_mask           0x00000000U

#define MSK_NX90_xpic_break0_contr_mask_val         0x000000ffU
#define SRT_NX90_xpic_break0_contr_mask_val         0
#define DFLT_VAL_NX90_xpic_break0_contr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break0_contr_mask_val 0x00000000U

/* all used bits of 'NX90_xpic_break0_contr_mask': */
#define MSK_USED_BITS_NX90_xpic_break0_contr_mask 0x000000ffU

enum {
  BFW_NX90_xpic_break0_contr_mask_val       = 8,  /* [7:0] */
  BFW_NX90_xpic_break0_contr_mask_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_XPIC_BREAK0_CONTR_MASK_BIT_Ttag {
  unsigned int val       : BFW_NX90_xpic_break0_contr_mask_val;       /* Breakpoint 0 control mask */
  unsigned int reserved1 : BFW_NX90_xpic_break0_contr_mask_reserved1; /* reserved                  */
} NX90_XPIC_BREAK0_CONTR_MASK_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_BREAK0_CONTR_MASK_BIT_T bf;
} NX90_XPIC_BREAK0_CONTR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_addr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break1_addr            0x0000001CU
#define Adr_NX90_xpic_app_debug_xpic_break1_addr 0xFF88409CU
#define Adr_NX90_xpic_break1_addr                0xFF88409CU
#define DFLT_VAL_NX90_xpic_break1_addr           0x00000000U

#define MSK_NX90_xpic_break1_addr_val         0xffffffffU
#define SRT_NX90_xpic_break1_addr_val         0
#define DFLT_VAL_NX90_xpic_break1_addr_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_addr_val 0x00000000U

/* all used bits of 'NX90_xpic_break1_addr': */
#define MSK_USED_BITS_NX90_xpic_break1_addr 0xffffffffU

enum {
  BFW_NX90_xpic_break1_addr_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK1_ADDR_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break1_addr_val; /* Breakpoint 1 address value */
} NX90_XPIC_BREAK1_ADDR_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_XPIC_BREAK1_ADDR_BIT_T bf;
} NX90_XPIC_BREAK1_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_addr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break1_addr_mask            0x00000020U
#define Adr_NX90_xpic_app_debug_xpic_break1_addr_mask 0xFF8840A0U
#define Adr_NX90_xpic_break1_addr_mask                0xFF8840A0U
#define DFLT_VAL_NX90_xpic_break1_addr_mask           0x00000000U

#define MSK_NX90_xpic_break1_addr_mask_val         0xffffffffU
#define SRT_NX90_xpic_break1_addr_mask_val         0
#define DFLT_VAL_NX90_xpic_break1_addr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_addr_mask_val 0x00000000U

/* all used bits of 'NX90_xpic_break1_addr_mask': */
#define MSK_USED_BITS_NX90_xpic_break1_addr_mask 0xffffffffU

enum {
  BFW_NX90_xpic_break1_addr_mask_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK1_ADDR_MASK_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break1_addr_mask_val; /* Breakpoint 1 address mask */
} NX90_XPIC_BREAK1_ADDR_MASK_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_BREAK1_ADDR_MASK_BIT_T bf;
} NX90_XPIC_BREAK1_ADDR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_data */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break1_data            0x00000024U
#define Adr_NX90_xpic_app_debug_xpic_break1_data 0xFF8840A4U
#define Adr_NX90_xpic_break1_data                0xFF8840A4U
#define DFLT_VAL_NX90_xpic_break1_data           0x00000000U

#define MSK_NX90_xpic_break1_data_val         0xffffffffU
#define SRT_NX90_xpic_break1_data_val         0
#define DFLT_VAL_NX90_xpic_break1_data_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_data_val 0x00000000U

/* all used bits of 'NX90_xpic_break1_data': */
#define MSK_USED_BITS_NX90_xpic_break1_data 0xffffffffU

enum {
  BFW_NX90_xpic_break1_data_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK1_DATA_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break1_data_val; /* Breakpoint 1 data value   (for data access only) */
} NX90_XPIC_BREAK1_DATA_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_XPIC_BREAK1_DATA_BIT_T bf;
} NX90_XPIC_BREAK1_DATA_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_data_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break1_data_mask            0x00000028U
#define Adr_NX90_xpic_app_debug_xpic_break1_data_mask 0xFF8840A8U
#define Adr_NX90_xpic_break1_data_mask                0xFF8840A8U
#define DFLT_VAL_NX90_xpic_break1_data_mask           0x00000000U

#define MSK_NX90_xpic_break1_data_mask_val         0xffffffffU
#define SRT_NX90_xpic_break1_data_mask_val         0
#define DFLT_VAL_NX90_xpic_break1_data_mask_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_data_mask_val 0x00000000U

/* all used bits of 'NX90_xpic_break1_data_mask': */
#define MSK_USED_BITS_NX90_xpic_break1_data_mask 0xffffffffU

enum {
  BFW_NX90_xpic_break1_data_mask_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK1_DATA_MASK_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break1_data_mask_val; /* Breakpoint 1 data mask   (for data access only) */
} NX90_XPIC_BREAK1_DATA_MASK_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_BREAK1_DATA_MASK_BIT_T bf;
} NX90_XPIC_BREAK1_DATA_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_contr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break1_contr            0x0000002CU
#define Adr_NX90_xpic_app_debug_xpic_break1_contr 0xFF8840ACU
#define Adr_NX90_xpic_break1_contr                0xFF8840ACU
#define DFLT_VAL_NX90_xpic_break1_contr           0x00000000U

#define MSK_NX90_xpic_break1_contr_write               0x00000001U
#define SRT_NX90_xpic_break1_contr_write               0
#define DFLT_VAL_NX90_xpic_break1_contr_write          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_write       0x00000000U
#define MSK_NX90_xpic_break1_contr_mas                 0x00000006U
#define SRT_NX90_xpic_break1_contr_mas                 1
#define DFLT_VAL_NX90_xpic_break1_contr_mas            0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_mas         0x00000000U
#define MSK_NX90_xpic_break1_contr_data_access         0x00000008U
#define SRT_NX90_xpic_break1_contr_data_access         3
#define DFLT_VAL_NX90_xpic_break1_contr_data_access    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_data_access 0x00000000U
#define MSK_NX90_xpic_break1_contr_fiq_mode            0x00000010U
#define SRT_NX90_xpic_break1_contr_fiq_mode            4
#define DFLT_VAL_NX90_xpic_break1_contr_fiq_mode       0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_fiq_mode    0x00000000U
#define MSK_NX90_xpic_break1_contr_irq_mode            0x00000020U
#define SRT_NX90_xpic_break1_contr_irq_mode            5
#define DFLT_VAL_NX90_xpic_break1_contr_irq_mode       0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_irq_mode    0x00000000U
#define MSK_NX90_xpic_break1_contr_chain               0x00000040U
#define SRT_NX90_xpic_break1_contr_chain               6
#define DFLT_VAL_NX90_xpic_break1_contr_chain          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_chain       0x00000000U
#define MSK_NX90_xpic_break1_contr_range               0x00000080U
#define SRT_NX90_xpic_break1_contr_range               7
#define DFLT_VAL_NX90_xpic_break1_contr_range          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_range       0x00000000U
#define MSK_NX90_xpic_break1_contr_enable              0x00000100U
#define SRT_NX90_xpic_break1_contr_enable              8
#define DFLT_VAL_NX90_xpic_break1_contr_enable         0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_enable      0x00000000U

/* all used bits of 'NX90_xpic_break1_contr': */
#define MSK_USED_BITS_NX90_xpic_break1_contr 0x000001ffU

enum {
  BFW_NX90_xpic_break1_contr_write       = 1,  /* [0] */
  BFW_NX90_xpic_break1_contr_mas         = 2,  /* [2:1] */
  BFW_NX90_xpic_break1_contr_data_access = 1,  /* [3] */
  BFW_NX90_xpic_break1_contr_fiq_mode    = 1,  /* [4] */
  BFW_NX90_xpic_break1_contr_irq_mode    = 1,  /* [5] */
  BFW_NX90_xpic_break1_contr_chain       = 1,  /* [6] */
  BFW_NX90_xpic_break1_contr_range       = 1,  /* [7] */
  BFW_NX90_xpic_break1_contr_enable      = 1,  /* [8] */
  BFW_NX90_xpic_break1_contr_reserved1   = 23  /* [31:9] */
};

typedef struct NX90_XPIC_BREAK1_CONTR_BIT_Ttag {
  unsigned int write       : BFW_NX90_xpic_break1_contr_write;       /* Breakpoint 1  write/read access                                              */
  unsigned int mas         : BFW_NX90_xpic_break1_contr_mas;         /* Breakpoint 1  memory access size (00: byte. 01: word, 10 dword, 11 reserved) */
  unsigned int data_access : BFW_NX90_xpic_break1_contr_data_access; /* Breakpoint 1  (1: data access, 0: instruction fetch)                         */
  unsigned int fiq_mode    : BFW_NX90_xpic_break1_contr_fiq_mode;    /* Breakpoint 1  xPIC in FIQ Mode                                               */
  unsigned int irq_mode    : BFW_NX90_xpic_break1_contr_irq_mode;    /* Breakpoint 1  xPIC in IRQ Mode                                               */
  unsigned int chain       : BFW_NX90_xpic_break1_contr_chain;       /* reserved                                                                     */
  unsigned int range       : BFW_NX90_xpic_break1_contr_range;       /* reserved                                                                     */
  unsigned int enable      : BFW_NX90_xpic_break1_contr_enable;      /* Breakpoint 1                                                                 */
  unsigned int reserved1   : BFW_NX90_xpic_break1_contr_reserved1;   /* reserved                                                                     */
} NX90_XPIC_BREAK1_CONTR_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_BREAK1_CONTR_BIT_T bf;
} NX90_XPIC_BREAK1_CONTR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_contr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break1_contr_mask            0x00000030U
#define Adr_NX90_xpic_app_debug_xpic_break1_contr_mask 0xFF8840B0U
#define Adr_NX90_xpic_break1_contr_mask                0xFF8840B0U
#define DFLT_VAL_NX90_xpic_break1_contr_mask           0x00000000U

#define MSK_NX90_xpic_break1_contr_mask_val         0x000000ffU
#define SRT_NX90_xpic_break1_contr_mask_val         0
#define DFLT_VAL_NX90_xpic_break1_contr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break1_contr_mask_val 0x00000000U

/* all used bits of 'NX90_xpic_break1_contr_mask': */
#define MSK_USED_BITS_NX90_xpic_break1_contr_mask 0x000000ffU

enum {
  BFW_NX90_xpic_break1_contr_mask_val       = 8,  /* [7:0] */
  BFW_NX90_xpic_break1_contr_mask_reserved1 = 24  /* [31:8] */
};

typedef struct NX90_XPIC_BREAK1_CONTR_MASK_BIT_Ttag {
  unsigned int val       : BFW_NX90_xpic_break1_contr_mask_val;       /* Breakpoint 1 control mask */
  unsigned int reserved1 : BFW_NX90_xpic_break1_contr_mask_reserved1; /* reserved                  */
} NX90_XPIC_BREAK1_CONTR_MASK_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_BREAK1_CONTR_MASK_BIT_T bf;
} NX90_XPIC_BREAK1_CONTR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_last_pc */
/* =>  */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_last_pc            0x00000034U
#define Adr_NX90_xpic_app_debug_xpic_break_last_pc 0xFF8840B4U
#define Adr_NX90_xpic_break_last_pc                0xFF8840B4U

#define MSK_NX90_xpic_break_last_pc_val 0xffffffffU
#define SRT_NX90_xpic_break_last_pc_val 0

/* all used bits of 'NX90_xpic_break_last_pc': */
#define MSK_USED_BITS_NX90_xpic_break_last_pc 0xffffffffU

enum {
  BFW_NX90_xpic_break_last_pc_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK_LAST_PC_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break_last_pc_val; /* last PC */
} NX90_XPIC_BREAK_LAST_PC_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_XPIC_BREAK_LAST_PC_BIT_T bf;
} NX90_XPIC_BREAK_LAST_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_status */
/* => Read access shows the reason why xPIC is in HOLD / BREAK */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_status            0x00000038U
#define Adr_NX90_xpic_app_debug_xpic_break_status 0xFF8840B8U
#define Adr_NX90_xpic_break_status                0xFF8840B8U

#define MSK_NX90_xpic_break_status_xpic_in_hold      0x00000001U
#define SRT_NX90_xpic_break_status_xpic_in_hold      0
#define MSK_NX90_xpic_break_status_hold              0x00000002U
#define SRT_NX90_xpic_break_status_hold              1
#define MSK_NX90_xpic_break_status_break0            0x00000004U
#define SRT_NX90_xpic_break_status_break0            2
#define MSK_NX90_xpic_break_status_break1            0x00000008U
#define SRT_NX90_xpic_break_status_break1            3
#define MSK_NX90_xpic_break_status_soft_break        0x00000010U
#define SRT_NX90_xpic_break_status_soft_break        4
#define MSK_NX90_xpic_break_status_single_step       0x00000020U
#define SRT_NX90_xpic_break_status_single_step       5
#define MSK_NX90_xpic_break_status_data_misalignment 0x00000040U
#define SRT_NX90_xpic_break_status_data_misalignment 6
#define MSK_NX90_xpic_break_status_break0_read_data  0x00000080U
#define SRT_NX90_xpic_break_status_break0_read_data  7
#define MSK_NX90_xpic_break_status_break1_read_data  0x00000100U
#define SRT_NX90_xpic_break_status_break1_read_data  8
#define MSK_NX90_xpic_break_status_xpic_reset_status 0x00000200U
#define SRT_NX90_xpic_break_status_xpic_reset_status 9

/* all used bits of 'NX90_xpic_break_status': */
#define MSK_USED_BITS_NX90_xpic_break_status 0x000003ffU

enum {
  BFW_NX90_xpic_break_status_xpic_in_hold      = 1,  /* [0] */
  BFW_NX90_xpic_break_status_hold              = 1,  /* [1] */
  BFW_NX90_xpic_break_status_break0            = 1,  /* [2] */
  BFW_NX90_xpic_break_status_break1            = 1,  /* [3] */
  BFW_NX90_xpic_break_status_soft_break        = 1,  /* [4] */
  BFW_NX90_xpic_break_status_single_step       = 1,  /* [5] */
  BFW_NX90_xpic_break_status_data_misalignment = 1,  /* [6] */
  BFW_NX90_xpic_break_status_break0_read_data  = 1,  /* [7] */
  BFW_NX90_xpic_break_status_break1_read_data  = 1,  /* [8] */
  BFW_NX90_xpic_break_status_xpic_reset_status = 1,  /* [9] */
  BFW_NX90_xpic_break_status_reserved1         = 22  /* [31:10] */
};

typedef struct NX90_XPIC_BREAK_STATUS_BIT_Ttag {
  unsigned int xpic_in_hold      : BFW_NX90_xpic_break_status_xpic_in_hold;      /* xPIC is in Break or Hold (read only)                           */
  unsigned int hold              : BFW_NX90_xpic_break_status_hold;              /* global HOLD BIT status 0- start xPIC, 1- hold xPIC (read only) */
  unsigned int break0            : BFW_NX90_xpic_break_status_break0;            /* Breakpoint 0 is active(read only)                              */
  unsigned int break1            : BFW_NX90_xpic_break_status_break1;            /* Breakpoint 1 is active(read only)                              */
  unsigned int soft_break        : BFW_NX90_xpic_break_status_soft_break;        /* Software Break is active(read only)                            */
  unsigned int single_step       : BFW_NX90_xpic_break_status_single_step;       /* Single Step Break is active(read only)                         */
  unsigned int data_misalignment : BFW_NX90_xpic_break_status_data_misalignment; /* Data Misaligment is active(read only)                          */
  unsigned int break0_read_data  : BFW_NX90_xpic_break_status_break0_read_data;  /* Breakpoint 0 last load access (read only)                      */
  unsigned int break1_read_data  : BFW_NX90_xpic_break_status_break1_read_data;  /* Breakpoint 1 last load access (read only)                      */
  unsigned int xpic_reset_status : BFW_NX90_xpic_break_status_xpic_reset_status; /* 1 = XPIC ist in Reset(read only)                               */
  unsigned int reserved1         : BFW_NX90_xpic_break_status_reserved1;         /* reserved                                                       */
} NX90_XPIC_BREAK_STATUS_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_BREAK_STATUS_BIT_T bf;
} NX90_XPIC_BREAK_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_raw */
/* => xPIC_DEBUG Raw IRQ register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_irq_raw            0x0000003CU
#define Adr_NX90_xpic_app_debug_xpic_break_irq_raw 0xFF8840BCU
#define Adr_NX90_xpic_break_irq_raw                0xFF8840BCU
#define DFLT_VAL_NX90_xpic_break_irq_raw           0x00000000U

#define MSK_NX90_xpic_break_irq_raw_break0_irq               0x00000001U
#define SRT_NX90_xpic_break_irq_raw_break0_irq               0
#define DFLT_VAL_NX90_xpic_break_irq_raw_break0_irq          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_raw_break0_irq       0x00000000U
#define MSK_NX90_xpic_break_irq_raw_break1_irq               0x00000002U
#define SRT_NX90_xpic_break_irq_raw_break1_irq               1
#define DFLT_VAL_NX90_xpic_break_irq_raw_break1_irq          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_raw_break1_irq       0x00000000U
#define MSK_NX90_xpic_break_irq_raw_soft_break_irq           0x00000004U
#define SRT_NX90_xpic_break_irq_raw_soft_break_irq           2
#define DFLT_VAL_NX90_xpic_break_irq_raw_soft_break_irq      0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_raw_soft_break_irq   0x00000000U
#define MSK_NX90_xpic_break_irq_raw_single_step_irq          0x00000008U
#define SRT_NX90_xpic_break_irq_raw_single_step_irq          3
#define DFLT_VAL_NX90_xpic_break_irq_raw_single_step_irq     0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_raw_single_step_irq  0x00000000U
#define MSK_NX90_xpic_break_irq_raw_misalignment_irq         0x00000010U
#define SRT_NX90_xpic_break_irq_raw_misalignment_irq         4
#define DFLT_VAL_NX90_xpic_break_irq_raw_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_raw_misalignment_irq 0x00000000U

/* all used bits of 'NX90_xpic_break_irq_raw': */
#define MSK_USED_BITS_NX90_xpic_break_irq_raw 0x0000001fU

enum {
  BFW_NX90_xpic_break_irq_raw_break0_irq       = 1,  /* [0] */
  BFW_NX90_xpic_break_irq_raw_break1_irq       = 1,  /* [1] */
  BFW_NX90_xpic_break_irq_raw_soft_break_irq   = 1,  /* [2] */
  BFW_NX90_xpic_break_irq_raw_single_step_irq  = 1,  /* [3] */
  BFW_NX90_xpic_break_irq_raw_misalignment_irq = 1,  /* [4] */
  BFW_NX90_xpic_break_irq_raw_reserved1        = 27  /* [31:5] */
};

typedef struct NX90_XPIC_BREAK_IRQ_RAW_BIT_Ttag {
  unsigned int break0_irq       : BFW_NX90_xpic_break_irq_raw_break0_irq;       /* Breakpoint 0 Interrupt            */
  unsigned int break1_irq       : BFW_NX90_xpic_break_irq_raw_break1_irq;       /* Breakpoint 1 Interrupt            */
  unsigned int soft_break_irq   : BFW_NX90_xpic_break_irq_raw_soft_break_irq;   /* Software Breakpoint Interrupt     */
  unsigned int single_step_irq  : BFW_NX90_xpic_break_irq_raw_single_step_irq;  /* single step Breakpoint Interrupt  */
  unsigned int misalignment_irq : BFW_NX90_xpic_break_irq_raw_misalignment_irq; /* Data Misalignment Error Interrupt */
  unsigned int reserved1        : BFW_NX90_xpic_break_irq_raw_reserved1;        /* reserved                          */
} NX90_XPIC_BREAK_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_XPIC_BREAK_IRQ_RAW_BIT_T bf;
} NX90_XPIC_BREAK_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_masked */
/* => xPIC_DEBUG Masked IRQ register for other CPU (ARM): */
/*    Shows status of masked IRQs (as connected to ARM) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_irq_masked            0x00000040U
#define Adr_NX90_xpic_app_debug_xpic_break_irq_masked 0xFF8840C0U
#define Adr_NX90_xpic_break_irq_masked                0xFF8840C0U

#define MSK_NX90_xpic_break_irq_masked_break0_irq       0x00000001U
#define SRT_NX90_xpic_break_irq_masked_break0_irq       0
#define MSK_NX90_xpic_break_irq_masked_break1_irq       0x00000002U
#define SRT_NX90_xpic_break_irq_masked_break1_irq       1
#define MSK_NX90_xpic_break_irq_masked_soft_break_irq   0x00000004U
#define SRT_NX90_xpic_break_irq_masked_soft_break_irq   2
#define MSK_NX90_xpic_break_irq_masked_single_step_irq  0x00000008U
#define SRT_NX90_xpic_break_irq_masked_single_step_irq  3
#define MSK_NX90_xpic_break_irq_masked_misalignment_irq 0x00000010U
#define SRT_NX90_xpic_break_irq_masked_misalignment_irq 4

/* all used bits of 'NX90_xpic_break_irq_masked': */
#define MSK_USED_BITS_NX90_xpic_break_irq_masked 0x0000001fU

enum {
  BFW_NX90_xpic_break_irq_masked_break0_irq       = 1,  /* [0] */
  BFW_NX90_xpic_break_irq_masked_break1_irq       = 1,  /* [1] */
  BFW_NX90_xpic_break_irq_masked_soft_break_irq   = 1,  /* [2] */
  BFW_NX90_xpic_break_irq_masked_single_step_irq  = 1,  /* [3] */
  BFW_NX90_xpic_break_irq_masked_misalignment_irq = 1,  /* [4] */
  BFW_NX90_xpic_break_irq_masked_reserved1        = 27  /* [31:5] */
};

typedef struct NX90_XPIC_BREAK_IRQ_MASKED_BIT_Ttag {
  unsigned int break0_irq       : BFW_NX90_xpic_break_irq_masked_break0_irq;       /* Breakpoint 0 Interrupt            */
  unsigned int break1_irq       : BFW_NX90_xpic_break_irq_masked_break1_irq;       /* Breakpoint 1 Interrupt            */
  unsigned int soft_break_irq   : BFW_NX90_xpic_break_irq_masked_soft_break_irq;   /* Software Breakpoint Interrupt     */
  unsigned int single_step_irq  : BFW_NX90_xpic_break_irq_masked_single_step_irq;  /* single step Breakpoint Interrupt  */
  unsigned int misalignment_irq : BFW_NX90_xpic_break_irq_masked_misalignment_irq; /* Data Misalignment Error Interrupt */
  unsigned int reserved1        : BFW_NX90_xpic_break_irq_masked_reserved1;        /* reserved                          */
} NX90_XPIC_BREAK_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_BREAK_IRQ_MASKED_BIT_T bf;
} NX90_XPIC_BREAK_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_msk_set */
/* => xPIC_DEBUG interrupt mask set for other CPU (ARM): */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to xpic_break_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_irq_msk_set            0x00000044U
#define Adr_NX90_xpic_app_debug_xpic_break_irq_msk_set 0xFF8840C4U
#define Adr_NX90_xpic_break_irq_msk_set                0xFF8840C4U
#define DFLT_VAL_NX90_xpic_break_irq_msk_set           0x00000000U

#define MSK_NX90_xpic_break_irq_msk_set_break0_irq               0x00000001U
#define SRT_NX90_xpic_break_irq_msk_set_break0_irq               0
#define DFLT_VAL_NX90_xpic_break_irq_msk_set_break0_irq          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_set_break0_irq       0x00000000U
#define MSK_NX90_xpic_break_irq_msk_set_break1_irq               0x00000002U
#define SRT_NX90_xpic_break_irq_msk_set_break1_irq               1
#define DFLT_VAL_NX90_xpic_break_irq_msk_set_break1_irq          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_set_break1_irq       0x00000000U
#define MSK_NX90_xpic_break_irq_msk_set_soft_break_irq           0x00000004U
#define SRT_NX90_xpic_break_irq_msk_set_soft_break_irq           2
#define DFLT_VAL_NX90_xpic_break_irq_msk_set_soft_break_irq      0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_set_soft_break_irq   0x00000000U
#define MSK_NX90_xpic_break_irq_msk_set_single_step_irq          0x00000008U
#define SRT_NX90_xpic_break_irq_msk_set_single_step_irq          3
#define DFLT_VAL_NX90_xpic_break_irq_msk_set_single_step_irq     0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_set_single_step_irq  0x00000000U
#define MSK_NX90_xpic_break_irq_msk_set_misalignment_irq         0x00000010U
#define SRT_NX90_xpic_break_irq_msk_set_misalignment_irq         4
#define DFLT_VAL_NX90_xpic_break_irq_msk_set_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_set_misalignment_irq 0x00000000U

/* all used bits of 'NX90_xpic_break_irq_msk_set': */
#define MSK_USED_BITS_NX90_xpic_break_irq_msk_set 0x0000001fU

enum {
  BFW_NX90_xpic_break_irq_msk_set_break0_irq       = 1,  /* [0] */
  BFW_NX90_xpic_break_irq_msk_set_break1_irq       = 1,  /* [1] */
  BFW_NX90_xpic_break_irq_msk_set_soft_break_irq   = 1,  /* [2] */
  BFW_NX90_xpic_break_irq_msk_set_single_step_irq  = 1,  /* [3] */
  BFW_NX90_xpic_break_irq_msk_set_misalignment_irq = 1,  /* [4] */
  BFW_NX90_xpic_break_irq_msk_set_reserved1        = 27  /* [31:5] */
};

typedef struct NX90_XPIC_BREAK_IRQ_MSK_SET_BIT_Ttag {
  unsigned int break0_irq       : BFW_NX90_xpic_break_irq_msk_set_break0_irq;       /* Breakpoint 0 Interrupt            */
  unsigned int break1_irq       : BFW_NX90_xpic_break_irq_msk_set_break1_irq;       /* Breakpoint 1 Interrupt            */
  unsigned int soft_break_irq   : BFW_NX90_xpic_break_irq_msk_set_soft_break_irq;   /* Software Breakpoint Interrupt     */
  unsigned int single_step_irq  : BFW_NX90_xpic_break_irq_msk_set_single_step_irq;  /* single step Breakpoint Interrupt  */
  unsigned int misalignment_irq : BFW_NX90_xpic_break_irq_msk_set_misalignment_irq; /* Data Misalignment Error Interrupt */
  unsigned int reserved1        : BFW_NX90_xpic_break_irq_msk_set_reserved1;        /* reserved                          */
} NX90_XPIC_BREAK_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_BREAK_IRQ_MSK_SET_BIT_T bf;
} NX90_XPIC_BREAK_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_msk_reset */
/* => xPIC_DEBUG interrupt mask reset for other CPU (ARM): */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_irq_msk_reset            0x00000048U
#define Adr_NX90_xpic_app_debug_xpic_break_irq_msk_reset 0xFF8840C8U
#define Adr_NX90_xpic_break_irq_msk_reset                0xFF8840C8U
#define DFLT_VAL_NX90_xpic_break_irq_msk_reset           0x00000000U

#define MSK_NX90_xpic_break_irq_msk_reset_break0_irq               0x00000001U
#define SRT_NX90_xpic_break_irq_msk_reset_break0_irq               0
#define DFLT_VAL_NX90_xpic_break_irq_msk_reset_break0_irq          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_reset_break0_irq       0x00000000U
#define MSK_NX90_xpic_break_irq_msk_reset_break1_irq               0x00000002U
#define SRT_NX90_xpic_break_irq_msk_reset_break1_irq               1
#define DFLT_VAL_NX90_xpic_break_irq_msk_reset_break1_irq          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_reset_break1_irq       0x00000000U
#define MSK_NX90_xpic_break_irq_msk_reset_soft_break_irq           0x00000004U
#define SRT_NX90_xpic_break_irq_msk_reset_soft_break_irq           2
#define DFLT_VAL_NX90_xpic_break_irq_msk_reset_soft_break_irq      0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_reset_soft_break_irq   0x00000000U
#define MSK_NX90_xpic_break_irq_msk_reset_single_step_irq          0x00000008U
#define SRT_NX90_xpic_break_irq_msk_reset_single_step_irq          3
#define DFLT_VAL_NX90_xpic_break_irq_msk_reset_single_step_irq     0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_reset_single_step_irq  0x00000000U
#define MSK_NX90_xpic_break_irq_msk_reset_misalignment_irq         0x00000010U
#define SRT_NX90_xpic_break_irq_msk_reset_misalignment_irq         4
#define DFLT_VAL_NX90_xpic_break_irq_msk_reset_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_irq_msk_reset_misalignment_irq 0x00000000U

/* all used bits of 'NX90_xpic_break_irq_msk_reset': */
#define MSK_USED_BITS_NX90_xpic_break_irq_msk_reset 0x0000001fU

enum {
  BFW_NX90_xpic_break_irq_msk_reset_break0_irq       = 1,  /* [0] */
  BFW_NX90_xpic_break_irq_msk_reset_break1_irq       = 1,  /* [1] */
  BFW_NX90_xpic_break_irq_msk_reset_soft_break_irq   = 1,  /* [2] */
  BFW_NX90_xpic_break_irq_msk_reset_single_step_irq  = 1,  /* [3] */
  BFW_NX90_xpic_break_irq_msk_reset_misalignment_irq = 1,  /* [4] */
  BFW_NX90_xpic_break_irq_msk_reset_reserved1        = 27  /* [31:5] */
};

typedef struct NX90_XPIC_BREAK_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int break0_irq       : BFW_NX90_xpic_break_irq_msk_reset_break0_irq;       /* Breakpoint 0 Interrupt            */
  unsigned int break1_irq       : BFW_NX90_xpic_break_irq_msk_reset_break1_irq;       /* Breakpoint 1 Interrupt            */
  unsigned int soft_break_irq   : BFW_NX90_xpic_break_irq_msk_reset_soft_break_irq;   /* Software Breakpoint Interrupt     */
  unsigned int single_step_irq  : BFW_NX90_xpic_break_irq_msk_reset_single_step_irq;  /* single step Breakpoint Interrupt  */
  unsigned int misalignment_irq : BFW_NX90_xpic_break_irq_msk_reset_misalignment_irq; /* Data Misalignment Error Interrupt */
  unsigned int reserved1        : BFW_NX90_xpic_break_irq_msk_reset_reserved1;        /* reserved                          */
} NX90_XPIC_BREAK_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_XPIC_BREAK_IRQ_MSK_RESET_BIT_T bf;
} NX90_XPIC_BREAK_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_own_irq_masked */
/* => xPIC_DEBUG own Masked IRQ register (for xPIC): */
/*    Shows status of masked IRQs (as connected to xPIC) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_own_irq_masked            0x0000004CU
#define Adr_NX90_xpic_app_debug_xpic_break_own_irq_masked 0xFF8840CCU
#define Adr_NX90_xpic_break_own_irq_masked                0xFF8840CCU

#define MSK_NX90_xpic_break_own_irq_masked_misalignment_irq 0x00000001U
#define SRT_NX90_xpic_break_own_irq_masked_misalignment_irq 0

/* all used bits of 'NX90_xpic_break_own_irq_masked': */
#define MSK_USED_BITS_NX90_xpic_break_own_irq_masked 0x00000001U

enum {
  BFW_NX90_xpic_break_own_irq_masked_misalignment_irq = 1,  /* [0] */
  BFW_NX90_xpic_break_own_irq_masked_reserved1        = 31  /* [31:1] */
};

typedef struct NX90_XPIC_BREAK_OWN_IRQ_MASKED_BIT_Ttag {
  unsigned int misalignment_irq : BFW_NX90_xpic_break_own_irq_masked_misalignment_irq; /* Data Misalignment Error Interrupt */
  unsigned int reserved1        : BFW_NX90_xpic_break_own_irq_masked_reserved1;        /* reserved                          */
} NX90_XPIC_BREAK_OWN_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_XPIC_BREAK_OWN_IRQ_MASKED_BIT_T bf;
} NX90_XPIC_BREAK_OWN_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_own_irq_msk_set */
/* => xPIC_DEBUG own interrupt mask set (for xPIC): */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to xpic_break_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_own_irq_msk_set            0x00000050U
#define Adr_NX90_xpic_app_debug_xpic_break_own_irq_msk_set 0xFF8840D0U
#define Adr_NX90_xpic_break_own_irq_msk_set                0xFF8840D0U
#define DFLT_VAL_NX90_xpic_break_own_irq_msk_set           0x00000000U

#define MSK_NX90_xpic_break_own_irq_msk_set_misalignment_irq         0x00000001U
#define SRT_NX90_xpic_break_own_irq_msk_set_misalignment_irq         0
#define DFLT_VAL_NX90_xpic_break_own_irq_msk_set_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_own_irq_msk_set_misalignment_irq 0x00000000U

/* all used bits of 'NX90_xpic_break_own_irq_msk_set': */
#define MSK_USED_BITS_NX90_xpic_break_own_irq_msk_set 0x00000001U

enum {
  BFW_NX90_xpic_break_own_irq_msk_set_misalignment_irq = 1,  /* [0] */
  BFW_NX90_xpic_break_own_irq_msk_set_reserved1        = 31  /* [31:1] */
};

typedef struct NX90_XPIC_BREAK_OWN_IRQ_MSK_SET_BIT_Ttag {
  unsigned int misalignment_irq : BFW_NX90_xpic_break_own_irq_msk_set_misalignment_irq; /* Data Misalignment Error Interrupt */
  unsigned int reserved1        : BFW_NX90_xpic_break_own_irq_msk_set_reserved1;        /* reserved                          */
} NX90_XPIC_BREAK_OWN_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                              val;
  NX90_XPIC_BREAK_OWN_IRQ_MSK_SET_BIT_T bf;
} NX90_XPIC_BREAK_OWN_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_own_irq_msk_reset */
/* => xPIC_DEBUG own interrupt mask reset (for XPIC): */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_own_irq_msk_reset            0x00000054U
#define Adr_NX90_xpic_app_debug_xpic_break_own_irq_msk_reset 0xFF8840D4U
#define Adr_NX90_xpic_break_own_irq_msk_reset                0xFF8840D4U
#define DFLT_VAL_NX90_xpic_break_own_irq_msk_reset           0x00000000U

#define MSK_NX90_xpic_break_own_irq_msk_reset_misalignment_irq         0x00000001U
#define SRT_NX90_xpic_break_own_irq_msk_reset_misalignment_irq         0
#define DFLT_VAL_NX90_xpic_break_own_irq_msk_reset_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_break_own_irq_msk_reset_misalignment_irq 0x00000000U

/* all used bits of 'NX90_xpic_break_own_irq_msk_reset': */
#define MSK_USED_BITS_NX90_xpic_break_own_irq_msk_reset 0x00000001U

enum {
  BFW_NX90_xpic_break_own_irq_msk_reset_misalignment_irq = 1,  /* [0] */
  BFW_NX90_xpic_break_own_irq_msk_reset_reserved1        = 31  /* [31:1] */
};

typedef struct NX90_XPIC_BREAK_OWN_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int misalignment_irq : BFW_NX90_xpic_break_own_irq_msk_reset_misalignment_irq; /* Data Misalignment Error Interrupt */
  unsigned int reserved1        : BFW_NX90_xpic_break_own_irq_msk_reset_reserved1;        /* reserved                          */
} NX90_XPIC_BREAK_OWN_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                                val;
  NX90_XPIC_BREAK_OWN_IRQ_MSK_RESET_BIT_T bf;
} NX90_XPIC_BREAK_OWN_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_return_fiq_pc */
/* => xPIC_DEBUG information FIQ return PC value */
/*    valid if xPIC is in FIQ */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_return_fiq_pc            0x00000058U
#define Adr_NX90_xpic_app_debug_xpic_break_return_fiq_pc 0xFF8840D8U
#define Adr_NX90_xpic_break_return_fiq_pc                0xFF8840D8U

#define MSK_NX90_xpic_break_return_fiq_pc_val 0xffffffffU
#define SRT_NX90_xpic_break_return_fiq_pc_val 0

/* all used bits of 'NX90_xpic_break_return_fiq_pc': */
#define MSK_USED_BITS_NX90_xpic_break_return_fiq_pc 0xffffffffU

enum {
  BFW_NX90_xpic_break_return_fiq_pc_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK_RETURN_FIQ_PC_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break_return_fiq_pc_val; /* xPIC FIQ return value */
} NX90_XPIC_BREAK_RETURN_FIQ_PC_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_XPIC_BREAK_RETURN_FIQ_PC_BIT_T bf;
} NX90_XPIC_BREAK_RETURN_FIQ_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_return_irq_pc */
/* => xPIC_DEBUG information last IRQ return PC value */
/*    valid if xPIC is in IRQ */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_break_return_irq_pc            0x0000005CU
#define Adr_NX90_xpic_app_debug_xpic_break_return_irq_pc 0xFF8840DCU
#define Adr_NX90_xpic_break_return_irq_pc                0xFF8840DCU

#define MSK_NX90_xpic_break_return_irq_pc_val 0xffffffffU
#define SRT_NX90_xpic_break_return_irq_pc_val 0

/* all used bits of 'NX90_xpic_break_return_irq_pc': */
#define MSK_USED_BITS_NX90_xpic_break_return_irq_pc 0xffffffffU

enum {
  BFW_NX90_xpic_break_return_irq_pc_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_BREAK_RETURN_IRQ_PC_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_break_return_irq_pc_val; /* xPIC last IRQ return value */
} NX90_XPIC_BREAK_RETURN_IRQ_PC_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_XPIC_BREAK_RETURN_IRQ_PC_BIT_T bf;
} NX90_XPIC_BREAK_RETURN_IRQ_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_irq_status */
/* => Read access shows the xpic irq status and the xpic irq enable bits */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_irq_status            0x00000060U
#define Adr_NX90_xpic_app_debug_xpic_irq_status 0xFF8840E0U
#define Adr_NX90_xpic_irq_status                0xFF8840E0U

#define MSK_NX90_xpic_irq_status_irq_status 0x00000001U
#define SRT_NX90_xpic_irq_status_irq_status 0
#define MSK_NX90_xpic_irq_status_fiq_status 0x00000002U
#define SRT_NX90_xpic_irq_status_fiq_status 1
#define MSK_NX90_xpic_irq_status_irq_enable 0x00000004U
#define SRT_NX90_xpic_irq_status_irq_enable 2
#define MSK_NX90_xpic_irq_status_fiq_enable 0x00000008U
#define SRT_NX90_xpic_irq_status_fiq_enable 3

/* all used bits of 'NX90_xpic_irq_status': */
#define MSK_USED_BITS_NX90_xpic_irq_status 0x0000000fU

enum {
  BFW_NX90_xpic_irq_status_irq_status = 1,  /* [0] */
  BFW_NX90_xpic_irq_status_fiq_status = 1,  /* [1] */
  BFW_NX90_xpic_irq_status_irq_enable = 1,  /* [2] */
  BFW_NX90_xpic_irq_status_fiq_enable = 1,  /* [3] */
  BFW_NX90_xpic_irq_status_reserved1  = 28  /* [31:4] */
};

typedef struct NX90_XPIC_IRQ_STATUS_BIT_Ttag {
  unsigned int irq_status : BFW_NX90_xpic_irq_status_irq_status; /* IRQ status     */
  unsigned int fiq_status : BFW_NX90_xpic_irq_status_fiq_status; /* FIQ status     */
  unsigned int irq_enable : BFW_NX90_xpic_irq_status_irq_enable; /* IRQ enable bit */
  unsigned int fiq_enable : BFW_NX90_xpic_irq_status_fiq_enable; /* FIQ enable bit */
  unsigned int reserved1  : BFW_NX90_xpic_irq_status_reserved1;  /* reserved       */
} NX90_XPIC_IRQ_STATUS_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_XPIC_IRQ_STATUS_BIT_T bf;
} NX90_XPIC_IRQ_STATUS_T;


/* ===================================================================== */

/* AREA system_xpic */
/* Area of xpic_app_system */

/* ===================================================================== */

#define Addr_NX90_xpic_app_system 0xFF900000U

/* ===================================================================== */

/* AREA xpic_vic */
/* Area of vic_xpic_app */

/* ===================================================================== */

#define Addr_NX90_vic_xpic_app 0xFF900000U

/* --------------------------------------------------------------------- */
/* Register xpic_vic_config */
/* => XPIC VIC Configuration register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_config          0x00000000U
#define Adr_NX90_vic_xpic_app_xpic_vic_config 0xFF900000U
#define Adr_NX90_xpic_vic_config              0xFF900000U
#define DFLT_VAL_NX90_xpic_vic_config         0x00000000U

#define MSK_NX90_xpic_vic_config_enable         0x00000001U
#define SRT_NX90_xpic_vic_config_enable         0
#define DFLT_VAL_NX90_xpic_vic_config_enable    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_config_enable 0x00000000U
#define MSK_NX90_xpic_vic_config_table          0x00000002U
#define SRT_NX90_xpic_vic_config_table          1
#define DFLT_VAL_NX90_xpic_vic_config_table     0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_config_table  0x00000000U

/* all used bits of 'NX90_xpic_vic_config': */
#define MSK_USED_BITS_NX90_xpic_vic_config 0x00000003U

enum {
  BFW_NX90_xpic_vic_config_enable    = 1,  /* [0] */
  BFW_NX90_xpic_vic_config_table     = 1,  /* [1] */
  BFW_NX90_xpic_vic_config_reserved1 = 30  /* [31:2] */
};

typedef struct NX90_XPIC_VIC_CONFIG_BIT_Ttag {
  unsigned int enable    : BFW_NX90_xpic_vic_config_enable;    /* global enable of xPIC VIC (0: disable/ 1: enable)              */
  unsigned int table     : BFW_NX90_xpic_vic_config_table;     /* use far or near Table                                          */
                                                               /* 0 = Base Pointer Addr for IRQ Jmp Table + (n*4) DWORD Table    */
                                                               /* 1 = Base Pointer Addr for IRQ Jmp Table + (n*16) 4 DWORD Table */
                                                               /* n = IRQ vector number                                          */
  unsigned int reserved1 : BFW_NX90_xpic_vic_config_reserved1; /* reserved                                                       */
} NX90_XPIC_VIC_CONFIG_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_XPIC_VIC_CONFIG_BIT_T bf;
} NX90_XPIC_VIC_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_raw_intr0 */
/* => XPIC VIC Raw0 interrupt status register */
/*    see netx4000_irq doc */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_raw_intr0          0x00000004U
#define Adr_NX90_vic_xpic_app_xpic_vic_raw_intr0 0xFF900004U
#define Adr_NX90_xpic_vic_raw_intr0              0xFF900004U

#define MSK_NX90_xpic_vic_raw_intr0_irqs 0xffffffffU
#define SRT_NX90_xpic_vic_raw_intr0_irqs 0

/* all used bits of 'NX90_xpic_vic_raw_intr0': */
#define MSK_USED_BITS_NX90_xpic_vic_raw_intr0 0xffffffffU

enum {
  BFW_NX90_xpic_vic_raw_intr0_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_RAW_INTR0_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_raw_intr0_irqs; /* see netx doc */
} NX90_XPIC_VIC_RAW_INTR0_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_XPIC_VIC_RAW_INTR0_BIT_T bf;
} NX90_XPIC_VIC_RAW_INTR0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_raw_intr1 */
/* => XPIC VIC Raw1 interrupt status register */
/*    see netx4000_irq doc */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_raw_intr1          0x00000008U
#define Adr_NX90_vic_xpic_app_xpic_vic_raw_intr1 0xFF900008U
#define Adr_NX90_xpic_vic_raw_intr1              0xFF900008U

#define MSK_NX90_xpic_vic_raw_intr1_irqs 0xffffffffU
#define SRT_NX90_xpic_vic_raw_intr1_irqs 0

/* all used bits of 'NX90_xpic_vic_raw_intr1': */
#define MSK_USED_BITS_NX90_xpic_vic_raw_intr1 0xffffffffU

enum {
  BFW_NX90_xpic_vic_raw_intr1_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_RAW_INTR1_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_raw_intr1_irqs; /* see netx doc */
} NX90_XPIC_VIC_RAW_INTR1_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_XPIC_VIC_RAW_INTR1_BIT_T bf;
} NX90_XPIC_VIC_RAW_INTR1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_raw_intr2 */
/* => XPIC VIC Raw2 interrupt status register */
/*    see netx4000_irq doc */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_raw_intr2          0x0000000CU
#define Adr_NX90_vic_xpic_app_xpic_vic_raw_intr2 0xFF90000CU
#define Adr_NX90_xpic_vic_raw_intr2              0xFF90000CU

#define MSK_NX90_xpic_vic_raw_intr2_irqs 0xffffffffU
#define SRT_NX90_xpic_vic_raw_intr2_irqs 0

/* all used bits of 'NX90_xpic_vic_raw_intr2': */
#define MSK_USED_BITS_NX90_xpic_vic_raw_intr2 0xffffffffU

enum {
  BFW_NX90_xpic_vic_raw_intr2_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_RAW_INTR2_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_raw_intr2_irqs; /* see netx doc */
} NX90_XPIC_VIC_RAW_INTR2_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_XPIC_VIC_RAW_INTR2_BIT_T bf;
} NX90_XPIC_VIC_RAW_INTR2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint0_set */
/* => XPIC VIC Software0 interrupt set register: */
/*    Read status or set IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_softint0_set          0x00000010U
#define Adr_NX90_vic_xpic_app_xpic_vic_softint0_set 0xFF900010U
#define Adr_NX90_xpic_vic_softint0_set              0xFF900010U
#define DFLT_VAL_NX90_xpic_vic_softint0_set         0x00000000U

#define MSK_NX90_xpic_vic_softint0_set_irqs         0xffffffffU
#define SRT_NX90_xpic_vic_softint0_set_irqs         0
#define DFLT_VAL_NX90_xpic_vic_softint0_set_irqs    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_softint0_set_irqs 0x00000000U

/* all used bits of 'NX90_xpic_vic_softint0_set': */
#define MSK_USED_BITS_NX90_xpic_vic_softint0_set 0xffffffffU

enum {
  BFW_NX90_xpic_vic_softint0_set_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_SOFTINT0_SET_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_softint0_set_irqs; /* see netx doc */
} NX90_XPIC_VIC_SOFTINT0_SET_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_SOFTINT0_SET_BIT_T bf;
} NX90_XPIC_VIC_SOFTINT0_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint1_set */
/* => XPIC VIC Software1 interrupt set register: */
/*    Read status or set IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_softint1_set          0x00000014U
#define Adr_NX90_vic_xpic_app_xpic_vic_softint1_set 0xFF900014U
#define Adr_NX90_xpic_vic_softint1_set              0xFF900014U
#define DFLT_VAL_NX90_xpic_vic_softint1_set         0x00000000U

#define MSK_NX90_xpic_vic_softint1_set_irqs         0xffffffffU
#define SRT_NX90_xpic_vic_softint1_set_irqs         0
#define DFLT_VAL_NX90_xpic_vic_softint1_set_irqs    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_softint1_set_irqs 0x00000000U

/* all used bits of 'NX90_xpic_vic_softint1_set': */
#define MSK_USED_BITS_NX90_xpic_vic_softint1_set 0xffffffffU

enum {
  BFW_NX90_xpic_vic_softint1_set_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_SOFTINT1_SET_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_softint1_set_irqs; /* see netx doc */
} NX90_XPIC_VIC_SOFTINT1_SET_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_SOFTINT1_SET_BIT_T bf;
} NX90_XPIC_VIC_SOFTINT1_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint2_set */
/* => XPIC VIC Software2 interrupt set register: */
/*    Read status or set IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_softint2_set          0x00000018U
#define Adr_NX90_vic_xpic_app_xpic_vic_softint2_set 0xFF900018U
#define Adr_NX90_xpic_vic_softint2_set              0xFF900018U
#define DFLT_VAL_NX90_xpic_vic_softint2_set         0x00000000U

#define MSK_NX90_xpic_vic_softint2_set_irqs         0xffffffffU
#define SRT_NX90_xpic_vic_softint2_set_irqs         0
#define DFLT_VAL_NX90_xpic_vic_softint2_set_irqs    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_softint2_set_irqs 0x00000000U

/* all used bits of 'NX90_xpic_vic_softint2_set': */
#define MSK_USED_BITS_NX90_xpic_vic_softint2_set 0xffffffffU

enum {
  BFW_NX90_xpic_vic_softint2_set_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_SOFTINT2_SET_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_softint2_set_irqs; /* see netx doc */
} NX90_XPIC_VIC_SOFTINT2_SET_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_SOFTINT2_SET_BIT_T bf;
} NX90_XPIC_VIC_SOFTINT2_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint0_reset */
/* => XPIC VIC Software0 interrupt reset register: */
/*    Read status or reset IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_softint0_reset          0x0000001CU
#define Adr_NX90_vic_xpic_app_xpic_vic_softint0_reset 0xFF90001CU
#define Adr_NX90_xpic_vic_softint0_reset              0xFF90001CU
#define DFLT_VAL_NX90_xpic_vic_softint0_reset         0x00000000U

#define MSK_NX90_xpic_vic_softint0_reset_irqs         0xffffffffU
#define SRT_NX90_xpic_vic_softint0_reset_irqs         0
#define DFLT_VAL_NX90_xpic_vic_softint0_reset_irqs    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_softint0_reset_irqs 0x00000000U

/* all used bits of 'NX90_xpic_vic_softint0_reset': */
#define MSK_USED_BITS_NX90_xpic_vic_softint0_reset 0xffffffffU

enum {
  BFW_NX90_xpic_vic_softint0_reset_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_SOFTINT0_RESET_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_softint0_reset_irqs; /* see netx doc */
} NX90_XPIC_VIC_SOFTINT0_RESET_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_XPIC_VIC_SOFTINT0_RESET_BIT_T bf;
} NX90_XPIC_VIC_SOFTINT0_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint1_reset */
/* => XPIC VIC Software1 interrupt reset register: */
/*    Read status or reset IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_softint1_reset          0x00000020U
#define Adr_NX90_vic_xpic_app_xpic_vic_softint1_reset 0xFF900020U
#define Adr_NX90_xpic_vic_softint1_reset              0xFF900020U
#define DFLT_VAL_NX90_xpic_vic_softint1_reset         0x00000000U

#define MSK_NX90_xpic_vic_softint1_reset_irqs         0xffffffffU
#define SRT_NX90_xpic_vic_softint1_reset_irqs         0
#define DFLT_VAL_NX90_xpic_vic_softint1_reset_irqs    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_softint1_reset_irqs 0x00000000U

/* all used bits of 'NX90_xpic_vic_softint1_reset': */
#define MSK_USED_BITS_NX90_xpic_vic_softint1_reset 0xffffffffU

enum {
  BFW_NX90_xpic_vic_softint1_reset_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_SOFTINT1_RESET_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_softint1_reset_irqs; /* see netx doc */
} NX90_XPIC_VIC_SOFTINT1_RESET_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_XPIC_VIC_SOFTINT1_RESET_BIT_T bf;
} NX90_XPIC_VIC_SOFTINT1_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint2_reset */
/* => XPIC VIC Software2 interrupt reset register: */
/*    Read status or reset IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_softint2_reset          0x00000024U
#define Adr_NX90_vic_xpic_app_xpic_vic_softint2_reset 0xFF900024U
#define Adr_NX90_xpic_vic_softint2_reset              0xFF900024U
#define DFLT_VAL_NX90_xpic_vic_softint2_reset         0x00000000U

#define MSK_NX90_xpic_vic_softint2_reset_irqs         0xffffffffU
#define SRT_NX90_xpic_vic_softint2_reset_irqs         0
#define DFLT_VAL_NX90_xpic_vic_softint2_reset_irqs    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_softint2_reset_irqs 0x00000000U

/* all used bits of 'NX90_xpic_vic_softint2_reset': */
#define MSK_USED_BITS_NX90_xpic_vic_softint2_reset 0xffffffffU

enum {
  BFW_NX90_xpic_vic_softint2_reset_irqs = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_SOFTINT2_RESET_BIT_Ttag {
  unsigned int irqs : BFW_NX90_xpic_vic_softint2_reset_irqs; /* see netx doc */
} NX90_XPIC_VIC_SOFTINT2_RESET_BIT_T;

typedef union {
  uint32_t                           val;
  NX90_XPIC_VIC_SOFTINT2_RESET_BIT_T bf;
} NX90_XPIC_VIC_SOFTINT2_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_addr */
/* => XPIC VIC FIQ Vector address 0 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_fiq_addr          0x00000028U
#define Adr_NX90_vic_xpic_app_xpic_vic_fiq_addr 0xFF900028U
#define Adr_NX90_xpic_vic_fiq_addr              0xFF900028U
#define DFLT_VAL_NX90_xpic_vic_fiq_addr         0x00000000U

#define MSK_NX90_xpic_vic_fiq_addr_val         0xffffffffU
#define SRT_NX90_xpic_vic_fiq_addr_val         0
#define DFLT_VAL_NX90_xpic_vic_fiq_addr_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_fiq_addr_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_fiq_addr': */
#define MSK_USED_BITS_NX90_xpic_vic_fiq_addr 0xffffffffU

enum {
  BFW_NX90_xpic_vic_fiq_addr_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_FIQ_ADDR_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_fiq_addr_val; /* FIQ handler address */
} NX90_XPIC_VIC_FIQ_ADDR_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_VIC_FIQ_ADDR_BIT_T bf;
} NX90_XPIC_VIC_FIQ_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_irq_addr */
/* => XPIC VIC normal IRQ address register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_irq_addr          0x0000002CU
#define Adr_NX90_vic_xpic_app_xpic_vic_irq_addr 0xFF90002CU
#define Adr_NX90_xpic_vic_irq_addr              0xFF90002CU
#define DFLT_VAL_NX90_xpic_vic_irq_addr         0x00000000U

#define MSK_NX90_xpic_vic_irq_addr_val         0xffffffffU
#define SRT_NX90_xpic_vic_irq_addr_val         0
#define DFLT_VAL_NX90_xpic_vic_irq_addr_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_irq_addr_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_irq_addr': */
#define MSK_USED_BITS_NX90_xpic_vic_irq_addr 0xffffffffU

enum {
  BFW_NX90_xpic_vic_irq_addr_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_IRQ_ADDR_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_irq_addr_val; /* IRQ handler address */
} NX90_XPIC_VIC_IRQ_ADDR_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_VIC_IRQ_ADDR_BIT_T bf;
} NX90_XPIC_VIC_IRQ_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vector_addr */
/* => XPIC VIC IRQ Vector address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vector_addr          0x00000030U
#define Adr_NX90_vic_xpic_app_xpic_vic_vector_addr 0xFF900030U
#define Adr_NX90_xpic_vic_vector_addr              0xFF900030U

#define MSK_NX90_xpic_vic_vector_addr_val 0xffffffffU
#define SRT_NX90_xpic_vic_vector_addr_val 0

/* all used bits of 'NX90_xpic_vic_vector_addr': */
#define MSK_USED_BITS_NX90_xpic_vic_vector_addr 0xffffffffU

enum {
  BFW_NX90_xpic_vic_vector_addr_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_VECTOR_ADDR_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_vector_addr_val; /* IRQ vector address                                                  */
                                                        /* read access get actuel highest prior IRQ                            */
                                                        /* read access get  adr_xpic_vic_table_base_addr + IRQ Number * (4/16) */
} NX90_XPIC_VIC_VECTOR_ADDR_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_XPIC_VIC_VECTOR_ADDR_BIT_T bf;
} NX90_XPIC_VIC_VECTOR_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_table_base_addr */
/* => XPIC VIC IRQ TABLE ADDRESS BASE POINTER */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_table_base_addr          0x00000034U
#define Adr_NX90_vic_xpic_app_xpic_vic_table_base_addr 0xFF900034U
#define Adr_NX90_xpic_vic_table_base_addr              0xFF900034U
#define DFLT_VAL_NX90_xpic_vic_table_base_addr         0x00000000U

#define MSK_NX90_xpic_vic_table_base_addr_val         0xffffffffU
#define SRT_NX90_xpic_vic_table_base_addr_val         0
#define DFLT_VAL_NX90_xpic_vic_table_base_addr_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_table_base_addr_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_table_base_addr': */
#define MSK_USED_BITS_NX90_xpic_vic_table_base_addr 0xffffffffU

enum {
  BFW_NX90_xpic_vic_table_base_addr_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_TABLE_BASE_ADDR_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_table_base_addr_val; /* IRQ Table base address                  */
                                                            /* the Base Pointer Addr for IRQ Jmp Table */
} NX90_XPIC_VIC_TABLE_BASE_ADDR_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_XPIC_VIC_TABLE_BASE_ADDR_BIT_T bf;
} NX90_XPIC_VIC_TABLE_BASE_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_vect_config */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_fiq_vect_config          0x00000038U
#define Adr_NX90_vic_xpic_app_xpic_vic_fiq_vect_config 0xFF900038U
#define Adr_NX90_xpic_vic_fiq_vect_config              0xFF900038U
#define DFLT_VAL_NX90_xpic_vic_fiq_vect_config         0x00000000U

#define MSK_NX90_xpic_vic_fiq_vect_config_int_source                 0x0000007fU
#define SRT_NX90_xpic_vic_fiq_vect_config_int_source                 0
#define DFLT_VAL_NX90_xpic_vic_fiq_vect_config_int_source            0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_fiq_vect_config_int_source         0x00000000U
#define MSK_NX90_xpic_vic_fiq_vect_config_select_fiq_default         0x40000000U
#define SRT_NX90_xpic_vic_fiq_vect_config_select_fiq_default         30
#define DFLT_VAL_NX90_xpic_vic_fiq_vect_config_select_fiq_default    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_fiq_vect_config_select_fiq_default 0x00000000U
#define MSK_NX90_xpic_vic_fiq_vect_config_enable                     0x80000000U
#define SRT_NX90_xpic_vic_fiq_vect_config_enable                     31
#define DFLT_VAL_NX90_xpic_vic_fiq_vect_config_enable                0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_fiq_vect_config_enable             0x00000000U

/* all used bits of 'NX90_xpic_vic_fiq_vect_config': */
#define MSK_USED_BITS_NX90_xpic_vic_fiq_vect_config 0xc000007fU

enum {
  BFW_NX90_xpic_vic_fiq_vect_config_int_source         = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_fiq_vect_config_reserved1          = 23, /* [29:7] */
  BFW_NX90_xpic_vic_fiq_vect_config_select_fiq_default = 1,  /* [30] */
  BFW_NX90_xpic_vic_fiq_vect_config_enable             = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_FIQ_VECT_CONFIG_BIT_Ttag {
  unsigned int int_source         : BFW_NX90_xpic_vic_fiq_vect_config_int_source;         /* INT_SOURCE 0-95                                                        */
  unsigned int reserved1          : BFW_NX90_xpic_vic_fiq_vect_config_reserved1;          /* reserved                                                               */
  unsigned int select_fiq_default : BFW_NX90_xpic_vic_fiq_vect_config_select_fiq_default; /* 1 = select default vector for fiq (overwrite the int_source selection) */
  unsigned int enable             : BFW_NX90_xpic_vic_fiq_vect_config_enable;             /* vector interrupt enable                                                */
} NX90_XPIC_VIC_FIQ_VECT_CONFIG_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_XPIC_VIC_FIQ_VECT_CONFIG_BIT_T bf;
} NX90_XPIC_VIC_FIQ_VECT_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config0 */
/* => highest priority */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config0          0x0000003CU
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config0 0xFF90003CU
#define Adr_NX90_xpic_vic_vect_config0              0xFF90003CU
#define DFLT_VAL_NX90_xpic_vic_vect_config0         0x00000000U

#define MSK_NX90_xpic_vic_vect_config0_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config0_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config0_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config0_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config0_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config0_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config0_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config0_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config0': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config0 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config0_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config0_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config0_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG0_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config0_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config0_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config0_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG0_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG0_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config1 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config1          0x00000040U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config1 0xFF900040U
#define Adr_NX90_xpic_vic_vect_config1              0xFF900040U
#define DFLT_VAL_NX90_xpic_vic_vect_config1         0x00000000U

#define MSK_NX90_xpic_vic_vect_config1_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config1_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config1_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config1_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config1_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config1_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config1_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config1_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config1': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config1 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config1_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config1_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config1_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG1_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config1_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config1_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config1_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG1_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG1_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config2 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config2          0x00000044U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config2 0xFF900044U
#define Adr_NX90_xpic_vic_vect_config2              0xFF900044U
#define DFLT_VAL_NX90_xpic_vic_vect_config2         0x00000000U

#define MSK_NX90_xpic_vic_vect_config2_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config2_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config2_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config2_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config2_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config2_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config2_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config2_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config2': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config2 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config2_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config2_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config2_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG2_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config2_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config2_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config2_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG2_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG2_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config3 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config3          0x00000048U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config3 0xFF900048U
#define Adr_NX90_xpic_vic_vect_config3              0xFF900048U
#define DFLT_VAL_NX90_xpic_vic_vect_config3         0x00000000U

#define MSK_NX90_xpic_vic_vect_config3_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config3_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config3_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config3_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config3_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config3_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config3_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config3_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config3': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config3 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config3_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config3_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config3_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG3_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config3_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config3_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config3_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG3_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG3_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG3_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config4 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config4          0x0000004CU
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config4 0xFF90004CU
#define Adr_NX90_xpic_vic_vect_config4              0xFF90004CU
#define DFLT_VAL_NX90_xpic_vic_vect_config4         0x00000000U

#define MSK_NX90_xpic_vic_vect_config4_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config4_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config4_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config4_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config4_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config4_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config4_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config4_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config4': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config4 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config4_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config4_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config4_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG4_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config4_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config4_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config4_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG4_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG4_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG4_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config5 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config5          0x00000050U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config5 0xFF900050U
#define Adr_NX90_xpic_vic_vect_config5              0xFF900050U
#define DFLT_VAL_NX90_xpic_vic_vect_config5         0x00000000U

#define MSK_NX90_xpic_vic_vect_config5_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config5_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config5_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config5_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config5_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config5_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config5_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config5_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config5': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config5 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config5_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config5_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config5_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG5_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config5_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config5_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config5_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG5_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG5_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG5_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config6 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config6          0x00000054U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config6 0xFF900054U
#define Adr_NX90_xpic_vic_vect_config6              0xFF900054U
#define DFLT_VAL_NX90_xpic_vic_vect_config6         0x00000000U

#define MSK_NX90_xpic_vic_vect_config6_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config6_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config6_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config6_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config6_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config6_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config6_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config6_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config6': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config6 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config6_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config6_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config6_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG6_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config6_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config6_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config6_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG6_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG6_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG6_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config7 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config7          0x00000058U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config7 0xFF900058U
#define Adr_NX90_xpic_vic_vect_config7              0xFF900058U
#define DFLT_VAL_NX90_xpic_vic_vect_config7         0x00000000U

#define MSK_NX90_xpic_vic_vect_config7_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config7_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config7_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config7_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config7_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config7_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config7_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config7_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config7': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config7 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config7_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config7_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config7_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG7_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config7_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config7_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config7_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG7_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG7_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG7_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config8 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config8          0x0000005CU
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config8 0xFF90005CU
#define Adr_NX90_xpic_vic_vect_config8              0xFF90005CU
#define DFLT_VAL_NX90_xpic_vic_vect_config8         0x00000000U

#define MSK_NX90_xpic_vic_vect_config8_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config8_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config8_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config8_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config8_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config8_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config8_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config8_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config8': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config8 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config8_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config8_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config8_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG8_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config8_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config8_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config8_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG8_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG8_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG8_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config9 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config9          0x00000060U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config9 0xFF900060U
#define Adr_NX90_xpic_vic_vect_config9              0xFF900060U
#define DFLT_VAL_NX90_xpic_vic_vect_config9         0x00000000U

#define MSK_NX90_xpic_vic_vect_config9_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config9_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config9_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config9_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config9_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config9_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config9_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config9_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config9': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config9 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config9_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config9_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config9_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG9_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config9_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config9_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config9_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG9_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_VECT_CONFIG9_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG9_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config10 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config10          0x00000064U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config10 0xFF900064U
#define Adr_NX90_xpic_vic_vect_config10              0xFF900064U
#define DFLT_VAL_NX90_xpic_vic_vect_config10         0x00000000U

#define MSK_NX90_xpic_vic_vect_config10_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config10_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config10_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config10_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config10_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config10_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config10_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config10_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config10': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config10 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config10_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config10_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config10_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG10_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config10_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config10_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config10_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG10_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_VIC_VECT_CONFIG10_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG10_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config11 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config11          0x00000068U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config11 0xFF900068U
#define Adr_NX90_xpic_vic_vect_config11              0xFF900068U
#define DFLT_VAL_NX90_xpic_vic_vect_config11         0x00000000U

#define MSK_NX90_xpic_vic_vect_config11_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config11_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config11_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config11_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config11_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config11_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config11_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config11_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config11': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config11 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config11_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config11_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config11_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG11_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config11_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config11_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config11_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG11_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_VIC_VECT_CONFIG11_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG11_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config12 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config12          0x0000006CU
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config12 0xFF90006CU
#define Adr_NX90_xpic_vic_vect_config12              0xFF90006CU
#define DFLT_VAL_NX90_xpic_vic_vect_config12         0x00000000U

#define MSK_NX90_xpic_vic_vect_config12_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config12_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config12_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config12_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config12_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config12_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config12_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config12_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config12': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config12 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config12_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config12_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config12_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG12_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config12_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config12_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config12_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG12_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_VIC_VECT_CONFIG12_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG12_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config13 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config13          0x00000070U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config13 0xFF900070U
#define Adr_NX90_xpic_vic_vect_config13              0xFF900070U
#define DFLT_VAL_NX90_xpic_vic_vect_config13         0x00000000U

#define MSK_NX90_xpic_vic_vect_config13_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config13_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config13_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config13_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config13_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config13_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config13_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config13_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config13': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config13 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config13_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config13_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config13_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG13_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config13_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config13_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config13_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG13_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_VIC_VECT_CONFIG13_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG13_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config14 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config14          0x00000074U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config14 0xFF900074U
#define Adr_NX90_xpic_vic_vect_config14              0xFF900074U
#define DFLT_VAL_NX90_xpic_vic_vect_config14         0x00000000U

#define MSK_NX90_xpic_vic_vect_config14_int_source         0x0000007fU
#define SRT_NX90_xpic_vic_vect_config14_int_source         0
#define DFLT_VAL_NX90_xpic_vic_vect_config14_int_source    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config14_int_source 0x00000000U
#define MSK_NX90_xpic_vic_vect_config14_enable             0x80000000U
#define SRT_NX90_xpic_vic_vect_config14_enable             31
#define DFLT_VAL_NX90_xpic_vic_vect_config14_enable        0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config14_enable     0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config14': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config14 0x8000007fU

enum {
  BFW_NX90_xpic_vic_vect_config14_int_source = 7,  /* [6:0] */
  BFW_NX90_xpic_vic_vect_config14_reserved1  = 24, /* [30:7] */
  BFW_NX90_xpic_vic_vect_config14_enable     = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG14_BIT_Ttag {
  unsigned int int_source : BFW_NX90_xpic_vic_vect_config14_int_source; /* INT_SOURCE 0-95         */
  unsigned int reserved1  : BFW_NX90_xpic_vic_vect_config14_reserved1;  /* reserved                */
  unsigned int enable     : BFW_NX90_xpic_vic_vect_config14_enable;     /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG14_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_VIC_VECT_CONFIG14_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG14_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config15 */
/* => XPIC default interrupt vector, all interrupt sources (wired-OR) */
/*    select with default interrupt vector register */
/*    lowest priority */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_vect_config15          0x00000078U
#define Adr_NX90_vic_xpic_app_xpic_vic_vect_config15 0xFF900078U
#define Adr_NX90_xpic_vic_vect_config15              0xFF900078U
#define DFLT_VAL_NX90_xpic_vic_vect_config15         0x00000000U

#define MSK_NX90_xpic_vic_vect_config15_enable         0x80000000U
#define SRT_NX90_xpic_vic_vect_config15_enable         31
#define DFLT_VAL_NX90_xpic_vic_vect_config15_enable    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_vect_config15_enable 0x00000000U

/* all used bits of 'NX90_xpic_vic_vect_config15': */
#define MSK_USED_BITS_NX90_xpic_vic_vect_config15 0x80000000U

enum {
  BFW_NX90_xpic_vic_vect_config15_reserved1 = 31, /* [30:0] */
  BFW_NX90_xpic_vic_vect_config15_enable    = 1   /* [31] */
};

typedef struct NX90_XPIC_VIC_VECT_CONFIG15_BIT_Ttag {
  unsigned int reserved1 : BFW_NX90_xpic_vic_vect_config15_reserved1; /* reserved                */
  unsigned int enable    : BFW_NX90_xpic_vic_vect_config15_enable;    /* vector interrupt enable */
} NX90_XPIC_VIC_VECT_CONFIG15_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_VIC_VECT_CONFIG15_BIT_T bf;
} NX90_XPIC_VIC_VECT_CONFIG15_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_default0 */
/* => XPIC default interrupt vector select0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_default0          0x0000007CU
#define Adr_NX90_vic_xpic_app_xpic_vic_default0 0xFF90007CU
#define Adr_NX90_xpic_vic_default0              0xFF90007CU
#define DFLT_VAL_NX90_xpic_vic_default0         0x00000000U

#define MSK_NX90_xpic_vic_default0_val         0xffffffffU
#define SRT_NX90_xpic_vic_default0_val         0
#define DFLT_VAL_NX90_xpic_vic_default0_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_default0_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_default0': */
#define MSK_USED_BITS_NX90_xpic_vic_default0 0xffffffffU

enum {
  BFW_NX90_xpic_vic_default0_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_DEFAULT0_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_default0_val; /* select int0 - int31 (wired-OR) 1-selected 0-not selected */
} NX90_XPIC_VIC_DEFAULT0_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_VIC_DEFAULT0_BIT_T bf;
} NX90_XPIC_VIC_DEFAULT0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_default1 */
/* => XPIC default interrupt vector select1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_default1          0x00000080U
#define Adr_NX90_vic_xpic_app_xpic_vic_default1 0xFF900080U
#define Adr_NX90_xpic_vic_default1              0xFF900080U
#define DFLT_VAL_NX90_xpic_vic_default1         0x00000000U

#define MSK_NX90_xpic_vic_default1_val         0xffffffffU
#define SRT_NX90_xpic_vic_default1_val         0
#define DFLT_VAL_NX90_xpic_vic_default1_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_default1_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_default1': */
#define MSK_USED_BITS_NX90_xpic_vic_default1 0xffffffffU

enum {
  BFW_NX90_xpic_vic_default1_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_DEFAULT1_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_default1_val; /* select int32 - int63 (wired-OR) 1-selected 0-not selected */
} NX90_XPIC_VIC_DEFAULT1_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_VIC_DEFAULT1_BIT_T bf;
} NX90_XPIC_VIC_DEFAULT1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_default2 */
/* => XPIC default interrupt vector select1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_default2          0x00000084U
#define Adr_NX90_vic_xpic_app_xpic_vic_default2 0xFF900084U
#define Adr_NX90_xpic_vic_default2              0xFF900084U
#define DFLT_VAL_NX90_xpic_vic_default2         0x00000000U

#define MSK_NX90_xpic_vic_default2_val         0xffffffffU
#define SRT_NX90_xpic_vic_default2_val         0
#define DFLT_VAL_NX90_xpic_vic_default2_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_default2_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_default2': */
#define MSK_USED_BITS_NX90_xpic_vic_default2 0xffffffffU

enum {
  BFW_NX90_xpic_vic_default2_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_DEFAULT2_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_default2_val; /* select int64 - int95 (wired-OR) 1-selected 0-not selected */
} NX90_XPIC_VIC_DEFAULT2_BIT_T;

typedef union {
  uint32_t                     val;
  NX90_XPIC_VIC_DEFAULT2_BIT_T bf;
} NX90_XPIC_VIC_DEFAULT2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_default0 */
/* => XPIC default interrupt vector select0 for fiq */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_fiq_default0          0x00000088U
#define Adr_NX90_vic_xpic_app_xpic_vic_fiq_default0 0xFF900088U
#define Adr_NX90_xpic_vic_fiq_default0              0xFF900088U
#define DFLT_VAL_NX90_xpic_vic_fiq_default0         0x00000000U

#define MSK_NX90_xpic_vic_fiq_default0_val         0xffffffffU
#define SRT_NX90_xpic_vic_fiq_default0_val         0
#define DFLT_VAL_NX90_xpic_vic_fiq_default0_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_fiq_default0_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_fiq_default0': */
#define MSK_USED_BITS_NX90_xpic_vic_fiq_default0 0xffffffffU

enum {
  BFW_NX90_xpic_vic_fiq_default0_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_FIQ_DEFAULT0_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_fiq_default0_val; /* select int0 - int31 (wired-OR) 1-selected 0-not selected */
} NX90_XPIC_VIC_FIQ_DEFAULT0_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_FIQ_DEFAULT0_BIT_T bf;
} NX90_XPIC_VIC_FIQ_DEFAULT0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_default1 */
/* => XPIC default interrupt vector select1 for fiq */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_fiq_default1          0x0000008CU
#define Adr_NX90_vic_xpic_app_xpic_vic_fiq_default1 0xFF90008CU
#define Adr_NX90_xpic_vic_fiq_default1              0xFF90008CU
#define DFLT_VAL_NX90_xpic_vic_fiq_default1         0x00000000U

#define MSK_NX90_xpic_vic_fiq_default1_val         0xffffffffU
#define SRT_NX90_xpic_vic_fiq_default1_val         0
#define DFLT_VAL_NX90_xpic_vic_fiq_default1_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_fiq_default1_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_fiq_default1': */
#define MSK_USED_BITS_NX90_xpic_vic_fiq_default1 0xffffffffU

enum {
  BFW_NX90_xpic_vic_fiq_default1_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_FIQ_DEFAULT1_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_fiq_default1_val; /* select int32 - int63 (wired-OR) 1-selected 0-not selected */
} NX90_XPIC_VIC_FIQ_DEFAULT1_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_FIQ_DEFAULT1_BIT_T bf;
} NX90_XPIC_VIC_FIQ_DEFAULT1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_default2 */
/* => XPIC default interrupt vector select1 for fiq */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_vic_fiq_default2          0x00000090U
#define Adr_NX90_vic_xpic_app_xpic_vic_fiq_default2 0xFF900090U
#define Adr_NX90_xpic_vic_fiq_default2              0xFF900090U
#define DFLT_VAL_NX90_xpic_vic_fiq_default2         0x00000000U

#define MSK_NX90_xpic_vic_fiq_default2_val         0xffffffffU
#define SRT_NX90_xpic_vic_fiq_default2_val         0
#define DFLT_VAL_NX90_xpic_vic_fiq_default2_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_vic_fiq_default2_val 0x00000000U

/* all used bits of 'NX90_xpic_vic_fiq_default2': */
#define MSK_USED_BITS_NX90_xpic_vic_fiq_default2 0xffffffffU

enum {
  BFW_NX90_xpic_vic_fiq_default2_val = 32  /* [31:0] */
};

typedef struct NX90_XPIC_VIC_FIQ_DEFAULT2_BIT_Ttag {
  unsigned int val : BFW_NX90_xpic_vic_fiq_default2_val; /* select int64 - int95 (wired-OR) 1-selected 0-not selected */
} NX90_XPIC_VIC_FIQ_DEFAULT2_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_XPIC_VIC_FIQ_DEFAULT2_BIT_T bf;
} NX90_XPIC_VIC_FIQ_DEFAULT2_T;


/* ===================================================================== */

/* AREA xpic_wdg */
/* Area of wdg_xpic_app */

/* ===================================================================== */

#define Addr_NX90_wdg_xpic_app 0xFF900180U

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_trig */
/* => netX xPIC Watchdog Trigger Register. */
/*    The watchdog access code is generated by a pseudo random generator. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_trig          0x00000000U
#define Adr_NX90_wdg_xpic_app_xpic_wdg_trig 0xFF900180U
#define Adr_NX90_xpic_wdg_trig              0xFF900180U
#define DFLT_VAL_NX90_xpic_wdg_trig         0x00000000U

#define MSK_NX90_xpic_wdg_trig_wdg_access_code               0x000fffffU
#define SRT_NX90_xpic_wdg_trig_wdg_access_code               0
#define DFLT_VAL_NX90_xpic_wdg_trig_wdg_access_code          0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_trig_wdg_access_code       0x00000000U
#define MSK_NX90_xpic_wdg_trig_irq_req_watchdog              0x01000000U
#define SRT_NX90_xpic_wdg_trig_irq_req_watchdog              24
#define DFLT_VAL_NX90_xpic_wdg_trig_irq_req_watchdog         0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_trig_irq_req_watchdog      0x00000000U
#define MSK_NX90_xpic_wdg_trig_wdg_counter_trigger_w         0x10000000U
#define SRT_NX90_xpic_wdg_trig_wdg_counter_trigger_w         28
#define DFLT_VAL_NX90_xpic_wdg_trig_wdg_counter_trigger_w    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_trig_wdg_counter_trigger_w 0x00000000U
#define MSK_NX90_xpic_wdg_trig_write_enable                  0x80000000U
#define SRT_NX90_xpic_wdg_trig_write_enable                  31
#define DFLT_VAL_NX90_xpic_wdg_trig_write_enable             0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_trig_write_enable          0x00000000U

/* all used bits of 'NX90_xpic_wdg_trig': */
#define MSK_USED_BITS_NX90_xpic_wdg_trig 0x910fffffU

enum {
  BFW_NX90_xpic_wdg_trig_wdg_access_code       = 20, /* [19:0] */
  BFW_NX90_xpic_wdg_trig_reserved1             = 4,  /* [23:20] */
  BFW_NX90_xpic_wdg_trig_irq_req_watchdog      = 1,  /* [24] */
  BFW_NX90_xpic_wdg_trig_reserved2             = 3,  /* [27:25] */
  BFW_NX90_xpic_wdg_trig_wdg_counter_trigger_w = 1,  /* [28] */
  BFW_NX90_xpic_wdg_trig_reserved3             = 2,  /* [30:29] */
  BFW_NX90_xpic_wdg_trig_write_enable          = 1   /* [31] */
};

typedef struct NX90_XPIC_WDG_TRIG_BIT_Ttag {
  unsigned int wdg_access_code       : BFW_NX90_xpic_wdg_trig_wdg_access_code;       /* Watchdog access code for triggering. A read access gives the next 16 bit code for trigger. */
                                                                                     /* A write access with correct access code will trigger the watchdog counter.                 */
  unsigned int reserved1             : BFW_NX90_xpic_wdg_trig_reserved1;             /* reserved                                                                                   */
  unsigned int irq_req_watchdog      : BFW_NX90_xpic_wdg_trig_irq_req_watchdog;      /* xPIC IRQ request of watchdog, writing 1 deletes IRQ to xPIC                                */
  unsigned int reserved2             : BFW_NX90_xpic_wdg_trig_reserved2;             /* reserved                                                                                   */
  unsigned int wdg_counter_trigger_w : BFW_NX90_xpic_wdg_trig_wdg_counter_trigger_w; /* Watchdog trigger bit:                                                                      */
                                                                                     /* Bit must be set to trigger the watchdog counter.                                           */
                                                                                     /* When read, this bit is always '0'                                                          */
  unsigned int reserved3             : BFW_NX90_xpic_wdg_trig_reserved3;             /* reserved                                                                                   */
  unsigned int write_enable          : BFW_NX90_xpic_wdg_trig_write_enable;          /* Write enable bit for timeout register:                                                     */
                                                                                     /* As long as this bit is not set all write accesses to the timeout register are ignored.     */
} NX90_XPIC_WDG_TRIG_BIT_T;

typedef union {
  uint32_t                 val;
  NX90_XPIC_WDG_TRIG_BIT_T bf;
} NX90_XPIC_WDG_TRIG_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_counter */
/* => netX xPIC Watchdog Counter Register */
/*    The counter value is decremented each 10000 system clock cycles. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_counter          0x00000004U
#define Adr_NX90_wdg_xpic_app_xpic_wdg_counter 0xFF900184U
#define Adr_NX90_xpic_wdg_counter              0xFF900184U

#define MSK_NX90_xpic_wdg_counter_val 0x0001ffffU
#define SRT_NX90_xpic_wdg_counter_val 0

/* all used bits of 'NX90_xpic_wdg_counter': */
#define MSK_USED_BITS_NX90_xpic_wdg_counter 0x0001ffffU

enum {
  BFW_NX90_xpic_wdg_counter_val       = 17, /* [16:0] */
  BFW_NX90_xpic_wdg_counter_reserved1 = 15  /* [31:17] */
};

typedef struct NX90_XPIC_WDG_COUNTER_BIT_Ttag {
  unsigned int val       : BFW_NX90_xpic_wdg_counter_val;       /* Actual watchdog counter value:                                       */
                                                                /* Bit 16 shows:                                                        */
                                                                /* 1: Watchdog is counting down from xpic_irq_timeout to 0 for xPIC-IRQ */
                                                                /* 0: Watchdog is counting down from arm_irq_timeout to 0 for ARM-IRQ   */
  unsigned int reserved1 : BFW_NX90_xpic_wdg_counter_reserved1; /* reserved                                                             */
} NX90_XPIC_WDG_COUNTER_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_XPIC_WDG_COUNTER_BIT_T bf;
} NX90_XPIC_WDG_COUNTER_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_xpic_irq_timeout */
/* => netX xPIC Watchdog xPIC interrupt timout register: */
/*    xpic_irq_timeout or arm_irq_timeout must be nonzero to enable watchdog */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_xpic_irq_timeout          0x00000008U
#define Adr_NX90_wdg_xpic_app_xpic_wdg_xpic_irq_timeout 0xFF900188U
#define Adr_NX90_xpic_wdg_xpic_irq_timeout              0xFF900188U
#define DFLT_VAL_NX90_xpic_wdg_xpic_irq_timeout         0x00000000U

#define MSK_NX90_xpic_wdg_xpic_irq_timeout_val         0x0000ffffU
#define SRT_NX90_xpic_wdg_xpic_irq_timeout_val         0
#define DFLT_VAL_NX90_xpic_wdg_xpic_irq_timeout_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_xpic_irq_timeout_val 0x00000000U

/* all used bits of 'NX90_xpic_wdg_xpic_irq_timeout': */
#define MSK_USED_BITS_NX90_xpic_wdg_xpic_irq_timeout 0x0000ffffU

enum {
  BFW_NX90_xpic_wdg_xpic_irq_timeout_val       = 16, /* [15:0] */
  BFW_NX90_xpic_wdg_xpic_irq_timeout_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_XPIC_WDG_XPIC_IRQ_TIMEOUT_BIT_Ttag {
  unsigned int val       : BFW_NX90_xpic_wdg_xpic_irq_timeout_val;       /* Watchdog interrupt timeout                                                                  */
                                                                         /* The total xpic_irq timeout for a netX clock of 100MHz is: xpic_wdg_xpic_irq_timeout * 100s */
  unsigned int reserved1 : BFW_NX90_xpic_wdg_xpic_irq_timeout_reserved1; /* reserved                                                                                    */
} NX90_XPIC_WDG_XPIC_IRQ_TIMEOUT_BIT_T;

typedef union {
  uint32_t                             val;
  NX90_XPIC_WDG_XPIC_IRQ_TIMEOUT_BIT_T bf;
} NX90_XPIC_WDG_XPIC_IRQ_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_arm_irq_timeout */
/* => netX xPIC Watchdog ARM interrupt timout register: */
/*    xpic_irq_timeout or arm_irq_timeout must be nonzero to enable watchdog */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_arm_irq_timeout          0x0000000CU
#define Adr_NX90_wdg_xpic_app_xpic_wdg_arm_irq_timeout 0xFF90018CU
#define Adr_NX90_xpic_wdg_arm_irq_timeout              0xFF90018CU
#define DFLT_VAL_NX90_xpic_wdg_arm_irq_timeout         0x00000000U

#define MSK_NX90_xpic_wdg_arm_irq_timeout_val         0x0000ffffU
#define SRT_NX90_xpic_wdg_arm_irq_timeout_val         0
#define DFLT_VAL_NX90_xpic_wdg_arm_irq_timeout_val    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_arm_irq_timeout_val 0x00000000U

/* all used bits of 'NX90_xpic_wdg_arm_irq_timeout': */
#define MSK_USED_BITS_NX90_xpic_wdg_arm_irq_timeout 0x0000ffffU

enum {
  BFW_NX90_xpic_wdg_arm_irq_timeout_val       = 16, /* [15:0] */
  BFW_NX90_xpic_wdg_arm_irq_timeout_reserved1 = 16  /* [31:16] */
};

typedef struct NX90_XPIC_WDG_ARM_IRQ_TIMEOUT_BIT_Ttag {
  unsigned int val       : BFW_NX90_xpic_wdg_arm_irq_timeout_val;       /* Watchdog ARM interrupt timeout                                                                                          */
                                                                        /* The total arm_irq timeout for a netX clock of 100MHz is: (xpic_wdg_xpic_irq_timeout + xpic_wdg_arm_irq_timeout) * 100s */
  unsigned int reserved1 : BFW_NX90_xpic_wdg_arm_irq_timeout_reserved1; /* reserved                                                                                                                */
} NX90_XPIC_WDG_ARM_IRQ_TIMEOUT_BIT_T;

typedef union {
  uint32_t                            val;
  NX90_XPIC_WDG_ARM_IRQ_TIMEOUT_BIT_T bf;
} NX90_XPIC_WDG_ARM_IRQ_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_raw */
/* => Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_irq_raw          0x00000010U
#define Adr_NX90_wdg_xpic_app_xpic_wdg_irq_raw 0xFF900190U
#define Adr_NX90_xpic_wdg_irq_raw              0xFF900190U
#define DFLT_VAL_NX90_xpic_wdg_irq_raw         0x00000000U

#define MSK_NX90_xpic_wdg_irq_raw_wdg_arm_irq         0x00000001U
#define SRT_NX90_xpic_wdg_irq_raw_wdg_arm_irq         0
#define DFLT_VAL_NX90_xpic_wdg_irq_raw_wdg_arm_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_irq_raw_wdg_arm_irq 0x00000000U

/* all used bits of 'NX90_xpic_wdg_irq_raw': */
#define MSK_USED_BITS_NX90_xpic_wdg_irq_raw 0x00000001U

enum {
  BFW_NX90_xpic_wdg_irq_raw_wdg_arm_irq = 1,  /* [0] */
  BFW_NX90_xpic_wdg_irq_raw_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_XPIC_WDG_IRQ_RAW_BIT_Ttag {
  unsigned int wdg_arm_irq : BFW_NX90_xpic_wdg_irq_raw_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
  unsigned int reserved1   : BFW_NX90_xpic_wdg_irq_raw_reserved1;   /* reserved                            */
} NX90_XPIC_WDG_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                    val;
  NX90_XPIC_WDG_IRQ_RAW_BIT_T bf;
} NX90_XPIC_WDG_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_masked */
/* => xpic_wdg Masked IRQ register: */
/*    Shows status of masked IRQs (as connected to xPIC). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_irq_masked          0x00000014U
#define Adr_NX90_wdg_xpic_app_xpic_wdg_irq_masked 0xFF900194U
#define Adr_NX90_xpic_wdg_irq_masked              0xFF900194U

#define MSK_NX90_xpic_wdg_irq_masked_wdg_arm_irq 0x00000001U
#define SRT_NX90_xpic_wdg_irq_masked_wdg_arm_irq 0

/* all used bits of 'NX90_xpic_wdg_irq_masked': */
#define MSK_USED_BITS_NX90_xpic_wdg_irq_masked 0x00000001U

enum {
  BFW_NX90_xpic_wdg_irq_masked_wdg_arm_irq = 1,  /* [0] */
  BFW_NX90_xpic_wdg_irq_masked_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_XPIC_WDG_IRQ_MASKED_BIT_Ttag {
  unsigned int wdg_arm_irq : BFW_NX90_xpic_wdg_irq_masked_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
  unsigned int reserved1   : BFW_NX90_xpic_wdg_irq_masked_reserved1;   /* reserved                            */
} NX90_XPIC_WDG_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_XPIC_WDG_IRQ_MASKED_BIT_T bf;
} NX90_XPIC_WDG_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_msk_set */
/* => xpic_wdg interrupt mask enable: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to wdg_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_irq_msk_set          0x00000018U
#define Adr_NX90_wdg_xpic_app_xpic_wdg_irq_msk_set 0xFF900198U
#define Adr_NX90_xpic_wdg_irq_msk_set              0xFF900198U
#define DFLT_VAL_NX90_xpic_wdg_irq_msk_set         0x00000000U

#define MSK_NX90_xpic_wdg_irq_msk_set_wdg_arm_irq         0x00000001U
#define SRT_NX90_xpic_wdg_irq_msk_set_wdg_arm_irq         0
#define DFLT_VAL_NX90_xpic_wdg_irq_msk_set_wdg_arm_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_irq_msk_set_wdg_arm_irq 0x00000000U

/* all used bits of 'NX90_xpic_wdg_irq_msk_set': */
#define MSK_USED_BITS_NX90_xpic_wdg_irq_msk_set 0x00000001U

enum {
  BFW_NX90_xpic_wdg_irq_msk_set_wdg_arm_irq = 1,  /* [0] */
  BFW_NX90_xpic_wdg_irq_msk_set_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_XPIC_WDG_IRQ_MSK_SET_BIT_Ttag {
  unsigned int wdg_arm_irq : BFW_NX90_xpic_wdg_irq_msk_set_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
  unsigned int reserved1   : BFW_NX90_xpic_wdg_irq_msk_set_reserved1;   /* reserved                            */
} NX90_XPIC_WDG_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                        val;
  NX90_XPIC_WDG_IRQ_MSK_SET_BIT_T bf;
} NX90_XPIC_WDG_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_msk_reset */
/* => xpic_wdg interrupt mask disable: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xpic_wdg_irq_msk_reset          0x0000001CU
#define Adr_NX90_wdg_xpic_app_xpic_wdg_irq_msk_reset 0xFF90019CU
#define Adr_NX90_xpic_wdg_irq_msk_reset              0xFF90019CU
#define DFLT_VAL_NX90_xpic_wdg_irq_msk_reset         0x00000000U

#define MSK_NX90_xpic_wdg_irq_msk_reset_wdg_arm_irq         0x00000001U
#define SRT_NX90_xpic_wdg_irq_msk_reset_wdg_arm_irq         0
#define DFLT_VAL_NX90_xpic_wdg_irq_msk_reset_wdg_arm_irq    0x00000000U
#define DFLT_BF_VAL_NX90_xpic_wdg_irq_msk_reset_wdg_arm_irq 0x00000000U

/* all used bits of 'NX90_xpic_wdg_irq_msk_reset': */
#define MSK_USED_BITS_NX90_xpic_wdg_irq_msk_reset 0x00000001U

enum {
  BFW_NX90_xpic_wdg_irq_msk_reset_wdg_arm_irq = 1,  /* [0] */
  BFW_NX90_xpic_wdg_irq_msk_reset_reserved1   = 31  /* [31:1] */
};

typedef struct NX90_XPIC_WDG_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int wdg_arm_irq : BFW_NX90_xpic_wdg_irq_msk_reset_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
  unsigned int reserved1   : BFW_NX90_xpic_wdg_irq_msk_reset_reserved1;   /* reserved                            */
} NX90_XPIC_WDG_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                          val;
  NX90_XPIC_WDG_IRQ_MSK_RESET_BIT_T bf;
} NX90_XPIC_WDG_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* Area of io_link_xpic_app */

/* ===================================================================== */

#define Addr_NX90_io_link_xpic_app 0xFF900400U

/* ===================================================================== */

/* AREA xlink */
/* Area of xlink0, xlink1, xlink2, xlink3, xlink4, xlink5, xlink6, xlink7 */

/* ===================================================================== */

#define Addr_NX90_xlink0 0xFF900400U
#define Addr_NX90_xlink1 0xFF900410U
#define Addr_NX90_xlink2 0xFF900420U
#define Addr_NX90_xlink3 0xFF900430U
#define Addr_NX90_xlink4 0xFF900440U
#define Addr_NX90_xlink5 0xFF900450U
#define Addr_NX90_xlink6 0xFF900460U
#define Addr_NX90_xlink7 0xFF900470U

/* --------------------------------------------------------------------- */
/* Register xlink_cfg */
/* => configuration register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xlink_cfg    0x00000000U
#define Adr_NX90_xlink0_xlink_cfg 0xFF900400U
#define Adr_NX90_xlink1_xlink_cfg 0xFF900410U
#define Adr_NX90_xlink2_xlink_cfg 0xFF900420U
#define Adr_NX90_xlink3_xlink_cfg 0xFF900430U
#define Adr_NX90_xlink4_xlink_cfg 0xFF900440U
#define Adr_NX90_xlink5_xlink_cfg 0xFF900450U
#define Adr_NX90_xlink6_xlink_cfg 0xFF900460U
#define Adr_NX90_xlink7_xlink_cfg 0xFF900470U
#define DFLT_VAL_NX90_xlink_cfg   0xb4a0001bU

#define MSK_NX90_xlink_cfg_rate_inc           0x0000ffffU
#define SRT_NX90_xlink_cfg_rate_inc           0
#define DFLT_VAL_NX90_xlink_cfg_rate_inc      0x0000001bU
#define DFLT_BF_VAL_NX90_xlink_cfg_rate_inc   0x0000001bU
#define MSK_NX90_xlink_cfg_xlink_en           0x00010000U
#define SRT_NX90_xlink_cfg_xlink_en           16
#define DFLT_VAL_NX90_xlink_cfg_xlink_en      0x00000000U
#define DFLT_BF_VAL_NX90_xlink_cfg_xlink_en   0x00000000U
#define MSK_NX90_xlink_cfg_fb_en              0x00020000U
#define SRT_NX90_xlink_cfg_fb_en              17
#define DFLT_VAL_NX90_xlink_cfg_fb_en         0x00000000U
#define DFLT_BF_VAL_NX90_xlink_cfg_fb_en      0x00000000U
#define MSK_NX90_xlink_cfg_bclk2oe_en         0x00040000U
#define SRT_NX90_xlink_cfg_bclk2oe_en         18
#define DFLT_VAL_NX90_xlink_cfg_bclk2oe_en    0x00000000U
#define DFLT_BF_VAL_NX90_xlink_cfg_bclk2oe_en 0x00000000U
#define MSK_NX90_xlink_cfg_cnt_da             0x00080000U
#define SRT_NX90_xlink_cfg_cnt_da             19
#define DFLT_VAL_NX90_xlink_cfg_cnt_da        0x00000000U
#define DFLT_BF_VAL_NX90_xlink_cfg_cnt_da     0x00000000U
#define MSK_NX90_xlink_cfg_bits2rec           0x00f00000U
#define SRT_NX90_xlink_cfg_bits2rec           20
#define DFLT_VAL_NX90_xlink_cfg_bits2rec      0x00a00000U
#define DFLT_BF_VAL_NX90_xlink_cfg_bits2rec   0x0000000aU
#define MSK_NX90_xlink_cfg_start_spl          0x0f000000U
#define SRT_NX90_xlink_cfg_start_spl          24
#define DFLT_VAL_NX90_xlink_cfg_start_spl     0x04000000U
#define DFLT_BF_VAL_NX90_xlink_cfg_start_spl  0x00000004U
#define MSK_NX90_xlink_cfg_end_spl            0xf0000000U
#define SRT_NX90_xlink_cfg_end_spl            28
#define DFLT_VAL_NX90_xlink_cfg_end_spl       0xb0000000U
#define DFLT_BF_VAL_NX90_xlink_cfg_end_spl    0x0000000bU

/* all used bits of 'NX90_xlink_cfg': */
#define MSK_USED_BITS_NX90_xlink_cfg 0xffffffffU

enum {
  BFW_NX90_xlink_cfg_rate_inc   = 16, /* [15:0] */
  BFW_NX90_xlink_cfg_xlink_en   = 1,  /* [16] */
  BFW_NX90_xlink_cfg_fb_en      = 1,  /* [17] */
  BFW_NX90_xlink_cfg_bclk2oe_en = 1,  /* [18] */
  BFW_NX90_xlink_cfg_cnt_da     = 1,  /* [19] */
  BFW_NX90_xlink_cfg_bits2rec   = 4,  /* [23:20] */
  BFW_NX90_xlink_cfg_start_spl  = 4,  /* [27:24] */
  BFW_NX90_xlink_cfg_end_spl    = 4   /* [31:28] */
};

typedef struct NX90_XLINK_CFG_BIT_Ttag {
  unsigned int rate_inc   : BFW_NX90_xlink_cfg_rate_inc;   /* bitrate compare value                                                      */
                                                           /* for bit clock counter (bit_cnt)                                            */
                                                           /* BITRATE = 100e6/(rate_inc)                                                 */
                                                           /* typical settings for IOLINK:                                               */
                                                           /* {| cols=4                                                                  */
                                                           /* BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE                      */
                                                           /* 4800     | 0x5160   | 208,33 us    | 208,3333us                            */
                                                           /* 38400    | 0xa2b    |  26,04 us    |  26,04167us                           */
                                                           /* 230400   | 0x1b1    |   4,34 us    |   4,340278us                          */
                                                           /* ...      |          |                                                      */
                                                           /* invalid:                                                                   */
                                                           /*      0   | 0        | 0            | 0                                     */
                                                           /* }                                                                          */
  unsigned int xlink_en   : BFW_NX90_xlink_cfg_xlink_en;   /* disable the output enable, and activity                                    */
  unsigned int fb_en      : BFW_NX90_xlink_cfg_fb_en;      /* test feature, enable internal feedback                                     */
  unsigned int bclk2oe_en : BFW_NX90_xlink_cfg_bclk2oe_en; /* test feature, do not set this bit!                                         */
  unsigned int cnt_da     : BFW_NX90_xlink_cfg_cnt_da;     /* test feature, do not set this bit!                                         */
  unsigned int bits2rec   : BFW_NX90_xlink_cfg_bits2rec;   /* count of bits to receive                                                   */
                                                           /* note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit */
  unsigned int start_spl  : BFW_NX90_xlink_cfg_start_spl;  /* start sample point for receive data                                        */
                                                           /* a sample period is defined as 1/16 of the bitrate period                   */
                                                           /* range: 0x0 - 0xf                                                           */
                                                           /* note: settings for start_spl and end_spl                                   */
                                                           /*       should always fulfill the condition:                                 */
                                                           /*       (start_spl < end_spl)                                                */
  unsigned int end_spl    : BFW_NX90_xlink_cfg_end_spl;    /* end sample point  for receive data                                         */
} NX90_XLINK_CFG_BIT_T;

typedef union {
  uint32_t             val;
  NX90_XLINK_CFG_BIT_T bf;
} NX90_XLINK_CFG_T;

/* --------------------------------------------------------------------- */
/* Register xlink_tx */
/* => xlink transmit register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xlink_tx    0x00000004U
#define Adr_NX90_xlink0_xlink_tx 0xFF900404U
#define Adr_NX90_xlink1_xlink_tx 0xFF900414U
#define Adr_NX90_xlink2_xlink_tx 0xFF900424U
#define Adr_NX90_xlink3_xlink_tx 0xFF900434U
#define Adr_NX90_xlink4_xlink_tx 0xFF900444U
#define Adr_NX90_xlink5_xlink_tx 0xFF900454U
#define Adr_NX90_xlink6_xlink_tx 0xFF900464U
#define Adr_NX90_xlink7_xlink_tx 0xFF900474U
#define DFLT_VAL_NX90_xlink_tx   0x00030000U

#define MSK_NX90_xlink_tx_hold            0x0000ffffU
#define SRT_NX90_xlink_tx_hold            0
#define DFLT_VAL_NX90_xlink_tx_hold       0x00000000U
#define DFLT_BF_VAL_NX90_xlink_tx_hold    0x00000000U
#define MSK_NX90_xlink_tx_rdy_ro          0x00010000U
#define SRT_NX90_xlink_tx_rdy_ro          16
#define DFLT_VAL_NX90_xlink_tx_rdy_ro     0x00010000U
#define DFLT_BF_VAL_NX90_xlink_tx_rdy_ro  0x00000001U
#define MSK_NX90_xlink_tx_idle_ro         0x00020000U
#define SRT_NX90_xlink_tx_idle_ro         17
#define DFLT_VAL_NX90_xlink_tx_idle_ro    0x00020000U
#define DFLT_BF_VAL_NX90_xlink_tx_idle_ro 0x00000001U

/* all used bits of 'NX90_xlink_tx': */
#define MSK_USED_BITS_NX90_xlink_tx 0x0003ffffU

enum {
  BFW_NX90_xlink_tx_hold      = 16, /* [15:0] */
  BFW_NX90_xlink_tx_rdy_ro    = 1,  /* [16] */
  BFW_NX90_xlink_tx_idle_ro   = 1,  /* [17] */
  BFW_NX90_xlink_tx_reserved1 = 14  /* [31:18] */
};

typedef struct NX90_XLINK_TX_BIT_Ttag {
  unsigned int hold      : BFW_NX90_xlink_tx_hold;      /* hold register                                                                    */
                                                        /*   format for a valid serial DATA sequence:                                       */
                                                        /*   <-ctrl.DATA-><------------------- serial DATA -------------------->            */
                                                        /*   { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}]            */
                                                        /*   notes:                                                                         */
                                                        /*   ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. */
                                                        /*   this condition implied, than all other not used bits should be zero            */
  unsigned int rdy_ro    : BFW_NX90_xlink_tx_rdy_ro;    /* TX buffer ready (valid on ready)                                                 */
                                                        /*  0 TX buffer not ready                                                           */
                                                        /*  1 TX buffer ready                                                               */
  unsigned int idle_ro   : BFW_NX90_xlink_tx_idle_ro;   /* indicates no activity on tx                                                      */
  unsigned int reserved1 : BFW_NX90_xlink_tx_reserved1; /* reserved                                                                         */
} NX90_XLINK_TX_BIT_T;

typedef union {
  uint32_t            val;
  NX90_XLINK_TX_BIT_T bf;
} NX90_XLINK_TX_T;

/* --------------------------------------------------------------------- */
/* Register xlink_rx */
/* => xlink RX register */
/*    writing to the register, reset the ready bit, the overflow bit and the sampling error bit */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xlink_rx    0x00000008U
#define Adr_NX90_xlink0_xlink_rx 0xFF900408U
#define Adr_NX90_xlink1_xlink_rx 0xFF900418U
#define Adr_NX90_xlink2_xlink_rx 0xFF900428U
#define Adr_NX90_xlink3_xlink_rx 0xFF900438U
#define Adr_NX90_xlink4_xlink_rx 0xFF900448U
#define Adr_NX90_xlink5_xlink_rx 0xFF900458U
#define Adr_NX90_xlink6_xlink_rx 0xFF900468U
#define Adr_NX90_xlink7_xlink_rx 0xFF900478U
#define DFLT_VAL_NX90_xlink_rx   0x0000ffffU

#define MSK_NX90_xlink_rx_hold_ro            0x0000ffffU
#define SRT_NX90_xlink_rx_hold_ro            0
#define DFLT_VAL_NX90_xlink_rx_hold_ro       0x0000ffffU
#define DFLT_BF_VAL_NX90_xlink_rx_hold_ro    0x0000ffffU
#define MSK_NX90_xlink_rx_rdy_ro             0x00010000U
#define SRT_NX90_xlink_rx_rdy_ro             16
#define DFLT_VAL_NX90_xlink_rx_rdy_ro        0x00000000U
#define DFLT_BF_VAL_NX90_xlink_rx_rdy_ro     0x00000000U
#define MSK_NX90_xlink_rx_rxd_ro             0x00080000U
#define SRT_NX90_xlink_rx_rxd_ro             19
#define DFLT_VAL_NX90_xlink_rx_rxd_ro        0x00000000U
#define DFLT_BF_VAL_NX90_xlink_rx_rxd_ro     0x00000000U
#define MSK_NX90_xlink_rx_ovf_err_ro         0x00100000U
#define SRT_NX90_xlink_rx_ovf_err_ro         20
#define DFLT_VAL_NX90_xlink_rx_ovf_err_ro    0x00000000U
#define DFLT_BF_VAL_NX90_xlink_rx_ovf_err_ro 0x00000000U
#define MSK_NX90_xlink_rx_spl_err_ro         0x00200000U
#define SRT_NX90_xlink_rx_spl_err_ro         21
#define DFLT_VAL_NX90_xlink_rx_spl_err_ro    0x00000000U
#define DFLT_BF_VAL_NX90_xlink_rx_spl_err_ro 0x00000000U

/* all used bits of 'NX90_xlink_rx': */
#define MSK_USED_BITS_NX90_xlink_rx 0x0039ffffU

enum {
  BFW_NX90_xlink_rx_hold_ro    = 16, /* [15:0] */
  BFW_NX90_xlink_rx_rdy_ro     = 1,  /* [16] */
  BFW_NX90_xlink_rx_reserved1  = 2,  /* [18:17] */
  BFW_NX90_xlink_rx_rxd_ro     = 1,  /* [19] */
  BFW_NX90_xlink_rx_ovf_err_ro = 1,  /* [20] */
  BFW_NX90_xlink_rx_spl_err_ro = 1,  /* [21] */
  BFW_NX90_xlink_rx_reserved2  = 10  /* [31:22] */
};

typedef struct NX90_XLINK_RX_BIT_Ttag {
  unsigned int hold_ro    : BFW_NX90_xlink_rx_hold_ro;    /* RX byte (when valid)                                */
                                                          /*   hold[15:0] is used to shift in RX(LSB first!)     */
                                                          /*   the amount of shifted bits is defined by bits2rec */
                                                          /*   shift order is bit15 downto bit0                  */
  unsigned int rdy_ro     : BFW_NX90_xlink_rx_rdy_ro;     /* RX buffer ready (valid on ready)                    */
                                                          /*  0 RX buffer not ready                              */
                                                          /*  1 RX buffer ready                                  */
  unsigned int reserved1  : BFW_NX90_xlink_rx_reserved1;  /* reserved                                            */
  unsigned int rxd_ro     : BFW_NX90_xlink_rx_rxd_ro;     /* current status of rx data                           */
  unsigned int ovf_err_ro : BFW_NX90_xlink_rx_ovf_err_ro; /* overflow error on received data                     */
  unsigned int spl_err_ro : BFW_NX90_xlink_rx_spl_err_ro; /* sampling error detected                             */
                                                          /* if the amount of sampled bits (HI or LOW)           */
                                                          /* do not fulfill the condition:                       */
                                                          /* (end_spl - start_spl) < (count of HI/LOW bits)      */
  unsigned int reserved2  : BFW_NX90_xlink_rx_reserved2;  /* reserved                                            */
} NX90_XLINK_RX_BIT_T;

typedef union {
  uint32_t            val;
  NX90_XLINK_RX_BIT_T bf;
} NX90_XLINK_RX_T;

/* --------------------------------------------------------------------- */
/* Register xlink_stat */
/* => xlink status register & io control */
/*    writing to this register set the bit clock counter to zero! */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_xlink_stat    0x0000000CU
#define Adr_NX90_xlink0_xlink_stat 0xFF90040CU
#define Adr_NX90_xlink1_xlink_stat 0xFF90041CU
#define Adr_NX90_xlink2_xlink_stat 0xFF90042CU
#define Adr_NX90_xlink3_xlink_stat 0xFF90043CU
#define Adr_NX90_xlink4_xlink_stat 0xFF90044CU
#define Adr_NX90_xlink5_xlink_stat 0xFF90045CU
#define Adr_NX90_xlink6_xlink_stat 0xFF90046CU
#define Adr_NX90_xlink7_xlink_stat 0xFF90047CU
#define DFLT_VAL_NX90_xlink_stat   0x01000000U

#define MSK_NX90_xlink_stat_bit_cnt_ro         0x0000ffffU
#define SRT_NX90_xlink_stat_bit_cnt_ro         0
#define DFLT_VAL_NX90_xlink_stat_bit_cnt_ro    0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_bit_cnt_ro 0x00000000U
#define MSK_NX90_xlink_stat_bit_clk_ro         0x00010000U
#define SRT_NX90_xlink_stat_bit_clk_ro         16
#define DFLT_VAL_NX90_xlink_stat_bit_clk_ro    0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_bit_clk_ro 0x00000000U
#define MSK_NX90_xlink_stat_txo_ro             0x00020000U
#define SRT_NX90_xlink_stat_txo_ro             17
#define DFLT_VAL_NX90_xlink_stat_txo_ro        0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_txo_ro     0x00000000U
#define MSK_NX90_xlink_stat_rxo_ro             0x00040000U
#define SRT_NX90_xlink_stat_rxo_ro             18
#define DFLT_VAL_NX90_xlink_stat_rxo_ro        0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_rxo_ro     0x00000000U
#define MSK_NX90_xlink_stat_txoe_ro            0x00080000U
#define SRT_NX90_xlink_stat_txoe_ro            19
#define DFLT_VAL_NX90_xlink_stat_txoe_ro       0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_txoe_ro    0x00000000U
#define MSK_NX90_xlink_stat_io_mode            0x00100000U
#define SRT_NX90_xlink_stat_io_mode            20
#define DFLT_VAL_NX90_xlink_stat_io_mode       0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_io_mode    0x00000000U
#define MSK_NX90_xlink_stat_set_tx             0x00200000U
#define SRT_NX90_xlink_stat_set_tx             21
#define DFLT_VAL_NX90_xlink_stat_set_tx        0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_set_tx     0x00000000U
#define MSK_NX90_xlink_stat_set_txoe           0x00400000U
#define SRT_NX90_xlink_stat_set_txoe           22
#define DFLT_VAL_NX90_xlink_stat_set_txoe      0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_set_txoe   0x00000000U
#define MSK_NX90_xlink_stat_set_wakeup         0x00800000U
#define SRT_NX90_xlink_stat_set_wakeup         23
#define DFLT_VAL_NX90_xlink_stat_set_wakeup    0x00000000U
#define DFLT_BF_VAL_NX90_xlink_stat_set_wakeup 0x00000000U
#define MSK_NX90_xlink_stat_filter_en          0x01000000U
#define SRT_NX90_xlink_stat_filter_en          24
#define DFLT_VAL_NX90_xlink_stat_filter_en     0x01000000U
#define DFLT_BF_VAL_NX90_xlink_stat_filter_en  0x00000001U

/* all used bits of 'NX90_xlink_stat': */
#define MSK_USED_BITS_NX90_xlink_stat 0x01ffffffU

enum {
  BFW_NX90_xlink_stat_bit_cnt_ro = 16, /* [15:0] */
  BFW_NX90_xlink_stat_bit_clk_ro = 1,  /* [16] */
  BFW_NX90_xlink_stat_txo_ro     = 1,  /* [17] */
  BFW_NX90_xlink_stat_rxo_ro     = 1,  /* [18] */
  BFW_NX90_xlink_stat_txoe_ro    = 1,  /* [19] */
  BFW_NX90_xlink_stat_io_mode    = 1,  /* [20] */
  BFW_NX90_xlink_stat_set_tx     = 1,  /* [21] */
  BFW_NX90_xlink_stat_set_txoe   = 1,  /* [22] */
  BFW_NX90_xlink_stat_set_wakeup = 1,  /* [23] */
  BFW_NX90_xlink_stat_filter_en  = 1,  /* [24] */
  BFW_NX90_xlink_stat_reserved1  = 7   /* [31:25] */
};

typedef struct NX90_XLINK_STAT_BIT_Ttag {
  unsigned int bit_cnt_ro : BFW_NX90_xlink_stat_bit_cnt_ro; /* status of bit clock counter                 */
  unsigned int bit_clk_ro : BFW_NX90_xlink_stat_bit_clk_ro; /* status of bit clock signal                  */
  unsigned int txo_ro     : BFW_NX90_xlink_stat_txo_ro;     /* status of tx output                         */
  unsigned int rxo_ro     : BFW_NX90_xlink_stat_rxo_ro;     /* status of rx input                          */
  unsigned int txoe_ro    : BFW_NX90_xlink_stat_txoe_ro;    /* status of tx output enable                  */
  unsigned int io_mode    : BFW_NX90_xlink_stat_io_mode;    /* enable the io mode on tx and wakeup         */
                                                            /* 0 : disable io function on tx, txoe, wakeup */
                                                            /* 1 : enable io function on tx, txoe, wakeup  */
  unsigned int set_tx     : BFW_NX90_xlink_stat_set_tx;     /* set the tx port,                            */
  unsigned int set_txoe   : BFW_NX90_xlink_stat_set_txoe;   /* set the tx output enable                    */
  unsigned int set_wakeup : BFW_NX90_xlink_stat_set_wakeup; /* set the wakeup port                         */
  unsigned int filter_en  : BFW_NX90_xlink_stat_filter_en;  /* enable 3 majority ruling filter             */
  unsigned int reserved1  : BFW_NX90_xlink_stat_reserved1;  /* reserved                                    */
} NX90_XLINK_STAT_BIT_T;

typedef union {
  uint32_t              val;
  NX90_XLINK_STAT_BIT_T bf;
} NX90_XLINK_STAT_T;


/* ===================================================================== */

/* Area of io_link_irq */

/* ===================================================================== */

#define Addr_NX90_io_link_irq 0xFF900480U

/* --------------------------------------------------------------------- */
/* Register io_link_irq_raw */
/* => IO-Link raw interrupts: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_link_irq_raw         0x00000000U
#define Adr_NX90_io_link_irq_io_link_irq_raw 0xFF900480U
#define Adr_NX90_io_link_irq_raw             0xFF900480U
#define DFLT_VAL_NX90_io_link_irq_raw        0x00000000U

#define MSK_NX90_io_link_irq_raw_xlink0_tx_next          0x00000001U
#define SRT_NX90_io_link_irq_raw_xlink0_tx_next          0
#define DFLT_VAL_NX90_io_link_irq_raw_xlink0_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink0_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink0_rx_next          0x00000002U
#define SRT_NX90_io_link_irq_raw_xlink0_rx_next          1
#define DFLT_VAL_NX90_io_link_irq_raw_xlink0_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink0_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink0_shift_en         0x00000004U
#define SRT_NX90_io_link_irq_raw_xlink0_shift_en         2
#define DFLT_VAL_NX90_io_link_irq_raw_xlink0_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink0_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink1_tx_next          0x00000010U
#define SRT_NX90_io_link_irq_raw_xlink1_tx_next          4
#define DFLT_VAL_NX90_io_link_irq_raw_xlink1_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink1_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink1_rx_next          0x00000020U
#define SRT_NX90_io_link_irq_raw_xlink1_rx_next          5
#define DFLT_VAL_NX90_io_link_irq_raw_xlink1_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink1_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink1_shift_en         0x00000040U
#define SRT_NX90_io_link_irq_raw_xlink1_shift_en         6
#define DFLT_VAL_NX90_io_link_irq_raw_xlink1_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink1_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink2_tx_next          0x00000100U
#define SRT_NX90_io_link_irq_raw_xlink2_tx_next          8
#define DFLT_VAL_NX90_io_link_irq_raw_xlink2_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink2_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink2_rx_next          0x00000200U
#define SRT_NX90_io_link_irq_raw_xlink2_rx_next          9
#define DFLT_VAL_NX90_io_link_irq_raw_xlink2_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink2_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink2_shift_en         0x00000400U
#define SRT_NX90_io_link_irq_raw_xlink2_shift_en         10
#define DFLT_VAL_NX90_io_link_irq_raw_xlink2_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink2_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink3_tx_next          0x00001000U
#define SRT_NX90_io_link_irq_raw_xlink3_tx_next          12
#define DFLT_VAL_NX90_io_link_irq_raw_xlink3_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink3_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink3_rx_next          0x00002000U
#define SRT_NX90_io_link_irq_raw_xlink3_rx_next          13
#define DFLT_VAL_NX90_io_link_irq_raw_xlink3_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink3_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink3_shift_en         0x00004000U
#define SRT_NX90_io_link_irq_raw_xlink3_shift_en         14
#define DFLT_VAL_NX90_io_link_irq_raw_xlink3_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink3_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink4_tx_next          0x00010000U
#define SRT_NX90_io_link_irq_raw_xlink4_tx_next          16
#define DFLT_VAL_NX90_io_link_irq_raw_xlink4_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink4_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink4_rx_next          0x00020000U
#define SRT_NX90_io_link_irq_raw_xlink4_rx_next          17
#define DFLT_VAL_NX90_io_link_irq_raw_xlink4_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink4_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink4_shift_en         0x00040000U
#define SRT_NX90_io_link_irq_raw_xlink4_shift_en         18
#define DFLT_VAL_NX90_io_link_irq_raw_xlink4_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink4_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink5_tx_next          0x00100000U
#define SRT_NX90_io_link_irq_raw_xlink5_tx_next          20
#define DFLT_VAL_NX90_io_link_irq_raw_xlink5_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink5_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink5_rx_next          0x00200000U
#define SRT_NX90_io_link_irq_raw_xlink5_rx_next          21
#define DFLT_VAL_NX90_io_link_irq_raw_xlink5_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink5_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink5_shift_en         0x00400000U
#define SRT_NX90_io_link_irq_raw_xlink5_shift_en         22
#define DFLT_VAL_NX90_io_link_irq_raw_xlink5_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink5_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink6_tx_next          0x01000000U
#define SRT_NX90_io_link_irq_raw_xlink6_tx_next          24
#define DFLT_VAL_NX90_io_link_irq_raw_xlink6_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink6_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink6_rx_next          0x02000000U
#define SRT_NX90_io_link_irq_raw_xlink6_rx_next          25
#define DFLT_VAL_NX90_io_link_irq_raw_xlink6_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink6_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink6_shift_en         0x04000000U
#define SRT_NX90_io_link_irq_raw_xlink6_shift_en         26
#define DFLT_VAL_NX90_io_link_irq_raw_xlink6_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink6_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink7_tx_next          0x10000000U
#define SRT_NX90_io_link_irq_raw_xlink7_tx_next          28
#define DFLT_VAL_NX90_io_link_irq_raw_xlink7_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink7_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink7_rx_next          0x20000000U
#define SRT_NX90_io_link_irq_raw_xlink7_rx_next          29
#define DFLT_VAL_NX90_io_link_irq_raw_xlink7_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink7_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_raw_xlink7_shift_en         0x40000000U
#define SRT_NX90_io_link_irq_raw_xlink7_shift_en         30
#define DFLT_VAL_NX90_io_link_irq_raw_xlink7_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_raw_xlink7_shift_en 0x00000000U

/* all used bits of 'NX90_io_link_irq_raw': */
#define MSK_USED_BITS_NX90_io_link_irq_raw 0x77777777U

enum {
  BFW_NX90_io_link_irq_raw_xlink0_tx_next  = 1, /* [0] */
  BFW_NX90_io_link_irq_raw_xlink0_rx_next  = 1, /* [1] */
  BFW_NX90_io_link_irq_raw_xlink0_shift_en = 1, /* [2] */
  BFW_NX90_io_link_irq_raw_reserved1       = 1, /* [3] */
  BFW_NX90_io_link_irq_raw_xlink1_tx_next  = 1, /* [4] */
  BFW_NX90_io_link_irq_raw_xlink1_rx_next  = 1, /* [5] */
  BFW_NX90_io_link_irq_raw_xlink1_shift_en = 1, /* [6] */
  BFW_NX90_io_link_irq_raw_reserved2       = 1, /* [7] */
  BFW_NX90_io_link_irq_raw_xlink2_tx_next  = 1, /* [8] */
  BFW_NX90_io_link_irq_raw_xlink2_rx_next  = 1, /* [9] */
  BFW_NX90_io_link_irq_raw_xlink2_shift_en = 1, /* [10] */
  BFW_NX90_io_link_irq_raw_reserved3       = 1, /* [11] */
  BFW_NX90_io_link_irq_raw_xlink3_tx_next  = 1, /* [12] */
  BFW_NX90_io_link_irq_raw_xlink3_rx_next  = 1, /* [13] */
  BFW_NX90_io_link_irq_raw_xlink3_shift_en = 1, /* [14] */
  BFW_NX90_io_link_irq_raw_reserved4       = 1, /* [15] */
  BFW_NX90_io_link_irq_raw_xlink4_tx_next  = 1, /* [16] */
  BFW_NX90_io_link_irq_raw_xlink4_rx_next  = 1, /* [17] */
  BFW_NX90_io_link_irq_raw_xlink4_shift_en = 1, /* [18] */
  BFW_NX90_io_link_irq_raw_reserved5       = 1, /* [19] */
  BFW_NX90_io_link_irq_raw_xlink5_tx_next  = 1, /* [20] */
  BFW_NX90_io_link_irq_raw_xlink5_rx_next  = 1, /* [21] */
  BFW_NX90_io_link_irq_raw_xlink5_shift_en = 1, /* [22] */
  BFW_NX90_io_link_irq_raw_reserved6       = 1, /* [23] */
  BFW_NX90_io_link_irq_raw_xlink6_tx_next  = 1, /* [24] */
  BFW_NX90_io_link_irq_raw_xlink6_rx_next  = 1, /* [25] */
  BFW_NX90_io_link_irq_raw_xlink6_shift_en = 1, /* [26] */
  BFW_NX90_io_link_irq_raw_reserved7       = 1, /* [27] */
  BFW_NX90_io_link_irq_raw_xlink7_tx_next  = 1, /* [28] */
  BFW_NX90_io_link_irq_raw_xlink7_rx_next  = 1, /* [29] */
  BFW_NX90_io_link_irq_raw_xlink7_shift_en = 1, /* [30] */
  BFW_NX90_io_link_irq_raw_reserved8       = 1  /* [31] */
};

typedef struct NX90_IO_LINK_IRQ_RAW_BIT_Ttag {
  unsigned int xlink0_tx_next  : BFW_NX90_io_link_irq_raw_xlink0_tx_next;  /* tx_next interrupt  */
  unsigned int xlink0_rx_next  : BFW_NX90_io_link_irq_raw_xlink0_rx_next;  /* rx_next interrupt  */
  unsigned int xlink0_shift_en : BFW_NX90_io_link_irq_raw_xlink0_shift_en; /* shift_en interrupt */
  unsigned int reserved1       : BFW_NX90_io_link_irq_raw_reserved1;       /* reserved           */
  unsigned int xlink1_tx_next  : BFW_NX90_io_link_irq_raw_xlink1_tx_next;  /* tx_next interrupt  */
  unsigned int xlink1_rx_next  : BFW_NX90_io_link_irq_raw_xlink1_rx_next;  /* rx_next interrupt  */
  unsigned int xlink1_shift_en : BFW_NX90_io_link_irq_raw_xlink1_shift_en; /* shift_en interrupt */
  unsigned int reserved2       : BFW_NX90_io_link_irq_raw_reserved2;       /* reserved           */
  unsigned int xlink2_tx_next  : BFW_NX90_io_link_irq_raw_xlink2_tx_next;  /* tx_next interrupt  */
  unsigned int xlink2_rx_next  : BFW_NX90_io_link_irq_raw_xlink2_rx_next;  /* rx_next interrupt  */
  unsigned int xlink2_shift_en : BFW_NX90_io_link_irq_raw_xlink2_shift_en; /* shift_en interrupt */
  unsigned int reserved3       : BFW_NX90_io_link_irq_raw_reserved3;       /* reserved           */
  unsigned int xlink3_tx_next  : BFW_NX90_io_link_irq_raw_xlink3_tx_next;  /* tx_next interrupt  */
  unsigned int xlink3_rx_next  : BFW_NX90_io_link_irq_raw_xlink3_rx_next;  /* rx_next interrupt  */
  unsigned int xlink3_shift_en : BFW_NX90_io_link_irq_raw_xlink3_shift_en; /* shift_en interrupt */
  unsigned int reserved4       : BFW_NX90_io_link_irq_raw_reserved4;       /* reserved           */
  unsigned int xlink4_tx_next  : BFW_NX90_io_link_irq_raw_xlink4_tx_next;  /* tx_next interrupt  */
  unsigned int xlink4_rx_next  : BFW_NX90_io_link_irq_raw_xlink4_rx_next;  /* rx_next interrupt  */
  unsigned int xlink4_shift_en : BFW_NX90_io_link_irq_raw_xlink4_shift_en; /* shift_en interrupt */
  unsigned int reserved5       : BFW_NX90_io_link_irq_raw_reserved5;       /* reserved           */
  unsigned int xlink5_tx_next  : BFW_NX90_io_link_irq_raw_xlink5_tx_next;  /* tx_next interrupt  */
  unsigned int xlink5_rx_next  : BFW_NX90_io_link_irq_raw_xlink5_rx_next;  /* rx_next interrupt  */
  unsigned int xlink5_shift_en : BFW_NX90_io_link_irq_raw_xlink5_shift_en; /* shift_en interrupt */
  unsigned int reserved6       : BFW_NX90_io_link_irq_raw_reserved6;       /* reserved           */
  unsigned int xlink6_tx_next  : BFW_NX90_io_link_irq_raw_xlink6_tx_next;  /* tx_next interrupt  */
  unsigned int xlink6_rx_next  : BFW_NX90_io_link_irq_raw_xlink6_rx_next;  /* rx_next interrupt  */
  unsigned int xlink6_shift_en : BFW_NX90_io_link_irq_raw_xlink6_shift_en; /* shift_en interrupt */
  unsigned int reserved7       : BFW_NX90_io_link_irq_raw_reserved7;       /* reserved           */
  unsigned int xlink7_tx_next  : BFW_NX90_io_link_irq_raw_xlink7_tx_next;  /* tx_next interrupt  */
  unsigned int xlink7_rx_next  : BFW_NX90_io_link_irq_raw_xlink7_rx_next;  /* rx_next interrupt  */
  unsigned int xlink7_shift_en : BFW_NX90_io_link_irq_raw_xlink7_shift_en; /* shift_en interrupt */
  unsigned int reserved8       : BFW_NX90_io_link_irq_raw_reserved8;       /* reserved           */
} NX90_IO_LINK_IRQ_RAW_BIT_T;

typedef union {
  uint32_t                   val;
  NX90_IO_LINK_IRQ_RAW_BIT_T bf;
} NX90_IO_LINK_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register io_link_irq_masked */
/* => IO-Link Masked IRQ register */
/*    Shows status of masked IRQs (as connected to ARM/xPIC) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_link_irq_masked         0x00000004U
#define Adr_NX90_io_link_irq_io_link_irq_masked 0xFF900484U
#define Adr_NX90_io_link_irq_masked             0xFF900484U

#define MSK_NX90_io_link_irq_masked_xlink0_tx_next  0x00000001U
#define SRT_NX90_io_link_irq_masked_xlink0_tx_next  0
#define MSK_NX90_io_link_irq_masked_xlink0_rx_next  0x00000002U
#define SRT_NX90_io_link_irq_masked_xlink0_rx_next  1
#define MSK_NX90_io_link_irq_masked_xlink0_shift_en 0x00000004U
#define SRT_NX90_io_link_irq_masked_xlink0_shift_en 2
#define MSK_NX90_io_link_irq_masked_xlink1_tx_next  0x00000010U
#define SRT_NX90_io_link_irq_masked_xlink1_tx_next  4
#define MSK_NX90_io_link_irq_masked_xlink1_rx_next  0x00000020U
#define SRT_NX90_io_link_irq_masked_xlink1_rx_next  5
#define MSK_NX90_io_link_irq_masked_xlink1_shift_en 0x00000040U
#define SRT_NX90_io_link_irq_masked_xlink1_shift_en 6
#define MSK_NX90_io_link_irq_masked_xlink2_tx_next  0x00000100U
#define SRT_NX90_io_link_irq_masked_xlink2_tx_next  8
#define MSK_NX90_io_link_irq_masked_xlink2_rx_next  0x00000200U
#define SRT_NX90_io_link_irq_masked_xlink2_rx_next  9
#define MSK_NX90_io_link_irq_masked_xlink2_shift_en 0x00000400U
#define SRT_NX90_io_link_irq_masked_xlink2_shift_en 10
#define MSK_NX90_io_link_irq_masked_xlink3_tx_next  0x00001000U
#define SRT_NX90_io_link_irq_masked_xlink3_tx_next  12
#define MSK_NX90_io_link_irq_masked_xlink3_rx_next  0x00002000U
#define SRT_NX90_io_link_irq_masked_xlink3_rx_next  13
#define MSK_NX90_io_link_irq_masked_xlink3_shift_en 0x00004000U
#define SRT_NX90_io_link_irq_masked_xlink3_shift_en 14
#define MSK_NX90_io_link_irq_masked_xlink4_tx_next  0x00010000U
#define SRT_NX90_io_link_irq_masked_xlink4_tx_next  16
#define MSK_NX90_io_link_irq_masked_xlink4_rx_next  0x00020000U
#define SRT_NX90_io_link_irq_masked_xlink4_rx_next  17
#define MSK_NX90_io_link_irq_masked_xlink4_shift_en 0x00040000U
#define SRT_NX90_io_link_irq_masked_xlink4_shift_en 18
#define MSK_NX90_io_link_irq_masked_xlink5_tx_next  0x00100000U
#define SRT_NX90_io_link_irq_masked_xlink5_tx_next  20
#define MSK_NX90_io_link_irq_masked_xlink5_rx_next  0x00200000U
#define SRT_NX90_io_link_irq_masked_xlink5_rx_next  21
#define MSK_NX90_io_link_irq_masked_xlink5_shift_en 0x00400000U
#define SRT_NX90_io_link_irq_masked_xlink5_shift_en 22
#define MSK_NX90_io_link_irq_masked_xlink6_tx_next  0x01000000U
#define SRT_NX90_io_link_irq_masked_xlink6_tx_next  24
#define MSK_NX90_io_link_irq_masked_xlink6_rx_next  0x02000000U
#define SRT_NX90_io_link_irq_masked_xlink6_rx_next  25
#define MSK_NX90_io_link_irq_masked_xlink6_shift_en 0x04000000U
#define SRT_NX90_io_link_irq_masked_xlink6_shift_en 26
#define MSK_NX90_io_link_irq_masked_xlink7_tx_next  0x10000000U
#define SRT_NX90_io_link_irq_masked_xlink7_tx_next  28
#define MSK_NX90_io_link_irq_masked_xlink7_rx_next  0x20000000U
#define SRT_NX90_io_link_irq_masked_xlink7_rx_next  29
#define MSK_NX90_io_link_irq_masked_xlink7_shift_en 0x40000000U
#define SRT_NX90_io_link_irq_masked_xlink7_shift_en 30

/* all used bits of 'NX90_io_link_irq_masked': */
#define MSK_USED_BITS_NX90_io_link_irq_masked 0x77777777U

enum {
  BFW_NX90_io_link_irq_masked_xlink0_tx_next  = 1, /* [0] */
  BFW_NX90_io_link_irq_masked_xlink0_rx_next  = 1, /* [1] */
  BFW_NX90_io_link_irq_masked_xlink0_shift_en = 1, /* [2] */
  BFW_NX90_io_link_irq_masked_reserved1       = 1, /* [3] */
  BFW_NX90_io_link_irq_masked_xlink1_tx_next  = 1, /* [4] */
  BFW_NX90_io_link_irq_masked_xlink1_rx_next  = 1, /* [5] */
  BFW_NX90_io_link_irq_masked_xlink1_shift_en = 1, /* [6] */
  BFW_NX90_io_link_irq_masked_reserved2       = 1, /* [7] */
  BFW_NX90_io_link_irq_masked_xlink2_tx_next  = 1, /* [8] */
  BFW_NX90_io_link_irq_masked_xlink2_rx_next  = 1, /* [9] */
  BFW_NX90_io_link_irq_masked_xlink2_shift_en = 1, /* [10] */
  BFW_NX90_io_link_irq_masked_reserved3       = 1, /* [11] */
  BFW_NX90_io_link_irq_masked_xlink3_tx_next  = 1, /* [12] */
  BFW_NX90_io_link_irq_masked_xlink3_rx_next  = 1, /* [13] */
  BFW_NX90_io_link_irq_masked_xlink3_shift_en = 1, /* [14] */
  BFW_NX90_io_link_irq_masked_reserved4       = 1, /* [15] */
  BFW_NX90_io_link_irq_masked_xlink4_tx_next  = 1, /* [16] */
  BFW_NX90_io_link_irq_masked_xlink4_rx_next  = 1, /* [17] */
  BFW_NX90_io_link_irq_masked_xlink4_shift_en = 1, /* [18] */
  BFW_NX90_io_link_irq_masked_reserved5       = 1, /* [19] */
  BFW_NX90_io_link_irq_masked_xlink5_tx_next  = 1, /* [20] */
  BFW_NX90_io_link_irq_masked_xlink5_rx_next  = 1, /* [21] */
  BFW_NX90_io_link_irq_masked_xlink5_shift_en = 1, /* [22] */
  BFW_NX90_io_link_irq_masked_reserved6       = 1, /* [23] */
  BFW_NX90_io_link_irq_masked_xlink6_tx_next  = 1, /* [24] */
  BFW_NX90_io_link_irq_masked_xlink6_rx_next  = 1, /* [25] */
  BFW_NX90_io_link_irq_masked_xlink6_shift_en = 1, /* [26] */
  BFW_NX90_io_link_irq_masked_reserved7       = 1, /* [27] */
  BFW_NX90_io_link_irq_masked_xlink7_tx_next  = 1, /* [28] */
  BFW_NX90_io_link_irq_masked_xlink7_rx_next  = 1, /* [29] */
  BFW_NX90_io_link_irq_masked_xlink7_shift_en = 1, /* [30] */
  BFW_NX90_io_link_irq_masked_reserved8       = 1  /* [31] */
};

typedef struct NX90_IO_LINK_IRQ_MASKED_BIT_Ttag {
  unsigned int xlink0_tx_next  : BFW_NX90_io_link_irq_masked_xlink0_tx_next;  /* tx_next interrupt  */
  unsigned int xlink0_rx_next  : BFW_NX90_io_link_irq_masked_xlink0_rx_next;  /* rx_next interrupt  */
  unsigned int xlink0_shift_en : BFW_NX90_io_link_irq_masked_xlink0_shift_en; /* shift_en interrupt */
  unsigned int reserved1       : BFW_NX90_io_link_irq_masked_reserved1;       /* reserved           */
  unsigned int xlink1_tx_next  : BFW_NX90_io_link_irq_masked_xlink1_tx_next;  /* tx_next interrupt  */
  unsigned int xlink1_rx_next  : BFW_NX90_io_link_irq_masked_xlink1_rx_next;  /* rx_next interrupt  */
  unsigned int xlink1_shift_en : BFW_NX90_io_link_irq_masked_xlink1_shift_en; /* shift_en interrupt */
  unsigned int reserved2       : BFW_NX90_io_link_irq_masked_reserved2;       /* reserved           */
  unsigned int xlink2_tx_next  : BFW_NX90_io_link_irq_masked_xlink2_tx_next;  /* tx_next interrupt  */
  unsigned int xlink2_rx_next  : BFW_NX90_io_link_irq_masked_xlink2_rx_next;  /* rx_next interrupt  */
  unsigned int xlink2_shift_en : BFW_NX90_io_link_irq_masked_xlink2_shift_en; /* shift_en interrupt */
  unsigned int reserved3       : BFW_NX90_io_link_irq_masked_reserved3;       /* reserved           */
  unsigned int xlink3_tx_next  : BFW_NX90_io_link_irq_masked_xlink3_tx_next;  /* tx_next interrupt  */
  unsigned int xlink3_rx_next  : BFW_NX90_io_link_irq_masked_xlink3_rx_next;  /* rx_next interrupt  */
  unsigned int xlink3_shift_en : BFW_NX90_io_link_irq_masked_xlink3_shift_en; /* shift_en interrupt */
  unsigned int reserved4       : BFW_NX90_io_link_irq_masked_reserved4;       /* reserved           */
  unsigned int xlink4_tx_next  : BFW_NX90_io_link_irq_masked_xlink4_tx_next;  /* tx_next interrupt  */
  unsigned int xlink4_rx_next  : BFW_NX90_io_link_irq_masked_xlink4_rx_next;  /* rx_next interrupt  */
  unsigned int xlink4_shift_en : BFW_NX90_io_link_irq_masked_xlink4_shift_en; /* shift_en interrupt */
  unsigned int reserved5       : BFW_NX90_io_link_irq_masked_reserved5;       /* reserved           */
  unsigned int xlink5_tx_next  : BFW_NX90_io_link_irq_masked_xlink5_tx_next;  /* tx_next interrupt  */
  unsigned int xlink5_rx_next  : BFW_NX90_io_link_irq_masked_xlink5_rx_next;  /* rx_next interrupt  */
  unsigned int xlink5_shift_en : BFW_NX90_io_link_irq_masked_xlink5_shift_en; /* shift_en interrupt */
  unsigned int reserved6       : BFW_NX90_io_link_irq_masked_reserved6;       /* reserved           */
  unsigned int xlink6_tx_next  : BFW_NX90_io_link_irq_masked_xlink6_tx_next;  /* tx_next interrupt  */
  unsigned int xlink6_rx_next  : BFW_NX90_io_link_irq_masked_xlink6_rx_next;  /* rx_next interrupt  */
  unsigned int xlink6_shift_en : BFW_NX90_io_link_irq_masked_xlink6_shift_en; /* shift_en interrupt */
  unsigned int reserved7       : BFW_NX90_io_link_irq_masked_reserved7;       /* reserved           */
  unsigned int xlink7_tx_next  : BFW_NX90_io_link_irq_masked_xlink7_tx_next;  /* tx_next interrupt  */
  unsigned int xlink7_rx_next  : BFW_NX90_io_link_irq_masked_xlink7_rx_next;  /* rx_next interrupt  */
  unsigned int xlink7_shift_en : BFW_NX90_io_link_irq_masked_xlink7_shift_en; /* shift_en interrupt */
  unsigned int reserved8       : BFW_NX90_io_link_irq_masked_reserved8;       /* reserved           */
} NX90_IO_LINK_IRQ_MASKED_BIT_T;

typedef union {
  uint32_t                      val;
  NX90_IO_LINK_IRQ_MASKED_BIT_T bf;
} NX90_IO_LINK_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register io_link_irq_msk_set */
/* => IO-Link interrupt mask enable: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to io_link_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_link_irq_msk_set         0x00000008U
#define Adr_NX90_io_link_irq_io_link_irq_msk_set 0xFF900488U
#define Adr_NX90_io_link_irq_msk_set             0xFF900488U
#define DFLT_VAL_NX90_io_link_irq_msk_set        0x00000000U

#define MSK_NX90_io_link_irq_msk_set_xlink0_tx_next          0x00000001U
#define SRT_NX90_io_link_irq_msk_set_xlink0_tx_next          0
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink0_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink0_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink0_rx_next          0x00000002U
#define SRT_NX90_io_link_irq_msk_set_xlink0_rx_next          1
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink0_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink0_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink0_shift_en         0x00000004U
#define SRT_NX90_io_link_irq_msk_set_xlink0_shift_en         2
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink0_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink0_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink1_tx_next          0x00000010U
#define SRT_NX90_io_link_irq_msk_set_xlink1_tx_next          4
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink1_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink1_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink1_rx_next          0x00000020U
#define SRT_NX90_io_link_irq_msk_set_xlink1_rx_next          5
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink1_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink1_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink1_shift_en         0x00000040U
#define SRT_NX90_io_link_irq_msk_set_xlink1_shift_en         6
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink1_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink1_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink2_tx_next          0x00000100U
#define SRT_NX90_io_link_irq_msk_set_xlink2_tx_next          8
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink2_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink2_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink2_rx_next          0x00000200U
#define SRT_NX90_io_link_irq_msk_set_xlink2_rx_next          9
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink2_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink2_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink2_shift_en         0x00000400U
#define SRT_NX90_io_link_irq_msk_set_xlink2_shift_en         10
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink2_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink2_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink3_tx_next          0x00001000U
#define SRT_NX90_io_link_irq_msk_set_xlink3_tx_next          12
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink3_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink3_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink3_rx_next          0x00002000U
#define SRT_NX90_io_link_irq_msk_set_xlink3_rx_next          13
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink3_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink3_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink3_shift_en         0x00004000U
#define SRT_NX90_io_link_irq_msk_set_xlink3_shift_en         14
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink3_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink3_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink4_tx_next          0x00010000U
#define SRT_NX90_io_link_irq_msk_set_xlink4_tx_next          16
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink4_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink4_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink4_rx_next          0x00020000U
#define SRT_NX90_io_link_irq_msk_set_xlink4_rx_next          17
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink4_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink4_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink4_shift_en         0x00040000U
#define SRT_NX90_io_link_irq_msk_set_xlink4_shift_en         18
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink4_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink4_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink5_tx_next          0x00100000U
#define SRT_NX90_io_link_irq_msk_set_xlink5_tx_next          20
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink5_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink5_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink5_rx_next          0x00200000U
#define SRT_NX90_io_link_irq_msk_set_xlink5_rx_next          21
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink5_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink5_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink5_shift_en         0x00400000U
#define SRT_NX90_io_link_irq_msk_set_xlink5_shift_en         22
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink5_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink5_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink6_tx_next          0x01000000U
#define SRT_NX90_io_link_irq_msk_set_xlink6_tx_next          24
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink6_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink6_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink6_rx_next          0x02000000U
#define SRT_NX90_io_link_irq_msk_set_xlink6_rx_next          25
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink6_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink6_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink6_shift_en         0x04000000U
#define SRT_NX90_io_link_irq_msk_set_xlink6_shift_en         26
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink6_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink6_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink7_tx_next          0x10000000U
#define SRT_NX90_io_link_irq_msk_set_xlink7_tx_next          28
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink7_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink7_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink7_rx_next          0x20000000U
#define SRT_NX90_io_link_irq_msk_set_xlink7_rx_next          29
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink7_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink7_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_set_xlink7_shift_en         0x40000000U
#define SRT_NX90_io_link_irq_msk_set_xlink7_shift_en         30
#define DFLT_VAL_NX90_io_link_irq_msk_set_xlink7_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_set_xlink7_shift_en 0x00000000U

/* all used bits of 'NX90_io_link_irq_msk_set': */
#define MSK_USED_BITS_NX90_io_link_irq_msk_set 0x77777777U

enum {
  BFW_NX90_io_link_irq_msk_set_xlink0_tx_next  = 1, /* [0] */
  BFW_NX90_io_link_irq_msk_set_xlink0_rx_next  = 1, /* [1] */
  BFW_NX90_io_link_irq_msk_set_xlink0_shift_en = 1, /* [2] */
  BFW_NX90_io_link_irq_msk_set_reserved1       = 1, /* [3] */
  BFW_NX90_io_link_irq_msk_set_xlink1_tx_next  = 1, /* [4] */
  BFW_NX90_io_link_irq_msk_set_xlink1_rx_next  = 1, /* [5] */
  BFW_NX90_io_link_irq_msk_set_xlink1_shift_en = 1, /* [6] */
  BFW_NX90_io_link_irq_msk_set_reserved2       = 1, /* [7] */
  BFW_NX90_io_link_irq_msk_set_xlink2_tx_next  = 1, /* [8] */
  BFW_NX90_io_link_irq_msk_set_xlink2_rx_next  = 1, /* [9] */
  BFW_NX90_io_link_irq_msk_set_xlink2_shift_en = 1, /* [10] */
  BFW_NX90_io_link_irq_msk_set_reserved3       = 1, /* [11] */
  BFW_NX90_io_link_irq_msk_set_xlink3_tx_next  = 1, /* [12] */
  BFW_NX90_io_link_irq_msk_set_xlink3_rx_next  = 1, /* [13] */
  BFW_NX90_io_link_irq_msk_set_xlink3_shift_en = 1, /* [14] */
  BFW_NX90_io_link_irq_msk_set_reserved4       = 1, /* [15] */
  BFW_NX90_io_link_irq_msk_set_xlink4_tx_next  = 1, /* [16] */
  BFW_NX90_io_link_irq_msk_set_xlink4_rx_next  = 1, /* [17] */
  BFW_NX90_io_link_irq_msk_set_xlink4_shift_en = 1, /* [18] */
  BFW_NX90_io_link_irq_msk_set_reserved5       = 1, /* [19] */
  BFW_NX90_io_link_irq_msk_set_xlink5_tx_next  = 1, /* [20] */
  BFW_NX90_io_link_irq_msk_set_xlink5_rx_next  = 1, /* [21] */
  BFW_NX90_io_link_irq_msk_set_xlink5_shift_en = 1, /* [22] */
  BFW_NX90_io_link_irq_msk_set_reserved6       = 1, /* [23] */
  BFW_NX90_io_link_irq_msk_set_xlink6_tx_next  = 1, /* [24] */
  BFW_NX90_io_link_irq_msk_set_xlink6_rx_next  = 1, /* [25] */
  BFW_NX90_io_link_irq_msk_set_xlink6_shift_en = 1, /* [26] */
  BFW_NX90_io_link_irq_msk_set_reserved7       = 1, /* [27] */
  BFW_NX90_io_link_irq_msk_set_xlink7_tx_next  = 1, /* [28] */
  BFW_NX90_io_link_irq_msk_set_xlink7_rx_next  = 1, /* [29] */
  BFW_NX90_io_link_irq_msk_set_xlink7_shift_en = 1, /* [30] */
  BFW_NX90_io_link_irq_msk_set_reserved8       = 1  /* [31] */
};

typedef struct NX90_IO_LINK_IRQ_MSK_SET_BIT_Ttag {
  unsigned int xlink0_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink0_tx_next;  /* tx_next interrupt  */
  unsigned int xlink0_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink0_rx_next;  /* rx_next interrupt  */
  unsigned int xlink0_shift_en : BFW_NX90_io_link_irq_msk_set_xlink0_shift_en; /* shift_en interrupt */
  unsigned int reserved1       : BFW_NX90_io_link_irq_msk_set_reserved1;       /* reserved           */
  unsigned int xlink1_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink1_tx_next;  /* tx_next interrupt  */
  unsigned int xlink1_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink1_rx_next;  /* rx_next interrupt  */
  unsigned int xlink1_shift_en : BFW_NX90_io_link_irq_msk_set_xlink1_shift_en; /* shift_en interrupt */
  unsigned int reserved2       : BFW_NX90_io_link_irq_msk_set_reserved2;       /* reserved           */
  unsigned int xlink2_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink2_tx_next;  /* tx_next interrupt  */
  unsigned int xlink2_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink2_rx_next;  /* rx_next interrupt  */
  unsigned int xlink2_shift_en : BFW_NX90_io_link_irq_msk_set_xlink2_shift_en; /* shift_en interrupt */
  unsigned int reserved3       : BFW_NX90_io_link_irq_msk_set_reserved3;       /* reserved           */
  unsigned int xlink3_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink3_tx_next;  /* tx_next interrupt  */
  unsigned int xlink3_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink3_rx_next;  /* rx_next interrupt  */
  unsigned int xlink3_shift_en : BFW_NX90_io_link_irq_msk_set_xlink3_shift_en; /* shift_en interrupt */
  unsigned int reserved4       : BFW_NX90_io_link_irq_msk_set_reserved4;       /* reserved           */
  unsigned int xlink4_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink4_tx_next;  /* tx_next interrupt  */
  unsigned int xlink4_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink4_rx_next;  /* rx_next interrupt  */
  unsigned int xlink4_shift_en : BFW_NX90_io_link_irq_msk_set_xlink4_shift_en; /* shift_en interrupt */
  unsigned int reserved5       : BFW_NX90_io_link_irq_msk_set_reserved5;       /* reserved           */
  unsigned int xlink5_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink5_tx_next;  /* tx_next interrupt  */
  unsigned int xlink5_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink5_rx_next;  /* rx_next interrupt  */
  unsigned int xlink5_shift_en : BFW_NX90_io_link_irq_msk_set_xlink5_shift_en; /* shift_en interrupt */
  unsigned int reserved6       : BFW_NX90_io_link_irq_msk_set_reserved6;       /* reserved           */
  unsigned int xlink6_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink6_tx_next;  /* tx_next interrupt  */
  unsigned int xlink6_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink6_rx_next;  /* rx_next interrupt  */
  unsigned int xlink6_shift_en : BFW_NX90_io_link_irq_msk_set_xlink6_shift_en; /* shift_en interrupt */
  unsigned int reserved7       : BFW_NX90_io_link_irq_msk_set_reserved7;       /* reserved           */
  unsigned int xlink7_tx_next  : BFW_NX90_io_link_irq_msk_set_xlink7_tx_next;  /* tx_next interrupt  */
  unsigned int xlink7_rx_next  : BFW_NX90_io_link_irq_msk_set_xlink7_rx_next;  /* rx_next interrupt  */
  unsigned int xlink7_shift_en : BFW_NX90_io_link_irq_msk_set_xlink7_shift_en; /* shift_en interrupt */
  unsigned int reserved8       : BFW_NX90_io_link_irq_msk_set_reserved8;       /* reserved           */
} NX90_IO_LINK_IRQ_MSK_SET_BIT_T;

typedef union {
  uint32_t                       val;
  NX90_IO_LINK_IRQ_MSK_SET_BIT_T bf;
} NX90_IO_LINK_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register io_link_irq_msk_reset */
/* => IO-Link interrupt mask disable: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX90_io_link_irq_msk_reset         0x0000000CU
#define Adr_NX90_io_link_irq_io_link_irq_msk_reset 0xFF90048CU
#define Adr_NX90_io_link_irq_msk_reset             0xFF90048CU
#define DFLT_VAL_NX90_io_link_irq_msk_reset        0x00000000U

#define MSK_NX90_io_link_irq_msk_reset_xlink0_tx_next          0x00000001U
#define SRT_NX90_io_link_irq_msk_reset_xlink0_tx_next          0
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink0_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink0_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink0_rx_next          0x00000002U
#define SRT_NX90_io_link_irq_msk_reset_xlink0_rx_next          1
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink0_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink0_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink0_shift_en         0x00000004U
#define SRT_NX90_io_link_irq_msk_reset_xlink0_shift_en         2
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink0_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink0_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink1_tx_next          0x00000010U
#define SRT_NX90_io_link_irq_msk_reset_xlink1_tx_next          4
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink1_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink1_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink1_rx_next          0x00000020U
#define SRT_NX90_io_link_irq_msk_reset_xlink1_rx_next          5
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink1_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink1_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink1_shift_en         0x00000040U
#define SRT_NX90_io_link_irq_msk_reset_xlink1_shift_en         6
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink1_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink1_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink2_tx_next          0x00000100U
#define SRT_NX90_io_link_irq_msk_reset_xlink2_tx_next          8
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink2_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink2_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink2_rx_next          0x00000200U
#define SRT_NX90_io_link_irq_msk_reset_xlink2_rx_next          9
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink2_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink2_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink2_shift_en         0x00000400U
#define SRT_NX90_io_link_irq_msk_reset_xlink2_shift_en         10
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink2_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink2_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink3_tx_next          0x00001000U
#define SRT_NX90_io_link_irq_msk_reset_xlink3_tx_next          12
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink3_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink3_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink3_rx_next          0x00002000U
#define SRT_NX90_io_link_irq_msk_reset_xlink3_rx_next          13
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink3_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink3_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink3_shift_en         0x00004000U
#define SRT_NX90_io_link_irq_msk_reset_xlink3_shift_en         14
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink3_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink3_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink4_tx_next          0x00010000U
#define SRT_NX90_io_link_irq_msk_reset_xlink4_tx_next          16
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink4_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink4_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink4_rx_next          0x00020000U
#define SRT_NX90_io_link_irq_msk_reset_xlink4_rx_next          17
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink4_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink4_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink4_shift_en         0x00040000U
#define SRT_NX90_io_link_irq_msk_reset_xlink4_shift_en         18
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink4_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink4_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink5_tx_next          0x00100000U
#define SRT_NX90_io_link_irq_msk_reset_xlink5_tx_next          20
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink5_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink5_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink5_rx_next          0x00200000U
#define SRT_NX90_io_link_irq_msk_reset_xlink5_rx_next          21
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink5_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink5_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink5_shift_en         0x00400000U
#define SRT_NX90_io_link_irq_msk_reset_xlink5_shift_en         22
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink5_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink5_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink6_tx_next          0x01000000U
#define SRT_NX90_io_link_irq_msk_reset_xlink6_tx_next          24
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink6_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink6_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink6_rx_next          0x02000000U
#define SRT_NX90_io_link_irq_msk_reset_xlink6_rx_next          25
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink6_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink6_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink6_shift_en         0x04000000U
#define SRT_NX90_io_link_irq_msk_reset_xlink6_shift_en         26
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink6_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink6_shift_en 0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink7_tx_next          0x10000000U
#define SRT_NX90_io_link_irq_msk_reset_xlink7_tx_next          28
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink7_tx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink7_tx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink7_rx_next          0x20000000U
#define SRT_NX90_io_link_irq_msk_reset_xlink7_rx_next          29
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink7_rx_next     0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink7_rx_next  0x00000000U
#define MSK_NX90_io_link_irq_msk_reset_xlink7_shift_en         0x40000000U
#define SRT_NX90_io_link_irq_msk_reset_xlink7_shift_en         30
#define DFLT_VAL_NX90_io_link_irq_msk_reset_xlink7_shift_en    0x00000000U
#define DFLT_BF_VAL_NX90_io_link_irq_msk_reset_xlink7_shift_en 0x00000000U

/* all used bits of 'NX90_io_link_irq_msk_reset': */
#define MSK_USED_BITS_NX90_io_link_irq_msk_reset 0x77777777U

enum {
  BFW_NX90_io_link_irq_msk_reset_xlink0_tx_next  = 1, /* [0] */
  BFW_NX90_io_link_irq_msk_reset_xlink0_rx_next  = 1, /* [1] */
  BFW_NX90_io_link_irq_msk_reset_xlink0_shift_en = 1, /* [2] */
  BFW_NX90_io_link_irq_msk_reset_reserved1       = 1, /* [3] */
  BFW_NX90_io_link_irq_msk_reset_xlink1_tx_next  = 1, /* [4] */
  BFW_NX90_io_link_irq_msk_reset_xlink1_rx_next  = 1, /* [5] */
  BFW_NX90_io_link_irq_msk_reset_xlink1_shift_en = 1, /* [6] */
  BFW_NX90_io_link_irq_msk_reset_reserved2       = 1, /* [7] */
  BFW_NX90_io_link_irq_msk_reset_xlink2_tx_next  = 1, /* [8] */
  BFW_NX90_io_link_irq_msk_reset_xlink2_rx_next  = 1, /* [9] */
  BFW_NX90_io_link_irq_msk_reset_xlink2_shift_en = 1, /* [10] */
  BFW_NX90_io_link_irq_msk_reset_reserved3       = 1, /* [11] */
  BFW_NX90_io_link_irq_msk_reset_xlink3_tx_next  = 1, /* [12] */
  BFW_NX90_io_link_irq_msk_reset_xlink3_rx_next  = 1, /* [13] */
  BFW_NX90_io_link_irq_msk_reset_xlink3_shift_en = 1, /* [14] */
  BFW_NX90_io_link_irq_msk_reset_reserved4       = 1, /* [15] */
  BFW_NX90_io_link_irq_msk_reset_xlink4_tx_next  = 1, /* [16] */
  BFW_NX90_io_link_irq_msk_reset_xlink4_rx_next  = 1, /* [17] */
  BFW_NX90_io_link_irq_msk_reset_xlink4_shift_en = 1, /* [18] */
  BFW_NX90_io_link_irq_msk_reset_reserved5       = 1, /* [19] */
  BFW_NX90_io_link_irq_msk_reset_xlink5_tx_next  = 1, /* [20] */
  BFW_NX90_io_link_irq_msk_reset_xlink5_rx_next  = 1, /* [21] */
  BFW_NX90_io_link_irq_msk_reset_xlink5_shift_en = 1, /* [22] */
  BFW_NX90_io_link_irq_msk_reset_reserved6       = 1, /* [23] */
  BFW_NX90_io_link_irq_msk_reset_xlink6_tx_next  = 1, /* [24] */
  BFW_NX90_io_link_irq_msk_reset_xlink6_rx_next  = 1, /* [25] */
  BFW_NX90_io_link_irq_msk_reset_xlink6_shift_en = 1, /* [26] */
  BFW_NX90_io_link_irq_msk_reset_reserved7       = 1, /* [27] */
  BFW_NX90_io_link_irq_msk_reset_xlink7_tx_next  = 1, /* [28] */
  BFW_NX90_io_link_irq_msk_reset_xlink7_rx_next  = 1, /* [29] */
  BFW_NX90_io_link_irq_msk_reset_xlink7_shift_en = 1, /* [30] */
  BFW_NX90_io_link_irq_msk_reset_reserved8       = 1  /* [31] */
};

typedef struct NX90_IO_LINK_IRQ_MSK_RESET_BIT_Ttag {
  unsigned int xlink0_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink0_tx_next;  /* tx_next interrupt  */
  unsigned int xlink0_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink0_rx_next;  /* rx_next interrupt  */
  unsigned int xlink0_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink0_shift_en; /* shift_en interrupt */
  unsigned int reserved1       : BFW_NX90_io_link_irq_msk_reset_reserved1;       /* reserved           */
  unsigned int xlink1_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink1_tx_next;  /* tx_next interrupt  */
  unsigned int xlink1_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink1_rx_next;  /* rx_next interrupt  */
  unsigned int xlink1_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink1_shift_en; /* shift_en interrupt */
  unsigned int reserved2       : BFW_NX90_io_link_irq_msk_reset_reserved2;       /* reserved           */
  unsigned int xlink2_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink2_tx_next;  /* tx_next interrupt  */
  unsigned int xlink2_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink2_rx_next;  /* rx_next interrupt  */
  unsigned int xlink2_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink2_shift_en; /* shift_en interrupt */
  unsigned int reserved3       : BFW_NX90_io_link_irq_msk_reset_reserved3;       /* reserved           */
  unsigned int xlink3_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink3_tx_next;  /* tx_next interrupt  */
  unsigned int xlink3_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink3_rx_next;  /* rx_next interrupt  */
  unsigned int xlink3_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink3_shift_en; /* shift_en interrupt */
  unsigned int reserved4       : BFW_NX90_io_link_irq_msk_reset_reserved4;       /* reserved           */
  unsigned int xlink4_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink4_tx_next;  /* tx_next interrupt  */
  unsigned int xlink4_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink4_rx_next;  /* rx_next interrupt  */
  unsigned int xlink4_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink4_shift_en; /* shift_en interrupt */
  unsigned int reserved5       : BFW_NX90_io_link_irq_msk_reset_reserved5;       /* reserved           */
  unsigned int xlink5_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink5_tx_next;  /* tx_next interrupt  */
  unsigned int xlink5_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink5_rx_next;  /* rx_next interrupt  */
  unsigned int xlink5_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink5_shift_en; /* shift_en interrupt */
  unsigned int reserved6       : BFW_NX90_io_link_irq_msk_reset_reserved6;       /* reserved           */
  unsigned int xlink6_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink6_tx_next;  /* tx_next interrupt  */
  unsigned int xlink6_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink6_rx_next;  /* rx_next interrupt  */
  unsigned int xlink6_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink6_shift_en; /* shift_en interrupt */
  unsigned int reserved7       : BFW_NX90_io_link_irq_msk_reset_reserved7;       /* reserved           */
  unsigned int xlink7_tx_next  : BFW_NX90_io_link_irq_msk_reset_xlink7_tx_next;  /* tx_next interrupt  */
  unsigned int xlink7_rx_next  : BFW_NX90_io_link_irq_msk_reset_xlink7_rx_next;  /* rx_next interrupt  */
  unsigned int xlink7_shift_en : BFW_NX90_io_link_irq_msk_reset_xlink7_shift_en; /* shift_en interrupt */
  unsigned int reserved8       : BFW_NX90_io_link_irq_msk_reset_reserved8;       /* reserved           */
} NX90_IO_LINK_IRQ_MSK_RESET_BIT_T;

typedef union {
  uint32_t                         val;
  NX90_IO_LINK_IRQ_MSK_RESET_BIT_T bf;
} NX90_IO_LINK_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* Area of debug_slave */

/* ===================================================================== */

#define Addr_NX90_debug_slave 0xFFFF8000U

/* ===================================================================== */

/* Area of cssys_rom_table */

/* ===================================================================== */

#define Addr_NX90_cssys_rom_table 0xFFFF8000U

/* ===================================================================== */

/* Area of cssys_tsgen */

/* ===================================================================== */

#define Addr_NX90_cssys_tsgen 0xFFFF9000U

/* ===================================================================== */

/* Area of cssys_cti */

/* ===================================================================== */

#define Addr_NX90_cssys_cti 0xFFFFA000U

/* ===================================================================== */

/* Area of cssys_atbfunnel */

/* ===================================================================== */

#define Addr_NX90_cssys_atbfunnel 0xFFFFB000U

/* ===================================================================== */

/* Area of cssys_tpiu */

/* ===================================================================== */

#define Addr_NX90_cssys_tpiu 0xFFFFC000U



/*********************************************************************/
/* area structure definitions                                        */
/*********************************************************************/


typedef struct NX90_CM4_SCS_AREA_Ttag
{
  volatile uint32_t aulReserved0[2];
  volatile uint32_t  ulCm4_scs_actlr;
  volatile uint32_t aulReserved1[1];
  volatile uint32_t  ulCm4_scs_stcsr;
  volatile uint32_t  ulCm4_scs_strvr;
  volatile uint32_t  ulCm4_scs_stcvr;
  volatile uint32_t  ulCm4_scs_stcr;
  volatile uint32_t aulReserved2[56];
  volatile uint32_t aulCm4_scs_nvic_iser[3];
  volatile uint32_t aulReserved3[29];
  volatile uint32_t aulCm4_scs_nvic_icer[3];
  volatile uint32_t aulReserved4[29];
  volatile uint32_t aulCm4_scs_nvic_ispr[3];
  volatile uint32_t aulReserved5[29];
  volatile uint32_t aulCm4_scs_nvic_icpr[3];
  volatile uint32_t aulReserved6[29];
  volatile uint32_t aulCm4_scs_nvic_iabr[3];
  volatile uint32_t aulReserved7[61];
  volatile uint32_t aulCm4_scs_nvic_ipr[17];
  volatile uint32_t aulReserved8[559];
  volatile uint32_t  ulCm4_scs_cpuid;
  volatile uint32_t  ulCm4_scs_icsr;
  volatile uint32_t  ulCm4_scs_vtor;
  volatile uint32_t  ulCm4_scs_aircr;
  volatile uint32_t  ulCm4_scs_scr;
  volatile uint32_t  ulCm4_scs_ccr;
  volatile uint32_t  ulCm4_scs_shpr1;
  volatile uint32_t  ulCm4_scs_shpr2;
  volatile uint32_t  ulCm4_scs_shpr3;
  volatile uint32_t  ulCm4_scs_shcsr;
  volatile uint32_t  ulCm4_scs_cfsr;
  volatile uint32_t  ulCm4_scs_hfsr;
  volatile uint32_t  ulCm4_scs_dfsr;
  volatile uint32_t  ulCm4_scs_mmfar;
  volatile uint32_t  ulCm4_scs_bfar;
  volatile uint32_t  ulCm4_scs_afsr;
  volatile uint32_t aulReserved9[18];
  volatile uint32_t  ulCm4_scs_cpacr;
  volatile uint32_t aulReserved10[25];
  volatile uint32_t  ulCm4_scs_dhcsr;
  volatile uint32_t  ulCm4_scs_dcrsr;
  volatile uint32_t  ulCm4_scs_dcrdr;
  volatile uint32_t  ulCm4_scs_demcr;
  volatile uint32_t aulReserved11[116];
  volatile uint32_t  ulCm4_scs_pidr4;
  volatile uint32_t aulReserved12[3];
  volatile uint32_t aulCm4_scs_pidr[4];
  volatile uint32_t aulCm4_scs_cidr[4];
} NX90_CM4_SCS_AREA_T;

typedef struct NX90_CM4_MISC_CTRL_AREA_Ttag
{
  volatile uint32_t  ulCm4_misc_ctrl_cpu_info;
  volatile uint32_t  ulCm4_misc_ctrl_fpu_irq_raw;
  volatile uint32_t  ulCm4_misc_ctrl_fpu_irq_masked;
  volatile uint32_t  ulCm4_misc_ctrl_fpu_irq_msk_set;
  volatile uint32_t  ulCm4_misc_ctrl_fpu_irq_msk_reset;
} NX90_CM4_MISC_CTRL_AREA_T;

typedef struct NX90_IDPM_AREA_Ttag
{
  volatile uint32_t  ulIdpm_cfg0x0;
  volatile uint32_t aulReserved0[3];
  volatile uint32_t  ulIdpm_addr_cfg;
  volatile uint32_t aulReserved1[2];
  volatile uint32_t  ulIdpm_status;
  volatile uint32_t aulReserved2[6];
  volatile uint32_t  ulIdpm_tunnel_cfg;
  volatile uint32_t  ulIdpm_itbaddr;
  volatile uint32_t  ulIdpm_win1_end;
  volatile uint32_t  ulIdpm_win1_map;
  volatile uint32_t  ulIdpm_win2_end;
  volatile uint32_t  ulIdpm_win2_map;
  volatile uint32_t  ulIdpm_win3_end;
  volatile uint32_t  ulIdpm_win3_map;
  volatile uint32_t  ulIdpm_win4_end;
  volatile uint32_t  ulIdpm_win4_map;
  volatile uint32_t aulReserved3[8];
  volatile uint32_t  ulIdpm_irq_raw;
  volatile uint32_t  ulIdpm_irq_host_mask_set;
  volatile uint32_t  ulIdpm_irq_host_mask_reset;
  volatile uint32_t  ulIdpm_irq_host_masked;
  volatile uint32_t aulReserved4[12];
  volatile uint32_t  ulIdpm_sw_irq;
  volatile uint32_t aulReserved5[5];
  volatile uint32_t  ulIdpm_sys_sta;
  volatile uint32_t  ulIdpm_reset_request;
  volatile uint32_t  ulIdpm_firmware_irq_raw;
  volatile uint32_t aulReserved6[3];
  volatile uint32_t  ulIdpm_firmware_irq_mask;
  volatile uint32_t aulReserved7[2];
  volatile uint32_t  ulIdpm_netx_version;
} NX90_IDPM_AREA_T;

typedef struct NX90_HASH_AREA_Ttag
{
  volatile uint32_t  ulHash_din;
  volatile uint32_t  ulHash_cfg;
  volatile uint32_t  ulHash_stat;
  volatile uint32_t  ulHash_debug_info;
  volatile uint32_t  ulHash_irq_raw;
  volatile uint32_t  ulHash_irq_masked;
  volatile uint32_t  ulHash_irq_msk_set;
  volatile uint32_t  ulHash_irq_msk_reset;
  volatile uint32_t aulHash_dout[16];
} NX90_HASH_AREA_T;

typedef struct NX90_AES_AREA_Ttag
{
  volatile uint32_t  ulAes_cfg;
  volatile uint32_t  ulAes_stat;
  volatile uint32_t  ulAes_irq_raw;
  volatile uint32_t  ulAes_irq_masked;
  volatile uint32_t  ulAes_irq_msk_set;
  volatile uint32_t  ulAes_irq_msk_reset;
  volatile uint32_t aulAes_key[8];
  volatile uint32_t  ulAes_din;
  volatile uint32_t  ulAes_dout;
} NX90_AES_AREA_T;

typedef struct NX90_RANDOM_AREA_Ttag
{
  volatile uint32_t  ulRandom_init;
  volatile uint32_t  ulRandom_random;
} NX90_RANDOM_AREA_T;

typedef struct NX90_MTGY_AREA_Ttag
{
  volatile uint32_t  ulMtgy_cmd;
  volatile uint32_t  ulMtgy_stat;
  volatile uint32_t  ulMtgy_irq_raw;
  volatile uint32_t  ulMtgy_irq_masked;
  volatile uint32_t  ulMtgy_irq_msk_set;
  volatile uint32_t  ulMtgy_irq_msk_reset;
  volatile uint32_t aulReserved0[1018];
  volatile uint32_t aulMtgy_op_tc[128];
  volatile uint32_t aulMtgy_op_ts[128];
  volatile uint32_t aulMtgy_op_p[128];
  volatile uint32_t aulMtgy_op_b[128];
  volatile uint32_t aulMtgy_op_a[128];
  volatile uint32_t aulMtgy_op_e[128];
  volatile uint32_t aulMtgy_op_x[128];
} NX90_MTGY_AREA_T;

typedef struct NX90_NFIFO_AREA_Ttag
{
  volatile uint32_t  ulNfifo_config;
  volatile uint32_t aulReserved0[2];
  volatile uint32_t  ulNfifo_irq_raw;
  volatile uint32_t  ulNfifo_irq_arm_app_masked;
  volatile uint32_t  ulNfifo_irq_arm_app_msk_set;
  volatile uint32_t  ulNfifo_irq_arm_app_msk_reset;
  volatile uint32_t aulReserved1[3];
  volatile uint32_t  ulNfifo_irq_xpic_app_masked;
  volatile uint32_t  ulNfifo_irq_xpic_app_msk_set;
  volatile uint32_t  ulNfifo_irq_xpic_app_msk_reset;
  volatile uint32_t aulReserved2[9];
  volatile uint32_t aulNfifo_irq_observe[10];
  volatile uint32_t aulNfifo_fifo[992];
} NX90_NFIFO_AREA_T;

typedef struct NX90_PAD_CTRL_AREA_Ttag
{
  volatile uint32_t  ulPad_ctrl_rdy_n;
  volatile uint32_t  ulPad_ctrl_run_n;
  volatile uint32_t aulPad_ctrl_mled[4];
  volatile uint32_t aulPad_ctrl_com_io[4];
  volatile uint32_t  ulPad_ctrl_mii0_rxclk;
  volatile uint32_t aulPad_ctrl_mii0_rxd[4];
  volatile uint32_t  ulPad_ctrl_mii0_rxdv;
  volatile uint32_t  ulPad_ctrl_mii0_rxer;
  volatile uint32_t  ulPad_ctrl_mii0_txclk;
  volatile uint32_t aulPad_ctrl_mii0_txd[4];
  volatile uint32_t  ulPad_ctrl_mii0_txen;
  volatile uint32_t  ulPad_ctrl_mii0_col;
  volatile uint32_t  ulPad_ctrl_mii0_crs;
  volatile uint32_t  ulPad_ctrl_phy0_led_link_in;
  volatile uint32_t  ulPad_ctrl_mii1_rxclk;
  volatile uint32_t aulPad_ctrl_mii1_rxd[4];
  volatile uint32_t  ulPad_ctrl_mii1_rxdv;
  volatile uint32_t  ulPad_ctrl_mii1_rxer;
  volatile uint32_t  ulPad_ctrl_mii1_txclk;
  volatile uint32_t aulPad_ctrl_mii1_txd[4];
  volatile uint32_t  ulPad_ctrl_mii1_txen;
  volatile uint32_t  ulPad_ctrl_mii1_col;
  volatile uint32_t  ulPad_ctrl_mii1_crs;
  volatile uint32_t  ulPad_ctrl_phy1_led_link_in;
  volatile uint32_t  ulPad_ctrl_mii_mdc;
  volatile uint32_t  ulPad_ctrl_mii_mdio;
  volatile uint32_t  ulPad_ctrl_rst_out_n;
  volatile uint32_t  ulPad_ctrl_clk25out;
  volatile uint32_t aulPad_ctrl_mmio[8];
  volatile uint32_t  ulPad_ctrl_sqi_clk;
  volatile uint32_t  ulPad_ctrl_sqi_cs0n;
  volatile uint32_t  ulPad_ctrl_sqi_mosi;
  volatile uint32_t  ulPad_ctrl_sqi_miso;
  volatile uint32_t  ulPad_ctrl_sqi_sio2;
  volatile uint32_t  ulPad_ctrl_sqi_sio3;
  volatile uint32_t aulPad_ctrl_hif_a[18];
  volatile uint32_t aulPad_ctrl_hif_d[16];
  volatile uint32_t  ulPad_ctrl_hif_bhen;
  volatile uint32_t  ulPad_ctrl_hif_csn;
  volatile uint32_t  ulPad_ctrl_hif_rdn;
  volatile uint32_t  ulPad_ctrl_hif_wrn;
  volatile uint32_t  ulPad_ctrl_hif_rdy;
  volatile uint32_t  ulPad_ctrl_hif_dirq;
  volatile uint32_t  ulPad_ctrl_hif_sdclk;
} NX90_PAD_CTRL_AREA_T;

typedef struct NX90_ASIC_CTRL_AREA_Ttag
{
  struct
  {
    volatile uint32_t  ulConfig;
    volatile uint32_t  ulMask;
  } asIo_config[9];
  volatile uint32_t aulReserved0[2];
  struct
  {
    volatile uint32_t  ulEnable;
    volatile uint32_t  ulMask;
  } asClock_enable[2];
  volatile uint32_t  ulReset_ctrl;
  volatile uint32_t  ulAhbl_master_ready;
  volatile uint32_t aulReserved1[3];
  volatile uint32_t  ulSystem_status;
  volatile uint32_t  ulSystime_feth_ctrl;
  volatile uint32_t aulReserved2[1];
  volatile uint32_t  ulSystime_gpio_app_ctrl;
  volatile uint32_t  ulOnly_porn;
  volatile uint32_t  ulOnly_porn_rom;
  volatile uint32_t  ulNetx_version;
  volatile uint32_t  ulNetx_status;
  volatile uint32_t  ulRdy_run_cfg;
  volatile uint32_t  ulFirewall_cfg_hifmem_sdram;
  volatile uint32_t  ulFirewall_cfg_hifmem_amem;
  volatile uint32_t  ulFirewall_cfg_sqirom;
  volatile uint32_t  ulFirewall_cfg_crypt;
  volatile uint32_t  ulMisc_asic_ctrl;
  volatile uint32_t aulReserved3[5];
  volatile uint32_t  ulAsic_ctrl_access_key;
  volatile uint32_t aulReserved4[1];
  volatile uint32_t  ulAsic_ctrl_irq_raw;
  volatile uint32_t  ulAsic_ctrl_irq_masked;
  volatile uint32_t  ulAsic_ctrl_irq_mask_set;
  volatile uint32_t  ulAsic_ctrl_irq_mask_reset;
} NX90_ASIC_CTRL_AREA_T;

typedef struct NX90_MMIO_CTRL_AREA_Ttag
{
  volatile uint32_t aulMmio_cfg[16];
  volatile uint32_t  ulMmio_pio_out_line_cfg0;
  volatile uint32_t  ulMmio_pio_out_line_set_cfg0;
  volatile uint32_t  ulMmio_pio_out_line_reset_cfg0;
  volatile uint32_t  ulMmio_pio_oe_line_cfg0;
  volatile uint32_t  ulMmio_pio_oe_line_set_cfg0;
  volatile uint32_t  ulMmio_pio_oe_line_reset_cfg0;
  volatile uint32_t  ulMmio_in_line_status0;
  volatile uint32_t  ulMmio_is_pio_status0;
} NX90_MMIO_CTRL_AREA_T;

typedef struct NX90_GLOBAL_BUF_MAN_AREA_Ttag
{
  volatile uint32_t aulGlobal_read_buffer_[8];
  volatile uint32_t aulGlobal_write_buffer_[8];
} NX90_GLOBAL_BUF_MAN_AREA_T;

typedef struct NX90_IFLASH_CFG_AREA_Ttag
{
  volatile uint32_t  ulBuffer_read_ahead_instructions;
  volatile uint32_t  ulBuffer_read_ahead_data;
  volatile uint32_t  ulIflash_signals_cfg;
  volatile uint32_t  ulIflash_mode_cfg;
  volatile uint32_t  ulIflash_access;
  volatile uint32_t  ulIflash_yadr;
  volatile uint32_t  ulIflash_xadr;
  volatile uint32_t aulIflash_din[5];
  volatile uint32_t  ulIflash_reset;
  volatile uint32_t aulIflash_red_cfg[2];
  volatile uint32_t  ulIflash_ifren_cfg;
  volatile uint32_t  ulIflash_din4_ecc;
  volatile uint32_t  ulIflash_special_cfg;
  volatile uint32_t  ulIflash_protection_info;
  volatile uint32_t  ulIflash_write_protection_main;
} NX90_IFLASH_CFG_AREA_T;

typedef struct NX90_HIF_IO_CTRL_AREA_Ttag
{
  volatile uint32_t  ulHif_io_cfg;
  volatile uint32_t  ulHif_pio_cfg;
  volatile uint32_t aulHif_pio_out[2];
  volatile uint32_t aulHif_pio_oe[2];
  volatile uint32_t aulHif_pio_in[2];
  volatile uint32_t aulReserved0[1];
  volatile uint32_t  ulHif_pio_irq_raw;
  volatile uint32_t  ulHif_pio_irq_arm_mask_set;
  volatile uint32_t  ulHif_pio_irq_arm_mask_reset;
  volatile uint32_t  ulHif_pio_irq_arm_masked;
  volatile uint32_t  ulHif_pio_irq_xpic_mask_set;
  volatile uint32_t  ulHif_pio_irq_xpic_mask_reset;
  volatile uint32_t  ulHif_pio_irq_xpic_masked;
} NX90_HIF_IO_CTRL_AREA_T;

typedef struct NX90_EXT_ASYNCMEM_CTRL_AREA_Ttag
{
  volatile uint32_t aulExtsram_ctrl[4];
  volatile uint32_t  ulExt_cs0_apm_ctrl;
  volatile uint32_t aulReserved0[3];
  volatile uint32_t  ulExt_rdy_cfg;
  volatile uint32_t  ulExt_rdy_status;
} NX90_EXT_ASYNCMEM_CTRL_AREA_T;

typedef struct NX90_EXT_SDRAM_CTRL_AREA_Ttag
{
  volatile uint32_t  ulSdram_general_ctrl;
  volatile uint32_t  ulSdram_timing_ctrl;
  volatile uint32_t  ulSdram_mr;
} NX90_EXT_SDRAM_CTRL_AREA_T;

typedef struct NX90_EXTMEM_PRIORITY_CTRL_AREA_Ttag
{
  volatile uint32_t  ulExtmem_prio_timslot_ctrl;
  volatile uint32_t  ulExtmem_prio_accesstime_ctrl;
} NX90_EXTMEM_PRIORITY_CTRL_AREA_T;

typedef struct NX90_ABORT_AREA_Ttag
{
  volatile uint32_t  ulAbort_base;
  volatile uint32_t aulReserved0[2];
  volatile uint32_t  ulAbort_end;
} NX90_ABORT_AREA_T;

typedef struct NX90_SQI_AREA_Ttag
{
  volatile uint32_t aulSqi_cr[2];
  volatile uint32_t  ulSqi_dr;
  volatile uint32_t  ulSqi_sr;
  volatile uint32_t  ulSqi_tcr;
  volatile uint32_t  ulSqi_irq_mask;
  volatile uint32_t  ulSqi_irq_raw;
  volatile uint32_t  ulSqi_irq_masked;
  volatile uint32_t  ulSqi_irq_clear;
  volatile uint32_t  ulSqi_dmacr;
  volatile uint32_t  ulSqi_pio_out;
  volatile uint32_t aulReserved0[1];
  volatile uint32_t  ulSqi_pio_oe;
  volatile uint32_t  ulSqi_pio_in;
  volatile uint32_t  ulSqi_sqirom_cfg;
} NX90_SQI_AREA_T;

typedef struct NX90_SAMPLE_AT_PORN_STAT_AREA_Ttag
{
  volatile uint32_t aulSample_at_porn_stat_in[2];
} NX90_SAMPLE_AT_PORN_STAT_AREA_T;

typedef struct NX90_ADC_SEQ_AREA_Ttag
{
  volatile uint32_t  ulAdc_seq_start;
  volatile uint32_t  ulAdc_seq_cfg;
  volatile uint32_t  ulAdc_seq_cfg_clock;
  volatile uint32_t  ulAdc_seq_status;
  volatile uint32_t aulAdc_seq_adc_data[2];
  volatile uint32_t  ulAdc_seq_debug;
  volatile uint32_t  ulAdc_seq_irq_raw;
  volatile uint32_t  ulAdc_seq_irq_masked;
  volatile uint32_t  ulAdc_seq_irq_mask_set;
  volatile uint32_t  ulAdc_seq_irq_mask_reset;
} NX90_ADC_SEQ_AREA_T;

typedef struct NX90_MIIMU_AREA_Ttag
{
  volatile uint32_t  ulMiimu;
  volatile uint32_t  ulMiimu_sw;
} NX90_MIIMU_AREA_T;

typedef struct NX90_ETH_AREA_Ttag
{
  volatile uint32_t  ulEth_config;
  volatile uint32_t  ulEth_tx_config;
  volatile uint32_t  ulEth_status;
  volatile uint32_t  ulEth_tx_data;
  volatile uint32_t  ulEth_rx_data;
  volatile uint32_t  ulEth_tx_len;
  volatile uint32_t  ulEth_rx_len_stat;
  volatile uint32_t aulReserved0[1];
  volatile uint32_t  ulEth_rx_systime_ns;
  volatile uint32_t  ulEth_tx_systime_ns;
  volatile uint32_t  ulEth_irq_raw;
  volatile uint32_t  ulEth_irq_masked;
  volatile uint32_t  ulEth_irq_msk_set;
  volatile uint32_t  ulEth_irq_msk_reset;
} NX90_ETH_AREA_T;

typedef struct NX90_DMAC_CH_AREA_Ttag
{
  volatile uint32_t  ulDmac_chsrc_ad;
  volatile uint32_t  ulDmac_chdest_ad;
  volatile uint32_t  ulDmac_chlink;
  volatile uint32_t  ulDmac_chctrl;
  volatile uint32_t  ulDmac_chcfg;
} NX90_DMAC_CH_AREA_T;

typedef struct NX90_DMAC_REG_AREA_Ttag
{
  volatile uint32_t  ulDmac_int_status;
  volatile uint32_t  ulDmac_inttc_status;
  volatile uint32_t  ulDmac_inttc_clear;
  volatile uint32_t  ulDmac_interr_status;
  volatile uint32_t  ulDmac_interr_clear;
  volatile uint32_t  ulDmac_rawinttc_status;
  volatile uint32_t  ulDmac_rawinterr_status;
  volatile uint32_t  ulDmac_enabled_channel;
  volatile uint32_t  ulDmac_softb_req;
  volatile uint32_t  ulDmac_softs_req;
  volatile uint32_t  ulDmac_softlb_req;
  volatile uint32_t  ulDmac_softls_req;
  volatile uint32_t  ulDmac_config;
  volatile uint32_t  ulDmac_sync;
} NX90_DMAC_REG_AREA_T;

typedef struct NX90_DMAC_MUX_AREA_Ttag
{
  volatile uint32_t aulDmac_mux_peripheral_input_sel[6];
} NX90_DMAC_MUX_AREA_T;

typedef struct NX90_UART_AREA_Ttag
{
  volatile uint32_t  ulUartdr;
  volatile uint32_t  ulUartrsr;
  volatile uint32_t  ulUartlcr_h;
  volatile uint32_t  ulUartlcr_m;
  volatile uint32_t  ulUartlcr_l;
  volatile uint32_t  ulUartcr;
  volatile uint32_t  ulUartfr;
  volatile uint32_t  ulUartiir;
  volatile uint32_t  ulUartilpr;
  volatile uint32_t  ulUartrts;
  volatile uint32_t  ulUartforerun;
  volatile uint32_t  ulUarttrail;
  volatile uint32_t  ulUartdrvout;
  volatile uint32_t  ulUartcr_2;
  volatile uint32_t  ulUartrxiflsel;
  volatile uint32_t  ulUarttxiflsel;
} NX90_UART_AREA_T;

typedef struct NX90_I2C_AREA_Ttag
{
  volatile uint32_t  ulI2c_mcr;
  volatile uint32_t  ulI2c_scr;
  volatile uint32_t  ulI2c_cmd;
  volatile uint32_t  ulI2c_mdr;
  volatile uint32_t  ulI2c_sdr;
  volatile uint32_t  ulI2c_mfifo_cr;
  volatile uint32_t  ulI2c_sfifo_cr;
  volatile uint32_t  ulI2c_sr;
  volatile uint32_t  ulI2c_irqmsk;
  volatile uint32_t  ulI2c_irqsr;
  volatile uint32_t  ulI2c_irqmsked;
  volatile uint32_t  ulI2c_dmacr;
  volatile uint32_t  ulI2c_pio;
} NX90_I2C_AREA_T;

typedef struct NX90_MLED_CTRL_APP_AREA_Ttag
{
  volatile uint32_t  ulMled_ctrl_app_cfg;
  volatile uint32_t aulMled_ctrl_app_output_sel[16];
  volatile uint32_t aulMled_ctrl_app_output_on_time[16];
  volatile uint32_t  ulMled_ctrl_app_line0;
} NX90_MLED_CTRL_APP_AREA_T;

typedef struct NX90_ECC_CTRL_AREA_Ttag
{
  volatile uint32_t aulEcc_ctrl_intram_ctrl[8];
  volatile uint32_t  ulEcc_ctrl_intramhs_ctrl;
  volatile uint32_t aulEcc_ctrl_xc0_rpec_pram_ctrl[2];
  volatile uint32_t aulEcc_ctrl_xc0_tpec_pram_ctrl[2];
  volatile uint32_t aulEcc_ctrl_xc0_dpram_ctrl[2];
  volatile uint32_t aulEcc_ctrl_xc0_rpu_ram_ctrl[2];
  volatile uint32_t aulEcc_ctrl_xc0_tpu_ram_ctrl[2];
  volatile uint32_t  ulEcc_ctrl_xc0_pfifo_ctrl;
  volatile uint32_t aulEcc_ctrl_xpic_pram_ctrl[2];
  volatile uint32_t aulEcc_ctrl_xpic_dram_ctrl[2];
  volatile uint32_t aulEcc_ctrl_iflash_ctrl[3];
  volatile uint32_t aulEcc_ctrl_intram_addr_sbe[8];
  volatile uint32_t  ulEcc_ctrl_intramhs_addr_sbe;
  volatile uint32_t aulEcc_ctrl_xc0_rpec_pram_addr_sbe[2];
  volatile uint32_t aulEcc_ctrl_xc0_tpec_pram_addr_sbe[2];
  volatile uint32_t aulEcc_ctrl_xc0_rpu_ram_addr_sbe[2];
  volatile uint32_t aulEcc_ctrl_xc0_tpu_ram_addr_sbe[2];
  volatile uint32_t aulEcc_ctrl_xpic_pram_addr_sbe[2];
  volatile uint32_t aulEcc_ctrl_xpic_dram_addr_sbe[2];
  volatile uint32_t aulEcc_ctrl_iflash_addr_sbe[3];
  volatile uint32_t aulEcc_ctrl_intram_addr_dbe[8];
  volatile uint32_t  ulEcc_ctrl_intramhs_addr_dbe;
  volatile uint32_t aulEcc_ctrl_xc0_rpec_pram_addr_dbe[2];
  volatile uint32_t aulEcc_ctrl_xc0_tpec_pram_addr_dbe[2];
  volatile uint32_t aulEcc_ctrl_xc0_rpu_ram_addr_dbe[2];
  volatile uint32_t aulEcc_ctrl_xc0_tpu_ram_addr_dbe[2];
  volatile uint32_t aulEcc_ctrl_xpic_pram_addr_dbe[2];
  volatile uint32_t aulEcc_ctrl_xpic_dram_addr_dbe[2];
  volatile uint32_t aulEcc_ctrl_iflash_addr_dbe[3];
  volatile uint32_t  ulEcc_ctrl_status_sbe;
  volatile uint32_t  ulEcc_ctrl_status_dbe;
} NX90_ECC_CTRL_AREA_T;

typedef struct NX90_GPIO_APP_AREA_Ttag
{
  volatile uint32_t aulGpio_app_cfg[8];
  volatile uint32_t aulGpio_app_tc[8];
  volatile uint32_t aulGpio_app_counter_ctrl[3];
  volatile uint32_t aulGpio_app_counter_max[3];
  volatile uint32_t aulGpio_app_counter_cnt[3];
  volatile uint32_t  ulGpio_app_line;
  volatile uint32_t  ulGpio_app_in;
  volatile uint32_t  ulGpio_app_irq_raw;
  volatile uint32_t  ulGpio_app_irq_masked;
  volatile uint32_t  ulGpio_app_irq_mask_set;
  volatile uint32_t  ulGpio_app_irq_mask_rst;
  volatile uint32_t  ulGpio_app_cnt_irq_raw;
  volatile uint32_t  ulGpio_app_cnt_irq_masked;
  volatile uint32_t  ulGpio_app_cnt_irq_mask_set;
  volatile uint32_t  ulGpio_app_cnt_irq_mask_rst;
} NX90_GPIO_APP_AREA_T;

typedef struct NX90_INTLOGIC_SYSTIME_LT_AREA_Ttag
{
  volatile uint32_t  ulIntlogic_lt_systime_com_ns;
  volatile uint32_t  ulIntlogic_lt_systime_com_s;
  volatile uint32_t  ulIntlogic_lt_systime_com_uc_ns;
  volatile uint32_t  ulIntlogic_lt_systime_com_uc_s;
  volatile uint32_t  ulIntlogic_lt_systime_app_ns;
  volatile uint32_t  ulIntlogic_lt_systime_app_s;
  volatile uint32_t  ulIntlogic_lt_systimes_latch;
} NX90_INTLOGIC_SYSTIME_LT_AREA_T;

typedef struct NX90_ARM_TIMER_AREA_Ttag
{
  volatile uint32_t aulTimer_config_timer[3];
  volatile uint32_t aulTimer_preload_timer[3];
  volatile uint32_t aulTimer_timer[3];
  volatile uint32_t  ulTimer_systime_s;
  volatile uint32_t  ulTimer_systime_ns;
  volatile uint32_t  ulTimer_compare_systime_s_value;
  volatile uint32_t  ulTimer_irq_raw;
  volatile uint32_t  ulTimer_irq_masked;
  volatile uint32_t  ulTimer_irq_msk_set;
  volatile uint32_t  ulTimer_irq_msk_reset;
  volatile uint32_t  ulTimer_systime_config;
} NX90_ARM_TIMER_AREA_T;

typedef struct NX90_SYSTIME_AREA_Ttag
{
  volatile uint32_t  ulSystime_s;
  volatile uint32_t  ulSystime_ns;
  volatile uint32_t  ulSystime_border;
  volatile uint32_t  ulSystime_count_value;
} NX90_SYSTIME_AREA_T;

typedef struct NX90_HS_IRQ_REG_AREA_Ttag
{
  volatile uint32_t  ulHs_irq_set_raw;
  volatile uint32_t  ulHs_irq_reset_raw;
  volatile uint32_t  ulHs_irq_set_mask;
  volatile uint32_t  ulHs_irq_reset_mask;
  volatile uint32_t  ulHs_irq_masked;
} NX90_HS_IRQ_REG_AREA_T;

typedef struct NX90_WATCHDOG_AREA_Ttag
{
  volatile uint32_t  ulNetx_sys_wdg_ctrl;
  volatile uint32_t  ulNetx_sys_wdg;
  volatile uint32_t  ulNetx_sys_wdg_irq_timeout;
  volatile uint32_t  ulNetx_sys_wdg_res_timeout;
  volatile uint32_t  ulNetx_sys_wdg_irq_raw;
  volatile uint32_t  ulNetx_sys_wdg_irq_masked;
  volatile uint32_t  ulNetx_sys_wdg_irq_msk_set;
  volatile uint32_t  ulNetx_sys_wdg_irq_msk_reset;
} NX90_WATCHDOG_AREA_T;

typedef struct NX90_TRIGGER_IRQ_AREA_Ttag
{
  volatile uint32_t  ulTrigger_irq_cfg;
  volatile uint32_t  ulTrigger_irq_raw;
  volatile uint32_t  ulTrigger_irq_masked;
  volatile uint32_t  ulTrigger_irq_msk_set;
  volatile uint32_t  ulTrigger_irq_msk_reset;
} NX90_TRIGGER_IRQ_AREA_T;

typedef struct NX90_ENDAT_AREA_Ttag
{
  volatile uint32_t  ulEndat_send;
  volatile uint32_t aulEndat_receive1_[2];
  volatile uint32_t  ulEndat_receive2;
  volatile uint32_t  ulEndat_receive3;
  volatile uint32_t  ulEndat_conf1;
  volatile uint32_t  ulEndat_conf2;
  volatile uint32_t  ulEndat_conf3;
  volatile uint32_t  ulEndat_stat;
  volatile uint32_t  ulEndat_int;
  volatile uint32_t  ulEndat_test1;
  volatile uint32_t  ulEndat_test2;
  volatile uint32_t aulEndat_receive4_[2];
  volatile uint32_t  ulEndat_sw_strobe;
  volatile uint32_t  ulEndat_id;
} NX90_ENDAT_AREA_T;

typedef struct NX90_ENDAT_CTRL_AREA_Ttag
{
  volatile uint32_t  ulEndat_ctrl_trigger_cfg;
  volatile uint32_t  ulEndat_ctrl_trigger;
  volatile uint32_t  ulEndat_ctrl_strobe_cfg;
} NX90_ENDAT_CTRL_AREA_T;

typedef struct NX90_CANCTRL_AREA_Ttag
{
  volatile uint32_t  ulCanctrl_mode;
  volatile uint32_t  ulCanctrl_command;
  volatile uint32_t  ulCanctrl_status;
  volatile uint32_t  ulCanctrl_irq;
  volatile uint32_t  ulCanctrl_irq_en;
  volatile uint32_t  ulCanctrl_not_extended_acceptance_mask0;
  volatile uint32_t aulCanctrl_bus_timing[2];
  volatile uint32_t aulReserved0[2];
  volatile uint32_t  ulCanctrl_not_extended_data0;
  volatile uint32_t  ulCanctrl_arb_lost_capture;
  volatile uint32_t  ulCanctrl_err_code_capture;
  volatile uint32_t  ulCanctrl_err_warning_limit;
  volatile uint32_t  ulCanctrl_rx_error_cnt;
  volatile uint32_t  ulCanctrl_tx_error_cnt;
  volatile uint32_t aulCanctrl_data[13];
  volatile uint32_t  ulCanctrl_rx_message_cnt;
  volatile uint32_t aulReserved1[1];
  volatile uint32_t  ulCanctrl_mode_control;
} NX90_CANCTRL_AREA_T;

typedef struct NX90_SPI_AREA_Ttag
{
  volatile uint32_t aulSpi_cr[2];
  volatile uint32_t  ulSpi_dr;
  volatile uint32_t  ulSpi_sr;
  volatile uint32_t aulReserved0[1];
  volatile uint32_t  ulSpi_imsc;
  volatile uint32_t  ulSpi_ris;
  volatile uint32_t  ulSpi_mis;
  volatile uint32_t  ulSpi_icr;
  volatile uint32_t aulReserved1[1];
  volatile uint32_t  ulSpi_dmacr;
  volatile uint32_t aulReserved2[1];
  volatile uint32_t  ulSpi_data_register;
  volatile uint32_t  ulSpi_status_register;
  volatile uint32_t  ulSpi_control_register;
  volatile uint32_t  ulSpi_interrupt_control_register;
} NX90_SPI_AREA_T;

typedef struct NX90_PIO_AREA_Ttag
{
  volatile uint32_t  ulPio_in;
  volatile uint32_t  ulPio_out;
  volatile uint32_t  ulPio_oe;
} NX90_PIO_AREA_T;

typedef struct NX90_BISS_AREA_Ttag
{
  volatile uint32_t aulBiss_scdata0_[2];
  volatile uint32_t aulBiss_scdata1_[2];
  volatile uint32_t aulBiss_scdata2_[2];
  volatile uint32_t aulBiss_scdata3_[2];
  volatile uint32_t aulBiss_scdata4_[2];
  volatile uint32_t aulBiss_scdata5_[2];
  volatile uint32_t aulBiss_scdata6_[2];
  volatile uint32_t aulBiss_scdata7_[2];
  volatile uint32_t aulReserved0[16];
  volatile uint32_t aulBiss_rdata[16];
  volatile uint32_t aulBiss_sc[8];
  volatile uint32_t  ulBiss_ccc0;
  volatile uint32_t  ulBiss_ccc1_mc0;
  volatile uint32_t  ulBiss_mc1;
  volatile uint32_t  ulBiss_cc_sl;
  volatile uint32_t  ulBiss_status0;
  volatile uint32_t  ulBiss_ir;
  volatile uint32_t  ulBiss_status1;
} NX90_BISS_AREA_T;

typedef struct NX90_BISS_CTRL_AREA_Ttag
{
  volatile uint32_t  ulBiss_ctrl_trigger_cfg;
  volatile uint32_t  ulBiss_ctrl_trigger;
  volatile uint32_t  ulBiss_ctrl_irq_raw;
  volatile uint32_t  ulBiss_ctrl_irq_masked;
  volatile uint32_t  ulBiss_ctrl_irq_msk_set;
  volatile uint32_t  ulBiss_ctrl_irq_msk_reset;
} NX90_BISS_CTRL_AREA_T;

typedef struct NX90_XPIC_AREA_Ttag
{
  volatile uint32_t aulXpic_r[8];
  volatile uint32_t aulXpic_usr[5];
  volatile uint32_t  ulXpic_pc;
  volatile uint32_t  ulXpic_stat;
  volatile uint32_t  ulXpic_zero;
} NX90_XPIC_AREA_T;

typedef struct NX90_XPIC_DEBUG_AREA_Ttag
{
  volatile uint32_t  ulXpic_hold_pc;
  struct
  {
    volatile uint32_t  ulAddr;
    volatile uint32_t  ulAddr_mask;
    volatile uint32_t  ulData;
    volatile uint32_t  ulData_mask;
    volatile uint32_t  ulContr;
    volatile uint32_t  ulContr_mask;
  } asXpic_break[2];
  volatile uint32_t  ulXpic_break_last_pc;
  volatile uint32_t  ulXpic_break_status;
  volatile uint32_t  ulXpic_break_irq_raw;
  volatile uint32_t  ulXpic_break_irq_masked;
  volatile uint32_t  ulXpic_break_irq_msk_set;
  volatile uint32_t  ulXpic_break_irq_msk_reset;
  volatile uint32_t  ulXpic_break_own_irq_masked;
  volatile uint32_t  ulXpic_break_own_irq_msk_set;
  volatile uint32_t  ulXpic_break_own_irq_msk_reset;
  volatile uint32_t  ulXpic_break_return_fiq_pc;
  volatile uint32_t  ulXpic_break_return_irq_pc;
  volatile uint32_t  ulXpic_irq_status;
} NX90_XPIC_DEBUG_AREA_T;

typedef struct NX90_XPIC_VIC_AREA_Ttag
{
  volatile uint32_t  ulXpic_vic_config;
  volatile uint32_t aulXpic_vic_raw_intr[3];
  volatile uint32_t aulXpic_vic_softint_set[3];
  volatile uint32_t aulXpic_vic_softint_reset[3];
  volatile uint32_t  ulXpic_vic_fiq_addr;
  volatile uint32_t  ulXpic_vic_irq_addr;
  volatile uint32_t  ulXpic_vic_vector_addr;
  volatile uint32_t  ulXpic_vic_table_base_addr;
  volatile uint32_t  ulXpic_vic_fiq_vect_config;
  volatile uint32_t aulXpic_vic_vect_config[16];
  volatile uint32_t aulXpic_vic_default[3];
  volatile uint32_t aulXpic_vic_fiq_default[3];
} NX90_XPIC_VIC_AREA_T;

typedef struct NX90_XPIC_WDG_AREA_Ttag
{
  volatile uint32_t  ulXpic_wdg_trig;
  volatile uint32_t  ulXpic_wdg_counter;
  volatile uint32_t  ulXpic_wdg_xpic_irq_timeout;
  volatile uint32_t  ulXpic_wdg_arm_irq_timeout;
  volatile uint32_t  ulXpic_wdg_irq_raw;
  volatile uint32_t  ulXpic_wdg_irq_masked;
  volatile uint32_t  ulXpic_wdg_irq_msk_set;
  volatile uint32_t  ulXpic_wdg_irq_msk_reset;
} NX90_XPIC_WDG_AREA_T;

typedef struct NX90_XLINK_AREA_Ttag
{
  volatile uint32_t  ulXlink_cfg;
  volatile uint32_t  ulXlink_tx;
  volatile uint32_t  ulXlink_rx;
  volatile uint32_t  ulXlink_stat;
} NX90_XLINK_AREA_T;

typedef struct NX90_IO_LINK_IRQ_AREA_Ttag
{
  volatile uint32_t  ulIo_link_irq_raw;
  volatile uint32_t  ulIo_link_irq_masked;
  volatile uint32_t  ulIo_link_irq_msk_set;
  volatile uint32_t  ulIo_link_irq_msk_reset;
} NX90_IO_LINK_IRQ_AREA_T;


#endif
